<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO_8859-1/books/developers-handbook/book.sgml,v 1.3 2000/10/06 15:36:45 phantom Exp $
-->

<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V3.1-Based Extension//EN" [
<!ENTITY % bookinfo PUBLIC "-//FreeBSD//ENTITIES DocBook BookInfo Entities//EN">
%bookinfo;
]>

<book>
  <bookinfo>
    <title>FreeBSD Developers' Handbook</title>
    
    <authorgroup>
      <author>
	<surname>The FreeBSD Documentation Project</surname>
        <affiliation>
          <address>
            <email>doc@FreeBSD.org</email>
          </address>
        </affiliation>
      </author>
    </authorgroup>
    
    <pubdate>August 2000</pubdate>
    
    <copyright>
      <year>2000</year>
      <holder>The FreeBSD Documentation Project</holder>
    </copyright>

    &bookinfo.legalnotice;
    
    <abstract>
      <para>Welcome to the Developers' Handbook.</para>
    </abstract>
  </bookinfo>
  
  <part id="introduction">
    <title>Introduction</title>

    <chapter id="developmentplatform">
      <title>Developing on FreeBSD</title>

      <para>This will need to discuss FreeBSD as a development
        platform, the vision of BSD, architectural overview, layout of
        /usr/src, history, etc.</para>

      <para>Thank you for considering FreeBSD as your development
        platform!  We hope it will not let you down.</para>
    </chapter>

    <chapter id="bsdvision">
      <title>The BSD Vision</title>

      <para></para>
    </chapter>

    <chapter id="archoverview">
      <title>Architectural Overview</title>

      <para></para>
    </chapter>

    <chapter id="sourcelayout">
      <title>The Layout of /usr/src</title>

      <para>The complete source code to FreeBSD is available from our
      public CVS repository.  The source code is normally installed in
      <filename class=directory>/usr/src</filename> which contains the
      following subdirectories.</para>

      <para>
      <informaltable frame="none">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Directory</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  
	  <tbody>
	    <row>
	    <entry><filename class=directory>bin/</filename></entry>
            <entry>Source for files in
            <filename>/bin</filename></entry>
	    </row>
	    
	    <row>
	    <entry><filename class=directory>contrib/</filename></entry>
	    <entry>Source for files from contribued software.</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>crypto/</filename></entry>
	    <entry>DES source</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>etc/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/etc</filename></entry>
	    </row>

	    <row>
	    <entry><filename class=directory>games/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/usr/games</filename></entry>
	    </row>

	    <row>
	    <entry><filename class=directory>gnu/</filename></entry>
	    <entry>Utilities covered by the GNU Public License</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>include/</filename></entry>
            <entry>Source for files in <filename
            class=directory>/usr/include</filename></entry>
	    </row>

	    <row>
	    <entry><filename
 class=directory>kerberosIV/</filename></entry>
            <entry>Source for Kerbereros version IV</entry>
	    </row>

	    <row>
	    <entry><filename
 class=directory>kerberos5/</filename></entry>
            <entry>Source for Kerbereros version 5</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>lib/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/usr/lib</filename></entry>
	    </row>
	    
	    <row>
	    <entry><filename class=directory>libexec/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/usr/libexec</filename></entry>
	    </row>
	    
	    <row>
	    <entry><filename
 class=directory>release/</filename></entry>
            <entry>Files required to produce a FreeBSD release</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>sbin/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/sbin</filename></entry>
	    </row>

	    <row>
	    <entry><filename class=directory>secure/</filename></entry>
	    <entry>FreeSec sources</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>share/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/sbin</filename></entry>
	    </row>

	    <row>
	    <entry><filename class=directory>sys/</filename></entry>
	    <entry>Kernel source files</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>tools/</filename></entry>
	    <entry>Tools used for maintenance and testing of
	    FreeBSD</entry>
	    </row>

	    <row>
	    <entry><filename
 class=directory>usr.bin/</filename></entry>
            <entry>Source for files in <filename
 class=directory>/usr/bin</filename></entry>
            </row>

	    <row>
	    <entry><filename
 class=directory>usr.sbin/</filename></entry>
            <entry>Source for files in <filename
 class=directory>/usr/sbin</filename></entry>
            </row>
          </tbody>
	</tgroup>
      </informaltable>

      </para>

    </chapter>
  </part>

  <part id="Basics">
    <title>Basics</title>

    <chapter id="compilation">
      <title>Compilation</title>

      <para>This will include things like: compilation, makefiles, .mk
        files, basic debugging, linking, secure programming
        guidelines, style(9), CVS, diff, patch, etc.</para>

      <para></para>
    </chapter>
  </part>

  <part id="kernel">
    <title>Kernel</title>

    <chapter id="kernelhistory">
      <title>History of the Unix Kernel</title>

      <para>Some history of the Unix/BSD kernel, system calls, how do
        processes work, blocking, scheduling, threads (kernel),
        context switching, signals, interrupts, modules, etc.</para>

      <para></para>
    </chapter>
  </part>

  <part id="memory">
    <title>Memory and Virtual Memory</title>

    <chapter id="virtualmemory">
      <title>Virtual Memory</title>

      <para>VM, paging, swapping, allocating memory, testing for
        memory leaks, mmap, vnodes, etc.</para>

      <para></para>
    </chapter>
  </part>

  <part id="iosystem">
    <title>I/O System</title>

    <chapter id="ufs">
      <title>UFS</title>

      <para>UFS, FFS, Ext2FS, JFS, inodes, buffer cache, labeling,
        locking, metadata, soft-updates, LFS, portalfs, procfs,
        vnodes, memory sharing, memory objects, TLBs, caching</para>

    </chapter>
  </part>

  <part id="ipc">
    <title>Interprocess Communication</title>
    
    <chapter id="signals">
      <title>Signals</title>

      <para>Signals, pipes, semaphores, message queues, shared memory,
        ports, sockets, doors</para>

    </chapter>
  </part>

  <part id="networking">
    <title>Networking</title>
    
    <chapter id="sockets">
      <title>Sockets</title>

      <para>Sockets, bpf, IP, TCP, UDP, ICMP, OSI, bridging,
        firewalling, NAT, switching, etc</para>

    </chapter>
  </part>
  
  <part id="networkfs">
    <title>Network Filesystems</title>

    <chapter id="afs">
      <title>AFS</title>

      <para>AFS, NFS, SANs etc]</para>

    </chapter>
  </part>
  
  <part id="terminal">
    <title>Terminal Handling</title>

    <chapter id="syscons">
      <title>Syscons</title>

      <para>Syscons, tty, PCVT, serial console, screen savers,
        etc</para>

    </chapter>
  </part>
  
  <part id="sound">
    <title>Sound</title>

    <chapter id="oss">
      <title>OSS</title>

      <para>OSS, waveforms, etc</para>

    </chapter>
  </part>
  
  <part id="devicedrivers">
    <title>Device Drivers</title>

    <chapter id="driverbasics">
      <title>Writing FreeBSD Device Drivers</title>

      <para>This chapter was written by Murray Stokely with selections from
      a variety of sources including the intro(4) man page by Joerg
      Wunsch.</para>

      <sect1>
        <title>Introduction</title>
	<para>
	This chapter provides a brief introduction to writing device
	drivers for FreeBSD.  A device in this context is a term used
	mostly for hardware-related stuff that belongs to the system,
	like disks, printers, or a graphics display with its keyboard.
	A device driver is the software component of the operating
	system that controls a specific device.  There are also
	so-called pseudo-devices where a device driver emulates the
	behaviour of a device in software without any particular
	underlying hardware.  Device drivers can be compiled into the
	system statically or loaded on demand through the dynamic
	kernel linker facility `kld'.</para>

	<para>Most devices in a Unix-like operating system are
	accessed through device-nodes, sometimes also called special
	files.  These files are usually located under the directory
	<filename>/dev</filename> in the file system hierarchy.  Until
	devfs is fully integrated into FreeBSD, each device node must
	be created statically and independent of the existence of the
	associated device driver.  Most device nodes on the system are
	created by running <command>MAKEDEV</command>.</para>

	<para>Device drivers can roughly be broken down into three
	categories; character (unbuffered), block (buffered), and
	network drivers.</para>
      </sect1>

      <sect1>
        <title>Dynamic Kernel Linker Facility - KLD</title>
	<para>The kld interface allows system administrators to
	dynamically add and remove functionality from a running
	system.  This allows device driver writers to load their new
	changes into a running kernel without constantly rebooting to
	test changes.</para>

	<para>The kld interface is used through the following
	administrator commands : 
	<itemizedlist>
	<listitem><simpara><command>kldload</command> - loads a new kernel
	module</simpara></listitem>
	<listitem><simpara><command>kldunload</command> - unloads a kernel
	module</simpara></listitem>
	<listitem><simpara><command>kldstat</command> - lists the currently loadded
	modules</simpara></listitem>
	</itemizedlist>
	</para>

	<para>Skeleton Layout of a kernel module</para>
<programlisting>
/*
 * KLD Skeleton
 * Inspired by Andrew Reiter's Daemonnews article
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt;  /* uprintf */ 
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/kernel.h&gt; /* types used in module initialization */

/* 
 * Load handler that deals with the loading and unloading of a KLD.
 */

static int
skel_loader(struct module *m, int what, void *arg)
{
  int err = 0;
  
  switch (what) {
  case MOD_LOAD:                /* kldload */
    uprintf("Skeleton KLD loaded.\n");
    break;
  case MOD_UNLOAD:
    uprintf("Skeleton KLD unloaded.\n");
    break;
  default:
    err = EINVAL;
    break;
  }
  return(err);
}

/* Declare this module to the rest of the kernel */

DECLARE_MODULE(skeleton, skel_loader, SI_SUB_KLD, SI_ORDER_ANY);
</programlisting>


	<sect2>
	  <title>Makefile</title>
	  <para>FreeBSD provides a makefile include that you can use
	  to quickly compile your kernel addition.</para>
	  <programlisting>
SRCS=skeleton.c
KMOD=skeleton

.include &lt;bsd.kmod.mk&gt;
</programlisting>


	  <para>Simply running <command>make</command> with
	  this makefile will create a file
	  <filename>skeleton.ko</filename> that can be loaded into
	  your system by typing : 
<screen>  
&prompt.root kldload -v ./skeleton.ko
</screen>
          </para>
         </sect2>
      </sect1>

      <sect1>
        <title>Accessing a device driver</title>
	<para>Unix provides a common set of system calls for user
	applications to use.  The upper layers of the kernel dispatch
	these calls to the corresponding device driver when a user
	accesses a device node.  The <command>/dev/MAKEDEV</command>
	script makes most of the device nodes for your system but if
	you are doing your own driver development it may be necessary
	to create your own device nodes with <command>mknod</command>
	</para>

	<sect2>
	<title>Creating static device nodes</title>
	<para>The <command>mknod</command> command requires four
	arguments to create a device node.  You must specify the
	name of this device node, the type of device, the major number
	of the device, and the minor number of the device.</para>
	</sect2>

	<sect2>
	<title>Dynamic device nodes</title>
	<para>The device filesystem, or devfs, provides access to the
	kernel's device namespace in the global filesystem namespace.
	This eliminates the problems of potentially having a device
	driver without a static device node, or a device node without
	an installed device driver.  Unfortunately, devfs is still a
	work in progress.</para>
	</sect2>

      </sect1>

      <sect1>
        <title>Character Devices</title>
	<para>A character device driver is one that transfers data
	directly to and from a user process.  This is the most common
	type of device driver and there are plenty of simple examples
	in the source tree.</para>
	<para>This simple example pseudo-device remembers whatever values you write
	to it and can then supply them back to you when you read from
	it.</para>
<programlisting>
/*
 * Simple `echo' pseudo-device KLD
 *
 * Murray Stokely
 */

#define MIN(a,b) (((a) < (b)) ? (a) : (b))

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt; /* uprintf */ 
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/kernel.h&gt; /* types used in module initialization */
#include &lt;sys/conf.h&gt;   /* cdevsw struct */
#include &lt;sys/uio.h&gt;    /* uio struct */
#include &lt;sys/malloc.h&gt;

#define BUFFERSIZE 256

/* Function prototypes */
d_open_t      echo_open;
d_close_t     echo_close;
d_read_t      echo_read;
d_write_t     echo_write;

/* Character device entry points */
static struct cdevsw echo_cdevsw = {
  echo_open,
  echo_close,
  echo_read,
  echo_write,
  noioctl,
  nopoll,
  nommap,
  nostrategy,
  "echo",
  33,                   /* reserved for lkms - /usr/src/sys/conf/majors */
  nodump,
  nopsize,
  D_TTY,
  -1
};

typedef struct s_echo {
  char msg[BUFFERSIZE];
  int len;
} t_echo;

/* vars */
static dev_t sdev;
static int len;
static int count;
static t_echo *echomsg;

MALLOC_DECLARE(M_ECHOBUF);
MALLOC_DEFINE(M_ECHOBUF, "echobuffer", "buffer for echo module");

/*
 * This function acts is called by the kld[un]load(2) system calls to
 * determine what actions to take when a module is loaded or unloaded.
 */
      
static int
echo_loader(struct module *m, int what, void *arg)
{
  int err = 0;
  
  switch (what) {
  case MOD_LOAD:                /* kldload */
    sdev = make_dev(<literal>&</literal>echo_cdevsw,
		    0,
		    UID_ROOT,
		    GID_WHEEL,
		    0600,
		    "echo");
    /* kmalloc memory for use by this driver */
    /*    malloc(256,M_ECHOBUF,M_WAITOK); */
    MALLOC(echomsg, t_echo *, sizeof(t_echo), M_ECHOBUF, M_WAITOK);
    printf("Echo device loaded.\n");
    break;
  case MOD_UNLOAD:
    destroy_dev(sdev);
    FREE(echomsg,M_ECHOBUF);
    printf("Echo device unloaded.\n");
    break;
  default:
    err = EINVAL;
    break;
  }
  return(err);
}

int 
echo_open(dev_t dev, int oflags, int devtype, struct proc *p)
{
  int err = 0;
  
  uprintf("Opened device \"echo\" successfully.\n");
  return(err);
}

int 
echo_close(dev_t dev, int fflag, int devtype, struct proc *p)
{
  uprintf("Closing device \"echo.\"\n"); 
  return(0);
} 

/* 
 * The read function just takes the buf that was saved via
 * echo_write() and returns it to userland for accessing.
 * uio(9) 
 */

int
echo_read(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;
  int amt;

  /* How big is this read operation?  Either as big as the user wants,
     or as big as the remaining data */
  amt = MIN(uio->uio_resid, (echomsg->len - uio->uio_offset > 0) ? echomsg->len - uio->uio_offset : 0);
  if ((err = uiomove(echomsg->msg + uio->uio_offset,amt,uio)) != 0) {
    uprintf("uiomove failed!\n");
  }

  return err;
}

/*
 * echo_write takes in a character string and saves it
 * to buf for later accessing.
 */

int
echo_write(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;

  /* Copy the string in from user memory to kernel memory */
  err = copyin(uio->uio_iov->iov_base, echomsg->msg, MIN(uio->uio_iov->iov_len,BUFFERSIZE));

  /* Now we need to null terminate */
  *(echomsg->msg + MIN(uio->uio_iov->iov_len,BUFFERSIZE)) = 0;
  /* Record the length */
  echomsg->len = MIN(uio->uio_iov->iov_len,BUFFERSIZE);

  if (err != 0) {
    uprintf("Write failed: bad address!\n");
  }

  count++;
  return(err);
}

DEV_MODULE(echo,echo_loader,NULL);
</programlisting>

<para>To install this driver you will first need to make a node on
	your filesystem with a command such as : </para> 
<screen>
	&prompt.root mknod /dev/echo c 33 0
</screen>
<para>With this driver loaded you should now be able to type something
	like :</para>
<screen>
        &prompt.root echo -n "Test Data" > /dev/echo
        &prompt.root cat /dev/echo
	Test Data
</screen>
	<para>Real hardware devices in the next chapter..</para>

	<para>Additional Resources
	<itemizedlist>
	<listitem><simpara><ulink
	url="http://www.daemonnews.org/200010/blueprints.html">Dynamic
	Kernel Linker (KLD) Facility Programming Tutorial</ulink> -
	<ulink url="http://www.daemonnews.org">Daemonnews</ulink> October 2000</simpara></listitem>
	<listitem><simpara><ulink
	url="http://www.daemonnews.org/200007/newbus-intro.html">How
	to Write Kernel Drivers with NEWBUS</ulink> - <ulink
	url="http://www.daemonnews.org">Daemonnews</ulink> July
	2000</simpara></listitem>
	</itemizedlist>
	</para>
      </sect1>

      <sect1>
        <title>Block Devices</title>
	<para>A block device driver transfers data to and from the
	operating system's buffer cache.  They are solely intended to
	layer a file system on top of them.  For this reason they are
	normally implemented for disks and disk-like devices only.</para>

	<para>Example test data generator ... </para>

	<para>Example ramdisk device ... </para>

	<para>Real hardware devices in the next chapter..</para>
      </sect1>

      <sect1>
        <title>Network Drivers</title>
	<para>Drivers for network devices do not use device nodes in
	ord to be accessed.  Their selection is based on other
	decisions made inside the kernel and instead of calling
	open(), use of a network device is generally introduced by
	using the system call socket(2).</para>
	<para>man ifnet(), loopback device, Bill Pauls drivers, etc..</para>
      </sect1>

    </chapter>

    <chapter id="pci">
      <title>PCI Devices</title>

      <para>This chapter will talk about the FreeBSD mechanisms for
      writing a device driver for a device on a PCI bus.</para>

      <sect1><title>Probe and Attach</title>

      <para>Information here about how the PCI bus code iterates
      through the unattached devices and see if a newly loaded kld
      will attach to any of them.</para>
<programlisting>
/*
 * Simple KLD to play with the PCI functions.
 *
 * Murray Stokely
 */

#define MIN(a,b) (((a) < (b)) ? (a) : (b))

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt;  /* uprintf */ 
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/kernel.h&gt; /* types used in module initialization */
#include &lt;sys/conf.h&gt;   /* cdevsw struct */
#include &lt;sys/uio.h&gt;    /* uio struct */
#include &lt;sys/malloc.h&gt;
#include &lt;sys/bus.h&gt;	/* structs, prototypes for pci bus stuff */

#include &lt;pci/pcivar.h&gt; /* For get_pci macros! */

/* Function prototypes */
d_open_t      mypci_open;
d_close_t     mypci_close;
d_read_t      mypci_read;
d_write_t     mypci_write;

/* Character device entry points */

static struct cdevsw mypci_cdevsw = {
  mypci_open,
  mypci_close,
  mypci_read,
  mypci_write,
  noioctl,
  nopoll,
  nommap,
  nostrategy,
  "mypci",
  36,                   /* reserved for lkms - /usr/src/sys/conf/majors */
  nodump,
  nopsize,
  D_TTY,
  -1
};

/* vars */
static dev_t sdev;

/* We're more interested in probe/attach than with
   open/close/read/write at this point */

int 
mypci_open(dev_t dev, int oflags, int devtype, struct proc *p)
{
  int err = 0;

  uprintf("Opened device \"mypci\" successfully.\n");
  return(err);
}

int 
mypci_close(dev_t dev, int fflag, int devtype, struct proc *p)
{
  int err=0;

  uprintf("Closing device \"mypci.\"\n"); 
  return(err);
} 

int
mypci_read(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;

  uprintf("mypci read!\n");
  return err;
}

int
mypci_write(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;

  uprintf("mypci write!\n");
  return(err);
}

/* PCI Support Functions */

/*
 * Return identification string if this is device is ours.
 */
static int
mypci_probe(device_t dev)
{
  uprintf("MyPCI Probe\n"
	  "Vendor ID : 0x%x\n"
	  "Device ID : 0x%x\n",pci_get_vendor(dev),pci_get_device(dev));

  if (pci_get_vendor(dev) == 0x11c1) {
    uprintf("We've got the Winmodem, probe successful!\n");
    return 0;
  }

  return ENXIO;
}

/* Attach function is only called if the probe is successful */

static int
mypci_attach(device_t dev)
{
  uprintf("MyPCI Attach for : deviceID : 0x%x\n",pci_get_vendor(dev));
  sdev = make_dev(<literal>&</literal>mypci_cdevsw,
		  0,
		  UID_ROOT,
		  GID_WHEEL,
		  0600,
		  "mypci");
  uprintf("Mypci device loaded.\n");
  return ENXIO;
}

/* Detach device. */

static int
mypci_detach(device_t dev)
{
  uprintf("Mypci detach!\n");
  return 0;
}

/* Called during system shutdown after sync. */

static int
mypci_shutdown(device_t dev)
{
  uprintf("Mypci shutdown!\n");
  return 0;
}

/*
 * Device suspend routine.  
 */
static int
mypci_suspend(device_t dev)
{
  uprintf("Mypci suspend!\n");
  return 0;
}

/*
 * Device resume routine.
 */

static int
mypci_resume(device_t dev)
{
  uprintf("Mypci resume!\n");
  return 0;
}

static device_method_t mypci_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		mypci_probe),
	DEVMETHOD(device_attach,	mypci_attach),
	DEVMETHOD(device_detach,	mypci_detach),
	DEVMETHOD(device_shutdown,	mypci_shutdown),
	DEVMETHOD(device_suspend,	mypci_suspend),
	DEVMETHOD(device_resume,	mypci_resume),

	{ 0, 0 }
};

static driver_t mypci_driver = {
	"mypci",
	mypci_methods,
	0,
	/*	sizeof(struct mypci_softc), */
};

static devclass_t mypci_devclass;

DRIVER_MODULE(mypci, pci, mypci_driver, mypci_devclass, 0, 0);
</programlisting>
      
        <para>Additional Resources
	<itemizedlist>
	<listitem><simpara><ulink
	url="http://www.pcisig.org">PCI Special Interest
	Group</ulink></simpara></listitem>
	<listitem><simpara>PCI System Architecture, Fourth Edition by
	Tom Shanley, et al.</simpara></listitem>
	</itemizedlist>
	</para>
      </sect1>
    </chapter>

    <chapter id="usb">
      <title>USB Devices</title>

      <para>This chapter will talk about the FreeBSD mechanisms for
      writing a device driver for a device on a USB bus.</para>
    </chapter>

    <chapter id="newbus">
      <title>NewBus</title>

      <para>This chapter will talk about the FreeBSD NewBus
      architecture.</para>
    </chapter>

  </part>
  
  <part id="architectures">
    <title>Architectures</title>

    <chapter id="ia32">
      <title>IA-32</title>

      <para>Talk about the architectural specifics of FreeBSD/x86.</para>

    </chapter>

    <chapter id="alpha">
      <title>Alpha</title>

      <para>Talk about the architectural specifics of
      FreeBSD/alpha.</para>

      <para>Explanation of allignment errors, how to fix, how to
      ignore.</para>

      <para>Example assembly language code for FreeBSD/alpha.</para>
    </chapter>

    <chapter id="ia64">
      <title>IA-64</title>

      <para>Talk about the architectural specifics of
      FreeBSD/ia64.</para>

    </chapter>
  </part>
  
  <part id="debugging">
    <title>Debugging</title>

    <chapter id="truss">
      <title>Truss</title>

      <para>various descriptions on how to debug certain aspects of
        the system using truss, ktrace, gdb, kgdb, etc</para>

    </chapter>
  </part>
  
  <part id="compatibility">
    <title>Compatibility Layers</title>

    <chapter id="linux">
      <title>Linux</title>

      <para>Linux, SVR4, etc</para>

    </chapter>
  </part>
  
</book>
