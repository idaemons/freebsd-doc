<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO_8859-1/books/handbook/disks/chapter.sgml,v 1.21 2000/06/16 18:17:47 jim Exp $
-->

<chapter id="disks">
  <title>Disks</title>

  <sect1 id="disks-synopsis">
    <title>Synopsis</title>

    <para>This chapter covers how to use disks, whether physical,
      memory, or networked, on FreeBSD.</para>
  </sect1>

  <sect1 id="disks-bios-numbering">
    <title>BIOS Drive Numbering</title>

    <para>Before you install and configure FreeBSD on your system, there is an
      important subject that you should be aware of if, especially if you have
      multiple hard drives.</para>    

    <para>In a PC running DOS or any of the BIOS-dependent operating systems
      (WINxxx), the BIOS is able to abstract the normal disk drive order, and
      the operating system goes along with the change.  This allows the user
      to boot from a disk drive other than the so-called <quote>primary
	master</quote>.  This is especially convenient for some users who have
      found that the simplest and cheapest way to keep a system backup is to
      buy an identical second hard drive, and perform routine copies of the
      first drive to the second drive using Ghost or XCOPY.  Then, if the
      first drive fails, or is attacked by a virus, or is scribbled upon by an
      operating system defect, he can easily recover by instructing the BIOS
      to logically swap the drives. It's like switching the cables on the
      drives, but without having to open the case.</para>

    <para>More expensive systems with SCSI controllers often include BIOS
      extensions which allow the SCSI drives to be re-ordered in a similar
      fashion for up to seven drives.</para>

    <para>A user who is accustomed to taking advantage of these features may
      become surprised when the results with FreeBSD are not as expected.
      FreeBSD does not use the BIOS, and does not know the <quote>logical BIOS
	drive mapping</quote>.  This can lead to very perplexing situations,
      especially when drives are physically identical in geometry, and have
      also been made as data clones of one another.</para>

    <para>When using FreeBSD, always restore the BIOS to natural drive
      numbering before installing FreeBSD, and then leave it that way.  If you
      need to switch drives around, then do so, but do it the hard way, and
      open the case and move the jumpers and cables.</para>

    <sidebar>
      <title>An illustration from the files of Bill and Fred's Exceptional
	Adventures:</title>
      
      <para>Bill breaks-down an older Wintel box to make another FreeBSD box
	for Fred. Bill installs a single SCSI drive as SCSI unit zero, and
	installs FreeBSD on it.</para>

      <para>Fred begins using the system, but after several days notices that
	the older SCSI drive is reporting numerous soft errors, and reports
	this fact to Bill.</para>

      <para>After several more days, Bill decides it's time to address the
	situation, so he grabs an identical SCSI drive from the disk drive
	"archive" in the back room.  An initial surface scan indicates that
	this drive is functioning well, so Bill installs this drive as SCSI
	unit four, and makes an image copy from drive zero to drive four.  Now
	that the new drive is installed and functioning nicely, Bill decides
	that it's a good idea to start using it, so he uses features in the
	SCSI BIOS to re-order the disk drives so that the system boots from
	SCSI unit four.  FreeBSD boots and runs just fine.</para>

      <para>Fred continues his work for several days, and soon Bill and Fred
	decide that it's time for a new adventure -- time to upgrade to a
	newer version of FreeBSD.  Bill removes SCSI unit zero because it was
	a bit flaky, and replaces it with another identical disk drive from
	the "archive."  Bill then installs the new version of FreeBSD onto the
	new SCSI unit zero using Fred's magic internet FTP floppies.  The
	installation goes well.</para>

      <para>Fred uses the new version of FreeBSD for a few days, and certifies
	that it is good enough for use in the engineering department...it's
	time to copy all of his work from the old version.  So Fred mounts
	SCSI unit four (the latest copy of the older FreeBSD version).  Fred
	is dismayed to find that none of his precious work is present on SCSI
	unit four.</para>

      <para>Where did the data go?</para>

      <para>When Bill made an image copy of the original SCSI unit zero onto
	SCSI unit four, unit four became the "new clone,"  When Bill
	re-ordered the SCSI BIOS so that he could boot from SCSI unit four, he
	was only fooling himself. FreeBSD was still running on SCSI unit zero.
	Making this kind of BIOS change will cause some or all of the Boot and
	Loader code to be fetched from the selected BIOS drive, but when the
	FreeBSD kernel drivers take-over, the BIOS drive numbering will be
	ignored, and FreeBSD will transition back to normal drive numbering.
	In the illustration at hand, the system continued to operate on the
	original SCSI unit zero, and all of Fred's data was there, not on SCSI
	unit four.  The fact that the system appeared to be running on SCSI
	unit four was simply an artifact of human expectations.</para>

      <para>We are delighted to mention that no data bytes were killed or
	harmed in any way by our discovery of this phenomenon.  The older SCSI
	unit zero was retrieved from the bone pile, and all of Fred's work was
	returned to him, (and now Bill knows that he can count as high as
	zero).</para>

      <para>Although SCSI drives were used in this illustration, the concepts
	apply equally to IDE drives.</para>
    </sidebar>
  </sect1>

  <sect1 id="disks-naming">
    <title>Disk Naming</title>

    <para>Physical drives come in two main flavors,
      <acronym>IDE</acronym>, or <acronym>SCSI</acronym>; but there
      are also drives backed by RAID controllers, flash memory, and so
      forth.  Since these behave quite differently, they have their
      own drivers and devices.</para>

    <table id="disk-naming-physical-table">
      <title>Physical Disk Naming Conventions</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Drive type</entry>
	    <entry>Drive device name</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>IDE hard drives</entry>
	    <entry><literal>ad</literal> in 4.0-RELEASE,
	      <literal>wd</literal> before 4.0-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>IDE CDROM drives</entry>
	    <entry><literal>acd</literal> in 4.0-RELEASE,
	      <literal>wcd</literal> before 4.0-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>SCSI hard drives</entry>
	    <entry><literal>da</literal> from 3.0-RELEASE,
	      <literal>sd</literal> before 3.0-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>SCSI CDROM drives</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry>Assorted non-standard CDROM drives</entry>
	    <entry><literal>mcd</literal> for Mitsumi CD-ROM,
	      <literal>scd</literal> for Sony CD-ROM,
	      <literal>matcd</literal> for Matsushita/Panasonic CD-ROM
	    </entry>
	  </row>
	  <row>
	    <entry>Floppy drives</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI tape drives</entry>
	    <entry><literal>sa</literal> from 3.0-RELEASE,
	      <literal>st</literal> before 3.0-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>IDE tape drives</entry>
	    <entry><literal>ast</literal> from 4.0-RELEASE,
	      <literal>wst</literal> before 4.0-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>Flash drives</entry>
	    <entry><literal>fla</literal> for DiskOnChip Flash device
	      from 3.3-RELEASE.</entry>
	  </row>
	  <row>
	    <entry>RAID drives</entry>
	    <entry><literal>myxd</literal> for Mylex, and
	      <literal>amrd</literal> for AMI MegaRAID,
	      <literal>idad</literal> for Compaq Smart RAID.
	      from 4.0-RELEASE.  <literal>id</literal> between
	      3.2-RELEASE and 4.0-RELEASE.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <sect2>
      <title>Slices and Partitions</title>

      <para>Physical disks usually contain
	<firstterm>slices</firstterm>, unless they are
	<quote>dangerously dedicated</quote>.  Slice numbers follow
	the device name, prefixed with an <literal>s</literal>:
	<quote>da0<emphasis>s1</emphasis></quote>.</para>

      <para>Slices, <quote>dangerously dedicated</quote> physical
	drives, and other drives contain
	<firstterm>partitions</firstterm>, which represented as
	letters from <literal>a</literal> to <literal>h</literal>.
	<literal>b</literal> is reserved for swap partitions, and
	<literal>c</literal> is an unused partition the size of the
	entire slice or drive.  This is explained in <xref
	linkend="disks-adding" />.</para>
    </sect2>
  </sect1>

  <sect1 id="disks-mounting">
    <title>Mounting and Unmounting Filesystems</title>

    <para>The filesystem is best visualized as a tree,
      rooted, as it were, at <filename>/</filename>.
      <filename>/dev</filename>, <filename>/usr</filename>, and the
      other directories in the root directory are branches, which may
      have their own branches, such as
      <filename>/usr/local</filename>, and so on.</para>

    <para>There are various reasons to house certain of these
      directories on separate filesystems.  <filename>/var</filename>
      contains log, spool, and various types of temporary files, and
      as such, may get filled up.  Filling up the root filesystem
      isn't a good idea, so splitting <filename>/var</filename> from
      <filename>/</filename> is often a good idea.</para>

    <para>Another common reason to contain certain directory trees on
      other filesystems is if they are to be housed on separate
      physical disks, or are separate virtual disks, such as <link
	linkend="nfs">Network File System</link> mounts, or CDROM
      drives.</para>

    <sect2 id="disks-fstab">
      <title>The fstab File</title>

      <para>During the <link linkend="boot">boot process</link>,
	filesystems listed in <filename>/etc/fstab</filename> are
	automatically mounted (unless they are listed with
	<option>noauto</option>).</para>

      <para>The <filename>/etc/fstab</filename> file contains a list
	of lines of the following format:</para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <para><literal>device</literal> is a device name (which should
	exist), as explained in the <link linkend="disks-naming">Disk
	  naming conventions</link> above.</para>

      <para><literal>mount-point</literal> is a directory (which
	should exist), on which to mount the filesystem.</para>

      <para><literal>fstype</literal> is the filesystem type to pass
	to &man.mount.8;.  The default FreeBSD filesystem is
	<literal>ufs</literal>.</para>

      <para><literal>options</literal> is either <option>rw</option>
	for read-write filesystems, or <option>ro</option> for
	read-only filesystems, followed by any other options that may
	be needed.  A common option is <option>noauto</option> for
	filesystems not normally mounted during the boot sequence.
	Other options in the &man.mount.8; manual page.</para>

      <para><literal>dumpfreq</literal> is the number of days the
	filesystem should be dumped, and <literal>passno</literal> is
	the pass number during which the filesystem is mounted during
	the boot sequence.</para>
    </sect2>

    <sect2 id="disks-mount">
      <title>The mount Command</title>

      <para>The &man.mount.8; command is what is ultimately used to
	mount filesystems.</para>

      <para>In its most basic form, you use:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>There are plenty of options, as mentioned in the
	&man.mount.8; manual page, but the most common are:</para>

      <variablelist>
	<title>mount options</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Mount all filesystems in
	      <filename>/etc/fstab</filename>, as modified by
	      <option>-t</option>, if given.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>Do everything but actually mount the
	      filesystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Force the mounting the filesystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Mount the filesystem read-only.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>Mount the given filesystem as the given filesystem
	      type, or mount only filesystems of the given type, if
	      given the <option>-a</option> option.</para>

	    <para><quote>ufs</quote> is the default filesystem
	      type.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Update mount options on the filesystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Be verbose.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Mount the filesystem read-write.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>The <option>-o</option> takes a comma-separated list of
	the options, including the following:</para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	  <listitem>
	    <para>Do not interpret special devices on the
	      filesystem.  Useful security option.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	    <para>Do not allow execution of binaries on this
	      filesystem.  Useful security option.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>Do not interpret setuid or setgid flags on the
	      filesystem.  Useful security option.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>The umount Command</title>

      <para>The umount command takes, as a parameter, one of a
	mountpoint, a device name, or the <option>-a</option> or
	<option>-A</option> option.</para>

      <para>All forms take <option>-f</option> to force unmounting,
	and <option>-v</option> for verbosity.</para>

      <para><option>-a</option> and <option>-A</option> are used to
	unmount all mounted filesystems, possibly modified by the
	filesystem types listed after <option>-t</option>.
	<option>-A</option>, however, doesn't attempt to unmount the
	root filesystem.</para>
    </sect2>
  </sect1>
  
  <sect1 id="disks-adding">
    <title>Adding Disks</title>

    <para><emphasis>Originally contributed by &a.obrien; 26 April
      1998</emphasis></para>
      
    <para>Lets say we want to add a new SCSI disk to a machine that currently
      only has a single drive.  First turn off the computer and install the
      drive in the computer following the instructions of the computer,
      controller, and drive manufacturer.  Due the wide variations of procedures
      to do this, the details are beyond the scope of this document.</para>

    <para>Login as user <username>root</username>.  After you've installed the
      drive, inspect <filename>/var/run/dmesg.boot</filename> to ensure the new
      disk was found.  Continuing with our example, the newly added drive will
      be <filename>da1</filename> and we want to mount it on
      <filename>/1</filename> (if you are adding an IDE drive, it will
      be <filename>wd1</filename> in pre-4.0 systems, or
      <filename>ad1</filename> in most 4.X systems).</para>

    <para>Because FreeBSD runs on IBM-PC compatible computers, it must take into
      account the PC BIOS partitions.  These are different from the traditional
      BSD partitions.  A PC disk has up to four BIOS partition entries.  If the
      disk is going to be truly dedicated to FreeBSD, you can use the
      <emphasis>dedicated</emphasis> mode.  Otherwise, FreeBSD will have to live
      with in one of the PC BIOS partitions.  FreeBSD calls the PC BIOS
      partitions, <emphasis>slices</emphasis> so as not to confuse them with
      traditional BSD partitions.  You may also use slices on a disk that is
      dedicated to FreeBSD, but used in a computer that also has another
      operating system installed.  This is to not confuse the
      <command>fdisk</command> utility of the other operating system.</para>

    <para>In the slice case the drive will be added as
      <filename>/dev/da1s1e</filename>.  This is read as: SCSI disk, unit number
      1 (second SCSI disk), slice 1 (PC BIOS partition 1), and
      <filename>e</filename> BSD partition.  In the dedicated case, the drive
      will be added simply as <filename>/dev/da1e</filename>.</para>

    <sect2>
      <title>Using sysinstall</title>
      
      <para>You may use <command>/stand/sysinstall</command> to partition and
	label a new disk using its easy to use menus.  Either login as user
	<username>root</username> or use the <command>su</command> command.  Run
	<command>/stand/sysinstall</command> and enter the
	<literal>Configure</literal> menu.  With in the <literal>FreeBSD
	  Configuration Menu</literal>, scroll down and select the
	<literal>Partition</literal> item.  Next you should be presented with a
	list of hard drives installed in your system.  If you do not see
	<literal>da1</literal> listed, you need to recheck your physical
	installation and <command>dmesg</command> output in the file
	<filename>/var/run/dmesg.boot</filename>.</para>
      
      <para>Select <literal>da1</literal> to enter the <literal>FDISK Partition
	  Editor</literal>.  Choose <literal>A</literal> to use the entire disk
	for FreeBSD.  When asked if you want to <quote>remain cooperative with
	  any future possible operating systems</quote>, answer
	<literal>YES</literal>.  Write the changes to the disk using
	<command>W</command>.  Now exit the FDISK editor using
	<command>q</command>.  Next you will be asked about the Master Boot
	Record.  Since you are adding a disk to an already running system,
	choose <literal>None</literal>.</para>

      <para>Next enter the <literal>Disk Label Editor</literal>.  This is where
	you will create the traditional BSD partitions.  A disk can have up to
	eight partitions, labeled a-h.  A few of the partition labels have
	special uses.  The <literal>a</literal> partition is used for the root
	partition (<filename>/</filename>).  Thus only your system disk (e.g,
	the disk you boot from) should have an <literal>a</literal> partition.
	The <literal>b</literal> partition is used for swap partitions, and you
	may have many disks with swap partitions.  The <literal>c</literal>
	partition addresses the entire disk in dedicated mode, or the entire
	FreeBSD slice in slice mode.  The other partitions are for general
	use.</para>

      <para>Sysinstall's Label editor favors the <literal>e</literal> partition
	for non-root, non-swap partitions.  With in the Label editor, create a
	single file system using <command>C</command>.  When prompted if this
	will be a FS (file  system) or swap, choose <literal>FS</literal> and
	give a mount point (e.g, <filename>/mnt</filename>).  When adding a disk
	in post-install mode, Sysinstall will not create entries in
	<filename>/etc/fstab</filename> for you, so the mount point you specify
	isn't important.</para>

      <para>You are now ready to write the new label to the disk and create a
	file system on it.  Do this by hitting <command>W</command>.  Ignore any
	errors from Sysinstall that it could not mount the new partition.  Exit
	the Label Editor and Sysinstall completely.</para>

      <para>The last step is to edit <filename>/etc/fstab</filename> to add an
	entry for your new disk.</para>
    </sect2>

    <sect2>
      <title>Using Command Line Utilities</title>

      <sect3>
	<title>* Using Slices</title>

	<para></para>
      </sect3>
      
      <sect3>
	<title>Dedicated</title>

	<para>If you will not be sharing the new drive with another operating
	  system, you may use the <literal>dedicated</literal> mode.  Remember
	  this mode can confuse Microsoft operating systems; however, no damage
	  will be done by them.  IBM's OS/2 however, will
	  <quote>appropriate</quote> any partition it finds which it doesn't
	  understand.</para>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 bs=1k count=1</userinput>
&prompt.root; <userinput>disklabel -Brw da1 auto</userinput>
&prompt.root; <userinput>disklabel -e da1</userinput>				# create the `e' partition
&prompt.root; <userinput>newfs -d0 /dev/rda1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>				# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>
      
	<para>An alternate method is:</para>
      
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 count=2</userinput>
&prompt.root; <userinput>disklabel /dev/rda1 | disklabel -BrR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/rda1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>					# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="disks-virtual">
    <title>Virtual Disks: Network, Memory, and File-Based Filesystems</title>

    <para>Besides the disks you physically insert into your computer;
      floppies, CDs, hard drives, and so forth, other forms of disks
      are understood by FreeBSD - the <firstterm>virtual
      disks</firstterm>.</para>

    <para>These include network filesystems such as the <link
	linkend="nfs">Network Filesystem</link> and Coda, memory-based
      filesystems such as <link linkend="disks-md">md</link> and
      file-backed filesystems created by <link
	linkend="disks-vnconfig">vnconfig</link>.</para>

    <sect2 id="disks-vnconfig">
      <title>vnconfig: file-backed filesystem</title>

      <para>&man.vnconfig.8; configures and enables vnode pseudo disk
	devices.  A <firstterm>vnode</firstterm> is a representation
	of a file, and is the focus of file activity.  This means that
	&man.vnconfig.8; uses files to create and operate a
	filesystem.  One possible use is the mounting of floppy or CD
	images kept in files.</para>

      <para>To mount an existing filesystem image:</para>

      <example>
	<title>Using vnconfig to mount an existing filesystem
	  image</title>

	<screen>&prompt.root; <userinput>vnconfig vn<replaceable>0</replaceable> <replaceable>diskimage</replaceable></userinput>
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>To create a new filesystem image with vnconfig:</para>

      <example>
	<title>Creating a New File-Backed Disk with vnconfig</title>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>vnconfig -s labels -c vn<replaceable>0</replaceable> <replaceable>newimage</replaceable></userinput>
&prompt.root; <userinput>disklabel -r -w vn<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs vn<replaceable>0</replaceable>c</userinput>
Warning: 2048 sector(s) in last cylinder unallocated
/dev/rvn0c:     10240 sectors in 3 cylinders of 1 tracks, 4096 sectors
        5.0MB in 1 cyl groups (16 c/g, 32.00MB/g, 1280 i/g)
super-block backups (for fsck -b #) at:
 32
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2 id="disks-md">
      <title>md: Memory Filesystem</title>

      <para>md is a simple, efficient means to do memory
	filesystems.</para>

      <para>Simply take a filesystem you've prepared with, for
	example, &man.vnconfig.8;, and:</para>

      <example>
	<title>md memory disk</title>

	<screen>&prompt.root; <userinput>dd if=<replaceable>newimage</replaceable> of=/dev/md<replaceable>0</replaceable></userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mount /dev/md<replaceable>0c</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>
  </sect1>
  
  <sect1 id="quotas">
    <title>Disk Quotas</title>

    <para>Quotas are an optional feature of the operating system that
      allow you to limit the amount of disk space and/or the number of
      files a user, or members of a group, may allocate on a per-file
      system basis. This is used most often on timesharing systems where
      it is desirable to limit the amount of resources any one user or
      group of users may allocate.  This will prevent one user from
      consuming all of the available disk space.</para>

    <sect2>
      <title>Configuring Your System to Enable Disk Quotas</title>

      <para>Before attempting to use disk quotas it is necessary to make
	sure that quotas are configured in your kernel.  This is done by
	adding the following line to your kernel configuration
	file:</para>

      <programlisting>
options QUOTA</programlisting>

      <para>The stock <filename>GENERIC</filename> kernel does not have
	this enabled by default, so you will have to configure, build and
	install a custom kernel in order to use disk quotas.  Please refer
	to the <link linkend="kernelconfig">Configuring the FreeBSD
	Kernel</link> section for more information on kernel
	configuration.</para>

      <para>Next you will need to enable disk quotas in
	<filename>/etc/rc.conf</filename>.  This is done by adding the
	line:</para>

      <programlisting>
enable_quotas=<quote>YES</quote></programlisting>

      <para>For finer control over your quota startup, there is an
	additional configuration variable available. Normally on bootup,
	the quota integrity of each file system is checked by the
	<command>quotacheck</command> program.  The
	<command>quotacheck</command> facility insures that the data in
	the quota database properly reflects the data on the file system.
	This is a very time consuming process that will significantly
	affect the time your system takes to boot. If you would like to
	skip this step, a variable is made available for the
	purpose:</para>

      <programlisting>
check_quotas=<quote>NO</quote></programlisting>

      <para>If you are running FreeBSD prior to 3.2-RELEASE, the
	configuration is simpler, and consists of only one variable.  Set
	the following in your <filename>/etc/rc.conf</filename>:</para>

      <programlisting>
check_quotas=<quote>YES</quote></programlisting>

      <para>Finally you will need to edit <filename>/etc/fstab</filename>
	to enable disk quotas on a per-file system basis.  This is where
	you can either enable user or group quotas or both for all of your
	file systems.</para>

      <para>To enable per-user quotas on a file system, add the
	<literal>userquota</literal> option to the options field in the
	<filename>/etc/fstab</filename> entry for the file system you want
	to to enable quotas on.  For example:</para>

      <programlisting>
/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>Similarly, to enable group quotas, use the
	<literal>groupquota</literal> option instead of the
	<literal>userquota</literal> keyword.  To enable both user and
	group quotas, change the entry as follows:</para>

      <programlisting>
/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>By default the quota files are stored in the root directory of
	the file system with the names <filename>quota.user</filename> and
	<filename>quota.group</filename> for user and group quotas
	respectively.  See <command>man fstab</command> for more
	information.  Even though that man page says that you can specify
	an alternate location for the quota files, this is not recommended
	because the various quota utilities do not seem to handle this
	properly.</para>

      <para>At this point you should reboot your system with your new
	kernel.  <filename>/etc/rc</filename> will automatically run the
	appropriate commands to  create the initial quota files for all of
	the quotas you enabled in <filename>/etc/fstab</filename>, so
	there is no need to manually create any zero length quota
	files.</para>

      <para>In the normal course of operations you should not be required
	to run the <command>quotacheck</command>,
	<command>quotaon</command>, or <command>quotaoff</command>
	commands manually.  However, you may want to read their man pages
	just to be familiar with their operation.</para>
    </sect2>

    <sect2>
      <title>Setting Quota Limits</title>

      <para>Once you have configured your system to enable quotas, verify
	that they really are enabled.  An easy way to do this is to
	run:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>
	  
      <para>You should see a one line summary of disk usage and current
	quota limits for each file system that quotas are enabled
	on.</para>

      <para>You are now ready to start assigning quota limits with the
	<command>edquota</command> command.</para>

      <para>You have several options on how to enforce limits on the
	amount of disk space a user or group may allocate, and how many
	files they may create.  You may limit allocations based on disk
	space (block quotas) or number of files (inode quotas) or a
	combination of both.  Each of these limits are further broken down
	into two categories; hard and soft limits.</para>

      <para>A hard limit may not be exceeded.  Once a user reaches their
	hard limit they may not make any further allocations on the file
	system in question.  For example, if the user has a hard limit of
	500 blocks on a file system and is currently using 490 blocks, the
	user can only allocate an additional 10 blocks.  Attempting to
	allocate an additional 11 blocks  will fail.</para>

      <para>Soft limits on the other hand can be exceeded for a limited
	amount of time.  This period of time is known as the grace period,
	which is one week by default.  If a user stays over his or her
	soft limit longer than their grace period, the soft limit will
	turn into a hard limit and no further allocations will be allowed.
	When the user drops back below the soft limit, the grace period
	will be reset.</para>

      <para>The following is an example of what you might see when you run
	the <command>edquota</command> command.  When the
	<command>edquota</command> command is invoked, you are placed into
	the editor specified by the <envar>EDITOR</envar> environment
	variable, or in the <command>vi</command> editor if the
	<envar>EDITOR</envar> variable is not set, to allow you to edit
	the quota limits.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>
Quotas for user test:
/usr: blocks in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: blocks in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>You will normally see two lines for each file system that has
	quotas enabled.  One line for the block limits, and one line for
	inode limits.  Simply change the value you want updated to modify
	the quota limit.  For example, to raise this users block limit
	from a soft limit of 50 and a hard limit of 75 to a soft limit of
	500 and a hard limit of 600, change:</para>

      <programlisting>/usr: blocks in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>to:</para>

      <programlisting> /usr: blocks in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>The new quota limits will be in place when you exit the
	editor.</para>

      <para>Sometimes it is desirable to set quota limits on a range of
	uids.  This can be done by use of the <option>-p</option> option
	on the <command>edquota</command> command.  First, assign the
	desired quota limit to a user, and then run
	<command>edquota -p protouser startuid-enduid</command>.  For
	example, if user <username>test</username> has the desired quota
	limits, the following command can be used to duplicate those quota
	limits for uids 10,000 through 19,999:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>
	  
      <para>See <command>man edquota</command> for more detailed
	information.</para>
    </sect2>

    <sect2>
      <title>Checking Quota Limits and Disk Usage</title>

      <para>You can use either the <command>quota</command> or the
	<command>repquota</command> commands to check quota limits and
	disk usage.  The <command>quota</command> command can be used to
	check individual user and group quotas and disk usage.  Only the
	super-user may examine quotas and usage for other users, or for
	groups that they are not a member of.  The
	<command>repquota</command> command can be used to get a summary
	of all quotas and disk usage for file systems with quotas
	enabled.</para>

      <para>The following is some sample output from the
	<command>quota -v</command> command for a user that has quota
	limits on two file systems.</para>

      <programlisting>
Disk quotas for user test (uid 1002):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <para>On the <filename>/usr</filename> file system in the above
	example this user is  currently 15 blocks over their soft limit of
	50 blocks and has 5 days of  their grace period left.  Note the
	asterisk <literal>*</literal> which indicates that the user is
	currently over their quota limit.</para>

      <para>Normally file systems that the user is not using any disk
	space on will not show up in the output from the
	<command>quota</command> command, even if they have a quota limit
	assigned for that file system.  The <option>-v</option> option
	will display those file systems, such as the
	<filename>/usr/var</filename> file system in the above
	example.</para>
    </sect2>

    <sect2>
      <title>Quotas over NFS</title>

      <para>Quotas are enforced by the quota subsystem on the NFS server.
	The &man.rpc.rquotad.8; daemon makes quota information available
	to the &man.quota.1; command on NFS clients, allowing users on
	those machines to see their quota statistics.</para>

      <para>Enable <command>rpc.rquotad</command> in
	<filename>/etc/inetd.conf</filename> like so:</para>

      <programlisting>
rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Now restart <command>inetd</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
    </sect2>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
