<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/disks/chapter.sgml,v 1.59 2002/12/01 13:50:13 mheinen Exp $
     basiert auf: 1.116
-->

<chapter id="disks">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Bernd</firstname>
        <surname>Warken</surname>
        <contrib>&Uuml;bersetzt von </contrib>
        <!--  bwarken@mayn.de -->
      </author>
      <author>
	<firstname>Martin</firstname>
	<surname>Heinen</surname>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Speichermedien</title>

  <sect1 id="disks-synopsis">
    <title>&Uuml;bersicht</title>

    <para>Dieses Kapitel behandelt die Benutzung von Laufwerken unter
      FreeBSD.  Laufwerke k&ouml;nnen speichergest&uuml;tzte Laufwerke,
      Netzwerklaufwerke oder normale SCSI/IDE Ger&auml;te sein.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes
      wissen:</para>
    <itemizedlist>
      <listitem><para>Die Begriffe, die FreeBSD verwendet, um die Organisation
	der Daten auf einem physikalischen Laufwerk zu beschreiben
	(Partitionen und Slices).</para>
      </listitem>
      <listitem><para>Wie Sie Dateisysteme an- und abh&auml;ngen.</para>
      </listitem>
      <listitem><para>Wie Sie ein weiteres Laufwerk zu Ihrem System
	hinzuf&uuml;gen.</para>
      </listitem>
      <listitem><para>Wie virtuelle Dateisysteme, zum Beispiel RAM-Disks,
	aufgesetzt werden.</para>
      </listitem>
      <listitem><para>Wie Sie mit Quotas die Benutzung von Laufwerken
	einschr&auml;nken k&ouml;nnen.</para>
      </listitem>
      <listitem><para>Wie unter FreeBSD CDs und DVDs gebrannt werden.</para>
      </listitem>
      <listitem><para>Sie werden die Speichermedien, die Sie f&uuml;r
	Backups einsetzen k&ouml;nnen, kennen.</para></listitem>
      <listitem><para>Wie Sie die unter FreeBSD erh&auml;ltlichen Backup
	Programme benutzen.</para></listitem>
      <listitem><para>Wie Sie ein Backup mit Disketten erstellen.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="disks-naming">
    <title>Ger&auml;tenamen</title>

    <para>Die folgende Tabelle zeigt die von FreeBSD unterst&uuml;tzten
      Speicherger&auml;te und deren Ger&auml;tenamen.</para>

    <table id="disk-naming-physical-table">
      <title>Namenskonventionen von physikalischen Laufwerken</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Laufwerkstyp</entry>
	    <entry>Ger&auml;tename</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>IDE-Festplatten</entry>
	    <entry><literal>ad</literal>
	  </row>
	  <row>
	    <entry>IDE-CD-ROM Laufwerke</entry>
	    <entry><literal>acd</literal>
	  </row>
	  <row>
	    <entry>SCSI-Festplatten und USB-Speichermedien</entry>
	    <entry><literal>da</literal>
	  </row>
	  <row>
	    <entry>SCSI-CD-ROM Laufwerke</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry>Verschiedene propriet&auml;re CD-ROM-Laufwerke</entry>
	    <entry><literal>mcd</literal> Mitsumi CD-ROM,
	      <literal>scd</literal> Sony CD-ROM,
	      <literal>matcd</literal> Matsushita/Panasonic CD-ROM
	    </entry>
	  </row>
	  <row>
	    <entry>Diskettenlaufwerke</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI-Bandlaufwerke</entry>
	    <entry><literal>sa</literal>
            </row>
	  <row>
	    <entry>IDE-Bandlaufwerke</entry>
	    <entry><literal>ast</literal>
	  </row>
	  <row>
	    <entry>Flash-Laufwerke</entry>
	    <entry><literal>fla</literal> f&uuml;r DiskOnChip Flash device
	  </row>
	  <row>
	    <entry>RAID-Laufwerke</entry>
	    <entry><literal>myxd</literal> f&uuml;r Mylex,
	      <literal>amrd</literal> f&uuml;r AMI MegaRAID,
	      <literal>idad</literal> f&uuml;r Compaq Smart RAID.
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 id="disks-adding">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>David</firstname>
	  <surname>O'Brian</surname>
	  <contrib>Im Original von </contrib>
	</author>
      </authorgroup>
      <!-- 26 Apr 1998 -->
    </sect1info>

    <title>Hinzuf&uuml;gen von Laufwerken</title>
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>hinzuf&uuml;gen</secondary>
    </indexterm>

    <para>Angenommen, Sie wollen ein neues SCSI-Laufwerk zu einer Maschine
      hinzuf&uuml;gen, die momentan nur ein Laufwerk hat.  Dazu schalten
      Sie zuerst den Rechner aus und installieren das Laufwerk entsprechend
      der Anleitungen Ihres Rechners, Ihres Controllers und Laufwerk
      Herstellers.  Wegen der gro&szlig;en Abweichungen in der genauen 
      Vorgehensweise w&uuml;rde eine detaillierte Beschreibung den Rahmen
      dieses Dokumentes sprengen.</para>

    <para>Nachdem Sie das Laufwerk installiert haben, melden Sie sich als
      Benutzer <username>root</username> an und kontrollieren Sie
      <filename>/var/run/dmesg.boot</filename>, um sicherzustellen,
      dass das neue Laufwerk gefunden wurde.  Das neue Laufwerk
      wird, um das Beispiel fortzuf&uuml;hren, <devicename>da1</devicename>
      hei&szlig;en und soll unter <filename>/1</filename> angehangen
      werden.  F&uuml;gen Sie eine IDE-Platte hinzu, wird sie
      <devicename>wd1</devicename> auf FreeBSD Systemen vor 4.0 und
      <devicename>ad1</devicename>
      auf den meisten 4.X Systemen hei&szlig;en.</para>

    <indexterm><primary>Partitionen</primary></indexterm>
    <indexterm><primary>Slices</primary></indexterm>
    <indexterm>
      <primary><command>fdisk</command></primary>
    </indexterm>
    <para>Da FreeBSD auf IBM-PC kompatiblen Rechnern l&auml;uft, muss
      es die PC BIOS-Partitionen, die verschieden von den traditionellen
      BSD-Partitionen sind, ber&uuml;cksichtigen.  Eine PC Platte kann
      bis zu vier BIOS-Partitionen enthalten.  Wenn die Platte 
      ausschlie&szlig;lich f&uuml;r FreeBSD verwendet wird, k&ouml;nnen
      Sie den <emphasis>dedicated</emphasis> Modus benutzen, ansonsten
      muss FreeBSD in eine der BIOS-Partitionen installiert werden.
      In FreeBSD hei&szlig;en die PC BIOS-Partitionen 
      <emphasis>Slices</emphasis>, um sie nicht mit den traditionellen
      BSD-Partitionen zu verwechseln.  Sie k&ouml;nnen auch Slices auf
      einer Platte verwenden, die ausschlie&szlig;lich von FreeBSD benutzt wird,
      sich aber in einem Rechner befindet, der noch ein anderes Betriebssystem
      installiert hat.  Dadurch stellen Sie sicher, dass Sie
      <command>fdisk</command> des anderen Betriebssystems noch
      benutzen k&ouml;nnen.</para>

    <para>Im Fall von Slices wird die Platte als
      <filename>/dev/da1s1e</filename> hinzugef&uuml;gt.  Das hei&szlig;t:
      SCSI-Platte, Einheit 1 (die zweite SCSI-Platte), Slice 1
      (PC BIOS-Partition 1) und die <filename>e</filename> BSD-Partition.
      Wird die Platte ausschlie&szlig;lich f&uuml;r FreeBSD verwendet
      (<quote>dangerously dedicated</quote>), wird sie einfach als 
      <filename>/dev/da1e</filename> hinzugef&uuml;gt.</para>

    <sect2>
      <title>Verwenden von &man.sysinstall.8;</title>
      <indexterm>
	<primary><application>sysinstall</application></primary>
	<secondary>hinzuf&uuml;gen von Laufwerken</secondary>
      </indexterm>
      <indexterm>
	<primary>su</primary>
      </indexterm>
      
      <procedure>
	<step>
	  <title>Das <application>sysinstall</application> Men&uuml;</title>

          <para>Um ein Laufwerk zu partitionieren und zu labeln, kann das
	    men&uuml;gest&uuml;tzte <command>/stand/sysinstall</command>
	    benutzt werden.  Dazu melden Sie sich als <username>root</username>
	    an oder benutzen <command>su</command>, um 
	    <username>root</username> zu werden.  Starten Sie 
	    <command>/stand/sysinstall</command> und w&auml;hlen das
	    <literal>Configure</literal> Men&uuml;, w&auml;hlen Sie dort
	    den Punkt <literal>Fdisk</literal> aus.</para>
	</step>
      
      <step>
	<title>Partitionieren mit <application>fdisk</application></title>

	<para>Innerhalb von <application>fdisk</application> geben Sie
	  <userinput>A</userinput> ein, um die ganze Platte f&uuml;r
	  FreeBSD zu benutzen.  Beantworten Sie die Frage <quote>remain
	    cooperative with any future possible operating systems</quote> mit
	  <literal>YES</literal>.  <userinput>W</userinput> schreibt die
	  &Auml;nderung auf die Platte, danach k&ouml;nnen Sie 
	  <application>fdisk</application> mit <userinput>q</userinput>
	  verlassen.  Da Sie eine Platte zu einem schon laufenden System
	  hinzugef&uuml;gt haben, beantworten Sie die Frage nach dem
	  Master Boot Record mit <literal>None</literal>.</para>
      </step>

      <step>
	<title>Disk Label Editor</title>
	<indexterm><primary>BSD Partitionen</primary></indexterm>

	<para>Als n&auml;chstes m&uuml;ssen Sie
	  <application>sysinstall</application> verlassen und es erneut
	  starten.  Folgen Sie dazu bitte den Anweisungen von oben, aber
	  w&auml;hlen Sie dieses Mal die Option <literal>Label</literal>,
	  um in den <literal>Disk Label Editor</literal> zu gelangen.
	  Hier werden die traditionellen BSD-Partitionen erstellt.
	  Ein Laufwerk kann acht Partitionen, die mit den Buchstaben
	  <literal>a-h</literal> gekennzeichnet werden,
	  besitzen.  Einige Partitionen sind f&uuml;r spezielle Zwecke
	  reserviert.  Die <literal>a</literal> Partition ist f&uuml;r die
	  Root-Partition (<filename>/</filename>) reserviert.  Deshalb
	  sollte nur das Laufwerk, von dem gebootet wird, eine
	  <literal>a</literal> Partition besitzen.  Die <literal>b</literal>
	  Partition wird f&uuml;r Swap-Partitionen benutzt, wobei Sie
	  diese auf mehreren Platten benutzen d&uuml;rfen.
	  Im <quote>dangerously dedicated</quote> Modus spricht
	  die <literal>c</literal> Partition die gesamte Platte an,
	  werden Slices verwendet, wird damit die ganze Slice angesprochen.
	  Die anderen Partitionen sind f&uuml;r allgemeine Zwecke
	  verwendbar.</para>

        <para>Der Label Editor von <application>sysinstall</application>
	  bevorzugt die <literal>e</literal>
	  Partition f&uuml;r Partitionen, die weder Root-Partitionen noch
	  Swap-Partitionen sind.  Im Label
	  Editor k&ouml;nnen Sie ein einzelnes Dateisystem 
	  mit <userinput>C</userinput> erstellen.  W&auml;hlen Sie
	  <literal>FS</literal>, wenn Sie gefragt werden, ob Sie ein
	  FS (Dateisystem) oder Swap erstellen wollen, und geben Sie einen
	  Mountpoint z.B. <filename>/mnt</filename> an.  Wenn Sie nach einer
	  FreeBSD Installation ein Dateisystem mit 
	  <application>sysinstall</application> erzeugen,
	  so werden die Eintr&auml;ge in <filename>/etc/fstab</filename>
	  nicht erzeugt, so dass die Angabe des Mountpoints nicht
	  wichtig ist.</para>

        <para>Sie k&ouml;nnen nun das Label auf das Laufwerk schreiben und
	  das Dateisystem erstellen, indem Sie <userinput>W</userinput>
	  dr&uuml;cken.  Ignorieren Sie die Meldung von 
	  <application>sysinstall</application>, dass die neue Partition
	  nicht angehangen werden konnte, und verlassen Sie den Label Editor
	  sowie <application>sysinstall</application>.</para>
      </step>

      <step>
	<title>Ende</title>

        <para>Im letzten Schritt f&uuml;gen Sie noch in 
	  <filename>/etc/fstab</filename> den Eintrag f&uuml;r das neue
	  Laufwerk ein.</para>
      </step>

      </procedure>
    </sect2>

    <sect2>
      <title>Die Kommandozeile</title>

      <sect3>
	<title>Anlegen von Slices</title>

        <para>Mit der folgenden Vorgehensweise wird eine Platte mit
	  anderen Betriebssystemen, die vielleicht auf Ihrem Rechner
	  installiert sind, zusammenarbeiten und nicht das
	  <command>fdisk</command> Programm anderer Betriebssysteme
	  st&ouml;ren.  Bitte benutzen
	  Sie den <literal>dedicated</literal> Modus nur dann, wenn
	  Sie dazu einen guten Grund haben!</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> # Initialisieren der neuen Platte
&prompt.root; <userinput>disklabel -B -w -r da1s1 auto</userinput> # Labeln
&prompt.root; <userinput>disklabel -e da1s1</userinput> # Editieren des Disklabels und Hinzuf&uuml;gen von Partitionen
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> # Wiederholen Sie diesen Schritt f&uuml;r jede Partition
&prompt.root; <userinput>mount -t ufs /dev/da1s1e /1</userinput> # Anh&auml;ngen der Partitionen
&prompt.root; <userinput>vi /etc/fstab</userinput> # &Auml;ndern Sie <filename>/etc/fstab</filename> entsprechend</screen>

	<para>Wenn Sie ein IDE-Laufwerk besitzen, &auml;ndern Sie
	  <filename>da</filename> in <filename>ad</filename>.  Auf
	  Systemen vor 4.0 benutzen Sie <filename>wd</filename>.</para>
      </sect3>
      
      <sect3>
	<title>Dedicated</title>
	<indexterm><primary>OS/2</primary></indexterm>

        <para>Wenn das neue Laufwerk nicht von anderen Betriebssystemen
	  benutzt werden soll, k&ouml;nnen Sie es im 
	  <literal>dedicated</literal> Modus betreiben.  Beachten Sie bitte,
	  dass Microsoft Betriebssysteme mit diesem Modus eventuell nicht
	  zurechtkommen, aber es entsteht kein Schaden am Laufwerk.  Im
	  Gegensatz dazu wird IBMs OS/2 versuchen, jede ihm nicht bekannte
	  Partition zu reparieren.</para>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 bs=1k count=1</userinput>
&prompt.root; <userinput>disklabel -Brw da1 auto</userinput>
&prompt.root; <userinput>disklabel -e da1</userinput> # Erstellen der `e' Partition
&prompt.root; <userinput>newfs -d0 /dev/rda1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput> # /dev/da1e hinzuf&uuml;gen
&prompt.root; <userinput>mount /1</userinput></screen>
      
	<para>Eine alternative Methode:</para>
      
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 count=2</userinput>
&prompt.root; <userinput>disklabel /dev/rda1 | disklabel -BrR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/rda1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput> # /dev/da1e hinzuf&uuml;gen
&prompt.root; <userinput>mount /1</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="raid">
    <title>RAID</title>

    <sect2 id="raid-soft">
      <title>Software RAID</title>

      <sect3 id="ccd">
        <sect3info>
          <authorgroup>
	    <author>
	      <firstname>Christopher</firstname>
              <surname>Shumway</surname>
	      <contrib>Geschrieben von </contrib>
	    </author>
	  </authorgroup>
          <authorgroup>
	    <author>
	      <firstname>Valentino</firstname>
	      <surname>Vaschetto</surname>
	      <contrib>Mark Up von </contrib>
	    </author>
          </authorgroup>
        </sect3info>

        <title>ccd (Concatenated Disk Configuration)</title>

        <para>Die wichtigsten Faktoren bei der Auswahl von Massenspeichern
	  sind Geschwindigkeit, Zuverl&auml;ssigkeit und der Preis.
	  Selten findet sich eine ausgewogene Mischung aller drei Faktoren.
	  Schnelle und zuverl&auml;ssige Massenspeicher sind f&uuml;r
	  gew&ouml;hnlich teuer.  Um die Kosten zu senken, muss
	  entweder an der Geschwindigkeit oder an der Zuverl&auml;ssigkeit
	  gespart werden.  Bei der Planung meines Systems habe ich die
	  Faktoren nach ihrer Wichtigkeit geordnet.  Der wichtigste Faktor
	  waren die Kosten, da ich sehr viel Speicher zu einem guten Preis
	  brauchte.  Der n&auml;chste Faktor, Geschwindigkeit, war nicht
	  so wichtig, da auf die Daten &uuml;ber ein geswitchtes
	  100&nbsp;Mbit Ethernet, das wahrscheinlich den Engpass
          darstellen w&uuml;rde, zugegriffen werden sollte.  Die
	  M&ouml;glichkeit, die Ein- und Ausgabeoperationen auf mehrere
	  Platten zu verteilen,  sollte f&uuml;r dieses Netzwerk mehr als
	  schnell genug sein.  Die Frage nach der Zuverl&auml;ssigkeit war
	  leicht zu beantworten, da sich die Daten ja schon auf CD-Rs
	  befanden und der Massenspeicher nur f&uuml;r den leichteren Zugriff
	  auf die Daten sorgen sollte.  Wenn ein Laufwerk kaputt geht, kann
	  es leicht ersetzt werden und die Daten k&ouml;nnen nach dem
	  Wiederherstellen des Dateisystems von CD-Rs wieder kopiert
	  werden.</para>

        <para>Unter dem Strich wollte ich also m&ouml;glichst viel Speicher
          f&uuml;r mein Geld.  Gro&szlig;e IDE-Laufwerke sind heutzutage billig:
          Ich fand IDE-Laufwerke von Western Digital mit 30,7 GB und 5400 RPM
          f&uuml;r 130 US Dollars, von denen ich drei und damit ungef&auml;hr
          neunzig Gigabyte Speicher kaufte.</para>
    
        <sect4 id="ccd-installhw">
          <title>Installation der Hardware</title>
      
          <para>Die Laufwerke wurden in ein System eingebaut, das schon ein
	    IDE-Laufwerk als Systemplatte besa&szlig;.  Es w&auml;re ideal
	    gewesen, f&uuml;r jedes IDE-Laufwerk einen eigenen Controller
	    und ein eigenes Kabel zu haben, doch haben das die damit verbundenen
	    Kosten verboten.  Zwei Platten wurden als Slave und eine als
	    Master konfiguriert.  An den ersten IDE-Controller schloss ich
	    eine als Slave konfigurierte Platte zus&auml;tzlich zur Systemplatte
	    an.  Die beiden anderen Platten wurden als Master und Slave an den
	    zweiten Controller angeschlossen.</para>
      
          <para>Beim Reboot wurde das BIOS so konfiguriert, dass es
	    die angeschlossenen Platten automatisch erkennt und FreeBSD
	    erkannte die Platten ebenfalls:</para>
      
          <programlisting>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</programlisting>
      
          <para>Wenn FreeBSD die Platten jetzt nicht erkennt,
	    &uuml;berpr&uuml;fen Sie, ob die Jumper korrekt konfiguriert sind.
	    Ich habe von vielen Problemen geh&ouml;rt, die dadurch entstanden
	    sind, dass die Platten mit <quote>cable select</quote> anstatt
	    richtig als Master und Slave konfiguriert waren.</para>
      
          <para>Die n&auml;chste &Uuml;berlegung war, wie die Platten in
	    das Dateisystem eingebunden werden sollten.  Ich schaute mir
	    &man.vinum.8; (<xref linkend="vinum-vinum">)
	    und FreeBSDs &man.ccd.4; im Hinblick auf meine
	    Konfiguration an.  Die Entscheidung fiel zugunsten von &man.ccd.4;,
	    da es aus weniger Teilen besteht und weniger Teile h&auml;ufig
	    eine h&ouml;here Stabilit&auml;t anzeigen.  Vinum schien f&uuml;r
	    meine Zwecke ein bisschen zuviel zu sein.</para>
        </sect4>
    
        <sect4 id="ccd-setup">
          <title>Konfiguration von CCD</title>
      
          <para>Mit <application>ccd</application> k&ouml;nnen mehrere
	    gleiche Platten zu einem logischen Dateisystem
	    zusammengefasst werden.  Um <application>ccd</application>
	    zu benutzen, muss der Kernel mit der entsprechenden
	    Unterst&uuml;tzung &uuml;bersetzt werden.  Ich f&uuml;gte die
	    folgende Zeile zu meiner Konfigurationsdatei hinzu und
	    &uuml;bersetzte den Kernel neu:</para>
      
          <programlisting>pseudo-device   ccd     4</programlisting>
      
          <para>In FreeBSD&nbsp;4.0 und sp&auml;teren Versionen kann
	    <application>ccd</application> auch als Kernelmodul geladen
	    werden.</para>
      
          <para>Um <application>ccd</application> zu benutzen, m&uuml;ssen
	    die Laufwerke zuerst mit einem Label versehen werden.  Die Label
	    erstellte ich mit den folgenden Kommandos:</para>
      
          <programlisting>disklabel -r -w ad1 auto
disklabel -r -w ad2 auto
disklabel -r -w ad3 auto</programlisting>
      
          <para>Damit wurden die Label <devicename>ad1c</devicename>,
	    <devicename>ad2c</devicename> und <devicename>ad3c</devicename>
	    erstellt, die jeweils das gesamte Laufwerk umfassen.</para>
      
          <para>Im n&auml;chsten Schritt muss der Typ des Labels
	    ge&auml;ndert werden.  Zum Editieren der Lables benutzte ich
	    folgende Kommandos:</para>
      
          <programlisting>disklabel -e ad1
disklabel -e ad2
disklabel -e ad3</programlisting>
      
          <para>F&uuml;r jedes Label startete dies den durch
	    <envar>EDITOR</envar> gegebenen Editor, in meinem Fall &man.vi.1;,
	    der dann einen Abschnitt, wie den folgenden zeigte:</para>
      
          <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</programlisting>
      
          <para>F&uuml;r <application>ccd</application> musste ich eine
	    <quote>e</quote> Partition erstellen.  Diese kann durch Kopieren
	    der <quote>c</quote> Partition erstellt werden, allerdings muss
	    <option>fstype</option> auf <userinput>4.2BSD</userinput>
	    gesetzt werden.  Der editierte Label sah dann wie folgt aus:</para>
      
          <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</programlisting>
      
        </sect4>
    
        <sect4 id="ccd-buildingfs">
          <title>Erstellen des Dateisystems</title>
      
          <para>Nachdem die Label erstellt waren, musste ich
	    <application>ccd</application> konfigurieren.  Dazu dient
	    &man.ccdconfig.8;, das als ersten Parameter das zu konfigurierende
	    Ger&auml;t, in meinem Fall <devicename>/dev/ccd0c</devicename>,
	    erwartet.  Wenn die Ger&auml;tedatei f&uuml;r
	    <devicename>ccd0c</devicename> noch nicht existiert, k&ouml;nnen
	    Sie diese mit den folgenden Kommandos erstellen:</para>
      
          <programlisting>cd /dev
sh MAKEDEV ccd0</programlisting>
      
          <para>Das n&auml;chste Argument, das <command>ccdconfig</command>
	    erwartet, ist der Interleave f&uuml;r das Dateisystem.  Der
	    Interleave definiert die Gr&ouml;&szlig;e eines Streifens in
	    Bl&ouml;cken, die normal 512&nbsp;Bytes gro&szlig; sind.  Ein
	    Interleave von 32 ist demnach 16384&nbsp;Bytes gro&szlig;.</para>
      
          <para>Nach der Angabe des Interleaves k&ouml;nnen Sie Optionen
	    f&uuml;r <command>ccdconfig</command> angeben.  Wenn Sie
	    gespiegelte Laufwerke einrichten  m&ouml;chten, m&uuml;ssen
	    Sie an dieser Stelle eine Option angeben.
	    Da ich keinen Spiegel erstellen wollte, habe ich
	    <literal>0</literal> eingesetzt.</para>
      
          <para>Zum Schluss werden die Ger&auml;te des Verbundes angegeben.
            Die komplette Kommandozeile sieht dann wie folgt aus:</para>
      
          <programlisting>ccdconfig ccd0 32 0 /dev/ad1e /dev/ad2e /dev/ad3e</programlisting>
      
          <para>Damit ist <application>ccd</application> konfiguriert und
            mit &man.newfs.8; kann nun ein Dateisystem angelegt werden:</para>
      
          <programlisting>newfs /dev/ccd0c</programlisting>
      
        </sect4>

        <sect4 id="ccd-auto">
          <title>Automatisierung</title>
      
          <para>Damit <application>ccd</application> beim Start automatisch
	    aktiviert wird, ist die Datei <filename>/etc/ccd.conf</filename>
	    mit dem folgenden Kommando zu erstellen:</para>
      
          <programlisting>ccdconfig -g &gt; /etc/ccd.conf</programlisting>
      
          <para>Wenn <filename>/etc/ccd.conf</filename> existiert, wird beim
	    Reboot <command>ccdconfig -C</command> von
	    <command>/etc/rc</command> aufgerufen.  Damit wird
	    <application>ccd</application> eingerichtet und die darauf
	    befindlichen Dateisysteme k&ouml;nnen angeh&auml;ngt
	    werden.</para>
      
          <para>Wenn Sie in den Single-User Modus booten, m&uuml;ssen Sie
	    den Verbund erst konfigurieren, bevor Sie darauf befindliche
	    Dateisysteme anh&auml;ngen k&ouml;nnen:</para>
      
          <programlisting>ccdconfig -C</programlisting>
      
          <para>In <filename>/etc/fstab</filename> ist noch ein Eintrag f&uuml;r
	    das auf dem Verbund befindliche Dateisystem zu erstellen, damit
	    dieses beim Start des Systems immer angeh&auml;ngt wird:</para>
      
          <programlisting>/dev/ccd0c              /media       ufs     rw      2       2</programlisting>
        </sect4>
      </sect3>

      <sect3 id="vinum">
	<title>Der Vinum Volume Manager</title>

	<para>Der Vinum Volume Manager ist ein Block-Ger&auml;tetreiber,
	  der virtuelle Platten zur Verf&uuml;gung stellt.  Er trennt die
	  Verbindung zwischen der Festplatte und dem zugeh&ouml;rigen
	  Block-Ger&auml;t auf.  Im Gegensatz zur konventionellen
	  Aufteilung einer Platte in Slices lassen sich dadurch Daten
	  flexibler, leistungsf&auml;higer und zuverl&auml;ssiger verwalten.
	  &man.vinum.8; stellt RAID-0, RAID-1 und RAID-5 sowohl einzeln wie
	  auch in Kombination zur Verf&uuml;gung.</para>

	<para>Mehr Informationen &uuml;ber &man.vinum.8; erhalten Sie in
	  <xref linkend="vinum-vinum">.</para>
      </sect3>
    </sect2>

    <sect2 id="raid-hard">
      <title>Hardware RAID</title>

      <indexterm>
        <primary>RAID</primary>
        <secondary>Hardware</secondary>
      </indexterm>
      <para>FreeBSD unterst&uuml;tzt eine Reihe von
	<acronym>RAID</acronym>-Controllern, die mit Hilfe eines
	<acronym>BIOS</acronym> auf der Karte ein <acronym>RAID</acronym>
	System aufbauen und verwalten k&ouml;nnen.  Wie ein
	<acronym>RAID</acronym> System eingerichtet wird, sei kurz am
	Beispiel des Promise <acronym>IDE RAID</acronym>-Controllers
	gezeigt.  Nachdem die Karte eingebaut ist und der Rechner neu
	gestartet wurde, erscheint eine Eingabeaufforderung.  Wenn Sie den
	Anweisungen auf dem Bildschirm folgen, gelangen Sie in eine Maske,
	in der Sie mit den vorhandenen Festplatten ein
	<acronym>RAID</acronym> System aufbauen k&ouml;nnen.  Das
	<acronym>RAID</acronym> System erscheint sp&auml;ter unter FreeBSD
	als eine Festplatte.</para>
    </sect2>
    
    <sect2>
      <title>Wiederherstellen eines ATA-RAID-1 Verbunds</title>

      <para>Mit FreeBSD k&ouml;nnen Sie eine ausgefallene Platte in
	einem RAID-Verbund w&auml;hrend des Betriebs auswechseln,
	vorausgesetzt Sie bemerken den Ausfall vor einem Neustart.</para>

      <para>Einen Ausfall erkennen Sie, wenn in den Protokollen von
	&man.syslogd.8; oder &man.dmesg.8; Meldungen wie die folgenden
	auftauchen:</para>

      <programlisting>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11) status=59 error=40
ar0: WARNING - mirror lost</programlisting>

      <para>&Uuml;berpr&uuml;fen Sie den RAID-Verbund mit
        &man.atacontrol.8;:</para>

      <screen>&prompt.root; <userinput>atacontrol list</userinput>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</screen>

      <procedure>
	<step>
	  <para>Damit Sie die Platte ausbauen k&ouml;nnen, muss sie zuerst
	    aus dem Verbund entfernt werden:</para>

	  <screen>&prompt.root; <userinput>atacontrol detach 3</userinput></screen>
	</step>

	<step>
	  <para>Ersetzen Sie dann die Platte.</para>
	</step>

	<step>
	  <para>Nehmen Sie die neue Platte in den Verbund auf:</para>

	  <screen>&prompt.root; <userinput>atacontrol attach 3</userinput>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</screen>

	<step>
	  <para>Stellen Sie die Organisation des Verbunds wieder her:</para>

	  <screen>&prompt.root; <userinput>atacontrol rebuild ar0</userinput></screen>
	</step>

	<step>
	  <para>Das Kommando blockiert den Terminal bis der Verbund
	    wiederhergestellt ist.  Den Fortgang des Prozesses k&ouml;nnen
	    Sie in einem anderen Terminal mit den folgenden Befehlen
	    kontrollieren:</para>

	  <screen>&prompt.root; <userinput>dmesg | tail -10</userinput>
[output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</screen>
	</step>

	<step>
	  <para>Warten Sie bis die Wiederherstellung beendet ist.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 id="creating-cds">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Beigesteuert von </contrib>
	  <!-- mwm@mired.org -->
	</author>
      </authorgroup>
      <!-- Apr 2001 -->
    </sect1info>

    <title>Handhabung von optischen Speichermedien (CDs &amp; DVDs)</title>
    <indexterm>
      <primary>CD-ROM</primary>
      <secondary>erstellen</secondary>
    </indexterm>

    <sect2>
      <title>Einf&uuml;hrung</title>

      <para>CDs besitzen einige Eigenschaften, die sie von
	konventionellen Laufwerken unterscheiden.  Zuerst konnten
	sie nicht beschrieben werden.  Sie wurden so entworfen, dass
	sie ununterbrochen, ohne Verz&ouml;gerungen durch Kopfbewegungen
	zwischen den Spuren, gelesen werden k&ouml;nnen.  Sie konnten
	fr&uuml;her auch leichter als vergleichbar gro&szlig;e Medien zwischen
	Systemen bewegt werden.</para>
    
      <para>CDs besitzen Spuren, aber damit ist der Teil Daten
	gemeint, der ununterbrochen gelesen wird, und nicht eine
	physikalische Eigenschaft der CD.  Um eine CD mit FreeBSD
	zu erstellen,  werden die Daten jeder Spur der CD in
	Dateien vorbereitet und dann die Spuren auf die CD 
	geschrieben.</para>
    
      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>ISO-9660</secondary>
      </indexterm>
      <para>Das ISO 9660-Dateisystem wurde entworfen, um mit diesen
	Unterschieden umzugehen.  Leider hat es auch damals &uuml;bliche
	Grenzen f&uuml;r Dateisysteme implementiert.  Gl&uuml;cklicherweise
	existiert ein Erweiterungsmechanismus, der es korrekt
	geschriebenen CDs erlaubt, diese Grenzen zu &uuml;berschreiten
	und dennoch auf Systemen zu funktionieren, die diese
	Erweiterungen nicht unterst&uuml;tzen.</para>

      <indexterm>
	<primary><command>mkisofs</command></primary>
      </indexterm>
      <para>Mit <filename role="package">sysutils/mkisofs</filename>
	wird eine Datei erstellt, die ein ISO 9660-Dateisystem enth&auml;lt.
	Das Kommando hat Optionen, um verschiedene Erweiterungen
	zu unterst&uuml;tzen, und wird unten beschrieben.  Sie
	k&ouml;nnen es aus dem <filename role="package">sysutils/mkisofs</filename>
	Port installieren.</para>
    
      <indexterm>
	<primary>CD Brenner</primary>
	<secondary>ATAPI</secondary>
      </indexterm>
      <para>Welches Tool Sie zum Brennen von CDs benutzen, h&auml;ngt davon
	ab, ob Ihr CD Brenner ein ATAPI Ger&auml;t ist oder nicht.
	Mit ATAPI CD Brennern wird <command><link linkend="burncd"
	</link>burncd</command> benutzt, das Teil des Basissystems ist.
	SCSI und USB CD-Brenner werden mit <command><link linkend="cdrecord">
	cdrecord</link></command> aus 
	<filename role="package">sysutils/cdrtools</filename>
	benutzt.</para>

      <para>Von <command>burncd</command> wird nur eine beschr&auml;nkte
	Anzahl von Laufwerken unterst&uuml;tzt.  Um herauszufinden, ob
	ein Laufwerk unterst&uuml;tzt wird, sehen Sie bitte unter
	<ulink url="http://freebsd.dk/ata/">CD-R/RW supported drives</ulink>
	nach.</para>
    </sect2>

    <sect2 id="mkisofs">
      <title>mkisofs</title>

      <para><filename role="package">sysutils/mkisofs</filename> erstellt ein
	ISO 9660-Dateisystem,
	das ein Abbild eines Verzeichnisbaumes des Unix-Dateisystems
	ist.  Die einfachste Anwendung ist wie folgt:</para>
    
      <screen>&prompt.root; <userinput>mkisofs -o <replaceable>Imagedatei</replaceable> <replaceable>/path/to/tree</replaceable></userinput></screen>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>ISO-9660</secondary>
      </indexterm>
      <para>Dieses Kommando erstellt eine <replaceable>Imagedatei</replaceable>,
        die ein ISO 9660-Dateisystem enth&auml;lt, das eine Kopie des
	Baumes unter <replaceable>/path/to/tree</replaceable> ist.
	Dabei werden die Dateinamen auf Namen abgebildet, die den
	Restriktionen des ISO 9660-Dateisystems entsprechen.  Dateien
	mit Namen, die im ISO 9660-Dateisystem nicht g&uuml;ltig sind,
	bleiben unber&uuml;cksichtigt.</para>
    
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>HFS</secondary>
      </indexterm>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>Joliet</secondary>
      </indexterm>
      <para>Es einige Optionen, um diese Beschr&auml;nkungen
	zu &uuml;berwinden.  Die unter Unix-Systemen &uuml;blichen
	Rock Ridge Erweiterungen werden durch <option>-R</option>
	aktiviert, <option>-J</option> aktiviert die von Microsoft
	Systemen benutzten Joliet Erweiterungen und <option>-hfs</option>
	dient dazu, um das von MacOS benutzte HFS zu erstellen.
    
      <para>F&uuml;r CDs, die nur auf FreeBSD-Systemen verwendet werden
	sollen, kann <option>-U</option> genutzt werden, um alle
	Beschr&auml;nkungen f&uuml;r Dateinamen aufzuheben.  Zusammen
	mit <option>-R</option> wird ein Abbild des
	Dateisystems, ausgehend von dem Startpunkt im FreeBSD-Dateibaum,
	erstellt, obwohl dies den ISO 9660 Standard
	verletzen kann.</para>
    
      <indexterm>
	<primary>CD-ROM</primary>
	<secondary>bootbare erstellen</secondary>
      </indexterm>
      <para>Die letzte &uuml;bliche Option ist <option>-b</option>.
	Sie wird benutzt, um den Ort eines Bootimages einer
	<quote>El Torito</quote> bootbaren CD anzugeben.  Das Argument
	zu dieser Option ist der Pfad zu einem Bootimage ausgehend
	von der Wurzel des Baumes, der auf die CD geschrieben werden
	soll.  Wenn <filename>/tmp/myboot</filename> ein bootbares
	FreeBSD-System enth&auml;lt, dessen Bootimage sich in
	<filename>/tmp/myboot/boot/cdboot</filename> befindet, k&ouml;nnen
	Sie ein Abbild eines ISO 9660-Dateisystems in
	<filename>/tmp/bootable.iso</filename> wie folgt
	erstellen:</para>

      <screen>&prompt.root; <userinput>mkisofs -U -R -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</userinput></screen>

      <para>Wenn Sie <devicename>vn</devicename> in Ihrem Kernel 
	konfiguriert haben, k&ouml;nnen Sie danach das Dateisystem
	anh&auml;ngen:</para>

      <screen>&prompt.root; <userinput>vnconfig -e vn0c /tmp/bootable.iso</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/vn0c /mnt</userinput></screen>

      <para>Jetzt k&ouml;nnen Sie &uuml;berpr&uuml;fen, dass
	<filename>/mnt</filename> und <filename>/tmp/myboot</filename>
	identisch sind.</para>

      <para>Sie k&ouml;nnen das Verhalten von
	<filename role="package">sysutils/mkisofs</filename>
	mit einer Vielzahl von Optionen beeinflussen.  Insbesondere k&ouml;nnen
	Sie das ISO-9660 Dateisystem modifizieren und Joliet- oder
	HFS-Dateisysteme brennen.  Details dazu entnehmen Sie
	bitte der Manualpage von
	<filename role="package">sysutils/mkisofs</filename>.</para>
    </sect2>

    <sect2 id="burncd">
      <title>burncd</title>

      <indexterm>
	<primary>CD-ROM</primary>
	<secondary>brennen</secondary>
      </indexterm>
      <para>Wenn Sie einen ATAPI CD Brenner besitzen, k&ouml;nnen
	Sie <command>burncd</command> benutzen, um ein ISO-Image
	auf CD zu brennen.  <command>burncd</command> ist Teil
	des Basissystems und unter <filename>/usr/sbin/burncd</filename>
	installiert.  Da es nicht viele Optionen hat, ist es leicht
	zu benutzen:</para>
      
      <screen>&prompt.root; <userinput>burncd -f <replaceable>cddevice</replaceable> data <replaceable>imagefile.iso</replaceable> fixate</userinput></screen>

      <para>Dieses Kommando brennt eine Kopie von
	<replaceable>imagefile.iso</replaceable> auf das Ger&auml;t
	<replaceable>cddevice</replaceable>.  In der Grundeinstellung
	wird das Ger&auml;t <filename>/dev/acd0c</filename> benutzt.
	&man.burncd.8; beschreibt, wie die Schreibgeschwindigkeit
	gesetzt wird, die CD ausgeworfen wird und Audio Daten
	geschrieben werden.</para>
    </sect2>

    <sect2 id="cdrecord">
      <title>cdrecord</title>

      <para>Wenn Sie keinen ATAPI CD Brenner besitzen, benutzen Sie
	<command>cdrecord</command>, um CDs zu brennen. 
	<command>cdrecord</command> ist nicht Bestandteil des Basissystems.
	Sie m&uuml;ssen es entweder aus den Ports in
	<filename role="package">sysutils/cdrtools</filename> oder dem
	passenden Paket installieren.  &Auml;nderungen im Basissystem
	k&ouml;nnen Fehler im bin&auml;ren Programm verursachen und
	f&uuml;hren m&ouml;glicherweise dazu, dass Sie einen
	<quote>Untersetzer</quote> brennen.  Sie sollten
	daher den Port aktualisieren, wenn Sie Ihr System aktualisieren
	bzw. wenn Sie
	<link linkend="stable">STABLE verfolgen</link>,
	den Port aktualisieren, wenn es eine neue Version gibt.</para>
      
      <para>Obwohl <command>cdrecord</command> viele Optionen besitzt,
	ist die grundlegende Anwendung einfacher als <command>burncd</command>.
	Ein ISO 9660 Image erstellen Sie mit:</para>
      
      <screen>&prompt.root; <userinput>cdrecord dev=<replaceable>device</replaceable> <replaceable>imagefile.iso</replaceable></userinput></screen>
      
      <para>Der Knackpunkt in der Benutzung von <command>cdrecord</command>
	besteht darin, das richtige Argument zu <option>dev</option> zu
	finden.  Benutzen Sie dazu den <option>-scanbus</option> Schalter
	von <command>cdrecord</command>, der eine &auml;hnliche Ausgabe
	wie die folgende produziert:</para>
      
      <indexterm>
	<primary>CD-ROM</primary>
	<secondary>brennen</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord 1.9 (i386-unknown-freebsd4.2) Copyright (C) 1995-2000 J&ouml;rg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>F&uuml;r die aufgef&uuml;hrten Ger&auml;te in der Liste
	wird das passende Argument zu <option>dev</option> gegeben.
        Benutzen Sie die drei durch Kommas separierten Zahlen, die zu
	Ihrem CD Brenner angegeben sind, als Argument f&uuml;r
	<option>dev</option>.  Im Beispiel ist das CDRW Ger&auml;t
	1,5,0, so dass die passende Eingabe 
	<userinput>dev=1,5,0</userinput> w&auml;re.
	Einfachere Wege das Argument anzugeben, sind in &man.cdrecord.1;
	beschrieben.  Dort sollten Sie auch nach 
	Informationen &uuml;ber Audio Spuren, das Einstellen der
	Geschwindigkeit und &auml;hnlichem suchen.</para>
    </sect2>

    <sect2 id="duplicating-audiocds">
      <title>Kopieren von Audio-CDs</title>

      <para>Um eine Kopie einer Audio-CD zu erstellen, kopieren Sie die
        St&uuml;cke der CD in einzelne Dateien und brennen diese Dateien
	dann auf eine leere CD.  Das genaue Verfahren h&auml;ngt davon ab,
	ob Sie ATAPI-Laufwerke oder SCSI-Laufwerke verwenden.</para>

      <procedure>
	<title>SCSI-Laufwerke</title>

	<step>
	  <para>Kopieren Sie die Audio-Daten mit
	    <command>cdda2wav</command>:</para>

	  <screen>&prompt.user; <userinput>cdda2wav -v255 -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
	  <para>Die erzeugten <filename>.wav</filename> Dateien schreiben
	    Sie mit <command>cdrecord</command> auf eine leere CD:</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=<replaceable>2,0</replaceable> -dao -useinfo  *.wav</userinput></screen>

	  <para>Das Argument von <option>dev</option> gibt das verwendete
	    Ger&auml;t an, das Sie, wie in <xref linkend="cdrecord">
	    beschrieben, ermitteln k&ouml;nnen.</para>
	</step>
      </procedure>

      <procedure>
	<title>ATAPI-Laufwerke</title>
	
	<step>
	  <para>Der ATAPI CD-Treiber stellt die einzelnen St&uuml;cke der
	    CD &uuml;ber die Dateien
	    <filename>/dev/acd<replaceable>d</replaceable>t<replaceable>n</replaceable></filename>, 
	    zur Verf&uuml;gung.  <replaceable>d</replaceable> bezeichnet
	    die Laufwerksnummer und <replaceable>n</replaceable> ist die
	    Nummer des St&uuml;cks.  Die Datei <filename>/dev/acd0t1</filename>
	    bezeichnet also das erste St&uuml;ck auf dem ersten
	    CD-Laufwerk.</para>

	  <para>Die entsprechenden Dateien in <filename>/dev</filename>
	    erstellen Sie mit <command>MAKEDEV</command>:</para>
	  
	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV acd0t99</userinput></screen>
	</step>

	<step>
	  <para>Die einzelnen St&uuml;cke kopieren Sie mit &man.dd.1;.  Sie
	    m&uuml;ssen dazu eine spezielle Blockgr&ouml;&szlig;e
	    angeben:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t1 of=track1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t2 of=track2.cdr bs=2352</userinput>
...
</screen>
	</step>

	<step>
	  <para>Die kopierten Dateien k&ouml;nnen Sie dann mit
	    <command>burncd</command> brennen.  Auf der Kommandozeile
	    m&uuml;ssen Sie angeben, dass Sie Audio-Daten brennen
	    wollen und dass das Medium fixiert werden soll:</para>

	  <screen>&prompt.root; <userinput>burncd -f <replaceable>/dev/acd0c</replaceable> audio track1.cdr track2.cdr <replaceable>...</replaceable> fixate</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 id="imaging-cd">
      <title>Kopieren von Daten-CDs</title>

      <para>Sie k&ouml;nnen eine Daten-CD in eine Datei kopieren, die einem
        Image entspricht, das mit
	<filename role="package">sysutils/mkisofs</filename> erstellt
	wurde.  Mit Hilfe dieses Images k&ouml;nnen Sie jede Daten-CD
	kopieren.  Das folgende Beispiel verwendet
	<devicename>acd0</devicename> f&uuml;r das CD-ROM Ger&auml;t.  Wenn
	Sie ein anderes Laufwerk benutzen, setzen Sie bitte den richtigen
	Namen ein.  An den Ger&auml;tenamen muss ein
	<literal>c</literal> angehangen werden, um die ganze Partition,
	in diesem Fall ist das die ganze CD-ROM, anzusprechen.</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0c of=file.iso bs=2048</userinput></screen>

      <para>Danach haben Sie ein Image, das Sie wie oben beschrieben, auf
        eine CD brennen k&ouml;nnen.</para>
    </sect2>

    <sect2 id="mounting-cd">
      <title>Einh&auml;ngen von Daten-CDs</title>

      <para>Nachdem Sie eine Daten-CD gebrannt haben, wollen Sie
        wahrscheinlich auch die Daten auf der CD lesen.  Dazu m&uuml;ssen
	Sie die CD in den Dateibaum einh&auml;ngen.  Die Voreinstellung
	f&uuml;r den Typ des Dateisystems von &man.mount.8; ist
	<literal>UFS</literal>.  Das System wird die Fehlermeldung
	<errorname>Incorrect super block</errorname> ausgeben, wenn Sie
	versuchen, die CD mit dem folgenden Kommando
	einzuh&auml;ngen:</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0c /mnt</userinput></screen>

      <para>Auf der CD befindet sich ja kein <literal>UFS</literal>
	Dateisystem, so dass der Versuch, die CD einzuh&auml;ngen
	fehlschl&auml;gt.  Sie m&uuml;ssen &man.mount.8; sagen, dass
	es ein Dateisystem vom Typ <literal>ISO9660</literal> verwenden
	soll.  Dies erreichen Sie durch die Angabe von <option>-t
	cd9660</option> auf der Kommandozeile.  Wenn Sie also die CD-ROM
	<devicename>/dev/cd0c</devicename> in <filename>/mnt</filename>
	einh&auml;ngen wollen, f&uuml;hren Sie folgenden Befehl aus:</para>

          <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0c /mnt</userinput></screen>
          
      <para>Abh&auml;ngig vom verwendeten CD-ROM kann der Ger&auml;tename
        von dem im Beispiel (<devicename>/dev/cd0c</devicename>)
	abweichen.  Die Angabe von <option>-t cd9660</option> f&uuml;hrt
	&man.mount.cd9660.8; aus, so dass das Beispiel verk&uuml;rzt
	werden kann:</para>

<screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0c /mnt</userinput></screen>

      <para>Auf diese Weise k&ouml;nnen Sie
        Daten-CDs von jedem Hersteller verwenden.  Es kann allerdings zu
	Problemen mit CDs kommen, die verschiedene ISO 9660 Erweiterungen
	benutzen.  So speichern Joliet CDs alle Dateinamen unter Verwendung
	von zwei Byte langen Unicode Zeichen.  Der FreeBSD Kernel
	unterst&uuml;tzt zurzeit noch kein Unicode und manche
	Sonderzeichen werden als Fragezeichen dargestellt.  Ab
	FreeBSD 4.3 sind im CD9660-Treiber M&ouml;glichkeiten vorgesehen,
	eine Konvertierungstabelle zur Laufzeit zu laden.  Module f&uuml;r
	die gebr&auml;uchlisten Kodierungen finden Sie im Port
	<filename role="package">sysutils/cd9660_unicode</filename>.</para>

      <para>Manchmal werden Sie die Meldung <errorname>Device
        not configured</errorname> erhalten, wenn Sie versuchen,  eine
	CD-ROM einzuh&auml;ngen.  F&uuml;r gew&ouml;hnlich liegt das daran,
	dass das Laufwerk meint es sei keine CD eingelegt, oder
	dass das Laufwerk auf dem Bus nicht erkannt wird.  Es kann
	einige Sekunden dauern, bevor das Laufwerk merkt, dass eine CD
	eingelegt wurde.  Seien Sie also geduldig.</para>

      <para>Manchmal wird ein SCSI-CD-ROM nicht erkannt, weil es keine Zeit
        hatte, auf das Zur&uuml;cksetzen des Busses zu antworten.  Wenn Sie
	ein SCSI-CD-ROM besitzen, sollten Sie die folgende Zeile in Ihre
	Kernelkonfiguration aufnehmen und einen neuen <link
	linkend="kernelconfig-building">Kernel bauen</link>:</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>Die Zeile bewirkt, dass nach dem Zur&uuml;cksetzen des
        SCSI-Busses beim Booten 15&nbsp;Sekunden gewartet wird, um dem
	CD-ROM-Laufwerk gen&uuml;gend Zeit zu geben, darauf zu
	antworten.</para>
    </sect2>

    <sect2 id="rawdata-cd">
      <title>Brennen von rohen CDs</title>

      <para>Sie k&ouml;nnen eine Datei auch direkt auf eine CD brennen,
        ohne vorher auf ihr ein ISO 9660 Dateisystem einzurichten.
	Einige Leute nutzen dies, um Datensicherungen durchzuf&uuml;hren.
	Diese Vorgehensweise hat den Vorteil, dass Sie schneller als
	das Brennen einer normalen CD ist.</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1c -s 12 data archive.tar.gz fixate</userinput></screen>

      <para>Wenn Sie die Daten von einer solchen CD wieder
        zur&uuml;ckbekommen wollen, m&uuml;ssen Sie sie direkt von dem
	rohen Ger&auml;t lesen:</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1c</userinput></screen>

      <para>Eine auf diese Weise gefertigte CD k&ouml;nnen Sie nicht in das
        Dateisystem einh&auml;ngen.  Sie k&ouml;nnen Sie auch nicht auf
	einem anderen Betriebssystem lesen.  Wenn Sie die erstellten CDs in
	das Dateisystem einh&auml;ngen oder mit anderen Betriebssystemen
	austauschen wollen, m&uuml;ssen Sie
	<filename role="package">sysutils/mkisofs</filename>,
	wie oben beschrieben, benutzen.</para>
    </sect2>
  </sect1>

  <sect1 id="floppies">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Julio</firstname>
	  <surname>Merino</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <!-- 24 Dec 2001 -->
    </sect1info>

    <title>Handhabung von Disketten</title>

    <para>Heutzutage sind Disketten kein geeignetes Speichermedium mehr.
      Trotzdem werden sie manchmal noch verwendet, wenn zum Beispiel kein
      anderes Medium zur Verf&uuml;gung steht und auf Daten eines anderen
      Rechners zugegriffen werden muss.</para>

    <para>Dieser Abschnitt zeigt Ihnen, wie Sie Disketten formatieren, Daten
      auf Disketten schreiben und Daten von Disketten lesen.
      Tats&auml;chlich habe ich diesen Abschnitt geschrieben, um Ihnen zu
      zeigen, wie Sie die Kapazit&auml;t Ihrer Disketten erh&ouml;hen
      k&ouml;nnen.</para>

    <sect2>
      <title>Die Ger&auml;tedateien</title>

      <para>Wie auf jedes andere Ger&auml;t auch, greifen Sie auf Disketten
	&uuml;ber Eintr&auml;ge im Verzeichnis <filename>/dev</filename>
	zu.  Um auf das rohe Ger&auml;t zuzugreifen, benutzen Sie
	<filename>/dev/rfd<replaceable>X</replaceable></filename>, wobei
	Sie f&uuml;r <replaceable>X</replaceable> die Ger&auml;tenummer,
	normalerweise <literal>0</literal>, einsetzen.  Auf eine formatierte
	Diskette greifen Sie &uuml;ber das Ger&auml;t
	<filename>/dev/fd<replaceable>X</replaceable></filename> zu.  Sie
	k&ouml;nnen dazu auch die Eintr&auml;ge
	<filename>/dev/fd<replaceable>XY</replaceable></filename>, wobei
	<replaceable>Y</replaceable> ein Buchstabe ist, benutzen.</para>

      <para>Die Eintr&auml;ge der Form
        <filename>/dev/fd<replaceable>X</replaceable>.<replaceable>
	  Gr&ouml;&szlig;e</replaceable></filename> werden
	genutzt, um Disketten zu formatieren.
	<replaceable>Gr&ouml;&szlig;e</replaceable> gibt die Kapazit&auml;t
	der Diskette in Kilobytes an.</para>

      <para>Manchmal m&uuml;ssen Sie diese Eintr&auml;ge in
        <filename>/dev</filename> anlegen oder wiederherstellen.  Dazu
	k&ouml;nnen Sie das folgende Kommando benutzen:</para>

      <screen>&prompt.root; <userinput>cd /dev && ./MAKEDEV "fd*"</userinput></screen>
    </sect2>

    <sect2>
      <title>Formatieren</title>

      <para>Bevor eine Diskette benutzt werden kann, muss Sie
        (low-level) formatiert werden, was normalerweise der Hersteller
	schon gemacht hat.  Sie k&ouml;nnen sie allerdings noch einmal
	formatieren, um das Medium zu &uuml;berpr&uuml;fen, oder die
	Kapazit&auml;t zu erh&ouml;hen.</para>

      <para>Mit &man.fdformat.1; formatieren Sie eine
        Diskette.  Dieses Werkzeug erwartet
	die Angabe eines Ger&auml;tenamens der Form
	<filename>/dev/fd<replaceable>X</replaceable>.<replaceable>
	  Gr&ouml;&szlig;e</replaceable></filename> aus
	<filename>/dev</filename>, mit dem Sie die Kapazit&auml;t der
	Diskette steuern k&ouml;nnen.  Legen Sie eine 3,5 Zoll Diskette in
	Ihr Laufwerk ein und f&uuml;hren das folgende Kommando aus:</para>

      <screen>&prompt.root; <userinput>/usr/sbin/fdformat /dev/rfd0.1440</userinput></screen>

      <para>Das Formatieren dauert eine Weile und hier auftauchende Fehler
        zeigen schlechte Medien an.</para>

      <para>Um eine andere Kapazit&auml;t zu erzwingen, nehmen Sie
	einen anderen Eintrag aus <filename>/dev</filename>.  Benutzen Sie
	dieselbe Diskette mit folgendem Befehl:</para>

      <screen>&prompt.root; <userinput>/usr/sbin/fdformat /dev/rfd0.1720</userinput></screen>

      <para>Das Formatieren mit einer h&ouml;heren Kapazit&auml;t nimmt
        etwas mehr Zeit in Anspruch als das vorige Beispiel.  Nachdem der
	Befehl ausgef&uuml;hrt ist, haben Sie eine Diskette mit 1720&nbsp;KB
	Kapazit&auml;t.  Sie k&ouml;nnen auch andere Eintr&auml;ge aus
	<filename>/dev</filename> verwenden, doch sind 1720&nbsp;KB f&uuml;r
	3,5-Zoll Disketten am besten geeignet.</para>
    </sect2>

    <sect2>
      <title>Das Disklabel</title>

      <para>Nach dem Formatieren muss auf der Diskette ein Disklabel
        erstellt werden.  Das Disklabel wird sp&auml;ter zerst&ouml;rt, ist
	aber notwendig, um die Gr&ouml;&szlig;e und Geometrie der Diskette
	zu erkennen.</para>

      <para>Das Disklabel gilt f&uuml;r die ganze Diskette und enth&auml;lt
	alle Informationen &uuml;ber die Geometrie der Diskette.  Eine
	Liste der m&ouml;glichen Geometrien finden Sie in
	<filename>/etc/disktab</filename>.</para>

      <para>Erstellen Sie nun das Label mit
	<application>disklabel</application>:</para>

      <screen>&prompt.root; <userinput>/sbin/disklabel -B -r -w /dev/rfd0 <replaceable>fdsize</replaceable></userinput></screen>

      <para>Wenn Sie eine andere Kapazit&auml;t benutzen wollen, ersetzen Sie
	<replaceable>fdsize</replaceable> mit dem passenden Wert
	(beispielsweise <literal>fd1440</literal> oder
	<literal>fd1720</literal>).  Damit bestimmen Sie, welchen Eintrag
	<application>disklabel</application> aus
	<filename>/etc/disktab</filename> benutzt.</para>
    </sect2>

    <sect2>
      <title>Das Dateisystem</title>

      <para>Auf der Diskette muss nun ein Dateisystem erstellt werden
        (high-level Formatierung), damit FreeBSD von der Diskette lesen und
	auf sie schreiben kann.  Das Disklabel wird durch das Anlegen eines
	Dateisystems zerst&ouml;rt.  Falls Sie die Diskette sp&auml;ter erneut
	formatieren wollen, m&uuml;ssen Sie dann auch ein neues Disklabel
	anlegen.</para>

      <para>F&uuml;r das zu erstellende Dateisystem haben Sie die Wahl
        zwischen UFS und FAT.  Da UFS f&uuml;r Disketten weniger geeignet
	ist, nehmen Sie bitte FAT.</para>

      <para>Das folgende Kommando legt ein Dateisystem auf der Diskette
        an:</para>

      <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>

      <para>Durch das Disklabel erkennt &man.newfs.8;
        den Diskettentyp und ist in der Lage, ein neues Dateisystem
        anzulegen.  Die Diskette kann nun benutzt werden.</para>
    </sect2>

    <sect2>
      <title>Verwenden der Diskette</title>

      <para>Sie k&ouml;nnen die Diskette mit
        &man.mount.msdos.8; in Ihren Dateibaum
	einh&auml;ngen oder mit den <application>Mtools</application> aus
	der Ports-Sammlung darauf zugreifen.</para>

      <para>Wenn Sie die <application>Mtools</application> benutzen und die
        Diskette mit einer erh&ouml;hten Kapazit&auml;t formatiert haben,
	sollte <application>mdir</application> diese Kapazit&auml;t
	anzeigen.</para>

      <para>Disketten mit erh&ouml;hter Kapazit&auml;t lassen sich praktisch
	mit allen anderen Betriebssystemen ohne zus&auml;tzliche Utilities
	verwenden.  Microsoft-Systeme k&ouml;nnen mit ihnen ohne Probleme
	umgehen.  Es kann allerdings sein, dass &auml;ltere Laufwerke
	nicht mit diesen Disketten zurechtkommen.</para>
    </sect2>
  </sect1>

  <sect1 id="backups-tapebackups">
    <title>Handhabung von Bandmedien</title>
    
    <indexterm><primary>Bandmedien</primary></indexterm>
    <para>Die wichtigsten Bandmedien sind 4mm, 8mm, QIC,
      Mini-Cartridge und DLT.</para>
    
    <sect2 id="backups-tapebackups-4mm">
      <title>4mm (DDS: Digital Data Storage)</title>

      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>DDS (4mm) B&auml;nder</secondary>
      </indexterm>
      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>QIC B&auml;nder</secondary>
      </indexterm>
      
      <para>Die 4mm-B&auml;nder ersetzen mehr und mehr das QIC-Format als
        Backupmedium der Wahl f&uuml;r Workstations.  Dieser Trend nahm stark
        zu, als Conner die Firma Archive, einen f&uuml;hrenden Hersteller von
        QIC-Laufwerken, aufkaufte und die Produktion von QIC-Laufwerken
        stoppte.  4mm-Laufwerke sind klein und ruhig, haben aber nicht den
        gleichen Ruf der Zuverl&auml;ssigkeit, den die 8mm-Laufwerke
        genie&szlig;en.  Die 4mm-Kassetten sind preiswerter und mit den
        Ma&szlig;en 76,2&nbsp;x&nbsp;50,8&nbsp;x&nbsp;12,7&nbsp;mm
	(3&nbsp;x&nbsp;2&nbsp;x&nbsp;0,5&nbsp;Inch) kleiner als die
        8mm-Kassetten.  Sowohl die 4mm- als auch die 8mm-Magnetk&ouml;pfe
        haben eine relativ kurze Lebensdauer, weil beide die gleiche
        Helical-Scan-Technologie benutzen.</para>
      
      <para>Der Datendurchsatz dieser Laufwerke beginnt bei etwa
	150&nbsp;kByte/s, Spitzenwerte liegen bei etwa 500&nbsp;kByte/s.
        Die Datenkapazit&auml;t liegt zwischen 1,3&nbsp;GB und 2&nbsp;GB.
	Die meisten Ger&auml;te haben eine Hardwarekompression eingebaut,
	die die Kapazit&auml;t ungef&auml;hr verdoppelt.  Es gibt
        Multi-Drive-Einheiten f&uuml;r Bandbibliotheken mit bis zu 6
        Laufwerken in einem Geh&auml;use und automatischem Bandwechsel.  Die
        Kapazit&auml;t einer solchen Bibliothek liegt bei 240&nbsp;GB.</para>
      
      <para>Der Standard DDS-3 unterst&uuml;tzt nun Bandkapazit&auml;ten bis
        zu 12&nbsp;GB (oder komprimiert 24&nbsp;GB).</para>
      
      <para>4mm-Laufwerke, ebenso wie 8mm-Laufwerke, verwenden Helical-Scan.
        Alle Vor- und Nachteile von Helical-Scan gelten sowohl f&uuml;r 4mm-
        als auch f&uuml;r 8mm-Laufwerke.</para>
      
      <para>B&auml;nder sollten nach 2.000 Banddurchl&auml;ufen oder 100
        vollen Backups ersetzt werden.</para>
    </sect2>
    
    <sect2 id="backups-tapebackups-8mm">
      <title>8mm (Exabyte)</title>
      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>Exabyte (8mm) B&auml;nder</secondary>
      </indexterm>
      
      <para>8mm-B&auml;nder sind die verbreitetsten SCSI-Bandlaufwerke; sie
        sind das geeignetste Bandformat zum Austausch von B&auml;ndern.
        Fast an jedem Standort gibt es ein 8mm-Bandlaufwerk mit 2&nbsp;GB.
        8mm-B&auml;nder sind zuverl&auml;ssig, gut zu handhaben und
	arbeiten leise.  Bandkassetten sind preiswert und klein mit
	122&nbsp;x&nbsp;84&nbsp;x&nbsp;15&nbsp;mm
        (4,8&nbsp;x&nbsp;3,3&nbsp;x&nbsp;0,6&nbsp;Inch).  Ein Nachteil
	der 8mm-Technologie ist die relativ kurze Lebensdauer des
	Schreib-/Lesekopfs und der B&auml;nder auf Grund der hohen
	Relativgeschwindigkeit des Bandes &uuml;ber die K&ouml;pfe
	hinweg.</para>
      
      <para>Der Datendurchsatz liegt ungef&auml;hr zwischen
	250&nbsp;kByte/s und 500&nbsp;kByte/s.  Die Datenkapazit&auml;t
	beginnt bei 300&nbsp;MB und erreicht bis zu 7&nbsp;GB bei den
	Spitzenger&auml;ten.  Die meisten Ger&auml;te
        haben eine Hardwarekompression eingebaut, die die Kapazit&auml;t
        ungef&auml;hr verdoppelt.  Diese Laufwerke sind erh&auml;ltlich in
        Form von Einzelger&auml;ten oder als Multi-Drive-Bandbibliotheken mit
        6 Laufwerken und 120 B&auml;ndern in einem Geh&auml;use.  Die
        B&auml;nder werden von der Ger&auml;teeinheit automatisch gewechselt.
        Die Kapazit&auml;t einer solchen Bibliothek liegt bei 840&nbsp;GB und
        mehr.</para>
      
      <para>Das Exabyte-Modell <quote>Mammoth</quote> unterst&uuml;tzt
	12&nbsp;GB auf einem Band (24&nbsp;GB mit Kompression) und kostet
	etwa doppelt so viel wie ein konventionelles Bandlaufwerk.</para>
      
      <para>Die Daten werden mittels Helical-Scan auf das Band
        aufgezeichnet, die K&ouml;pfe sind leicht schr&auml;g zum Medium
        angebracht (mit einem Winkel von etwa 6 Grad).  Das Band wickelt
	sich 270&nbsp;Grad um die Spule, die die K&ouml;pfe tr&auml;gt.
	Die Spule dreht sich, w&auml;hrend das Band dar&uuml;berl&auml;uft.
	Das Resultat ist eine hohe Datendichte und eng gepackte Spuren,
	die von einem Rand des Bands zum gegen&uuml;berliegenden quer
	&uuml;ber das Band abgewinkelt verlaufen.</para>
    </sect2>
    
    <sect2 id="backups-tapebackups-qic">
      <title>QIC</title>

      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>QIC-150</secondary>
      </indexterm>
      
      <para>QIC-150-B&auml;nder und -Laufwerke sind wohl der am weitesten
        verbreitete Bandtyp &uuml;berhaupt.  QIC-Bandlaufwerke sind die
        preiswertesten <quote>seri&ouml;sen</quote> Backupger&auml;te,
	die angeboten werden.  Der Nachteil dabei ist der hohe Preis
	der B&auml;nder.  QIC-B&auml;nder sind im Vergleich zu 8mm- oder
	4mm-B&auml;ndern bis zu f&uuml;nf Mal teurer, wenn man den Preis
	auf 1&nbsp;GB Datenkapazit&auml;t umrechnet.  Aber wenn Ihr Bedarf
	mit einem halben Dutzend B&auml;nder abgedeckt werden kann,
	mag QIC die richtige Wahl sein.</para>
      
      <para>QIC ist der <emphasis>g&auml;ngigste</emphasis>
        Bandlaufwerkstyp.  Jeder Standort hat ein QIC-Laufwerk der einen oder
        anderen Dichte.  Aber gerade das ist der Haken an der Sache, QIC
        bietet eine gro&szlig;e Anzahl verschiedener Datendichten auf
        physikalisch &auml;hnlichen (manchmal gleichen) B&auml;ndern.
        QIC-Laufwerke sind nicht leise.  Diese Laufwerke suchen lautstark die
        richtige Bandstelle, bevor sie mit der Datenaufzeichnung beginnen.
        Sie sind w&auml;hrend des Lesens, Schreibens und Suchens deutlich
        h&ouml;rbar.</para>
      
      <para>Die Abmessungen der QIC-Kassetten betragen
	152.4&nbsp;x&nbsp;101.6&nbsp;x&nbsp;17.78&nbsp;mm
	(6&nbsp;x&nbsp;4&nbsp;x&nbsp;0,7&nbsp;Inch),
	die QIC-Bandbreite betr&auml;gt 6,35&nbsp;mm (1/4&nbsp;Inch).  <link
          linkend="backups-tapebackups-mini">Mini-Cartridges</link>, die die
        gleiche Bandbreite verwenden, werden gesondert vorgestellt.
        Bandbibliotheken und Bandwechselger&auml;te gibt es im QIC-Format
        keine.</para>
      
      <para>Der Datendurchsatz liegt ungef&auml;hr zwischen
	150&nbsp;kByte/s und 500&nbsp;kByte/s.  Die Datenkapazit&auml;t
	reicht von 40&nbsp;MB bis zu 15&nbsp;GB.
        Hardwarekompression ist in vielen der neueren QIC-Laufwerke eingebaut.
        QIC-Laufwerke werden heute seltener eingesetzt; sie werden von den
        DAT-Laufwerken abgel&ouml;st.</para>
      
      <para>Die Daten werden auf dem Band in Spuren aufgezeichnet.  Die
        Spuren verlaufen entlang der L&auml;ngsachse des Bandmediums von einem
        Ende zum anderen.  Die Anzahl der Spuren, und damit auch die Breite
        einer Spur, variiert mit der Kapazit&auml;t des Laufwerks.  Die
        meisten, wenn nicht alle neueren Laufwerke sind
        r&uuml;ckw&auml;rtskompatibel, zumindest zum Lesen (aber oft auch zum
        Schreiben).  QIC hat einen guten Ruf bez&uuml;glich der
        Datensicherheit (die Mechanik ist einfacher und robuster als diejenige
        der Helical-Scan-Laufwerke).</para>
      
      <para>B&auml;nder sollten nach 5,000 Backups ersetzt werden.</para>
    </sect2>
    
    <sect2 id="backups-tapebackups-mini">
      <title>XXX* Mini-Cartridge</title>
      
      <para></para>
    </sect2>

    <sect2 id="backups-tapebackups-dlt">
      <title>DLT</title>
      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>DLT</secondary>
      </indexterm>
      
      <para>DLT hat die schnellste Datentransferrate von allen hier
        aufgelisteten Ger&auml;tetypen.  Das 1/2-Inch-Band (12,7&nbsp;mm)
	befindet sich in einer Spulkassette mit den Abmessungen
	101,6&nbsp;x&nbsp;101,6&nbsp;x&nbsp;25,4&nbsp;mm
        (4&nbsp;x&nbsp;4&nbsp;x&nbsp;1&nbsp;Inch).  Die eine Seite
	der Kassette hat eine bewegliche Abdeckung.  Der Laufwerksmechanismus
	&ouml;ffnet diese Abdeckung und zieht die Bandf&uuml;hrung heraus.
	Die Bandf&uuml;hrung tr&auml;gt ein ovales Loch, die das Laufwerk
	zum <quote>Einh&auml;ngen</quote> des Bandes benutzt.  Die
	Aufwickelspule befindet sich im Innern des Bandlaufwerks.  Bei allen
	anderen hier besprochenen Bandkassetten (9-Spur-B&auml;nder
	sind die einzige Ausnahme) befinden sich sowohl die Auf- als auch
	die Abwickelspule im Inneren der Bandkassette.</para>
      
      <para>Der Datendurchsatz liegt bei etwa 1,5&nbsp;MBytes/s, der dreifache
        Durchsatz der 4mm-, 8mm- oder QIC-Bandlaufwerke.  Die
        Datenkapazit&auml;t reicht von 10&nbsp;GB bis 20&nbsp;GB f&uuml;r
        Einfachlaufwerke.  Auch Mehrfachbandger&auml;te sind erh&auml;ltlich,
        sowohl als Bandwechsler wie auch als Multi-Drive-Bandbibliotheken, die
        Platz f&uuml;r 5 bis 900 B&auml;nder verteilt auf 1 bis 20 Laufwerke
        enthalten, mit einer Speicherkapazit&auml;t von 50&nbsp;GB bis
	9&nbsp;TB.</para>
      
      <para>Mit Kompression unterst&uuml;tzt das Format DLT Type IV bis zu
        70&nbsp;GB Kapazit&auml;t.</para>
      
      <para>Die Daten werden auf dem Band in Spuren aufgezeichnet, die
        parallel zur Bewegungsrichtung verlaufen (gerade so wie bei den
        QIC-B&auml;ndern).  Zwei Spuren werden dabei gleichzeitig beschrieben.
        Die Lebenszeit der Lese- und Schreibk&ouml;pfe sind relativ lang; denn
        sobald das Band anh&auml;lt, gibt es keine Relativbewegung mehr
        zwischen den K&ouml;pfen und dem Band.</para>
    </sect2>
    
    <sect2>
      <title id="backups-tapebackups-ait">AIT</title>
      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>AIT</secondary>
      </indexterm>
      
      <para>AIT ist ein neues Format von Sony, das (mit Kompression) bis zu
        50&nbsp;GB pro Band speichern kann.  Die B&auml;nder haben einen
        Speicherchip, der einen Index mit dem Inhalt des Bandes anlegt.
        Dieser Index kann vom Bandlaufwerk zur schnellen Bestimmung der Lage
        von Dateien auf dem Band benutzt werden, w&auml;hrend andere
        B&auml;nder einige Minuten zur Lokalisierung ben&ouml;tigen.</para>
      
      <para>Entsprechende Software wie etwa SAMS:Alexandria
        k&ouml;nnen 40 oder mehr AIT-Bandbibliotheken verarbeiten, indem sie
        direkt mit dem Speicherchip des Bandes kommunizieren, wenn der
        Bandinhalt am Bildschirm dargestellt werden soll oder bestimmt werden
        soll, welche Dateien auf welchem Band gespeichert sind, oder um das
        richtige Band zu lokalisieren, zu laden und Daten vom Band
        zur&uuml;ckzuspielen.  Bibliotheken dieser Art liegen in der
        Preiskategorie von $20,000, womit sie etwas aus dem Hobbymarkt
        herausfallen.</para>
    </sect2>
    
    <sect2>
      <title>Die erste Benutzung eines neuen Bands</title>
      
      <para>Der Versuch ein neues, vollkommen leeres Band ohne weiteres zu
        lesen oder zu beschreiben wird schief gehen.  Auf der Konsole werden
        dann Meldungen &auml;hnlich wie folgt ausgegeben:</para>
      
      <screen>sa0(ncr1:4:0): NOT READY asc:4,1
0(ncr1:4:0): Logical unit is in process of becoming ready</screen>
      
      <para>Das Band enth&auml;lt n&auml;mlich keinen Identifier-Block
        (Blocknummer 0).  Alle QIC-Bandlaufwerke seit der Einf&uuml;hrung des
        QIC-525-Standards schreiben einen Identifier-Block auf das Band.  Es
        gibt zwei L&ouml;sungen:</para>
      
      <para><command>mt fsf 1</command> veranlasst das Bandlaufwerk einen
        Identifier-Block auf das Band zu schreiben.</para>
      
      <para>Das Band durch Dr&uuml;cken des Bandauswurfknopfs an der
        Vorderseite des Bandger&auml;ts auswerfen.</para>
      
      <para>Danach das Band wieder einlegen und Daten auf das Band
        &uuml;bertragen wie in <command>dump</command> beschrieben.</para>
      
      <para>Das Kommando <command>dump</command> gibt die Meldung
	<literal>DUMP: End of tape detected</literal> zur&uuml;ck und die
	Konsole zeigt:
        <literal>HARDWARE FAILURE info:280 asc:80,96</literal>.</para>
      
      <para>Das Band zur&uuml;ckspulen mit dem Kommando: <command>mt
          rewind</command>.</para>
      
      <para>Nachfolgende Bandoperationen werden dann erfolgreich
        ausgef&uuml;hrt.</para>
    </sect2>
  </sect1>

  <sect1 id="backups-floppybackups">
    <title>Was ist mit Backups auf Disketten?</title>
    
    <sect2 id="floppies-using">
      <title>Kann ich Disketten zum Backup meiner Daten verwenden?</title>
      <indexterm><primary>Backup Disketten</primary></indexterm>
      <indexterm><primary>Disketten</primary></indexterm>
      
      <para>Disketten sind kein wirklich geeignetes Medium f&uuml;r Backups
        aus folgenden Gr&uuml;nden:</para>
      
      <itemizedlist>
        <listitem>
          <para>Disketten sind unzuverl&auml;ssig, besonders
            langfristig.</para>
        </listitem>
        
        <listitem>
          <para>Speichern und Wiederherstellen ist sehr langsam.</para>
        </listitem>
        
        <listitem>
          <para>Sie haben eine sehr eingeschr&auml;nkte Kapazit&auml;t (Die
            Zeiten sind l&auml;ngst vorbei, wo eine ganze Festplatte auf ein
            Dutzend Floppies oder so gespeichert werden konnte).</para>
        </listitem>
      </itemizedlist>
      
      <para>Wenn jedoch keine andere M&ouml;glichkeit zum Datenbackup
        vorhanden ist, dann sind Disketten immer noch besser als gar kein
        Backup.</para>
      
      <para>Wenn man gezwungen ist Disketten zu verwenden, dann sollte man
        auf eine gute Qualit&auml;t achten.  Floppies, die schon einige Jahre
        im B&uuml;ro herumgelegen haben, sind eine schlechte Wahl.  Ideal sind
        neue Disketten von einem renommierten Hersteller.</para>
    </sect2>
    
    <sect2 id="floppies-creating">
      <title>Wie mache ich ein Backup auf Disketten?</title>
      
      <para>Die beste Art eines Diskettenbackups ist der Befehl
	<command>tar</command>
        mit der Mehrfachband-Option <option>-M</option>, die es
        erm&ouml;glicht ein Backup &uuml;ber mehrere Floppies zu
        verteilen.</para>
      
      <para>Ein Backup aller Dateien im aktuellen Verzeichnis
        einschlie&szlig;lich aller Unterverzeichnisse wird durch den folgenden
        Befehl veranlasst (als <username>root</username>):</para>
      
      <screen>&prompt.root; <userinput>tar Mcvf /dev/rfd0 *</userinput></screen>
      
      <para>Wenn die erste Floppy voll ist, meldet sich <command>tar</command>
	und verlangt einen Diskettenwechsel (weil <command>tar</command>
	unabh&auml;ngig vom
        Medium arbeitet, wird das n&auml;chste Band (Volume) verlangt, was in
        diesem Zusammenhang eine Diskette bedeutet), in etwa wie folgt:</para>
      
      <screen>Prepare volume #2 for /dev/rfd0 and hit return:</screen>
      
      <para>Dies wird mit steigender Volumenzahl wiederholt, bis alle
        angegebenen Dateien archiviert sind.</para>
    </sect2>
    
    <sect2 id="floppies-compress">
      <title>K&ouml;nnen Diskettenbackups komprimiert werden?</title>
      <indexterm>
	<primary><command>tar</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>gzip</command></primary>
      </indexterm>
      <indexterm><primary>Kompression</primary></indexterm>
      
      <para>Leider erlaubt es <command>tar</command> nicht, die Option
        <option>-z</option> f&uuml;r Multi-Volume-Archive zu verwenden.  Man
        kann nat&uuml;rlich alle Dateien mit <command>gzip</command>
	komprimieren, sie mit <command>tar</command> auf die Floppies
	aufspielen, und dann die Dateien wieder <command>gunzip</command>
	entkomprimieren!</para>
    </sect2>
    
    <sect2 id="floppies-restoring">
      <title>Wie werden Diskettenbackups wieder hergestellt?</title>
      
      <para>Zur Wiederherstellung des gesamten Archivs verwendet man:</para>
      
      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0</userinput></screen>
      
      <para>Eine Methode um nur bestimmte Dateien wieder her zu stellen ist
        mit der ersten Diskette den folgenden Befehl auszuf&uuml;hren:</para>
      
      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0 <replaceable>filename</replaceable></userinput></screen>
      
      <para><command>tar</command> wird dann die folgenden Disketten anfordern,
	bis die ben&ouml;tigte Datei gefunden ist.</para>
      
      <para>Wenn man die Diskette kennt, auf der sich die Datei befindet,
        kann man alternativ diese Diskette auch direkt einlegen und den
        gleichen Befehl wie oben verwenden.  Man beachte, dass, falls die
        erste Datei eine Fortsetzung einer Datei von einer
        der vorigen Disketten ist, <command>tar</command> die Warnung ausgibt,
	dass diese Datei nicht wiederhergestellt werden kann, selbst dann,
	wenn dies gar nicht verlangt wurde!</para>
    </sect2>
  </sect1>
  
  <sect1 id="backup-basics">
    <title>Datensicherung</title>
    <indexterm><primary>Datensicherung</primary></indexterm>
    <indexterm><primary>Backup</primary></indexterm>
    
    <para>Die drei wichtigsten Programme zur Sicherung von Daten sind
      &man.dump.8;, &man.tar.1; und &man.cpio.1;.</para>
    
    <sect2>
      <title>Sichern und Wiederherstellen</title>
      <indexterm>
	<primary>Backup Software</primary>
	<secondary>Sichern / Wiederherstellen</secondary>
      </indexterm>
      <indexterm><primary><command>dump</command></primary></indexterm>
      <indexterm><primary><command>restore</command></primary></indexterm>
      
      <para><command>dump</command> und <command>restore</command> sind die
	traditionellen
        Backupprogramme in Unix.  Sie betrachten das Laufwerk als eine
        Ansammlung von Bl&ouml;cken, operieren also unterhalb dem
        Abstraktionslevel von Dateien, Links und Verzeichnissen, die die
        Grundlage des Dateisystemkonzepts bilden.  <command>dump</command>
	sichert ein ganzes Dateisystem auf einem Ger&auml;t, es ist nicht
	m&ouml;glich nur einen Teil des Dateisystems, oder einen
	Verzeichnisbaum, der mehr als ein Dateisystem umfasst zu
	sichern.  <command>dump</command> schreibt keine Dateien oder
	Verzeichnisse auf das Band, sondern die Bl&ouml;cke, aus denen
	Dateien und Verzeichnisse bestehen.</para>
      
      <note><para>Wenn Sie mit <command>dump</command> das Root-Verzeichnis
	sichern, werden <filename>/home</filename>, <filename>/usr</filename>
	und viele andere Verzeichnisse nicht gesichert, da dies normalerweise
	Mountpunkte f&uuml;r andere Dateisysteme oder symbolische Links
	zu diesen Dateisystemen sind.</para></note>

      <para><command>dump</command> hat einige Eigenarten, die noch aus den
        fr&uuml;hen
        Tagen der Version 6 von ATT Unix (ca. 1975) stammen.  Die Parameter
        sind f&uuml;r 9-Spur-B&auml;nder (6250&nbsp;bpi) voreingestellt,
	nicht auf die heute &uuml;blichen Medien hoher Dichte (bis zu
	62.182&nbsp;ftpi).  Bei der Verwendung der Kapazit&auml;ten
	moderner Bandlaufwerke muss diese Voreinstellung auf der
	Kommandozeile &uuml;berschrieben werden.</para>
      
      <indexterm><primary><filename>.rhosts</filename></primary></indexterm>
      <para><command>rdump</command> und <command>rrestore</command>
	k&ouml;nnen Daten &uuml;ber
        Netzwerk auf ein Band, das sich in einem Laufwerk eines anderen
        Computers befindet, &uuml;berspielen.  Beide Programme benutzen die
        Befehle <command>rcmd</command> und <command>ruserok</command> zum
	Zugriff auf das entfernte
        Bandlaufwerk.  Daher muss der Anwender, der das Backup
        durchf&uuml;hrt, auf dem entfernten Rechner in
        <filename>.rhosts</filename> eingetragen sein.</para>
      
      <para>Die Argumente zu <command>rdump</command> und
	<command>rrestore</command> m&uuml;ssen
        zur Verwendung auf dem entfernten Computer geeignet sein.
	Wenn Sie zum Beispiel mit <command>rdump</command> von einem
	FreeBSD Rechner aus auf ein Exabyte Bandlaufwerk einer Sun mit
	Namen <hostid>komodo</hostid> zugreifen m&ouml;chten, setzen Sie
	das folgende Kommando ab:</para>

      <screen>&prompt.root; <userinput>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nrsa8 /dev/rda0a 2&gt;&amp;1</userinput></screen>

      <para>Zum Ausf&uuml;hren dieses Kommandos m&uuml;ssen Sie auf dem
	entfernten Rechner in <filename>.rhosts</filename> eingetragen
	sein.  Die r-Kommandos sind ein gro&szlig;es Sicherheitsrisiko,
	daher sollten Sie deren Verwendung sorgf&auml;ltig
	abw&auml;gen.</para>

      <para>Es ist auch m&ouml;glich, <command>dump</command> und
	<command>restore</command> &uuml;ber eine gesicherte Verbindung
	mit <command>ssh</command> einzusetzen:</para>

      <example>
	<title><command>dump</command> mit <application>ssh</application>
	  benutzen</title>
	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh1 -c blowfish \
	  targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</userinput></screen

      </example>
    </sect2>
    
    <sect2>
      <title><command>tar</command></title>
      <indexterm>
	<primary>Backup Software</primary>
	<secondary><command>tar</command></secondary>
      </indexterm>
      
      <para>&man.tar.1; stammt ebenfalls aus Version 6 von ATT Unix
        (ca. 1975).  <command>tar</command> arbeitet mit dem Dateisystem,
	denn es schreibt Dateien und Verzeichnisse auf das Band.
	<command>tar</command> unterst&uuml;tzt zwar nicht den vollen Umfang
	von Optionen, die bei
        &man.cpio.1; zur Verf&uuml;gung stehen, aber daf&uuml;r erfordert
        <command>tar</command> nicht die ungew&ouml;hnliche Kommando-Pipeline,
	die <command>cpio</command> verwendet.</para>
      
      <indexterm><primary><command>tar</command></primary></indexterm>
      <para>Die meisten Versionen von <command>tar</command> unterst&uuml;tzen
        keine Backups &uuml;ber das Netzwerk.  Die GNU-Version von
	<command>tar</command> die in FreeBSD verwendet wird, unterst&uuml;tzt
	jedoch entfernte Ger&auml;te mit der gleichen Syntax wie
	<command>rdump</command>.  Um <command>tar</command>
        f&uuml;r ein Exabyte-Bandlaufwerk auf einer Sun
        namens <hostid>komodo</hostid> auszuf&uuml;hren, muss folgendes
        Kommando aufgerufen werden:</para>

      <screen>&prompt.root; <userinput>/usr/bin/tar cf komodo:/dev/nrsa8 . 2&gt;&amp;1</userinput></screen>

      <para>Bei den Versionen ohne Unterst&uuml;tzung
        f&uuml;r entfernte Ger&auml;te kann man die Daten &uuml;ber eine
        Pipeline und <command>rsh</command> an ein entferntes Laufwerk
	senden.</para>

        <screen>&prompt.root; <userinput>tar cf - . | rsh <replaceable>hostname</replaceable> dd of=<replaceable>tape-device</replaceable> obs=20b</userinput></screen>

        <para>Wenn Sie Bedenken bez&uuml;glich der Sicherheit beim Backup
          &uuml;ber das Netz haben, sollten Sie <command>ssh</command> anstatt
          <command>rsh</command> benutzen.</para>
    </sect2>
    
    <sect2>
      <title>Cpio</title>
      <indexterm>
	<primary>Backup Software</primary>
	<secondary><command>cpio</command></secondary>
      </indexterm>
      
      <para>&man.cpio.1; ist das urspr&uuml;ngliche Unix-Programm zum
        Dateitransfer mit magnetischen Medien.  <command>cpio</command>
	hat (neben vielen
        anderen Leistungsmerkmalen) Optionen zum Byte-Swapping, zum Schreiben
        einer Anzahl verschiedener Archivformate und zum Weiterleiten von
        Daten an andere Programme &uuml;ber eine Pipeline.  Dieses letzte
        Leistungsmerkmal macht <command>cpio</command> zu einer
	ausgezeichneten Wahl f&uuml;r Installationsmedien.  Leider kann
	<command>cpio</command> keine
        Dateib&auml;ume durchlaufen, so dass eine Liste der zu bearbeitenden
        Dateien &uuml;ber <filename>stdin</filename> angegeben werden
        muss.</para>
      
      <para><command>cpio</command> unterst&uuml;tzt keine Backups
	&uuml;ber das Netzwerk.  Man kann aber eine Pipeline und
	<command>rsh</command> verwenden, um
        Daten an ein entferntes Bandlaufwerk zu senden.</para>

      <screen>&prompt.root; <userinput>for f in <replaceable>directory_list; do</replaceable></userinput>
<userinput>find $f >> backup.list</userinput>
<userinput>done</userinput>
&prompt.root; <userinput>cpio -v -o --format=newc < backup.list | ssh <replaceable>user</replaceable>@<replaceable>host</replaceable> "cat > <replaceable>backup_device</replaceable>"</userinput></screen>

      <para>Dabei steht <replaceable>directory_list</replaceable> f&uuml;r
	eine Aufz&auml;hlung der Verzeichnisse, die Sie sichern wollen.
	<replaceable>user</replaceable>@<replaceable>host</replaceable>
	gibt den Benutzer auf dem Zielrechner an, der die Sicherung
	laufen l&auml;sst.  Der Ort der Sicherung wird durch
	<replaceable>backup_device</replaceable> angegeben
	(z.B. <filename>/dev/nrsa0</filename>).</para>
    </sect2>
    
    <sect2>
      <title><command>pax</command></title>
      <indexterm>
	<primary>Backup Software</primary>
	<secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>
      
      <para>&man.pax.1; ist die Antwort von IEEE/POSIX auf
	<command>tar</command> und <command>cpio</command>.
        &Uuml;ber die Jahre hinweg sind die verschiedenen
        Versionen von <command>tar</command> und <command>cpio</command> leicht
	inkompatibel geworden.  Daher hat POSIX, statt eine Standardisierung
	zwischen diesen auszufechten, ein neues Archivprogramm geschaffen.
	<command>pax</command> versucht viele der unterschiedlichen 
	<command>cpio</command>- und <command>tar</command>-Formate zu lesen
        und zu schreiben, au&szlig;erdem einige neue, eigene Formate.  Die
        Kommandostruktur &auml;hnelt eher <command>cpio</command> als
	<command>tar</command>.</para>
    </sect2>
    
    <sect2 id="backups-programs-amanda">
      <title><application>Amanda</application></title>
      <indexterm>
	<primary>Backup Software</primary>
	<secondary><application>Amanda</application></secondary>
      </indexterm>
      <indexterm><primary><application>Amanda</application></primary></indexterm>
      
      <!-- Remove link until <port> tag is available -->
      <para><application>Amanda</application>
        (Advanced Maryland Network Disk Archiver) ist ein
        Client/Server-Backupsystem, nicht nur ein einzelnes Programm.  Ein
        Amanda-Server kann auf einem einzigen Bandlaufwerk Datensicherungen
        von jeder beliebigen Anzahl von Computern speichern, sofern auf diesen
        jeweils ein Amanda-Client l&auml;uft und sie &uuml;ber Netzwerk mit
        dem Amanda-Server verbunden sind.</para>
      
      <para>Ein h&auml;ufiges Problem bei Standorten mit einer Anzahl
        gro&szlig;er Festplatten ist, dass das Kopieren der Daten auf Band
        langsamer vor sich geht als solche Daten anfallen.  Amanda l&ouml;st
        dieses Problem durch Verwendung einer <quote>Holding Disk</quote>,
	einer Festplatte
        zum gleichzeitigen Zwischenspeichern mehrerer Dateisysteme.</para>
      
      <para>F&uuml;r Datensicherungen &uuml;ber einen l&auml;ngeren Zeitraum
        erzeugt Amanda <quote>Archivsets</quote> von allen Dateisystemen,
	die in Amanda's
        Konfigurationsdatei genannt werden.  Ein Archivset ist eine Gruppe von
        B&auml;ndern mit vollen Backups und Reihen von inkrementellen (oder
        differentiellen) Backups, die jeweils nur die Unterschiede zum vorigen
        Backup enthalten.  Zur Wiederherstellung von besch&auml;digten
        Dateisystemen ben&ouml;tigt man Das Letzte volle Backup und alle
        darauf folgenden inkrementellen Backups.</para>
      
      <para>Die Konfigurationsdatei erm&ouml;glicht die Feineinstellung der
        Backups und des Netzwerkverkehrs von Amanda.  Amanda kann zum
        Schreiben der Daten auf das Band jedes der oben beschriebenen
        Backuprogramme verwenden.  Amanda ist nicht Teil des Basissystems,
	Sie m&uuml;ssen Amanda &uuml;ber die Ports-Sammlung oder als Paket
	installieren.</para>
    </sect2>
    
    <sect2>
      <title>Tue nichts</title>
      
      <para><quote>Tue nichts</quote> ist kein Computerprogramm, sondern die
        am h&auml;ufigsten angewendete Backupstrategie.  Diese kostet nichts,
        man muss keinen Backupplan befolgen, einfach nur nein sagen.  Wenn
        etwas passiert, einfach grinsen und ertragen!</para>
      
      <para>Wenn Ihre Zeit und Ihre Daten nicht so wichtig sind, dann ist
        die Strategie <quote>Tue nichts</quote> das geeignetste Backupprogramm
        f&uuml;r Ihren Computer.  Aber Unix ist ein n&uuml;tzliches Werkzeug,
	Sie m&uuml;ssen damit rechnen, dass Sie innerhalb von sechs Monaten
	eine Sammlung von Dateien haben, die f&uuml;r Sie wertvoll geworden
        sind.</para>
      
      <para><quote>Tue nichts</quote> ist die richtige Backupmethode f&uuml;r
        <filename>/usr/obj</filename> und andere Verzeichnisb&auml;ume, die
        vom Computer exakt wiedererzeugt werden k&ouml;nnen.  Ein Beispiel
        sind die Dateien, die diese Handbuchseiten darstellen &mdash; sie
        wurden aus Quelldateien im Format <acronym>SGML</acronym> erzeugt.
	Es ist nicht n&ouml;tig, Sicherheitskopien der Dateien in den
        sekund&auml;ren Formaten wie etwa <acronym>HTML</acronym> zu
        erstellen.  Die Quelldateien in <acronym>SGML</acronym> sollten jedoch
        in die regelm&auml;&szlig;igen Backups mit einbezogen werden.</para>
    </sect2>
    
    <sect2>
      <title>Welches Backup-Programm ist am Besten?</title>
      <indexterm>
	<primary>LISA</primary>
      </indexterm>
      
      <para><command>dump</command>, <emphasis>Punkt und Schluss.</emphasis>
	Elizabeth&nbsp;D. Zwicky hat alle hier genannten Backup-Programme
	bis zur Ersch&ouml;pfung ausgetestet.  Ihre eindeutige Wahl zur
	Sicherung aller Daten mit Ber&uuml;cksichtigung aller Besonderheiten
	von Unix-Dateisystemen ist <command>dump</command>.</para>
      
      <para>Elizabeth erzeugte Dateisysteme mit einer gro&szlig;en Vielfalt
        ungew&ouml;hnlicher Bedingungen (und einiger gar nicht so
        ungew&ouml;hnlicher) und testete jedes Programm durch ein Backup und
        eine Wiederherstellung dieser Dateisysteme.  Unter den Besonderheiten
        waren Dateien mit L&ouml;chern, Dateien mit L&ouml;chern und einem
        Block mit Null-Zeichen, Dateien mit ausgefallenen Buchstaben im
        Dateinamen, unlesbare und nichtschreibbare Dateien,
        Ger&auml;tedateien, Dateien, deren L&auml;nge sich w&auml;hrend des
        Backups &auml;ndert, Dateien, die w&auml;hrend des Backups erzeugt und
        gel&ouml;scht werden, u.v.m.  Sie berichtete &uuml;ber ihre Ergebnisse
        in LISA V im Oktober 1991, s. <ulink
          url="http://reality.sgi.com/zwicky_neu/testdump.doc.html">Torture-testing
          Backup and Archive Programs</ulink>.</para>
    </sect2>
    
    <sect2>
      <title>Die Wiederherstellung in einem Notfall</title>
      
      <sect3>
        <title>Vor dem Ungl&uuml;ck</title>
        
        <para>Es sind nur vier Vorkehrungen zu treffen, um auf jedes
          erdenkliche Ungl&uuml;ck vorbereitet zu sein.</para>
	<indexterm>
	  <primary><command>disklabel</command></primary>
	</indexterm>
        
        <para>Als erstes drucken Sie das Disklabel jeder Ihrer Festplatten
          (z.B. mittels <command>disklabel da0 | lpr</command>), die
          Partitions- und Dateisystemtabelle jeder Festplatte (mit
          <filename>/etc/fstab</filename>) sowie alle Bootmeldungen, jeweils
          in zweifacher Ausfertigung.</para>
        
	<indexterm><primary>fix-it floppies</primary></indexterm>
        <para>Zweitens, &uuml;berzeugen Sie sich, dass sowohl die
          Bootdiskette als auch die Reparaturdiskette
          (<filename>boot.flp</filename> bzw.  <filename>fixit.flp</filename>)
          all Ihre Ger&auml;te ansprechen k&ouml;nnen.  Die einfachste Methode
          dies nachzupr&uuml;fen ist, Ihren Rechner mit der Boot-Diskette im
          Floppylaufwerk neu zu starten und die Bootmeldungen zu durchzusehen.
          Wenn all Ihre Ger&auml;te aufgelistet sind und funktionieren,
          k&ouml;nnen Sie weiter zu Schritt drei gehen.</para>
        
        <para>Ist das nicht der Fall, m&uuml;ssen Sie sich eine eigene
          Version der beiden zum Booten ben&ouml;tigten Disketten erstellen.
          Diese m&uuml;ssen einen Kernel enthalten, der all Ihre Platten
          mounten kann und Zugriff auf Ihr Bandlaufwerk gestattet.  Diese
          Disketten m&uuml;ssen ferner folgende Programme enthalten:
          <command>fdisk</command>, <command>disklabel</command>,
	  <command>newfs</command>, <command>mount</command> sowie
          jedes Backup-Programm, das Sie verwenden.  Diese Programme
          m&uuml;ssen statisch gelinkt sein.  Falls Sie <command>dump</command>
          verwenden, muss die Diskette auch <command>restore</command>
	  enthalten.</para>
        
        <para>Drittens, machen Sie oft Backups auf Band.  Jede &Auml;nderung
          seit Ihrem letzten Backup kann unwiederbringlich verloren gehen.
          Versehen Sie die Backup-B&auml;nder mit Schreibschutz.</para>
        
        <para>Viertens, testen Sie aus, wie die Disketten (entweder
          <filename>boot.flp</filename> und <filename>fixit.flp</filename>
          oder Ihre beiden eigenen Disketten aus Schritt zwei) und die
          B&auml;nder mit den Backups zu behandeln sind.  Machen Sie sich
          Notizen zu diesem Test.  Bewahren Sie diese Notizen zusammen mit den
          Bootdisketten, den Ausdrucken und den B&auml;ndern mit den Backups
          auf.  Wenn der Ernstfall eintritt, werden Sie vielleicht so genervt
          sein, dass Sie ohne Ihre Notizen vielleicht das Backup auf Ihren
          B&auml;ndern zerst&ouml;ren.  (Wie das geht?  Man braucht nur
          ungl&uuml;cklicherweise den Befehl <command>tar cvf
            /dev/rsa0</command> einzugeben um ein Band zu
          &uuml;berschreiben).</para>
        
        <para>Als zus&auml;tzliche Sicherheitsvorkehrung, kann man jeweils
          die Disketten und B&auml;nder zweifach erstellen.  Eine der Kopien
          sollte an einem entfernten Standort aufbewahrt werden.  Ein
          entfernter Standort ist NICHT der Keller im gleichen
          B&uuml;rogeb&auml;ude.  Eine Anzahl von Firmen im World Trade Center
          musste diese Lektion auf die harte Tour lernen.  Ein entfernter
          Standort sollte von Ihrem Computer und Ihren Festplatten
          physikalisch durch eine erhebliche Entfernung getrennt sein.</para>
        
	<example>
          <title>Ein Beispielskript zum Erstellen eigener Bootdisketten</title>
        
        <programlisting><![ CDATA [#!/bin/sh
#
# Erstellen einer Diskette zur Wiederherstellung eines Backups
#
# Diskette formatieren
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
echo "Bad floppy, please use a new one"
exit 1
fi

# Die Bootbloecke auf die Diskette schreiben
#
disklabel -w -B /dev/fd0c fd1440

#
# Dateisystem fuer die (einzige) Partition auf der Diskette
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# Diskette mounten
#
mount /dev/fd0a /mnt

#
# Benoetigte Verzeichnisse erstellen
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# fuer die Root-Partition
mkdir /mnt/tmp
mkdir /mnt/var

#
# die Verzeichnisse bevoelkern
#
if [ ! -x /sys/compile/MINI/kernel ] 
then
cat << EOM
Der MINI_Kernel existiert nicht, bitte einen erzeugen.
Hier ein Beispiel einer Konfigurationsdatei:
#
# MINI -- Ein FreeBSD-Kernel, der auf die Diskette passt.
#
machine		"i386"
cpu		"I486_CPU"
ident		MINI
maxusers	5

options		INET			# notwendig fuer _tcp _icmpstat _ipstat
#               _udpstat _tcpstat _udb
options		FFS			#Berkeley Fast File System
options		FAT_CURSOR		#Blockcursor in syscons oder pccons
options		SCSI_DELAY=15		#traue nicht Joe's SCSI-Geraet
options		NCONS=2		        #2 virtuelle Konsolen
options		USERCONFIG		#Konfiguration mit -c XXX zulassen


config		kernel	root on da0 swap on da0 and da1 dumps on da0

controller	isa0
controller	pci0

controller	fdc0	at isa? port "IO_FD1" bio irq 6 drq 2 vector fdintr
disk		fd0	at fdc0 drive 0

controller	ncr0

controller	scbus0

device		sc0	at isa? port "IO_KBD" tty irq 1 vector scintr
device		npx0	at isa? port "IO_NPX" irq 13 vector npxintr

device		da0
device		da1
device		da2

device		sa0

pseudo-device	loop		# von INET benoetigt
pseudo-device	gzip		# komprimierte a.out-Dateien ausfuehren
EOM
exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init > /mnt/sbin/init
gzip -c -best /sbin/fsck > /mnt/sbin/fsck
gzip -c -best /sbin/mount > /mnt/sbin/mount
gzip -c -best /sbin/halt > /mnt/sbin/halt
gzip -c -best /sbin/restore > /mnt/sbin/restore

gzip -c -best /bin/sh > /mnt/bin/sh
gzip -c -best /bin/sync > /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# Geraetedateien erstellen
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# Minimale Dateisystemtabelle erstellen
#
cat > /mnt/etc/fstab <<EOM
/dev/fd0a	/	ufs	rw 1 1
EOM

#
# Minimale Passwortdatei erstellen
#
cat > /mnt/etc/passwd <<EOM
root:*:0:0:Charlie &:/root:/bin/sh
EOM

cat > /mnt/etc/master.passwd <<EOM
root::0:0::0:0:Charlie &:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# Die Diskette aushaengen und den Benutzer informieren
#
/sbin/umount /mnt
echo "Die Diskette wurde ausgehaengt und ist jetzt bereit."]]></programlisting>

	</example>
      </sect3>
      
      <sect3>
        <title>Nach dem Ungl&uuml;ck</title>
        
        <para>Die Schl&uuml;sselfrage ist, ob Ihre Hardware &uuml;berlebt
          hat.  Denn da Sie ja regelm&auml;&szlig;ig Backups angefertigt
          haben, brauchen Sie sich um die Software keine Sorgen zu
          machen.</para>
        
        <para>Falls die Hardware besch&auml;digt wurde, ersetzen Sie zuerst
          die defekten Teile.</para>
        
        <para>Falls die Hardware funktioniert, &uuml;berpr&uuml;fen Sie die
          Disketten.  Wenn Sie eigene Bootdisketten verwenden, booten Sie im
          Single-User-Modus (geben dazu Sie <literal>-s</literal> am
          Boot-Prompt <prompt>boot:</prompt> ein).  &Uuml;berspringen Sie den
          folgenden Paragrafen.</para>
        
        <para>Wenn Sie die Standarddisketten <filename>boot.flp</filename>
          und <filename>fixit.flp</filename> verwenden, lesen Sie hier weiter.
          Legen Sie die Bootdiskette <filename>boot.flp</filename> in das
          erste Floppylaufwerk ein und starten Sie den Computer.  Wie
          &uuml;blich wird dann das originale Installationsmen&uuml; von
          FreeBSD gestartet.  W&auml;hlen Sie die Option
          <literal>Fixit--Repair mode with CD-ROM or floppy</literal>.  Legen
          Sie die Diskette <filename>fixit.flp</filename> ein, wenn danach
          gefragt wird.  <command>restore</command> und die anderen Programme,
          die Sie ben&ouml;tigen, befinden sich dann in
          <filename>/mnt2/stand</filename>.</para>
        
        <para>Stellen Sie die Dateisysteme nacheinander, getrennt von
          einander, wieder her.</para>
        
	<indexterm>
	  <primary><command>mount</command></primary>
	</indexterm>
	<indexterm>
	  <primary>Root-Partition</primary>
	</indexterm>
	<indexterm>
	  <primary><command>disklabel</command></primary>
	</indexterm>
	<indexterm>
	  <primary><command>newfs</command></primary>
	</indexterm>
        <para>Versuchen Sie die Root-Partition Ihrer ersten Festplatte
          einzuh&auml;ngen (z.B. mit <command>mount /dev/sd0a
            /mnt</command>).  Wenn das Disklabel besch&auml;digt wurde,
	  benutzen Sie <command>disklabel</command> um die Platte
	  neu zu partitionieren und zu benennen und zwar so, dass die
	  Festplatte mit dem Label &uuml;bereinstimmt, das Sie
	  ausgedruckt und aufbewahrt haben.</para>
        
        <para>Verwenden Sie <command>newfs</command> um neue Dateisysteme
	  auf den
          Partitionen anzulegen.  H&auml;ngen Sie nun die Root-Partition der
          Festplatte mit Schreibzugriff ein (mit <command>mount -u -o rw
            /mnt</command>).  Benutzen Sie Ihr Backup-Programm um die Daten
          f&uuml;r das jeweilige Dateisystem aus den Backup-B&auml;ndern
          wieder her zu stellen (z.B. durch <command>restore vrf
            /dev/sta</command>).  H&auml;ngen Sie das Dateisystem wieder aus
          (z.B. durch <command>umount /mnt</command>).  Wiederholen Sie diesen
          Ablauf f&uuml;r jedes betroffene Dateisystem.</para>
        
        <para>Sobald Ihr System wieder l&auml;uft, machen Sie gleich wieder
          ein vollst&auml;ndiges Backup auf neue B&auml;nder.  Denn die
          Ursache f&uuml;r den Absturz oder den Datenverlust kann wieder
          zuschlagen.  Eine weitere Stunde, die Sie jetzt noch
          dranh&auml;ngen, kann Ihnen sp&auml;ter ein weiteres Missgeschick
          ersparen.</para>
      </sect3>
      
<![ %not.published; [

      <sect3>
        <title>* Ich habe mich nicht auf Missgeschicke vorbereitet - was
          nun?</title>
        
        <para></para>
      </sect3>

]]>

    </sect2>
  </sect1>

  <sect1 id="disks-virtual">
    <title>Netzwerk-, Speicher- und dateibasierte Dateisysteme</title>
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>virtuelle</secondary>
    </indexterm>

    <para>Neben Laufwerken, die sich physikalisch im Rechner befinden
      wie Floppylaufwerke, CDs, Festplatten usw., kann FreeBSD auch
      mit anderen Laufwerken, den <firstterm>virtuellen Laufwerken</firstterm>,
      umgehen.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>speicherbasierte</secondary>
    </indexterm>
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>RAM-Disks</secondary>
    </indexterm>
    <para>Diese beinhalten Netzwerkdateisysteme wie
      <!--
      <link linkend="nfs">Network Filesystem</link> und Coda,
      -->
      Network Filesystem und Coda,
      speicherbasierte Dateisysteme wie
      <link linkend="disks-md">md</link> und auf Dateien basierende
      Dateisysteme, die mit <link linkend="disks-vnconfig">vnconfig</link>
      oder <command>mdconfig</command> erstellt wurden.</para>

    <sect2 id="disks-vnconfig">
      <title>vnconfig: dateibasierte Dateisysteme</title>
      <indexterm>
	<primary>Laufwerke</primary>
	<secondary>dateibasierte</secondary>
      </indexterm>

      <para>Mit &man.vnconfig.8; werden vnode Pseudo-Platten
        konfiguriert und aktiviert.  Ein <firstterm>vnode</firstterm>
	stellt eine Datei dar, auf der Dateioperationen ablaufen.
	Das bedeutet, dass &man.vnconfig.8; Dateien benutzt,
	um ein Dateisystem zu erstellen und zu verwalten.  Damit
	ist es z.B. m&ouml;glich, Dateien, die Images von Floppies
	oder CDs enthalten, anzuh&auml;ngen.</para>

      <para>Um ein existierendes Image eines Dateisystems 
	anzuh&auml;ngen:</para>

      <example>
	<title>Anh&auml;ngen eines existierenden Images mit vnconfig</title>

	<screen>&prompt.root; <userinput>vnconfig vn<replaceable>0</replaceable> <replaceable>diskimage</replaceable></userinput>
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>Um ein neues Dateisystem mit vnconfig anzulegen:</para>

      <example>
	<title>Anlegen eines dateibasierten Laufwerks</title>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>vnconfig -s labels -c vn<replaceable>0</replaceable> <replaceable>newimage</replaceable></userinput>
&prompt.root; <userinput>disklabel -r -w vn<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs vn<replaceable>0</replaceable>c</userinput>
Warning: 2048 sector(s) in last cylinder unallocated
/dev/rvn0c:     10240 sectors in 3 cylinders of 1 tracks, 4096 sectors
        5.0MB in 1 cyl groups (16 c/g, 32.00MB/g, 1280 i/g)
super-block backups (for fsck -b #) at:
 32
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2 id="disks-md">
      <title>md: RAM-Disks</title>
      <indexterm>
	<primary>Laufwerke</primary>
	<secondary>speicherbasierte</secondary>
      </indexterm>
      <indexterm>
	<primary>Laufwerke</primary>
	<secondary>RAM-Disks</secondary>
      </indexterm>

      <para><devicename>md</devicename> ist ein einfaches und effizientes
	Mittel um RAM-Disks zu erstellen.</para>

      <para>Nehmen Sie einfach ein Dateisystem, dass Sie
	z.B. mit &man.vnconfig.8; vorbereitet haben:</para>

      <example>
	<title>md Speicher Laufwerk</title>

	<screen>&prompt.root; <userinput>dd if=<replaceable>newimage</replaceable> of=/dev/md<replaceable>0</replaceable></userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mount /dev/md<replaceable>0c</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>
  </sect1>

  <sect1 id="snapshots">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <!-- 15 JUL 2002 -->
    </sect1info>

    <title>Schnappsch&uuml;sse von Dateisystemen</title>

    <indexterm>
      <primary>Schnappsch&uuml;sse von Dateisystemen</primary>
      <secondary>Schnappsch&uuml;sse</secondary>
    </indexterm>
    
    <para>Zusammen mit <link linkend="soft-updates">Softupdates</link>
      bietet FreeBSD&nbsp;5.0 eine neue Funktion: Schnappsch&uuml;sse von
      Dateisystemen.</para>

    <para>Schnappsch&uuml;sse sind Dateien, die ein Abbild eines
      Dateisystems enthalten und m&uuml;ssen auf dem jeweiligen
      Dateisystem erstellt werden.  Pro Dateisystem darf es maximal
      20&nbsp;Schnappsch&uuml;sse, die im Superblock vermerkt werden, geben.
      Schnappsch&uuml;sse bleiben erhalten, wenn das Dateisystem abgehangen,
      neu eingehangen oder das System neu gestartet wird.  Wenn Sie einen
      Schnappschuss nicht mehr ben&ouml;tigen, k&ouml;nnen Sie ihn
      mit &man.rm.1; l&ouml;schen.  Es ist egal, in welcher Reihenfolge
      Schnappsch&uuml;sse gel&ouml;scht werden.  Es kann allerdings
      vorkommen, dass nicht der gesamte Speicherplatz
      wieder freigegeben wird, da ein anderer
      Schnappschuss einen Teil der entfernten Bl&ouml;cke f&uuml;r sich
      beanspruchen kann.</para>

    <para>Schnappsch&uuml;sse werden mit dem <option>schg</option> Flag 
      (siehe &man.chflags.1;) angelegt, um sicherzustellen, das nicht
      einmal <username>root</username> den Schnappschuss beschreiben
      kann.  In &man.unlink.1; wird allerdings f&uuml;r
      Schnappsch&uuml;sse eine Ausnahme gemacht: Sie d&uuml;rfen
      gel&ouml;scht werden, ohne das das <option>schg</option> Flag
      vorher entfernt werden muss.</para>

    <para>Schnappsch&uuml;sse werden mit &man.mount.8; erstellt.  Das
      folgende Kommando legt einen Schnappschuss von
      <filename>/var</filename> in <filename>/var/snapshot/snap</filename>
      ab:</para>

<screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

    <para>Nachdem ein Schnappschuss erstellt wurde, k&ouml;nnen Sie
      ihn f&uuml;r verschiedene Zwecke benutzen:</para>
	
    <itemizedlist>
      <listitem>
	<para>Sie k&ouml;nnen den Schnappschuss f&uuml;r die
	  Datensicherung benutzen und ihn auf eine CD oder ein Band
	  schreiben.</para>
      </listitem>
	
      <listitem>
	<para>Sie k&ouml;nnen den Schnappschuss mit &man.fsck.8;
	  pr&uuml;fen.  Wenn das Dateisystem zum Zeitpunkt der Erstellung
	  des Schnappschusses in Ordnung war, sollte &man.fsck.8; immer
	  erfolgreich durchlaufen.</para>
	  <!-- This is essentially what the
	  background &man.fsck.8; process does.-->
      </listitem>
	
      <listitem>
	<para>Sie k&ouml;nnen den Schnappschuss mit &man.dump.8;
	  sichern.  Sie erhalten dann eine konsistente Sicherung des
	  Dateisystems zu dem Zeitpunkt, der durch den Zeitstempel des
	  Schnappschusses gegeben ist.</para>

	<warning><para>Zurzeit aktualisiert &man.dump.8; noch nicht die
	  Zeitstempel in <filename>/etc/dumpdates</filename>.  Daher
	  sollten Sie Schnappsch&uuml;sse nicht f&uuml;r Sicherungen
	  verwenden.</para></warning>
      </listitem>
	
      <listitem>
	<para>Sie k&ouml;nnen einen Schnappschuss in den
	  Verzeichnisbaum einh&auml;ngen und sich dann den Zustand des 
	  Dateisystems zu dem Zeitpunkt ansehen, an dem der
	  Schnappschuss erstellt wurde.  Der folgende Befehl
	  h&auml;ngt den Schnappschuss
	  <filename>/var/snapshot/snap</filename> ein:</para>

<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput></screen>
<screen>&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>

      </listitem>
    </itemizedlist>

    <para>Sie k&ouml;nnen sich nun den eingefrorenen Stand des
      <filename>/var</filename> Dateisystems unterhalb von
      <filename>/mnt</filename> ansehen.  Mit Ausnahme der fr&uuml;heren
      Schnappsch&uuml;sse, die als leere Dateien auftauchen, wird alles
      so aussehen, wie zu dem Zeitpunkt als der Schnappschuss
      erstellt wurde.  Wenn Sie den Schnappschuss nicht mehr
      ben&ouml;tigen, k&ouml;nnen Sie ihn, wie nachfolgend gezeigt,
      abh&auml;ngen:</para>

<screen>&prompt.root; <userinput>umount /mnt</userinput></screen>
<screen>&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

    <para>Weitere Informationen &uuml;ber Softupdates und
      Schnappsch&uuml;sse von Dateisystemen sowie technische Artikel finden
      Sie auf der <ulink url="http://www.mckusick.com/">Webseite
        von Marshall Kirk McKusick</ulink>.</para>
  </sect1>
  
  <sect1 id="quotas">
    <title>Dateisystem Quotas</title>
    <indexterm>
      <primary>Accounting</primary>
      <secondary>Plattenplatz</secondary>
    </indexterm>
    <indexterm><primary>Disk Quotas</primary></indexterm>

    <para>Quotas sind eine optionale Funktion des Betriebssystems,
      die es Ihnen erlauben, den Plattenplatz und/oder die Anzahl
      der Dateien eines Benutzers oder der Mitglieder einer Gruppe,
      auf Dateisystemebene zu beschr&auml;nken.  Oft wird dies
      auf Timesharing-Systemen (Mehrbenutzersystemen) genutzt, da
      es dort erw&uuml;nscht ist, die Ressourcen, die ein Benutzer oder
      eine Gruppe von Benutzern belegen k&ouml;nnen, zu limitieren.  Das
      verhindert, dass ein Benutzer oder eine Gruppe von Benutzern
      den ganzen verf&uuml;gbaren Plattenplatz belegt.</para>

    <sect2>
      <title>Konfiguration des Systems, um Quotas zu
	aktivieren</title>

      <para>Bevor Quotas benutzt werden k&ouml;nnen, m&uuml;ssen
	sie im Kernel konfiguriert werden, wozu die folgende Zeile
	der Kernel Konfiguration hinzugef&uuml;gt wird:</para>

      <programlisting>options QUOTA</programlisting>

      <para>Im gew&ouml;hnlichen <filename>GENERIC</filename> Kernel
        sind Quotas nicht aktiviert, so dass Sie einen angepassten
	Kernel konfigurieren und bauen m&uuml;ssen, um Quotas zu
	benutzen.  Weitere Informationen
	finden Sie in <xref linkend="kernelconfig">.</para>

      <para>Durch Hinzuf&uuml;gen der folgenden Zeile in
        <filename>/etc/rc.conf</filename> wird das Quota-System
	aktiviert:</para>

      <programlisting>enable_quotas="YES"</programlisting>
      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>&uuml;berpr&uuml;fen</secondary>
      </indexterm>

      <para>Um den Start des Quota-Systems zu beeinflussen, steht
	eine weitere Variable zur Verf&uuml;gung.  Normalerweise
	wird beim Booten die Integrit&auml;t der Quotas auf
	allen Dateisystemen mit <command>quotacheck</command>
	&uuml;berpr&uuml;ft.  <command>quotacheck</command> stellt
	sicher, dass die Quota-Datenbank mit den Daten auf
	einem Dateisystem &uuml;bereinstimmt.  Dies ist allerdings
	ein sehr zeitraubender Prozess, der die Zeit, die
	das System zum Booten braucht, signifikant beeinflusst.
	Eine Variable in <filename>/etc/rc.config</filename> erlaubt es Ihnen,
	diesen Schritt zu &uuml;berspringen:</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>Wenn Sie ein FreeBSD vor 3.2-RELEASE benutzen, ist
	die Konfiguration einfacher.  In <filename>/etc/rc.conf</filename>
	setzen Sie nur eine Variable:</para>

      <programlisting>check_quotas="YES"</programlisting>

      <para>Schlie&szlig;lich m&uuml;ssen Sie noch in 
	<filename>/etc/fstab</filename> die Plattenquotas auf
	Dateisystemebene aktivieren.  Dort k&ouml;nnen Sie 
	f&uuml;r alle Dateisysteme Quotas f&uuml;r Benutzer, Gruppen
	oder f&uuml;r beide aktivieren.</para>

      <para>Um Quotas pro Benutzer f&uuml;r ein Dateisystem zu
        aktivieren, geben Sie f&uuml;r dieses Dateisystem die
	Option <literal>userquota</literal> im Feld Optionen von
	<filename>/etc/fstab</filename> an.  Beispiel:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>Um Quotas f&uuml;r Gruppen einzurichten, verwenden
	Sie <literal>groupquota</literal> anstelle von
	<literal>userquota</literal>.  Um Quotas f&uuml;r Benutzer
	und Gruppen einzurichten, &auml;ndern Sie den Eintrag
	wie folgt ab:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>Die Quotas werden jeweils im Rootverzeichnis des Dateisystems
	unter dem Namen <filename>quota.user</filename> f&uuml;r 
	Benutzer-Quotas und <filename>quota.group</filename> f&uuml;r
	Gruppen-Quotas abgelegt.  Obwohl &man.fstab.5; beschreibt,
	dass diese Dateien an anderer Stelle gespeichert werden 
	k&ouml;nnen, wird das nicht empfohlen, da es den Anschein hat,
	dass die verschiedenen Quota-Utilities das nicht richtig
	unterst&uuml;tzen.</para>

      <para>Jetzt sollten Sie Ihr System mit dem neuen Kernel booten.
	<filename>/etc/rc</filename> wird dann automatisch die
	richtigen Kommandos aufrufen, die die Quota-Dateien f&uuml;r
	alle Quotas, die Sie in <filename>/etc/fstab</filename>
	definiert haben, anlegen.  Deshalb m&uuml;ssen vorher auch keine
	leeren Quota-Dateien angelegt werden.</para>

      <para>Normalerweise brauchen Sie die Kommandos 
	<command>quotacheck</command>, <command>quotaon</command> oder
	<command>quotaoff</command> nicht h&auml;ndisch aufzurufen,
	obwohl Sie vielleicht die entsprechenden Seiten im
	Manual lesen sollten, um sich mit ihnen vertraut 
	zu machen.</para>
    </sect2>

    <sect2>
      <title>Setzen von Quota-Limits</title>
      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>Limits</secondary>
      </indexterm>

      <para>Nachdem Sie Quotas in Ihrem System aktiviert haben, sollten
        Sie &uuml;berpr&uuml;fen, dass Sie auch tats&auml;chlich
	aktiviert sind.  F&uuml;hren Sie dazu einfach den folgenden
	Befehl aus:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>
	  
      <para>F&uuml;r jedes Dateisystem, auf dem Quotas aktiviert sind,
	sollten Sie eine Zeile mit der Plattenauslastung und den
	aktuellen Quota-Limits sehen.</para>

      <para>Mit <command>edquota</command> k&ouml;nnen Sie nun
	Quota-Limits setzen.</para>

      <para>Sie haben mehrere M&ouml;glichkeiten, die Limits f&uuml;r
	den Plattenplatz, den ein Benutzer oder eine Gruppe verbrauchen
	kann, oder die Anzahl der Dateien, die angelegt werden d&uuml;rfen,
	festzulegen.  Die Limits k&ouml;nnen auf dem Plattenplatz 
	(Block-Quotas) oder der Anzahl der Dateien (Inode-Quotas) oder
	einer Kombination von beiden basieren.
	Jedes dieser Limits wird weiterhin in zwei Kategorien geteilt:
	Hardlimits und Softlimits.</para>

      <indexterm><primary>Hardlimit</primary></indexterm>
      <para>Ein Hardlimit kann nicht &uuml;berschritten werden.
	Hat der Benutzer einmal ein Hardlimit erreicht, so kann er
	auf dem betreffenden Dateisystem keinen weiteren Platz mehr
	beanspruchen.  Hat ein Benutzer beispielsweise ein Hardlimit
	von 500 Bl&ouml;cken auf einem Dateisystem und benutzt davon
	490 Bl&ouml;cke, so kann er nur noch 10 weitere Bl&ouml;cke
	beanspruchen.  Der Versuch, weitere 11 Bl&ouml;cke zu beanspruchen,
	wird fehlschlagen.</para>

      <indexterm><primary>Softlimit</primary></indexterm>
      <para>Im Gegensatz dazu k&ouml;nnen Softlimits f&uuml;r eine
	befristete Zeit &uuml;berschritten werden.  Diese Frist
	betr&auml;gt in der Grundeinstellung
	eine Woche.  Hat der Benutzer das Softlimit &uuml;ber die
	Frist hinaus &uuml;berschritten, so wird das Softlimit in
	ein Hardlimit umgewandelt und der Benutzer kann
	keinen weiteren Platz mehr beanspruchen.  Wenn er einmal
	das Softlimit unterschreitet, wird die Frist wieder
	zur&uuml;ckgesetzt.</para>

      <para>Das folgende Beispiel zeigt die Benutzung von
	<command>edquota</command>.  Wenn <command>edquota</command>
	aufgerufen wird, wird ein Editor, der durch <envar>EDITOR</envar>
	gegeben ist, oder <command>vi</command> falls <envar>EDITOR</envar>
	nicht gesetzt ist, gestartet, in dem Sie die Limits eingeben
	k&ouml;nnen.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: blocks in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: blocks in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>F&uuml;r jedes Dateisystem, auf dem Quotas aktiv sind, 
	sehen Sie zwei Zeilen, eine f&uuml;r die Block-Quotas und die
	andere f&uuml;r die Inode-Quotas.  Um ein Limit zu modifizieren,
	&auml;ndern Sie einfach den angezeigten Wert.  Um beispielsweise
	das Blocklimit dieses Benutzers von einem Softlimit von 50
	und einem Hardlimit von 75 auf ein Softlimit von 500 und
	ein Hardlimit von 600 zu erh&ouml;hen, &auml;ndern Sie
	die Zeile</para>

      <programlisting>/usr: blocks in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>zu:</para>

      <programlisting> /usr: blocks in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>Die neuen Limits sind wirksam, wenn Sie den 
	Editor verlassen.</para>

      <para>Manchmal ist es erw&uuml;nscht, die Limits f&uuml;r einen
	Bereich von UIDs zu setzen.  Dies kann mit der <option>-p</option>
	Option von <command>edquota</command> bewerkstelligt werden.
	Weisen Sie dazu die Limits einem Benutzer zu und rufen danach
	<command>edquota -p protouser startuid-enduid</command> auf.
	Besitzt beispielsweise der Benutzer <username>test</username>
	die gew&uuml;nschten Limits, k&ouml;nnen diese mit
	dem folgenden Kommando f&uuml;r die UIDs 10.000 bis 19.999
	dupliziert werden:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>
	  
      <para>Weitere Informationen erhalten Sie in &man.edquota.8;.</para>
    </sect2>

    <sect2>
      <title>&Uuml;berpr&uuml;fen von Quota-Limits und Plattennutzung</title>
      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>&uuml;berpr&uuml;fen</secondary>
      </indexterm>

      <para>Sie k&ouml;nnen <command>quota</command> oder
	<command>repquota</command> benutzen, um Quota-Limits
	und Plattennutzung zu &uuml;berpr&uuml;fen.  Um die Limits
	oder die Plattennutzung individueller Benutzer und Gruppen
	zu &uuml;berpr&uuml;fen, kann <command>quota</command>
	benutzt werden.  Ein Benutzer kann nur die eigenen Quotas und die
	Quotas der Gruppe, der er angeh&ouml;rt untersuchen.  Nur der
	Superuser darf sich alle Limits ansehen.
	Mit <command>repquota</command> erhalten Sie eine Zusammenfassung
	von allen Limits und der Plattenausnutzung f&uuml;r alle
	Dateisysteme, auf denen Quotas aktiv sind.</para>

      <para>Das folgende Beispiel zeigt die Ausgabe von
	<command>quota -v</command> f&uuml;r einen Benutzer, der
	Quota-Limits auf zwei Dateisystemen besitzt:</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>Frist</secondary>
      </indexterm>
      <para>Im Dateisystem <filename>/usr</filename> liegt der Benutzer
	momentan 15 Bl&ouml;cke &uuml;ber dem Softlimit von
	50 Bl&ouml;cken und hat noch 5 Tage seiner Frist &uuml;brig.
	Der Stern <literal>*</literal> zeigt an, dass der
	Benutzer sein Limit &uuml;berschritten hat.</para>

      <para>In der Ausgabe von <command>quota</command> werden Dateisysteme,
	auf denen ein Benutzer keinen Platz verbraucht, nicht angezeigt,
	auch wenn diesem Quotas zugewiesen wurden.  Mit <option>-v</option>
	werden diese Dateisysteme, wie <filename>/usr/var</filename>
	im obigen Beispiel, angezeigt.</para>
    </sect2>

    <sect2>
      <title>Quotas &uuml;ber NFS</title>
      <indexterm><primary>NFS</primary></indexterm>

      <para>Quotas werden von dem Quota-Subsystem auf dem NFS Server
	erzwungen.  Der &man.rpc.rquotad.8; D&aelig;mon stellt 
	&man.quota.1; die Quota Informationen auf dem NFS Client
	zur Verf&uuml;gung, so dass Benutzer auf diesen
	Systemen ihre Quotas abfragen k&ouml;nnen.</para>

      <para>Aktivieren Sie <command>rpc.rquotad</command> in
	<filename>/etc/inetd.conf</filename> wie folgt:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Anschlie&szlig;end starten Sie <command>inetd</command>
	neu:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
    </sect2>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
