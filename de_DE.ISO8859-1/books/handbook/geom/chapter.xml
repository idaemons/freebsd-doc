<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r41911
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="GEOM">
  <info><title>GEOM: Modulares Framework zur
    Plattentransformation</title>
    <authorgroup>
      <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geschrieben von </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Daniel</firstname><surname>Seuffert</surname></personname><contrib>Übersetzt von </contrib></author>
      <author><personname><firstname>Johann</firstname><surname>Kois</surname></personname></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="geom-synopsis">
    <title>Übersicht</title>

    <indexterm>
      <primary>GEOM</primary>
    </indexterm>
    <indexterm>
      <primary>GEOM Disk Framework</primary>
      <see>GEOM</see>
    </indexterm>

    <para>Dieses Kapitel behandelt den Einsatz von Laufwerken mit
      dem GEOM-Framework in &os;. Dies beinhaltet auch die wichtigen
      <acronym role="Redundant Array of Inexpensive       Disks">RAID</acronym>-Überwachungswerkzeuge, welche das
      Framework zur Konfiguration nutzen. Dieses Kapitel enthält
      keine tiefschürfenden Betrachtungen, wie GEOM I/O nutzt
      oder steuert, sein zugrundeliegendes Subsystem oder den
      Quelltext von GEOM.  Solche Informationen werden in &man.geom.4;
      und seinen zahlreichen <quote>SEE ALSO</quote>-Verweisen
      bereitgestellt. Dieses Kapitel ist auch kein ausführlicher
      Leitfaden für <acronym>RAID</acronym>-Konfigurationen.  Nur
      durch GEOM unterstützte <acronym>RAID</acronym>-Klassen werden
      erörtert.</para>

    <para>Nach Lesen dieses Kapitels werden Sie folgendes
      wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Welche Art von
	  <acronym>RAID</acronym>-Unterstützung durch GEOM
	  verfügbar ist.</para>
      </listitem>

      <listitem>
	<para>Wie man die Basis-Dienstprogramme nutzt, um
	  verschiedene <acronym>RAID</acronym>-Stufen zu
	  konfigurieren, zu manipulieren und zu warten.</para>
      </listitem>

      <listitem>
	<para>Wie man mittels GEOM spiegelt, striped,
	  verschlüsselt und entfernte Laufwerke verbindet.</para>
      </listitem>

      <listitem>
	<para>Wie man an Laufwerken, welche an das GEOM-Framework
	  angeschlossen sind, Fehler behebt.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie:</para>

    <itemizedlist>
      <listitem>
	<para>Verstehen, wie &os; Laufwerke behandelt
	  (<xref linkend="disks"/>).</para>
      </listitem>

      <listitem>
	<para>Wissen wie man einen neuen &os;-Kernel installiert
	  und konfiguriert (<xref linkend="kernelconfig"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="GEOM-intro">
    <title>Einführung in GEOM</title>

    <para>GEOM erlaubt den Zugriff und die Kontrolle von Klassen, wie
      beispielsweise Master Boot Records und
      <acronym>BSD</acronym>-Label, durch die Nutzung von Datenträgern
      (Providern) oder den besonderen Dateien in
      <filename>/dev</filename>. Verschiedene Software
      <acronym>RAID</acronym>-Konfigurationen unterstützend, gewährt
      GEOM transparenten Zugriff auf das Betriebssystem und die
      System-Dienstprogramme.</para>
  </sect1>

  <sect1 xml:id="GEOM-striping">
    <info><title>RAID0 - Striping</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geschrieben von </contrib></author>
	<author><personname><firstname>Murray</firstname><surname>Stokely</surname></personname></author>
      </authorgroup>
    </info>


    <indexterm>
      <primary>GEOM</primary>
    </indexterm>
    <indexterm>
      <primary>Striping</primary>
    </indexterm>

    <para>Striping (stripe = Streifen) fasst verschiedene Laufwerke in
      einem einzigen Datenträger zusammen. In vielen Fällen wird dies
      durch die Nutzung von Hardware-Controllern bewerkstelligt. Das
      GEOM-Subsystem unterstützt Software-<acronym>RAID</acronym>0,
      welches auch als Striping bekannt ist.</para>

    <para>In einem <acronym>RAID</acronym>0-System werden die Daten
      in einzelne Blöcke aufgeteilt, welche über alle
      angeschlossenen Laufwerke in einem Datenfeld (Array) geschrieben
      werden. Anstatt darauf warten zu müssen, dass 256K auf
      ein einzelnes Laufwerk geschrieben werden, kann ein
      <acronym>RAID</acronym>0-System gleichzeitig 64K auf jedes von 4
      Laufwerken schreiben mit entsprechend besserer I/O-Leistung.
      Dieser Durchsatz kann durch die Verwendung mehrerer
      Controller noch zusätzlich gesteigert werden.</para>

    <para>Jedes Laufwerk in einem <acronym>RAID</acronym>0-Stripe
      muss die gleiche Größe haben, da
      I/O-Anforderungen für das Lesen und Schreiben
      abwechselnd auf mehrere Laufwerke parallel erfolgen.</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="geom/striping" align="center"/>
      </imageobject>

      <textobject>
	<phrase>Disk Striping Illustration</phrase>
      </textobject>
    </mediaobject>

    <procedure>
      <title>Erzeugen eines Stripe von unformatierten
	ATA-Platten</title>

      <step>
	<para>Laden Sie das
	  <filename>geom_stripe.ko</filename>-Modul:</para>

	<screen>&prompt.root; <userinput>kldload geom_stripe</userinput></screen>
      </step>

      <step>
	<para>Stellen Sie sicher, dass ein geeigneter Mount-Punkt
	  existiert. Falls dieser Datenträger eine Root-Partition
	  werden soll, dann nutzen Sie zeitweise einen anderen
	  Mount-Punkt, beispielsweise <filename>/mnt</filename>:</para>

	<screen>&prompt.root; <userinput>mkdir /mnt</userinput></screen>
      </step>

      <step>
	<para>Bestimmen Sie die Gerätenamen derjenigen Platten,
	  welche gestriped werden sollen, und erzeugen Sie ein neues
	  Stripe-Gerät.  Das folgende Beispiel verwendet zwei
	  unbenutzte und unpartitionierte
	  <acronym>ATA</acronym>-Platten, die gestriped werden sollen.
	  Die Gerätenamen lauten <filename>/dev/ad2</filename> und
	  <filename>/dev/ad3</filename>:</para>

	<screen>&prompt.root; <userinput>gstripe label -v st0 /dev/ad2 /dev/ad3</userinput>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</screen>

      </step>

      <step>
	<para>Schreiben Sie einen Standard-Label (auch als
	  Partitions-Tabelle bekannt) auf den neuen Datenträger
	  und installieren Sie den normalen Bootstrap-Code:</para>

        <screen>&prompt.root; <userinput>bsdlabel -wB /dev/stripe/st0</userinput></screen>
      </step>

      <step>
	<para>Dieser Prozess sollte zwei weitere Geräte im
	  Verzeichnis <filename>/dev/stripe</filename> (zusätzlich zum
	  Gerät <filename>st0</filename>) erzeugt haben. Diese
	  schliessen <filename>st0a</filename> und
	  <filename>st0c</filename> ein. Nun kann mit
	  <command>newfs</command> ein Dateisystem auf dem Gerät
	  <filename>st0a</filename> erzeugt werden:</para>

	<screen>&prompt.root; <userinput>newfs -U /dev/stripe/st0a</userinput></screen>

	<para>Viele Zahlen rauschen nun über Ihren Bildschirm
	  und nach ein paar Sekunden wird der Prozess abgeschlossen
	  sein. Der Datenträger wurde erzeugt und kann in den
	  Verzeichnisbaum eingehängt werden.</para>
      </step>
    </procedure>

    <para>Um das erzeugte Stripe manuell zu mounten:</para>

    <screen>&prompt.root; <userinput>mount /dev/stripe/st0a /mnt</userinput></screen>

    <para>Um das erzeugte Dateisystem automatisch während des
      Startvorgangs zu mounten, muss die Datenträgerinformation
      in <filename>/etc/fstab</filename> eingetragen werden.  In
      diesem Beispiel wird ein permanenter Mountpunkt namens
      <filename>stripe</filename> erstellt:</para>

  <screen>&prompt.root; <userinput>mkdir /stripe</userinput>
&prompt.root; <userinput>echo "/dev/stripe/st0a /stripe ufs rw 2 2" \</userinput>
    <userinput>&gt;&gt; /etc/fstab</userinput></screen>

    <para>Das <filename>geom_stripe.ko</filename>-Modul muss
      ebenfalls automatisch beim Systemstart geladen werden (durch
      die Aufnahme der folgenden Zeile in die Datei
      <filename>/boot/loader.conf</filename>):</para>

    <screen>&prompt.root; <userinput>echo 'geom_stripe_load="YES"' &gt;&gt; /boot/loader.conf</userinput></screen>
  </sect1>

  <sect1 xml:id="GEOM-mirror">
    <title>RAID1 - Spiegelung</title>

    <indexterm>
      <primary>GEOM</primary>
    </indexterm>
    <indexterm>
      <primary>Disk Mirroring</primary>
    </indexterm>
    <indexterm>
      <primary>RAID1</primary>
    </indexterm>

    <para>Spiegelung (<acronym>RAID1</acronym> / Mirroring) ist eine
      Technik, bei der identische Daten auf mehr als ein Laufwerk
      geschrieben werden.  Spiegel werden in der Regel zum Schutz vor
      Datenverlust aufgrund von Festplattenausfällen verwendet.  Jedes
      Laufwerk in einem Spiegel enthält eine identische Kopie der
      Daten.  Wenn ein einzelnes Laufwerk ausfällt, funktioniert der
      Spiegel weiterhin und die Daten werden von den restlichen
      Festplatten bereit gestellt.  Der Rechner läuft einfach weiter
      und der Administrator hat die Gelegentheit, das defekte Laufwerk
      auszutauschen.</para>

    <para>Zwei häufige Situationen werden in diesem Beispiel
      erläutert.  Im ersten Beispiel wird ein Spiegel aus zwei
      neuen Laufwerken erstellt, der die existierende Platte ersetzt.
      Das zweite Beispiel erzeugt ein Spiegel mit einem einzigen
      Laufwerk, kopiert dann die Daten von der alten Platte und fügt
      die alte Platte zum Spiegel hinzu.  Obwohl dieses Verfahren
      etwas komplizierter ist, wird nur ein neues Laufwerk
      benötigt.</para>

    <para>Traditionell sind die Laufwerke in einem Spiegel vom
      gleichen Modell und besitzen die gleiche Kapazität.  Dies ist
      jedoch keine Voraussetzung für &man.gmirror.8;.  Hier können
      Spiegel mit unterschiedlichen Kapazitäten verwendet werden.  Die
      Kapazität richtet sich dann nach dem kleinsten Laufwerk im
      Spiegel.  Zusätzlicher Speicherplatz auf größeren Laufwerken
      bleibt dann ungenutzt.  Werden später weitere Laufwerke zum
      Spiegel hinzugefügt, müssen diese mindestens so viel Kapazität
      haben wie das kleinste Laufwerk im Spiegel.</para>

    <warning>
      <para>Die hier gezeigten Verfahren löschen keine Daten. Dennoch
	sollte, wie bei jeder größeren Operation, zuerst eine
	vollständige Sicherung erstellt werden.</para>
    </warning>

    <sect2 xml:id="geom-mirror-metadata">
      <title>Probleme mit Metadaten</title>

      <para>Viele Plattensysteme speichern Metadaten am Ende der
	Platte.  Alte Metadaten sollten vor der Wiederverwendung in
	einem Spiegel gelöscht werden, da die meisten Probleme aus
	zwei Arten von übrig gebliebenen Metadaten resultieren:
	<acronym>GPT</acronym>-Partitionstabellen und alte Metadaten
	aus einem vorherigen Spiegel.</para>

      <para><acronym>GPT</acronym>-Metadaten können mit &man.gpart.8;
	gelöscht werden.  Dieses Beispiel löscht sowohl die primären,
	als auch die <acronym>GPT</acronym>-Partitionstabelle von der
	Festplatte <filename>ada8</filename>:</para>

      <screen>&prompt.root; <userinput>gpart destroy -F ada8</userinput></screen>

      <para>Mit &man.gmirror.8; kann eine Platte aus einem aktiven
	Spiegel entfernt und gleichzeitig die Metadaten gelöscht
	werden.  In diesem Beispiel wird die Platte
	<filename>ada8</filename> aus dem aktiven Spiegel
	<filename>gm4</filename> entfernt:</para>

      <screen>&prompt.root; <userinput>gmirror remove gm4 ada8</userinput></screen>

      <para>Wenn der Spiegel nicht aktiv ist, sich jedoch noch alte
	Metadaten auf der Festplatte befinden, benutzen Sie
	<command>gmirror clear</command>, um die Metadaten zu
	entfernen:</para>

      <screen>&prompt.root; <userinput>gmirror clear ada8</userinput></screen>

      <para>&man.gmirror.8; speichert einen Datenblock an Metadaten am
	Ende der Festplatte.  Da das
	<acronym>GPT</acronym>-Partitionschema die Metadaten auch am
	Ende der Platte speichert, wird es nicht empfohlen, mit
	&man.gmirror.8; einen Spiegel aus einem gesamten
	<acronym>GPT</acronym>-Datenträger zu erstellen.  In diesen
	Fällen sollte eine <acronym>MBR</acronym>-Partitionierung
	benutzt werden, weil hier nur eine Partitionstabelle am Anfang
	der Platte gespeichert wird und somit nicht mit den Metadaten
	des Spiegels im Konflikt steht.</para>
    </sect2>

    <sect2 xml:id="GEOM-mirror-two-new-disks">
      <title>Einen Spiegel mit zwei neuen Festplatten
	erstellen</title>

      <para>In diesem Beispiel wurde &os; bereits auf der vorhandenen
	Festplatte <filename>ada0</filename> installiert.  Zwei neue
	Platten, <filename>ada1</filename> und
	<filename>ada2</filename>, wurden bereits mit dem System
	verbunden.  Ein neuer Spiegel soll mit diesen beiden Platten
	erzeugt und verwendet werden, um die alte vorhandene Platte zu
	ersetzen.</para>

      <para>Das Kernelmodul <filename>geom_mirror.ko</filename> muss
	entweder in den Kernel eingebaut, oder zur Laufzeit geladen
	werden.  Sie können das Modul manuell laden:</para>

      <screen>&prompt.root; <userinput>gmirror load</userinput></screen>

      <para>Erstellen Sie den Spiegel mit den beiden neuen
	Festplatten:</para>

      <screen>&prompt.root; <userinput>gmirror label -v gm0 /dev/ada1 /dev/ada2</userinput></screen>

      <para><filename>gm0</filename> ist ein vom Benutzer gewählter
	Name, der dem neuen Spiegel zugeordnet wird.  Nachdem der
	Spiegel gestartet wurde, erscheint dieser Gerätename in
	<filename>/dev/mirror/</filename>.</para>

      <para><acronym>MBR</acronym>- und
	<application>bsdlabel</application>-Partitionstabellen können
	jetzt auf dem neuen Spiegel erzeugt werden.  Dieses Beispiel
	verwendet das herkömmliche Dateisystem-Layout für
	<filename>/</filename>, swap, <filename>/var</filename>,
	<filename>/tmp</filename> und <filename>/usr</filename>.  Eine
	einzelne Root- und Swap-Partition würde ebenfalls
	funktionieren.</para>

      <para>Die Partitionen auf dem Spiegel müssen nicht zwingend die
	gleiche Größe wie die auf der Festplatte haben, aber sie
	müssen groß genug sein, um alle Daten aufnehmen zu können, die
	bereits auf <filename>ada0</filename> gespeichert sind.</para>

      <screen>&prompt.root; <userinput>gpart create -s MBR mirror/gm0</userinput>
&prompt.root; <userinput>gpart add -t freebsd -a 4k mirror/gm0</userinput>
&prompt.root; <userinput>gpart show mirror/gm0</userinput>
=&gt;       63  156301423  mirror/gm0  MBR  (74G)
         63         63                    - free -  (31k)
        126  156301299                 1  freebsd  (74G)
  156301425         61                    - free -  (30k)</screen>

      <screen>&prompt.root; <userinput>gpart create -s BSD mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs  -a 4k mirror/gm0s1</userinput>
&prompt.root; <userinput>gpart show mirror/gm0s1</userinput>
=&gt;        0  156301299  mirror/gm0s1  BSD  (74G)
          0          2                      - free -  (1.0k)
          2    4194304                   1  freebsd-ufs  (2.0G)
    4194306    8388608                   2  freebsd-swap (4.0G)
   12582914    4194304                   4  freebsd-ufs  (2.0G)
   16777218    2097152                   5  freebsd-ufs  (1.0G)
   18874370  137426928                   6  freebsd-ufs  (65G)
  156301298          1                      - free -  (512B)</screen>

      <para>Damit von dem Spiegel gebootet werden kann, muss der
	Bootcode in den <acronym>MBR</acronym> installiert, ein
	bsdlabel erstellt und die aktive Partition gesetzt
	werden:</para>

      <screen>&prompt.root; <userinput>gpart bootcode -b /boot/mbr mirror/gm0</userinput>
&prompt.root; <userinput>gpart set -a active -i 1 mirror/gm0</userinput>
&prompt.root; <userinput>gpart bootcode -b /boot/boot mirror/gm0s1</userinput></screen>

      <para>Erstellen Sie die Dateisysteme auf dem neuen Spiegel und
	aktivieren Sie Soft-Updates:</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1a</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1d</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1e</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1f</userinput></screen>

      <para>Die Dateisysteme der vorhandenen Platte
	<filename>ada0</filename> können jetzt mit &man.dump.8; und
	&man.restore.8; auf den Spiegel kopiert werden.</para>

<screen>&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1d /mnt/var</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1e /mnt/tmp</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1f /mnt/usr</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</userinput></screen>

      <para>Fügen Sie die Dateisysteme für den Spiegel in
	<filename>/etc/rc.conf</filename> hinzu:</para>

      <programlisting># Device          Mountpoint       FStype  Options Dump    Pass#
/dev/mirror/gm0s1a      /               ufs     rw       1       1
/dev/mirror/gm0s1b      none            swap    sw       0       0
/dev/mirror/gm0s1d      /var            ufs     rw       2       2
/dev/mirror/gm0s1e      /tmp            ufs     rw       2       2
/dev/mirror/gm0s1f      /usr            ufs     rw       2       2</programlisting>

      <para>Wenn das Modul <filename>geom_mirror.ko</filename> nicht
	im Kernel enthalten ist, können Sie
	<filename>/mnt/boot/loader.conf</filename> bearbeiten, damit
	das Modul beim Systemstart geladen wird:</para>

      <programlisting>geom_mirror_load="YES"</programlisting>

      <para>Starten Sie das System neu und überprüfen Sie, ob
	alle Daten erfolgreich kopiert wurden.  Das
	<acronym>BIOS</acronym> wird den Spiegel vermutlich als
	zwei einzelne Laufwerke erkennen.  Da beide Laufwerke
	jedoch identisch sind, spielt es keine Rolle, welches
	Laufwerk zum Booten ausgewählt wird.</para>

      <para>Falls es Probleme beim Booten gibt, lesen Sie den
	<xref linkend="gmirror-troubleshooting"/>.  Die alte
	Festplatte <filename>ada0</filename> kann vom System
	getrennt und als Offline-Sicherung aufbewahrt werden.</para>

      <para>Im laufenden Betrieb verhält sich der Spiegel genau
	wie ein einzelnes Laufwerk.</para>
    </sect2>

    <sect2 xml:id="GEOM-mirror-existing-drive">
      <title>Einen Spiegel mit einem vorhandenen Laufwerk
	erstellen</title>

      <para>In diesem Beispiel wurde &os; bereits auf der
	Festplatte <filename>ada0</filename> installiert und eine
	weitere Platte, <filename>ada1</filename>, wurde an
	das System angeschlossen.  Zunächst wird ein Spiegel mit
	einer Festplatte erstellt, dann das vorhandene System auf
	den Spiegel kopiert.  Zuletzt wird die alte Festplatte in den
	Spiegel eingefügt.  Diese etwas komplexere Vorgehensweise ist
	erforderlich, da <command>gmirror</command> 512 Byte an
	Metadaten am Ende der Festplatte speichert, und die bestehende
	Platte, <filename>ada0</filename>, in der Regel den Platz
	bereits belegt hat.</para>

      <para>Laden Sie das Kernelmodul
	<filename>geom_mirror.ko</filename>:</para>

      <screen>&prompt.root; <userinput>gmirror load</userinput></screen>

      <para>Prüfen Sie mit <command>diskinfo</command> die Mediengröße
	der vorhandenen Festplatte:</para>

      <screen>&prompt.root; <userinput>diskinfo -v ada0 | head -n3</userinput>
/dev/ada0
        512             # sectorsize
        1000204821504   # mediasize in bytes (931G)</screen>

      <para>Jetzt können Sie den Spiegel auf der neuen Festplatte
	erzeugen.  Um sicherzustellen, dass die Kapazität nicht größer
	ist, als die Kapazität der vorhandenen Platte
	<filename>ada0</filename>, benutzen Sie &man.gnop.8; um eine
	Platte mit der exakt gleichen Größe zu imitieren.  Diese
	Platte speichert keine Daten und wird nur verwendet, um die
	Größe des Spiegels zu begrenzen.  &man.gmirror.8; wird die
	Kapazität des Spiegels auf die Größe von
	<filename>gzero.nop</filename> beschränken, auch wenn die neue
	Festplatte <filename>ada1</filename> mehr Platz zur Verfügung
	hätte.  Beachten Sie, dass
	<replaceable>1000204821504</replaceable> in der zweiten Zeile
	der ermittelten Mediengröße von <command>diskinfo</command>
	entspricht.</para>

      <screen>&prompt.root; <userinput>geom zero load</userinput>
&prompt.root; <userinput>gnop create -s 1000204821504 gzero</userinput>
&prompt.root; <userinput>gmirror label -v gm0 gzero.nop ada1</userinput>
&prompt.root; <userinput>gmirror forget gm0</userinput></screen>

      <para>Da <filename>gzero.nop</filename> keine Daten speichert,
	sieht der Spiegel sie als nicht verbunden an.  Der Spiegel ist
	so konfiguriert, dass er nicht verbundene Komponenten einfach
	<quote>vergisst</quote>.  Das Ergebnis ist ein Spiegel mit nur
	einer einzigen Platte, <filename>ada1</filename>.</para>

      <para>Sehen Sie sich nach der Erstellung von
	<filename>gm0</filename> die Partitionstabelle von
	<filename>ada0</filename> an.  Diese Ausgabe stammt von einer
	1&nbsp;TB Festplatte.  Falls am Ende der Platte noch freier
	Speicherplatz ist, kann der Inhalt von
	<filename>ada0</filename> direkt auf den Spiegel kopiert
	werden.</para>

      <para>Falls jedoch der gesamte Speicherplatz auf der Platte
	zugeordnet ist, dann gibt es keinen Platz mehr für die 512
	Byte Metadaten für den Spiegel am Ende der Platte, wie in
	dieser Auflistung zu sehen.</para>

      <screen>&prompt.root; <userinput>gpart show ada0</userinput>
=&gt;        63  1953525105        ada0  MBR  (931G)
          63  1953525105           1  freebsd  [active]  (931G)</screen>

      <para>In diesem Fall muss die Partitionstabelle bearbeitet
	werden, um die Kapazität von <filename>mirror/gm0</filename>
	um einen Sektor zu reduzieren.  Dieses Verfahren wird später
	erläutert.</para>

      <para>In beiden Fällen sollte die Partitionstabelle der primären
	Platte mit <command>gpart backup</command> gesichert
	werden.</para>

      <screen>&prompt.root; <userinput>gpart backup ada0 &gt; table.ada0</userinput>
&prompt.root; <userinput>gpart backup ada0s1 &gt; table.ada0s1</userinput></screen>

      <para>Diese Kommandos erstellen zwei Dateien,
	<filename>table.ada0</filename> und
	<filename>table.ada0s1</filename>.  Das Beispiel verwendet
	eine 1&nbsp;TB Festplatte:</para>

      <screen>&prompt.root; <userinput>cat table.ada0</userinput>
MBR 4
1 freebsd         63 1953525105   [active]</screen>

      <screen>&prompt.root; <userinput>cat table.ada0s1</userinput>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640881</screen>

      <para>Wenn am Ende der Platte kein Platz vorhanden ist, muss
	die Größe des Slice und der letzten Partition verringert
	werden.  Bearbeiten Sie die beiden Dateien, und verringern
	Sie die Größe der Slice und der Partition jeweils um eins.
	Dies bezieht sich auf die letzten Zahlen in der Liste.</para>

      <screen>&prompt.root; <userinput>cat table.ada0</userinput>
MBR 4
1 freebsd         63 <emphasis>1953525104</emphasis>   [active]</screen>

      <screen>&prompt.root; <userinput>cat table.ada0s1</userinput>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  <emphasis>984640880</emphasis></screen>

      <para>Wenn mindestens ein Sektor der Platte nicht zugewiesen
	wurde, kann die Platte ohne Modifikation verwendet
	werden.</para>

      <para>Jetzt kann die Partitionstabelle auf
	<filename>mirror/gm0</filename> wiederhergestellt
	werden:</para>

      <screen>&prompt.root; <userinput>gpart restore mirror/gm0 &lt; table.ada0</userinput>
&prompt.root; <userinput>gpart restore mirror/gm0s1 &lt; table.ada0s1</userinput></screen>

      <para>Prüfen Sie die Partitionstabellen mit
	<command>gpart show</command>.  Dieses Beispiel nutzt
	<filename>gm0s1a</filename> für <filename>/</filename>,
	<filename>gm0s1d</filename> für <filename>/var</filename>,
	<filename>gm0s1e</filename> für <filename>/usr</filename>,
	<filename>gm0s1f</filename> für <filename>/data1</filename>
	und <filename>gm0s1g</filename> für
	<filename>/data2</filename>.</para>

      <screen>&prompt.root; <userinput>gpart show mirror/gm0</userinput>
=&gt;        63  1953525104  mirror/gm0  MBR  (931G)
          63  1953525042           1  freebsd  [active]  (931G)
  1953525105          62              - free -  (31k)

&prompt.root; <userinput>gpart show mirror/gm0s1</userinput>
=&gt;         0  1953525042  mirror/gm0s1  BSD  (931G)
           0     2097152             1  freebsd-ufs  (1.0G)
     2097152    16777216             2  freebsd-swap  (8.0G)
    18874368    41943040             4  freebsd-ufs  (20G)
    60817408    20971520             5  freebsd-ufs  (10G)
    81788928   629145600             6  freebsd-ufs  (300G)
   710934528  1242590514             7  freebsd-ufs  (592G)
  1953525042          63                - free -  (31k)</screen>

      <para>Sowohl die Slice, als auch die letzte Partition, muss
	mindestens einen freien Block am Ende der Platte haben.</para>

      <para>Erstellen Sie Dateisysteme auf diesen neuen
	Partitionen:</para>

<screen>&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1a</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1d</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1e</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1f</userinput>
&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1g</userinput></screen>

      <para>Damit Sie von dem Spiegel booten können, müssen Sie den
	Bootcode in den <acronym>MBR</acronym> installieren, ein
	bsdlabel anlegen und das aktive Slice setzen:</para>

      <screen>&prompt.root; <userinput>gpart bootcode -b /boot/mbr mirror/gm0</userinput>
&prompt.root; <userinput>gpart set -a active -i 1 mirror/gm0</userinput>
&prompt.root; <userinput>gpart bootcode -b /boot/boot mirror/gm0s1</userinput></screen>

      <para>Bearbeiten Sie <filename>/etc/fstab</filename>, um die
	neuen Partitionen auf dem Spiegel nutzen zu können.  Speichern
	Sie zunächst eine Kopie der Datei unter
	<filename>/etc/fstab.orig</filename>:</para>

      <screen>&prompt.root; <userinput>cp /etc/fstab /etc/fstab.orig</userinput></screen>

      <para>Ersetzen Sie in <filename>/etc/fstab</filename>
	<filename>/dev/ada0</filename> durch
	<filename>mirror/gm0</filename>.</para>

      <programlisting># Device>>>>>>>>>>Mountpoint>>>>>>FStype>>Options>Dump>>>>Pass#
/dev/mirror/gm0s1a>>>>>>/>>>>>>>>>>>>>>>ufs>>>>>rw>>>>>>1>>>>>>>1
/dev/mirror/gm0s1b>>>>>>none>>>>>>>>>>>>swap>>>>sw>>>>>>0>>>>>>>0
/dev/mirror/gm0s1d>>>>>>/var>>>>>>>>>>>>ufs>>>>>rw>>>>>>2>>>>>>>2
/dev/mirror/gm0s1e>>>>>>/usr>>>>>>>>>>>>ufs>>>>>rw>>>>>>2>>>>>>>2
/dev/mirror/gm0s1f>>>>>>/data1>>>>>>>>>>ufs>>>>>rw>>>>>>2>>>>>>>2
/dev/mirror/gm0s1g>>>>>>/data2>>>>>>>>>>ufs>>>>>rw>>>>>>2>>>>>>>2</programlisting>

      <para>Wenn das Modul <filename>geom_mirror.ko</filename> nicht
	im Kernel enthalten ist, können Sie
	<filename>/boot/loader.conf</filename> bearbeiten, damit
	das Modul beim Systemstart geladen wird:</para>

      <programlisting>geom_mirror_load="YES"</programlisting>

      <para>Die Dateisysteme der ursprünglichen Platte können jetzt
	mit &man.dump.8; und &man.restore.8; auf den Spiegel kopiert
	werden.  Wenn Sie das Dateisystem mit <command>dump
	-L</command> sichern, wird zunächst ein Snapshot des
	Dateisystems erstellt, was einige Zeit dauern kann.</para>

      <screen>&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1d /mnt/var</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1e /mnt/usr</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1f /mnt/data1</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1g /mnt/data2</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 &amp;&amp; restore -rf -)</userinput>
&prompt.root; <userinput>dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 &amp;&amp; restore -rf -)</userinput></screen>

      <para>Starten Sie das System neu und booten Sie von
	<filename>ada1</filename>.  Wenn alles funktioniert, wird
	das System von <filename>mirror/gm0</filename> booten,
	welches jetzt die gleichen Daten enthält wie
	<filename>ada0</filename>.  Lesen Sie <xref
	  linkend="gmirror-troubleshooting"/>, falls es Probleme beim
	Booten gibt.</para>

      <para>An dieser Stelle besteht der Spiegel immer noch aus der
	einzelnen Platte <filename>ada1</filename>.</para>

      <para>Nachdem erfolgreich von <filename>mirror/gm0</filename>
	gebootet wurde, besteht der letzte Schritt darin,
	<filename>ada0</filename> in den Spiegel einzufügen.</para>

      <important>
	<para>Wenn Sie <filename>ada0</filename> in den Spiegel
	  einfügen, wird der Inhalt der Platte mit den Daten aus
	  dem Spiegel überschrieben.  Sie müssen sicherstellen, das
	  <filename>mirror/gm0</filename> den gleichen Inhalt wie
	  <filename>ada0</filename> hat, bevor Sie
	  <filename>ada0</filename> zum Spiegel hinzufügen.  Falls der
	  zuvor mit &man.dump.8; und &man.restore.8; kopierte Inhalt
	  nicht mit dem von <filename>ada0</filename> identisch ist,
	  machen Sie die Änderungen an <filename>/etc/fstab</filename>
	  rückgängig, starten Sie das System neu und beginnen Sie die
	  Prozedur von vorn.</para>
      </important>

      <screen>&prompt.root; <userinput>gmirror insert gm0 ada0</userinput>
GEOM_MIRROR: Device gm0: rebuilding provider ada0</screen>

      <para>Die Synchronisation zwischen den beiden Platten wird
	direkt gestartet.  Verwenden Sie <command>gmirror
	  status</command> um den Fortschritt zu beobachten.</para>

      <screen>&prompt.root; <userinput>gmirror status</userinput>
      Name    Status  Components
girror/gm0  DEGRADED  ada1 (ACTIVE)
                      ada0 (SYNCHRONIZING, 64%)</screen>

      <para>Nach einer Weile wird die Wiederherstellung abgeschlossen
	sein.</para>

      <screen>GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
&prompt.root; <userinput>gmirror status</userinput>
      Name    Status  Components
mirror/gm0  COMPLETE  ada1 (ACTIVE)
                      ada0 (ACTIVE)</screen>

      <para><filename>mirror/gm0</filename> besteht nun aus den beiden
	Platten <filename>ada0</filename> und
	<filename>ada1</filename>.  Der Inhalt der beiden Platten wird
	automatisch miteinander synchronisiert.  Im laufenden Betrieb
	verhält sich <filename>mirror/gm0</filename> wie eine einzelne
	Festplatte.</para>
    </sect2>

    <sect2 xml:id="gmirror-troubleshooting">
      <title>Fehlerbehebung</title>

      <sect3>
	<title>Probleme beim Bootvorgang</title>

      <sect4>
	<title>BIOS-Einstellungen</title>

	<para>Möglicherweise müssen die
	  <acronym>BIOS</acronym>-Einstellungen geändert werden, um
	  von dem neuen gespiegelten Laufwerk zu booten.  Beide
	  Platten des Spiegels können zum Booten verwendet werden, da
	  sie als Komponenten des Spiegels identische Daten
	  enthalten.</para>
      </sect4>

      <sect4>
	<title>Probleme beim Booten</title>

	<para>Wenn der Bootvorgang mit der folgenden Meldung
	  abbricht, ist irgendwas mit dem Spiegel nicht in
	  Ordnung:</para>

	<screen>Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

Loader variables:
  vfs.root.mountfrom=ufs:/dev/mirror/gm0s1a
  vfs.root.mountfrom.options=rw

Manual root filesystem specification:
  &lt;fstype&gt;:&lt;device&gt; [options]
      Mount &lt;device&gt; using filesystem &lt;fstype&gt;
      and with the specified (optional) option list.

    eg. ufs:/dev/da0s1a
        zfs:tank
        cd9660:/dev/acd0 ro
          (which is equivalent to: mount -t cd9660 -o ro /dev/acd0 /)

  ?               List valid disk boot devices
  .               Yield 1 second (for background tasks)
  &lt;empty line&gt;    Abort manual input

mountroot&gt;</screen>

	<para>Dieses Problem kann durch ein nicht geladenes
	  Kernelmodul <filename>geom_mirror.ko</filename> in
	  <filename>/boot/loader.conf</filename> verursacht werden.
	  Um das Problem zu beheben, booten Sie von einem
	  &os;-Installationsmedium und wählen Sie
	  <literal>Shell</literal> an der Eingabeaufforderung.  Laden
	  Sie dann das Modul und hängen Sie den Spiegel ein:</para>

	<screen>&prompt.root; <userinput>gmirror load</userinput>
&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput></screen>

	<para>Bearbeiten Sie dann
	  <filename>/mnt/boot/loader.conf</filename> und fügen Sie
	  eine Zeile für das Kernelmodul hinzu:</para>

	<programlisting>geom_mirror_load="YES"</programlisting>

	<para>Speichern Sie die Datei und starten Sie das System
	  neu.</para>

	<para>Andere Probleme, die <literal>error 19</literal>
	  verursachen können, sind nur mit mehr Aufwand zu beheben.
	  Obwohl das System von <filename>ada0</filename> booten
	  sollte, wird ein weiterer Prompt erscheinen, wenn
	  <filename>/etc/fstab</filename> fehlerhaft ist.  Geben
	  Sie am Loader-Prompt <literal>ufs:/dev/ada0s1a</literal> ein
	  und drücken Sie <keycap>Enter</keycap>.  Machen Sie die
	  Änderungen an <filename>/etc/fstab</filename> rückgängig und
	  hängen Sie anstelle des Spiegels die originale Festplatte
	  (<filename>ada0</filename>) ein.  Starten Sie dann das
	  System neu und versuchen Sie den Vorgang erneut.</para>

	<screen>Enter full pathname of shell or RETURN for /bin/sh:
&prompt.root; <userinput>cp /etc/fstab.orig /etc/fstab</userinput>
&prompt.root; <userinput>reboot</userinput></screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Wiederherstellung des Systems nach einem
	Plattenausfall</title>

      <para>Der Vorteil der Plattenspiegelung ist, dass eine Platte
	ausfallen kann, ohne dass Sie dabei Daten verlieren. Falls
	<filename>ada0</filename> aus dem obigen Beispiel ausfällt,
	steht der Spiegel weiterhin zur Verfügung und bietet die Daten
	von der verbleibenden Platte <filename>ada1</filename>
	an.</para>

      <para>Um das ausgefallene Laufwerk zu ersetzen, muss das System
	heruntergefahren werden und das ausgefallene Laufwerk durch
	ein neues Laufwerk von gleicher oder größerer Kapazität
	ersetzt werden.  Hersteller verwenden oft etwas
	willkürliche Werte für die Kapazität.  Der einzige Weg, um
	wirklich sicher zu sein, ist die Gesamtzahl der Sektoren von
	<command>diskinfo -V</command> zu vergleichen.  Ein Laufwerk
	mit größerer Kapazität wird funktionieren, allerdings wird der
	zusätzliche Platz ungenutzt bleiben.</para>

      <para>Nachdem der Rechner wieder eingeschaltet ist, wird der
	Spiegel im <quote>degraded</quote> Modus ausgeführt werden.
	Der Spiegel wird angewiesen, Laufwerke zu vergessen, die noch
	nicht verbunden sind:</para>

      <screen>&prompt.root; <userinput>gmirror forget gm0</userinput></screen>

      <para>Alte Metadaten sollten von der Ersatzfestplatte nach den
	Anweisungen in <xref linkend="geom-mirror-metadata"/> gelöscht
	werden.  Anschließend kann die Ersatzfestplatte, in diesem
	Beispiel <filename>ada4</filename>, in den Spiegel eingefügt
	werden:</para>

      <screen>&prompt.root; <userinput>gmirror insert gm0 /dev/ada4</userinput></screen>

      <para>Die Wiederherstellung beginnt, sobald das neue Laufwerk in
	den Spiegel eingesetzt wird.  Das Kopieren der Daten vom
	Spiegel auf das neue Laufwerk kann eine Weile dauern.  Die
	Leistung des Spiegels ist während dieser Zeit stark reduziert,
	deswegen sollten neue Laufwerke idealerweise dann eingefügt
	werden, wenn der Rechner nicht benötigt wird.</para>

      <para>Der Fortschritt der Wiederherstellung kann mit
	<command>gmirror status</command> überwacht werden.  Während
	der Wiederherstellung ist der Status
	<computeroutput>DEGRADED</computeroutput>.  Wenn der Vorgang
	abgeschlossen ist, wechselt der Status zu
	<computeroutput>COMPLETE</computeroutput>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="geom-raid3">
    <info>

      <title><acronym>RAID</acronym>3 - Byte-Level Striping mit
	dedizierter Parität</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mark</firstname>
	    <surname>Gladman</surname>
	  </personname>
	  <contrib>Geschrieben von </contrib>
	</author>
	<author>
	  <personname>
	    <firstname>Daniel</firstname>
	    <surname>Gerzo</surname>
	  </personname>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Basierend auf Dokumentation von </contrib>
	</author>
	<author>
	  <personname>
	    <firstname>Murray</firstname>
	    <surname>Stokely</surname>
	  </personname>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Björn</firstname>
	    <surname>Heidotting</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>GEOM</acronym></primary>
    </indexterm>
    <indexterm>
      <primary>RAID3</primary>
    </indexterm>

    <para><acronym>RAID</acronym>3 ist eine Methode, die mehrere
      Festplatten zu einem einzigen Volume mit einer dedizierten
      Paritätsfestplatte kombiniert.  In einem
      <acronym>RAID</acronym>3-System werden die Daten in einzelne
      Bytes aufgeteilt und dann über alle Laufwerke,
      mit Ausnahme der Paritätsfestplatte, geschrieben.  Beim Lesen
      von Daten in einer <acronym>RAID</acronym>3 Implementierung
      werden alle Festplatten im Array parallel genutzt.  Die Leistung
      kann durch den Einsatz von mehreren Controllern weiter erhöht
      werden.  Ein <acronym>RAID</acronym>3-Array hat eine
      Fehlertoleranz von 1 Laufwerk und bietet dabei eine Kapazität
      von 1 - 1/n der Gesamtkapazität der Laufwerke im Array, wobei
      n die Anzahl der Festplatten im Array darstellt.  So eine
      Konfiguration ist meistens für die Speicherung von größeren
      Dateien geeignet, wie beispielsweise Multimediadateien.</para>

    <para>Mindestens 3 Festplatten sind erforderlich, um ein
      <acronym>RAID</acronym>3 zu erstellen.  Jede Festplatte muss
      von der gleichen Größe sein, da die
      <acronym>I/O</acronym>-Anfragen für Lesen oder Schreiben
      auf mehreren Festplatten parallel stattfinden.  Aufgrund der
      Beschaffenheit von <acronym>RAID</acronym>3, muss die Anzahl der
      Laufwerke 3, 5, 9, 17 bzw. 2^n + 1 sein.</para>

    <para>Dieser Abschnitt beschreibt, wie ein Software
      <acronym>RAID</acronym>3 auf einem &os;-System erstellt
      wird.</para>

    <note>
      <para>Obwohl es theoretisch möglich ist &os; von einem
	<acronym>RAID</acronym>3-Array zu booten, wird von solch
	einer ungewöhnlichen Konfiguration dringend abgeraten.</para>
    </note>

    <sect2>
      <title>Ein dediziertes <acronym>RAID</acronym>3-Array
	erstellen</title>

      <para>In &os; wird die Unterstützung für
	<acronym>RAID</acronym>3 über die
	<acronym>GEOM</acronym>-Klasse &man.graid3.8; implementiert.
	Zum Erstellen eines dedizierten
	<acronym>RAID</acronym>3-Arrays sind folgende Schritte
	erforderlich.</para>

      <procedure>
	<step>
	  <para>Laden Sie zunächst das Modul
	    <filename>geom_raid3.ko</filename> mit einem der folgenden
	    Befehle:</para>

	  <screen>&prompt.root; <userinput>graid3 load</userinput></screen>

	  <para>oder:</para>

	  <screen>&prompt.root; <userinput>kldload geom_raid3</userinput></screen>
	</step>

	<step>
	  <para>Stellen Sie sicher, dass ein geeigneter Mountpoint
	    existiert.  Dieser Befehl erstellt ein neues Verzeichnis,
	    welches als Mountpoint verwendet werden kann:</para>

	  <screen>&prompt.root; <userinput>mkdir <replaceable>/multimedia</replaceable></userinput></screen>
	</step>

	<step>
	  <para>Bestimmen Sie die Gerätenamen der Festplatten, die dem
	    Array hinzugefügt werden und erstellen Sie ein neues
	    <acronym>RAID</acronym>3 Gerät.  Das letzte aufgeführte
	    Gerät wird als dediziertes Paritätslaufwerk verwendet.
	    Dieses Beispiel verwendet drei unpartionierte
	    <acronym>ATA</acronym>-Platten:
	    <filename><replaceable>ada1</replaceable></filename> und
	    <filename><replaceable>ada2</replaceable></filename> für
	    die Daten, sowie
	    <filename><replaceable>ada3</replaceable></filename> für
	    die Parität.</para>

	  <screen>&prompt.root; <userinput>graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</userinput>
Metadata value stored on /dev/ada1.
Metadata value stored on /dev/ada2.
Metadata value stored on /dev/ada3.
Done.</screen>
	</step>

	<step>
	  <para>Partitionieren Sie das neu erstelle Gerät
	    <filename>gr0</filename> und erstellen Sie darauf
	    ein <acronym>UFS</acronym>-Dateisystem:</para>
	
	  <screen>&prompt.root; <userinput>gpart create -s GPT /dev/raid3/gr0</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs /dev/raid3/gr0</userinput>
&prompt.root; <userinput>newfs -j /dev/raid3/gr0p1</userinput></screen>

	  <para>Viele Zahlen rauschen nun über den Bildschirm und
	    nach einer gewissen Zeit ist der Vorgang abgeschlossen.
	    Das Volume wurde erstellt und kann jetzt in den
	    Verzeichnisbaum eingehangen werden:</para>

	  <screen>&prompt.root; <userinput>mount /dev/raid3/gr0p1 /multimedia/</userinput></screen>

	  <para>Das <acronym>RAID</acronym>3-Array ist nun
	    einsatzbereit.</para>
	</step>
      </procedure>

      <para>Weitere Konfigurationsschritte sind erforderlich, um die
	Einstellungen nach einem Systemneustart zu erhalten.</para>

      <procedure>
	<step>
	  <para>Das Modul <filename>geom_raid3.ko</filename> muss
	    geladen werden, bevor das Array eingehangen werden kann.
	    Damit das Kernelmodul automatisch beim Systemstart geladen
	    wird, muss die folgende Zeile in
	    <filename>/boot/loader.conf</filename> hinzugefügt
	    werden:</para>

	  <programlisting>geom_raid3_load="YES"</programlisting>
	</step>

	<step>
	  <para>Die folgenden Informationen über das Volume müssen in
	    <filename>/etc/fstab</filename> hinzugefügt werden, um
	    das Dateisystem des Arrays automatisch beim Systemstart
	    zu aktivieren:</para>

	  <programlisting>/dev/raid3/gr0p1	/multimedia	ufs	rw	2	2</programlisting>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="geom-ggate">
    <title>GEOM Gate Netzwerkgeräte</title>

    <para>GEOM unterstützt die Verwendung entfernter Geräte
      wie Festplatten, CD-ROMs und Dateien mittels Nutzung
      der Gate-Dienstprogramme. Dies ist vergleichbar mit
      <acronym>NFS</acronym>.</para>

    <para>Zu Beginn muss eine Exportdatei erzeugt werden. Diese
      Datei legt fest, wer Zugriff auf die exportierten Ressourcen
      hat und welche Zugriffstechniken angeboten werden. Um zum
      Beispiel den vierten Slice auf der ersten
      <acronym>SCSI</acronym>-Platte zu exportieren, ist die
      folgende Datei <filename>/etc/gg.exports</filename>
      mehr als ausreichend:</para>

    <programlisting>192.168.1.0/24 RW /dev/da0s4d</programlisting>

    <para>Sie wird allen Hosts innerhalb des privaten Netzwerkes
      den Zugriff auf das Dateisystem auf der Partition
      <filename>da0s4d</filename> erlauben.</para>

    <para>Um dieses Gerät zu exportieren, stellen Sie bitte
      sicher, dass es momentan nicht gemounted ist und
      starten Sie den &man.ggated.8; Server-Daemon:</para>

    <screen>&prompt.root; <userinput>ggated</userinput></screen>

    <para>Um nun <command>mount</command> auf der Client-Maschine
      auszuführen, geben Sie bitte die folgenden Befehle
      ein:</para>

    <screen>&prompt.root; <userinput>ggatec create -o rw 192.168.1.1 /dev/da0s4d</userinput>
ggate0
&prompt.root; <userinput>mount /dev/ggate0 /mnt</userinput></screen>

    <para>Auf das Gerät kann jetzt über den Mount-Punkt
      <filename>/mnt</filename> zugegriffen werden.</para>

    <note>
      <para>Es sollte darauf hingewiesen werden, dass dies
	scheitern wird, falls das Gerät momentan entweder
	auf dem Server oder irgendeiner anderen Maschine
	gemountet ist.</para>
    </note>

    <para>Wenn das Gerät nicht länger gebraucht wird, kann es mit
      &man.umount.8; ausgehängt werden.</para>
  </sect1>

  <sect1 xml:id="geom-glabel">
    <title>Das Labeln von Laufwerken</title>

    <indexterm>
      <primary>GEOM</primary>
    </indexterm>
    <indexterm>
      <primary>Disk Labels</primary>
    </indexterm>

    <para>Während der Initialisierung des Systems legt der
      &os;-Kernel für jedes gefundene Gerät Knotenpunkte
      an. Diese Methode für die Überprüfung auf
      vorhandene Geräte wirft einige Fragen auf.  Was passiert
      beispielsweise, wenn ein neues
      <acronym>USB</acronym>-Laufwerk hinzugefügt wird?
      Es ist sehr wahrscheinlich, dass ein
      Flash-Speicher-Gerät den Gerätenamen
      <filename>da0</filename> erhält, während
      gleichzeitig das bisherige <filename>da0</filename>
      zu <filename>da1</filename> wird. Dies verursacht
      Probleme beim Einhängen von Dateisystemen, wenn diese
      in <filename>/etc/fstab</filename> aufgeführt sind und kann dazu
      führen, dass das System nicht mehr startet.</para>

    <para>Eine Lösung für dieses Problem ist das
      Aneinanderketten der <acronym>SCSI</acronym>-Geräte,
      damit ein neues Gerät, welches der
      <acronym>SCSI</acronym>-Karte hinzugefügt wird,
      unbenutzte Gerätenummern erhält. Aber was
      geschieht, wenn ein <acronym>USB</acronym>-Gerät
      möglicherweise die primäre
      <acronym>SCSI</acronym>-Platte ersetzt? Dies kann
      passieren, weil <acronym>USB</acronym>-Geräte
      normalerweise vor der <acronym>SCSI</acronym>-Karte
      geprüft werden. Eine Lösung ist das
      Hinzufügen dieser Geräte, nachdem das System
      gestartet ist. Eine andere Lösung könnte sein,
      nur ein einzelnes <acronym>ATA</acronym>-Laufwerk zu
      nutzen und die <acronym>SCSI</acronym>-Geräte niemals
      in der <filename>/etc/fstab</filename> aufzuführen.</para>

    <para>Eine bessere Lösung ist die Verwendung von
      <command>glabel</command>, um die Laufwerke zu mit Labeln zu
      versehen und diese in <filename>/etc/fstab</filename> zu
      nutzen. Da <command>glabel</command> seine Label im letzten
      Sektor jedes vorhandenen Datenträgers speichert, wird
      das Label persistent bleiben (auch über Neustarts hinweg).
      Durch Nutzung dieses Labels als Gerät kann das
      Dateisystem immer gemountet sein, unabhängig davon,
      durch welchen Geräte-Knotenpunkt auf ihn zugegriffen
      wird.</para>

    <note>
      <para><command>glabel</command> kann permanente (dauerhaft) und
	vorübergehende Label erstellen.  Aber nur dauerhafte
	Label bleiben konsistent über Neustarts hinweg. Lesen
	Sie die &man.glabel.8; für weitere Unterschiede zwischen den
	Label-Typen.</para>
    </note>

    <sect2>
      <title>Label-Typen und Beispiele</title>

      <para>Permanente Label können generische Label oder
	Dateisystem-Label sein.  Permanente Dateisystem-Label können
	mit &man.tunefs.8; oder &man.newfs.8; erzeugt werden.  Dieser
	Typ von Label wird in einem Unterverzeichnis von
	<filename>/dev</filename> angelegt und wird dem Dateisystem
	entsprechend benannt.
	<acronym>UFS</acronym>2-Dateisystem-Label werden zum Beispiel
	in <filename>/dev/ufs</filename> angelegt.  Permanente Label können außerdem durch
	den Befehl <command>glabel label</command> erzeugt werden.
	Diese Label sind nicht dateisystemspezisch und werden im
	Unterverzeichnis <filename>/dev/label</filename>
	erzeugt.</para>

      <para>Temporäre Label werden beim nächsten Systemstart zerstört.
	Diese Label werden im Verzeichnis
	<filename>/dev/label</filename> erzeugt und sind ideal für
	Testzwecke.  Ein temporäres Label kann mit
	<command>glabel create</command> erzeugt werden.</para>

<!-- XXXTR: How do you create a file system label without running newfs
            or when there is no newfs (e.g.: cd9660)? -->

      <para>Um ein permanentes Label auf einem
	<acronym>UFS</acronym>2-Dateisystem ohne
	Löschung von Daten zu erzeugen, kann man folgenden
	Befehl verwenden:</para>

      <screen>&prompt.root; <userinput>tunefs -L home /dev/da3</userinput></screen>

      <warning>
	<para>Wenn das Dateisystem voll ist, kann dies zu
	  Datenkorruption führen.</para>
      </warning>

      <para>In <filename>/dev/ufs</filename> sollte nun ein Label
	vorhanden sein, welches zu <filename>/etc/fstab</filename>
	hinzugefügt werden kann:</para>

      <programlisting>/dev/ufs/home		/home            ufs     rw              2      2</programlisting>

      <note>
	<para>Das Dateisystem darf nicht gemountet sein beim
	  Versuch, <command>tunefs</command> auszuführen.</para>
      </note>

      <para>Nun kann das Dateisystem eingehängt werden:</para>

      <screen>&prompt.root; <userinput>mount /home</userinput></screen>

      <para>Von nun an kann der Geräte-Knotenpunkt sich ohne
	negative Effekte auf das System ändern, solange das
	Kernelmodul <filename>geom_label.ko</filename> beim
	Systemstart mittels <filename>/boot/loader.conf</filename>
	geladen wird oder die
	<literal>GEOM_LABEL</literal>-Kernel-Option aktiv ist.</para>

      <para>Dateisysteme können auch mit einem Standard-Label
	erzeugt werden (mittels des Flags <option>-L</option> in
	<command>newfs</command>). Lesen Sie &man.newfs.8; für weitere
	Informationen.</para>

      <para>Der folgende Befehl kann genutzt werden, um das Label
	zu beseitigen:</para>

      <screen>&prompt.root; <userinput>glabel destroy home</userinput></screen>

      <para>Das folgende Beispiel zeigt Ihnen, wie Sie Label für
	die Partitionen einer Bootplatte erzeugen.</para>

      <example>
	<title>Die Partitionen einer Bootplatte labeln</title>

	<para>Durch das Erstellen von permanenten Labeln für die
	  Partitionen einer Bootplatte sollte das System selbst dann noch
	  normal starten können, wenn Sie die Platte an einen
	  anderen Controller anschließen oder in ein anderes
	  System installieren.  In diesem Beispiel nehmen wir an, dass
	  nur eine einzige <acronym>ATA</acronym>-Platte verwendet wird,
	  die Ihr System derzeit als <filename>ad0</filename>
	  erkennt.  Weiters nehmen wir an, dass Sie das
	  Standard-Partionierungsschema von &os; vewendet haben und Ihre
	  Platte daher die Dateisysteme
	  <filename>/</filename>,
	  <filename>/var</filename>,
	  <filename>/usr</filename> sowie
	  <filename>/tmp</filename> aufweist.
	  Zusätzlich wurde eine Swap-Partition angelegt.</para>

	<para>Starten Sie das System neu.  Am &man.loader.8;-Prompt
	  drücken Sie die Taste <keycap>4</keycap>, um in den
	  Single-User-Modus zu gelangen.  Dort führen Sie die
	  folgenden Befehle aus:</para>

	<screen>&prompt.root; <userinput>glabel label rootfs /dev/ad0s1a</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1a is label/rootfs
&prompt.root; <userinput>glabel label var /dev/ad0s1d</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1d is label/var
&prompt.root; <userinput>glabel label usr /dev/ad0s1f</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1f is label/usr
&prompt.root; <userinput>glabel label tmp /dev/ad0s1e</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1e is label/tmp
&prompt.root; <userinput>glabel label swap /dev/ad0s1b</userinput>
GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap
&prompt.root; <userinput>exit</userinput></screen>

	<para>Das System startet daraufhin in den Multi-User-Modus.
	  Nachdem der Startvorgang abgeschlossen ist, editieren Sie
	  <filename>/etc/fstab</filename> und ersetzen die
	  konventionellen Gerätedateien durch die entsprechenden
	  Label.  Die modifizierte <filename>/etc/fstab</filename>
	  sollte wie folgt aussehen:</para>

	<programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2</programlisting>

	<para>Starten Sie Ihr System neu.  Traten keine Probleme auf,
	  wird das System normal hochfahren und Sie erhalten die folgende
	  Ausgabe, wenn Sie den Befehl <command>mount</command>
	  ausführen:</para>

	<screen>&prompt.root; <userinput>mount</userinput>
/dev/label/rootfs on / (ufs, local)
devfs on /dev (devfs, local)
/dev/label/tmp on /tmp (ufs, local, soft-updates)
/dev/label/usr on /usr (ufs, local, soft-updates)
/dev/label/var on /var (ufs, local, soft-updates)</screen>
      </example>

      <para>Beginnend mit &os;&nbsp;7.2, unterstützt
	&man.glabel.8; einen neuen Labeltyp für
	<acronym>UFS</acronym>-Dateisysteme.  Dieser basiert auf der
	eindeutigen Dateisystem-ID <literal>ufsid</literal>.
	Derartige Label finden sich in
	<filename>/dev/ufsid</filename> und werden
	während des Systemstarts automatisch erzeugt.  Es ist
	möglich, diese <literal>ufsid</literal>-Label zum
	automatischen Einhängen von Partitionen in
	<filename>/etc/fstab</filename> einzusetzen.  Verwenden Sie
	<command>glabel status</command>, um eine Liste
	aller Dateisysteme und ihrer <literal>ufsid</literal>-Label
	zu erhalten:</para>

      <screen>&prompt.user; <userinput>glabel status</userinput>
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</screen>

      <para>In diesem Beispiel repräsentiert
	<filename>ad4s1d</filename> das
	<filename>/var</filename>-Dateisystem,
	während <filename>ad4s1f</filename> dem
	<filename>/usr</filename>-Dateisystem
	entspricht.  Wenn Sie die angegebenen
	<literal>ufsid</literal>-Werte verwenden, können
	diese Dateisysteme durch die folgenden Einträge in
	der Datei <filename>/etc/fstab</filename> gemountet
	werden:</para>

      <programlisting>/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2</programlisting>

      <para>Jede Partition, die ein <literal>ufsid</literal>-Label
	aufweist, kann auf diese Art gemountet werden.  Dies hat den
	Vorteil, dass Sie die permanenten Label nicht manuell anlegen
	müssen, wobei sich die Platten nach wie vor über
	geräteunabhängige Namen ansprechen und einhängen
	lassen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="geom-gjournal">
    <title>UFS Journaling in GEOM</title>

    <indexterm>
      <primary>GEOM</primary>
    </indexterm>
    <indexterm>
      <primary>Journaling</primary>
    </indexterm>

    <para>&os; unterstützt Journaling für
      <acronym>UFS</acronym>-Dateisysteme.  Diese Funktion wird über
      das <acronym>GEOM</acronym>-Subsystem realisiert und kann
      über das Werkzeug &man.gjournal.8; eingerichtet werden.</para>

    <para>Bei Journaling wird ein Protokoll über alle
      Dateisystemtransaktionen angelegt, inklusive aller
      Veränderungen, aus denen ein kompletter Schreibvorgang besteht,
      bevor diese Änderungen (Metadaten sowie tatsächliche
      Schreibvorgänge) physisch auf der Festplatte ausgeführt werden.
      Dieses Protokoll kann später erneut aufgerufen werden, um diese
      Vorgänge zu wiederholen, damit Systeminkonsistenzen vermieden
      werden.</para>

    <para>Diese Technik bietet eine weitere Möglichkeit,
      sich vor Datenverlust und Dateisystem-Inkonsistenzen zu
      schützen.  Im Gegensatz zu Soft Updates (die
      Metadaten-Aktualisierungen verfolgen und erzwingen) und
      Snapshots (die ein Image eines Dateisystems darstellen) wird
      bei Journaling ein tatsächliches Protokoll in einem
      speziell dafür bereitgestellten Bereich der Festplatte
      (oder manchmal sogar auf einer separaten Platte)
      gespeichert.</para>

    <para>Im Gegensatz zu anderen Journaling-Dateisystemen arbeitet
      die <command>gjournal</command>-Methode blockbasiert und wurde
      nicht als Teil des Dateisystems implementiert, sondern als
      <acronym>GEOM</acronym>-Erweiterung.</para>

    <para>Um die <command>gjournal</command>-Unterstützung zu
      aktivieren, muss der &os;-Kernel die folgende Option
      enthalten:</para>

    <programlisting>options	UFS_GJOURNAL</programlisting>

    <para>Um ein Volume mit Journalunterstützung beim Systemstart
      automatisch zu mounten,  muss das Kernelmodul
      <filename>geom_journal.ko</filename> ebenfalls automatisch geladen
      werden (durch einen entsprechenden Eintrag in der Datei
      <filename>/boot/loader.conf</filename>):</para>

    <programlisting>geom_journal_load="YES"</programlisting>

    <para>Alternativ können Sie auch einen angepassten Kernel
      bauen, der diese Funktionalität enthält, indem Sie die
      folgende Zeile in die Kernelkonfigurationsdatei
      aufnehmen:</para>

    <programlisting>options     GEOM_JOURNAL</programlisting>

    <para>Das Anlegen eines neuen Journals auf einem freien Dateisystem
      erfolgt durch die folgenden Schritte (im Folgenden wird
      angenommen, dass es sich bei <filename>da4</filename> um
      eine neue <acronym>SCSI</acronym>-Platte handelt):</para>

    <screen>&prompt.root; <userinput>gjournal load</userinput>
&prompt.root; <userinput>gjournal label /dev/da4</userinput></screen>

    <para>Danach sollten die Gerätedateien
      <filename>/dev/da4</filename> sowie
      <filename>/dev/da4.journal</filename> vorhanden sein.  Nun
      können Sie auf diesem Gerät ein Dateisystem
      anlegen:</para>

    <screen>&prompt.root; <userinput>newfs -O 2 -J /dev/da4.journal</userinput></screen>

    <para>Dieser Befehl erzeugt ein <acronym>UFS</acronym>2-Dateisystem
      auf dem Gerät, für das im letzten Schritt das
      Journaling aktiviert wurde.</para>

    <para>Danach hängen Sie das neue Dateisystem mit
      <command>mount</command> in den Verzeichnisbaum ein:</para>

    <screen>&prompt.root; <userinput>mount /dev/da4.journal /mnt</userinput></screen>

    <note>
      <para>Falls auf Ihrem System mehrere Slices angelegt sind
	(beispielsweise <filename>ad4s1</filename> sowie
	<filename>ad4s2</filename>), wird
	<command>gjournal</command> für jedes Slice ein
	Journal anlegen (also <filename>ad4s1.journal</filename>
	sowie <filename>ad4s2.journal</filename>).</para>
    </note>

    <para>Um die Leistung zu optimieren, kann das Journal auf eine
      externe Platte ausgelagert werden.  In einem solchen Fall
      geben Sie die Gerätedatei der Platte nach dem Gerät
      an, für das Sie Journaling aktivieren wollen.
      Theoretisch ist es auch möglich, Journaling auf bereits
      existierenden Dateisystemen durch das Werkzeug
      <command>tunefs</command> zu aktivieren.  Machen Sie aber
      <emphasis>immer</emphasis> eine Sicherung der Daten, bevor Sie
      versuchen, ein existierendes Dateisystem zu ändern.
      <command>gjournal</command> wird zwar den Vorgang abbrechen,
      wenn es das Journal nicht erzeugen kann, allerdings schützt
      dies nicht vor Datenverlust durch einen fehlerhaften Einsatz
      von <command>tunefs</command>.</para>

    <para>Es ist möglich, Journale auch für die Bootplatte eines
      &os;-Systems zu verwenden.  Der Artikel <link
	xlink:href="&url.articles.gjournal-desktop.en;/article.html">
	Implementing UFS Journaling on a Desktop PC</link> enthält
      eine ausführliche Anleitung zu diesem Thema.</para>
  </sect1>
</chapter>
