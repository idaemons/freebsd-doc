<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/security/chapter.xml,v 1.178 2012/04/30 17:07:41 bcr Exp $
     basiert auf: r44311
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="security">
  <info><title>Sicherheit</title>
    <authorgroup>
      <author>
	<personname>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</personname>
	<contrib>Neu verfasst von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Martin</firstname><surname>Heinen</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>

  
  <indexterm><primary>Sicherheit</primary></indexterm>

  <sect1 xml:id="security-synopsis">
    <title>Übersicht</title>

    <para>Sicherheit, ob nun physisch oder virtuell, ist ein so breit
      gefächertes Thema, dass sich eine ganze Industrie darum gebildet
      hat.  Es wurden bereits hunderte Verfahren zur Sicherung von
      Systemen und Netzwerken verfasst, und als Benutzer von &os; ist
      es unumgänglich zu verstehen, wie Sie sich gegen Angreifer und
      Eindringlinge schützen können.</para>


    <para>In diesem Kapitel werden einige Grundlagen und Techniken
      diskutiert.  Ein &os;-System implementiert Sicherheit in
      mehreren Schichten, und viele weitere Programme von
      Drittanbietern können zur Verbesserung der Sicherheit
      beitragen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie:</para>

    <itemizedlist>
      <listitem>
	<para>Grundlegende auf &os; bezogene Sicherheitsaspekte
	  kennen.</para>
      </listitem>

      <listitem>
	<para>Die verschiedenen Verschlüsselungsmechanismen
	  von &os; kennen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie ein Einmalpasswörter
	  zur Authentifizierung verwenden.</para>
      </listitem>

      <listitem>
	<para><acronym>TCP</acronym>-Wrapper für &man.inetd.8;
	  einrichten können.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <application>Kerberos</application>
	  unter &os; einrichten.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie IPsec konfigurieren und ein
	  <acronym>VPN</acronym> einrichten.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <application>OpenSSH</application> unter
	  &os; konfigurieren und benutzen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <acronym>ACL</acronym>s für Dateisysteme
	  benutzen.</para>
      </listitem>

      <listitem>
	<para><application>Portaudit</application> anwenden können,
	  um Softwarepakete aus der Ports-Sammlung auf bekannte
	  Sicherheitslücken hin zu überprüfen.</para>
      </listitem>

      <listitem>
	<para>Mit &os;-Sicherheitshinweisen umgehen können.</para>
      </listitem>

      <listitem>
	<para>Eine Vorstellung davon haben, was Prozessüberwachung
	  (<foreignphrase>Process Accounting</foreignphrase>) ist und
	  wie Sie diese Funktion unter &os; aktivieren können.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie die Ressourcen-Datenbank benutzt, um die
	  Ressourcen für Benutzer zu steuern.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Grundlegende Konzepte von &os; und dem Internet
	  verstehen.</para>
      </listitem>
    </itemizedlist>

    <para>Dieses Buch behandelt weitere Sicherheitsthemen.
      Beispielsweise werden verbindliche Zugriffskontrollen
      im <xref linkend="mac"/> und Firewalls im
      <xref linkend="firewalls"/> besprochen.</para>
  </sect1>

  <sect1 xml:id="security-intro">
    <title>Einführung</title>

    <para>Sicherheit ist die Verantwortung eines jeden Einzelnen.  Ein
      schwacher Einstiegspunkt in einem System kann einem
      Eindringling Zugriff auf wichtige Informationen verschaffen, was
      sich verheerend auf das gesamte Netzwerk auswirken kann.  Eines
      der Grundprinzipien der Informationssicherheit sind die
      Vertraulichkeit, Integrität und Verfügbarkeit von
      Informationssystemen.</para>

    <para>Diese Grundprinzipien sind ein fundamentales Konzept der
      Computer-Sicherheit, da Kunden und Benutzer erwarten, dass ihre
      Daten geschützt sind.  Zum Beispiel erwartet ein Kunde, dass
      seine Kreditkarteninformationen sicher gespeichert werden
      (Vertraulichkeit), dass seine Aufträge nicht hinter den Kulissen
      geändert werden (Integrität) und dass er zu jeder Zeit Zugang zu
      seinen Informationen hat (Verfügbarkeit).</para>

    <para>Um diese Grundprinzipien zu implementieren, wenden
      Sicherheitsexperten das sogenannte
      <foreignphrase>Defense-in-Depth</foreignphrase>-Konzept an.  Die
      Idee dahinter ist, mehrere Sicherheitsschichten zu addieren, so
      dass nicht die gesamte Systemsicherheit gefährdet ist, wenn
      eine einzelne Sicherheitsschicht kompromittiert wird.
      Beispielsweise ist es nicht ausreichend, ein Netzwerk oder ein
      System nur mit einer Firewall zu sichern.  Der
      Systemadministrator muss auch Benutzerkonten überwachen, die
      Integrität von Binärdateien prüfen und sicherstellen, dass keine
      bösartigen Programme installiert sind.  Um eine effektive
      Sicherheitsstrategie zu implementieren, muss man Bedrohungen
      verstehen und wissen, wie man sich dagegen verteidigen
      kann.</para>

    <para>Was ist eine Bedrohung, wenn es um Computer-Sicherheit geht?
      Bedrohungen beschränken sich nicht nur auf entfernte Angreifer,
      die sich unerlaubten Zugriff auf ein System verschaffen wollen.
      Zu den Bedrohungen zählen auch Mitarbeiter, bösartige Software,
      nicht autorisierte Netzwerkgeräte, Naturkatastrophen,
      Sicherheitslücken und sogar konkurrierende Unternehmen.</para>

    <para>Der Zugriff auf Netzwerke und Systeme erfolgt ohne
      Erlaubnis, manchmal durch Zufall, oder von entfernten
      Angreifern, und in einigen Fällen durch Industriespionage oder
      ehemalige Mitarbeiter.  Als Anwender müssen Sie vorbereitet sein
      und auch zugeben, wenn ein Fehler zu einer Sicherheitsverletzung
      geführt hat.  Melden Sie Probleme umgehend dem verantwortlichen
      Sicherheitspersonal.  Als Administrator ist es wichtig,
      Bedrohungen zu kennen und darauf vorbereitet zu sein, mögliche
      Schäden zu mildern.</para>

    <para>Wenn Sicherheit auf Systeme angewendet wird, empfiehlt es
      sich mit der Sicherung der Benutzerkonten zu beginnen und dann
      die Netzwerkschicht zu sichern.  Dabei ist zu beachten, dass die
      Sicherheitsrichtlinien des Systems und des Unternehmens
      eingehalten werden.  Viele Unternehmen haben bereits eine
      Sicherheitsrichtlinie, welche die Konfiguration von technischen
      Geräten abdeckt.  Die Richtlinie sollte die Konfiguration von
      Arbeitsplatzrechnern, Desktops, mobilen Geräten, Mobiltelefonen,
      Produktions- und Entwicklungsservern umfassen.  In einigen
      Fällen ist bereits eine Standardvorgehensweise vorhanden.
      Fragen Sie im Zweifelsfall das Sicherheitspersonal.</para>

    <para>Der übrige Teil dieser Einführung beschreibt, wie einige
      dieser grundlegenden Sicherheitskonfigurationen auf einem
      &os;-System durchgeführt werden.  Der Rest dieses Kapitels
      beschreibt einige spezifische Werkzeuge, die verwendet werden
      können, um eine Sicherheitsrichtlinie auf einem &os;-System zu
      implementieren.</para>

    <sect2 xml:id="security-accounts">
      <title>Anmeldungen am System verhindern</title>

      <para>Ein guter Ausgangspunkt für die Absicherung des Systems
	ist die Prüfung der Benutzerkonten.  Stellen Sie sicher, dass
	<systemitem class="username">root</systemitem> ein starkes
	Passwort besitzt und dass dieses Passwort nicht weitergegeben
	wird.  Deaktivieren Sie alle Konten, die keinen Zugang zum
	System benötigen.</para>

      <para>Es existieren zwei Methoden, um die Anmeldung über ein
	Benutzerkonto zu verweigern.  Die erste Methode ist, das
	Konto zu sperren.  Dieses Beispiel sperrt das Benutzerkonto
	<systemitem class="username">toor</systemitem>:</para>

      <screen>&prompt.root; <userinput>pw lock <replaceable>toor</replaceable></userinput></screen>

      <para>Bei der zweiten Methode wird der Anmeldevorgang
	verhindert, indem die Shell auf
	<filename>/sbin/nologin</filename> gesetzt wird.  Nur der
	Superuser kann die Shell für andere Benutzer ändern:</para>

      <screen>&prompt.root; <userinput>chsh -s /usr/sbin/nologin <replaceable>toor</replaceable></userinput></screen>

      <para>Die Shell <filename>/usr/sbin/nologin</filename>
	verhindert, dass dem Benutzer bei der Anmeldung am System eine
	Shell zugeordnet wird.</para>
    </sect2>

    <sect2 xml:id="security-accountmgmt">
      <title>Gemeinsame Nutzung von Benutzerkonten</title>

      <para>In manchen Fällen wird die Systemadministration auf
	mehrere Benutzer aufgeteilt.  &os; bietet zwei Methoden, um
	solche Situationen zu handhaben.  Bei der ersten und nicht
	empfohlenen Methode wird ein gemeinsames root Passwort der
	Mitglieder der Gruppe <systemitem
	class="groupname">wheel</systemitem> verwendet.  Hier gibt
	der Benutzer <command>su</command> und das Passwort für
	<systemitem class="groupname">wheel</systemitem> ein, wenn er
	die Rechte des Superusers benötigt.  Der Benutzer sollte dann
	nach der Beendigung der administrativen Aufgaben
	<command>exit</command> eingeben.  Um einen Benutzer zu dieser
	Gruppe hinzuzufügen, bearbeiten Sie
	<filename>/etc/group</filename> und fügen Sie den Benutzer an
	das Ende des Eintrags <literal>wheel</literal> hinzu.  Die
	Benutzer müssen durch Komma und ohne Leerzeichen getrennt
	werden.</para>

      <para>Die zweite und empfohlene Methode ein Benutzerkonto zu
	teilen wird über den Port oder das Paket
	<package>security/sudo</package> realisiert.  Dieses Programm
	bietet zusätzliche Prüfungen, bessere Benutzerkontrolle und
	es kann auch konfiguriert werden, einzelnen Benutzern Zugriff
	auf bestimme, privilegierte Befehle zu gestatten.</para>

      <para>Benutzen Sie nach der Installation
	<command>visudo</command>, um
	<filename>/usr/local/etc/sudoers</filename> zu bearbeiten.
	Dieses Beispiel erstellt eine neue Gruppe <systemitem
	  class="groupname">webadmin</systemitem> und fügt das
	Benutzerkonto <systemitem
	  class="username">trhodes</systemitem> dieser Gruppe hinzu.
	Anschließend wird die Gruppe so konfiguriert, dass es
	Gruppenmitgliedern gestattet wird <package>apache24</package>
	neu zu starten:</para>

      <screen>&prompt.root; <userinput>pw groupadd webadmin -M trhodes -g 6000</userinput>
&prompt.root; <userinput>visudo</userinput>
%webadmin ALL=(ALL) /usr/sbin/service apache24 *</screen>
    </sect2>

    <sect2 xml:id="security-passwords">
      <title>Passwort-Hashes</title>

      <para>Passwörter sind ein notwendiges Übel.  Wenn sie verwendet
       werden müssen, sollten sie sehr komplex sein und dazu sollte
       eine leistungsfähige Hash-Funktion gewählt werden, um die
       Version des Passworts zu verschlüsseln, die in der
       Passwortdatenbank gespeichert wird.  &os; unterstützt die
       Hash-Funktionen <acronym>DES</acronym>, <acronym>MD5</acronym>,
       <acronym>SHA256</acronym>, <acronym>SHA512</acronym>, sowie
       Blowfish Hash-Funktionen in seiner
       <function>crypt()</function>-Bibliothek.  Das in der
       Voreinstellung verwendete <acronym>SHA512</acronym> sollte
       nicht durch eine weniger sichere Hash-Funktion getauscht
       werden.  Es kann jedoch durch den besseren Blowfish-Algorithmus
       ersetzt werden.</para>

      <note>
	<para>Blowfish ist nicht Bestandteil von
	  <acronym>AES</acronym> und ist nicht kompatibel mit allen
	  Federal Information Processing Standards
	  (<acronym>FIPS</acronym>).  Die Verwendung wird in einigen
	  Umgebungen vielleicht nicht gestattet.</para>
      </note>

      <para>Um zu bestimmen, welche Hash-Funktion das Passwort eines
	Benutzers verschlüsselt, kann der Superuser den Hash für den
	Benutzer in der Passwortdatenbank von &os; nachsehen.  Jeder
	Hash beginnt mit einem Zeichen, mit dem die verwendete
	Hash-Funktion identifiziert werden kann.  Bei
	<acronym>DES</acronym> gibt es allerdings kein führendes
	Zeichen.  <acronym>MD5</acronym> benutzt das Zeichen
	<literal>$</literal>.  <acronym>SHA256</acronym> und
	<acronym>SHA512</acronym> verwenden das Zeichen
	<literal>$6$</literal>.  Blowfish benutzt das Zeichen
	<literal>$2a$</literal>.  In diesem Beispiel wird das Passwort
	von <systemitem class="username">dru</systemitem> mit dem
	Hash-Algorithmus <acronym>SHA512</acronym> verschlüsselt, da
	der Hash mit <literal>$6$</literal> beginnt.  Beachten Sie,
	dass der verschlüsselte Hash und nicht das Passwort selbst, in
	der Passwortdatenbank gespeichert wird:</para>

      <screen>&prompt.root; <userinput>grep dru /etc/master.passwd</userinput>
dru:$6$pzIjSvCAn.PBYQBA$PXpSeWPx3g5kscj3IMiM7tUEUSPmGexxta.8Lt9TGSi2lNQqYGKszsBPuGME0:1001:1001::0:0:dru:/usr/home/dru:/bin/csh</screen>

      <para>Der Hash-Mechanismus wird in der Login-Klasse des
	Benutzers festgelegt.  In diesem Beispiel wird die
	voreingestellte Login-Klasse für den Benutzer verwendet.  Der
	Hash-Algorithmus wird mit dieser Zeile in
	<filename>/etc/login.conf</filename> gesetzt:</para>

      <programlisting>        :passwd_format=sha512:\</programlisting>

      <para>Um den Algorithmus auf Blowfish zu ändern, passen Sie die
	Zeile wie folgt an:</para>

      <programlisting>        :passwd_format=blf:\</programlisting>

      <para>Führen Sie anschließend <command>cap_mkdb
	/etc/login.conf</command> aus, wie in <xref
	  linkend="users-limiting"/> beschrieben.  Beachten Sie, dass
	vorhandene Passwort-Hashes durch diese Änderung nicht
	beeinträchtigt werden.  Das bedeutet, dass alle Passwörter neu
	gehasht werden sollten, indem die Benutzer mit
	<command>passwd</command> ihr Passwort ändern.</para>

      <para>Für die Anmeldung auf entfernten Rechnern sollte eine
	Zwei-Faktor-Authentifizierung verwendet werden.  Ein Beispiel
	für eine Zwei-Faktor-Authentifizierung ist
	<quote>etwas, was Sie besitzen</quote> (bspw. einen Schlüssel)
	und <quote>etwas, was Sie wissen</quote> (bspw. das Passwort
	für diesen Schlüssel).  Da <application>OpenSSH</application>
	Teil des &os;-Basissystems ist, sollten alle Anmeldungen über
	das Netzwerk über eine verschlüsselte Verbindung mit einer
	schlüsselbasierten Authentifizierung stattfinden. Passwörter
	sollten hier nicht verwendet werden.  Weitere Informationen
	finden Sie in <xref linkend="openssh"/>.  Kerberos-Benutzer
	müssen eventuell zusätzliche Änderungen vornehmen, um
	<application>OpenSSH</application> in Ihrem Netzwerk zu
	implementieren.  Diese Änderungen sind in <xref
	  linkend="kerberos5"/> beschrieben.</para>
    </sect2>

    <sect2 xml:id="security-pwpolicy">
      <title>Durchsetzung einer Passwort-Richtlinie</title>

      <para>Die Durchsetzung einer starken Passwort-Richtlinie für
	lokale Benutzerkonten ist ein wesentlicher Aspekt der
	Systemsicherheit.  In &os; kann die Länge, Stärke und
	Komplexität des Passworts mit den
	<foreignphrase>Pluggable Authentication Modules</foreignphrase>
	(<acronym>PAM</acronym>) implementiert werden.</para>

      <para>In diesem Abschnitt wird gezeigt, wie Sie die minimale und
	maximale Passwortlänge und die Durchsetzung von gemischten
	Zeichen mit dem Modul <filename>pam_passwdqc.so</filename>
	konfigurieren.  Dieses Modul wird aufgerufen, wenn ein
	Benutzer sein Passwort ändert.</para>

      <para>Um dieses Modul zu konfigurieren, müssen Sie als Superuser
	die Zeile mit <literal>pam_passwdqc.so</literal> in
	<filename>/etc/pam.d/passwd</filename> auskommentieren.
	Anschließend bearbeiten Sie die Zeile, so dass sie den
	vorliegenden Passwort-Richtlinien entspricht:</para>

      <programlisting>password        requisite       pam_passwdqc.so <replaceable>min=disabled,disabled,disabled,12,10 similar=deny retry=3</replaceable> enforce=users</programlisting>

      <para>Dieses Beispiel legt gleich mehrere Anforderungen für neue
	Passwörter fest.  Die Einstellung <literal>min</literal>
	kontrolliert die Passwortlänge.  Es verfügt über fünf Werte,
	weil dieses Modul fünf verschiedene Arten von Passwörtern
	definiert, basierend auf der Komplexität.  Die Komplexität
	wird durch die Art von Zeichen definiert, die in einem
	Passwort vorhanden sind, wie zum Beispiel Buchstaben, Zahlen
	und Sonderzeichen.  Die verschiedenen Arten von Passwörtern
	werden in &man.pam.passwdqc.8; beschrieben.  In diesem
	Beispiel sind die ersten drei Arten von Passwörtern
	deaktiviert, was bedeutet, dass Passwörter, die dieser
	Komplexitätsstufe entsprechen, nicht akzeptiert werden,
	unabhängig von der Länge des Passworts.  Die
	<literal>12</literal> legt eine Richtlinie von mindestens
	zwölf Zeichen fest, wenn das Passwort auch drei Arten von
	Komplexität aufweist.  Die <literal>10</literal> legt eine
	Richtlinie fest, die auch Passwörter mit mindestens zehn
	Zeichen zulassen, wenn das Passwort Zeichen mit vier Arten
	von Komplexität aufweist.</para>

      <para>Die Einstellung <literal>similar</literal> verbietet
	Passwörter, die dem vorherigen Passwort des Benutzers ähnlich
	sind.  Die Einstellung <literal>retry</literal> bietet dem
	Benutzer drei Möglichkeiten, ein neues Passwort
	einzugeben.</para>

      <para>Sobald diese Datei gespeichert wird, sehen Benutzer bei
	der Änderung ihres Passworts die folgende Meldung:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for trhodes
Old Password:

You can now choose the new password.
A valid password should be a mix of upper and lower case letters,
digits and other characters.  You can use a 12 character long
password with characters from at least 3 of these 4 classes, or
a 10 character long password containing characters from all the
classes.  Characters that form a common pattern are discarded by
the check.
Alternatively, if noone else can see your terminal now, you can
pick this as your password: "trait-useful&amp;knob".
Enter new password:</screen>

      <para>Wenn ein Passwort nicht den Richtlinien entspricht, wird
	es mit einer Warnung abgelehnt und der Benutzer bekommt die
	Möglichkeit, es erneut zu versuchen, bis die Anzahl an
	Wiederholungen erreicht ist.</para>

      <para>Die meisten Passwort-Richtlinien erzwingen, dass
	Passwörter nach einer bestimmten Anzahl von Tagen ablaufen.
	Um dieses Limit in &os; zu konfigurieren, setzen Sie es für
	die Login-Klasse des Benutzers in
	<filename>/etc/login.conf</filename>.  Die voreingestellte
	Login-Klasse enthält dazu ein Beispiel:</para>

      <programlisting>#       :passwordtime=90d:\</programlisting>

      <para>Um für diese Login-Klasse das Passwort nach 90 Tagen
	ablaufen zu lassen, entfernen Sie das Kommentarzeichen
	(<literal>#</literal>), speichern Sie die Änderungen und
	führen Sie <command>cap_mkdb /etc/login.conf</command>
	aus.</para>

      <para>Um das Passwort für einzelne Benutzer ablaufen zu lassen,
	geben Sie <command>pw</command> ein Ablaufdatum oder die
	Anzahl von Tagen, zusammen mit dem Benutzer an:</para>

      <screen>&prompt.root; <userinput>pw usermod -p <replaceable>30-apr-2015</replaceable> -n <replaceable>trhodes</replaceable></userinput></screen>

      <para>Wie zu sehen ist, wird das Ablaufdatum in der Form von
	Tag, Monat und Jahr angegeben. Weitere Informationen finden
	Sie in &man.pw.8;.</para>
    </sect2>

    <sect2 xml:id="security-rkhunter">
      <title>Erkennen von Rootkits</title>

      <para>Ein <firstterm>Rootkit</firstterm> ist eine nicht
	autorisierte Software die versucht, Root-Zugriff auf ein
	System zu erlangen.  Einmal installiert, wird diese bösartige
	Software normalerweise eine Hintertür für den Angreifer
	installieren.  Realistisch betrachtet sollte ein durch ein
	Rootkit kompromittiertes System nach der Untersuchung von
	Grund auf neu installiert werden.  Es besteht jedoch die
	enorme Gefahr, dass sogar das Sicherheitspersonal oder
	Systemingenieure etwas übersehen, was ein Angreifer dort
	platziert hat.</para>

      <para>Wird ein Rootkit erkannt, ist dies bereits ein Zeichen
	dafür, dass das System an einem bestimmten Zeitpunkt
	kompromittiert wurde.  Meist neigen diese Art von Anwendungen
	dazu, sehr gut versteckt zu sein.  Dieser Abschnitt zeigt ein
	Werkzeug, mit dem Rootkits erkannt werden können:
	<package>security/rkhunter</package>.</para>

      <para>Nach der Installation dieses Ports oder Pakets kann das
	System mit dem folgenden Kommando überprüft werden.  Das
	Programm generiert eine ganze Menge Informationen und Sie
	werden diverse Male <keycap>ENTER</keycap> drücken
	müssen:</para>

      <screen>&prompt.root; <userinput>rkhunter -c</userinput></screen>

      <para>Nachdem der Prozess abgeschlossen ist, wird eine
	Statusmeldung auf dem Bildschirm ausgegeben.  Die Meldung
	enthält die Anzahl der überprüften Dateien, verdächtige
	Dateien, mögliche Rootkits und weitere Informationen.  Während
	der Überprüfung erscheinen allgemeine Sicherheitswarnungen,
	zum Beispiel über versteckte Dateien, die Auswahl von
	<application>OpenSSH</application>-Protokollen und bekannte,
	anfällige Versionen installierter Anwendungen.  Diese können
	nun direkt, oder nach detaillierter Analyse untersucht
	werden.</para>

      <para>Jeder Administrator sollte wissen, was auf den Systemen
	läuft, für die er verantwortlich ist.  Werkzeuge von
	Drittanbietern, wie <application>rkhunter</application> oder
	<package>sysutils/lsof</package>, sowie native Befehle wie
	<application>netstat</application> oder
	<application>ps</application>, können eine große Menge an
	Informationen über das System anzeigen.  Machen Sie sich
	Notizen darüber, was <quote>normal</quote> ist, und fragen Sie
	nach, wenn Ihnen etwas suspekt erscheint.  Eine
	Beeinträchtigung zu verhindern ist ideal, aber die Erkennung
	einer Beeinträchtigung ist ein Muss.</para>
    </sect2>

    <sect2 xml:id="security-ids">
      <title>Überprüfung von Binärdateien</title>

      <para>Die Überprüfung von System- und Binärdateien ist wichtig,
	da sie Systemadministratoren Informationen über
	Systemänderungen zur Verfügung stellt.  Eine Software, die das
	System auf Änderungen überwacht wird <foreignphrase>Intrustion
	  Detection System</foreignphrase> (<acronym>IDS</acronym>)
	genannt.</para>
	
      <para>&os; bietet native Unterstützung für ein einfaches
	<acronym>IDS</acronym>-System.  Obwohl die täglichen
	Sicherheits-E-Mails den Administrator über Änderungen in
	Kenntnis setzen, werden diese Informationen lokal gespeichert
	und es besteht die Möglichkeit, dass ein Angreifer diese
	Informationen manipulieren kann, um Änderungen am System zu
	verbergen.  Daher ist es empfehlenswert, einen eigenen Satz an
	Signaturen zu erstellen und diese dann in einem
	schreibgeschützten Verzeichnis, oder vorzugsweise auf einem
	<acronym>USB</acronym>-Stick oder auf einem entfernten Server
	zu speichern.</para>

      <para>Das im Basissystem enthaltene Werkzeug
	<application>mtree</application> kann verwendet werden, um
	eine Spezifikation des Inhalts eines Verzeichnisses zu
	erzeugen.  Hierbei wird ein Startwert
	(<foreignphrase>Seed</foreignphrase>) oder eine numerische
	Konstante benutzt, um die Spezifikation zu erstellen und um
	sicherzustellen, dass sich die Spezifikation nicht geändert
	hat.  Dadurch kann festgestellt werden, ob eine Datei oder
	eine Binärdatei verändert wurde.  Da ein Angreifer den
	Seed nicht kennt, ist es ihm fast unmöglich die
	Prüfsummen von Dateien zu manipulieren.  Das folgende Beispiel
	generiert einen Satz mit <acronym>SHA256</acronym>-Prüfsummen
	für jede Binärdatei unterhalb von <filename>/bin</filename>
	und speichert diese Werte in einer versteckten Datei im
	Heimatverzeichnis von <systemitem
	  class="username">root</systemitem> unter dem Namen
	<filename>/root/.bin_chksum_mtree</filename>:</para>

      <screen>&prompt.root; <userinput>mtree -s <replaceable>3483151339707503</replaceable> -c -K cksum,sha256digest -p <replaceable>/bin</replaceable> &gt; <replaceable>/root/.bin_chksum_mtree</replaceable></userinput>
&prompt.root; mtree: /bin checksum: 3427012225</screen>

      <para><replaceable>3483151339707503</replaceable> stellt den
	Seed dar.  Diesen Wert sollten Sie sich merken, aber
	nicht mit anderen Personen teilen.</para>

      <para>Die Ausgabe von
	<filename>/root/.bin_chksum_mtree</filename> sollte ähnlich
	der folgenden sein:</para>

      <programlisting>#          user: root
#       machine: dreadnaught
#          tree: /bin
#          date: Mon Feb  3 10:19:53 2014

# .
/set type=file uid=0 gid=0 mode=0555 nlink=1 flags=none
.               type=dir mode=0755 nlink=2 size=1024 \
                time=1380277977.000000000
    \133        nlink=2 size=1170 time=1380277977.000000000 \
                cksum=484492447 \
                sha256digest=6207490fbdb5ed1904441fbfa941279055c3e24d3a4049aeb45094596400662a
    cat         size=12096 time=1380277975.000000000 cksum=3909216944 \
                sha256digest=65ea347b9418760b247ab10244f47a7ca2a569c9836d77f074e7a306900c1e69
    chflags     size=8168 time=1380277975.000000000 cksum=3949425175 \
                sha256digest=c99eb6fc1c92cac335c08be004a0a5b4c24a0c0ef3712017b12c89a978b2dac3
    chio        size=18520 time=1380277975.000000000 cksum=2208263309 \
                sha256digest=ddf7c8cb92a58750a675328345560d8cc7fe14fb3ccd3690c34954cbe69fc964
    chmod       size=8640 time=1380277975.000000000 cksum=2214429708 \
                sha256digest=a435972263bf814ad8df082c0752aa2a7bdd8b74ff01431ccbd52ed1e490bbe7</programlisting>

      <para>Der Report enthält den Rechnernamen, das Datum und die
	Uhrzeit der Spezifikation, sowie den Namen des Benutzers, der
	die Spezifikation erstellt hat.  Für jede Binärdatei im
	Verzeichnis gibt es eine Prüfsumme, Größe, Uhrzeit und einen
	<acronym>SHA256</acronym>-Hashwert.</para>

      <para>Um sicherzustellen, dass die binären Signaturen nicht
        verändert wurden, vergleichen Sie den Inhalt des aktuellen
	Verzeichnisses mit der zuvor erstellen Spezifikation.
	Speichern Sie die Ergebnisse in einer Datei.  Dieses Kommando
	benötigt den Seed, der verwendet wurde um die
	ursprüngliche Spezifikation zu erstellen:</para>

      <screen>&prompt.root; <userinput>mtree -s <replaceable>3483151339707503</replaceable> -p <replaceable>/bin</replaceable> &lt; <replaceable>/root/.bin_chksum_mtree</replaceable> &gt;&gt; <replaceable>/root/.bin_chksum_output</replaceable></userinput>
&prompt.root; mtree: /bin checksum: 3427012225</screen>

      <para>Dies sollte die gleiche Prüfsumme für
	<filename>/bin</filename> produzieren, wie die ursprüngliche
	Spezifikation.  Wenn keine Änderungen an den Binärdateien in
	diesem Verzeichnis aufgetreten sind, wird die Ausgabedatei
	<filename>/root/.bin_chksum_output</filename> leer sein.  Um
	eine Änderung zu simulieren, ändern Sie mit
	<command>touch</command> das Datum von
	<filename>/bin/cat</filename> und führen Sie die Verifikation
	erneut aus:</para>

      <screen>&prompt.root; <userinput>touch /bin/cat</userinput>
&prompt.root; <userinput>mtree -s <replaceable>3483151339707503</replaceable> -p <replaceable>/bin</replaceable> &lt; <replaceable>/root/.bin_chksum_mtree</replaceable> &gt;&gt; <replaceable>/root/.bin_chksum_output</replaceable></userinput>
&prompt.root; <userinput>more /root/.bin_chksum_output</userinput>
cat changed
	modification time expected Fri Sep 27 06:32:55 2013 found Mon Feb  3 10:28:43 2014</screen>

      <para>Es wird empfohlen, Spezifikationen für Verzeichnisse zu
	erstellen, welche Binärdateien, Konfigurationsdateien und
	sensible Daten enthalten.  In der Regel werden Spezifikationen
	für <filename>/bin</filename>, <filename>/sbin</filename>,
	<filename>/usr/bin</filename>, <filename>/usr/sbin</filename>,
	<filename>/usr/local/bin</filename>,
	<filename>/usr/local/sbin</filename>,
	<filename>/etc</filename> und
	<filename>/usr/local/etc</filename> erstellt.</para>

      <para>Mit <package>security/aide</package> steht ein
	fortgeschrittenes <acronym>IDS</acronym>-System zur Verfügung,
	aber in den meisten Fällen bietet <command>mtree</command> die
	Funktionalität, die von Administratoren benötigt wird.  Es ist
	jedoch sehr wichtig den Seed und die Prüfsummen in der
	Ausgabe vor böswilligen Benutzern verborgen zu halten.
	Weitere Informationen zu <command>mtree</command> finden Sie
	in &man.mtree.8;.</para>
    </sect2>

    <sect2 xml:id="security-tuning">
      <title>System-Tuning für Sicherheit</title>

      <para>Unter &os; können viele Systemfunktionen mit
	<command>sysctl</command> konfiguriert werden.  Dieser
	Abschnitt behandelt ein paar Sicherheitsmerkmale mit denen
	<foreignphrase>Denial of Service</foreignphrase>
	(<acronym>DoS</acronym>) verhindert werden sollen.  Weitere
	Informationen über die Benutzung von
	<command>sysctl</command> und wie Werte vorübergehend oder
	auch permanent geändert werden können, finden Sie in <xref
	  linkend="configtuning-sysctl"/>.</para>

      <note>
	<para>Jedes Mal wenn eine Einstellung mit
	  <command>sysctl</command> geändert wird, vergrößert sich die
	  Wahrscheinlichkeit eines unerwünschten Schadens, was die
	  Verfügbarkeit des Systems beeinflusst.  Alle Änderungen
	  sollten überwacht und wenn möglich, vorher auf einem
	  Testsystem ausprobiert werden, bevor sie auf einem
	  Produktivsystem verwendet werden.</para>
      </note>

      <para>In der Voreinstellung startet &os; in der Sicherheitsstufe
	(<foreignphrase>Securelevel</foreignphrase>)
	<literal>-1</literal>.  Dieser Modus wird
	<quote>unsicherer Modus</quote> genannt, da die
	unveränderlichen Datei-Flags ausgeschaltet werden können und
	dadurch von allen Geräten gelesen und geschrieben werden kann.
	Solange die Einstellung nicht über <command>sysctl</command>
	oder in den Startskripten geändert wird, verbleibt die
	Sicherheitsstufe auf <literal>-1</literal>.  Die
	Sicherheitsstufe kann während des Systemstarts erhöht werden.
	Dazu muss in <filename>/etc/rc.conf</filename>
	<varname>kern_securelevel_enable</varname> auf
	<literal>YES</literal> und <varname>kern_securelevel</varname>
	auf den gewünschten Wert gesetzt werden.  Weitere
	Informationen zu diesen Einstellungen und den verfügbaren
	Sicherheitsstufen finden Sie in &man.security.7; und
	&man.init.8;.</para>

      <warning>
	<para>Das Erhöhen der Sicherheitsstufe kann zu Problemen mit
	  <application>&xorg;</application> führen.</para>
      </warning>

      <para>Die Einstellungen
	<varname>net.inet.tcp.blackhole</varname> und
	<varname>net.inet.udp.blackhole</varname> können benutzt
	werden, um eingehende <acronym>SYN</acronym>-Pakete an
	geschlossenen Ports zu blockieren, ohne ein
	<acronym>RST</acronym>-Paket als Antwort zu senden.
	Standardmäßig wird jedoch ein <acronym>RST</acronym>-Paket
	gesendet, um zu zeigen, dass der Port geschlossen ist.  Das
	ändern dieser Voreinstellung bietet einen gewissen Schutz
	gegen Portscans.  Diese Portscans versuchen herauszufinden,
	welche Anwendungen auf einem System ausgeführt werden.  Setzen
	Sie <varname>net.inet.tcp.blackhole</varname> auf
	<literal>2</literal> und
	<varname>net.inet.udp.blackhole</varname> auf
	<literal>1</literal>.  Weitere Informationen zu diesen
	Einstellungen finden Sie in &man.blackhole.4;.</para>

      <para>Die Einstellung
	<varname>net.inet.icmp.drop_redirect</varname> hilft dabei,
	sogenannte Redirect-Angriffe zu verhindern.  Ein
	Redirect-Angriff ist eine Art von <acronym>DoS</acronym>, die
	massenhaft <acronym>ICMP</acronym>-Pakete Typ 5 versendet.  Da
	solche Pakete nicht benötigt werden, setzen Sie
	<varname>net.inet.icmp.drop_redirect</varname> auf
	<literal>1</literal> und
	<varname>net.inet.ip.redirect</varname> auf
	<literal>0</literal>.</para>

      <para><foreignphrase>Source Routing</foreignphrase> zur
	Erfassung und zum Zugriff auf nicht-routbare Adressen im
	internen Netzwerk.  Dies sollte deaktiviert werden, da
	nicht-routbare Adressen in der Regel nicht absichtlich
	geroutet werden.  Um diese Funktion zu deaktivieren, setzen
	Sie <varname>net.inet.ip.sourceroute</varname> und
	<varname>net.inet.accept_sourceroute</varname> auf
	<literal>0</literal>.</para>

      <para>Wenn ein Netzwerkgerät Nachrichten an alle Rechner in
	einem Subnetz senden muss, wird eine
	<acronym>ICMP</acronym>-Echo-Request Nachricht an die
	Broadcast-Adresse gesendet.  Allerdings gibt es keinen guten
	Grund für externe Rechner, solche Nachrichten zu verschicken.
	Um alle externen Broadcast-Anfragen abzulehnen, setzen Sie
	<varname>net.inet.icmp.bmcastecho</varname> auf
	<literal>0</literal>.</para>

      <para>Einige zusätzliche Einstellungen sind in &man.security.7;
	dokumentiert.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="one-time-passwords">
    <title>Einmalpasswörter</title>

    <indexterm><primary>Einmalpasswörter</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>Einmalpasswörter</secondary>
    </indexterm>

    <para>In der Voreinstellung unterstützt &os;
      <foreignphrase>One-time Passwords in Everything</foreignphrase>
      (<acronym>OPIE</acronym>).  <acronym>OPIE</acronym> wurde
      konzipiert um Replay-Angriffe zu verhindern, bei dem ein
      Angreifer das Passwort eines Benutzers ausspäht und es
      benutzt, um Zugriff auf ein System zu erlangen.  Da ein Passwort
      unter <acronym>OPIE</acronym> nur einmal benutzt wird, ist ein
      ausgespähtes Passwort für einen Angreifer nur von geringem
      Nutzen.  <acronym>OPIE</acronym> verwendet eine sichere
      Hash-Funktion und ein Challenge/Response-System, um Passwörter
      zu verwalten.  Die &os;-Implementation verwendet in der
      Voreinstellung die <acronym>MD5</acronym>-Hash-Funktion.</para>

    <para><acronym>OPIE</acronym> verwendet drei verschiedene Arten
      von Passwörtern.  Das erste ist das normale &unix;- oder
      Kerberos-Passwort.  Das zweite ist das Einmalpasswort, das von
      <command>opiekey</command> generiert wird.  Das dritte Passwort
      ist das <quote>geheime Passwort</quote>, das zum Erstellen der
      Einmalpasswörter verwendet wird.  Das geheime Passwort steht in
      keiner Beziehung zum &unix;-Passwort und beide Passwörter
      sollten unterschiedlich sein.</para>

    <para>Es gibt noch zwei weitere Werte, die für
      <acronym>OPIE</acronym> wichtig sind.  Der erste ist der
      <quote>Initialwert</quote> (engl.
      <foreignphrase>seed</foreignphrase> oder
      <foreignphrase>key</foreignphrase>), der aus zwei Buchstaben und
      fünf Ziffern besteht.  Der zweite Wert ist der
      <quote>Iterationszähler</quote>, eine Zahl zwischen 1 und 100.
      <acronym>OPIE</acronym> generiert das Einmalpasswort, indem
      es den Initialwert und das geheime Passwort aneinander hängt
      und dann die <acronym>MD5</acronym>-Hash-Funktion so oft, wie
      durch den Iterationszähler gegeben, anwendet.  Das Ergebnis wird
      in sechs englische Wörter umgewandelt, die das Einmalpasswort
      ergeben.  Das Authentifizierungssystem (meistens PAM) merkt sich
      das zuletzt benutzte Einmalpasswort und der Benutzer ist
      authentifiziert, wenn die Hash-Funktion des Passworts dem
      vorigen Passwort entspricht.  Da nicht umkehrbare
      Hash-Funktionen benutzt werden, ist es unmöglich, aus einem
      bekannten Passwort weitere gültige Einmalpasswörter zu
      berechnen.  Der Iterationszähler wird nach jeder erfolgreichen
      Anmeldung um eins verringert und stellt so die Synchronisation
      zwischen Benutzer und Login-Programm sicher.  Wenn der
      Iterationszähler den Wert <literal>1</literal> erreicht, muss
      <acronym>OPIE</acronym> neu initialisiert werden.</para>

    <para>Es gibt ein paar Programme, die in diesen Prozess einbezogen
      werden.  Ein Einmalpasswort oder eine Liste von
      Einmalpasswörtern, die von &man.opiekey.1; durch Angabe eines
      Iterationszählers, eines Initalwertes und einem geheimen
      Passwort generiert wird.  &man.opiepasswd.1; wird benutzt, um
      Passwörter, Iterationszähler oder Initialwerte zu ändern.
      &man.opieinfo.1; hingegen gibt den momentanen Iterationszähler
      und Initialwert eines Benutzers aus, den es aus
      <filename>/etc/opiekeys</filename> ermittelt.</para>
      <!-- Credential Dateien -->

    <para>Dieser Abschnitt beschreibt vier verschiedene Arten von
      Tätigkeiten.  Zuerst wird erläutert, wie Einmalpasswörter über
      eine gesicherte Verbindung konfiguriert werden.  Als nächstes
      wird erklärt, wie <command>opiepasswd</command> über
      eine nicht gesicherte Verbindung eingesetzt wird. Als drittes
      wird beschrieben, wie man sich über eine nicht gesicherte
      Verbindung anmeldet.  Die vierte Tätigkeit beschreibt, wie man
      eine Reihe von Schlüsseln generiert, die man sich aufschreiben
      oder ausdrucken kann, um sich von Orten anzumelden, die über
      keine gesicherten Verbindungen verfügen.</para>

    <sect2>
      <title><acronym>OPIE</acronym> initialisieren</title>

      <para>Um <acronym>OPIE</acronym> erstmals zu initialisieren,
	rufen Sie &man.opiepasswd.1; über eine gesicherte Verbindung
	auf:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:

ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
      </screen>

      <para>Die Option <option>-c</option> startet den Konsolen-Modus,
	der davon ausgeht, dass der Befehl von einem sicherem Ort
	ausgeführt wird.  Dies kann beispielsweise der eigene Rechner
	sein, oder über eine mit <acronym>SSH</acronym> gesicherte
	Verbindung zum eigenen Rechner.</para>

      <para>Geben Sie das geheime Passwort ein, wenn Sie danach
	gefragt werden.  Damit werden die Einmalpasswörter generiert.
	Dieses Passwort sollte schwer zu erraten sein und sich
	ebenfalls vom Passwort des Bentuzerkontos unterscheiden.  Es
	muss zwischen 10 und 127 Zeichen lang sein.  Prägen Sie sich
	dieses Passwort gut ein!</para>

      <para>Die Zeile, die mit <quote>ID</quote> beginnt, enthält den
	Login-Namen (<literal>unfrul</literal>), den voreingestellten
	Iterationszähler (<literal>499</literal>) und den Initialwert
	(<literal>to4268</literal>).  Das System erinnert sich an
	diese Parameter und wird sie bei einem Anmeldeversuch
	anzeigen.  Sie brauchen sich diese Dinge also nicht merken.
	Die letzte Zeile enthält das generierte Einmalpasswort, das
	aus den Parametern und dem geheimen Passwort ermittelt wurde.
	Bei der nächsten Anmeldung muss dann diese Einmalpasswort
	benutzt werden.</para>
    </sect2>

    <sect2>
      <title>Initialisierung über eine nicht gesicherte
	Verbindung</title>

      <para>Um Einmalpasswörter über eine nicht gesicherte Verbindung
	zu initialisieren, oder das geheime Passwort zu ändern, müssen
	Sie über eine gesicherte Verbindung zu einer Stelle verfügen,
	an der Sie <command>opiekey</command> ausführen können.  Dies kann etwa die
	Eingabeaufforderung auf einer Maschine sein, der Sie
	vertrauen.  Zudem müssen Sie einen Iterationszähler vorgeben
	(100 ist ein guter Wert) und einen Initialwert wählen, wobei
	Sie auch einen zufällig generierten benutzen können.  Benutzen
	Sie &man.opiepasswd.1; über die ungesicherte Verbindung zu der
	Maschine, die Sie einrichten wollen:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</screen>

      <para>Drücken Sie <keycap>Return</keycap>, um die Vorgabe
	für den Initialwert zu akzeptieren.  Bevor
	Sie nun das Zugriffspasswort
	(engl. <foreignphrase>access password</foreignphrase>)
	eingeben, rufen Sie über die gesicherte Verbindung
	<command>opikey</command> mit denselben Parametern auf:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Gehen Sie zurück zu der nicht gesicherten Verbindung
	und geben dort das eben generierte Einmalpasswort ein.</para>
    </sect2>

    <sect2>
      <title>Erzeugen eines einzelnen Einmalpasswortes</title>

      <para>Nachdem Sie <acronym>OPIE</acronym> eingerichtet haben,
	werden Sie beim nächsten Anmelden wie folgt begrüßt:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para><acronym>OPIE</acronym> besitzt eine nützliche
	Eigenschaft.  Wenn Sie an der Eingabeaufforderung
	<keycap>Return</keycap> drücken, wird die echo-Funktion
	eingeschaltet, das heißt Sie sehen, was Sie tippen.  Dies ist
	besonders nützlich, wenn Sie ein generiertes Passwort von
	einem Ausdruck abtippen müssen.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>Jetzt müssen Sie das Einmalpasswort generieren,
	um der Anmeldeaufforderung nachzukommen.  Dies muss auf
	einem gesicherten System geschehen, auf dem Sie
	&man.opiekey.1; ausführen können. Dieses Programm gibt es
	auch für &windows;, &macos; und &os;.  Es benötigt den
	Iterationszähler sowie den Initialwert als Parameter, die Sie
	mittels <quote>cut-and-paste</quote> direkt von der
	Login-Aufforderung nehmen können.</para>

      <para>Auf dem sicheren System:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Sobald das Einmalpasswort generiert wurde, können Sie die
	Anmeldeprozedur fortsetzen.</para>
    </sect2>

    <sect2>
      <title>Erzeugen von mehreren Einmalpasswörtern</title>

      <para>Manchmal haben Sie keinen Zugriff auf eine sichere
	Maschine oder eine sichere Verbindung.  In diesem Fall können
	Sie vorher mit &man.opiekey.1; einige Einmalpasswörter
	generieren.  Zum Beispiel:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para>Mit <option>-n 5</option> fordern Sie fünf
	Passwörter der Reihe nach an.  Der letzte
	Iterationszähler wird durch <option>30</option> gegeben.
	Beachten Sie bitte, dass die Passwörter in der
	<emphasis>umgekehrten</emphasis> Reihenfolge, in der sie
	zu benutzen sind, ausgeben werden.  Wirklich paranoide
	Benutzer können sich jetzt die Passwörter aufschreiben oder
	ausdrucken.  Sie sollten die Passwörter nach Gebrauch
	durchstreichen.</para>
    </sect2>

    <sect2>
      <title>Einschränken der Benutzung von
	System-Passwörtern</title>

      <para><acronym>OPIE</acronym> kann die Verwendung von
	&unix;-Passwörtern abhängig von der
	<acronym>IP</acronym>-Adresse einschränken.  Die dazu nötigen
	Einstellungen werden in <filename>/etc/opieaccess</filename>
	vorgenommen, die bei der Installation des Systems automatisch
	erzeugt wird.  Weitere Informationen über diese Datei und
	Sicherheitshinweise zu ihrer Verwendung finden Sie in
	&man.opieaccess.5;.</para>

      <para><filename>opieaccess</filename> könnte
	beispielsweise die folgende Zeile enthalten:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>Diese Zeile erlaubt es Benutzern, die sich von einer der
	angegebenen <acronym>IP</acronym>-Adressen anmelden, ihr
	&unix;-Passwort zu verwenden.  Beachten Sie bitte, dass eine
	<acronym>IP</acronym>-Adresse leicht gefälscht werden
	kann.</para>

      <para>Findet sich in <filename>opieaccess</filename> kein
	passender Eintrag, muss die Anmeldung mit
	<acronym>OPIE</acronym> erfolgen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="tcpwrappers">
    <info><title>TCP-Wrapper</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>TCP-Wrapper</primary>
    </indexterm>

    <para><acronym>TCP</acronym>-Wrapper erweitern die Fähigkeiten von
      <xref linkend="network-inetd"/>.  Beispielsweise können
      Verbindungen protokolliert, Nachrichten zurückgesandt oder nur
      interne Verbindungen angenommen werden.  Einige dieser
      Fähigkeiten können auch über eine Firewall implementiert werden,
      <acronym>TCP</acronym>-Wrapper fügen jedoch noch eine weitere
      Sicherheitsschicht und Kontrollmöglichkeiten hinzu, die eine
      Firewall nicht bieten kann.</para>

    <para><acronym>TCP</acronym>-Wrapper sollten nicht als Ersatz für
      eine ordentlich konfigurierte Firewall angesehen werden, sondern
      stattdessen in Verbindung mit einer Firewall und anderen
      Sicherheitsmechanismen eingesetzt werden.</para>

    <sect2>
      <title>TCP-Wrapper einrichten</title>

      <para>Um <acronym>TCP</acronym>-Wrapper unter &os; zu benutzen,
	muss der &man.inetd.8;-Server aus <filename>rc.conf</filename>
	mit den Optionen <option>-Ww</option> gestartet werden.
	Anschließend muss <filename>/etc/hosts.allow</filename>
	richtig konfiguriert werden.</para>

      <note>
        <para>Im Gegensatz zu anderen Implementierungen der
          <acronym>TCP</acronym>-Wrapper wird vom Gebrauch
          der Datei <filename>hosts.deny</filename> abgeraten.
          Die Konfiguration sollte sich vollständig in der
          Datei <filename>/etc/hosts.allow</filename> befinden.</para>
      </note>

      <para>In der einfachsten Konfiguration werden Dienste
        abhängig vom Inhalt der Datei
        <filename>/etc/hosts.allow</filename> erlaubt oder
        gesperrt.  Unter &os; wird in der Voreinstellung
        jeder von &man.inetd.8; gestartete Dienst
        erlaubt.</para>

      <para>Eine Konfigurationszeile ist wie folgt aufgebaut:
        <literal>Dienst : Adresse : Aktion</literal>.
        <literal>Dienst</literal> ist der von &man.inetd.8;
        gestartete Dienst (auch Daemon genannt).  Die
        <literal>Adresse</literal> ist ein gültiger
        Rechnername, eine <acronym>IP</acronym>-Adresse oder
        eine <acronym>IPv6</acronym>-Adresse in Klammern
        (<literal>[</literal>&nbsp;<literal>]</literal>).
        Der Wert <literal>allow</literal> im Feld
        <literal>Aktion</literal> erlaubt Zugriffe, der Wert
        <literal>deny</literal> verbietet Zugriffe.
        Die Zeilen in <filename>hosts.allow</filename>
        werden für jede Verbindung der Reihe nach
        abgearbeitet.  Trifft eine Zeile auf eine Verbindung
        zu, wird die entsprechende Aktion ausgeführt
        und die Abarbeitung ist beendet.</para>

      <para>Um beispielsweise einkommende
	<acronym>POP</acronym>3-Verbindungen für den Dienst
	<package>mail/qpopper</package> zu erlauben, sollte
	<filename>hosts.allow</filename> um die nachstehende Zeile
	erweitert werden:</para>

      <programlisting># This line is required for POP3 connections:
qpopper : ALL : allow</programlisting>

      <para>Nachdem Sie die Zeile hinzugefügt haben, muss
	&man.inetd.8; neu gestartet werden:</para>

      <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
    </sect2>

    <sect2>
      <title>Erweiterte Konfiguration</title>

      <para><acronym>TCP</acronym>-Wrapper besitzen
	weitere Optionen, die bestimmen, wie Verbindungen
	behandelt werden.  In einigen Fällen ist es
	gut, wenn bestimmten Rechnern oder Diensten eine
	Nachricht geschickt wird.  In anderen Fällen
	soll vielleicht der Verbindungsaufbau protokolliert
	oder eine E-Mail an einen Administrator versandt
	werden. Oder ein Dienst soll nur für das
	lokale Netz bereitstehen.  Dies alles ist mit so genannten
	Wildcards, Metazeichen und der Ausführung externer
	Programme möglich.</para>

      <sect3>
	<title>Externe Kommandos</title>

	<para>Stellen Sie sich vor, eine Verbindung soll
	  verhindert werden und gleichzeitig soll demjenigen,
	  der die Verbindung aufgebaut hat, eine Nachricht
	  geschickt werden.  Solch eine Aktion ist mit
	  <option>twist</option> möglich.  <option>twist</option>
	  führt beim Verbindungsaufbau ein Kommando oder ein Skript
	  aus.  Ein Beispiel ist in <filename>hosts.allow</filename>
	  enthalten:</para>

	<programlisting># Alle anderen Dienste sind geschützt
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

	<para>Für jeden Dienst, der nicht vorher in
	  <filename>hosts.allow</filename> konfiguriert wurde, wird
	  die Meldung <quote>You are not allowed to use
	    <literal>daemon</literal> from
	    <literal>hostname</literal>.</quote> zurückgegeben.
	  Dies ist nützlich, wenn die Gegenstelle sofort
	  benachrichtigt werden soll, nachdem die Verbindung getrennt
	  wurde.  Der Text der Meldung <emphasis>muss</emphasis> in
	  Anführungszeichen (<literal>"</literal>) stehen.</para>

	<warning>
	  <para>Ein so konfigurierter Server ist anfällig
	    für Denial-of-Service-Angriffe.  Ein Angreifer
	    kann die gesperrten Dienste mit Verbindungsanfragen
	    überfluten.</para>
	</warning>

	<para>Eine weitere Möglichkeit bietet <option>spawn</option>.
	  Wie <option>twist</option> verbietet <option>spawn</option>
	  die Verbindung und führt externe Kommandos aus.  Allerdings
	  sendet <option>spawn</option> der Gegenstelle keine
	  Rückmeldung.  Sehen Sie sich die nachstehende
	  Konfigurationsdatei an:</para>

	<programlisting># Verbindungen von example.com sind gesperrt:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</programlisting>

	<para>Damit sind Verbindungen von der Domain
	  <systemitem class="fqdomainname">*.example.com</systemitem> gesperrt.
	  Jeder Verbindungsaufbau wird zudem in
	  <filename>/var/log/connections.log</filename>
	  protokolliert.  Das Protokoll enthält den
	  Rechnernamen, die <acronym>IP</acronym>-Adresse
	  und den Dienst, der angesprochen wurde.</para>

	<para>In diesem Beispiel wurden die Metazeichen
	  <literal>%a</literal> und <literal>%h</literal> verwendet.
	  Eine vollständige Liste der Metazeichen finden Sie in
	  &man.hosts.access.5;.</para>
      </sect3>

      <sect3>
	<title>Wildcards</title>

	<para>Die Wildcard <literal>ALL</literal> passt auf jeden
	  Dienst, jede Domain oder jede <acronym>IP</acronym>-Adresse.
	  Eine andere Wildcard ist <literal>PARANOID</literal>.  Sie
	  passt auf jeden Rechner, dessen
	  <acronym>IP</acronym>-Adresse möglicherweise gefälscht ist.
	  Dies ist beispielsweise der Fall, wenn der Verbindungsaufbau
	  von einer <acronym>IP</acronym>-Adresse erfolgt, die nicht
	  zu dem übermittelten Rechnernamen passt.  In diesem Beispiel
	  werden alle Verbindungsanfragen zu &man.sendmail.8;
	  abgelehnt, wenn die <acronym>IP</acronym>-Adresse nicht zum
	  Rechnernamen passt:</para>

	<programlisting># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</programlisting>

	<caution>
	  <para>Die Wildcard <literal>PARANOID</literal>
	    kann einen Dienst unbrauchbar machen, wenn der
	    Client oder der Server eine fehlerhafte
	    <acronym>DNS</acronym>-Konfiguration besitzt.
	    Seien Sie daher besonders vorsichtig, wenn Sie diese Wildcard
	    in Ihre Konfiguration aufnehmen wollen.</para>
	</caution>

	<para>Weitere Informationen über Wildcards und deren Funktion
	  finden Sie in &man.hosts.access.5;.</para>

	<para>Damit die gezeigten Beispiele funktionieren, muss die
	  erste Konfigurationszeile in
	  <filename>hosts.allow</filename> auskommentiert
	  werden.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="kerberos5">
    <info><title><application>Kerberos5</application></title>
      <authorgroup>
	<author><personname><firstname>Tillman</firstname><surname>Hodgson</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Mark</firstname><surname>Murray</surname></personname><contrib>Beruht auf einem Beitrag von </contrib></author>
      </authorgroup>
    </info>

    

    <para><application>Kerberos</application> ist ein Netzwerk-Protokoll,
      das Benutzer mithilfe eines sicheren Servers authentifiziert.
      Die Daten einer Kommunikation können verschlüsselt werden,
      nachdem die Kommunikationspartner mit
      <application>Kerberos</application> ihre Identität geprüft
      haben.</para>

    <para><application>Kerberos</application> hat nur eine Aufgabe:
      Die sichere Prüfung der Identität eines Benutzers
      (Authentifizierung) über das Netzwerk.  Das System
      überprüft weder die Berechtigungen der Benutzer
      (Autorisierung), noch verfolgt es die durchgeführten
      Aktionen (Audit).  Daher sollte
      <application>Kerberos</application> zusammen mit anderen
      Sicherheits-Systemen eingesetzt werden, die diese Funktionen
      bereitstellen.</para>

    <para>Die folgenden Anweisungen beschreiben, wie Sie das mit
      &os; gelieferte <application>Kerberos</application> einrichten.
      Eine vollständige Beschreibung des Systems entnehmen Sie den
      entsprechenden Hilfeseiten.</para>

    <para>Die Beschreibung der
      <application>Kerberos</application>-Installation benutzt
      folgende Namensräume:</para>

    <itemizedlist>
      <listitem>
	<para>Die <acronym>DNS</acronym>-Domain (<quote>Zone</quote>)
	  heißt <systemitem
	    class="fqdomainname">example.org</systemitem>.</para>
      </listitem>

      <listitem>
	<para>Das <application>Kerberos</application>-Realm
	  heißt <literal>EXAMPLE.ORG</literal>.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Benutzen Sie echte Domain-Namen, wenn Sie
	<application>Kerberos</application> einrichten.  Damit
	vermeiden Sie <acronym>DNS</acronym>-Probleme und stellen
	die Zusammenarbeit mit anderen
	<application>Kerberos</application>-Realms sicher.</para>
    </note>

    <sect2>
      <title>Geschichte</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Geschichte</secondary>
      </indexterm>

      <para>Das <acronym>MIT</acronym> hat
	<application>Kerberos</application> entwickelt, um
	Sicherheitsprobleme auf dem Netzwerk zu lösen.  Das
	<application>Kerberos</application>-Protokoll verwendet
	starke Kryptographie, sodass ein Server die Identität
	eines Clients (der umgekehrte Vorgang ist auch möglich)
	über ein unsicheres Netzwerk feststellen kann.</para>

      <para>Der Begriff Kerberos wird sowohl für das Protokoll
	als auch für Programme verwendet, die
	<application>Kerberos</application> benutzen, wie
	<application>Kerberos</application>-Telnet.  Die aktuelle
	Protokollversion ist 5 und wird in
	<acronym>RFC</acronym>&nbsp;1510 beschrieben.</para>

      <para>Mehrere Implementierungen des Protokolls stehen frei
	zur Verfügung und decken viele Betriebssysteme ab.
	Das Massachusetts Institute of Technology
	(<acronym>MIT</acronym>), an dem <application>Kerberos</application>
	ursprünglich entwickelt wurde, entwickelt seine
	<application>Kerberos</application>-Version weiter.  In den
	<acronym>USA</acronym> wird diese Version häufig
	eingesetzt, unterlag aber Export-Beschränkungen,
	da sie in den <acronym>USA</acronym> entwickelt wurde.
	Die <acronym>MIT</acronym>-Version von
	<application>Kerberos</application> ist als Port oder Paket
	<package>security/krb5</package> verfügbar.
	Heimdal ist eine weitere Implementierung der Protokollversion 5.
	Sie wurde außerhalb der <acronym>USA</acronym> entwickelt
	und unterliegt daher keinen Export-Beschränkungen.
	Heimdal-<application>Kerberos</application> befindet sich
	im Port oder Paket <package>security/heimdal</package>
	und das Basissystem von &os; enthält eine minimale
	Installation von Heimdal.</para>

      <para>Die folgenden Beispiele verwenden die in &os; enthaltene
	Heimdal-Distribution.</para>
    </sect2>

    <sect2>
      <title>Das Heimdal <acronym>KDC</acronym> einrichten</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Key Distribution Center</secondary>
      </indexterm>

      <para><application>Kerberos</application> authentifiziert
	Benutzer an einer zentralen Stelle: dem Key Distribution
	Center (<acronym>KDC</acronym>).  Das <acronym>KDC</acronym>
	verteilt <firstterm>Tickets</firstterm>, mit denen ein
	Dienst die Identität eines Benutzers feststellen kann.
	Alle Mitglieder eines <application>Kerberos</application>-Realms
	vertrauen dem <acronym>KDC</acronym>, daher gelten für
	das <acronym>KDC</acronym> erhöhte
	Sicherheitsanforderungen.</para>

      <para>Obwohl der <application>Kerberos</application>-Server
	wenig Ressourcen benötigt, sollte das <acronym>KDC</acronym>
	wegen der Sicherheitsanforderungen auf einem separaten Rechner
	installiert werden.</para>

      <para>Das <acronym>KDC</acronym> wird in
        <filename>/etc/rc.conf</filename> wie folgt aktiviert:</para>

      <programlisting>kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

      <para>Danach wird <filename>/etc/krb5.conf</filename>
	wie folgt bearbeitet:</para>

      <programlisting>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
	admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</programlisting>

      <para>Diese Einstellungen setzen voraus, dass der voll
	qualifizierte Name des <acronym>KDC</acronym>s
	<systemitem
	  class="fqdomainname">kerberos.example.org</systemitem> ist.
	Wenn das <acronym>KDC</acronym> einen anderen Namen hat,
	muss in der <acronym>DNS</acronym>-Zone ein Alias-Eintrag
	(CNAME-Record) für das <acronym>KDC</acronym> hinzugefügt
	werden.</para>

      <note>
	<para>In großen Netzwerken mit einem ordentlich
	  konfigurierten <acronym>DNS</acronym>-Server kann die Datei
	  aus dem obigen Beispiel verkürzt werden:</para>

        <programlisting>[libdefaults]
      default_realm = EXAMPLE.ORG</programlisting>

	<para>Die Zonendatei von <systemitem class="fqdomainname">example.org</systemitem>
	  muss dann die folgenden Zeilen enthalten:</para>

	<programlisting>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</programlisting>
      </note>

      <note>
	<para>Damit die Clients die
	  <application>Kerberos</application>-Dienste benutzen
	  können, muss <filename>/etc/krb5.conf</filename>
	  entweder die vollständige Konfiguration enthalten
	  oder eine minimale Konfiguration enthalten
	  <emphasis>und</emphasis> zusätzlich ein
	  <acronym>DNS</acronym>-Server richtig eingerichtet
	  sein.</para>
      </note>

      <para>Im nächsten Schritt wird die
        <application>Kerberos</application>-Datenbank eingerichtet.
	Die Datenbank enthält die Schlüssel aller Prinzipale
	und ist mit einem Passwort geschützt.  Dieses Passwort
	brauchen Sie sich nicht merken, da ein davon abgeleiteter
	Schlüssel in <filename>/var/heimdal/m-key</filename>
	gespeichert wird.  Um den Schlüssel zu erstellen, rufen Sie
	&man.kstash.8; auf und geben Sie ein Passwort ein.</para>

      <para>Nachdem der Schlüssel erstellt wurde, sollte die
	Datenbank initialisiert werden.  Das
	<application>Kerberos</application>-Werkzeug &man.kadmin.8;
	kann mit <command>kadmin -l</command> im lokalen Modus benutzt
	werden, ohne den Netzwerkdienst, welcher zu diesem Zeitpunkt
	noch nicht läuft, zu verwenden.  An der Eingabeaufforderung
	von &man.kadmin.8; kann mit <command>init</command>
	die Datenbank des Realms initialisiert werden.</para>

      <para>Zuletzt wird mit <command>add</command> das erste
	Prinzipal erstellt.  Benutzen Sie die voreingestellten
	Optionen.  Die Einstellungen können später
	<command>modify</command> verändert werden.  An der
	Eingabeaufforderung von &man.kadmin.8; zeigt
	<command>?</command> Hilfetexte an.</para>

      <para>Zusammengefasst wird die Datenbank wie folgt
	eingerichtet:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
Master key: <userinput>xxxxxxxx</userinput>
Verifying password - Master key: <userinput>xxxxxxxx</userinput>

&prompt.root; <userinput>kadmin -l</userinput>
kadmin&gt; <userinput>init EXAMPLE.ORG</userinput>
Realm max ticket life [unlimited]:
kadmin&gt; <userinput>add tillman</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: <userinput>xxxxxxxx</userinput>
Verifying password - Password: <userinput>xxxxxxxx</userinput></screen>

      <para>Jetzt kann das <acronym>KDC</acronym> gestartet werden.
	Führen Sie zum Start der Dienste
	<command>service kerberos start</command> und
	<command>service kadmind start</command> aus.  Obwohl
	zu diesem Zeitpunkt noch keine kerberisierten Dienste
	laufen, kann die Funktion des <acronym>KDC</acronym>s
	schon überprüft werden.  Für den eben angelegten
	Benutzer können Sie sich vom <acronym>KDC</acronym>
	Tickets holen und anzeigen lassen:</para>

      <screen>&prompt.user; <userinput>kinit tillman</userinput>
tillman@EXAMPLE.ORG's Password:

&prompt.user; <userinput>klist</userinput>
Credentials cache: FILE: <filename>/tmp/krb5cc_500</filename>
        Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</screen>

      <para>Nachdem der Test abgeschlossen ist, kann das temporäre
	Ticket zurückgezogen werden:</para>

      <screen>&prompt.user; <userinput>kdestroy</userinput></screen>
    </sect2>

    <sect2>
      <title>Heimdal <application>Kerberos</application>-Dienste
	einrichten</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Dienste einrichten</secondary>
      </indexterm>

      <para>Bei der Konfiguration eines Servers für die
	<application>Kerberos</application>-Authentifizierung muss
	zuerst sichergestellt werden, dass
	<filename>/etc/krb5.conf</filename> richtig konfiguriert ist.
	Die Datei kann entweder vom <acronym>KDC</acronym> kopiert,
	oder auf dem neuen System regeneriert werden.</para>

      <para>Als nächstes muss auf dem Server die
	<filename>/etc/krb5.keytab</filename> erzeugt werden.  Dies
	ist der Hauptbestandteil um Dienste zu
	<quote>kerberisieren</quote> und entspricht der Erzeugung
	eines geheimen Schlüssels zwischen dem Dienst und dem
	<application>KDC</application>.  Das Geheimnis ist ein
	kryptographischer Schlüssel, der in einem
	<filename>keytab</filename>> abgelegt wird.  Diese Datei
	enthält den Schlüssel des Servers, mit dem sich der Server und
	das <acronym>KDC</acronym> gegenseitig authentifizieren
	können.  Sie muss in einer sicheren Art und Weise an den
	Server übertragen werden, da ansonsten die Sicherheit des
	Servers gefährdet ist, wenn z.B. die Schlüssel öffentlich
	werden.  In der Regel wird die <filename>keytab</filename> auf
	einem vertrauenswürdigen Rechner mit <command>kadmin</command>
	erzeugt und anschließend sicher auf den Server übertragen,
	beispielsweise mit &man.scp.1;.  Wenn die
	Sicherheitsrichtlinien es erlauben, kann die Datei auch direkt
	auf dem Server erzeugt werden.  Es ist sehr wichtig, dass die
	<filename>keytab</filename> auf sichere Weise auf den Server
	übertragen wird.  Wenn der Schlüssel einer anderen Partei
	bekannt wird, kann sich diese Partei den Benutzern als
	Server ausgeben!  Da der Eintrag für das Host-Prinzipal für
	die <acronym>KDC</acronym>-Datenbank auch mit
	<command>kadmin</command> erstellt wird, ist es praktisch,
	<command>kadmin</command> direkt auf dem Server zu
	benutzen.</para>

      <para>Natürlich ist auch <command>kadmin</command> ein
	kerberisierter Dienst: ein
	<application>Kerberos</application>-Ticket ist erforderlich,
	um sich gegenüber dem Netzwerkdienst zu authentifizieren und
	um sicherzustellen, dass der Benutzer, der
	<command>kadmin</command> ausführt, tatsächlich vorhanden ist.
	<command>kadmin</command> wird nach dem Passwort fragen, um
	ein neues Ticket zu generieren.  Das Prinzipal, das sich mit
	dem kadmin-Dienst authentifiziert, muss über die
	Zugriffskontrollliste <filename>kadmin.acl</filename> dazu
	berechtigt sein.  Weitere Informationen über
	Zugriffskontrolllisten finden Sie in den Heimdal-Info-Seiten
	(<command>info heimdal</command>) im Abschnitt
	<quote>Remote administration</quote>.  Wenn der Zugriff auf
	<command>kadmin</command> von entfernten Rechnern verboten
	ist, kann sich der Administrator entweder über die lokale
	Konsole oder über &man.ssh.1; mit dem <acronym>KDC</acronym>
	verbinden, um die lokale Administration mit
	<command>kadmin -l</command> durchzuführen.</para>

      <para>Nach der Installation von
	<filename>/etc/krb5.conf</filename>, können Sie das Kommando
	<command>add --random-key</command> in
	<command>kadmin</command> ausführen, um das Host-Prinzipal in
	die Datenbank zu schreiben.  Das Kommando
	<command>ext</command> extrahiert den Schlüssel des Prinzipals
	in eine eigene keytab:</para>

      <screen>&prompt.root; <userinput>kadmin</userinput>
kadmin&gt; <userinput>add --random-key host/myserver.example.org</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin&gt; <userinput>ext host/myserver.example.org</userinput>
kadmin&gt; <userinput>exit</userinput></screen>

      <para>Beachten Sie, dass <command>ext</command> den
	extrahierten Schlüssel standardmäßig in
	<filename>/etc/krb5.keytab</filename> speichert.  Das ist
	gut, wenn das Kommando auf dem kerberisierten Server
	ausgeführt wird, ansonsten sollte das Argument
	<command>--keytab
	  <replaceable>pfad/zur/datei</replaceable></command>
	benutzt werden, wenn die keytab an einen anderen Ort
	extrahiert wird:</para>

      <screen>&prompt.root; <userinput>kadmin</userinput>
kadmin&gt; <userinput>ext --keytab=/tmp/example.keytab <replaceable>host/myserver.example.org</replaceable></userinput>
kadmin&gt; <userinput>exit</userinput></screen>

      <para>Anschließend kann die erzeugte keytab sicher mit
	<command>scp</command> auf Server oder auf einen
	Wechseldatenträger kopiert werden.  Geben Sie auf jeden Fall
	einen anderen Namen für die keytab an, weil sonst die keytab
	des <acronym>KDC</acronym>s überschrieben würde.</para>

      <para>Wegen der Datei <filename>krb5.conf</filename> kann
	der Server nun mit dem <acronym>KDC</acronym> kommunizieren
	und seine Identität mithilfe der Datei
	<filename>krb5.keytab</filename> nachweisen.  Jetzt
	können die kerberisierten Dienste aktiviert werden.  Einer der
	gebräuchlichsten Dienste ist &man.sshd.8;, der
	<application>Kerberos</application> über
	<acronym>GSS-API</acronym> unterstützt.  Fügen Sie folgende
	Zeile in <filename>/etc/ssh/sshd_config</filename> ein:</para>

      <programlisting>GSSAPIAuthentication yes</programlisting>

      <para>Nach dieser Änderung muss &man.sshd.8; mit
	<command>service sshd restart</command> neu gestartet werden,
	damit die neue Konfiguration wirksam wird.</para>
    </sect2>

    <sect2>
      <title>Heimdal <application>Kerberos</application>-Clients
	einrichten</title>

      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Clients einrichten</secondary>
      </indexterm>

      <para>Genau wie der Server, benötigt auch der Client eine
	Konfiguration in <filename>/etc/krb5.conf</filename>.
	Kopien Sie die Datei (sicher) vom <acronym>KDC</acronym>
	auf den Client, oder schreiben Sie die Datei bei Bedarf
	einfach neu.  Testen Sie den Client, indem Sie mit
	<command>kinit</command> Tickets anfordern, mit
	<command>klist</command> Tickets anzeigen und mit
	<command>kdestroy</command> Tickets löschen.
	<application>Kerberos</application>-Anwendungen sollten auch
	kerberisierte Server ansprechen können.  Wenn das nicht
	funktioniert, Sie aber Tickets anfordern können, hat
	wahrscheinlich der kerberisierte Server ein Problem und nicht
	der Client oder das <acronym>KDC</acronym>.  Im Falle eines
	kerberisierten &man.ssh.1; ist <acronym>GSS-API</acronym> in
	der Voreinstellung deaktiviert.  Testen Sie daher mit
	<command>ssh -o GSSAPIAuthentication=yes
	  <replaceable>hostname</replaceable></command>.</para>

      <para>Wenn Sie die kerberisierten Anwendungen testen, können Sie
	einen Paket-Sniffer wie <command>tcpdump</command> benutzen,
	um sicherzustellen, dass keine sensiblen Informationen im
	Klartext übertragen werden.</para>

      <para>Es stehen verschiedene
	<application>Kerberos</application>-Anwendungen zur Verfügung.
	Die Anwendungen, die <acronym>SASL</acronym> benutzen, können
	dann auch <acronym>GSS-API</acronym> benutzen.  Viele Arten
	von Anwendungen können <application>Kerberos</application> zur
	Authentifizierung verwenden, vom Jabber-Client bis zum
	<acronym>IMAP</acronym>-Client.</para>

      <indexterm>
	<primary><filename>.k5login</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>.k5users</filename></primary>
      </indexterm>

      <para>Normalerweise wird ein
	<application>Kerberos</application>-Prinzipal auf ein lokales
	Benutzerkonto abgebildet.  Manchmal wird aber Zugriff auf ein
	lokales Benutzerkonto benötigt, zu dem es keinen passenden
	<application>Kerberos</application>-Prinzipal gibt.
	Der Prinzipal <systemitem
	  class="username">tillman@EXAMPLE.ORG</systemitem> bräuchte
	beispielsweise Zugriff auf das Konto <systemitem
	  class="username">webdevelopers</systemitem>.  Ebenso könnten
	andere Prinzipale auf dieses Konto zugreifen wollen.</para>

      <para>Die Dateien <filename>.k5login</filename> und
	<filename>.k5users</filename> im Heimatverzeichnis eines
	Benutzers können verwendet werden, um dieses Problem zu lösen.
	Mit der folgenden <filename>.k5login</filename> im
	Heimatverzeichnis des Benutzers <systemitem
	  class="username">webdevelopers</systemitem> haben beide
	Prinzipale auch ohne das gemeinsame Passwort Zugriff auf das
	Konto:</para>
	
      <programlisting>tillmann@example.org
jdoe@example.org</programlisting>

      <para>Weitere Informationen zu <filename>.k5users</filename>
	finden Sie in &man.ksu.1;.</para>
    </sect2>

    <sect2>
      <title>Tipps und Fehlersuche</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Fehlersuche</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>Wenn Sie den Heimdal-Port oder den
	    <acronym>MIT</acronym>-Port benutzen, muss in der
	    Umgebungsvariable <envar>PATH</envar> der Pfad zu
	    den <application>Kerberos</application>-Programmen vor dem
	    Pfad zu den Programmen des Systems stehen.</para>
	</listitem>

	<listitem>
	  <para>Wenn die Clients im Realm ihre Uhrzeit nicht
	    synchronisieren, schlägt vielleicht die Authentifizierung
	    fehl.  <xref linkend="network-ntp"/> beschreibt, wie
	    Sie mithilfe von <acronym>NTP</acronym> die Uhrzeiten
	    synchronisieren.</para>
	</listitem>

	<listitem>
	  <para>Die <acronym>MIT</acronym>- und Heimdal-Systeme
	    arbeiten bis auf <command>kadmin</command>, welches nicht
	    standardisiert ist, gut zusammen.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie den Namen eines Rechners ändern,
	    müssen Sie auch den <systemitem
	      class="username">host/</systemitem>-Prinzipal ändern und
	    die <filename>keytab</filename> aktualisieren.  Dies
	    betrifft auch spezielle Einträge wie den Prinzipal für
	    Apaches <package>www/mod_auth_kerb</package>.</para>
	</listitem>

	<listitem>
	  <para>Alle Rechner in einem Realm müssen vor- und
	    rückwärts aufgelöst werden können.  Entweder über
	    <acronym>DNS</acronym>, zumindest aber über
	    <filename>/etc/hosts</filename>.
	    <acronym>CNAME</acronym>-Einträge im
	    <acronym>DNS</acronym> funktionieren, aber die
	    entsprechenden A- und PTR-Einträge müssen
	    vorhanden und richtig sein.  Wenn sich Namen nicht
	    auflösen lassen, ist die Fehlermeldung nicht
	    gerade selbstsprechend: <errorname>Kerberos5 refuses
	      authentication because Read req
	      failed: Key table entry not found</errorname>.</para>
	</listitem>

	<listitem>
	  <para>Einige Betriebssysteme installieren
	    <command>ksu</command> mit falschen Zugriffsrechten;
	    es fehlt das Set-UID-Bit für <systemitem
	      class="username">root</systemitem>.  Das hat zur Folge,
	    dass <command>ksu</command> nicht funktioniert.  Dies ist
	    ein Fehler in den Zugriffsrechten und kein Fehler des
	    <acronym>KDC</acronym>s.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie für einen Prinzipal unter
	    <acronym>MIT</acronym>-<application>Kerberos</application>
	    Tickets mit einer längeren Gültigkeit als
	    der vorgegebenen zehn Stunden einrichten wollen,
	    müssen Sie zwei Sachen ändern.  Benutzen
	    Sie das <command>modify_principal</command> von
	    <command>kadmin</command>, um die maximale
	    Gültigkeitsdauer für den Prinzipal selbst
	    und den Prinzipal <systemitem
	      class="username">krbtgt</systemitem>
	    zu erhöhen.  Das Prinzipal kann dann mit
	    <command>kinit -l</command> ein Ticket mit einer
	    längeren Gültigkeit beantragen.</para>
	</listitem>

	<listitem>
	  <para>Mit einem Packet-Sniffer können Sie feststellen,
	    dass Sie sofort nach dem Aufruf von <command>kinit</command>
	    eine Antwort vom <acronym>KDC</acronym>
	    bekommen &ndash; noch bevor Sie überhaupt ein
	    Passwort eingegeben haben!  Das ist in Ordnung:
	    Das <acronym>KDC</acronym> händigt
	    ein Ticket-Granting-Ticket (<acronym>TGT</acronym>)
	    auf Anfrage aus, da es durch einen vom Passwort
	    des Benutzers abgeleiteten Schlüssel
	    geschützt ist.  Wenn das Passwort
	    eingegeben wird, wird es nicht zum <acronym>KDC</acronym>
	    gesendet, sondern zum Entschlüsseln der
	    Antwort des <acronym>KDC</acronym>s benutzt, die
	    <command>kinit</command> schon erhalten hat.
	    Wird die Antwort erfolgreich entschlüsselt,
	    erhält der Benutzer einen Sitzungs-Schlüssel
	    für die künftige verschlüsselte
	    Kommunikation mit dem <acronym>KDC</acronym> und das
	    <acronym>TGT</acronym>.  Das <acronym>TGT</acronym>
	    wiederum ist mit dem Schlüssel des <acronym>KDC</acronym>s
	    verschlüsselt.  Diese Verschlüsselung ist
	    für den Benutzer völlig transparent und
	    erlaubt dem <acronym>KDC</acronym>,
	    die Echtheit jedes einzelnen <acronym>TGT</acronym>
	    zu prüfen.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie <application>OpenSSH</application> verwenden
	    und Tickets mir einer langen Gültigkeit
	    (beispielsweise einer Woche) benutzen, setzen Sie
	    <option>TicketCleanup</option> in
	    <filename>sshd_config</filename> auf <literal>no</literal>.
	    Ansonsten werden die Tickets gelöscht, wenn Sie
	    sich abmelden.</para>
	</listitem>

	<listitem>
	  <para>Host-Prinzipale können Tickets mit
	    längerer Gültigkeit besitzen.  Wenn der
	    Prinzipal eines Benutzers über ein Ticket verfügt,
	    das eine Woche gültig ist, das Ticket des
	    Host-Prinzipals aber nur neun Stunden gültig ist,
	    funktioniert der Ticket-Cache nicht wie erwartet.
	    Im Cache befindet sich dann ein abgelaufenes Ticket
	    des Host-Prinzipals.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie mit <filename>krb5.dict</filename> die
	    Verwendung schlechter Passwörter verhindern wollen, wie
	    in &man.kadmin.8; beschrieben, geht das nur mit
	    Prinzipalen, denen eine Passwort-Policy zugewiesen wurde.
	    Das Format von <filename>krb5.dict</filename> enthält pro
	    Zeile ein Wort.   Sie können daher einen symbolischen Link
	    auf <filename>/usr/share/dict/words</filename>
	    erstellen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Unterschiede zum <acronym>MIT</acronym>-Port</title>

      <para>Der Hauptunterschied zwischen
	<acronym>MIT</acronym>-<application>Kerberos</application>
	und Heimdal-<application>Kerberos</application>
	ist das Kommando <command>kadmin</command>.
	Die Befehlssätze des Kommandos (obwohl funktional
	gleichwertig) und das verwendete
	Protokoll unterscheiden sich in beiden Varianten.
	Das <acronym>KDC</acronym> lässt sich nur mit
	dem <command>kadmin</command> Kommando der passenden
	<application>Kerberos</application>-Variante verwalten.</para>

      <para>Für dieselbe Funktion können auch die
	Client-Anwendungen leicht geänderte Kommandozeilenoptionen
	besitzen.  Folgen Sie bitte der Anleitung auf der
	<application>Kerberos</application>-Seite
	<uri xlink:href="http://web.mit.edu/Kerberos/www/">http://web.mit.edu/Kerberos/www/</uri>
	des <acronym>MIT</acronym>s.  Achten Sie besonders auf den
	Suchpfad für Anwendungen.  Der <acronym>MIT</acronym>-Port
	wird standardmäßig in
	<filename>/usr/local/</filename>
	installiert.  Wenn die Umgebungsvariable <envar>PATH</envar>
	zuerst die Systemverzeichnisse enthält, werden die
	Systemprogramme anstelle der <acronym>MIT</acronym>-Programme
	ausgeführt.</para>

      <note>
	<para>Wenn Sie den <acronym>MIT</acronym>-Port
	  <package>security/krb5</package> verwenden,
	  erscheint bei der Anmeldung mit <command>telnetd</command>
	  und <command>klogind</command> die Fehlermeldung
	  <errorname>incorrect permissions on cache file</errorname>.
	  Lesen Sie dazu die im Port enthaltene Datei
	  <filename>/usr/local/share/doc/krb5/README.FreeBSD</filename>.
	  Wichtig ist, dass zur Authentifizierung die Binärdatei
	  <command>login.krb5</command> verwendet wird, die
	  für durchgereichte Berechtigungen die Eigentümer
	  korrekt ändert.</para>
      </note>

      <para>Wird
	<acronym>MIT</acronym>-<application>Kerberos</application> auf
	&os; eingesetzt, sollten in <filename>rc.conf</filename>
	folgende Zeilen aufgenommen werden:</para>

      <programlisting>kerberos5_server="/usr/local/sbin/krb5kdc"
kadmind5_server="/usr/local/sbin/kadmind"
kerberos5_server_flags=""
kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

      <para>Diese Zeilen sind notwendig, weil die Anwendungen
	von <acronym>MIT</acronym>-<acronym>Kerberos</acronym> die
	Binärdateien unterhalb von <filename>/usr/local</filename>
	installieren.</para>
    </sect2>

    <sect2>
      <title>Beschränkungen von
	<application>Kerberos</application></title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Beschränkungen</secondary>
      </indexterm>

      <sect3>
	<title><application>Kerberos</application> muss ganzheitlich
	  verwendet werden</title>

	<para>Jeder über das Netzwerk angebotene Dienst
	  muss mit <application>Kerberos</application>
	  zusammenarbeiten oder auf anderen Wegen gegen Angriffe
	  aus dem Netzwerk geschützt sein.  Andernfalls
	  können Berechtigungen gestohlen und wiederverwendet
	  werden.  Es ist beispielsweise nicht sinnvoll, für
	  Remote-Shells<application>Kerberos</application>
	  zu benutzen, dagegen aber <acronym>POP3</acronym>-Zugriff
	  auf einen Mail-Server zu erlauben, da
	  <acronym>POP3</acronym>-Passwörter im Klartext
	  versendet.</para>
      </sect3>

      <sect3>
	<title><application>Kerberos</application> ist für
	  Einbenutzer-Systeme gedacht</title>

	<para>In Mehrbenutzer-Umgebungen ist
	  <application>Kerberos</application> unsicherer als in
	  Einbenutzer-Umgebungen, da die Tickets im für alle
	  lesbaren Verzeichnis <filename>/tmp</filename>
	  gespeichert werden.  Wenn ein Rechner von mehreren
	  Benutzern verwendet wird, ist es möglich, dass
	  Tickets von einem anderen Benutzer gestohlen oder
	  kopiert werden.</para>

	<para>Dieses Problem können Sie lösen, indem Sie mit
	  der Kommandozeilenoption <option>-c</option> oder besser
	  mit der Umgebungsvariablen <envar>KRB5CCNAME</envar> einen
	  Ort für die Tickets vorgeben.  Es reicht, die Tickets
	  im Heimatverzeichnis eines Benutzers zu speichern und
	  mit Zugriffsrechten zu schützen.</para>
      </sect3>

      <sect3>
	<title>Das <acronym>KDC</acronym> ist verwundbar</title>

	<para>Das <acronym>KDC</acronym> muss genauso abgesichert
	  werden wie die auf ihm befindliche Passwort-Datenbank.
	  Auf dem <acronym>KDC</acronym> sollten absolut keine anderen
	  Dienste laufen und der Rechner sollte physikalisch
	  gesichert sein.  Die Gefahr ist groß, da
	  <application>Kerberos</application> alle Passwörter
	  mit einem Schlüssel, dem Haupt-Schlüssel,
	  verschlüsselt.  Der Haupt-Schlüssel wiederum
	  wird in einer Datei auf dem <acronym>KDC</acronym>
	  gespeichert.</para>

	<para>Ein kompromittierter Haupt-Schlüssel ist nicht
	  ganz so schlimm wie allgemein angenommen.  Der
	  Haupt-Schlüssel wird nur zum Verschlüsseln
	  der Passwort-Datenbank und zum Initialisieren des
	  Zufallsgenerators verwendet.  Solange der Zugriff
	  auf das <acronym>KDC</acronym> abgesichert ist, kann
	  ein Angreifer wenig mit dem Haupt-Schlüssel
	  anfangen.</para>

	<para>Wenn das <acronym>KDC</acronym> nicht zur Verfügung
	  steht, sind auch die Netzwerkdienste nicht benutzbar, da
	  eine Authentifizierung nicht durchgeführt werden kann.
	  Das <acronym>KDC</acronym> ist also ein optimales Ziel für
	  einen Denial-of-Service Angriff.  Sie können diesem Angriff
	  entgegenwirken, indem Sie einen
	  <acronym>KDC</acronym>-Master und einen oder mehrere Slaves
	  verwenden.  Der Rückfall auf ein sekundäres
	  <acronym>KDC</acronym> mittels
	  <acronym>PAM</acronym>-Authentifizierung muss sorgfältig
	  eingerichtet werden.</para>
      </sect3>

      <sect3>
	<title>Mängel von
	  <application>Kerberos</application></title>

	<para>Mit <application>Kerberos</application> können
	  sich Benutzer, Rechner und Dienste gegenseitig
	  authentifizieren.  Allerdings existiert kein Mechanismus,
	  der das <acronym>KDC</acronym> gegenüber Benutzern,
	  Rechnern oder Diensten authentifiziert.  Ein verändertes
	  &man.kinit.1; könnte beispielsweise alle
	  Benutzernamen und Passwörter abfangen.  Die von
	  veränderten Programmen ausgehende Gefahr können
	  Sie lindern, indem Sie die Integrität von Dateien
	  mit Werkzeugen wie
	  <package>security/tripwire</package>
	  prüfen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Weiterführende Dokumentation</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>weiterführende Dokumentation</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para><link xlink:href="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">The
            Kerberos FAQ</link></para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://web.mit.edu/Kerberos/www/dialogue.html">Designing
	    an Authentication System: a Dialogue in Four
	    Scenes</link></para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510,
	    The <application>Kerberos</application> Network
	    Authentication Service (V5)</link></para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://web.mit.edu/Kerberos/www/"><acronym>MIT</acronym>
	    <application>Kerberos</application>-Seite</link></para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://www.pdc.kth.se/heimdal/">Heimdal
	    <application>Kerberos</application>-Seite</link></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="openssl">
    <info><title>OpenSSL</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>
    <indexterm><primary>OpenSSL</primary></indexterm>

    <para><application>OpenSSL</application> ist eine freie
      Implementierung der <acronym>SSL</acronym> und
      <acronym>TLS</acronym>-Protokolle.  Es bietet eine
      verschlüsselte Transportschicht oberhalb der
      normalen Kommunikationsschicht und kann daher zusammen
      mit vielen Netzdiensten benutzt werden.</para>

    <para>Anwendungsbeispiele für <application>OpenSSL</application>
      sind die verschlüsselte Authentifizierung von
      E-Mail-Clients oder Web-Transaktionen wie das Bezahlen mit
      einer Kreditkarte.  <application>OpenSSL</application>
      kann während des Baus in viele Ports, wie
      <package>www/apache22</package> und
      <package>mail/claws-mail</package>,
      integriert werden.</para>

    <note>
      <para>Ist beim Aufruf von <command>make</command> die
	Variable <varname>WITH_OPENSSL_BASE</varname> nicht
	explizit auf <literal>yes</literal> gesetzt, baut
	die Ports-Sammlung meist den Port
	<package>security/openssl</package>.</para>
    </note>

    <para>Das in &os; integrierte <application>OpenSSL</application>
      stellt die Protokolle Secure Sockets Layer v2/v3 (SSLv2/SSLv3)
      und Transport Layer Security v1 (TLSv1) zur Verfügung.
      Die <application>OpenSSL</application>-Bibliotheken stellen
      kryptographische Funktionen bereit.</para>

    <note>
      <para>Mit <application>OpenSSL</application> kann der
	<acronym>IDEA</acronym>-Algorithmus verwendet werden,
	wegen Patenten in den USA ist der Algorithmus in der
	Voreinstellung allerdings deaktiviert.  Wenn Sie die
	<acronym>IDEA</acronym>-Lizenz akzeptieren, können
	Sie den <acronym>IDEA</acronym>-Algorithmus aktivieren,
	indem Sie die Variable <varname>MAKE_IDEA</varname>
	in <filename>/etc/make.conf</filename> setzen.</para>
    </note>

    <para>Meist wird <application>OpenSSL</application> eingesetzt,
      um Zertifikate für Anwendungen bereitzustellen.  Die
      Zertifikate stellen die Identität einer Firma oder
      eines Einzelnen sicher.  Wenn ein Zertifikat nicht von
      einer Zertifizierungsstelle (<foreignphrase>Certificate
        Authority</foreignphrase>, <acronym>CA</acronym>)
      gegengezeichnet wurde, erhalten Sie normalerweise eine
      Warnung.  Eine Zertifizierungsstelle ist eine Firma
      wie <link xlink:href="http://www.verisign.com/">VeriSign</link>,
      die Zertifikate von Personen oder Firmen
      gegenzeichnet und damit die Korrektheit der Zertifikate
      bestätigt.  Diese Prozedur kostet Geld, ist aber
      keine Voraussetzung für den Einsatz von Zertifikaten,
      beruhigt aber sicherheitsbewusste Benutzer.</para>

    <sect2>
      <title>Zertifikate erzeugen</title>

      <indexterm>
	<primary>OpenSSL</primary>
	<secondary>Zertifikate erzeugen</secondary>
      </indexterm>

      <para>Ein Zertifikat erzeugen Sie mit dem nachstehenden
	Kommando:</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.pem</userinput>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (eg, YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:<userinput><replaceable>Another Name</replaceable></userinput></screen>

      <para>Beachten Sie, dass die Eingabe bei
	<quote>Common Name</quote> ein gültiger Domain-Name
	sein muss.  Eine andere Eingabe erzeugt ein unbrauchbares
	Zertifikat.  Das Zertifikat kann mit einer
	Gültigkeitsdauer und anderen
	Verschlüsselungsalgorithmen erzeugt werden.
	&man.openssl.1; beschreibt die zur
	Verfügung stehenden Optionen.</para>

      <para>Das Verzeichnis, in dem Sie den letzten Befehl ausgeführt
	haben, enthält nun zwei Dateien:  Die Anforderung für
	ein neues Zertifikat wurde in <filename>req.pem</filename>
	gespeichert.  Diese Datei können Sie an eine
	<acronym>CA</acronym> senden, wo die Angaben geprüft werden.
	Nach erfolgreicher Prüfung wird das Zertifikat unterschrieben
	und an Sie zurückgesandt.  Die zweite Datei, <filename>cert.pem</filename>,
	enthält den privaten Schlüssel für das Zertifikat
	und darf auch keine Fall in fremde Hände geraten, da ein
	Angreifer sonst in der Lage ist, anderen Personen oder Rechnern
	vorzugaukeln, dass es sich bei ihm um Sie handelt.</para>

      <para>Wenn Sie keine Signatur einer Zertifizierungsstelle
	benötigen, können Sie ein selbst-signiertes
	Zertifikat erstellen.  Erzeugen Sie dazu zuerst einen
	<acronym>RSA</acronym>-Schlüssel:</para>

      <screen>&prompt.root; <userinput>openssl dsaparam -rand -genkey -out myRSA.key 1024</userinput></screen>

      <para>Erzeugen Sie dann den <acronym>CA</acronym>-Schlüssel:</para>

      <screen>&prompt.root; <userinput>openssl gendsa -des3 -out myca.key myRSA.key</userinput></screen>

      <para>Erstellen Sie mit diesem Schlüssel das
        Zertifikat:</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key myca.key -out new.crt</userinput></screen>

      <para>Zwei neue Dateien befinden sich nun im Verzeichnis:
	Der Schlüssel der Zertifizierungsstelle
	<filename>myca.key</filename> und das Zertifikat selbst,
	<filename>new.crt</filename>.  Sie sollten in einem
	Verzeichnis, vorzugsweise unterhalb von
	<filename>/etc/ssl</filename> abgelegt
	werden, das nur von <systemitem class="username">root</systemitem> lesbar
	ist.  Die Zugriffsrechte der Dateien können mit &man.chmod.1;
	auf <literal>0700</literal> gesetzt werden.</para>
    </sect2>

    <sect2>
      <title>Zertifikate benutzen</title>

      <para>Mit einem Zertifikat können beispielsweise die
	Verbindungen zu <application>Sendmail</application>
	verschlüsselt werden, um eine Klartext-Authentifizierung
	zu verhindern.</para>

      <note>
	<para>Einige E-Mail-Programme geben Warnungen aus, wenn ein
	  Zertifikat nicht lokal installiert ist.  Weitere
	  Informationen zur Installation von Zertifikaten finden Sie
	  in der Dokumentation der entsprechenden Software.</para>
      </note>

      <para>Ergänzen Sie die Konfigurationsdatei von
	<application>Sendmail</application> (<filename>.mc</filename>)
	um die nachstehenden Zeilen:</para>

      <programlisting>dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl</programlisting>

      <para>Im Verzeichnis <filename>/etc/certs</filename> befindet
	sich der Schlüssel und das Zertifikat.  Bauen Sie danach im
	Verzeichnis <filename>/etc/mail</filename>
	mit dem Kommando <command>make install</command> die
	<filename>.cf</filename>-Datei.  Starten Sie anschließend
	<application>Sendmail</application> mit
	<command>make restart</command> neu.</para>

      <para>Wenn alles gut ging, erscheinen keine Fehlermeldungen
	in <filename>/var/log/maillog</filename> und
	Sie sehen <application>Sendmail</application> in der
	Prozessliste.</para>

      <para>Testen Sie nun den Mailserver mit &man.telnet.1;:</para>

      <screen>&prompt.root; <userinput>telnet example.com 25</userinput>
Trying 192.0.34.166...
Connected to <systemitem class="fqdomainname">example.com</systemitem>.
Escape character is '^]'.
220 <systemitem class="fqdomainname">example.com</systemitem> ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
<userinput>ehlo example.com</userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 <systemitem class="fqdomainname">example.com</systemitem> closing connection
Connection closed by foreign host.</screen>

      <para>Wenn die Zeile <literal>STARTTLS</literal>
	erscheint, hat alles funktioniert.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="ipsec">
    <info><title><acronym>VPN</acronym> mit IPsec</title>
      <authorgroup>
        <author><personname><firstname>Nik</firstname><surname>Clayton</surname></personname><affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
          </affiliation><contrib>Geschrieben von </contrib></author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>IPsec</primary>
    </indexterm>

    <sect2>
      <info><title>IPsec Grundlagen</title>
        <authorgroup>
          <author><personname><firstname>Hiten M.</firstname><surname>Pandya</surname></personname><affiliation>
	      <address><email>hmp@FreeBSD.org</email></address>
	    </affiliation><contrib>Geschrieben von </contrib></author>
	</authorgroup>
      </info>

      <para>Dieser Abschnitt beschreibt die Einrichtung von IPsec.  Um
	IPsec einzurichten, sollten Sie einen neuen Kernel bauen können (siehe
	<xref linkend="kernelconfig"/>).</para>

      <para><emphasis>IPsec</emphasis> ist ein Protokoll, das auf dem
	Internet-Protokoll (<acronym>IP</acronym>) aufbaut.  Mit IPsec
	können mehrere Systeme geschützt miteinander kommunizieren.  Das in
	&os; realisierte IPsec-Protokoll baut auf der <link xlink:href="http://www.kame.net/">KAME-Implementierung</link>
	auf und unterstützt sowohl IPv4 als auch IPv6.</para>

      <indexterm>
	<primary>IPsec</primary>
	<secondary>ESP</secondary>
      </indexterm>

      <indexterm>
	<primary>IPsec</primary>
	<secondary>AH</secondary>
      </indexterm>

      <para>IPsec besteht wiederum aus zwei Protokollen:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Encapsulated Security Payload
	      (<acronym>ESP</acronym>)</emphasis> verschlüsselt
	    IP-Pakete mit einem symmetrischen Verfahren wie Blowfish
	    oder 3DES.  Damit werden die Pakete vor Manipulationen
	    Dritter geschützt.</para>
        </listitem>

        <listitem>
          <para>Der <emphasis>Authentication Header
	      (<acronym>AH</acronym>)</emphasis> enthält eine
	    kryptographische Prüfsumme, die sicher stellt, dass ein
	    IP-Paket nicht verändert wurde.  Der Authentication-Header
	    folgt nach dem normalen IP-Header und erlaubt dem Empfänger
	    eines IP-Paketes, dessen Integrität zu
	    prüfen.</para>
        </listitem>
      </itemizedlist>

      <para><acronym>ESP</acronym> und <acronym>AH</acronym>
	können, je nach Situation, zusammen oder einzeln
	verwendet werden.</para>

      <indexterm>
        <primary>VPN</primary>
      </indexterm>

      <indexterm>
        <primary>Virtual Private Network</primary>
        <see>VPN</see>
      </indexterm>

      <para>IPsec kann in zwei Modi betrieben werden:  Der
	<firstterm>Transport-Modus</firstterm> verschlüsselt
	die Daten zwischen zwei Systemen.  Der
	<firstterm>Tunnel-Modus</firstterm> verbindet zwei
	Subnetze miteinander.  Durch einen Tunnel können
	dann beispielsweise verschlüsselte Daten übertragen
	werden.  Ein Tunnel wird auch als
	<foreignphrase>Virtual-Private-Network</foreignphrase>
	(<acronym>VPN</acronym>) bezeichnet.  Detaillierte
	Informationen über das IPsec-Subsystem von &os; finden Sie in
	&man.ipsec.4;.</para>

      <para>Die folgenden Optionen in der Kernelkonfiguration
	aktivieren IPsec:</para>

      <indexterm>
        <primary>Kerneloption</primary>
        <secondary>IPSEC</secondary>
      </indexterm>

      <screen>options   IPSEC        #IP security
device    crypto</screen>

      <indexterm>
        <primary>Kerneloption</primary>
        <secondary>IPSEC_DEBUG</secondary>
      </indexterm>

      <para>Wenn Sie zur Fehlersuche im IPsec-Subsystem
	Unterstützung wünschen, sollten Sie die
	folgende Option ebenfalls aktivieren:</para>

      <screen>options   IPSEC_DEBUG  #debug for IP security</screen>
    </sect2>

    <sect2>
      <title>VPN zwischen einem Heim- und Firmennetzwerk
	einrichten</title>

      <indexterm>
        <primary>VPN</primary>
        <secondary>einrichten</secondary>
      </indexterm>

      <para>Es gibt keinen Standard, der festlegt, was ein
	Virtual-Private-Network ist.  VPNs können mit
	verschiedenen Techniken, die jeweils eigene Vor- und
	Nachteile besitzen, implementiert werden.
	Dieser Abschnitt stellt Möglichkeiten vor, um ein VPN
	für das folgende Szenario aufzubauen:</para>

      <itemizedlist>
        <listitem>
	  <para>Es müssen mindestens zwei Netzwerke vorhanden sein,
	    welche intern IP benutzen.</para>
        </listitem>

        <listitem>
	  <para>Beide Netzwerke sind über ein &os;-Gateway
	    mit dem Internet verbunden.</para>
        </listitem>

        <listitem>
	  <para>Der Gateway jedes Netzwerks besitzt mindestens
	    eine öffentliche IP-Adresse.</para>
        </listitem>

        <listitem>
          <para>Die intern verwendeten IP-Adressen können
	    private oder öffentliche Adressen sein.
	    Sie dürfen sich jedoch nicht überlappen.  Zum Beispiel
	    sollten nicht beide Netze <systemitem
	      class="ipaddress">192.168.1.x</systemitem>
	    benutzen.</para>
        </listitem>
      </itemizedlist>

    <sect3>
      <info><title>Konfiguration von IPsec in &os;</title>
        <authorgroup>
          <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><affiliation>
              <address><email>trhodes@FreeBSD.org</email></address>
            </affiliation><contrib>Geschrieben von </contrib></author>
        </authorgroup>
      </info>


      <para>Als erstes muss <package>security/ipsec-tools</package>
	aus der Ports-Sammlung installiert werden.  Diese Software
	enthält einige Anwendungen, die bei der Konfiguration von
	IPsec hilfreich sind.</para>

      <para>Als nächstes müssen zwei &man.gif.4;-Pseudogeräte
        angelegt werden, um die Pakete zu tunneln und dafür zu sorgen,
        dass beide Netzwerke richtig miteinander kommunizieren können.
        Geben Sie als <systemitem class="username">root</systemitem>
	die folgenden Befehle ein, wobei Sie
	<replaceable>intern</replaceable> und
	<replaceable>extern</replaceable> durch die realen internen
	und externen <acronym>IP</acronym>-Adressen der Gateways
	ersetzen müssen:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput></screen>
      <screen>&prompt.root; <userinput>ifconfig gif0 <replaceable>intern1 intern2</replaceable></userinput></screen>
      <screen>&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>extern1 extern2</replaceable></userinput></screen>

      <para>In diesem Beispiel ist die externe
	<acronym>IP</acronym>-Adresse des Firmennetzwerkes
	(<acronym>LAN</acronym>) <systemitem
	  class="ipaddress">172.16.5.4</systemitem> und die interne
        <acronym>IP</acronym>-Adresse ist <systemitem
	  class="ipaddress">10.246.38.1</systemitem>.  Das
	Heimnetzwerk (<acronym>LAN</acronym>) hat die externe
	<acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">192.168.1.12</systemitem> mit der internen
        privaten <acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">10.0.0.5</systemitem>.</para>

      <para>Wenn dies verwirrend erscheint, schauen Sie sich die
	folgende Ausgabe von &man.ifconfig.8;an:</para>

      <programlisting>Gateway 1:

gif0: flags=8051 mtu 1280
tunnel inet 172.16.5.4 --&gt; 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
inet 10.246.38.1 --&gt; 10.0.0.5 netmask 0xffffff00

Gateway 2:

gif0: flags=8051 mtu 1280
tunnel inet 192.168.1.12 --&gt; 172.16.5.4
inet 10.0.0.5 --&gt; 10.246.38.1 netmask 0xffffff00
inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4</programlisting>

      <para>Wenn Sie fertig sind, sollten beide internen Adressen über
	&man.ping.8; erreichbar sein:</para>

      <programlisting>priv-net# ping 10.0.0.5
PING 10.0.0.5 (10.0.0.5): 56 data bytes
64 bytes from 10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms
64 bytes from 10.0.0.5: icmp_seq=1 ttl=64 time=19.255 ms
64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms
--- 10.0.0.5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms

corp-net# ping 10.246.38.1
PING 10.246.38.1 (10.246.38.1): 56 data bytes
64 bytes from 10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms
64 bytes from 10.246.38.1: icmp_seq=1 ttl=64 time=42.917 ms
64 bytes from 10.246.38.1: icmp_seq=2 ttl=64 time=127.525 ms
64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms
64 bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms
--- 10.246.38.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms</programlisting>

      <para>Wie erwartet, können nun beiden Seiten
        <acronym>ICMP</acronym>-Pakete von ihren privaten Adressen
	senden und empfangen.  Als nächstes müssen beide
	Gateways so konfiguriert werden, dass sie die Pakete des anderen
	Netzwerkes richtig routen.  Mit dem folgenden Befehl
	erreicht man das Ziel:</para>

      <screen>&prompt.root; <userinput>corp-net# route add 10.0.0.0 10.0.0.5 255.255.255.0</userinput></screen>
      <screen>&prompt.root; <userinput>corp-net# route add net 10.0.0.0: gateway 10.0.0.5</userinput></screen>

      <screen>&prompt.root; <userinput>priv-net# route add 10.246.38.0 10.246.38.1 255.255.255.0</userinput></screen>
      <screen>&prompt.root; <userinput>priv-net# route add host 10.246.38.0: gateway 10.246.38.1</userinput></screen>

      <para>Ab jetzt sollten die Rechner von den Gateways sowie von
	den Rechnern hinter den Gateways erreichbar sein.  Dies können
	Sie wieder mit &man.ping.8; überprüfen:</para>

      <programlisting>corp-net# ping 10.0.0.8
PING 10.0.0.8 (10.0.0.8): 56 data bytes
64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
--- 10.0.0.8 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

priv-net# ping 10.246.38.107
PING 10.246.38.1 (10.246.38.107): 56 data bytes
64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
--- 10.246.38.107 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms</programlisting>

      <para>Das Konfigurieren der Tunnel ist der einfache Teil.  Die
	Konfiguration einer sicheren Verbindung geht viel mehr in
	die Tiefe.  Die folgende Konfiguration benutzt pre-shared
	(<acronym>PSK</acronym>) <acronym>RSA</acronym>-Schlüssel.
	Abgesehen von den <acronym>IP</acronym>-Adressen, sind beide
	<filename>/usr/local/etc/racoon/racoon.conf</filename>
	identisch und sehen ähnlich aus:</para>

      <programlisting>path    pre_shared_key  "/usr/local/etc/racoon/psk.txt"; #location of pre-shared key file
log     debug;  #log verbosity setting: set to 'notify' when testing and debugging is complete

padding # options are not to be changed
{
        maximum_length  20;
        randomize       off;
        strict_check    off;
        exclusive_tail  off;
}

timer   # timing options. change as needed
{
        counter         5;
        interval        20 sec;
        persend         1;
#       natt_keepalive  15 sec;
        phase1          30 sec;
        phase2          15 sec;
}

listen  # address [port] that racoon will listen on
{
        isakmp          172.16.5.4 [500];
        isakmp_natt     172.16.5.4 [4500];
}

remote  192.168.1.12 [500]
{
        exchange_mode   main,aggressive;
        doi             ipsec_doi;
        situation       identity_only;
        my_identifier   address 172.16.5.4;
        peers_identifier        address 192.168.1.12;
        lifetime        time 8 hour;
        passive         off;
        proposal_check  obey;
#       nat_traversal   off;
        generate_policy off;

                        proposal {
                                encryption_algorithm    blowfish;
                                hash_algorithm          md5;
                                authentication_method   pre_shared_key;
                                lifetime time           30 sec;
                                dh_group                1;
                        }
}

sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)    # address $network/$netmask $type address $network/$netmask $type ( $type being any or esp)
{                                                               # $network must be the two internal networks you are joining.
        pfs_group       1;
        lifetime        time    36000 sec;
        encryption_algorithm    blowfish,3des,des;
        authentication_algorithm        hmac_md5,hmac_sha1;
        compression_algorithm   deflate;
}</programlisting>

      <para>Eine Beschreibung der verfügbaren Optionen finden Sie in
	der Manualpage von <filename>racoon.conf</filename>.</para>

      <para>Die
	<foreignphrase>Security Policy Database</foreignphrase>
	(<acronym>SPD</acronym>) muss noch konfiguriert werden, so
	dass &os; und <application>racoon</application> in der
	Lage sind den Netzwerkverkehr zwischen den Hosts zu ver-
	und entschlüsseln.</para>

      <para>Dies wird durch ein Shellskript ähnlich wie das
	folgende, das auf dem Firmennetzwerk-Gateway liegt,
	ausgeführt.  Diese Datei wird während der
	Systeminitialisierung ausgeführt und sollte unter
	<filename>/usr/local/etc/racoon/setkey.conf</filename>
	gespeichert werden.</para>

<programlisting>flush;
spdflush;

# To the home network
spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
spdadd 10.0.0.0/24 10.246.38.0/24 any -P in ipsec esp/tunnel/192.168.1.12-172.16.5.4/use;</programlisting>

      <para>Einmal abgespeichert, kann <application>racoon</application>
	durch das folgende Kommando auf beiden Gateways gestartet
	werden:</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log</userinput></screen>

      <para>Die Ausgabe sollte so ähnlich aussehen:</para>

      <programlisting>corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
Foreground mode.
2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=28496098(0x1b2d0e2)
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=47784998(0x2d92426)
2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=124397467(0x76a279b)
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=175852902(0xa7b4d66)</programlisting>

      <para>Um sicherzustellen, dass der Tunnel richtig funktioniert,
	wechseln Sie auf eine andere Konsole und benutzen Sie
	&man.tcpdump.1; mit dem folgenden Befehl, um sich den
	Netzwerkverkehr anzusehen.  Tauschen Sie
	<literal>em0</literal> durch die richtige Netzwerkkarte
	aus:</para>

      <screen>&prompt.root; <userinput>tcpdump -i em0 host <replaceable>172.16.5.4 and dst 192.168.1.12</replaceable></userinput></screen>

      <para>Die Ausgabe der Konsole sollte dem hier ähneln.  Wenn
	nicht, gibt es ein Problem und ein Debuggen der ausgegebenen
	Daten ist notwendig.</para>

      <programlisting>01:47:32.021683 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
01:47:33.022442 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
01:47:34.024218 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)</programlisting>

      <para>An diesem Punkt sollten beide Netzwerke verfügbar sein und
	den Anschein haben, dass sie zum selben Netzwerk gehören.
	Meistens sind beide Netzwerke durch eine Firewall geschützt.
	Um den Netzwerkverkehr zwischen den beiden Netzwerken zu erlauben,
	ist es notwendig Regeln zu erstellen.  Für die &man.ipfw.8;
	Firewall fügen Sie folgende Zeilen in die
	Firewall-Konfigurationsdatei ein:</para>

      <programlisting>ipfw add 00201 allow log esp from any to any
ipfw add 00202 allow log ah from any to any
ipfw add 00203 allow log ipencap from any to any
ipfw add 00204 allow log udp from any 500 to any</programlisting>

      <note>
        <para>Die Regelnummern müssen eventuell, je nach ihrer
          Hostkonfiguration, angepasst werden.</para>
      </note>

      <para>Für Benutzer der &man.pf.4;- oder &man.ipf.8;-Firewall
	sollte folgendes funktionieren:</para>

      <programlisting>pass in quick proto esp from any to any
pass in quick proto ah from any to any
pass in quick proto ipencap from any to any
pass in quick proto udp from any port = 500 to any port = 500
pass in quick on gif0 from any to any
pass out quick proto esp from any to any
pass out quick proto ah from any to any
pass out quick proto ipencap from any to any
pass out quick proto udp from any port = 500 to any port = 500
pass out quick on gif0 from any to any</programlisting>

      <para>Zum Ende, um dem Computer den Start vom
	<acronym>VPN</acronym> während der Systeminitialisierung
	zu erlauben, fügen Sie folgende Zeilen in ihre
	<filename>/etc/rc.conf</filename>: ein</para>

      <programlisting>ipsec_enable="YES"
ipsec_program="/usr/local/sbin/setkey"
ipsec_file="/usr/local/etc/racoon/setkey.conf" # allows setting up spd policies on boot
racoon_enable="yes"</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="openssh">
    <info><title>OpenSSH</title>
      <authorgroup>
	<author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>Beigetragen von </contrib></author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </info>

    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> stellt Werkzeuge bereit,
      um sicher auf entfernte Maschinen zuzugreifen.  Zusätzlich
      können TCP/IP-Verbindungen sicher durch <acronym>SSH</acronym>
      weitergeleitet (getunnelt) werden.  Mit <acronym>SSH</acronym>
      werden alle Verbindungen verschlüsselt, dadurch wird verhindert,
      dass die Verbindung zum Beispiel abgehört oder übernommen
      (<foreignphrase>Hijacking</foreignphrase>) werden kann.</para>

    <para><application>OpenSSH</application> wird vom OpenBSD-Projekt
      gepflegt und wird in der Voreinstellung von &os; installiert.
      <application>OpenSSH</application> ist mit den
      <acronym>SSH</acronym>-Protokollen der Versionen 1 und 2
      kompatibel.</para>

    <sect2>
      <title>Vorteile von <application>OpenSSH</application></title>

      <para>Wenn Daten unverschlüsselt über das Netzwerk gesendet
	werden,  besteht die Gefahr, das Benutzer/Passwort
	Kombinationen oder alle Daten an beliebiger Stelle zwischen
	dem Client und dem Server abgehört werden.  Mit
	<application>OpenSSH</application> stehen eine Reihe von
	Authentifizierungs- und Verschlüsselungsmethoden zur
	Verfügung, um das zu verhindern.</para>
    </sect2>

    <sect2>
      <title>Den SSH-Server aktivieren</title>

      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>aktivieren</secondary>
      </indexterm>

      <para>Um zu überprüfen, ob &man.sshd.8; auf dem System aktiviert
	ist, suchen Sie in <filename>rc.conf</filename> nach der
	folgenden Zeile:</para>

      <programlisting>sshd_enable="YES"</programlisting>

      <para>Ist diese Zeile vorhanden, wird &man.sshd.8;, der
	<application>OpenSSH</application>-Daemon, beim
	Systemstart automatisch aktiviert.  Alternativ kann
	<application>OpenSSH</application> auch über &man.service.8;
	gestartet werden:</para>

      <screen>&prompt.root; <userinput>service sshd start</userinput></screen>
    </sect2>

    <sect2>
      <title>SSH Client</title>

      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Client</secondary>
      </indexterm>

      <para>Benutzen Sie &man.ssh.1; um sich mit einem System zu
	verbinden, auf dem &man.sshd.8; läuft.  Verwenden Sie dazu
	den Benutzernamen und den Namen des Rechners, mit dem Sie
	sich verbinden möchten:</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para><acronym>SSH</acronym> speichert einen Fingerabdruck des
	Serverschlüssels.  Die Aufforderung, <literal>yes</literal>
	einzugeben, erscheint nur bei der ersten Verbindung zu einem
	Server.  Weitere Verbindungen zu dem Server werden gegen den
	gespeicherten Fingerabdruck des Schlüssels geprüft und
	der Client gibt eine Warnung aus, wenn sich der empfangene
	Fingerabdruck von dem gespeicherten unterscheidet.  Die
	Fingerabdrücke werden in
	<filename>~/.ssh/known_hosts</filename> gespeichert.</para>

      <para>In der Voreinstellung akzeptieren aktuelle Versionen von
	&man.sshd.8; nur <acronym>SSH</acronym>&nbsp;v2 Verbindungen.
	Wenn möglich, wird der Client versuchen Version&nbsp;2 zu
	verwenden, ist dies nicht möglich, fällt er auf Version&nbsp;1
	zurück.  Der Client kann gezwungen werden, nur eine der beiden
	Versionen zu verwenden, indem die Option <option>-1</option>
	oder <option>-2</option> übergeben wird.  Die Unterstützung
	für Version&nbsp;1 ist nur noch aus Kompatibilitätsgründen zu
	älteren Versionen enthalten.</para>
    </sect2>

    <sect2>
      <title>Secure Copy</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>secure copy</secondary>
      </indexterm>
      <indexterm><primary>&man.scp.1;</primary></indexterm>

      <para>Mit &man.scp.1; lassen sich Dateien in einer sicheren
	Weise auf entfernte Maschinen übertragen.</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@example.com's password:
COPYRIGHT            100% |*****************************|  4735
00:00
&prompt.root;</screen>

      <para>Da der Fingerabdruck schon im vorigen Beispiel abgespeichert
        wurde, wird er bei der Verwendung von <command>scp</command> in
	diesem Beispiel überprüft.  Da die Fingerabdrücke
	übereinstimmen, wird keine Warnung ausgegeben.</para>

      <para>Die Argumente, die &man.scp.1; übergeben werden, gleichen
	denen von &man.cp.1; in der Beziehung, dass die ersten
	Argumente die zu kopierenden Dateien sind und das letzte
	Argument den Bestimmungsort angibt.  Da die Dateien über das
	Netzwerk kopiert werden, können ein oder mehrere Argumente die
	Form <option>user@host:&lt;path_to_remote_file&gt;</option>
	besitzen.</para>
    </sect2>

    <sect2>
      <title>Konfiguration</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Konfiguration</secondary>
      </indexterm>

      <para>Die für das ganze System gültigen Konfigurationsdateien
	des <application>OpenSSH</application>-Daemons und des
	Clients befinden sich in <filename>/etc/ssh</filename>.</para>

      <para>Die Client-Konfiguration befindet sich in
        <filename>ssh_config</filename>, die des Servers befindet sich
	in <filename>sshd_config</filename>.  Für beide Dateien
	existieren Manualpages, welche die einzelnen
	Konfigurationsoptionen beschreiben.</para>
    </sect2>

    <sect2 xml:id="security-ssh-keygen">
      <title>&man.ssh-keygen.1;</title>

      <para>Mit &man.ssh-keygen.1; können <acronym>DSA</acronym>- oder
	<acronym>RSA</acronym>-Schlüssel für einen Benutzer erzeugt
	werden, die anstelle von Passwörtern verwendet werden
	können:</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t <replaceable>dsa</replaceable></userinput>
Generating public/private dsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_dsa):
Created directory '/home/user/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_dsa.
Your public key has been saved in /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com</screen>

      <para>&man.ssh-keygen.1; erzeugt einen öffentlichen und einen
        privaten Schlüssel für die Authentifizierung.  Der private
        Schlüssel wird in <filename>~/.ssh/id_dsa</filename> oder
        <filename>~/.ssh/id_rsa</filename> gespeichert, während
        sich der öffentliche Schlüssel in
        <filename>~/.ssh/id_dsa.pub</filename> oder
        <filename>~/.ssh/id_rsa.pub</filename> befindet, je nachdem,
        ob es sich um einen <acronym>DSA</acronym>- oder einen
        <acronym>RSA</acronym>-Schlüssel handelt.
        Der öffentliche Schlüssel muss sowohl für
	<acronym>RSA</acronym>- als auch für
	<acronym>DSA</acronym>-Schlüssel in
        <filename>~/.ssh/authorized_keys</filename> auf dem entfernten
        Rechner aufgenommen werden, damit der Schlüssel
        funktioniert.</para>

      <para>Damit werden Verbindungen zu der entfernten Maschine über
	<acronym>SSH</acronym>-Schlüsseln anstelle von Passwörtern
	authentifiziert.</para>

      <warning>
	<para>Viele Benutzer denken, dass die Verwendung von
	  Schlüsseln generell sicher ist.  Sie verwenden dann einen
	  Schlüssel ohne eine Passphrase.  Dies ist jedoch sehr
	  <emphasis>gefährlich</emphasis>.  Ein Administrator kann
	  überprüfen, ob ein Schlüsselpaar mit einer Passphrase
	  geschützt ist.  Wenn die Datei mit dem privaten Schlüssel
	  den Text <literal>ENCRYPTED</literal> enthält, dann hat
	  der Benutzer eine Passphrase verwendet.  Um die Benutzer
	  zusätzlich zu schützen, kann ein
	  <literal>from</literal>-Feld in der Datei des öffentlichen
	  Schlüssels hinzugefügt werden.  Zum Beispiel würde das
	  Hinzufügen von <literal>from="192.168.10.5"</literal> vor
	  dem <literal>ssh-rsa</literal>- oder
	  <literal>ssh-dsa</literal>-Präfix dafür sorgen, dass sich
	  ein bestimmter Benutzer nur noch von dieser
	  <acronym>IP</acronym>-Adresse anmelden darf.</para>
      </warning>

      <para>Wenn bei der Erstellung der Schlüssel mit
	&man.ssh-keygen.1; eine Passphrase angegeben wurde, wird der
	Benutzer bei jeder Anmeldung zur Eingabe des Passworts
	aufgefordert.  Um den Umgang mit
	<acronym>SSH</acronym>-Schlüsseln zu erleichtern, kann
	&man.ssh-agent.1; die Verwaltung dieser Schlüssel für Sie
	übernehmen.  Lesen Sie dazu den <xref
	  linkend="security-ssh-agent"/>.</para>

      <warning>
	<para>Die Optionen und Dateinamen sind
	  abhängig von der <application>OpenSSH</application>-Version.
	  Die für das System gültigen Optionen finden Sie in
	  &man.ssh-keygen.1;.</para>
      </warning>
    </sect2>

    <sect2 xml:id="security-ssh-agent">
      <title>Verwendung von SSH-Agent</title>

      <para>Mit &man.ssh-agent.1; und &man.ssh-add.1; ist es
        möglich, <application>SSH</application>-Schlüssel
        in den Speicher zu laden, damit die Passphrase nicht jedes Mal
        eingegeben werden muss.</para>

      <para>&man.ssh-agent.1; übernimmt die Authentifizierung
        von ihm geladener privater Schlüssel.
        &man.ssh-agent.1; sollte nur dazu verwendet werden, ein
        anderes Programm zu starten, beispielsweise eine Shell oder
        einen Window-Manager.</para>

      <para>Um &man.ssh-agent.1; in einer Shell zu verwenden, muss
	es mit einer Shell als Argument aufgerufen werden.  Zudem muss
	die zu verwaltende Identität mit &man.ssh-add.1; sowie deren
	Passphrase für den privaten Schlüssel übergeben werden.
	Nachdem dies erledigt ist, kann sich ein Benutzer über
	&man.ssh.1; auf jedem Rechner anmelden, der einen
	entsprechenden öffentlichen Schlüssel besitzt.  Dazu ein
        Beispiel:</para>

      <screen>&prompt.user; ssh-agent <replaceable>csh</replaceable>
&prompt.user; ssh-add
Enter passphrase for /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)
&prompt.user;</screen>

      <para>Um &man.ssh-agent.1; unter
	<application>&xorg;</application> zu verwenden, muss
	&man.ssh-agent.1; in <filename>~/.xinitrc</filename>
	aufgenommen werden.  Dadurch können alle unter
	<application>&xorg;</application> gestarteten Programme die
	Dienste von &man.ssh-agent.1; nutzen.
	<filename>~/.xinitrc</filename> könnte etwa so
	aussehen:</para>

      <programlisting>exec ssh-agent <replaceable>startxfce4</replaceable></programlisting>

      <para>Dadurch wird bei jedem Start von
	<application>&xorg;</application> zuerst &man.ssh-agent.1;
	aufgerufen, das wiederum <application>XFCE</application>
	startet.  Nachdem diese Änderung durchgeführt wurde, muss
	<application>&xorg;</application> neu gestartet werden.
	Danach können Sie mit &man.ssh-add.1; die
	<acronym>SSH</acronym>-Schlüssel laden.</para>
    </sect2>

    <sect2 xml:id="security-ssh-tunneling">
      <title><acronym>SSH</acronym>-Tunnel</title>

      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Tunnel</secondary>
      </indexterm>

      <para>Mit <application>OpenSSH</application> ist es möglich,
	einen Tunnel zu erstellen, in dem ein anderes Protokoll
	verschlüsselt übertragen wird.</para>

      <para>Das folgende Kommando erzeugt einen Tunnel für
        &man.telnet.1;:</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

      <para>Dieses Beispiel verwendet die folgenden Optionen:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>

	  <listitem>
	    <para>Zwingt &man.ssh.1; dazu, die Version 2 des
	      Protokolls zu verwenden, um sich mit dem Server zu
	      verbinden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>Zeigt an, dass ein Tunnel erstellt werden soll.
	      Ohne diese Option würde &man.ssh.1; eine normale Sitzung
	      öffnen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Zwingt &man.ssh.1; im Hintergrund zu laufen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Ein lokaler Tunnel wird in der Form
	      <replaceable>localport:remotehost:remoteport</replaceable>
	      angegeben.  Die Verbindung wird dabei von dem lokalen Port
	      <replaceable>localport</replaceable> auf einen entfernten
	      Rechner weitergeleitet.</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>Gibt den Anmeldenamen auf dem entfernten
	      <acronym>SSH</acronym>-Server an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

       <para>Ein <acronym>SSH</acronym>-Tunnel erzeugt einen Socket
	 auf <systemitem>localhost</systemitem> und dem angegebenen
	 Port.  Jede Verbindung, die auf dem angegebenen Socket
	 aufgemacht wird, wird dann auf den spezifizierten entfernten
	 Rechner und Port weitergeleitet.</para>

       <para>Im Beispiel wird der Port <replaceable>5023</replaceable>
	 auf die entfernte Maschine und dort auf
	 <systemitem>localhost</systemitem> Port
	 <replaceable>23</replaceable> weitergeleitet.  Da der Port
	 <replaceable>23</replaceable> für &man.telnet.1; reserviert
	 ist, erzeugt das eine sichere &man.telnet.1;-Verbindung durch
	 einen <acronym>SSH</acronym>-Tunnel.</para>

       <para>Diese Vorgehensweise kann genutzt werden, um jedes
	 unsichere <acronym>TCP</acronym>-Protokoll wie
	 <acronym>SMTP</acronym>, <acronym>POP3</acronym> und
	 <acronym>FTP</acronym> weiterzuleiten.</para>

      <example>
	<title>Mit &man.ssh.1; einen sicheren Tunnel für
	   <acronym>SMTP</acronym> erstellen</title>

	<screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>

	<para>Zusammen mit &man.ssh-keygen.1; und zusätzlichen
	  Benutzer-Accounts können leicht benutzbare SSH-Tunnel
	  aufgebaut werden.  Anstelle von Passwörtern können
	  Schlüssel benutzt werden und jeder Tunnel kann unter einem
	  eigenen Benutzer laufen.</para>
      </example>

      <sect3>
	<title>Praktische Beispiele für
	  <acronym>SSH</acronym>-Tunnel</title>

	<sect4>
	  <title>Sicherer Zugriff auf einen
	    <acronym>POP3</acronym>-Server</title>

	  <para>In diesem Beispiel gibt es einen
	    <acronym>SSH</acronym>-Server, der Verbindungen von außen
	    akzeptiert.  Im selben Netzwerk befindet sich zudem
	    noch ein Mail-Server, der <acronym>POP3</acronym> spricht.
	    Um E-Mails auf sichere Weise abzurufen, bauen Sie eine
	    <acronym>SSH</acronym>-Verbindung zu dem
	    <acronym>SSH</acronym>-Server im Netzwerk auf und tunneln
	    von dort zum Mail-Server weiter.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Wenn Sie den Tunnel eingerichtet haben, konfigurieren
	    Sie den Mail-Client so, dass er <acronym>POP3</acronym>
	    Anfragen zu <systemitem>localhost</systemitem> auf Port
	    2110 sendet.  Diese Verbindung wird dann über den
	    gesicherten Tunnel zu
	    <systemitem>mail.example.com</systemitem>
	    weitergeleitet.</para>
	</sect4>

	<sect4>
	  <title>Umgehen einer strengen Firewall</title>

	  <para>Einige Netzwerkadministratoren stellen sehr
	    drakonische Firewall-Regeln auf, die nicht nur einkommende
	    Verbindungen filtern, sondern auch ausgehende.  Es kann
	    sein, dass Sie externe Maschinen nur über die Ports 22 und
	    80 (<acronym>SSH</acronym> und Web) erreichen.</para>

	  <para>Die Lösung hier ist es, eine
	    <acronym>SSH</acronym>-Verbindung zu einer Maschine
	    außerhalb der Firewall aufzumachen und durch diese zum
	    gewünschten Dienst zu tunneln.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>In diesem Beispiel benutzt ein Ogg Vorbis Client
	    <systemitem>localhost</systemitem> und Port 8888.  Die
	    Verbindung wird dann zu
	    <systemitem>music.example.com</systemitem> Port 8000
	    weitergeleitet.  Die Firewall wurde somit erfolgreich
	    umgangen.</para>
      </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Die Option <varname>AllowUsers</varname></title>

      <para>Es ist in der Regel ein gute Idee, festzulegen, welche
        Benutzer sich von welchem Rechner aus anmelden können.
        Dies lässt sich beispielsweise über die Option
        <literal>AllowUsers</literal> festlegen.  Soll sich etwa
        nur <systemitem class="username">root</systemitem> vom Rechner
	mit der <acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">192.168.1.32</systemitem> aus einwählen
        dürfen, würden Sie folgenden Eintrag in
        <filename>/etc/ssh/sshd_config</filename> aufnehmen:</para>

      <programlisting>AllowUsers root@192.168.1.32</programlisting>

      <para>Damit sich <systemitem class="username">admin</systemitem>
	von jedem Rechner aus anmelden kann, geben Sie nur den
	Benutzernamen an:</para>

      <programlisting>AllowUsers admin</programlisting>

      <para>Sie können auch mehrere Benutzer in einer Zeile
        aufführen:</para>

      <programlisting>AllowUsers root@192.168.1.32 admin</programlisting>

      <note>
        <para>Nur Benutzer, die in dieser Liste aufgeführt ist,
          dürfen sich auf diesem Rechner anmelden.</para>
      </note>

      <para>Nachdem Sie <filename>/etc/ssh/sshd_config</filename>
        angepasst haben, muss &man.sshd.8; seine Konfigurationsdateien
        neu einlesen.  Dazu geben Sie Folgendes ein:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sshd reload</userinput></screen>
    </sect2>

    <sect2>
      <title>Weiterführende Informationen</title>

      <para><link
	xlink:href="http://www.openssh.com/">OpenSSH</link></para>

      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1;
        &man.ssh-agent.1; &man.ssh-add.1; &man.ssh.config.5; für
	Client Optionen.</para>

      <para>&man.sshd.8; &man.sftp-server.8; &man.sshd.config.5; für
	Server Optionen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="fs-acl">
    <info><title>Zugriffskontrolllisten für Dateisysteme</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>


    <indexterm>
      <primary>ACL</primary>
    </indexterm>

    <para><firstterm>Zugriffskontrolllisten</firstterm>
      (<foreignphrase>Access Control Lists</foreignphrase>,
      <acronym>ACL</acronym>) erweitern die normalen Zugriffsrechte
      von &unix; Systemen auf eine kompatible (&posix;.1e) Weise
      und bieten feiner granulierte Sicherheitsmechanismen.</para>

    <para>Der <filename>GENERIC</filename>-Kernel von &os; bietet
      <acronym>ACL</acronym>-Unterstützung für
      <acronym>UFS</acronym>-Dateisysteme.  Benutzer, die es vorziehen
      einen eigenen Kernel zu übersetzen, müssen die folgende Option
      in die Kernelkonfigurationsdatei aufnehmen:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>Das System gibt eine Warnung aus, wenn ein Dateisystem mit
      <acronym>ACL</acronym>s eingehangen werden soll und die
      Unterstützung für <acronym>ACL</acronym>s nicht im Kernel
      aktiviert ist.  Das Dateisystem muss weiterhin erweiterte
      Attribute zur Verfügung stellen, damit <acronym>ACL</acronym>s
      verwendet werden können.  <acronym>UFS2</acronym> stellt diese
      Attribute standardmäßig zur Verfügung.</para>

    <note>
      <para>Die Konfiguration erweiterter Attribute auf
	<acronym>UFS1</acronym> ist mit einem höheren Aufwand als die
	Konfiguration erweiterter Attribute auf
	<acronym>UFS2</acronym> verbunden.  Zugriffskontrolllisten
	sollten daher mit <acronym>UFS2</acronym> verwendet
	werden.</para>
    </note>

    <para>Die Angabe der Option <option>acl</option> in
      <filename>/etc/fstab</filename> aktiviert Zugriffskontrolllisten
      für ein Dateisystem.  Die bevorzugte Möglichkeit ist
      die Verwendung von Zugriffskontrolllisten mit &man.tunefs.8; (Option
      <option>-a</option>), im Superblock des Dateisystems festzuschreiben.
      Diese Möglichkeit hat mehrere Vorteile:</para>

    <itemizedlist>
      <listitem>
	<para>Nochmaliges Einhängen eines Dateisystems (Option
	  <option>-u</option> von &man.mount.8;) verändert den Status
	  der Zugriffskontrolllisten nicht.  Die Verwendung von
	  Zugriffskontrolllisten kann nur durch Abhängen und erneutes
	  Einhängen eines Dateisystems verändert werden.  Das
	  heißt auch, dass Zugriffskontrolllisten nicht
	  nachträglich auf dem Root-Dateisystem aktiviert werden
	  können.</para>
      </listitem>

      <listitem>
	<para>Die Zugriffskontrolllisten auf den Dateisystemen sind,
	  unabhängig von den Optionen in <filename>/etc/fstab</filename>
	  oder Namensänderungen der Geräte, immer aktiv.  Dies
	  verhindert auch, dass Zugriffskontrolllisten aus Versehen
	  auf Dateisystemen ohne Zugriffskontrolllisten aktiviert
	  werden und durch falsche Zugriffsrechte Sicherheitsprobleme
	  entstehen.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Es kann sein, dass sich der Status von Zugriffskontrolllisten
        später durch nochmaliges Einhängen des Dateisystems
	(Option <option>-u</option> von &man.mount.8;) ändern
	lässt.  Die momentane Variante ist aber sicherer, da der
	Status der Zugriffskontrolllisten nicht versehentlich geändert
	werden kann.  Allgemein sollten Zugriffskontrolllisten auf einem
	Dateisystem, auf dem sie einmal verwendet wurden, nicht deaktiviert
	werden, da danach die Zugriffsrechte falsch sein können.
	Werden Zugriffskontrolllisten auf einem solchen Dateisystem wieder
	aktiviert, werden die Zugriffsrechte von Dateien, die sich
	zwischenzeitlich geändert haben, überschrieben, was zu
	erneuten Problemen führt.</para>
    </note>

    <para>Die Zugriffsrechte einer Datei werden durch ein
      <literal>+</literal> (Plus) gekennzeichnet, wenn die Datei durch
      Zugriffskontrolllisten geschützt ist:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>In diesem Beispiel sind die Verzeichnisse
      <filename>directory1</filename>, <filename>directory2</filename>
      und <filename>directory3</filename> durch Zugriffskontrolllisten
      geschützt, wohingegen das Verzeichnis
      <filename>public_html</filename> nicht geschützt ist.</para>

    <sect2>
      <title>Zugriffskontrolllisten benutzen</title>

      <para>Das Werkzeug &man.getfacl.1; zeigt Zugriffskontrolllisten
	an.  Das folgende Kommando zeigt die <acronym>ACL</acronym>s
	auf der Datei <filename>test</filename>:</para>

      <screen>&prompt.user; <userinput>getfacl test</userinput>
	#file:test
	#owner:1001
	#group:1001
	user::rw-
	group::r--
	other::r--</screen>

      <para>Das Werkzeug &man.setfacl.1; ändert oder entfernt
        <acronym>ACL</acronym>s auf Dateien.  Zum Beispiel:</para>

      <screen>&prompt.user; <userinput>setfacl -k test</userinput></screen>

      <para>Die Option <option>-k</option> entfernt alle
	<acronym>ACL</acronym>s einer Datei oder eines Dateisystems.
	Besser wäre es, die Option <option>-b</option>
	zu verwenden, da sie die erforderlichen Felder
	beibehält.</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,g:web:r--,o::--- test</userinput></screen>

      <para>Mit dem vorstehenden Kommando werden die eben
	entfernten Zugriffskontrolllisten wiederhergestellt.
	Der Befehl gibt die Fehlermeldung
	<errorname>Invalid argument</errorname> aus,
	<!-- doch nicht auf <devicename>stdout</devicename> ?? -->
	wenn Sie nicht existierende Benutzer oder Gruppen
	als Parameter angeben.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="security-portaudit">
    <info><title>Sicherheitsprobleme in Software Dritter überwachen</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>portaudit</primary>
    </indexterm>

    <para>In den letzten Jahren wurden zahlreiche Verbesserungen in
      der Einschätzung und dem Umgang mit Sicherheitsproblemen
      erzielt.  Die Gefahr von Einbrüchen in ein System wird
      aber immer größer, da Softwarepakete von Dritten
      auf nahezu jedem Betriebssystem installiert und konfiguriert
      werden.</para>

    <para>Die Einschätzung der Verletzlichkeit eines Systems ist
      ein Schlüsselfaktor für dessen Sicherheit.  &os;
      veröffentlicht zwar Sicherheitshinweise
      (<foreignphrase>security advisories</foreignphrase>) für
      das Basissystem, das Projekt ist allerdings nicht dazu in der
      Lage, dies auch für die zahlreichen Softwarepakete von
      Dritten zu tun.  Dennoch gibt es einen Weg, auch diese
      Programmpakete zu überwachen.  Das in der Ports-Sammlung
      enthaltene Programm <application>portaudit</application> wurde
      gezielt dafür entwickelt.</para>

    <para>Der Port <package>ports-mgmt/portaudit</package>
      fragt dazu eine Datenbank, die vom &os; Security Team sowie
      den Ports-Entwicklern aktualisiert und gewartet wird, auf
      bekannte Sicherheitsprobleme ab.</para>

    <para>Bevor Sie <application>portaudit</application> verwenden
      können, müssen Sie es über die Ports-Sammlung
      installieren:</para>

    <screen>&prompt.root; <userinput>cd /usr/ports/security/portaudit &amp;&amp; make install clean</userinput></screen>

    <para>Während der Installation werden die
      Konfigurationsdateien für &man.periodic.8; aktualisiert, was
      es <application>portaudit</application> erlaubt, seine Ausgabe
      in den täglichen Sicherheitsbericht einzufügen.
      Stellen Sie auf jeden Fall sicher, dass diese (an das
      E-Mail-Konto von <systemitem class="username">root</systemitem> gesendeten)
      Sicherheitsberichte auch gelesen werden.  An dieser Stelle
      ist keine weitere Konfiguration nötig.</para>

    <para>Nach der Installation kann ein Administrator die unter
      <filename>/var/db/portaudit</filename> lokal
      gespeicherte Datenbank aktualisieren und sich danach durch
      folgenden Befehl über mögliche Sicherheitslücken
      der von ihm installierten Softwarepakete informieren:</para>

    <screen>&prompt.root; <userinput>portaudit -Fda</userinput></screen>

    <note>
      <para>Die Datenbank wird automatisch aktualisiert, wenn
        &man.periodic.8; ausgeführt wird.  Der eben genannte
        Befehl ist daher optional, er wird aber für das
        folgende Beispiel benötigt.</para>
    </note>

    <para>Nach erfolgter Installation der Datenbank kann ein
      Administrator über die Ports-Sammlung installierte
      Softwarepakete Dritter jederzeit überprüfen.  Dazu
      muss er lediglich folgenden Befehl eingeben:</para>

    <screen>&prompt.root; <userinput>portaudit -a</userinput></screen>

    <para>Existiert in Ihren installierten Softwarepaketen eine
      Sicherheitslücke, wird <application>portaudit</application>
      eine Ausgabe ähnlich der folgenden produzieren:</para>

    <programlisting>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</programlisting>

    <para>Wenn Sie die angegebene <acronym>URL</acronym> über einen
      Internetbrowser aufrufen, erhalten Sie weitere Informationen
      über die bestehende Sicherheitslücke, wie die betroffenen
      Versionen, die Version des &os;-Ports sowie Hinweise auf weitere
      Seiten, die ebenfalls Sicherheitshinweise zu diesem Problem
      bieten.</para>

    <para><application>Portaudit</application> ist ein mächtiges
      Werkzeug und insbesondere in Zusammenarbeit mit dem
      Port <application>Portupgrade</application> äußerst
      hilfreich.</para>
  </sect1>

  <sect1 xml:id="security-advisories">
    <info><title>&os; Sicherheitshinweise</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigesteuert von </contrib></author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>&os; Sicherheitshinweise</primary>
    </indexterm>

    <para>Wie für andere hochwertige Betriebssysteme auch
      werden für &os; Sicherheitshinweise herausgegeben.
      Die Hinweise werden gewöhnlich auf den Sicherheits-Mailinglisten
      und in den Errata veröffentlicht, nachdem das
      Sicherheitsproblem behoben ist.  Dieser Abschnitt beschreibt
      den Umgang mit den Sicherheitshinweisen.</para>

    <sect2>
      <title>Wie sieht ein Sicherheitshinweis aus?</title>

      <para>Hier ist ein Beispiel für einen &os;
	Sicherheitshinweis:</para>

      <programlisting>=============================================================================
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

=============================================================================
FreeBSD-SA-14:04.bind                                       Security Advisory
                                                          The FreeBSD Project

Topic:          BIND remote denial of service vulnerability

Category:       contrib
Module:         bind
Announced:      2014-01-14
Credits:        ISC
Affects:        FreeBSD 8.x and FreeBSD 9.x
Corrected:      2014-01-14 19:38:37 UTC (stable/9, 9.2-STABLE)
                2014-01-14 19:42:28 UTC (releng/9.2, 9.2-RELEASE-p3)
                2014-01-14 19:42:28 UTC (releng/9.1, 9.1-RELEASE-p10)
                2014-01-14 19:38:37 UTC (stable/8, 8.4-STABLE)
                2014-01-14 19:42:28 UTC (releng/8.4, 8.4-RELEASE-p7)
                2014-01-14 19:42:28 UTC (releng/8.3, 8.3-RELEASE-p14)
CVE Name:       CVE-2014-0591

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit &lt;URL:http://security.FreeBSD.org/&gt;.

I.   Background

BIND 9 is an implementation of the Domain Name System (DNS) protocols.
The named(8) daemon is an Internet Domain Name Server.

II.  Problem Description

Because of a defect in handling queries for NSEC3-signed zones, BIND can
crash with an "INSIST" failure in name.c when processing queries possessing
certain properties.  This issue only affects authoritative nameservers with
at least one NSEC3-signed zone.  Recursive-only servers are not at risk.

III. Impact

An attacker who can send a specially crafted query could cause named(8)
to crash, resulting in a denial of service.

IV.  Workaround

No workaround is available, but systems not running authoritative DNS service
with at least one NSEC3-signed zone using named(8) are not vulnerable.

V.   Solution

Perform one of the following:

1) Upgrade your vulnerable system to a supported FreeBSD stable or
release / security branch (releng) dated after the correction date.

2) To update your vulnerable system via a source code patch:

The following patches have been verified to apply to the applicable
FreeBSD release branches.

a) Download the relevant patch from the location below, and verify the
detached PGP signature using your PGP utility.

[FreeBSD 8.3, 8.4, 9.1, 9.2-RELEASE and 8.4-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch.asc
# gpg --verify bind-release.patch.asc

[FreeBSD 9.2-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch.asc
# gpg --verify bind-stable-9.patch.asc

b) Execute the following commands as root:

# cd /usr/src
# patch &lt; /path/to/patch

Recompile the operating system using buildworld and installworld as
described in &lt;URL:http://www.FreeBSD.org/handbook/makeworld.html&gt;.

Restart the applicable daemons, or reboot the system.

3) To update your vulnerable system via a binary patch:

Systems running a RELEASE version of FreeBSD on the i386 or amd64
platforms can be updated via the freebsd-update(8) utility:

# freebsd-update fetch
# freebsd-update install

VI.  Correction details

The following list contains the correction revision numbers for each
affected branch.

Branch/path                                                      Revision
- -------------------------------------------------------------------------
stable/8/                                                         r260646
releng/8.3/                                                       r260647
releng/8.4/                                                       r260647
stable/9/                                                         r260646
releng/9.1/                                                       r260647
releng/9.2/                                                       r260647
- -------------------------------------------------------------------------

To see which files were modified by a particular revision, run the
following command, replacing NNNNNN with the revision number, on a
machine with Subversion installed:

# svn diff -cNNNNNN --summarize svn://svn.freebsd.org/base

Or visit the following URL, replacing NNNNNN with the revision number:

&lt;URL:http://svnweb.freebsd.org/base?view=revision&amp;revision=NNNNNN&gt;

VII. References

&lt;URL:https://kb.isc.org/article/AA-01078&gt;

&lt;URL:http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0591&gt;

The latest revision of this advisory is available at
&lt;URL:http://security.FreeBSD.org/advisories/FreeBSD-SA-14:04.bind.asc&gt;
-----BEGIN PGP SIGNATURE-----

iQIcBAEBCgAGBQJS1ZTYAAoJEO1n7NZdz2rnOvQP/2/68/s9Cu35PmqNtSZVVxVG
ZSQP5EGWx/lramNf9566iKxOrLRMq/h3XWcC4goVd+gZFrvITJSVOWSa7ntDQ7TO
XcinfRZ/iyiJbs/Rg2wLHc/t5oVSyeouyccqODYFbOwOlk35JjOTMUG1YcX+Zasg
ax8RV+7Zt1QSBkMlOz/myBLXUjlTZ3Xg2FXVsfFQW5/g2CjuHpRSFx1bVNX6ysoG
9DT58EQcYxIS8WfkHRbbXKh9I1nSfZ7/Hky/kTafRdRMrjAgbqFgHkYTYsBZeav5
fYWKGQRJulYfeZQ90yMTvlpF42DjCC3uJYamJnwDIu8OhS1WRBI8fQfr9DRzmRua
OK3BK9hUiScDZOJB6OqeVzUTfe7MAA4/UwrDtTYQ+PqAenv1PK8DZqwXyxA9ThHb
zKO3OwuKOVHJnKvpOcr+eNwo7jbnHlis0oBksj/mrq2P9m2ueF9gzCiq5Ri5Syag
Wssb1HUoMGwqU0roS8+pRpNC8YgsWpsttvUWSZ8u6Vj/FLeHpiV3mYXPVMaKRhVm
067BA2uj4Th1JKtGleox+Em0R7OFbCc/9aWC67wiqI6KRyit9pYiF3npph+7D5Eq
7zPsUdDd+qc+UTiLp3liCRp5w6484wWdhZO6wRtmUgxGjNkxFoNnX8CitzF8AaqO
UWWemqWuz3lAZuORQ9KX
=OQzQ
-----END PGP SIGNATURE-----</programlisting>

      <para>Jeder Sicherheitshinweis verwendet das folgende
	Format:</para>

      <itemizedlist>
	<listitem>
	  <para>Jeder Sicherheitshinweis wird mit dem
	    <acronym>PGP</acronym>-Schlüssel des
	    Sicherheitsbeauftragten unterzeichnet.  Der öffentliche
	    Schlüssel des Sicherheitsbeauftragten kann in <xref
	      linkend="pgpkeys"/> überprüft werden.</para>
	</listitem>

	<listitem>
	  <para>Der Name des Sicherheitshinweises beginnt immer mit
	    <literal>FreeBSD-SA-</literal> (für FreeBSD Security
	    Advisory), gefolgt vom Jahr im zweistelligen Format
	    (<literal>14:</literal>), gefolgt von der Anzahl von
	    Sicherheitshinweisen für dieses Jahr
	    (<literal>04.</literal>), gefolgt vom Namen der Anwendung
	    oder des betroffenen Subsystems (<literal>bind</literal>).
	    Der hier gezeigte Sicherheitshinweis ist der vierte
	    Hinweis für das Jahr 2014 und betrifft die Anwendung
	    <application>BIND</application>.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Topic</literal> enthält eine
	    Beschreibung der Schwachstelle.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Category</literal> beschreibt den
	    betroffenen Systemteil.  Mögliche Werte für dieses Feld
	    sind <literal>core</literal>, <literal>contrib</literal>
	    oder <literal>ports</literal>.  Die Kategorie
	    <literal>core</literal> gilt für Komponenten des
	    &os;-Betriebssystems, die Kategorie
	    <literal>contrib</literal> beschreibt zum Basissystem
	    gehörende Software Dritter, beispielsweise
	    <application>BIND</application>.  Die Kategorie
	    <literal>ports</literal> beschreibt Software, die Teil
	    der Ports-Sammlung ist.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Module</literal> beschreibt die
	    betroffene Komponente.  Im diesem Beispiel ist das
	    <literal>bind</literal>-Modul betroffen, dass heißt
	    dieses Problem betrifft eine Anwendung aus dem
	    Betriebssystem.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Announced</literal> gibt den
	    Zeitpunkt der Bekanntgabe des Sicherheitshinweises
	    an.  Das bedeutet, dass das Sicherheitsteam das Problem
	    bestätigt hat und das eine entsprechende Korrektur bereits
	    im &os; Quellcode-Repository zur Verfügung steht .</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Credits</literal> gibt die Person
	    oder Organisation an, die das Sicherheitsproblem
	    bemerkt und gemeldet hat.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Affects</literal> listet die
	    &os;-Releases auf, die von dem Problem betroffen
	    sind.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Corrected</literal> zeigt an,
	    wann das Problem in welchem Release behoben wurde.</para>
	</listitem>

	<listitem>
	  <para>Reserviert für Informationen, über die
	    auf <link xlink:href="http://cve.mitre.org">
	      cve.mitre.org</link> nach Sicherheitslücken
	    gesucht werden kann.</para>
	</listitem>

	<listitem>
	  <para>Im Feld <literal>Background</literal> wird
	    das betroffene Modul beschrieben.</para>
	</listitem>

	<listitem>
	  <para>Im Feld <literal>Problem Description</literal> wird
	    das Sicherheitsproblem beschrieben.  Hier wird
	    fehlerhafter Code beschrieben oder geschildert,
	    wie ein Werkzeug ausgenutzt werden könnte.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Impact</literal> beschreibt die
	    Auswirkungen des Sicherheitsproblems auf ein
	    System.</para>
	</listitem>

	<listitem>
	  <para>Im Feld <literal>Workaround</literal> wird
	    eine Umgehung des Sicherheitsproblems beschrieben.
	    Die Umgehung ist für Administratoren gedacht,
	    die das System aus Zeitnot, Netzwerk-technischen oder
	    anderen Gründen nicht aktualisieren können.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Solution</literal> enthält eine
	    getestete Schritt-für-Schritt Anleitung, die das
	    Sicherheitsproblem behebt.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Correction Details</literal>
	    enthält die <application>Subversion</application>-Tags
	    der betroffenen Dateien zusammen mit zugehörigen
	    Revisionsnummern, in denen das Problem behoben
	    wurde.</para>
	</listitem>

	<listitem>
	  <para>Im Feld <literal>References</literal> finden sich
	    Verweise auf weitere Informationsquellen.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="security-accounting">
    <info><title>Prozess-Überwachung</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>Prozess-Überwachung</primary>
    </indexterm>

    <para>Prozess-Überwachung
      (<foreignphrase>Process accounting</foreignphrase>) ist ein
      Sicherheitsverfahren, bei dem ein Administrator verfolgt,
      welche Systemressourcen verwendet werden und wie sich diese
      auf die einzelnen Anwender verteilen.  Dadurch kann das
      System überwacht werden und es ist sogar möglich,
      zu kontrollieren, welche Befehle ein Anwender eingibt.</para>

    <para>Diese Fähigkeiten haben sowohl Vor- als auch Nachteile.
      Positiv ist, dass man einen Einbruchsversuch bis an den Anfang
      zurückverfolgen kann.  Von Nachteil ist allerdings,
      dass durch diesen Prozess Unmengen an Protokolldateien erzeugt
      werden, die auch dementsprechenden Plattenplatz benötigen.
      Dieser Abschnitt beschreibt die Grundlagen der
      Prozess-Überwachung.</para>

    <sect2>
      <title>Die Prozess-Überwachung aktivieren und
        konfigurieren</title>

      <para>Bevor Sie die Prozess-Überwachung verwenden können,
        müssen Sie diese über die folgenden Befehle aktivieren:</para>

       <screen>&prompt.root; <userinput>touch /var/account/acct</userinput>
&prompt.root; <userinput>chmod 600 /var/account/acct</userinput>
&prompt.root; <userinput>accton /var/account/acct</userinput>
&prompt.root; <userinput>echo 'accounting_enable="YES"' &gt;&gt; /etc/rc.conf</userinput></screen>

      <para>Einmal aktiviert, wird sofort mit der Überwachung von
	<acronym>CPU</acronym>-Statistiken, Befehlen und anderen
	Vorgängen begonnen.  Protokolldateien werden in einem
	nur von Maschinen lesbaren Format gespeichert und können
	über &man.sa.8; aufgerufen werden.  Ohne Optionen gibt
	&man.sa.8; Informationen wie die Anzahl der Aufrufe pro
	Anwender, die abgelaufene Zeit in Minuten, die gesamte
	<acronym>CPU</acronym>- und Anwenderzeit in Minuten und die
	durchschnittliche Anzahl der Ein- und Ausgabeoperationen
	aus.</para>

      <para>Um Informationen über ausgeführte Befehle zu
	erhalten, verwenden Sie &man.lastcomm.1;. So können Sie
	etwa ermitteln, welche Befehle von wem auf welchem &man.ttys.5;
	ausgeführt wurden.  Dieses Beispiel zeigt die Nutzung von
	&man.ls.1; durch <systemitem
	  class="username">trhodes</systemitem> auf dem Terminal
	<literal>ttyp1</literal>:</para>

      <screen>&prompt.root; <userinput>lastcomm ls trhodes ttyp1</userinput></screen>

      <para>Zahlreiche weitere nützliche Optionen finden Sie
	&man.lastcomm.1;, &man.acct.5; sowie &man.sa.8;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="security-resourcelimits">
    <title>Einschränkung von Ressourcen</title>

    <info>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Ressourcen einschränken</primary>
    </indexterm>

    <para>Seit Jahren benutzt &os; die Datenbank
      <filename>/etc/login.conf</filename> um Ressourcen zu
      beschränken.  Obwohl dies immer noch unterstützt wird, ist es
      nicht die optimale Methode um die Beschränkung von Ressourcen zu
      steuern, da Benutzer in verschiedene Gruppen (Login-Klassen)
      aufgeteilt werden müssen und bei Änderungen immer die Datei und
      die Passwortdatenbank bearbeitet werden muss.  Möglicherweise
      benötigt ein eingeschränkter Benutzer eine zusätzliche Klasse,
      dann müsste die Datenbank mit <command>cap_mkdb</command> neu
      gebaut werden und <filename>/etc/master.passwd</filename> müsste
      ebenfalls bearbeitet werden.  Zusätzlich müsste die
      Passwortdatenbank mit <command>pwd_mkdb</command> neu gebaut
      werden.  Dieser Prozess kann sehr zeitaufwendig sein, abhängig
      davon, wie viele Benutzer bearbeitet werden müssen.</para>

    <para>Mit &man.rctl.8; können Ressourcen für Benutzer sehr
      detailliert gesteuert werden.  Die Befehl unterstützt nicht
      nur die Kontrolle der Ressourcen für Benutzer, sondern auch
      die Beschränkung auf Prozesse, Jails und den ursprünglichen
      Login-Klassen.  Diese erweiterten Funktionen bieten
      Administratoren und Benutzern die Möglichkeit, Ressourcen über
      die Kommandozeile oder über eine Konfigurationsdatei zu
      steuern.</para>

    <para>Um diese Eigenschaft zu aktivieren, fügen Sie folgende Zeile
      in die Kernelkonfigurationsdatei:</para>

    <programlisting>options           RACCT
options         RCTL</programlisting>

    <para>Das System muss nun neu übersetzt werden. Dieser Vorgang
      wird in <xref linkend="kernelconfig"/> beschrieben.
      Anschließend kann <command>rctl</command> benutzt werden, um
      die Regeln für das System festzulegen.</para>

    <para>Die Syntax der Regeln ist einfach und wird durch
      <emphasis>subject</emphasis>, <emphasis>subject-id</emphasis>,
      <emphasis>resource</emphasis> und <emphasis>action</emphasis>
      gesteuert.  Hier ein Beispiel für eine Regel:</para>

    <programlisting>user:trhodes:<literal>maxproc</literal>:<literal>deny</literal>=10/user</programlisting>

    <para>Diese Regel zeigt den grundlegenden Aufbau, hier mit dem
      Subjekt <literal>user</literal> und der Subjekt-ID
      <literal>trhodes</literal>.  <literal>maxproc</literal>
      definiert die Anzahl der Prozesse.  Die <quote>Aktion</quote>
      <literal>deny</literal> verhindert, dass neue Prozesse erstellt
      werden.  Im vorherigen Beispiel wurde für den Benutzer
      <literal>trhodes</literal> eine Beschränkung von
      <literal>10</literal> (zehn) Prozessen konfiguriert.  Es sind
      noch weitere Aktionen verfügbar, beispielsweise die
      Protokollierung auf der Konsole, Benachrichtigungen an
      &man.devd.8; oder das Senden eines <literal>SIGTERM</literal>
      an einen Prozess.</para>

    <para>Beim hinzufügen von Regeln müssen einige Dinge beachtet
      werden.  Das obige Beispiel würde den Benutzer sogar daran
      hindern, einfachste Dinge zu tun, nachdem er sich anmeldet und
      eine <command>screen</command> Sitzung gestartet hat.  Sobald
      die Begrenzung für eine Ressource erreicht ist, wird folgende
      Meldung ausgegeben:</para>

    <screen>&prompt.root; <userinput>man test</userinput>
/usr/bin/man: Cannot fork: Resource temporarily unavailable
eval: Cannot fork: Resource temporarily unavailable</screen>

    <para>&man.rctl.8; kann auch benutzt werden, um einer Jail
      eine Speichergrenze zuzuweisen.  Eine solche Regel könnte
      wie folgt festgelegt werden:</para>

    <screen>&prompt.root; <userinput>rctl -a jail:httpd:memoryuse:deny=2G/jail</userinput></screen>

    <para>Damit die Regeln auch nach einem Neustart erhalten bleiben,
      müssen sie in <filename>/etc/rctl.conf</filename> hinzugefügt
      werden.  Dazu schreiben Sie einfach die Regel, ohne das
      vorhergehende Kommando.  Zum Beispiel:</para>

    <programlisting># Block jail from using more than 2G memory:
jail:httpd:memoryuse:deny=2G/jail</programlisting>

    <para>Mit <command>rctl</command> können auch Regeln entfernt
      werden:</para>

    <screen>&prompt.root; <userinput>rctl -r user:trhodes:maxproc:deny=10/user</userinput></screen>

    <para>Die Manualpage zeigt auch eine Möglichkeit, alle Regeln zu
      entfernen.  Falls es erforderlich ist alle Regeln für einen
      einzelnen Benutzer zu entfernen, kann dieser Befehl verwendet
      werden:</para>

    <screen>&prompt.root; <userinput>rctl -r user:trhodes</userinput></screen>

    <para>Es gibt noch viele weitere Ressourcen, die verwendet werden
      können, um zusätzliche <literal>subjects</literal> zu
      kontrollieren.  Weitere Informationen zu diesem Thema finden Sie
      in &man.rctl.8;.</para>
  </sect1>
</chapter>
