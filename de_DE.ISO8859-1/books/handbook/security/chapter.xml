<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/security/chapter.xml,v 1.178 2012/04/30 17:07:41 bcr Exp $
     basiert auf: r42014
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="security">
  <info><title>Sicherheit</title>
    <authorgroup>
      <author><personname><firstname>Matthew</firstname><surname>Dillon</surname></personname><contrib>Viel von diesem Kapitel stammt aus der security(7)
	  Manualpage von </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Martin</firstname><surname>Heinen</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>

  
  <indexterm><primary>Sicherheit</primary></indexterm>

  <sect1 xml:id="security-synopsis">
    <title>Übersicht</title>

    <para>Dieses Kapitel bietet eine Einführung in die Konzepte
      der Systemsicherheit.  Des weiteren werden einige allgemeine
      Daumenregeln und einige fortgeschrittene Themen unter &os;
      behandelt.  Viele der hier besprochenen Punkte treffen sowohl
      auf die Systemsicherheit als auch auf die Internetsicherheit zu.
      Die Absicherung eines Systems ist unumgänglich, um Daten,
      geistiges Eigentum, Zeit und vieles mehr vor Hackern und
      dergleichen zu schützen.</para>

    <para>&os; besitzt eine Reihe von Werkzeugen und Mechanismen, um
      die Integrität und die Sicherheit des Systems und des Netzwerks
      zu schützen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie:</para>

    <itemizedlist>
      <listitem>
	<para>Grundlegende auf &os; bezogene Sicherheitsaspekte
	  kennen.</para>
      </listitem>

      <listitem>
	<para>Die verschiedenen Verschlüsselungsmechanismen
	  von &os; kennen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie ein Einmalpasswörter
	  zur Authentifizierung verwenden.</para>
      </listitem>

      <listitem>
	<para><acronym>TCP</acronym>-Wrapper für &man.inetd.8;
	  einrichten können.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <application>Kerberos</application>
	  unter &os; einrichten.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie IPsec konfigurieren und ein
	  <acronym>VPN</acronym> einrichten.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <application>OpenSSH</application> unter
	  &os; konfigurieren und benutzen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <acronym>ACL</acronym>s für Dateisysteme
	  benutzen.</para>
      </listitem>

      <listitem>
	<para><application>Portaudit</application> anwenden können,
	  um Softwarepakete aus der Ports-Sammlung auf bekannte
	  Sicherheitslücken hin zu überprüfen.</para>
      </listitem>

      <listitem>
	<para>Mit &os;-Sicherheitshinweisen umgehen können.</para>
      </listitem>

      <listitem>
	<para>Eine Vorstellung davon haben, was Prozessüberwachung
	  (<foreignphrase>Process Accounting</foreignphrase>) ist und
	  wie Sie diese Funktion unter &os; aktivieren können.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie die Ressourcen-Datenbank benutzt, um die
	  Ressourcen für Benutzer zu steuern.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Grundlegende Konzepte von &os; und dem Internet
	  verstehen.</para>
      </listitem>
    </itemizedlist>

    <para>Dieses Buch behandelt weitere Sicherheitsthemen.
      Beispielsweise werden verbindliche Zugriffskontrollen
      im <xref linkend="mac"/> und Firewalls im
      <xref linkend="firewalls"/> besprochen.</para>
  </sect1>

  <sect1 xml:id="security-intro">
    <title>Einführung</title>

    <para>Sicherheit ist ein Konzept, das beim Systemadministrator
      anfängt und aufhört.  Obwohl &os; über Sicherheitsfunktionen
      verfügt, ist die Erstellung und Pflege von zusätzlichen
      Sicherheitsmechanismen wohl eine der größten Aufgaben eines
      Systemadministrators.</para>

    <para>Zur Systemsicherheit gehört auch die Beschäftigung mit
      verschiedenen Arten von Angriffen, auch solchen, die versuchen,
      ein System still zu legen, oder sonst unbrauchbar zu machen ohne
      <systemitem class="username">root</systemitem> zu
      kompromittieren.  Sicherheitsaspekte lassen sich in mehrere
      Kategorien unterteilen:</para>

    <orderedlist>
      <listitem>
	<para>Denial-of-Service Angriffe.</para>
      </listitem>

      <listitem>
	<para>Kompromittierte Accounts.</para>
      </listitem>

      <listitem>
	<para>Kompromittierter <systemitem
	    class="username">root</systemitem>-Account durch
	  zugängliche Server.</para>
      </listitem>

      <listitem>
	<para>Kompromittierter <systemitem class="username">root</systemitem>-Account durch
	  kompromittierte Accounts.</para>
      </listitem>

      <listitem>
	<para>Einrichten von Hintertüren.</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>DoS-Angriffe</primary>
      <see>Denial-of-Service (DoS)</see>
    </indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>DoS-AAngriffe</secondary>
      <see>Denial-of-Service (DoS)</see>
    </indexterm>
    <indexterm><primary>Denial-of-Service (DoS)</primary></indexterm>

    <para>Ein Denial-of-Service <acronym>DoS</acronym>-Angriff
      entzieht einer Maschine Ressourcen, die sie zur Bereitstellung
      von Diensten benötigt.  Meist versuchen
      <acronym>DoS</acronym>-Angriffe die Dienste oder den
      Netzwerkstack einer Maschine zu überlasten, um so die Maschine
      auszuschalten oder nicht nutzbar zu machen.  Oft können
      Angriffe auf Dienste durch die Angabe von Optionen verhindert
      werden, die die Last, die ein Dienst auf das System unter
      widrigen Umständen ausüben kann, begrenzt.  Angriffen auf das
      Netzwerk ist schwerer zu begegnen.  Außer durch Trennen der
      Internetverbindung ist zum Beispiel einem Angriff mit
      gefälschten Paketen nicht zu begegnen.  Diese Art von Angriff
      wird das System zwar nicht unbrauchbar machen, kann aber die
      Internetverbindung sättigen.</para>

    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>kompromittierte Accounts</secondary>
    </indexterm>

    <para>Kompromittierte Accounts kommen noch häufiger als
      <acronym>DoS</acronym>-Angriffe vor.  Viele
      Systemadministratoren lassen immer noch unverschlüsselte Dienste
      laufen, was zur Folge hat, dass das Passwort von Benutzern, die
      sich von einem entfernten Standort anmelden, leicht ausgespäht
      werden kann.  Ein aufmerksamer Systemadministrator wird die
      Logdateien über Anmeldungen von entfernten Systemen auf
      verdächtige Quelladressen, auch für erfolgreiche Anmeldungen,
      untersuchen.</para>

    <para>Allerdings gibt der Zugriff auf einen Account auf einem gut
      gesicherten und gepflegten System nicht notwendig Zugriff auf
      den <systemitem class="username">root</systemitem>-Account.
      Diese Unterscheidung ist wichtig, da ein Angreifer, der keinen
      Zugang zu <systemitem class="username">root</systemitem>
      besitzt, seine Spuren nicht verwischen kann.  Er kann höchstens
      die Dateien des betreffenden Benutzers verändern oder die
      Maschine stilllegen.  Kompromittierte Accounts sind sehr
      häufig, da Benutzer meist nicht dieselben Vorsichtsmaßnahmen
      wie Administratoren treffen.</para>

    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>Hintertüren</secondary>
    </indexterm>

    <para>Es gibt viele Wege, Zugang zum <systemitem class="username">root</systemitem>-Account
      eines Systems zu bekommen: Ein Angreifer kann das Passwort von
      <systemitem class="username">root</systemitem> kennen, er kann einen Fehler in einem
      Server entdecken, der unter <systemitem class="username">root</systemitem> läuft und
      dann über eine Netzwerkverbindung zu diesem Server einbrechen.
      Oder er kennt einen
      Fehler in einem SUID-<systemitem class="username">root</systemitem> Programm, der es
      ihm erlaubt, <systemitem class="username">root</systemitem> zu werden, wenn er einmal
      einen Account kompromittiert hat.  Wenn ein Angreifer einen
      Weg gefunden hat, <systemitem class="username">root</systemitem> zu werden, braucht er
      vielleicht keine Hintertür auf dem System installieren.</para>

    <para>Sicherheitsmaßnahmen sollten immer in mehreren Schichten
      angelegt werden.  Die Schichten können wie folgt eingeteilt
      werden:</para>

    <orderedlist>
      <listitem>
	<para>Absichern von <systemitem
	    class="username">root</systemitem>-Accounts.</para>
      </listitem>

      <listitem>
	<para>Absichern von unter <systemitem class="username">root</systemitem> laufenden
	  Servern und SUID/SGID Programmen.</para>
      </listitem>

      <listitem>
	<para>Absichern von Benutzer-Accounts.</para>
      </listitem>

      <listitem>
	<para>Absichern der Passwort-Datei.</para>
      </listitem>

      <listitem>
	<para>Absichern des Kernels, der Geräte und von
	  Dateisystemen.</para>
      </listitem>

      <listitem>
	<para>Schnelles Aufdecken von unbefugten Veränderungen des
	  Systems.</para>
      </listitem>

      <listitem>
	<para>Paranoia.</para>
      </listitem>
    </orderedlist>

    <para>Die einzelnen Punkte der obigen Liste werden im nächsten
      Abschnitt genauer behandelt.</para>
  </sect1>

  <sect1 xml:id="securing-freebsd">
    <title>Absichern von &os;</title>

    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>&os; absichern</secondary>
    </indexterm>

    <para>Dieser Abschnitt behandelt die im
      <link linkend="security-intro">letzten Abschnitt</link>
      erwähnten Methoden zur Absicherung eines &os;-Systems.</para>

    <sect2 xml:id="securing-root-and-staff">
      <title>Absichern von <systemitem class="username">root</systemitem> und
	Accounts</title>

      <indexterm>
        <primary>&man.su.1;</primary>
      </indexterm>

      <para>Auf den meisten Systemen ist <systemitem
	  class="username">root</systemitem> ein Passwort zugewiesen.
	Sie sollten <emphasis>immer</emphasis> davon ausgehen, dass
	dieses Passwort kompromittiert ist.  Das heißt nicht, dass Sie
	das Passwort entfernen sollten, da es meist für den
	Konsolenzugriff notwendig ist.  Vielmehr heißt es, dass Sie
	das Passwort nicht außerhalb der Konsole, auch nicht zusammen
	mit &man.su.1;, verwenden sollten.  Stellen Sie sicher, dass
	die PTYs in <filename>ttys</filename> als
	<literal>insecure</literal> markiert sind und damit
	Anmeldungen von <systemitem class="username">root</systemitem>
	verboten sind.  In &os; ist die Anmeldung für <systemitem
	  class="username">root</systemitem> über &man.ssh.1; in der
	Voreinstellung deaktiviert, da in
	<filename>/etc/ssh/sshd_config</filename>
	<literal>PermitRootLogin</literal> auf <literal>no</literal>
	gesetzt ist.  Beachten Sie jede Zugriffsmethode &ndash;
	Dienste wie FTP werden oft vergessen.  Nur an der
	Systemkonsole sollte ein direktes Anmelden als <systemitem
	  class="username">root</systemitem> möglich sein.</para>

      <indexterm>
        <primary><systemitem class="groupname">wheel</systemitem></primary>
      </indexterm>

      <para>Natürlich muss ein Systemadministrator
	<systemitem class="username">root</systemitem>-Zugriff
	erlangen können.  Dieser sollte aber durch zusätzliche
	Passwörter geschützt sein.  Ein Weg, Zugang zu <systemitem
	  class="username">root</systemitem> zu ermöglichen, ist es,
	berechtigte Mitarbeiter in <filename>/etc/group</filename> in
	die Gruppe <systemitem class="groupname">wheel</systemitem>
	aufzunehmen.  Die Personen dieser Gruppe können mit
	<command>su</command> zu <systemitem
	  class="username">root</systemitem> wechseln.  Nur die
	Mitarbeiter, die tatsächlich <systemitem
	  class="username">root</systemitem>-Zugriff benötigen,
	sollten in die Gruppe <systemitem
	  class="groupname">wheel</systemitem> aufgenommen werden.
	Wenn Sie Kerberos für die Authentifizierung benutzen,
	erstellen Sie <filename>.k5login</filename> im
	Heimatverzeichnis von <systemitem
	  class="username">root</systemitem>, damit &man.su.1;
	verwendet werden kann, ohne jemanden in <systemitem
	 class="groupname">wheel</systemitem> aufnehmen zu
	müssen.</para>

      <para>Um ein Konto komplett zu sperren, verwenden Sie
	&man.pw.8;:</para>

      <screen>&prompt.root;<userinput>pw lock <replaceable>staff</replaceable></userinput></screen>

      <para>Danach ist es diesem Benutzer nicht mehr möglich (auch
	nicht mit &man.ssh.1;), sich anzumelden.</para>

      <para>Eine weitere Möglichkeit, bestimmte Benutzer zu sperren,
	ist es, das verschlüsselte Passwort durch das Zeichen
	<quote><literal>*</literal></quote> zu ersetzen.  Da ein
	verschlüsseltes Passwort niemals diesem Zeichen entsprechen
	kann, kann sich der betroffene Benutzer ebenfalls nicht mehr
	anmelden.  Beispielsweise müsste dazu das Konto</para>

      <programlisting>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>mit &man.vipw.8; wie folgt abgeändert werden:</para>

      <programlisting>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Diese Änderung hindert den Benutzer <systemitem
	  class="username">foobar</systemitem> daran, sich auf
	konventionellem Wege am System anzumelden.  Diese Maßnahmen
	greifen allerdings nicht, wenn das betroffene System auch
	eine Anmeldung über <application>Kerberos</application> oder
	&man.ssh.1; erlaubt.</para>

      <para>Diese Sicherheitsmechanismen setzen voraus, dass sich
	Benutzer von einer restriktiven Maschine auf einer weniger
	restriktiven Maschine anmelden.  Wenn zum Beispiel auf dem
	Hauptrechner alle möglichen Arten von Servern laufen, so
	sollten auf der Workstation keine Server laufen.  Um die
	Workstation vernünftig abzusichern, sollten darauf so wenig
	Server wie möglich bis hin zu keinem Server laufen.  Sie
	sollten zudem über einen Bildschirmschoner verfügen, der mit
	einem Passwort gesichert ist.  Natürlich kann ein Angreifer,
	der physikalischen Zugang zu einer Maschine hat, jede Art von
	Sicherheitsmechanismen umgehen.  Beachten Sie, dass der
	Großteil der Einbrüche über das Netzwerk erfolgt und die
	Einbrecher keinen Zugang zu der Maschine besitzen.</para>

      <para>Mit <application>Kerberos</application> können Sie das
	Passwort eines Mitarbeiters an einer Stelle ändern
	und alle Maschinen, auf denen der Mitarbeiter einen Account hat,
	beachten die Änderung sofort.  Wird der Account eines
	Mitarbeiters einmal kompromittiert, so sollte die Fähigkeit, das
	Passwort mit einem Schlag auf allen Maschinen zu ändern,
	nicht unterschätzt werden.  Mit einzelnen Passwörtern
	wird es schwierig, das Passwort auf N Maschinen zu ändern.
	Mit <application>Kerberos</application> können Sie auch
	Beschränkungen für Passwörter festlegen:
	Nicht nur das Ticket kann nach einiger Zeit ungültig werden,
	Sie können auch festlegen, dass ein Benutzer nach einer
	bestimmten Zeit das Passwort wechseln muss.</para>
    </sect2>

    <sect2>
      <title>Absichern von unter <systemitem class="username">root</systemitem> laufenden
        Servern und SUID/SGID Programmen</title>

      <indexterm>
        <primary>Sandkästen</primary>
      </indexterm>
      <indexterm>
        <primary>&man.sshd.8;</primary>
      </indexterm>

      <para>Ein kluger Systemadministrator lässt nur die wirklich
	benötigten Dienste laufen und ist sich darüber im Klaren, dass
	Server von Dritten oft die fehleranfälligsten sind.  Lassen
	Sie keine Server laufen, die Sie vorher nicht genau überprüft
	haben.  Denken Sie zweimal darüber nach, bevor Sie einen
	Dienst als <systemitem class="username">root</systemitem>
	laufen lassen.  Viele Daemonen können unter einem separaten
	Dienstkonto, oder in einem Sandkasten ausgeführt werden.
	Aktivieren Sie keine unsicheren Dienste, wie &man.telnetd.8;
	oder &man.rlogind.8;.</para>

      <para>Ein weiteres potentielles Risiko sind SUID- und
	SGID-Programme.  Die meisten dieser Programme, wie
	&man.rlogin.1; stehen in <filename>/bin</filename>,
	<filename>/sbin</filename>, <filename>/usr/bin</filename>,
	oder <filename>/usr/sbin</filename> zur Verfügung.  Obwohl
	nichts 100% sicher ist, können Sie davon ausgehen, dass die
	SUID- und SGID-Programme des Basissystems ausreichend
	sicher sind.  Es wird empfohlen, den Zugriff auf
	SUID-Programme mit einer Gruppe, auf die nur Mitarbeiter
	zugreifen können, zu beschränken.  SUID-Programme, die niemand
	benutzt, sollten gelöscht werden.  SGID-Programme sind
	vergleichbar gefährlich.  Wenn ein Einbrecher Zugriff auf
	SGID-<systemitem class="groupname">kmem</systemitem> Programm
	erhält, kann er vielleicht <filename>/dev/kmem</filename> und
	damit die verschlüsselte Passwortdatei lesen.  Dies
	kompromittiert unter Umständen jeden Account, der mit einem Passwort
	geschützt ist.  Alternativ kann ein Einbrecher, der in die
	Gruppe <systemitem class="groupname">kmem</systemitem> eingebrochen ist, die
	Tastendrücke auf PTYs verfolgen.  Dies schließt
	auch PTYs mit ein, auf denen sich ein Benutzer mit sicheren
	Methoden anmeldet.  Ein Einbrecher, der Zugriff auf die
	<systemitem class="groupname">tty</systemitem> Gruppe hat, kann auf fast jeden Terminal
	anderer Benutzer schreiben.  Wenn der Benutzer einen Terminal-Emulator
	benutzt, der über eine Tastatur-Simulation verfügt,
	könnte der Angreifer Daten generieren, die den Terminal
	veranlassen, ein Kommando unter diesem Benutzer laufen zu lassen.</para>
    </sect2>

    <sect2 xml:id="secure-users">
      <title>Absichern von Benutzer-Accounts</title>

      <para>Accounts sind für gewöhnlich sehr schwierig
	abzusichern.  Seien Sie daher aufmerksam bei der Überwachung
	der Benutzerkonten. Die Verwendung von &man.ssh.1; und
	<application>Kerberos</application> erfordert zwar zusätzliche
	Administration und technische Unterstützung, ist aber
	verglichen mit der verschlüsselten Passwort-Datei die bessere
	Lösung.</para>
    </sect2>

    <sect2>
      <title>Absichern der Passwort-Datei</title>

      <para>Der einzig sichere Weg ist, so viele Accounts wie möglich
	als ungültig zu markieren und &man.ssh.1; oder
	<application>Kerberos</application> zu benutzen, um auf sie
	zuzugreifen.  Obwohl die Datei <filename>/etc/spwd.db</filename>,
	die die verschlüsselten Passwörter enthält,
	nur von <systemitem class="username">root</systemitem> gelesen werden kann, mag ein
	Angreifer lesenden Zugriff auf diese Datei erlangen, ohne die
	Fähigkeit sie auch zu beschreiben.</para>

      <para>Überwachungsskripten sollten Änderungen
	an der Passwort-Datei melden.  Dies wird in <link
	  linkend="security-integrity">Überprüfen der Integrität von
	  Dateien</link> beschrieben.</para>
    </sect2>

    <sect2>
      <title>Absichern des Kernels, der Geräte und von
        Dateisystemen</title>

      <para>Die meisten modernen Kernel haben einen Gerätetreiber,
	der es erlaubt, Pakete abzuhören.  Unter &os; wird das Gerät
	<filename>bpf</filename> genannt.  Dieses Gerät ist für
	<acronym>DHCP</acronym> erforderlich, kann aber in der
	Kernelkonfigurationsdatei entfernt werden, wenn das System
	kein <acronym>DHCP</acronym> anbietet.</para>

      <indexterm>
        <primary>&man.sysctl.8;</primary>
      </indexterm>

      <para>Auch wenn <filename>bpf</filename> deaktiviert ist,
	müssen Sie sich immer noch um <filename>/dev/mem</filename>
	und <filename>/dev/kmem</filename> sorgen.  Außerdem
	kann der Angreifer immer noch auf die rohen Geräte
	(<foreignphrase>raw devices</foreignphrase>)
	schreiben.  Ein Angreifer könnte &man.kldload.8; benutzen, um
	sein eigenes
	<filename>bpf</filename> oder ein anderes zum Abhören
	geeignetes Gerät in den laufenden Kernel einzubringen.  Um
	diese Probleme zu vermeiden, lassen Sie den Kernel auf
	einem höheren Sicherheitslevel laufen, mindestens
	auf securelevel 1.</para>

      <para>Das Securelevel des Kernels kann auf verschiedene Wege
        gesetzt werden.  Der einfachste Weg, den Securelevel des
	laufenden Kernels zu erhöhen, ist das Setzen von
        <varname>kern.securelevel</varname>:</para>

      <screen>&prompt.root; <userinput>sysctl kern.securelevel=1</userinput></screen>

      <para>In der Voreinstellung bootet der &os; Kernel mit einem
        Securelevel von -1.  Der Securelevel wird solange bei -1 bleiben,
        bis er entweder durch den Administrator oder von &man.init.8;
        durch einen Eintrag im Startskript verändert wird.  Der
        Securelevel kann während des Systemstarts durch das Setzen
        von <varname>kern_securelevel_enable</varname> auf
        <literal>YES</literal> und der Wert der Variable
        <varname>kern_securelevel</varname> auf den gewünschten
        Securelevel in der <filename>/etc/rc.conf</filename>
        erhöht werden.</para>

      <para>Sobald der Securelevel auf den Wert 1 oder höher gesetzt
        ist, werden die append-only und die unveränderlichen Dateien
        geschützt, die Flags können nicht abgeschaltet werden
        und der Zugriff auf raw Devices ist verboten.  Höhere Levels
        verbieten sogar noch weitere Aktionen.  Eine vollständige
	Beschreibung aller Securelevels finden Sie in &man.security.7;
	und &man.init.8;.</para>

      <note>
	<para>Das Erhöhen des Securelevels auf 1 oder höher
	  kann einige Probleme mit <application>&xorg;</application>,
	  verursachen, da der Zugriff auf <filename>/dev/io</filename>
	  geblockt wird, ebenso die Installation von &os; aus den
	  Quellen, da der <buildtarget>installworld</buildtarget>
	  Teil zeitweilig die append-only und die unveränderlichen
	  Flags einiger Dateien zurücksetzen muss.  Manchmal kann es,
	  wie bei <application>&xorg;</application>, durch das sehr
	  frühe Starten von &man.xdm.1; im Boot Prozess möglich sein,
	  dies zu umgehen, wenn der Securelevel noch niedrig genug
	  ist.  Workarounds wie dieser sind nicht für alle
	  Securelevels und für alle Einschränkungen, die sie schaffen,
	  möglich. Ein bisschen Vorausplanung ist eine gute
	  Idee.  Das Verständnis für die Beschränkungen,
	  die durch jedes Securelevel verursacht werden, ist wichtig, da sie
	  die einfache Benutzung des Systems verschlechtern.  Es vereinfacht
	  auch die Wahl einer Standardeinstellung und schützt vor
	  Überraschungen.</para>
      </note>

      <para>Wenn das Securelevel des Kernel auf einen Wert von 1 oder
        höher gesetzt ist, kann es sinnvoll sein das
        <literal>schg</literal> Flag auf kritische Startdateien,
        Verzeichnisse und Skripte zu setzen.  Ein weniger strenger
	Kompromiss ist es, das System auf einem höheren Securelevel
	laufen zu lassen, aber keine <literal>schg</literal> Flags für
	alle Systemdateien und Verzeichnisse zu setzen.  Eine andere
	Möglichkeit ist es, die Verzeichnisse <filename>/</filename>
	und <filename>/usr</filename> read-only zu mounten.  Es sei
	darauf hingewiesen, dass Sie nicht vor lauter Überlegen das
	Wichtigste, nämlich die Entdeckung eines Eindringens,
	vergessen.</para>
    </sect2>

    <sect2 xml:id="security-integrity">
      <title>Überprüfen der Integrität von Dateien</title>

      <para>Sie können die Systemkonfiguration und die Dateien
	nur so weit schützen, wie es die Benutzbarkeit des
	Systems nicht einschränkt.  Wenn Sie zum Beispiel
	mit <command>chflags</command> die Option <literal>schg</literal>
	auf die meisten Dateien in <filename>/</filename> und
	<filename>/usr</filename> setzen, kann das Ihre
	Arbeit mehr behindern
	als nützen.  Die Maßnahme schützt zwar die
	Dateien, schließt aber auch eine Möglichkeit,
	Veränderungen zu entdecken, aus.  Sicherheitsmaßnahmen
	sind nutzlos, oder schlimmer noch, vermitteln ein falsches
	Gefühl von Sicherheit, wenn der potentielle Angreifer nicht
	entdeckt wird.  Die Aufgabe besteht nicht darin, den Angreifer
	aufzuhalten, sondern seine Angriffe zu verzögern, um ihn dann
	auf frischer Tat zu ertappen.</para>

      <para>Der beste Weg, einen Einbruch zu entdecken, ist es, nach
	veränderten, fehlenden oder unerwarteten Dateien zu suchen.
	Der wiederum beste Weg, nach veränderten Dateien zu suchen, ist
	es, die Suche von einem anderen (oft zentralen) besonders
	geschützten System durchzuführen.  Es ist wichtig, dass
	Ihre Sicherheitsüberprüfungen vor einem Angreifer
	verborgen bleiben und daher sind sie auf einem besonders
	geschützten System gut aufgehoben.  Um dies optimal auszunutzen,
	müssen Sie dem besonders geschützten System Zugriffsrechte
	auf die zu schützenden Systeme geben.  Sie können die
	Dateisysteme der zu schützenden Systeme schreibgeschützt
	für das besonders geschützte System exportieren, oder
	Sie können der besonders geschützten Maschine
	<application>SSH</application> auf die anderen Maschinen erlauben,
	indem Sie <application>SSH</application>-Schlüsselpaare
	installieren.  Mit Ausnahme des verursachten Netzwerkverkehrs
	ist die NFS-Methode die am wenigsten sichtbare.  Sie erlaubt es Ihnen,
	nahezu unentdeckt die Dateisysteme der Clients zu beobachten.  Wenn
	Ihr besonders geschütztes System mit den Clients über
	einen Switch verbunden ist, ist die NFS-Methode oft das Mittel der
	Wahl.  Wenn das besonders geschützte System allerdings
	mit einem Hub verbunden ist, oder der Zugriff über mehrere
	Router geschieht, ist die NFS-Methode aus der Netzwerksicht zu
	unsicher.  In einem solchen Fall ist <application>SSH</application>
	besser geeignet, auch wenn es deutliche Spuren
	hinterlässt.</para>

      <para>Wenn das besonders geschützte System lesenden Zugriff
        auf die Clients hat, müssen Sie Skripten schreiben, die die
	Überwachung durchführen.  Wenn Sie die NFS-Methode
	verwenden, können Sie dazu einfache Systemwerkzeuge wie
	&man.find.1; und &man.md5.1; benutzen.  Am besten berechnen
	Sie einmal am Tag MD5-Prüfsummen der Dateien, Konfigurationsdateien
	in <filename>/etc</filename> und
	<filename>/usr/local/etc</filename>
	sollten öfter überprüft werden.  Wenn Unstimmigkeiten
	zwischen den auf der besonders geschützten Maschine gehaltenen
	MD5-Prüfsummen und den ermittelten Prüfsummen festgestellt
	werden, sollte Ihr System einen Systemadministrator benachrichtigen,
	der den Unstimmigkeiten dann nachgehen sollte.  Ein gutes Skript
	überprüft das System auch auf verdächtige
	SUID-Programme sowie gelöschte oder neue Dateien in
	<filename>/</filename> und
	<filename>/usr</filename>.</para>

      <para>Wenn Sie <application>SSH</application> anstelle von NFS
	benutzen, wird das Erstellen der Skripten schwieriger.  Sie müssen
	die Skripten und die Programme wie <command>find</command> mit
	<command>scp</command> auf den Client kopieren.  Damit machen
	Sie die Überprüfung für einen Angreifer sichtbar.
	Außerdem kann der SSH-Client auf dem
	Zielsystem schon kompromittiert sein.  Zusammenfassend kann der
	Einsatz von <application>SSH</application> nötig sein,
	wenn Sie über ungesicherte Verbindungen arbeiten, aber
	der Umgang mit dieser Methode ist auch sehr viel schwieriger.</para>

      <para>Ein gutes Sicherheitsskript wird auch Dateien von Benutzern,
	die den Zugriff auf ein System ermöglichen, wie
	<filename>.rhosts</filename>, <filename>.shosts</filename>,
	<filename>.ssh/authorized_keys</filename> usw., auf
	Veränderungen untersuchen, die über die Möglichkeiten
	einer Überprüfung mit <literal>MD5</literal>
	(die ja nur Veränderungen erkennen kann) hinausgehen.</para>

      <para>Wenn Sie über große Partitionen verfügen, kann
	es zu lange dauern, jede Datei zu überprüfen.  In diesem
	Fall sollten Sie beim Einhängen des Dateisystems Optionen
	setzen, die das Ausführen von SUID-Programmen verbieten.
	&man.mount.8; stellt dazu <literal>nosuid</literal>
	zur Verfügung.  Sie sollten diese Dateien aber trotzdem
	mindestens einmal die Woche überprüfen, da das Ziel
	dieser Schicht das Aufdecken eines Einbruchs, auch wenn er nicht
	erfolgreich war, ist.</para>

      <para>Die Prozessüberwachung (siehe &man.accton.8;)
	des Betriebssystems steht ein günstiges Werkzeug zur
	Verfügung, dass sich bei der Analyse eines Einbruchs
	als nützlich erweisen kann.  Insbesondere können Sie
	damit herausfinden, wie der Einbrecher in das System eingedrungen ist,
	vorausgesetzt die Dateien der Prozessüberwachung sind
	noch alle intakt.</para>

      <para>Schließlich sollten die Sicherheitsskripten die Logdateien
	analysieren.  Dies sollte so sicher wie möglich durchgeführt
	werden, nützlich ist das Schreiben von Logdateien auf
	entfernte Systeme mit <command>syslog</command>.  Ein Einbrecher
	wird versuchen, seine Spuren zu verwischen.  Die Logdateien
	sind wichtig für den Systemadministrator, da er aus ihnen
	den Zeitpunkt und die Art des Einbruchs bestimmen kann.  Eine
	Möglichkeit, die Logdateien unverändert aufzuheben,
	ist es, die Systemkonsole auf einen seriellen Port zu legen
	und die Informationen dort von einer gesicherten Maschine
	auszulesen.</para>
    </sect2>

    <sect2>
      <title>Paranoia</title>

      <para>Es schadet nicht, ein bisschen paranoid zu sein.
	Grundsätzlich darf ein Systemadministrator jede
	Sicherheitsmaßnahme treffen, die die Bedienbarkeit des
	Systems nicht einschränkt.  Er kann auch Maßnahmen
	treffen, die die Bedienbarkeit einschränken,
	wenn er diese vorher genau durchdacht hat.  Was noch wichtiger
	ist: Halten Sie sich nicht sklavisch an dieses Dokument, sondern
	führen Sie eigene Maßnahmen ein, um nicht einem
	künftigen Angreifer, der auch Zugriff auf dieses Dokument
	hat, alle Ihre Methoden zu verraten.</para>
    </sect2>

    <sect2>
      <title>Denial-of-Service Angriffe</title>
      <indexterm><primary>Denial-of-Service (DoS)</primary></indexterm>

      <para>Dieser Abschnitt behandelt Denial-of-Service Angriffe (DoS).
	Ein DoS-Angriff findet typischerweise auf der Paketebene statt.
	Während Sie nicht viel gegen moderne Angriffe mit falschen
	Paketen, die das Netzwerk sättigen, ausrichten können,
	können Sie sehr wohl den Schaden begrenzen, den solche
	Angriffe verursachen können und insbesondere einen kompletten
	Serverausfall verhindern, indem Sie beispielsweise folgende
	Vorkehrungen treffen:</para>

      <orderedlist>
	<listitem>
	  <para>Begrenzen von <function>fork()</function> Aufrufen.</para>
	</listitem>

	<listitem>
	  <para>Begrenzen von Sprungbrett-Angriffen (ICMP response Angriffen,
	    <application>ping</application> zu Broadcast-Adressen usw.).</para>
	</listitem>

	<listitem>
	  <para>Kernel-Cache für Routen.</para>
	</listitem>
      </orderedlist>

      <para>Ein häufiger DoS-Angriff gegen forkende Server versucht
	den Server dazu zu bringen, solange neue Prozesse zu starten,
	bis das System den ganzen Speicher und alle Dateideskriptoren
	verbraucht hat, was dann zu einem Ausfall des Servers führt.
	&man.inetd.8; besitzt einige Optionen, um diese Art von Angriffen
	zu begrenzen.  Beachten Sie bitte, dass es möglich ist, einen
	Ausfall einer Maschine zu verhindern, doch ist es generell nicht
	möglich, den Ausfall eines Dienstes bei dieser Art
	von Angriffen zu verhindern.  Lesen Sie sich bitte die Manualpages
	von <application>inetd</application> gut durch und achten Sie speziell
	auf die Optionen <option>-c</option>, <option>-C</option> und
	<option>-R</option>.  Angriffe mit gefälschten IP-Adressen
	umgehen <option>-C</option>, so dass normalerweise eine
	Kombination der Optionen benutzt werden muss.  Manche Server,
	die nicht von <application>inetd</application> gestartet werden,
	besitzen Optionen, um den Start über <function>fork()</function>
	einzuschränken.</para>

      <para><application>Sendmail</application> besitzt die Option
	<option>-OMaxDaemonChildren</option>, die besser als die
	eingebauten Optionen zur Begrenzung der Systemauslastung funktioniert.
	Sie sollten beim Start von <application>Sendmail</application>
	<literal>MaxDaemonChildren</literal> so hoch setzen, dass Sie
	die erwartete Auslastung gut abfangen können.  Allerdings
	sollten Sie den Wert nicht so hoch setzen, dass der
	Rechner über seine eigenen Füße fällt.
	Es ist auch klug, <application>Sendmail</application> im
	Queue-Modus (<option>-ODeliveryMode=queued</option>) laufen zu
	lassen.  Der Daemon (<command>sendmail -bd</command>) sollte
	getrennt von den Queue-Läufen (<command>sendmail -q15m</command>)
	laufen.  Wenn Sie trotzdem eine sofortige Auslieferung der Post
	wünschen, können Sie die Queue in einem geringeren
	Intervall, etwa <option>-q1m</option>, abarbeiten.  Geben Sie
	für <emphasis>dieses</emphasis>
	<application>Sendmail</application> aber einen vernünftigen
	Wert für <literal>MaxDaemonChildren</literal> an, um
	Fehler zu verhindern.</para>

      <para><application>Syslogd</application> kann direkt angegriffen
	werden.  Daher empfehlen wir Ihnen unbedingt die Option
	<option>-s</option> zu benutzen.  Sollte das nicht möglich
	sein, benutzen Sie bitte <option>-a</option>.</para>

      <para>Vorsicht ist auch mit Diensten geboten, die automatisch
	eine Rückverbindung eröffnen, wie der
	reverse-identd der <application>TCP-Wrapper</application>.
        Diese Funktion der <application>TCP-Wrapper</application>
	sollten Sie normalerweise nicht benutzen.</para>

      <para>Es empfiehlt sich sehr, interne Dienste vor externen Zugriffen
	durch eine Firewall an der Grenze Ihres Netzwerks zu schützen.
	Dahinter steckt mehr die Idee, das Netzwerk vor Überlastung
	durch Angriffe von außen zu schützen, als interne
	Dienste vor einem <systemitem class="username">root</systemitem>-Zugriff aus dem Netz
	zu schützen.  Konfigurieren Sie immer eine Firewall, die
	alle Zugriffe blockiert, das heißt blockieren Sie
	<emphasis>alles</emphasis> außer den Ports A, B, C, D
	und M-Z.  Damit können Sie Zugriffe auf alle niedrigen
	Ports blockieren und Zugriffe auf spezielle Dienste wie
	<application>named</application>, wenn Sie den primären
	Namensdienst für eine Zone anbieten,
	<application>ntalkd</application> oder
	<application>Sendmail</application> erlauben.  Wenn Sie die
	Firewall so konfigurieren, das sie in der Voreinstellung alle
	Zugriffe erlaubt, ist es sehr wahrscheinlich, dass Sie
	vergessen, eine Reihe von Diensten zu blockieren bzw. einen
	internen Dienst einführen und dann vergessen die Firewall
	zu aktualisieren.  Sie können immer die höheren
	Portnummern öffnen, ohne die niedrigen Portnummern,
	die nur von <systemitem class="username">root</systemitem> benutzt werden dürfen,
	zu kompromittieren.  Beachten Sie bitte auch, dass es
	&os; erlaubt, die Portnummern, die für dynamische
	Verbindungen zur Verfügung stehen, zu konfigurieren.
	Mit <command>sysctl</command> lassen sich verschiedene
	Bereiche der <varname>net.inet.ip.portrange</varname> Variablen
	setzen (eine Liste erhalten Sie mit <command>sysctl -a | fgrep
	portrange</command>).
	So können Sie zum Beispiel die Portnummern 4000 bis 5000
	für den normalen Bereich und die Nummern 49152 bis 65535
	für den hohen Bereich vorsehen.  Dies erleichtert Ihnen
	die Konfiguration der Firewall, da Sie nun Zugriffe auf Ports
	unterhalb von 4000, mit Ausnahme der Dienste, die von außen
	erreichbar sein sollen, blockieren können.</para>

      <para>Eine andere Form eines DoS-Angriffs nutzt einen Server
	als Sprungbrett, der Server wird dabei so angegriffen, dass
	seine Antworten ihn selber, das lokale Netzwerk oder einen
	anderen Server überlasten.  Der am häufigsten verwendete
	Angriff dieser Art ist der <emphasis>ICMP ping broadcast
	Angriff</emphasis>.  Der Angreifer fälscht dazu
	<application>ping</application>-Pakete, die zu der Broadcast-Adresse
	Ihres LANs gesendet werden, indem er darin als Quelladresse
	die Adresse des Opfers einsetzt.  Wenn die Router an der Grenze
	Ihres Netzwerks <application>ping</application>-Pakete auf
	Broadcast-Adressen nicht abwehren, wird Ihr LAN genügend
	Netzwerkverkehr generieren, um das Ziel des Angriffs zu
	überlasten.  Dies kann besonders effektiv sein, wenn der
	Angreifer diese Methode mit mehreren Dutzend Broadcast-Adressen
	über mehrere Netzwerke einsetzt.  Es wurden schon
	Broadcast-Angriffe mit über 120&nbsp;Megabit pro Sekunde
	gemessen.  Ein zweiter Sprungbrett-Angriff wird gegen
	das Fehlerbehandlungssystem von ICMP eingesetzt.  Indem ein Angreifer
	Pakete konstruiert, die eine ICMP-Fehlermeldung hervorrufen, kann
	er das einkommende Netzwerk des Servers sättigen und diesen
	wiederum veranlassen sein ausgehendes Netzwerk mit ICMP-Antworten
	zu sättigen.  Diese Art des Angriffs kann den kompletten
	Speicher des Servers aufbrauchen und damit den Server stilllegen,
	insbesondere wenn der Server nicht in der Lage ist, die generierten
	ICMP-Antworten schnell genug abzuführen.  Verwenden Sie die
	<application>sysctl</application>-Variable
	<literal>net.inet.icmp.icmplim</literal>, um die Auswirkungen
	solcher Angriffe zu begrenzen.  Die letzte
	weit verbreitete Form von Sprungbrett-Angriffen verwendet
	interne <application>inetd</application>-Dienste wie den
	UDP <application>echo</application>-Dienst.  Der Angreifer fälscht
	dazu einfach ein UDP-Paket, indem er als Quellport den
	<application>echo</application>-Port von Server A
	und als Zielport den <application>echo</application>-Port von
	Server B angibt, wobei beide
	Server in Ihrem LAN stehen.  Die beiden Server werden nun
        dieses Paket zwischen sich hin und her schicken.  Der Angreifer
	kann die beiden Server und das LAN einfach damit überlasten,
	dass er mehrere Pakete dieser Art generiert.  Ähnliche
	Probleme gibt es mit dem internen
	<application>chargen</application>-Port, daher sollten Sie
	die internen <application>inetd</application>-Testdienste
	abstellen.</para>

      <para>Gefälschte IP-Pakete können dazu benutzt werden,
	den Kernel-Cache für Routen zu überlasten.  Schauen Sie
	sich bitte die  <command>sysctl</command>-Parameter
	<varname>net.inet.ip.rtexpire</varname>, <varname>rtminexpire</varname>
	und <varname>rtmaxcache</varname> an.  Ein Angriff der gefälschte
	Pakete mit zufälligen Quelladressen einsetzt, bewirkt, dass
	der Kernel eine Route im Route-Cache anlegt, die Sie sich mit
	<command>netstat -rna | fgrep W3</command> ansehen können.
	Diese Routen verfallen für gewöhnlich nach 1600 Sekunden.
	Wenn der Kernel feststellt, dass die Routingtabelle im Cache
	zu groß geworden ist, wird er dynamisch den Wert von
	<varname>rtexpire</varname> verringern.  Dieser Wert wird aber nie
	kleiner werden als <varname>rtminexpire</varname>.  Daraus
	ergeben sich zwei Probleme:</para>

      <orderedlist>
	<listitem>
	  <para>Der Kernel reagiert nicht schnell genug, wenn ein
	    Server mit einer niedrigen Grundlast plötzlich angegriffen
	    wird.</para>
	</listitem>

	<listitem>
	  <para><varname>rtminexpire</varname> ist nicht klein genug,
	    um einen anhaltenden Angriff zu überstehen.</para>
	</listitem>
      </orderedlist>

      <para>Wenn Ihre Server über eine T3 oder eine noch schnellere
	Leitung mit dem Internet verbunden sind, ist es klug, mit
        &man.sysctl.8; die Werte für <varname>rtexpire</varname> und
	<varname>rtminexpire</varname> händisch zu setzen.  Setzen
	Sie bitte keinen der Werte auf Null, außer Sie wollen die
	Maschine zum Erliegen bringen.  Ein Wert von 2&nbsp;Sekunden für
	beide Parameter sollte ausreichen, um die Routingtabelle vor
	einem Angriff zu schützen.</para>
    </sect2>

    <sect2>
      <title>Anmerkungen zum Zugriff mit Kerberos und SSH</title>
      <indexterm><primary><command>ssh</command></primary></indexterm>

      <para>Es gibt ein paar Punkte, die Sie beachten sollten, wenn Sie
	<application>Kerberos</application> oder <application>SSH</application>
	einsetzen wollen.  <application>Kerberos</application>&nbsp;5 ist ein
	ausgezeichnetes Authentifizierungsprotokoll.  Leider gibt es
	Fehler in den für <application>Kerberos</application>
	angepassten Versionen von <application>telnet</application> und
	<application>rlogin</application>, die sie ungeeignet für den
	Umgang mit binären Datenströmen machen.  Weiterhin
	verschlüsselt <application>Kerberos</application> Ihre Sitzung
	nicht, wenn Sie nicht die <option>-x</option> Option verwenden,
	mit <application>SSH</application> wird dagegen alles
	verschlüsselt.</para>

      <para>Ein Problem mit SSH sind Weiterleitungen von Verbindungen.
	Wenn Sie von einer sicheren Maschine, auf der sich Ihre
	Schlüssel  befinden, eine Verbindung zu einer
	ungesicherten Maschine aufmachen, wird für die Dauer der
	Sitzung ein Port für Weiterleitungen geöffnet.
	Ein Angreifer, der auf der unsicheren Maschine Zugang zu
	<systemitem class="username">root</systemitem> hat, kann diesen Port
	benutzen, um Zugriff auf andere Maschinen zu
	erlangen, die mit Ihren Schlüsseln zugänglich
	sind.</para>

      <para>Wir empfehlen Ihnen, für die Logins Ihrer Mitarbeiter immer
	<application>SSH</application> zusammen mit
	<application>Kerberos</application> einzusetzen.  Damit reduzieren
	Sie die Abhängigkeit von potentiell gefährdeten
	Schlüsseln und schützen gleichzeitig die Passwörter
	mit <application>Kerberos</application>.
	<application>SSH</application>-Schlüsselpaare sollten nur
	für automatisierte Aufgaben von einem besonders gesicherten
	Server eingesetzt werden (<application>Kerberos</application>
	kann für diese Art von Aufgaben nicht eingesetzt werden).
	Weiterhin empfehlen wir Ihnen, das Weiterreichen von Schlüsseln
	in der <application>SSH</application>-Konfiguration abzustellen bzw.
	die <literal>from=IP/DOMAIN</literal> Option in
	<filename>authorized_keys</filename> zu verwenden, die den
	Schlüssel nur von bestimmten Maschinen aus nutzbar macht.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="crypt">
    <info><title>DES, Blowfish, MD5, SHA256, SHA512 und Crypt</title>
      <authorgroup>
	<author><personname><firstname>Bill</firstname><surname>Swingle</surname></personname><contrib>Teile umgeschrieben und aktualisiert von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>Crypt</secondary>
    </indexterm>

    <indexterm><primary>Crypt</primary></indexterm>
    <indexterm><primary>Blowfish</primary></indexterm>
    <indexterm><primary>DES</primary></indexterm>
    <indexterm><primary>MD5</primary></indexterm>
    <indexterm><primary>SHA256</primary></indexterm>
    <indexterm><primary>SHA512</primary></indexterm>

    <para>Jedem Benutzer eines &unix; Systems ist ein Passwort zugeordnet.
      Es scheint offensichtlich, dass das Passwort nur dem Benutzer
      und dem System bekannt sein muss.  Um die Passwörter
      geheim zu halten, werden sie mit einer nicht umkehrbaren Hash-Funktion
      verschlüsselt, das heißt sie können leicht
      verschlüsselt aber nicht entschlüsselt werden.  Was wir
      gerade als offensichtlich dargestellt haben, ist also nicht wahr: Das
      Betriebssystem kennt das Passwort <emphasis>wirklich</emphasis>
      nicht, es kennt nur das <emphasis>verschlüsselte</emphasis>
      Passwort.  Die einzige Möglichkeit, das originale Passwort
      herauszufinden, besteht darin, alle möglichen Passwörter
      auszuprobieren (<foreignphrase>brute force</foreignphrase> Suche).</para>

    <para>Zu der Zeit als &unix; entstanden ist, war die einzig sichere
      Möglichkeit Passwörter zu verschlüsseln, leider
      DES (Data Encryption Standard).  Für die Einwohner der USA
      stellte das kein Problem dar, aber da der Quellcode von DES nicht aus
      den USA exportiert werden durfte, musste ein Weg gefunden werden,
      der die Gesetze der USA nicht verletzte und gleichzeitig die
      Kompatibilität mit anderen &unix; Systemen, die immer noch DES
      benutzten, wahrte.</para>

    <para>Die Lösung bestand darin, die Verschlüsselungsbibliotheken
      aufzuspalten.  Benutzer in den USA konnten die DES-Bibliotheken
      installieren und nutzen.  In der Grundeinstellung benutzt &os;
      MD5 als Verschlüsselungsmethode, das exportiert werden durfte
      und damit von jedem genutzt werden konnte.  Es wird davon ausgegangen,
      dass MD5 sicherer als DES ist, so dass DES nur aus
      Kompatibilitätsgründen installiert werden sollte.</para>

    <sect2>
      <title>Erkennen der Verschlüsselungsmethode</title>

      <para>Die derzeit unterstützten Hash-Funktionen sind DES, MD5,
	Blowfish, SHA256 und SHA512.  In der
	Voreinstellung benutzten &os;&nbsp;9.1 und neuere Versionen
	SHA512 zur Verschlüsselung von Passwörtern.  Ältere Versionen
	benutzen standardmäßig MD5.</para>

      <para>Sie können leicht herausfinden, welche
	Verschlüsselungsmethode von &os; verwendet wird.  Ein Weg
	besteht darin, die verschlüsselten Passwörter in
	<filename>/etc/master.passwd</filename> zu untersuchen.
	Passwörter, die mit MD5 verschlüsselt wurden,
	sind länger als die mit DES verschlüsselten und
	beginnen mit den Zeichen <literal>&dollar;1&dollar;</literal>.
	Passwörter, die mit <literal>&dollar;2a&dollar;</literal>
	anfangen, wurden mit der Blowfish-Funktion verschlüsselt.
	DES Passwörter besitzen keine offensichtlichen Merkmale,
	an denen sie identifiziert werden könnten.  Sie sind aber
	kürzer als MD5-Passwörter und sind in einem
	64 Zeichen umfassenden Alphabet kodiert, das das
	<literal>&dollar;</literal>-Zeichen nicht enthält.  Ein relativ
	kurzes Passwort, das nicht mit einem
	<literal>&dollar;</literal>-Zeichen anfängt, ist wahrscheinlich
	ein DES-Passwort.  SHA256 und SHA512 beginnen mit dem Zeichen
	<literal>&dollar;6&dollar;</literal>.</para>

      <para>Die Verschlüsselungsmethode für neue
        Passwörter wird durch <literal>passwd_format</literal> in
	<filename>/etc/login.conf</filename> bestimmt.  Der Wert
	dieser Variablen kann entweder <literal>des</literal>,
	<literal>md5</literal>, <literal>blf</literal>,
	<literal>sha256</literal> oder <literal>sha512</literal> sein.
	Näheres schlagen Sie bitte in &man.login.conf.5; nach.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="one-time-passwords">
    <title>Einmalpasswörter</title>

    <indexterm><primary>Einmalpasswörter</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>Einmalpasswörter</secondary>
    </indexterm>

    <para>In der Voreinstellung unterstützt &os;
      <foreignphrase>One-time Passwords in Everything</foreignphrase>
      (<acronym>OPIE</acronym>), das in der Voreinstellung
      MD5-Hash-Funktionen einsetzt.</para>

    <para>Es gibt drei verschiedene Arten von Passwörtern.  Das erste
      ist das normales &unix;- oder Kerberos-Passwort.  Das zweite ist
      das Einmalpasswort, das von <command>opiekey</command> generiert
      und von <command>opiepasswd</command> und dem Anmeldeprompt
      akzeptiert wird.  Das dritte Passwort ist das
      <quote>geheime Passwort</quote>, das mit
      <command>opiekey</command> (manchmal auch mit
      <command>opiepasswd</command>) zum Erstellen der
      Einmalpasswörter verwendet wird.</para>

    <para>Das geheime Passwort steht in keiner Beziehung zum
      &unix;-Passwort.  Beide können gleich sein, obwohl das nicht
      empfohlen wird.  Die geheimen Passwörter von
      <acronym>OPIE</acronym> sind nicht auf eine Länge von 8 Zeichen,
      wie alte &unix; Passwörter<footnote>
	<para>Unter &os; darf das System-Passwort maximal
	  128 Zeichen lang sein.</para></footnote>, beschränkt.
      Gebräuchlich sind Passwörter, die sich aus sechs bis sieben
      Wörtern zusammensetzen.  Das <acronym>OPIE</acronym>-System
      arbeitet vollständig unabhängig von den auf &unix;-Systemen
      verwendeten Passwort-Mechanismen.</para>

    <para>Neben dem Passwort gibt es noch zwei Werte, die für
      <acronym>OPIE</acronym> wichtig sind.  Der erste ist der
      <quote>Initialwert</quote> (engl.
      <foreignphrase>seed</foreignphrase> oder
      <foreignphrase>key</foreignphrase>), der aus zwei Buchstaben und
      fünf Ziffern besteht.  Der zweite Wert ist der
      <quote>Iterationszähler</quote>, eine Zahl zwischen 1 und 100.
      <acronym>OPIE</acronym> generiert das Einmalpasswort, indem
      es den Initialwert und das geheime Passwort aneinander hängt
      und dann die MD5-Hash-Funktion so oft, wie durch den
      Iterationszähler gegeben, anwendet.  Das Ergebnis wird in
      sechs englische Wörter umgewandelt, die das Einmalpasswort
      ergeben.  Das Authentifizierungssystem (meistens PAM) merkt sich
      das zuletzt benutzte Einmalpasswort und der Benutzer ist
      authentifiziert, wenn die Hash-Funktion des Passworts dem
      vorigen Passwort entspricht.  Da nicht umkehrbare
      Hash-Funktionen benutzt werden, ist es unmöglich, aus einem
      bekannten Passwort weitere gültige Einmalpasswörter zu
      berechnen.  Der Iterationszähler wird nach jeder erfolgreichen
      Anmeldung um eins verringert und stellt so die Synchronisation
      zwischen Benutzer und Login-Programm sicher.  Wenn der
      Iterationszähler den Wert 1 erreicht, muss
      <acronym>OPIE</acronym> neu initialisiert werden.</para>

    <para>Es gibt ein paar Programme, die in diesen Prozess einbezogen
      werden.  &man.opiekey.1; akzeptiert einen Iterationszähler,
      einen Initialwert und ein geheimes Passwort.  Daraus generiert
      es ein Einmalpasswort oder eine Liste von Einmalpasswörtern.
      &man.opiepasswd.1; wird benutzt, um Passwörter, Iterationszähler
      oder Initialwerte zu ändern.  Als Parameter verlangt es
      entweder ein geheimes Passwort oder einen Iterationszähler
      oder einen Initialwert und ein Einmalpasswort.
      &man.opieinfo.1; hingegen gibt den momentanen Iterationszähler
      und Initialwert eines Benutzers aus, den es aus
      <filename>/etc/opiekeys</filename> ermittelt.</para>
      <!-- Credential Dateien -->

    <para>Es gibt vier verschiedene Arten von Tätigkeiten.  Zuerst
      wird erläutert, wie &man.opiepasswd.1; über eine gesicherte
      Verbindung eingesetzt werden, um Einmalpasswörter das erste Mal
      zu konfigurieren oder das Passwort oder den Initialwert zu
      ändern.  Als nächstes wird erklärt, wie &man.opiepasswd.1; über
      eine nicht gesicherte Verbindung, oder zusammen mit
      &man.opiekey.1; über eine gesicherte Verbindung eingesetzt
      werden, um dasselbe zu erreichen. Als drittes wird beschrieben,
      wie &man.opiekey.1; genutzt wird, um sich über eine nicht
      gesicherte Verbindung anzumelden.  Die vierte Tätigkeit
      beschreibt, wie mit &man.opiekey.1; eine Reihe von Schlüsseln
      generiert wird, die Sie sich aufschreiben oder ausdrucken
      können, um sich von Orten anzumelden, die über keine gesicherten
      Verbindungen verfügen.</para>

    <sect2>
      <title>Einrichten über eine gesicherte Verbindung</title>

      <para>Um <acronym>OPIE</acronym> erstmals zu initialisieren,
	rufen Sie &man.opiepasswd.1; auf:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:

ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
      </screen>

      <para>Nach der Aufforderung <prompt>Enter new secret pass phrase:</prompt>
	oder <prompt>Enter secret password:</prompt> geben Sie bitte Ihr
	Passwort ein.  Dies ist nicht das Passwort, mit dem Sie sich
	anmelden, sondern es wird genutzt, um das Einmalpasswort
	zu generieren.  Die Zeile, die mit <quote>ID</quote> anfängt,
	enthält Ihren Login-Namen, den Iterationszähler und den
	Initialwert.  Diese Werte müssen Sie sich nicht merken, da
	das System sie zeigen wird, wenn Sie sich anmelden.  In der letzten
	Zeile steht das Einmalpasswort, das aus diesen Parametern
	und Ihrem geheimen Passwort ermittelt wurde.  Bei der nächsten
	Anmeldung müssen Sie dann dieses Einmalpasswort
	benutzen.</para>
    </sect2>

    <sect2>
      <title>Einrichten über eine nicht gesicherte Verbindung</title>

      <para>Um Einmalpasswörter über eine nicht gesicherte Verbindung
	einzurichten, oder das geheime Passwort zu ändern, müssen Sie
	über eine gesicherte Verbindung zu einer Stelle verfügen, an
	der Sie &man.opiekey.1; ausführen können.  Dies kann etwa die
	Eingabeaufforderung auf einer Maschine sein, der Sie
	vertrauen.  Zudem müssen Sie einen Iterationszähler vorgeben
	(100 ist ein guter Wert) und einen Initialwert wählen, wobei
	Sie auch einen zufällig generierten benutzen können.  Benutzen
	Sie &man.opiepasswd.1; über die ungesicherte Verbindung zu der
	Maschine, die Sie einrichten wollen:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</screen>

      <para>Drücken Sie <keycap>Return</keycap>, um die Vorgabe
	für den Initialwert zu akzeptieren.  Bevor
	Sie nun das Zugriffspasswort
	(engl. <foreignphrase>access password</foreignphrase>)
	eingeben, rufen Sie über die gesicherte Verbindung
	<command>opikey</command> mit denselben Parametern auf:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Gehen Sie zurück zu der nicht gesicherten Verbindung
	und geben dort das eben generierte Einmalpasswort ein.</para>
    </sect2>

    <sect2>
      <title>Erzeugen eines einzelnen Einmalpasswortes</title>

      <para>Nachdem Sie <acronym>OPIE</acronym> eingerichtet haben,
	werden Sie beim nächsten Anmelden wie folgt begrüßt:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para><acronym>OPIE</acronym> besitzt eine nützliche
	Eigenschaft.  Wenn Sie an der Eingabeaufforderung
	<keycap>Return</keycap> drücken, wird die echo-Funktion
	eingeschaltet, das heißt Sie sehen, was Sie tippen.  Dies ist
	besonders nützlich, wenn Sie ein generiertes Passwort von
	einem Ausdruck abtippen müssen.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>Jetzt müssen Sie das Einmalpasswort generieren,
	um der Anmeldeaufforderung nachzukommen.  Dies muss auf
	einem gesicherten System geschehen, auf dem Sie
	&man.opiekey.1; ausführen können. Dieses Programm gibt es
	auch für &windows;, &macos; und &os;.  Es benötigt den
	Iterationszähler sowie den Initialwert als Parameter, die Sie
	mittels <quote>cut-and-paste</quote> direkt von der
	Login-Aufforderung nehmen können.</para>

      <para>Auf dem sicheren System:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Sobald das Einmalpasswort generiert wurde, können Sie die
	Anmeldeprozedur fortsetzen.</para>
    </sect2>

    <sect2>
      <title>Erzeugen von mehreren Einmalpasswörtern</title>

      <para>Manchmal haben Sie keinen Zugriff auf eine sichere
	Maschine oder eine sichere Verbindung.  In diesem Fall können
	Sie vorher mit &man.opiekey.1; einige Einmalpasswörter
	generieren.  Zum Beispiel:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para>Mit <option>-n 5</option> fordern Sie fünf
	Passwörter der Reihe nach an.  Der letzte
	Iterationszähler wird durch <option>30</option> gegeben.
	Beachten Sie bitte, dass die Passwörter in der
	<emphasis>umgekehrten</emphasis> Reihenfolge, in der sie
	zu benutzen sind, ausgeben werden.  Wirklich paranoide
	Benutzer können sich jetzt die Passwörter aufschreiben oder
	ausdrucken.  Sie sollten die Passwörter nach Gebrauch
	durchstreichen.</para>
    </sect2>

    <sect2>
      <title>Einschränken der Benutzung von
	System-Passwörtern</title>

      <para><acronym>OPIE</acronym> kann die Verwendung von
	&unix;-Passwörtern abhängig von der
	<acronym>IP</acronym>-Adresse einschränken.  Die dazu nötigen
	Einstellungen werden in <filename>/etc/opieaccess</filename>
	vorgenommen, die bei der Installation des Systems automatisch
	erzeugt wird.  Weitere Informationen über diese Datei und
	Sicherheitshinweise zu ihrer Verwendung finden Sie in
	&man.opieaccess.5;.</para>

      <para><filename>opieaccess</filename> könnte
	beispielsweise die folgende Zeile enthalten:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>Diese Zeile erlaubt es Benutzern, die sich von einer der
	angegebenen <acronym>IP</acronym>-Adressen anmelden, ihr
	&unix;-Passwort zu verwenden.  Beachten Sie bitte, dass eine
	<acronym>IP</acronym>-Adresse leicht gefälscht werden
	kann.</para>

      <para>Findet sich in <filename>opieaccess</filename> kein
	passender Eintrag, muss die Anmeldung mit
	<acronym>OPIE</acronym> erfolgen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="tcpwrappers">
    <info><title>TCP-Wrapper</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>TCP-Wrapper</primary>
    </indexterm>

    <para><acronym>TCP</acronym>-Wrapper erweitern die Fähigkeiten von
      <xref linkend="network-inetd"/>.  Beispielsweise können
      Verbindungen protokolliert, Nachrichten zurückgesandt oder nur
      interne Verbindungen angenommen werden.  Einige dieser
      Fähigkeiten können auch über eine Firewall implementiert werden,
      <acronym>TCP</acronym>-Wrapper fügen jedoch noch eine weitere
      Sicherheitsschicht und Kontrollmöglichkeiten hinzu, die eine
      Firewall nicht bieten kann.</para>

    <para><acronym>TCP</acronym>-Wrapper sollten nicht als Ersatz für
      eine ordentlich konfigurierte Firewall angesehen werden, sondern
      stattdessen in Verbindung mit einer Firewall und anderen
      Sicherheitsmechanismen eingesetzt werden.</para>

    <sect2>
      <title>TCP-Wrapper einrichten</title>

      <para>Um <acronym>TCP</acronym>-Wrapper unter &os; zu benutzen,
	muss der &man.inetd.8;-Server aus <filename>rc.conf</filename>
	mit den Optionen <option>-Ww</option> gestartet werden.
	Anschließend muss <filename>/etc/hosts.allow</filename>
	richtig konfiguriert werden.</para>

      <note>
        <para>Im Gegensatz zu anderen Implementierungen der
          <acronym>TCP</acronym>-Wrapper wird vom Gebrauch
          der Datei <filename>hosts.deny</filename> abgeraten.
          Die Konfiguration sollte sich vollständig in der
          Datei <filename>/etc/hosts.allow</filename> befinden.</para>
      </note>

      <para>In der einfachsten Konfiguration werden Dienste
        abhängig vom Inhalt der Datei
        <filename>/etc/hosts.allow</filename> erlaubt oder
        gesperrt.  Unter &os; wird in der Voreinstellung
        jeder von &man.inetd.8; gestartete Dienst
        erlaubt.</para>

      <para>Eine Konfigurationszeile ist wie folgt aufgebaut:
        <literal>Dienst : Adresse : Aktion</literal>.
        <literal>Dienst</literal> ist der von &man.inetd.8;
        gestartete Dienst (auch Daemon genannt).  Die
        <literal>Adresse</literal> ist ein gültiger
        Rechnername, eine <acronym>IP</acronym>-Adresse oder
        eine <acronym>IPv6</acronym>-Adresse in Klammern
        (<literal>[</literal>&nbsp;<literal>]</literal>).
        Der Wert <literal>allow</literal> im Feld
        <literal>Aktion</literal> erlaubt Zugriffe, der Wert
        <literal>deny</literal> verbietet Zugriffe.
        Die Zeilen in <filename>hosts.allow</filename>
        werden für jede Verbindung der Reihe nach
        abgearbeitet.  Trifft eine Zeile auf eine Verbindung
        zu, wird die entsprechende Aktion ausgeführt
        und die Abarbeitung ist beendet.</para>

      <para>Um beispielsweise einkommende
	<acronym>POP</acronym>3-Verbindungen für den Dienst
	<package>mail/qpopper</package> zu erlauben, sollte
	<filename>hosts.allow</filename> um die nachstehende Zeile
	erweitert werden:</para>

      <programlisting># This line is required for POP3 connections:
qpopper : ALL : allow</programlisting>

      <para>Nachdem Sie die Zeile hinzugefügt haben, muss
	&man.inetd.8; neu gestartet werden:</para>

      <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
    </sect2>

    <sect2>
      <title>Erweiterte Konfiguration</title>

      <para><acronym>TCP</acronym>-Wrapper besitzen
	weitere Optionen, die bestimmen, wie Verbindungen
	behandelt werden.  In einigen Fällen ist es
	gut, wenn bestimmten Rechnern oder Diensten eine
	Nachricht geschickt wird.  In anderen Fällen
	soll vielleicht der Verbindungsaufbau protokolliert
	oder eine E-Mail an einen Administrator versandt
	werden. Oder ein Dienst soll nur für das
	lokale Netz bereitstehen.  Dies alles ist mit so genannten
	Wildcards, Metazeichen und der Ausführung externer
	Programme möglich.</para>

      <sect3>
	<title>Externe Kommandos</title>

	<para>Stellen Sie sich vor, eine Verbindung soll
	  verhindert werden und gleichzeitig soll demjenigen,
	  der die Verbindung aufgebaut hat, eine Nachricht
	  geschickt werden.  Solch eine Aktion ist mit
	  <option>twist</option> möglich.  <option>twist</option>
	  führt beim Verbindungsaufbau ein Kommando oder ein Skript
	  aus.  Ein Beispiel ist in <filename>hosts.allow</filename>
	  enthalten:</para>

	<programlisting># Alle anderen Dienste sind geschützt
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

	<para>Für jeden Dienst, der nicht vorher in
	  <filename>hosts.allow</filename> konfiguriert wurde, wird
	  die Meldung <quote>You are not allowed to use
	    <literal>daemon</literal> from
	    <literal>hostname</literal>.</quote> zurückgegeben.
	  Dies ist nützlich, wenn die Gegenstelle sofort
	  benachrichtigt werden soll, nachdem die Verbindung getrennt
	  wurde.  Der Text der Meldung <emphasis>muss</emphasis> in
	  Anführungszeichen (<literal>"</literal>) stehen.</para>

	<warning>
	  <para>Ein so konfigurierter Server ist anfällig
	    für Denial-of-Service-Angriffe.  Ein Angreifer
	    kann die gesperrten Dienste mit Verbindungsanfragen
	    überfluten.</para>
	</warning>

	<para>Eine weitere Möglichkeit bietet <option>spawn</option>.
	  Wie <option>twist</option> verbietet <option>spawn</option>
	  die Verbindung und führt externe Kommandos aus.  Allerdings
	  sendet <option>spawn</option> der Gegenstelle keine
	  Rückmeldung.  Sehen Sie sich die nachstehende
	  Konfigurationsdatei an:</para>

	<programlisting># Verbindungen von example.com sind gesperrt:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</programlisting>

	<para>Damit sind Verbindungen von der Domain
	  <systemitem class="fqdomainname">*.example.com</systemitem> gesperrt.
	  Jeder Verbindungsaufbau wird zudem in
	  <filename>/var/log/connections.log</filename>
	  protokolliert.  Das Protokoll enthält den
	  Rechnernamen, die <acronym>IP</acronym>-Adresse
	  und den Dienst, der angesprochen wurde.</para>

	<para>In diesem Beispiel wurden die Metazeichen
	  <literal>%a</literal> und <literal>%h</literal> verwendet.
	  Eine vollständige Liste der Metazeichen finden Sie in
	  &man.hosts.access.5;.</para>
      </sect3>

      <sect3>
	<title>Wildcards</title>

	<para>Die Wildcard <literal>ALL</literal> passt auf jeden
	  Dienst, jede Domain oder jede <acronym>IP</acronym>-Adresse.
	  Eine andere Wildcard ist <literal>PARANOID</literal>.  Sie
	  passt auf jeden Rechner, dessen
	  <acronym>IP</acronym>-Adresse möglicherweise gefälscht ist.
	  Dies ist beispielsweise der Fall, wenn der Verbindungsaufbau
	  von einer <acronym>IP</acronym>-Adresse erfolgt, die nicht
	  zu dem übermittelten Rechnernamen passt.  In diesem Beispiel
	  werden alle Verbindungsanfragen zu &man.sendmail.8;
	  abgelehnt, wenn die <acronym>IP</acronym>-Adresse nicht zum
	  Rechnernamen passt:</para>

	<programlisting># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</programlisting>

	<caution>
	  <para>Die Wildcard <literal>PARANOID</literal>
	    kann einen Dienst unbrauchbar machen, wenn der
	    Client oder der Server eine fehlerhafte
	    <acronym>DNS</acronym>-Konfiguration besitzt.
	    Seien Sie daher besonders vorsichtig, wenn Sie diese Wildcard
	    in Ihre Konfiguration aufnehmen wollen.</para>
	</caution>

	<para>Weitere Informationen über Wildcards und deren Funktion
	  finden Sie in &man.hosts.access.5;.</para>

	<para>Damit die gezeigten Beispiele funktionieren, muss die
	  erste Konfigurationszeile in
	  <filename>hosts.allow</filename> auskommentiert
	  werden.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="kerberos5">
    <info><title><application>Kerberos5</application></title>
      <authorgroup>
	<author><personname><firstname>Tillman</firstname><surname>Hodgson</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Mark</firstname><surname>Murray</surname></personname><contrib>Beruht auf einem Beitrag von </contrib></author>
      </authorgroup>
    </info>

    

    <para><application>Kerberos</application> ist ein Netzwerk-Protokoll,
      das Benutzer mithilfe eines sicheren Servers authentifiziert.
      Die Daten einer Kommunikation können verschlüsselt werden,
      nachdem die Kommunikationspartner mit
      <application>Kerberos</application> ihre Identität geprüft
      haben.</para>

    <para><application>Kerberos</application> hat nur eine Aufgabe:
      Die sichere Prüfung der Identität eines Benutzers
      (Authentifizierung) über das Netzwerk.  Das System
      überprüft weder die Berechtigungen der Benutzer
      (Autorisierung), noch verfolgt es die durchgeführten
      Aktionen (Audit).  Daher sollte
      <application>Kerberos</application> zusammen mit anderen
      Sicherheits-Systemen eingesetzt werden, die diese Funktionen
      bereitstellen.</para>

    <para>Die folgenden Anweisungen beschreiben, wie Sie das mit
      &os; gelieferte <application>Kerberos</application> einrichten.
      Eine vollständige Beschreibung des Systems entnehmen Sie den
      entsprechenden Hilfeseiten.</para>

    <para>Die Beschreibung der
      <application>Kerberos</application>-Installation benutzt
      folgende Namensräume:</para>

    <itemizedlist>
      <listitem>
	<para>Die <acronym>DNS</acronym>-Domain (<quote>Zone</quote>)
	  heißt <systemitem
	    class="fqdomainname">example.org</systemitem>.</para>
      </listitem>

      <listitem>
	<para>Das <application>Kerberos</application>-Realm
	  heißt <literal>EXAMPLE.ORG</literal>.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Benutzen Sie echte Domain-Namen, wenn Sie
	<application>Kerberos</application> einrichten.  Damit
	vermeiden Sie <acronym>DNS</acronym>-Probleme und stellen
	die Zusammenarbeit mit anderen
	<application>Kerberos</application>-Realms sicher.</para>
    </note>

    <sect2>
      <title>Geschichte</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Geschichte</secondary>
      </indexterm>

      <para>Das <acronym>MIT</acronym> hat
	<application>Kerberos</application> entwickelt, um
	Sicherheitsprobleme auf dem Netzwerk zu lösen.  Das
	<application>Kerberos</application>-Protokoll verwendet
	starke Kryptographie, sodass ein Server die Identität
	eines Clients (der umgekehrte Vorgang ist auch möglich)
	über ein unsicheres Netzwerk feststellen kann.</para>

      <para>Der Begriff Kerberos wird sowohl für das Protokoll
	als auch für Programme verwendet, die
	<application>Kerberos</application> benutzen, wie
	<application>Kerberos</application>-Telnet.  Die aktuelle
	Protokollversion ist 5 und wird in
	<acronym>RFC</acronym>&nbsp;1510 beschrieben.</para>

      <para>Mehrere Implementierungen des Protokolls stehen frei
	zur Verfügung und decken viele Betriebssysteme ab.
	Das Massachusetts Institute of Technology
	(<acronym>MIT</acronym>), an dem <application>Kerberos</application>
	ursprünglich entwickelt wurde, entwickelt seine
	<application>Kerberos</application>-Version weiter.  In den
	<acronym>USA</acronym> wird diese Version häufig
	eingesetzt, unterlag aber Export-Beschränkungen,
	da sie in den <acronym>USA</acronym> entwickelt wurde.
	Die <acronym>MIT</acronym>-Version von
	<application>Kerberos</application> ist als Port oder Paket
	<package>security/krb5</package> verfügbar.
	Heimdal ist eine weitere Implementierung der Protokollversion 5.
	Sie wurde außerhalb der <acronym>USA</acronym> entwickelt
	und unterliegt daher keinen Export-Beschränkungen.
	Heimdal-<application>Kerberos</application> befindet sich
	im Port oder Paket <package>security/heimdal</package>
	und das Basissystem von &os; enthält eine minimale
	Installation von Heimdal.</para>

      <para>Die folgenden Beispiele verwenden die in &os; enthaltene
	Heimdal-Distribution.</para>
    </sect2>

    <sect2>
      <title>Das Heimdal <acronym>KDC</acronym> einrichten</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Key Distribution Center</secondary>
      </indexterm>

      <para><application>Kerberos</application> authentifiziert
	Benutzer an einer zentralen Stelle: dem Key Distribution
	Center (<acronym>KDC</acronym>).  Das <acronym>KDC</acronym>
	verteilt <firstterm>Tickets</firstterm>, mit denen ein
	Dienst die Identität eines Benutzers feststellen kann.
	Alle Mitglieder eines <application>Kerberos</application>-Realms
	vertrauen dem <acronym>KDC</acronym>, daher gelten für
	das <acronym>KDC</acronym> erhöhte
	Sicherheitsanforderungen.</para>

      <para>Obwohl der <application>Kerberos</application>-Server
	wenig Ressourcen benötigt, sollte das <acronym>KDC</acronym>
	wegen der Sicherheitsanforderungen auf einem separaten Rechner
	installiert werden.</para>

      <para>Das <acronym>KDC</acronym> wird in
        <filename>/etc/rc.conf</filename> wie folgt aktiviert:</para>

      <programlisting>kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

      <para>Danach wird <filename>/etc/krb5.conf</filename>
	wie folgt bearbeitet:</para>

      <programlisting>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
	admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</programlisting>

      <para>Diese Einstellungen setzen voraus, dass der voll
	qualifizierte Name des <acronym>KDC</acronym>s
	<systemitem
	  class="fqdomainname">kerberos.example.org</systemitem> ist.
	Wenn das <acronym>KDC</acronym> einen anderen Namen hat,
	muss in der <acronym>DNS</acronym>-Zone ein Alias-Eintrag
	(CNAME-Record) für das <acronym>KDC</acronym> hinzugefügt
	werden.</para>

      <note>
	<para>In großen Netzwerken mit einem ordentlich
	  konfigurierten <acronym>DNS</acronym>-Server kann die Datei
	  aus dem obigen Beispiel verkürzt werden:</para>

        <programlisting>[libdefaults]
      default_realm = EXAMPLE.ORG</programlisting>

	<para>Die Zonendatei von <systemitem class="fqdomainname">example.org</systemitem>
	  muss dann die folgenden Zeilen enthalten:</para>

	<programlisting>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</programlisting>
      </note>

      <note>
	<para>Damit die Clients die
	  <application>Kerberos</application>-Dienste benutzen
	  können, muss <filename>/etc/krb5.conf</filename>
	  entweder die vollständige Konfiguration enthalten
	  oder eine minimale Konfiguration enthalten
	  <emphasis>und</emphasis> zusätzlich ein
	  <acronym>DNS</acronym>-Server richtig eingerichtet
	  sein.</para>
      </note>

      <para>Im nächsten Schritt wird die
        <application>Kerberos</application>-Datenbank eingerichtet.
	Die Datenbank enthält die Schlüssel aller Prinzipale
	und ist mit einem Passwort geschützt.  Dieses Passwort
	brauchen Sie sich nicht merken, da ein davon abgeleiteter
	Schlüssel in <filename>/var/heimdal/m-key</filename>
	gespeichert wird.  Um den Schlüssel zu erstellen, rufen Sie
	&man.kstash.8; auf und geben Sie ein Passwort ein.</para>

      <para>Nachdem der Schlüssel erstellt wurde, sollte die
	Datenbank initialisiert werden.  Das
	<application>Kerberos</application>-Werkzeug &man.kadmin.8;
	kann mit <command>kadmin -l</command> im lokalen Modus benutzt
	werden, ohne den Netzwerkdienst, welcher zu diesem Zeitpunkt
	noch nicht läuft, zu verwenden.  An der Eingabeaufforderung
	von &man.kadmin.8; kann mit <command>init</command>
	die Datenbank des Realms initialisiert werden.</para>

      <para>Zuletzt wird mit <command>add</command> das erste
	Prinzipal erstellt.  Benutzen Sie die voreingestellten
	Optionen.  Die Einstellungen können später
	<command>modify</command> verändert werden.  An der
	Eingabeaufforderung von &man.kadmin.8; zeigt
	<command>?</command> Hilfetexte an.</para>

      <para>Zusammengefasst wird die Datenbank wie folgt
	eingerichtet:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
Master key: <userinput>xxxxxxxx</userinput>
Verifying password - Master key: <userinput>xxxxxxxx</userinput>

&prompt.root; <userinput>kadmin -l</userinput>
kadmin&gt; <userinput>init EXAMPLE.ORG</userinput>
Realm max ticket life [unlimited]:
kadmin&gt; <userinput>add tillman</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: <userinput>xxxxxxxx</userinput>
Verifying password - Password: <userinput>xxxxxxxx</userinput></screen>

      <para>Jetzt kann das <acronym>KDC</acronym> gestartet werden.
	Führen Sie zum Start der Dienste
	<command>service kerberos start</command> und
	<command>service kadmind start</command> aus.  Obwohl
	zu diesem Zeitpunkt noch keine kerberisierten Dienste
	laufen, kann die Funktion des <acronym>KDC</acronym>s
	schon überprüft werden.  Für den eben angelegten
	Benutzer können Sie sich vom <acronym>KDC</acronym>
	Tickets holen und anzeigen lassen:</para>

      <screen>&prompt.user; <userinput>kinit tillman</userinput>
tillman@EXAMPLE.ORG's Password:

&prompt.user; <userinput>klist</userinput>
Credentials cache: FILE: <filename>/tmp/krb5cc_500</filename>
        Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</screen>

      <para>Nachdem der Test abgeschlossen ist, kann das temporäre
	Ticket zurückgezogen werden:</para>

      <screen>&prompt.user; <userinput>kdestroy</userinput></screen>
    </sect2>

    <sect2>
      <title>Heimdal <application>Kerberos</application>-Dienste
	einrichten</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Dienste einrichten</secondary>
      </indexterm>

      <para>Bei der Konfiguration eines Servers für die
	<application>Kerberos</application>-Authentifizierung muss
	zuerst sichergestellt werden, dass
	<filename>/etc/krb5.conf</filename> richtig konfiguriert ist.
	Die Datei kann entweder vom <acronym>KDC</acronym> kopiert,
	oder auf dem neuen System regeneriert werden.</para>

      <para>Als nächstes muss auf dem Server die
	<filename>/etc/krb5.keytab</filename> erzeugt werden.  Dies
	ist der Hauptbestandteil um Dienste zu
	<quote>kerberisieren</quote> und entspricht der Erzeugung
	eines geheimen Schlüssels zwischen dem Dienst und dem
	<application>KDC</application>.  Das Geheimnis ist ein
	kryptographischer Schlüssel, der in einem
	<filename>keytab</filename>> abgelegt wird.  Diese Datei
	enthält den Schlüssel des Servers, mit dem sich der Server und
	das <acronym>KDC</acronym> gegenseitig authentifizieren
	können.  Sie muss in einer sicheren Art und Weise an den
	Server übertragen werden, da ansonsten die Sicherheit des
	Servers gefährdet ist, wenn z.B. die Schlüssel öffentlich
	werden.  In der Regel wird die <filename>keytab</filename> auf
	einem vertrauenswürdigen Rechner mit <command>kadmin</command>
	erzeugt und anschließend sicher auf den Server übertragen,
	beispielsweise mit &man.scp.1;.  Wenn die
	Sicherheitsrichtlinien es erlauben, kann die Datei auch direkt
	auf dem Server erzeugt werden.  Es ist sehr wichtig, dass die
	<filename>keytab</filename> auf sichere Weise auf den Server
	übertragen wird.  Wenn der Schlüssel einer anderen Partei
	bekannt wird, kann sich diese Partei den Benutzern als
	Server ausgeben!  Da der Eintrag für das Host-Prinzipal für
	die <acronym>KDC</acronym>-Datenbank auch mit
	<command>kadmin</command> erstellt wird, ist es praktisch,
	<command>kadmin</command> direkt auf dem Server zu
	benutzen.</para>

      <para>Natürlich ist auch <command>kadmin</command> ein
	kerberisierter Dienst: ein
	<application>Kerberos</application>-Ticket ist erforderlich,
	um sich gegenüber dem Netzwerkdienst zu authentifizieren und
	um sicherzustellen, dass der Benutzer, der
	<command>kadmin</command> ausführt, tatsächlich vorhanden ist.
	<command>kadmin</command> wird nach dem Passwort fragen, um
	ein neues Ticket zu generieren.  Das Prinzipal, das sich mit
	dem kadmin-Dienst authentifiziert, muss über die
	Zugriffskontrollliste <filename>kadmin.acl</filename> dazu
	berechtigt sein.  Weitere Informationen über
	Zugriffskontrolllisten finden Sie in den Heimdal-Info-Seiten
	(<command>info heimdal</command>) im Abschnitt
	<quote>Remote administration</quote>.  Wenn der Zugriff auf
	<command>kadmin</command> von entfernten Rechnern verboten
	ist, kann sich der Administrator entweder über die lokale
	Konsole oder über &man.ssh.1; mit dem <acronym>KDC</acronym>
	verbinden, um die lokale Administration mit
	<command>kadmin -l</command> durchzuführen.</para>

      <para>Nach der Installation von
	<filename>/etc/krb5.conf</filename>, können Sie das Kommando
	<command>add --random-key</command> in
	<command>kadmin</command> ausführen, um das Host-Prinzipal in
	die Datenbank zu schreiben.  Das Kommando
	<command>ext</command> extrahiert den Schlüssel des Prinzipals
	in eine eigene keytab:</para>

      <screen>&prompt.root; <userinput>kadmin</userinput>
kadmin&gt; <userinput>add --random-key host/myserver.example.org</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin&gt; <userinput>ext host/myserver.example.org</userinput>
kadmin&gt; <userinput>exit</userinput></screen>

      <para>Beachten Sie, dass <command>ext</command> den
	extrahierten Schlüssel standardmäßig in
	<filename>/etc/krb5.keytab</filename> speichert.  Das ist
	gut, wenn das Kommando auf dem kerberisierten Server
	ausgeführt wird, ansonsten sollte das Argument
	<command>--keytab
	  <replaceable>pfad/zur/datei</replaceable></command>
	benutzt werden, wenn die keytab an einen anderen Ort
	extrahiert wird:</para>

      <screen>&prompt.root; <userinput>kadmin</userinput>
kadmin&gt; <userinput>ext --keytab=/tmp/example.keytab <replaceable>host/myserver.example.org</replaceable></userinput>
kadmin&gt; <userinput>exit</userinput></screen>

      <para>Anschließend kann die erzeugte keytab sicher mit
	<command>scp</command> auf Server oder auf einen
	Wechseldatenträger kopiert werden.  Geben Sie auf jeden Fall
	einen anderen Namen für die keytab an, weil sonst die keytab
	des <acronym>KDC</acronym>s überschrieben würde.</para>

      <para>Wegen der Datei <filename>krb5.conf</filename> kann
	der Server nun mit dem <acronym>KDC</acronym> kommunizieren
	und seine Identität mithilfe der Datei
	<filename>krb5.keytab</filename> nachweisen.  Jetzt
	können die kerberisierten Dienste aktiviert werden.  Einer der
	gebräuchlichsten Dienste ist &man.sshd.8;, der
	<application>Kerberos</application> über
	<acronym>GSS-API</acronym> unterstützt.  Fügen Sie folgende
	Zeile in <filename>/etc/ssh/sshd_config</filename> ein:</para>

      <programlisting>GSSAPIAuthentication yes</programlisting>

      <para>Nach dieser Änderung muss &man.sshd.8; mit
	<command>service sshd restart</command> neu gestartet werden,
	damit die neue Konfiguration wirksam wird.</para>
    </sect2>

    <sect2>
      <title>Heimdal <application>Kerberos</application>-Clients
	einrichten</title>

      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Clients einrichten</secondary>
      </indexterm>

      <para>Genau wie der Server, benötigt auch der Client eine
	Konfiguration in <filename>/etc/krb5.conf</filename>.
	Kopien Sie die Datei (sicher) vom <acronym>KDC</acronym>
	auf den Client, oder schreiben Sie die Datei bei Bedarf
	einfach neu.  Testen Sie den Client, indem Sie mit
	<command>kinit</command> Tickets anfordern, mit
	<command>klist</command> Tickets anzeigen und mit
	<command>kdestroy</command> Tickets löschen.
	<application>Kerberos</application>-Anwendungen sollten auch
	kerberisierte Server ansprechen können.  Wenn das nicht
	funktioniert, Sie aber Tickets anfordern können, hat
	wahrscheinlich der kerberisierte Server ein Problem und nicht
	der Client oder das <acronym>KDC</acronym>.  Im Falle eines
	kerberisierten &man.ssh.1; ist <acronym>GSS-API</acronym> in
	der Voreinstellung deaktiviert.  Testen Sie daher mit
	<command>ssh -o GSSAPIAuthentication=yes
	  <replaceable>hostname</replaceable></command>.</para>

      <para>Wenn Sie die kerberisierten Anwendungen testen, können Sie
	einen Paket-Sniffer wie <command>tcpdump</command> benutzen,
	um sicherzustellen, dass keine sensiblen Informationen im
	Klartext übertragen werden.</para>

      <para>Es stehen verschiedene
	<application>Kerberos</application>-Anwendungen zur Verfügung.
	Die Anwendungen, die <acronym>SASL</acronym> benutzen, können
	dann auch <acronym>GSS-API</acronym> benutzen.  Viele Arten
	von Anwendungen können <application>Kerberos</application> zur
	Authentifizierung verwenden, vom Jabber-Client bis zum
	<acronym>IMAP</acronym>-Client.</para>

      <indexterm>
	<primary><filename>.k5login</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>.k5users</filename></primary>
      </indexterm>

      <para>Normalerweise wird ein
	<application>Kerberos</application>-Prinzipal auf ein lokales
	Benutzerkonto abgebildet.  Manchmal wird aber Zugriff auf ein
	lokales Benutzerkonto benötigt, zu dem es keinen passenden
	<application>Kerberos</application>-Prinzipal gibt.
	Der Prinzipal <systemitem
	  class="username">tillman@EXAMPLE.ORG</systemitem> bräuchte
	beispielsweise Zugriff auf das Konto <systemitem
	  class="username">webdevelopers</systemitem>.  Ebenso könnten
	andere Prinzipale auf dieses Konto zugreifen wollen.</para>

      <para>Die Dateien <filename>.k5login</filename> und
	<filename>.k5users</filename> im Heimatverzeichnis eines
	Benutzers können verwendet werden, um dieses Problem zu lösen.
	Mit der folgenden <filename>.k5login</filename> im
	Heimatverzeichnis des Benutzers <systemitem
	  class="username">webdevelopers</systemitem> haben beide
	Prinzipale auch ohne das gemeinsame Passwort Zugriff auf das
	Konto:</para>
	
      <programlisting>tillmann@example.org
jdoe@example.org</programlisting>

      <para>Weitere Informationen zu <filename>.k5users</filename>
	finden Sie in &man.ksu.1;.</para>
    </sect2>

    <sect2>
      <title>Tipps und Fehlersuche</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Fehlersuche</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>Wenn Sie den Heimdal-Port oder den
	    <acronym>MIT</acronym>-Port benutzen, muss in der
	    Umgebungsvariable <envar>PATH</envar> der Pfad zu
	    den <application>Kerberos</application>-Programmen vor dem
	    Pfad zu den Programmen des Systems stehen.</para>
	</listitem>

	<listitem>
	  <para>Wenn die Clients im Realm ihre Uhrzeit nicht
	    synchronisieren, schlägt vielleicht die Authentifizierung
	    fehl.  <xref linkend="network-ntp"/> beschreibt, wie
	    Sie mithilfe von <acronym>NTP</acronym> die Uhrzeiten
	    synchronisieren.</para>
	</listitem>

	<listitem>
	  <para>Die <acronym>MIT</acronym>- und Heimdal-Systeme
	    arbeiten bis auf <command>kadmin</command>, welches nicht
	    standardisiert ist, gut zusammen.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie den Namen eines Rechners ändern,
	    müssen Sie auch den <systemitem
	      class="username">host/</systemitem>-Prinzipal ändern und
	    die <filename>keytab</filename> aktualisieren.  Dies
	    betrifft auch spezielle Einträge wie den Prinzipal für
	    Apaches <package>www/mod_auth_kerb</package>.</para>
	</listitem>

	<listitem>
	  <para>Alle Rechner in einem Realm müssen vor- und
	    rückwärts aufgelöst werden können.  Entweder über
	    <acronym>DNS</acronym>, zumindest aber über
	    <filename>/etc/hosts</filename>.
	    <acronym>CNAME</acronym>-Einträge im
	    <acronym>DNS</acronym> funktionieren, aber die
	    entsprechenden A- und PTR-Einträge müssen
	    vorhanden und richtig sein.  Wenn sich Namen nicht
	    auflösen lassen, ist die Fehlermeldung nicht
	    gerade selbstsprechend: <errorname>Kerberos5 refuses
	      authentication because Read req
	      failed: Key table entry not found</errorname>.</para>
	</listitem>

	<listitem>
	  <para>Einige Betriebssysteme installieren
	    <command>ksu</command> mit falschen Zugriffsrechten;
	    es fehlt das Set-UID-Bit für <systemitem
	      class="username">root</systemitem>.  Das hat zur Folge,
	    dass <command>ksu</command> nicht funktioniert.  Dies ist
	    ein Fehler in den Zugriffsrechten und kein Fehler des
	    <acronym>KDC</acronym>s.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie für einen Prinzipal unter
	    <acronym>MIT</acronym>-<application>Kerberos</application>
	    Tickets mit einer längeren Gültigkeit als
	    der vorgegebenen zehn Stunden einrichten wollen,
	    müssen Sie zwei Sachen ändern.  Benutzen
	    Sie das <command>modify_principal</command> von
	    <command>kadmin</command>, um die maximale
	    Gültigkeitsdauer für den Prinzipal selbst
	    und den Prinzipal <systemitem
	      class="username">krbtgt</systemitem>
	    zu erhöhen.  Das Prinzipal kann dann mit
	    <command>kinit -l</command> ein Ticket mit einer
	    längeren Gültigkeit beantragen.</para>
	</listitem>

	<listitem>
	  <para>Mit einem Packet-Sniffer können Sie feststellen,
	    dass Sie sofort nach dem Aufruf von <command>kinit</command>
	    eine Antwort vom <acronym>KDC</acronym>
	    bekommen &ndash; noch bevor Sie überhaupt ein
	    Passwort eingegeben haben!  Das ist in Ordnung:
	    Das <acronym>KDC</acronym> händigt
	    ein Ticket-Granting-Ticket (<acronym>TGT</acronym>)
	    auf Anfrage aus, da es durch einen vom Passwort
	    des Benutzers abgeleiteten Schlüssel
	    geschützt ist.  Wenn das Passwort
	    eingegeben wird, wird es nicht zum <acronym>KDC</acronym>
	    gesendet, sondern zum Entschlüsseln der
	    Antwort des <acronym>KDC</acronym>s benutzt, die
	    <command>kinit</command> schon erhalten hat.
	    Wird die Antwort erfolgreich entschlüsselt,
	    erhält der Benutzer einen Sitzungs-Schlüssel
	    für die künftige verschlüsselte
	    Kommunikation mit dem <acronym>KDC</acronym> und das
	    <acronym>TGT</acronym>.  Das <acronym>TGT</acronym>
	    wiederum ist mit dem Schlüssel des <acronym>KDC</acronym>s
	    verschlüsselt.  Diese Verschlüsselung ist
	    für den Benutzer völlig transparent und
	    erlaubt dem <acronym>KDC</acronym>,
	    die Echtheit jedes einzelnen <acronym>TGT</acronym>
	    zu prüfen.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie <application>OpenSSH</application> verwenden
	    und Tickets mir einer langen Gültigkeit
	    (beispielsweise einer Woche) benutzen, setzen Sie
	    <option>TicketCleanup</option> in
	    <filename>sshd_config</filename> auf <literal>no</literal>.
	    Ansonsten werden die Tickets gelöscht, wenn Sie
	    sich abmelden.</para>
	</listitem>

	<listitem>
	  <para>Host-Prinzipale können Tickets mit
	    längerer Gültigkeit besitzen.  Wenn der
	    Prinzipal eines Benutzers über ein Ticket verfügt,
	    das eine Woche gültig ist, das Ticket des
	    Host-Prinzipals aber nur neun Stunden gültig ist,
	    funktioniert der Ticket-Cache nicht wie erwartet.
	    Im Cache befindet sich dann ein abgelaufenes Ticket
	    des Host-Prinzipals.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie mit <filename>krb5.dict</filename> die
	    Verwendung schlechter Passwörter verhindern wollen, wie
	    in &man.kadmin.8; beschrieben, geht das nur mit
	    Prinzipalen, denen eine Passwort-Policy zugewiesen wurde.
	    Das Format von <filename>krb5.dict</filename> enthält pro
	    Zeile ein Wort.   Sie können daher einen symbolischen Link
	    auf <filename>/usr/share/dict/words</filename>
	    erstellen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Unterschiede zum <acronym>MIT</acronym>-Port</title>

      <para>Der Hauptunterschied zwischen
	<acronym>MIT</acronym>-<application>Kerberos</application>
	und Heimdal-<application>Kerberos</application>
	ist das Kommando <command>kadmin</command>.
	Die Befehlssätze des Kommandos (obwohl funktional
	gleichwertig) und das verwendete
	Protokoll unterscheiden sich in beiden Varianten.
	Das <acronym>KDC</acronym> lässt sich nur mit
	dem <command>kadmin</command> Kommando der passenden
	<application>Kerberos</application>-Variante verwalten.</para>

      <para>Für dieselbe Funktion können auch die
	Client-Anwendungen leicht geänderte Kommandozeilenoptionen
	besitzen.  Folgen Sie bitte der Anleitung auf der
	<application>Kerberos</application>-Seite
	<uri xlink:href="http://web.mit.edu/Kerberos/www/">http://web.mit.edu/Kerberos/www/</uri>
	des <acronym>MIT</acronym>s.  Achten Sie besonders auf den
	Suchpfad für Anwendungen.  Der <acronym>MIT</acronym>-Port
	wird standardmäßig in
	<filename>/usr/local/</filename>
	installiert.  Wenn die Umgebungsvariable <envar>PATH</envar>
	zuerst die Systemverzeichnisse enthält, werden die
	Systemprogramme anstelle der <acronym>MIT</acronym>-Programme
	ausgeführt.</para>

      <note>
	<para>Wenn Sie den <acronym>MIT</acronym>-Port
	  <package>security/krb5</package> verwenden,
	  erscheint bei der Anmeldung mit <command>telnetd</command>
	  und <command>klogind</command> die Fehlermeldung
	  <errorname>incorrect permissions on cache file</errorname>.
	  Lesen Sie dazu die im Port enthaltene Datei
	  <filename>/usr/local/share/doc/krb5/README.FreeBSD</filename>.
	  Wichtig ist, dass zur Authentifizierung die Binärdatei
	  <command>login.krb5</command> verwendet wird, die
	  für durchgereichte Berechtigungen die Eigentümer
	  korrekt ändert.</para>
      </note>

      <para>Wird
	<acronym>MIT</acronym>-<application>Kerberos</application> auf
	&os; eingesetzt, sollten in <filename>rc.conf</filename>
	folgende Zeilen aufgenommen werden:</para>

      <programlisting>kerberos5_server="/usr/local/sbin/krb5kdc"
kadmind5_server="/usr/local/sbin/kadmind"
kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

      <para>Diese Zeilen sind notwendig, weil die Anwendungen
	von <acronym>MIT</acronym>-<acronym>Kerberos</acronym> die
	Binärdateien unterhalb von <filename>/usr/local</filename>
	installieren.</para>
    </sect2>

    <sect2>
      <title>Beschränkungen von
	<application>Kerberos</application></title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Beschränkungen</secondary>
      </indexterm>

      <sect3>
	<title><application>Kerberos</application> muss ganzheitlich
	  verwendet werden</title>

	<para>Jeder über das Netzwerk angebotene Dienst
	  muss mit <application>Kerberos</application>
	  zusammenarbeiten oder auf anderen Wegen gegen Angriffe
	  aus dem Netzwerk geschützt sein.  Andernfalls
	  können Berechtigungen gestohlen und wiederverwendet
	  werden.  Es ist beispielsweise nicht sinnvoll, für
	  Remote-Shells<application>Kerberos</application>
	  zu benutzen, dagegen aber <acronym>POP3</acronym>-Zugriff
	  auf einen Mail-Server zu erlauben, da
	  <acronym>POP3</acronym>-Passwörter im Klartext
	  versendet.</para>
      </sect3>

      <sect3>
	<title><application>Kerberos</application> ist für
	  Einbenutzer-Systeme gedacht</title>

	<para>In Mehrbenutzer-Umgebungen ist
	  <application>Kerberos</application> unsicherer als in
	  Einbenutzer-Umgebungen, da die Tickets im für alle
	  lesbaren Verzeichnis <filename>/tmp</filename>
	  gespeichert werden.  Wenn ein Rechner von mehreren
	  Benutzern verwendet wird, ist es möglich, dass
	  Tickets von einem anderen Benutzer gestohlen oder
	  kopiert werden.</para>

	<para>Dieses Problem können Sie lösen, indem Sie mit
	  der Kommandozeilenoption <option>-c</option> oder besser
	  mit der Umgebungsvariablen <envar>KRB5CCNAME</envar> einen
	  Ort für die Tickets vorgeben.  Es reicht, die Tickets
	  im Heimatverzeichnis eines Benutzers zu speichern und
	  mit Zugriffsrechten zu schützen.</para>
      </sect3>

      <sect3>
	<title>Das <acronym>KDC</acronym> ist verwundbar</title>

	<para>Das <acronym>KDC</acronym> muss genauso abgesichert
	  werden wie die auf ihm befindliche Passwort-Datenbank.
	  Auf dem <acronym>KDC</acronym> sollten absolut keine anderen
	  Dienste laufen und der Rechner sollte physikalisch
	  gesichert sein.  Die Gefahr ist groß, da
	  <application>Kerberos</application> alle Passwörter
	  mit einem Schlüssel, dem Haupt-Schlüssel,
	  verschlüsselt.  Der Haupt-Schlüssel wiederum
	  wird in einer Datei auf dem <acronym>KDC</acronym>
	  gespeichert.</para>

	<para>Ein kompromittierter Haupt-Schlüssel ist nicht
	  ganz so schlimm wie allgemein angenommen.  Der
	  Haupt-Schlüssel wird nur zum Verschlüsseln
	  der Passwort-Datenbank und zum Initialisieren des
	  Zufallsgenerators verwendet.  Solange der Zugriff
	  auf das <acronym>KDC</acronym> abgesichert ist, kann
	  ein Angreifer wenig mit dem Haupt-Schlüssel
	  anfangen.</para>

	<para>Wenn das <acronym>KDC</acronym> nicht zur Verfügung
	  steht, sind auch die Netzwerkdienste nicht benutzbar, da
	  eine Authentifizierung nicht durchgeführt werden kann.
	  Das <acronym>KDC</acronym> ist also ein optimales Ziel für
	  einen Denial-of-Service Angriff.  Sie können diesem Angriff
	  entgegenwirken, indem Sie einen
	  <acronym>KDC</acronym>-Master und einen oder mehrere Slaves
	  verwenden.  Der Rückfall auf ein sekundäres
	  <acronym>KDC</acronym> mittels
	  <acronym>PAM</acronym>-Authentifizierung muss sorgfältig
	  eingerichtet werden.</para>
      </sect3>

      <sect3>
	<title>Mängel von
	  <application>Kerberos</application></title>

	<para>Mit <application>Kerberos</application> können
	  sich Benutzer, Rechner und Dienste gegenseitig
	  authentifizieren.  Allerdings existiert kein Mechanismus,
	  der das <acronym>KDC</acronym> gegenüber Benutzern,
	  Rechnern oder Diensten authentifiziert.  Ein verändertes
	  &man.kinit.1; könnte beispielsweise alle
	  Benutzernamen und Passwörter abfangen.  Die von
	  veränderten Programmen ausgehende Gefahr können
	  Sie lindern, indem Sie die Integrität von Dateien
	  mit Werkzeugen wie
	  <package>security/tripwire</package>
	  prüfen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Weiterführende Dokumentation</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>weiterführende Dokumentation</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para><link xlink:href="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">The
            Kerberos FAQ</link></para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://web.mit.edu/Kerberos/www/dialogue.html">Designing
	    an Authentication System: a Dialogue in Four
	    Scenes</link></para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510,
	    The <application>Kerberos</application> Network
	    Authentication Service (V5)</link></para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://web.mit.edu/Kerberos/www/"><acronym>MIT</acronym>
	    <application>Kerberos</application>-Seite</link></para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://www.pdc.kth.se/heimdal/">Heimdal
	    <application>Kerberos</application>-Seite</link></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="openssl">
    <info><title>OpenSSL</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>
    <indexterm><primary>OpenSSL</primary></indexterm>

    <para><application>OpenSSL</application> ist eine freie
      Implementierung der <acronym>SSL</acronym> und
      <acronym>TLS</acronym>-Protokolle.  Es bietet eine
      verschlüsselte Transportschicht oberhalb der
      normalen Kommunikationsschicht und kann daher zusammen
      mit vielen Netzdiensten benutzt werden.</para>

    <para>Anwendungsbeispiele für <application>OpenSSL</application>
      sind die verschlüsselte Authentifizierung von
      E-Mail-Clients oder Web-Transaktionen wie das Bezahlen mit
      einer Kreditkarte.  <application>OpenSSL</application>
      kann während des Baus in viele Ports, wie
      <package>www/apache22</package> und
      <package>mail/claws-mail</package>,
      integriert werden.</para>

    <note>
      <para>Ist beim Aufruf von <command>make</command> die
	Variable <varname>WITH_OPENSSL_BASE</varname> nicht
	explizit auf <literal>yes</literal> gesetzt, baut
	die Ports-Sammlung meist den Port
	<package>security/openssl</package>.</para>
    </note>

    <para>Das in &os; integrierte <application>OpenSSL</application>
      stellt die Protokolle Secure Sockets Layer v2/v3 (SSLv2/SSLv3)
      und Transport Layer Security v1 (TLSv1) zur Verfügung.
      Die <application>OpenSSL</application>-Bibliotheken stellen
      kryptographische Funktionen bereit.</para>

    <note>
      <para>Mit <application>OpenSSL</application> kann der
	<acronym>IDEA</acronym>-Algorithmus verwendet werden,
	wegen Patenten in den USA ist der Algorithmus in der
	Voreinstellung allerdings deaktiviert.  Wenn Sie die
	<acronym>IDEA</acronym>-Lizenz akzeptieren, können
	Sie den <acronym>IDEA</acronym>-Algorithmus aktivieren,
	indem Sie die Variable <varname>MAKE_IDEA</varname>
	in <filename>/etc/make.conf</filename> setzen.</para>
    </note>

    <para>Meist wird <application>OpenSSL</application> eingesetzt,
      um Zertifikate für Anwendungen bereitzustellen.  Die
      Zertifikate stellen die Identität einer Firma oder
      eines Einzelnen sicher.  Wenn ein Zertifikat nicht von
      einer Zertifizierungsstelle (<foreignphrase>Certificate
        Authority</foreignphrase>, <acronym>CA</acronym>)
      gegengezeichnet wurde, erhalten Sie normalerweise eine
      Warnung.  Eine Zertifizierungsstelle ist eine Firma
      wie <link xlink:href="http://www.verisign.com/">VeriSign</link>,
      die Zertifikate von Personen oder Firmen
      gegenzeichnet und damit die Korrektheit der Zertifikate
      bestätigt.  Diese Prozedur kostet Geld, ist aber
      keine Voraussetzung für den Einsatz von Zertifikaten,
      beruhigt aber sicherheitsbewusste Benutzer.</para>

    <sect2>
      <title>Zertifikate erzeugen</title>

      <indexterm>
	<primary>OpenSSL</primary>
	<secondary>Zertifikate erzeugen</secondary>
      </indexterm>

      <para>Ein Zertifikat erzeugen Sie mit dem nachstehenden
	Kommando:</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.pem</userinput>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (eg, YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:<userinput><replaceable>Another Name</replaceable></userinput></screen>

      <para>Beachten Sie, dass die Eingabe bei
	<quote>Common Name</quote> ein gültiger Domain-Name
	sein muss.  Eine andere Eingabe erzeugt ein unbrauchbares
	Zertifikat.  Das Zertifikat kann mit einer
	Gültigkeitsdauer und anderen
	Verschlüsselungsalgorithmen erzeugt werden.
	&man.openssl.1; beschreibt die zur
	Verfügung stehenden Optionen.</para>

      <para>Das Verzeichnis, in dem Sie den letzten Befehl ausgeführt
	haben, enthält nun zwei Dateien:  Die Anforderung für
	ein neues Zertifikat wurde in <filename>req.pem</filename>
	gespeichert.  Diese Datei können Sie an eine
	<acronym>CA</acronym> senden, wo die Angaben geprüft werden.
	Nach erfolgreicher Prüfung wird das Zertifikat unterschrieben
	und an Sie zurückgesandt.  Die zweite Datei, <filename>cert.pem</filename>,
	enthält den privaten Schlüssel für das Zertifikat
	und darf auch keine Fall in fremde Hände geraten, da ein
	Angreifer sonst in der Lage ist, anderen Personen oder Rechnern
	vorzugaukeln, dass es sich bei ihm um Sie handelt.</para>

      <para>Wenn Sie keine Signatur einer Zertifizierungsstelle
	benötigen, können Sie ein selbst-signiertes
	Zertifikat erstellen.  Erzeugen Sie dazu zuerst einen
	<acronym>RSA</acronym>-Schlüssel:</para>

      <screen>&prompt.root; <userinput>openssl dsaparam -rand -genkey -out myRSA.key 1024</userinput></screen>

      <para>Erzeugen Sie dann den <acronym>CA</acronym>-Schlüssel:</para>

      <screen>&prompt.root; <userinput>openssl gendsa -des3 -out myca.key myRSA.key</userinput></screen>

      <para>Erstellen Sie mit diesem Schlüssel das
        Zertifikat:</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key myca.key -out new.crt</userinput></screen>

      <para>Zwei neue Dateien befinden sich nun im Verzeichnis:
	Der Schlüssel der Zertifizierungsstelle
	<filename>myca.key</filename> und das Zertifikat selbst,
	<filename>new.crt</filename>.  Sie sollten in einem
	Verzeichnis, vorzugsweise unterhalb von
	<filename>/etc/ssl</filename> abgelegt
	werden, das nur von <systemitem class="username">root</systemitem> lesbar
	ist.  Die Zugriffsrechte der Dateien können mit &man.chmod.1;
	auf <literal>0700</literal> gesetzt werden.</para>
    </sect2>

    <sect2>
      <title>Zertifikate benutzen</title>

      <para>Mit einem Zertifikat können beispielsweise die
	Verbindungen zu <application>Sendmail</application>
	verschlüsselt werden, um eine Klartext-Authentifizierung
	zu verhindern.</para>

      <note>
	<para>Einige E-Mail-Programme geben Warnungen aus, wenn ein
	  Zertifikat nicht lokal installiert ist.  Weitere
	  Informationen zur Installation von Zertifikaten finden Sie
	  in der Dokumentation der entsprechenden Software.</para>
      </note>

      <para>Ergänzen Sie die Konfigurationsdatei von
	<application>Sendmail</application> (<filename>.mc</filename>)
	um die nachstehenden Zeilen:</para>

      <programlisting>dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl</programlisting>

      <para>Im Verzeichnis <filename>/etc/certs</filename> befindet
	sich der Schlüssel und das Zertifikat.  Bauen Sie danach im
	Verzeichnis <filename>/etc/mail</filename>
	mit dem Kommando <command>make install</command> die
	<filename>.cf</filename>-Datei.  Starten Sie anschließend
	<application>Sendmail</application> mit
	<command>make restart</command> neu.</para>

      <para>Wenn alles gut ging, erscheinen keine Fehlermeldungen
	in <filename>/var/log/maillog</filename> und
	Sie sehen <application>Sendmail</application> in der
	Prozessliste.</para>

      <para>Testen Sie nun den Mailserver mit &man.telnet.1;:</para>

      <screen>&prompt.root; <userinput>telnet example.com 25</userinput>
Trying 192.0.34.166...
Connected to <systemitem class="fqdomainname">example.com</systemitem>.
Escape character is '^]'.
220 <systemitem class="fqdomainname">example.com</systemitem> ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
<userinput>ehlo example.com</userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 <systemitem class="fqdomainname">example.com</systemitem> closing connection
Connection closed by foreign host.</screen>

      <para>Wenn die Zeile <literal>STARTTLS</literal>
	erscheint, hat alles funktioniert.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="ipsec">
    <info><title><acronym>VPN</acronym> mit IPsec</title>
      <authorgroup>
        <author><personname><firstname>Nik</firstname><surname>Clayton</surname></personname><affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
          </affiliation><contrib>Geschrieben von </contrib></author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>IPsec</primary>
    </indexterm>

    <sect2>
      <info><title>IPsec Grundlagen</title>
        <authorgroup>
          <author><personname><firstname>Hiten M.</firstname><surname>Pandya</surname></personname><affiliation>
	      <address><email>hmp@FreeBSD.org</email></address>
	    </affiliation><contrib>Geschrieben von </contrib></author>
	</authorgroup>
      </info>

      <para>Dieser Abschnitt beschreibt die Einrichtung von IPsec.  Um
	IPsec einzurichten, sollten Sie einen neuen Kernel bauen können (siehe
	<xref linkend="kernelconfig"/>).</para>

      <para><emphasis>IPsec</emphasis> ist ein Protokoll, das auf dem
	Internet-Protokoll (<acronym>IP</acronym>) aufbaut.  Mit IPsec
	können mehrere Systeme geschützt miteinander kommunizieren.  Das in
	&os; realisierte IPsec-Protokoll baut auf der <link xlink:href="http://www.kame.net/">KAME-Implementierung</link>
	auf und unterstützt sowohl IPv4 als auch IPv6.</para>

      <indexterm>
	<primary>IPsec</primary>
	<secondary>ESP</secondary>
      </indexterm>

      <indexterm>
	<primary>IPsec</primary>
	<secondary>AH</secondary>
      </indexterm>

      <para>IPsec besteht wiederum aus zwei Protokollen:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Encapsulated Security Payload
	      (<acronym>ESP</acronym>)</emphasis> verschlüsselt
	    IP-Pakete mit einem symmetrischen Verfahren wie Blowfish
	    oder 3DES.  Damit werden die Pakete vor Manipulationen
	    Dritter geschützt.</para>
        </listitem>

        <listitem>
          <para>Der <emphasis>Authentication Header
	      (<acronym>AH</acronym>)</emphasis> enthält eine
	    kryptographische Prüfsumme, die sicher stellt, dass ein
	    IP-Paket nicht verändert wurde.  Der Authentication-Header
	    folgt nach dem normalen IP-Header und erlaubt dem Empfänger
	    eines IP-Paketes, dessen Integrität zu
	    prüfen.</para>
        </listitem>
      </itemizedlist>

      <para><acronym>ESP</acronym> und <acronym>AH</acronym>
	können, je nach Situation, zusammen oder einzeln
	verwendet werden.</para>

      <indexterm>
        <primary>VPN</primary>
      </indexterm>

      <indexterm>
        <primary>Virtual Private Network</primary>
        <see>VPN</see>
      </indexterm>

      <para>IPsec kann in zwei Modi betrieben werden:  Der
	<firstterm>Transport-Modus</firstterm> verschlüsselt
	die Daten zwischen zwei Systemen.  Der
	<firstterm>Tunnel-Modus</firstterm> verbindet zwei
	Subnetze miteinander.  Durch einen Tunnel können
	dann beispielsweise verschlüsselte Daten übertragen
	werden.  Ein Tunnel wird auch als
	<foreignphrase>Virtual-Private-Network</foreignphrase>
	(<acronym>VPN</acronym>) bezeichnet.  Detaillierte
	Informationen über das IPsec-Subsystem von &os; finden Sie in
	&man.ipsec.4;.</para>

      <para>Die folgenden Optionen in der Kernelkonfiguration
	aktivieren IPsec:</para>

      <indexterm>
        <primary>Kerneloption</primary>
        <secondary>IPSEC</secondary>
      </indexterm>

      <screen>options   IPSEC        #IP security
device    crypto</screen>

      <indexterm>
        <primary>Kerneloption</primary>
        <secondary>IPSEC_DEBUG</secondary>
      </indexterm>

      <para>Wenn Sie zur Fehlersuche im IPsec-Subsystem
	Unterstützung wünschen, sollten Sie die
	folgende Option ebenfalls aktivieren:</para>

      <screen>options   IPSEC_DEBUG  #debug for IP security</screen>
    </sect2>

    <sect2>
      <title>VPN zwischen einem Heim- und Firmennetzwerk
	einrichten</title>

      <indexterm>
        <primary>VPN</primary>
        <secondary>einrichten</secondary>
      </indexterm>

      <para>Es gibt keinen Standard, der festlegt, was ein
	Virtual-Private-Network ist.  VPNs können mit
	verschiedenen Techniken, die jeweils eigene Vor- und
	Nachteile besitzen, implementiert werden.
	Dieser Abschnitt stellt Möglichkeiten vor, um ein VPN
	für das folgende Szenario aufzubauen:</para>

      <itemizedlist>
        <listitem>
	  <para>Es müssen mindestens zwei Netzwerke vorhanden sein,
	    welche intern IP benutzen.</para>
        </listitem>

        <listitem>
	  <para>Beide Netzwerke sind über ein &os;-Gateway
	    mit dem Internet verbunden.</para>
        </listitem>

        <listitem>
	  <para>Der Gateway jedes Netzwerks besitzt mindestens
	    eine öffentliche IP-Adresse.</para>
        </listitem>

        <listitem>
          <para>Die intern verwendeten IP-Adressen können
	    private oder öffentliche Adressen sein.
	    Sie dürfen sich jedoch nicht überlappen.  Zum Beispiel
	    sollten nicht beide Netze <systemitem
	      class="ipaddress">192.168.1.x</systemitem>
	    benutzen.</para>
        </listitem>
      </itemizedlist>

    <sect3>
      <info><title>Konfiguration von IPsec in &os;</title>
        <authorgroup>
          <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><affiliation>
              <address><email>trhodes@FreeBSD.org</email></address>
            </affiliation><contrib>Geschrieben von </contrib></author>
        </authorgroup>
      </info>


      <para>Als erstes muss <package>security/ipsec-tools</package>
	aus der Ports-Sammlung installiert werden.  Diese Software
	enthält einige Anwendungen, die bei der Konfiguration von
	IPsec hilfreich sind.</para>

      <para>Als nächstes müssen zwei &man.gif.4;-Pseudogeräte
        angelegt werden, um die Pakete zu tunneln und dafür zu sorgen,
        dass beide Netzwerke richtig miteinander kommunizieren können.
        Geben Sie als <systemitem class="username">root</systemitem>
	die folgenden Befehle ein, wobei Sie
	<replaceable>intern</replaceable> und
	<replaceable>extern</replaceable> durch die realen internen
	und externen <acronym>IP</acronym>-Adressen der Gateways
	ersetzen müssen:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput></screen>
      <screen>&prompt.root; <userinput>ifconfig gif0 <replaceable>intern1 intern2</replaceable></userinput></screen>
      <screen>&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>extern1 extern2</replaceable></userinput></screen>

      <para>In diesem Beispiel ist die externe
	<acronym>IP</acronym>-Adresse des Firmennetzwerkes
	(<acronym>LAN</acronym>) <systemitem
	  class="ipaddress">172.16.5.4</systemitem> und die interne
        <acronym>IP</acronym>-Adresse ist <systemitem
	  class="ipaddress">10.246.38.1</systemitem>.  Das
	Heimnetzwerk (<acronym>LAN</acronym>) hat die externe
	<acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">192.168.1.12</systemitem> mit der internen
        privaten <acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">10.0.0.5</systemitem>.</para>

      <para>Wenn dies verwirrend erscheint, schauen Sie sich die
	folgende Ausgabe von &man.ifconfig.8;an:</para>

      <programlisting>Gateway 1:

gif0: flags=8051 mtu 1280
tunnel inet 172.16.5.4 --&gt; 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
inet 10.246.38.1 --&gt; 10.0.0.5 netmask 0xffffff00

Gateway 2:

gif0: flags=8051 mtu 1280
tunnel inet 192.168.1.12 --&gt; 172.16.5.4
inet 10.0.0.5 --&gt; 10.246.38.1 netmask 0xffffff00
inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4</programlisting>

      <para>Wenn Sie fertig sind, sollten beide internen Adressen über
	&man.ping.8; erreichbar sein:</para>

      <programlisting>priv-net# ping 10.0.0.5
PING 10.0.0.5 (10.0.0.5): 56 data bytes
64 bytes from 10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms
64 bytes from 10.0.0.5: icmp_seq=1 ttl=64 time=19.255 ms
64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms
--- 10.0.0.5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms

corp-net# ping 10.246.38.1
PING 10.246.38.1 (10.246.38.1): 56 data bytes
64 bytes from 10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms
64 bytes from 10.246.38.1: icmp_seq=1 ttl=64 time=42.917 ms
64 bytes from 10.246.38.1: icmp_seq=2 ttl=64 time=127.525 ms
64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms
64 bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms
--- 10.246.38.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms</programlisting>

      <para>Wie erwartet, können nun beiden Seiten
        <acronym>ICMP</acronym>-Pakete von ihren privaten Adressen
	senden und empfangen.  Als nächstes müssen beide
	Gateways so konfiguriert werden, dass sie die Pakete des anderen
	Netzwerkes richtig routen.  Mit dem folgenden Befehl
	erreicht man das Ziel:</para>

      <screen>&prompt.root; <userinput>corp-net# route add 10.0.0.0 10.0.0.5 255.255.255.0</userinput></screen>
      <screen>&prompt.root; <userinput>corp-net# route add net 10.0.0.0: gateway 10.0.0.5</userinput></screen>

      <screen>&prompt.root; <userinput>priv-net# route add 10.246.38.0 10.246.38.1 255.255.255.0</userinput></screen>
      <screen>&prompt.root; <userinput>priv-net# route add host 10.246.38.0: gateway 10.246.38.1</userinput></screen>

      <para>Ab jetzt sollten die Rechner von den Gateways sowie von
	den Rechnern hinter den Gateways erreichbar sein.  Dies können
	Sie wieder mit &man.ping.8; überprüfen:</para>

      <programlisting>corp-net# ping 10.0.0.8
PING 10.0.0.8 (10.0.0.8): 56 data bytes
64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
--- 10.0.0.8 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

priv-net# ping 10.246.38.107
PING 10.246.38.1 (10.246.38.107): 56 data bytes
64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
--- 10.246.38.107 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms</programlisting>

      <para>Das Konfigurieren der Tunnel ist der einfache Teil.  Die
	Konfiguration einer sicheren Verbindung geht viel mehr in
	die Tiefe.  Die folgende Konfiguration benutzt pre-shared
	(<acronym>PSK</acronym>) <acronym>RSA</acronym>-Schlüssel.
	Abgesehen von den <acronym>IP</acronym>-Adressen, sind beide
	<filename>/usr/local/etc/racoon/racoon.conf</filename>
	identisch und sehen ähnlich aus:</para>

      <programlisting>path    pre_shared_key  "/usr/local/etc/racoon/psk.txt"; #location of pre-shared key file
log     debug;  #log verbosity setting: set to 'notify' when testing and debugging is complete

padding # options are not to be changed
{
        maximum_length  20;
        randomize       off;
        strict_check    off;
        exclusive_tail  off;
}

timer   # timing options. change as needed
{
        counter         5;
        interval        20 sec;
        persend         1;
#       natt_keepalive  15 sec;
        phase1          30 sec;
        phase2          15 sec;
}

listen  # address [port] that racoon will listening on
{
        isakmp          172.16.5.4 [500];
        isakmp_natt     172.16.5.4 [4500];
}

remote  192.168.1.12 [500]
{
        exchange_mode   main,aggressive;
        doi             ipsec_doi;
        situation       identity_only;
        my_identifier   address 172.16.5.4;
        peers_identifier        address 192.168.1.12;
        lifetime        time 8 hour;
        passive         off;
        proposal_check  obey;
#       nat_traversal   off;
        generate_policy off;

                        proposal {
                                encryption_algorithm    blowfish;
                                hash_algorithm          md5;
                                authentication_method   pre_shared_key;
                                lifetime time           30 sec;
                                dh_group                1;
                        }
}

sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)    # address $network/$netmask $type address $network/$netmask $type ( $type being any or esp)
{                                                               # $network must be the two internal networks you are joining.
        pfs_group       1;
        lifetime        time    36000 sec;
        encryption_algorithm    blowfish,3des,des;
        authentication_algorithm        hmac_md5,hmac_sha1;
        compression_algorithm   deflate;
}</programlisting>

      <para>Eine Beschreibung der verfügbaren Optionen finden Sie in
	der Manualpage von <filename>racoon.conf</filename>.</para>

      <para>Die
	<foreignphrase>Security Policy Database</foreignphrase>
	(<acronym>SPD</acronym>) muss noch konfiguriert werden, so
	dass &os; und <application>racoon</application> in der
	Lage sind den Netzwerkverkehr zwischen den Hosts zu ver-
	und entschlüsseln.</para>

      <para>Dies wird durch ein Shellskript ähnlich wie das
	folgende, das auf dem Firmennetzwerk-Gateway liegt,
	ausgeführt.  Diese Datei wird während der
	Systeminitialisierung ausgeführt und sollte unter
	<filename>/usr/local/etc/racoon/setkey.conf</filename>
	gespeichert werden.</para>

<programlisting>flush;
spdflush;

# To the home network
spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
spdadd 10.0.0.0/24 10.246.38.0/24 any -P in ipsec esp/tunnel/192.168.1.12-172.16.5.4/use;</programlisting>

      <para>Einmal abgespeichert, kann <application>racoon</application>
	durch das folgende Kommando auf beiden Gateways gestartet
	werden:</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log</userinput></screen>

      <para>Die Ausgabe sollte so ähnlich aussehen:</para>

      <programlisting>corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
Foreground mode.
2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=28496098(0x1b2d0e2)
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=47784998(0x2d92426)
2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=124397467(0x76a279b)
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=175852902(0xa7b4d66)</programlisting>

      <para>Um sicherzustellen, dass der Tunnel richtig funktioniert,
	wechseln Sie auf eine andere Konsole und benutzen Sie
	&man.tcpdump.1; mit dem folgenden Befehl, um sich den
	Netzwerkverkehr anzusehen.  Tauschen Sie
	<literal>em0</literal> durch die richtige Netzwerkkarte
	aus:</para>

      <screen>&prompt.root; <userinput>tcpdump -i em0 host <replaceable>172.16.5.4 and dst 192.168.1.12</replaceable></userinput></screen>

      <para>Die Ausgabe der Konsole sollte dem hier ähneln.  Wenn
	nicht, gibt es ein Problem und ein Debuggen der ausgegebenen
	Daten ist notwendig.</para>

      <programlisting>01:47:32.021683 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
01:47:33.022442 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
01:47:34.024218 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)</programlisting>

      <para>An diesem Punkt sollten beide Netzwerke verfügbar sein und
	den Anschein haben, dass sie zum selben Netzwerk gehören.
	Meistens sind beide Netzwerke durch eine Firewall geschützt.
	Um den Netzwerkverkehr zwischen den beiden Netzwerken zu erlauben,
	ist es notwendig Regeln zu erstellen.  Für die &man.ipfw.8;
	Firewall fügen Sie folgende Zeilen in die
	Firewall-Konfigurationsdatei ein:</para>

      <programlisting>ipfw add 00201 allow log esp from any to any
ipfw add 00202 allow log ah from any to any
ipfw add 00203 allow log ipencap from any to any
ipfw add 00204 allow log udp from any 500 to any</programlisting>

      <note>
        <para>Die Regelnummern müssen eventuell, je nach ihrer
          Hostkonfiguration, angepasst werden.</para>
      </note>

      <para>Für Benutzer der &man.pf.4;- oder &man.ipf.8;-Firewall
	sollte folgendes funktionieren:</para>

      <programlisting>pass in quick proto esp from any to any
pass in quick proto ah from any to any
pass in quick proto ipencap from any to any
pass in quick proto udp from any port = 500 to any port = 500
pass in quick on gif0 from any to any
pass out quick proto esp from any to any
pass out quick proto ah from any to any
pass out quick proto ipencap from any to any
pass out quick proto udp from any port = 500 to any port = 500
pass out quick on gif0 from any to any</programlisting>

      <para>Zum Ende, um dem Computer den Start vom
	<acronym>VPN</acronym> während der Systeminitialisierung
	zu erlauben, fügen Sie folgende Zeilen in ihre
	<filename>/etc/rc.conf</filename>: ein</para>

      <programlisting>ipsec_enable="YES"
ipsec_program="/usr/local/sbin/setkey"
ipsec_file="/usr/local/etc/racoon/setkey.conf" # allows setting up spd policies on boot
racoon_enable="yes"</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="openssh">
    <info><title>OpenSSH</title>
      <authorgroup>
	<author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>Beigetragen von </contrib></author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </info>

    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> stellt Werkzeuge bereit,
      um sicher auf entfernte Maschinen zuzugreifen.  Zusätzlich
      können TCP/IP-Verbindungen sicher durch <acronym>SSH</acronym>
      weitergeleitet (getunnelt) werden.  Mit <acronym>SSH</acronym>
      werden alle Verbindungen verschlüsselt, dadurch wird verhindert,
      dass die Verbindung zum Beispiel abgehört oder übernommen
      (<foreignphrase>Hijacking</foreignphrase>) werden kann.</para>

    <para><application>OpenSSH</application> wird vom OpenBSD-Projekt
      gepflegt und wird in der Voreinstellung von &os; installiert.
      <application>OpenSSH</application> ist mit den
      <acronym>SSH</acronym>-Protokollen der Versionen 1 und 2
      kompatibel.</para>

    <sect2>
      <title>Vorteile von <application>OpenSSH</application></title>

      <para>Wenn Daten unverschlüsselt über das Netzwerk gesendet
	werden,  besteht die Gefahr, das Benutzer/Passwort
	Kombinationen oder alle Daten an beliebiger Stelle zwischen
	dem Client und dem Server abgehört werden.  Mit
	<application>OpenSSH</application> stehen eine Reihe von
	Authentifizierungs- und Verschlüsselungsmethoden zur
	Verfügung, um das zu verhindern.</para>
    </sect2>

    <sect2>
      <title>Aktivieren von <application>sshd</application></title>

      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>aktivieren</secondary>
      </indexterm>

      <para>Um zu überprüfen, ob &man.sshd.8; auf dem System aktiviert
	ist, suchen Sie in <filename>rc.conf</filename> nach der
	folgenden Zeile:</para>

      <programlisting>sshd_enable="YES"</programlisting>

      <para>Ist diese Zeile vorhanden, wird &man.sshd.8;, der
	<application>OpenSSH</application>-Daemon, beim
	Systemstart automatisch aktiviert.  Alternativ kann
	<application>OpenSSH</application> auch über &man.service.8;
	gestartet werden:</para>

      <screen>&prompt.root; <userinput>service sshd start</userinput></screen>
    </sect2>

    <sect2>
      <title>SSH Client</title>

      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Client</secondary>
      </indexterm>

      <para>Benutzen Sie &man.ssh.1; um sich mit einem System zu
	verbinden, auf dem &man.sshd.8; läuft.  Verwenden Sie dazu
	den Benutzernamen und den Namen des Rechners, mit dem Sie
	sich verbinden möchten:</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para><acronym>SSH</acronym> speichert einen Fingerabdruck des
	Serverschlüssels.  Die Aufforderung, <literal>yes</literal>
	einzugeben, erscheint nur bei der ersten Verbindung zu einem
	Server.  Weitere Verbindungen zu dem Server werden gegen den
	gespeicherten Fingerabdruck des Schlüssels geprüft und
	der Client gibt eine Warnung aus, wenn sich der empfangene
	Fingerabdruck von dem gespeicherten unterscheidet.  Die
	Fingerabdrücke werden in
	<filename>~/.ssh/known_hosts</filename> gespeichert.</para>

      <para>In der Voreinstellung akzeptieren aktuelle Versionen von
	&man.sshd.8; nur <acronym>SSH</acronym>&nbsp;v2 Verbindungen.
	Wenn möglich, wird der Client versuchen Version&nbsp;2 zu
	verwenden, ist dies nicht möglich, fällt er auf Version&nbsp;1
	zurück.  Der Client kann gezwungen werden, nur eine der beiden
	Versionen zu verwenden, indem die Option <option>-1</option>
	oder <option>-2</option> übergeben wird.  Die Unterstützung
	für Version&nbsp;1 ist nur noch aus Kompatibilitätsgründen zu
	älteren Versionen enthalten.</para>
    </sect2>

    <sect2>
      <title>Secure Copy</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>secure copy</secondary>
      </indexterm>
      <indexterm><primary>&man.scp.1;</primary></indexterm>

      <para>Mit &man.scp.1; lassen sich Dateien in einer sicheren
	Weise auf entfernte Maschinen übertragen.</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@example.com's password:
COPYRIGHT            100% |*****************************|  4735
00:00
&prompt.root;</screen>

      <para>Da der Fingerabdruck schon im vorigen Beispiel abgespeichert
        wurde, wird er bei der Verwendung von <command>scp</command> in
	diesem Beispiel überprüft.  Da die Fingerabdrücke
	übereinstimmen, wird keine Warnung ausgegeben.</para>

      <para>Die Argumente, die &man.scp.1; übergeben werden, gleichen
	denen von &man.cp.1; in der Beziehung, dass die ersten
	Argumente die zu kopierenden Dateien sind und das letzte
	Argument den Bestimmungsort angibt.  Da die Dateien über das
	Netzwerk kopiert werden, können ein oder mehrere Argumente die
	Form <option>user@host:&lt;path_to_remote_file&gt;</option>
	besitzen.</para>
    </sect2>

    <sect2>
      <title>Konfiguration</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Konfiguration</secondary>
      </indexterm>

      <para>Die für das ganze System gültigen Konfigurationsdateien
	des <application>OpenSSH</application>-Daemons und des
	Clients befinden sich in <filename>/etc/ssh</filename>.</para>

      <para>Die Client-Konfiguration befindet sich in
        <filename>ssh_config</filename>, die des Servers befindet sich
	in <filename>sshd_config</filename>.  Für beide Dateien
	existieren Manualpages, welche die einzelnen
	Konfigurationsoptionen beschreiben.</para>
    </sect2>

    <sect2 xml:id="security-ssh-keygen">
      <title>&man.ssh-keygen.1;</title>

      <para>Mit &man.ssh-keygen.1; können <acronym>DSA</acronym>- oder
	<acronym>RSA</acronym>-Schlüssel für einen Benutzer erzeugt
	werden, die anstelle von Passwörtern verwendet werden
	können:</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t <replaceable>dsa</replaceable></userinput>
Generating public/private dsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_dsa):
Created directory '/home/user/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_dsa.
Your public key has been saved in /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com</screen>

      <para>&man.ssh-keygen.1; erzeugt einen öffentlichen und einen
        privaten Schlüssel für die Authentifizierung.  Der private
        Schlüssel wird in <filename>~/.ssh/id_dsa</filename> oder
        <filename>~/.ssh/id_rsa</filename> gespeichert, während
        sich der öffentliche Schlüssel in
        <filename>~/.ssh/id_dsa.pub</filename> oder
        <filename>~/.ssh/id_rsa.pub</filename> befindet, je nachdem,
        ob es sich um einen <acronym>DSA</acronym>- oder einen
        <acronym>RSA</acronym>-Schlüssel handelt.
        Der öffentliche Schlüssel muss sowohl für
	<acronym>RSA</acronym>- als auch für
	<acronym>DSA</acronym>-Schlüssel in die Datei
        <filename>~/.ssh/authorized_keys</filename> auf dem entfernten
        Rechner aufgenommen werden, damit der Schlüssel
        funktioniert.</para>

      <para>Damit werden Verbindungen zu der entfernten Maschine über
	<acronym>SSH</acronym>-Schlüsseln anstelle von Passwörtern
	authentifiziert.</para>

      <warning>
	<para>Viele Benutzer denken, dass die Verwendung von
	  Schlüsseln generell sicher ist.  Sie verwenden dann einen
	  Schlüssel ohne eine Passphrase.  Dies ist jedoch sehr
	  <emphasis>gefährlich</emphasis>.  Ein Administrator kann
	  überprüfen, ob ein Schlüsselpaar mit einer Passphrase
	  geschützt ist.  Wenn die Datei mit dem privaten Schlüssel
	  den Text <literal>ENCRYPTED</literal> enthält, dann hat
	  der Benutzer eine Passphrase verwendet.  Um die Benutzer
	  zusätzlich zu schützen, kann ein
	  <literal>from</literal>-Feld in der Datei des öffentlichen
	  Schlüssels hinzugefügt werden.  Zum Beispiel würde das
	  Hinzufügen von <literal>from="192.168.10.5"</literal> vor
	  dem <literal>ssh-rsa</literal>- oder
	  <literal>ssh-dsa</literal>-Präfix dafür sorgen, dass sich
	  ein bestimmter Benutzer nur noch von dieser
	  <acronym>IP</acronym>-Adresse anmelden darf.</para>
      </warning>

      <para>Wenn bei der Erstellung der Schlüssel mit
	&man.ssh-keygen.1; eine Passphrase angegeben wurde, wird der
	Benutzer bei jeder Anmeldung zur Eingabe des Passworts
	aufgefordert.  Um den Umgang mit
	<acronym>SSH</acronym>-Schlüsseln zu erleichtern, kann
	&man.ssh-agent.1; die Verwaltung dieser Schlüssel für Sie
	übernehmen.  Lesen Sie dazu den <xref
	  linkend="security-ssh-agent"/>.</para>

      <warning>
	<para>Die Optionen und Dateinamen sind
	  abhängig von der <application>OpenSSH</application>-Version.
	  Die für das System gültigen Optionen finden Sie in
	  &man.ssh-keygen.1;.</para>
      </warning>
    </sect2>

    <sect2 xml:id="security-ssh-agent">
      <title>Verwendung von SSH-Agent</title>

      <para>Mit &man.ssh-agent.1; und &man.ssh-add.1; ist es
        möglich, <application>SSH</application>-Schlüssel
        in den Speicher zu laden, damit die Passphrase nicht jedes Mal
        eingegeben werden muss.</para>

      <para>&man.ssh-agent.1; übernimmt die Authentifizierung
        von ihm geladener privater Schlüssel.
        &man.ssh-agent.1; sollte nur dazu verwendet werden, ein
        anderes Programm zu starten, beispielsweise eine Shell oder
        einen Window-Manager.</para>

      <para>Um &man.ssh-agent.1; in einer Shell zu verwenden, muss
	es mit einer Shell als Argument aufgerufen werden.  Zudem muss
	die zu verwaltende Identität mit &man.ssh-add.1; sowie deren
	Passphrase für den privaten Schlüssel übergeben werden.
	Nachdem dies erledigt ist, kann sich ein Benutzer über
	&man.ssh.1; auf jedem Rechner anmelden, der einen
	entsprechenden öffentlichen Schlüssel besitzt.  Dazu ein
        Beispiel:</para>

      <screen>&prompt.user; ssh-agent <replaceable>csh</replaceable>
&prompt.user; ssh-add
Enter passphrase for /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)
&prompt.user;</screen>

      <para>Um &man.ssh-agent.1; unter
	<application>&xorg;</application> zu verwenden, muss
	&man.ssh-agent.1; in <filename>~/.xinitrc</filename>
	aufgenommen werden.  Dadurch können alle unter
	<application>&xorg;</application> gestarteten Programme die
	Dienste von &man.ssh-agent.1; nutzen.
	<filename>~/.xinitrc</filename> könnte etwa so
	aussehen:</para>

      <programlisting>exec ssh-agent <replaceable>startxfce4</replaceable></programlisting>

      <para>Dadurch wird bei jedem Start von
	<application>&xorg;</application> zuerst &man.ssh-agent.1;
	aufgerufen, das wiederum <application>XFCE</application>
	startet.  Nachdem diese Änderung durchgeführt wurde, muss
	<application>&xorg;</application> neu gestartet werden.
	Danach können Sie mit &man.ssh-add.1; die
	<acronym>SSH</acronym>-Schlüssel laden.</para>
    </sect2>

    <sect2 xml:id="security-ssh-tunneling">
      <title><acronym>SSH</acronym>-Tunnel</title>

      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Tunnel</secondary>
      </indexterm>

      <para>Mit <application>OpenSSH</application> ist es möglich,
	einen Tunnel zu erstellen, in dem ein anderes Protokoll
	verschlüsselt übertragen wird.</para>

      <para>Das folgende Kommando erzeugt einen Tunnel für
        &man.telnet.1;:</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

      <para>Dieses Beispiel verwendet die folgenden Optionen:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>

	  <listitem>
	    <para>Zwingt &man.ssh.1; dazu, die Version 2 des
	      Protokolls zu verwenden, um sich mit dem Server zu
	      verbinden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>Zeigt an, dass ein Tunnel erstellt werden soll.
	      Ohne diese Option würde &man.ssh.1; eine normale Sitzung
	      öffnen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Zwingt &man.ssh.1; im Hintergrund zu laufen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Ein lokaler Tunnel wird in der Form
	      <replaceable>localport:remotehost:remoteport</replaceable>
	      angegeben.  Die Verbindung wird dabei von dem lokalen Port
	      <replaceable>localport</replaceable> auf einen entfernten
	      Rechner weitergeleitet.</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>Gibt den Anmeldenamen auf dem entfernten
	      <acronym>SSH</acronym>-Server an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

       <para>Ein <acronym>SSH</acronym>-Tunnel erzeugt einen Socket
	 auf <systemitem>localhost</systemitem> und dem angegebenen
	 Port.  Jede Verbindung, die auf dem angegebenen Socket
	 aufgemacht wird, wird dann auf den spezifizierten entfernten
	 Rechner und Port weitergeleitet.</para>

       <para>Im Beispiel wird der Port <replaceable>5023</replaceable>
	 auf die entfernte Maschine und dort auf
	 <systemitem>localhost</systemitem> Port
	 <replaceable>23</replaceable> weitergeleitet.  Da der Port
	 <replaceable>23</replaceable> für &man.telnet.1; reserviert
	 ist, erzeugt das eine sichere &man.telnet.1;-Verbindung durch
	 einen <acronym>SSH</acronym>-Tunnel.</para>

       <para>Diese Vorgehensweise kann genutzt werden, um jedes
	 unsichere <acronym>TCP</acronym>-Protokoll wie
	 <acronym>SMTP</acronym>, <acronym>POP3</acronym> und
	 <acronym>FTP</acronym> weiterzuleiten.</para>

      <example>
	<title>Mit &man.ssh.1; einen sicheren Tunnel für
	   <acronym>SMTP</acronym> erstellen</title>

	<screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>

	<para>Zusammen mit &man.ssh-keygen.1; und zusätzlichen
	  Benutzer-Accounts können leicht benutzbare SSH-Tunnel
	  aufgebaut werden.  Anstelle von Passwörtern können
	  Schlüssel benutzt werden und jeder Tunnel kann unter einem
	  eigenen Benutzer laufen.</para>
      </example>

      <sect3>
	<title>Praktische Beispiele für
	  <acronym>SSH</acronym>-Tunnel</title>

	<sect4>
	  <title>Sicherer Zugriff auf einen
	    <acronym>POP3</acronym>-Server</title>

	  <para>In diesem Beispiel gibt es einen
	    <acronym>SSH</acronym>-Server, der Verbindungen von außen
	    akzeptiert.  Im selben Netzwerk befindet sich zudem
	    noch ein Mail-Server, der <acronym>POP3</acronym> spricht.
	    Um E-Mails auf sichere Weise abzurufen, bauen Sie eine
	    <acronym>SSH</acronym>-Verbindung zu dem
	    <acronym>SSH</acronym>-Server im Netzwerk auf und tunneln
	    von dort zum Mail-Server weiter.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Wenn Sie den Tunnel eingerichtet haben, konfigurieren
	    Sie den Mail-Client so, dass er <acronym>POP3</acronym>
	    Anfragen zu <systemitem>localhost</systemitem> auf Port
	    2110 sendet.  Diese Verbindung wird dann über den
	    gesicherten Tunnel zu
	    <systemitem>mail.example.com</systemitem>
	    weitergeleitet.</para>
	</sect4>

	<sect4>
	  <title>Umgehen einer strengen Firewall</title>

	  <para>Einige Netzwerkadministratoren stellen sehr
	    drakonische Firewall-Regeln auf, die nicht nur einkommende
	    Verbindungen filtern, sondern auch ausgehende.  Es kann
	    sein, dass Sie externe Maschinen nur über die Ports 22 und
	    80 (<acronym>SSH</acronym> und Web) erreichen.</para>

	  <para>Die Lösung hier ist es, eine
	    <acronym>SSH</acronym>-Verbindung zu einer Maschine
	    außerhalb der Firewall aufzumachen und durch diese zum
	    gewünschten Dienst zu tunneln.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>In diesem Beispiel benutzt ein Ogg Vorbis Client
	    <systemitem>localhost</systemitem> und Port 8888.  Die
	    Verbindung wird dann zu
	    <systemitem>music.example.com</systemitem> Port 8000
	    weitergeleitet.  Die Firewall wurde somit erfolgreich
	    umgangen.</para>
      </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Die Option <varname>AllowUsers</varname></title>

      <para>Es ist in der Regel ein gute Idee, festzulegen, welche
        Benutzer sich von welchem Rechner aus anmelden können.
        Dies lässt sich beispielsweise über die Option
        <literal>AllowUsers</literal> festlegen.  Soll sich etwa
        nur <systemitem class="username">root</systemitem> vom Rechner
	mit der <acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">192.168.1.32</systemitem> aus einwählen
        dürfen, würden Sie folgenden Eintrag in
        <filename>/etc/ssh/sshd_config</filename> aufnehmen:</para>

      <programlisting>AllowUsers root@192.168.1.32</programlisting>

      <para>Damit sich <systemitem class="username">admin</systemitem>
	von jedem Rechner aus anmelden kann, geben Sie nur den
	Benutzernamen an:</para>

      <programlisting>AllowUsers admin</programlisting>

      <para>Sie können auch mehrere Benutzer in einer Zeile
        aufführen:</para>

      <programlisting>AllowUsers root@192.168.1.32 admin</programlisting>

      <note>
        <para>Nur Benutzer, die in dieser Liste aufgeführt ist,
          dürfen sich auf diesem Rechner anmelden.</para>
      </note>

      <para>Nachdem Sie <filename>/etc/ssh/sshd_config</filename>
        angepasst haben, muss &man.sshd.8; seine Konfigurationsdateien
        neu einlesen.  Dazu geben Sie Folgendes ein:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sshd reload</userinput></screen>
    </sect2>

    <sect2>
      <title>Weiterführende Informationen</title>

      <para><link
	xlink:href="http://www.openssh.com/">OpenSSH</link></para>

      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1;
        &man.ssh-agent.1; &man.ssh-add.1; &man.ssh.config.5; für
	Client Optionen.</para>

      <para>&man.sshd.8; &man.sftp-server.8; &man.sshd.config.5; für
	Server Optionen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="fs-acl">
    <info><title>Zugriffskontrolllisten für Dateisysteme</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>


    <indexterm>
      <primary>ACL</primary>
    </indexterm>

    <para><firstterm>Zugriffskontrolllisten</firstterm>
      (<foreignphrase>Access Control Lists</foreignphrase>,
      <acronym>ACL</acronym>) erweitern die normalen Zugriffsrechte
      von &unix; Systemen auf eine kompatible (&posix;.1e) Weise
      und bieten feiner granulierte Sicherheitsmechanismen.</para>

    <para>Der <filename>GENERIC</filename>-Kernel von &os; bietet
      <acronym>ACL</acronym>-Unterstützung für
      <acronym>UFS</acronym>-Dateisysteme.  Benutzer, die es vorziehen
      einen eigenen Kernel zu übersetzen, müssen die folgende Option
      in die Kernelkonfigurationsdatei aufnehmen:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>Das System gibt eine Warnung aus, wenn ein Dateisystem mit
      <acronym>ACL</acronym>s eingehangen werden soll und die
      Unterstützung für <acronym>ACL</acronym>s nicht im Kernel
      aktiviert ist.  Das Dateisystem muss weiterhin erweiterte
      Attribute zur Verfügung stellen, damit <acronym>ACL</acronym>s
      verwendet werden können.  <acronym>UFS2</acronym> stellt diese
      Attribute standardmäßig zur Verfügung.</para>

    <note>
      <para>Die Konfiguration erweiterter Attribute auf
	<acronym>UFS1</acronym> ist mit einem höheren Aufwand als die
	Konfiguration erweiterter Attribute auf
	<acronym>UFS2</acronym> verbunden.  Zugriffskontrolllisten
	sollten daher mit <acronym>UFS2</acronym> verwendet
	werden.</para>
    </note>

    <para>Die Angabe der Option <option>acl</option> in
      <filename>/etc/fstab</filename> aktiviert Zugriffskontrolllisten
      für ein Dateisystem.  Die bevorzugte Möglichkeit ist
      die Verwendung von Zugriffskontrolllisten mit &man.tunefs.8; (Option
      <option>-a</option>), im Superblock des Dateisystems festzuschreiben.
      Diese Möglichkeit hat mehrere Vorteile:</para>

    <itemizedlist>
      <listitem>
	<para>Nochmaliges Einhängen eines Dateisystems (Option
	  <option>-u</option> von &man.mount.8;) verändert den Status
	  der Zugriffskontrolllisten nicht.  Die Verwendung von
	  Zugriffskontrolllisten kann nur durch Abhängen und erneutes
	  Einhängen eines Dateisystems verändert werden.  Das
	  heißt auch, dass Zugriffskontrolllisten nicht
	  nachträglich auf dem Root-Dateisystem aktiviert werden
	  können.</para>
      </listitem>

      <listitem>
	<para>Die Zugriffskontrolllisten auf den Dateisystemen sind,
	  unabhängig von den Optionen in <filename>/etc/fstab</filename>
	  oder Namensänderungen der Geräte, immer aktiv.  Dies
	  verhindert auch, dass Zugriffskontrolllisten aus Versehen
	  auf Dateisystemen ohne Zugriffskontrolllisten aktiviert
	  werden und durch falsche Zugriffsrechte Sicherheitsprobleme
	  entstehen.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Es kann sein, dass sich der Status von Zugriffskontrolllisten
        später durch nochmaliges Einhängen des Dateisystems
	(Option <option>-u</option> von &man.mount.8;) ändern
	lässt.  Die momentane Variante ist aber sicherer, da der
	Status der Zugriffskontrolllisten nicht versehentlich geändert
	werden kann.  Allgemein sollten Zugriffskontrolllisten auf einem
	Dateisystem, auf dem sie einmal verwendet wurden, nicht deaktiviert
	werden, da danach die Zugriffsrechte falsch sein können.
	Werden Zugriffskontrolllisten auf einem solchen Dateisystem wieder
	aktiviert, werden die Zugriffsrechte von Dateien, die sich
	zwischenzeitlich geändert haben, überschrieben, was zu
	erneuten Problemen führt.</para>
    </note>

    <para>Die Zugriffsrechte einer Datei werden durch ein
      <literal>+</literal> (Plus) gekennzeichnet, wenn die Datei durch
      Zugriffskontrolllisten geschützt ist:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>In diesem Beispiel sind die Verzeichnisse
      <filename>directory1</filename>, <filename>directory2</filename>
      und <filename>directory3</filename> durch Zugriffskontrolllisten
      geschützt, wohingegen das Verzeichnis
      <filename>public_html</filename> nicht geschützt ist.</para>

    <sect2>
      <title>Zugriffskontrolllisten benutzen</title>

      <para>Das Werkzeug &man.getfacl.1; zeigt Zugriffskontrolllisten
	an.  Das folgende Kommando zeigt die <acronym>ACL</acronym>s
	auf der Datei <filename>test</filename>:</para>

      <screen>&prompt.user; <userinput>getfacl test</userinput>
	#file:test
	#owner:1001
	#group:1001
	user::rw-
	group::r--
	other::r--</screen>

      <para>Das Werkzeug &man.setfacl.1; ändert oder entfernt
        <acronym>ACL</acronym>s auf Dateien.  Zum Beispiel:</para>

      <screen>&prompt.user; <userinput>setfacl -k test</userinput></screen>

      <para>Die Option <option>-k</option> entfernt alle
	<acronym>ACL</acronym>s einer Datei oder eines Dateisystems.
	Besser wäre es, die Option <option>-b</option>
	zu verwenden, da sie die erforderlichen Felder
	beibehält.</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,g:web:r--,o::--- test</userinput></screen>

      <para>Mit dem vorstehenden Kommando werden die eben
	entfernten Zugriffskontrolllisten wiederhergestellt.
	Der Befehl gibt die Fehlermeldung
	<errorname>Invalid argument</errorname> aus,
	<!-- doch nicht auf <devicename>stdout</devicename> ?? -->
	wenn Sie nicht existierende Benutzer oder Gruppen
	als Parameter angeben.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="security-portaudit">
    <info><title>Sicherheitsprobleme in Software Dritter überwachen</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>portaudit</primary>
    </indexterm>

    <para>In den letzten Jahren wurden zahlreiche Verbesserungen in
      der Einschätzung und dem Umgang mit Sicherheitsproblemen
      erzielt.  Die Gefahr von Einbrüchen in ein System wird
      aber immer größer, da Softwarepakete von Dritten
      auf nahezu jedem Betriebssystem installiert und konfiguriert
      werden.</para>

    <para>Die Einschätzung der Verletzlichkeit eines Systems ist
      ein Schlüsselfaktor für dessen Sicherheit.  &os;
      veröffentlicht zwar Sicherheitshinweise
      (<foreignphrase>security advisories</foreignphrase>) für
      das Basissystem, das Projekt ist allerdings nicht dazu in der
      Lage, dies auch für die zahlreichen Softwarepakete von
      Dritten zu tun.  Dennoch gibt es einen Weg, auch diese
      Programmpakete zu überwachen.  Das in der Ports-Sammlung
      enthaltene Programm <application>portaudit</application> wurde
      gezielt dafür entwickelt.</para>

    <para>Der Port <package>ports-mgmt/portaudit</package>
      fragt dazu eine Datenbank, die vom &os; Security Team sowie
      den Ports-Entwicklern aktualisiert und gewartet wird, auf
      bekannte Sicherheitsprobleme ab.</para>

    <para>Bevor Sie <application>portaudit</application> verwenden
      können, müssen Sie es über die Ports-Sammlung
      installieren:</para>

    <screen>&prompt.root; <userinput>cd /usr/ports/security/portaudit &amp;&amp; make install clean</userinput></screen>

    <para>Während der Installation werden die
      Konfigurationsdateien für &man.periodic.8; aktualisiert, was
      es <application>portaudit</application> erlaubt, seine Ausgabe
      in den täglichen Sicherheitsbericht einzufügen.
      Stellen Sie auf jeden Fall sicher, dass diese (an das
      E-Mail-Konto von <systemitem class="username">root</systemitem> gesendeten)
      Sicherheitsberichte auch gelesen werden.  An dieser Stelle
      ist keine weitere Konfiguration nötig.</para>

    <para>Nach der Installation kann ein Administrator die unter
      <filename>/var/db/portaudit</filename> lokal
      gespeicherte Datenbank aktualisieren und sich danach durch
      folgenden Befehl über mögliche Sicherheitslücken
      der von ihm installierten Softwarepakete informieren:</para>

    <screen>&prompt.root; <userinput>portaudit -Fda</userinput></screen>

    <note>
      <para>Die Datenbank wird automatisch aktualisiert, wenn
        &man.periodic.8; ausgeführt wird.  Der eben genannte
        Befehl ist daher optional, er wird aber für das
        folgende Beispiel benötigt.</para>
    </note>

    <para>Nach erfolgter Installation der Datenbank kann ein
      Administrator über die Ports-Sammlung installierte
      Softwarepakete Dritter jederzeit überprüfen.  Dazu
      muss er lediglich folgenden Befehl eingeben:</para>

    <screen>&prompt.root; <userinput>portaudit -a</userinput></screen>

    <para>Existiert in Ihren installierten Softwarepaketen eine
      Sicherheitslücke, wird <application>portaudit</application>
      eine Ausgabe ähnlich der folgenden produzieren:</para>

    <programlisting>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</programlisting>

    <para>Wenn Sie die angegebene <acronym>URL</acronym> über einen
      Internetbrowser aufrufen, erhalten Sie weitere Informationen
      über die bestehende Sicherheitslücke, wie die betroffenen
      Versionen, die Version des &os;-Ports sowie Hinweise auf weitere
      Seiten, die ebenfalls Sicherheitshinweise zu diesem Problem
      bieten.</para>

    <para><application>Portaudit</application> ist ein mächtiges
      Werkzeug und insbesondere in Zusammenarbeit mit dem
      Port <application>Portupgrade</application> äußerst
      hilfreich.</para>
  </sect1>

  <sect1 xml:id="security-advisories">
    <info><title>&os; Sicherheitshinweise</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigesteuert von </contrib></author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>&os; Sicherheitshinweise</primary>
    </indexterm>

    <para>Wie für andere hochwertige Betriebssysteme auch
      werden für &os; Sicherheitshinweise herausgegeben.
      Die Hinweise werden gewöhnlich auf den Sicherheits-Mailinglisten
      und in den Errata veröffentlicht, nachdem das
      Sicherheitsproblem behoben ist.  Dieser Abschnitt beschreibt
      den Umgang mit den Sicherheitshinweisen.</para>

    <sect2>
      <title>Wie sieht ein Sicherheitshinweis aus?</title>

      <para>&os; Sicherheitshinweise haben das folgende Format:</para>

      <programlisting>=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem<co xml:id="co-topic"/>

Category:       core<co xml:id="co-category"/>
Module:         sys<co xml:id="co-module"/>
Announced:      2003-09-23<co xml:id="co-announce"/>
Credits:        Person<co xml:id="co-credit"/>
Affects:        All releases of &os;<co xml:id="co-affects"/>
                &os; 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<co xml:id="co-corrected"/>
<acronym>CVE</acronym> Name:       CVE-XXXX-XXXX<co xml:id="co-cve"/>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background<co xml:id="co-backround"/>


II.  Problem Description<co xml:id="co-descript"/>


III. Impact<co xml:id="co-impact"/>


IV.  Workaround<co xml:id="co-workaround"/>


V.   Solution<co xml:id="co-solution"/>


VI.  Correction details<co xml:id="co-details"/>


VII. References<co xml:id="co-ref"/></programlisting>


      <calloutlist>
	<callout arearefs="co-topic">
	  <para>Das Feld <literal>Topic</literal> enthält eine
	    Beschreibung des Sicherheitsproblems und benennt das
	    betroffene Programm.</para>
	</callout>

	<callout arearefs="co-category">
	  <para>Das Feld <literal>Category</literal> beschreibt den
	    betroffenen Systemteil.  Mögliche Werte für dieses
	    Feld sind <literal>core</literal>, <literal>contrib</literal>
	    oder <literal>ports</literal>.  Die Kategorie
	    <literal>core</literal> gilt für Kernkomponenten
	    des &os;-Betriebssystems, die Kategorie
	    <literal>contrib</literal> beschreibt zum Basissystem
	    gehörende Software Dritter beispielsweise
	    <application>Sendmail</application>.  Die Kategorie
	    <literal>ports</literal> beschreibt Software, die
	    Teil der Ports-Sammlung ist.</para>
	</callout>

	<callout arearefs="co-module">
	  <para>Das Feld <literal>Module</literal> beschreibt die
	    betroffene Komponente.  Im Beispiel ist
	    <literal>sys</literal> angegeben, das heißt
	    dieses Problem betrifft eine Komponente, die vom
	    Kernel benutzt wird.</para>
	</callout>

	<callout arearefs="co-announce">
	  <para>Das Feld <literal>Announced</literal> gibt den
	    Zeitpunkt der Bekanntgabe des Sicherheitshinweises
	    an.  Damit existiert das Sicherheitsproblem,
	    ist vom Sicherheits-Team bestätigt worden
	    und eine entsprechende Korrektur wurde in das
	    Quellcode-Repository von &os; gestellt.</para>
	</callout>

	<callout arearefs="co-credit">
	  <para>Das Feld <literal>Credits</literal> gibt die Person
	    oder Organisation an, die das Sicherheitsproblem
	    bemerkte und gemeldet hat.</para>
	</callout>

	<callout arearefs="co-affects">
	  <para>Welche &os;-Releases betroffen sind, ist im Feld
	    <literal>Affects</literal> angegeben.  Die Version einer
	    Datei, die zum Kernel gehört, können Sie
	    schnell mit &man.ident.1; ermitteln.  Bei Ports
	    ist die Versionsnummer angegeben, die Sie im Verzeichnis
	    <filename>/var/db/pkg</filename> finden.
	    Wenn Sie Ihr System nicht täglich aktualisieren,
	    ist Ihr System wahrscheinlich betroffen.</para>
	</callout>

	<callout arearefs="co-corrected">
	  <para>Wann das Problem in welchem Release behoben wurde,
	    steht im Feld <literal>Corrected</literal>.</para>
	</callout>

	<callout arearefs="co-cve">
	  <para>Reserviert für Informationen, über die
	    in der <link xlink:href="http://cve.mitre.org">Common
	      Vulnerabilities Database</link> nach Sicherheitslücken
	    gesucht werden kann.</para>
	</callout>

	<callout arearefs="co-backround">
	  <para>Im Feld <literal>Background</literal> wird
	    das betroffene Werkzeug beschrieben.  Meist finden Sie
	    hier warum das Werkzeug Bestandteil von &os; ist,
	    wofür es benutzt wird und eine kurze
	    Darstellung der Herkunft des Werkzeugs.</para>
	</callout>

	<callout arearefs="co-descript">
	  <para>Im Feld <literal>Problem Description</literal> befindet
	    sich eine genaue Darstellung des Sicherheitsproblems.
	    Hier wird fehlerhafter Code beschrieben oder geschildert,
	    wie ein Werkzeug ausgenutzt wird.</para>
	</callout>

	<callout arearefs="co-impact">
	  <para>Das Feld <literal>Impact</literal> beschreibt die
	    Auswirkungen des Sicherheitsproblems auf ein System,
	    beispielsweise erweiterte Rechte oder gar
	    Superuser-Rechte für normale Benutzer.</para>
	</callout>

	<callout arearefs="co-workaround">
	  <para>Im Feld <literal>Workaround</literal> wird
	    eine Umgehung des Sicherheitsproblems beschrieben.
	    Die Umgehung ist für Administratoren gedacht,
	    die ihr System aus Zeitnot, Netzwerk-technischen oder
	    anderen Gründen nicht aktualisieren können.
	    Nehmen Sie Sicherheitsprobleme ernst:  Auf einem
	    betroffenen System sollte das Problem entweder behoben
	    oder, wie hier beschrieben, umgangen werden.</para>
	</callout>

	<callout arearefs="co-solution">
	  <para>Im Feld <literal>Solution</literal> enthält eine
	    getestete Schritt-für-Schritt Anleitung, die das
	    Sicherheitsproblem behebt.</para>
	</callout>

	<callout arearefs="co-details">
	  <para>Das Feld <literal>Correction Details</literal>
	    enthält die <application>Subversion</application>-Tags
	    der betroffenen Dateien zusammen mit zugehörigen
	    Revisionsnummern.</para>
	</callout>

	<callout arearefs="co-ref">
	  <para>Im Feld <literal>References</literal> finden sich
	    Verweise auf weitere Informationsquellen.  Dies können
	    URLs zu Webseiten, Bücher, Mailinglisten und Newsgroups
	    sein.</para>
	</callout>
      </calloutlist>
    </sect2>
  </sect1>

  <sect1 xml:id="security-accounting">
    <info><title>Prozess-Überwachung</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>Prozess-Überwachung</primary>
    </indexterm>

    <para>Prozess-Überwachung
      (<foreignphrase>Process accounting</foreignphrase>) ist ein
      Sicherheitsverfahren, bei dem ein Administrator verfolgt,
      welche Systemressourcen verwendet werden und wie sich diese
      auf die einzelnen Anwender verteilen.  Dadurch kann das
      System überwacht werden und es ist sogar möglich,
      zu kontrollieren, welche Befehle ein Anwender eingibt.</para>

    <para>Diese Fähigkeiten haben sowohl Vor- als auch Nachteile.
      Positiv ist, dass man einen Einbruchsversuch bis an den Anfang
      zurückverfolgen kann.  Von Nachteil ist allerdings,
      dass durch diesen Prozess Unmengen an Protokolldateien erzeugt
      werden, die auch dementsprechenden Plattenplatz benötigen.
      Dieser Abschnitt beschreibt die Grundlagen der
      Prozess-Überwachung.</para>

    <sect2>
      <title>Die Prozess-Überwachung aktivieren und
        konfigurieren</title>

      <para>Bevor Sie die Prozess-Überwachung verwenden können,
        müssen Sie diese über die folgenden Befehle aktivieren:</para>

       <screen>&prompt.root; <userinput>touch /var/account/acct</userinput>
&prompt.root; <userinput>accton /var/account/acct</userinput>
&prompt.root; <userinput>echo 'accounting_enable="YES"' &gt;&gt; /etc/rc.conf</userinput></screen>

      <para>Einmal aktiviert, wird sofort mit der Überwachung von
	<acronym>CPU</acronym>-Statistiken, Befehlen und anderen
	Vorgängen begonnen.  Protokolldateien werden in einem
	nur von Maschinen lesbaren Format gespeichert und können
	über &man.sa.8; aufgerufen werden.  Ohne Optionen gibt
	&man.sa.8; Informationen wie die Anzahl der Aufrufe pro
	Anwender, die abgelaufene Zeit in Minuten, die gesamte
	<acronym>CPU</acronym>- und Anwenderzeit in Minuten und die
	durchschnittliche Anzahl der Ein- und Ausgabeoperationen
	aus.</para>

      <para>Um Informationen über ausgeführte Befehle zu
	erhalten, verwenden Sie &man.lastcomm.1;. So können Sie
	etwa ermitteln, welche Befehle von wem auf welchem &man.ttys.5;
	ausgeführt wurden.  Dieses Beispiel zeigt die Nutzung von
	&man.ls.1; durch <systemitem
	  class="username">trhodes</systemitem> auf dem Terminal
	<literal>ttyp1</literal>:</para>

      <screen>&prompt.root; <userinput>lastcomm ls
	trhodes ttyp1</userinput></screen>

      <para>Zahlreiche weitere nützliche Optionen finden Sie
	&man.lastcomm.1;, &man.acct.5; sowie &man.sa.8;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="security-resourcelimits">
    <title>Einschränkung von Ressourcen</title>

    <info>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Ressourcen einschränken</primary>
    </indexterm>

    <para>Seit Jahren benutzt &os; die Datenbank
      <filename>/etc/login.conf</filename> um Ressourcen zu
      beschränken.  Obwohl dies immer noch unterstützt wird, ist es
      nicht die optimale Methode um die Beschränkung von Ressourcen zu
      steuern, da Benutzer in verschiedene Gruppen (Login-Klassen)
      aufgeteilt werden müssen und bei Änderungen immer die Datei und
      die Passwortdatenbank bearbeitet werden muss.  Möglicherweise
      benötigt ein eingeschränkter Benutzer eine zusätzliche Klasse,
      dann müsste die Datenbank mit <command>cap_mkdb</command> neu
      gebaut werden und <filename>/etc/master.passwd</filename> müsste
      ebenfalls bearbeitet werden.  Zusätzlich müsste die
      Passwortdatenbank mit <command>pwd_mkdb</command> neu gebaut
      werden.  Dieser Prozess kann sehr zeitaufwendig sein, abhängig
      davon, wie viele Benutzer bearbeitet werden müssen.</para>

    <para>Mit &man.rctl.8; können Ressourcen für Benutzer sehr
      detailliert gesteuert werden.  Die Befehl unterstützt nicht
      nur die Kontrolle der Ressourcen für Benutzer, sondern auch
      die Beschränkung auf Prozesse, Jails und den ursprünglichen
      Login-Klassen.  Diese erweiterten Funktionen bieten
      Administratoren und Benutzern die Möglichkeit, Ressourcen über
      die Kommandozeile oder über eine Konfigurationsdatei zu
      steuern.</para>

    <para>Um diese Eigenschaft zu aktivieren, fügen Sie folgende Zeile
      in die Kernelkonfigurationsdatei:</para>

    <programlisting>options           RACCT
options         RCTL</programlisting>

    <para>Das System muss nun neu übersetzt werden. Dieser Vorgang
      wird in <xref linkend="kernelconfig"/> beschrieben.
      Anschließend kann <command>rctl</command> benutzt werden, um
      die Regeln für das System festzulegen.</para>

    <para>Die Syntax der Regeln ist einfach und wird durch
      <emphasis>subject</emphasis>, <emphasis>subject-id</emphasis>,
      <emphasis>resource</emphasis> und <emphasis>action</emphasis>
      gesteuert.  Hier ein Beispiel für eine Regel:</para>

    <programlisting>user:trhodes:<literal>maxproc</literal>:<literal>deny</literal>=10/user</programlisting>

    <para>Diese Regel zeigt den grundlegenden Aufbau, hier mit dem
      Subjekt <literal>user</literal> und der Subjekt-ID
      <literal>trhodes</literal>.  <literal>maxproc</literal>
      definiert die Anzahl der Prozesse.  Die <quote>Aktion</quote>
      <literal>deny</literal> verhindert, dass neue Prozesse erstellt
      werden.  Im vorherigen Beispiel wurde für den Benutzer
      <literal>trhodes</literal> eine Beschränkung von
      <literal>10</literal> (zehn) Prozessen konfiguriert.  Es sind
      noch weitere Aktionen verfügbar, beispielsweise die
      Protokollierung auf der Konsole, Benachrichtigungen an
      &man.devd.8; oder das Senden eines <literal>SIGTERM</literal>
      an einen Prozess.</para>

    <para>Beim hinzufügen von Regeln müssen einige Dinge beachtet
      werden.  Das obige Beispiel würde den Benutzer sogar daran
      hindern, einfachste Dinge zu tun, nachdem er sich anmeldet und
      eine <command>screen</command> Sitzung gestartet hat.  Sobald
      die Begrenzung für eine Ressource erreicht ist, wird folgende
      Meldung ausgegeben:</para>

    <screen>&prompt.root; <userinput>man test</userinput>
/usr/bin/man: Cannot fork: Resource temporarily unavailable
eval: Cannot fork: Resource temporarily unavailable</screen>

    <para>&man.rctl.8; kann auch benutzt werden, um einer Jail
      eine Speichergrenze zuzuweisen.  Eine solche Regel könnte
      wie folgt festgelegt werden:</para>

    <screen>&prompt.root; <userinput>rctl -a jail:httpd:memoryuse:deny=2G/jail</userinput></screen>

    <para>Damit die Regeln auch nach einem Neustart erhalten bleiben,
      müssen sie in <filename>/etc/rctl.conf</filename> hinzugefügt
      werden.  Dazu schreiben Sie einfach die Regel, ohne das
      vorhergehende Kommando.  Zum Beispiel:</para>

    <programlisting># Block jail from using more than 2G memory:
jail:httpd:memoryuse:deny=2G/jail</programlisting>

    <para>Mit <command>rctl</command> können auch Regeln entfernt
      werden:</para>

    <screen>&prompt.root; <userinput>rctl -r user:trhodes:maxproc:deny=10/user</userinput></screen>

    <para>Die Manualpage zeigt auch eine Möglichkeit, alle Regeln zu
      entfernen.  Falls es erforderlich ist alle Regeln für einen
      einzelnen Benutzer zu entfernen, kann dieser Befehl verwendet
      werden:</para>

    <screen>&prompt.root; <userinput>rctl -r user:trhodes</userinput></screen>

    <para>Es gibt noch viele weitere Ressourcen, die verwendet werden
      können, um zusätzliche <literal>subjects</literal> zu
      kontrollieren.  Weitere Informationen zu diesem Thema finden Sie
      in &man.rctl.8;.</para>
  </sect1>
</chapter>
