<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/security/chapter.sgml,v 1.65 2003/03/08 18:27:37 mheinen Exp $
     basiert auf: 1.139
-->

<chapter id="security">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Matthew</firstname>
	<surname>Dillon</surname>
	<contrib>Viel von diesem Kapitel stammt aus der security(7)
	  Manualpage von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Martin</firstname>
	<surname>Heinen</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Sicherheit</title>
  <indexterm><primary>Sicherheit</primary></indexterm>

  <sect1 id="security-synopsis">
    <title>&Uuml;bersicht</title>

    <para>Dieses Kapitel bietet eine Einf&uuml;hrung in die Konzepte
      der Systemsicherheit.  Neben einigen Daumenregeln werden
      weiterf&uuml;hrende Themen wie S/Key, OpenSSL und Kerberos
      diskutiert.  Die meisten der hier besprochenen Punkte treffen
      sowohl auf die Systemsicherheit sowie die Internetsicherheit zu.
      Das Internet hat aufgeh&ouml;rt ein <quote>friedlicher</quote>
      Ort zu sein, an dem Sie nur nette Leute finden werden.  Es ist
      unumg&auml;nglich, dass Sie Ihre Daten, Ihr geistiges Eigentum,
      Ihre Zeit und vieles mehr vor dem Zugriff von Hackern
      sch&uuml;tzen.</para>

    <para>FreeBSD besitzt eine Reihe von Werkzeugen und Mechanismen, um die
      Integrit&auml;t und die Sicherheit Ihrer Systeme und Netzwerke
      zu gew&auml;hrleisten.</para>

    <para>Nach dem Sie dieses Kapitel durchgearbeitet haben, werden
      Sie:</para>

    <itemizedlist>
      <listitem>
	<para>Grundlegende auf FreeBSD bezogene Sicherheitsaspekte
	  kennen.</para>
      </listitem>

      <listitem>
	<para>Die verschiedenen Verschl&uuml;sselungsmechanismen von FreeBSD,
	  wie DES oder MD5, kennen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie S/Key, ein Einmal-Passwort
	  Authentifizierungssystem konfigurieren.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie Kerberos, ein weiteres Authentifizierungssystem,
	  einrichten.</para>
      </listitem>

      <listitem>
	<para>Firewalls mit IPFW erstellen k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie IPsec konfigurieren.</para>
      </listitem>

      <listitem>
	<para>OpenSSH, FreeBSDs Implementierung von SSH, konfigurieren
	  und benutzen k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Wie sie mithilfe des TrustedBSD-MAC-Frameworks
	  Zugrifsskontrollen konfigurieren.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Grundlegende Konzepte von FreeBSD und dem Internet
	  verstehen.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="security-intro">
    <title>Einf&uuml;hrung</title>

    <para>Sicherheit ist ein Konzept, das beim Systemadministrator anf&auml;ngt
      und aufh&ouml;rt.  Obwohl alle BSD &unix; Mehrbenutzersysteme &uuml;ber
      Sicherheitsfunktionen verf&uuml;gen, ist es wohl eine der
      gr&ouml;&szlig;ten Aufgaben eines Systemadministrators zus&auml;tzliche
      Sicherheitsmechanismen zu erstellen und zu pflegen.  Maschinen sind
      nur so sicher wie sie gemacht werden und Sicherheitsanforderungen
      stehen oft der Benutzerfreundlichkeit entgegen.  Auf &unix; Systemen
      k&ouml;nnen sehr viele Prozesse gleichzeitig laufen und viele dieser
      Prozesse sind Server, das hei&szlig;t von au&szlig;en kann auf sie
      zugegriffen werden.  In einer Zeit, in der die Minicomputer und
      Mainframes von gestern die Desktops von heute sind und Rechner
      immer mehr vernetzt werden, kommt der Sicherheit eine gro&szlig;e
      Bedeutung zu.</para>

    <para>Sicherheit wird am besten in mehreren Schichten implementiert.
      Kurz gesagt wollen Sie eine angemessene Anzahl Schichten einrichten,
      und dann das System auf Einbr&uuml;che hin beobachten.  Die
      Sicherheitsma&szlig;nahmen sollten nicht &uuml;berzogen werden,
      da sie sonst das Entdecken von Einbr&uuml;chen st&ouml;ren und die
      M&ouml;glichkeit, Einbr&uuml;che zu entdecken, ist einer der wichtigsten
      Aspekte einer Sicherheitsma&szlig;nahme.  Es macht zum Beispiel wenig
      Sinn, jedes Programm mit der <literal>schg</literal> Option (siehe auch
      &man.chflags.1;) zu sch&uuml;tzen, weil dies verhindert, dass ein
      Angreifer eine leicht zu entdeckende Ver&auml;nderung vornimmt und
      vielleicht dazu f&uuml;hrt, dass Ihre Sicherheitsvorkehrungen den
      Angreifer &uuml;berhaupt nicht entdecken.</para>

    <para>Zur Systemsicherheit geh&ouml;rt auch die Besch&auml;ftigung mit
      verschiedenen Arten von Angriffen, auch solchen, die versuchen,
      ein System still zu legen, oder sonst unbrauchbar zu machen ohne
      <username>root</username> zu kompromittieren.  Sicherheitsaspekte
      lassen sich in mehrere Kategorien unterteilen:</para>

    <orderedlist>
      <listitem>
	<para>Denial of Service Angriffe.</para>
      </listitem>

      <listitem>
	<para>Kompromittierte Accounts.</para>
      </listitem>

      <listitem>
	<para>Kompromittierter <username>root</username>-Account durch
	  zugreifbare Server.</para>
      </listitem>

      <listitem>
	<para>Kompromittierter <username>root</username>-Account durch
	  kompromittierte Accounts.</para>
      </listitem>

      <listitem>
	<para>Einrichten von Hintert&uuml;ren.</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>DoS Angriffe</primary>
      <see>Denial of Service (DoS)</see>
    </indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>DoS Angriffe</secondary>
      <see>Denial of Service (DoS)</see>
    </indexterm>
    <indexterm><primary>Denial of Service (DoS)</primary></indexterm>

    <para>Ein Denial of Service (Verhinderung von Diensten, DoS) Angriff
      entzieht einer Maschine Ressourcen, die sie zur Bereitstellung
      von Diensten ben&ouml;tigt.  Meist versuchen Denial of Service Angriffe
      die Dienste oder den Netzwerkstack einer Maschine zu &uuml;berlasten,
      um so die Maschine auszuschalten oder nicht nutzbar zu machen.  Einige
      Angriffe versuchen, Fehler im Netzwerkstack auszunutzen, und die
      Maschine mit einem einzigen Paket auszuschalten.  Diese Art des
      Angriffs kann nur verhindert werden, indem der entsprechende Fehler
      im Kernel behoben wird.  Oft k&ouml;nnen Angriffe auf Dienste durch
      die Angabe von Optionen verhindert werden, die die Last, die ein
      Dienst auf das System unter widrigen Umst&auml;nden aus&uuml;ben kann,
      begrenzt.  Angriffen auf das Netzwerk ist schwerer zu begegnen.
      Au&szlig;er durch Trennen der Internetverbindung ist zum Beispiel
      einem Angriff mit gef&auml;lschten Paketen nicht zu begegnen.
      Diese Art von Angriff wird Ihr System zwar nicht unbrauchbar machen,
      kann aber die Internetverbindung s&auml;ttigen.</para>

    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>kompromittierte Accounts</secondary>
    </indexterm>

    <para>Kompromittierte Accounts kommen noch h&auml;ufiger als
      DoS Angriffe vor.  Viele Systemadministratoren lassen auf ihren
      Maschinen noch die Dienste <application>telnetd</application>,
      <application>rlogind</application>, <application>rshd</application>
      und <application>ftpd</application> laufen.  Verbindungen zu diesen
      Servern werden nicht verschl&uuml;sselt.  Wenn Sie eine
      gr&ouml;&szlig;ere Benutzerzahl auf Ihrem System haben, die sich von
      einem entfernten System anmelden, ist die Folge davon, dass
      das Passwort eines oder mehrerer Benutzer ausgesp&auml;ht wurde.
      Ein aufmerksamer Systemadministrator wird die Logs &uuml;ber Anmeldungen
      von entfernten Systemen auf verd&auml;chtige Quelladressen, auch
      f&uuml;r erfolgreiche Anmeldungen, untersuchen.</para>

    <para>Es ist immer davon auszugehen, dass ein Angreifer, der
      Zugriff auf einen Account hat, Zugang zum
      <username>root</username>-Account erlangt.  Allerdings gibt der
      Zugriff auf einen Account auf einem gut gesicherten und
      gepflegten System nicht notwendig Zugriff auf den
      <username>root</username>-Account.  Diese Unterscheidung ist wichtig,
      da ein Angreifer, der keinen Zugang zu <username>root</username>
      besitzt, seine Spuren nicht verwischen kann.  Er kann h&ouml;chstens
      die Dateien des betreffenden Benutzers ver&auml;ndern oder die
      Maschine stilllegen.  Kompromittierte Accounts sind sehr
      h&auml;ufig, da Benutzer meist nicht dieselben Vorsichtsma&szlig;nahmen
      wie Administratoren treffen.</para>

    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>Hintert&uuml;ren</secondary>
    </indexterm>

    <para>Es gibt viele Wege, Zugang zum <username>root</username>-Account
      eines Systems zu bekommen: Ein Angreifer kann das Passwort von
      <username>root</username> kennen, er kann einen Fehler in einem
      Server entdecken, der unter <username>root</username> l&auml;uft und
      dann &uuml;ber eine Netzwerkverbindung zu diesem Server einbrechen.
      Oder er kennt einen
      Fehler in einem SUID-<username>root</username> Programm, der es
      ihm erlaubt, <username>root</username> zu werden, wenn er einmal
      einen Account kompromittiert hat.  Wenn ein Angreifer einen
      Weg gefunden hat, <username>root</username> zu werden, braucht er
      vielleicht keine Hintert&uuml;r auf dem System installieren.
      Viele der heute
      bekannten und geschlossenen Sicherheitsl&ouml;cher, die zu einem
      <username>root</username> Zugriff f&uuml;hren, verlangen vom Angreifer
      einen erheblichen Aufwand, um seine Spuren zu verwischen.  Aus diesem
      Grund wird er sich wahrscheinlich entschlie&szlig;en, eine Hintert&uuml;r
      (engl. <foreignphrase>Backdoor</foreignphrase>) zu installieren.
      Eine Hintert&uuml;r erlaubt es
      dem Angreifer leicht auf den <username>root</username>-Account
      zuzugreifen.  Einem klugen Systemadministrator erlaubt sie allerdings
      auch, den Einbruch zu entdecken.  Wenn Sie es einem Angreifer verwehren,
      Hintert&uuml;ren zu installieren, kann das sch&auml;dlich f&uuml;r
      Ihre Sicherheit sein, da es vielleicht verhindert, dass die
      L&uuml;cke, die der Angreifer f&uuml;r den Einbruch ausgenutzt hat,
      entdeckt wird.</para>

    <para>Sicherheitsma&szlig;nahmen sollten immer in mehreren Schichten
      angelegt werden.  Die Schichten k&ouml;nnen wie folgt eingeteilt
      werden:</para>

    <orderedlist>
      <listitem>
	<para>Absichern von <username>root</username> und
	  Accounts.</para>
      </listitem>

      <listitem>
	<para>Absichern von unter <username>root</username> laufenden
	  Servern und SUID/SGID Programmen.</para>
      </listitem>

      <listitem>
	<para>Absichern von Accounts.</para>
      </listitem>

      <listitem>
	<para>Absichern der Passwort-Datei.</para>
      </listitem>

      <listitem>
	<para>Absichern des Kernels, der Ger&auml;te und von
	  Dateisystemen.</para>
      </listitem>

      <listitem>
	<para>Schnelles Aufdecken von unbefugten Ver&auml;nderungen des
	  Systems.</para>
      </listitem>

      <listitem>
	<para>Paranoia.</para>
      </listitem>
    </orderedlist>

    <para>Die einzelnen Punkte der obigen Liste werden im n&auml;chsten
      Abschnitt genauer behandelt.</para>
  </sect1>

  <indexterm>
    <primary>Sicherheit</primary>
    <secondary>Absichern</secondary>
  </indexterm>

  <sect1 id="securing-freebsd">
    <title>Absichern von FreeBSD</title>

    <note>
      <title>Kommandos und Protokolle</title>
      <para>In diesem Abschnitt wird <application>fett</application> verwendet,
	um Kommandos oder Anwendungen zu kennzeichnen.  Zum Beispiel
	wird <application>ssh</application> so gekennzeichnet, da es
	sowohl ein Protokoll wie auch ein Kommando ist.</para>
    </note>

    <para>Die folgenden Abschnitte behandeln die im
      <link linkend="security-intro">letzten Abschnitt</link> erw&auml;hnten
      Methoden Ihr FreeBSD-System zu sichern.</para>

    <sect2 id="securing-root-and-staff">
      <title>Absichern von <username>root</username> und
	Accounts</title>

      <indexterm>
        <primary><command>su</command></primary>
      </indexterm>

      <para>Zuallererst, k&uuml;mmern Sie sich nicht um die Absicherung
	von Accounts, wenn Sie <username>root</username>
	noch nicht abgesichert haben.  Auf den meisten Systemen ist
	<username>root</username> ein Passwort zugewiesen.  Sie
	sollten <emphasis>immer</emphasis> davon ausgehen, dass
	dieses Passwort kompromittiert ist.  Das hei&szlig;t nicht,
	dass Sie das Passwort entfernen sollten, da es meist
	f&uuml;r den Konsolenzugriff notwendig ist.  Vielmehr hei&szlig;t
	es, dass Sie das Passwort nicht au&szlig;erhalb der
	Konsole, auch nicht zusammen mit &man.su.1;, verwenden sollten.
	Stellen Sie sicher, dass Ihre PTYs in <filename>ttys</filename> als
	unsicher markiert sind und damit Anmeldungen von
	<username>root</username> mit <command>telnet</command> oder
	<command>rlogin</command> verboten sind.  Wenn Sie andere
	Anwendungen wie <application>sshd</application> zum Anmelden
	benutzen, vergewissern Sie sich, dass dort ebenfalls
	Anmeldungen als <username>root</username> verboten sind.  F&uuml;r
	<application>ssh</application> editieren Sie
	<filename>/etc/ssh/sshd_config</filename> und &uuml;berpr&uuml;fen,
	dass <literal>PermitRootLogin</literal> auf <literal>NO</literal>
	gesetzt ist.  Beachten Sie jede Zugriffsmethode &ndash; Dienste
	wie FTP werden oft vergessen.  Nur an der Systemkonsole sollte
	ein direktes Anmelden als <username>root</username> m&ouml;glich
	sein.</para>

      <indexterm>
        <primary><groupname>wheel</groupname></primary>
      </indexterm>

      <para>Nat&uuml;rlich m&uuml;ssen Sie als Systemadministrator
	<username>root</username>-Zugriff erlangen k&ouml;nnen.  Dieser
	sollte aber durch zus&auml;tzliche Passw&ouml;rter
	gesch&uuml;tzt sein.  Ein Weg, Zugang zu <username>root</username>
	zu erm&ouml;glichen, ist es, berechtigte Mitarbeiter in
	<filename>/etc/group</filename> in die Gruppe
	<groupname>wheel</groupname> aufzunehmen.  Die Personen, die
	Mitglieder in der Gruppe <groupname>wheel</groupname> sind,
	k&ouml;nnen mit <command>su</command> zu <username>root</username>
	wechseln.  Ihre Mitarbeiter sollten niemals die Gruppe
	<groupname>wheel</groupname> als prim&auml;re Gruppe in
	<filename>/etc/passwd</filename> besitzen.  Mitarbeiter sollten
	der Gruppe <groupname>staff</groupname> angeh&ouml;ren und &uuml;ber
	<filename>/etc/group</filename> in <groupname>wheel</groupname>
	aufgenommen werden.  Es sollten auch nur die Mitarbeiter, die
	wirklich <username>root</username> Zugriff ben&ouml;tigen in
	<groupname>wheel</groupname> aufgenommen werden.  Mit anderen
	Authentifizierungsmethoden m&uuml;ssen Sie niemanden in
	<groupname>wheel</groupname> aufnehmen.  Wenn Sie z.B.
	<application>Kerberos</application> benutzen, wechseln Sie mit
	&man.ksu.1; zu <username>root</username> und der Zugriff wird
	mit der Datei <filename>.k5login</filename> geregelt.  Dies ist
	vielleicht eine bessere L&ouml;sung, da es der
	<groupname>wheel</groupname>-Mechanismus einem Angreifer immer
	noch m&ouml;glich macht, den <username>root</username>-Account
	zu knacken, nachdem er einen Mitarbeiter-Account geknackt hat.
	Obwohl der <groupname>wheel</groupname>-Mechanismus besser als
	gar nichts ist, ist er nicht unbedingt die sicherste L&ouml;sung.</para>

      <para>Indirekt k&ouml;nnen Sie die Accounts von Mitarbeitern und
        damit auch den Zugriff auf <username>root</username> sch&uuml;tzen,
	indem Sie eine alternative Zugangsmethode verwenden und die
	Accounts der Mitarbeiter mit einem ung&uuml;ltigen verschl&uuml;sselten
	Passwort versehen.  Mit &man.vipw.8; k&ouml;nnen Sie jedes
	verschl&uuml;sselte Passwort mit einem
	<quote><literal>*</literal></quote> Zeichen ersetzen.  Das Kommando
	wird <filename>/etc/master.passwd</filename> und die
	Benutzer/Passwort Datenbank aktualisieren und die Passwort
	Authentifizierung abstellen.</para>

      <para>Ein Account wie</para>

      <programlisting>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>sollte wie folgt abge&auml;ndert werden:</para>

      <programlisting>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Da ein verschl&uuml;sseltes Passwort niemals
	ein <quote><literal>*</literal></quote> sein kann, verhindert dies
	die normale Anmeldung.  Damit m&uuml;ssen sich die Mitarbeiter
	mit anderen Mechanismen wie &man.kerberos.1; oder &man.ssh.1;
	authentifizieren.  Wenn Sie etwas wie
	<application>Kerberos</application> benutzen, m&uuml;ssen Sie
	die Maschinen, die die <application>Kerberos</application>-Server
	beheimaten und die Maschinen der Benutzer absichern.  Wenn Sie
	&ouml;ffentliche/private Schl&uuml;ssel mit
	<application>ssh</application> benutzen, muss die Maschine
	<emphasis>von</emphasis> der die Anmeldung gestartet wird, gesichert
	werden.  Als zus&auml;tzliche Sicherheitsschicht k&ouml;nnen Sie
	das Schl&uuml;sselpaar beim Erstellen mit &man.ssh-keygen.1; durch
	ein Passwort sch&uuml;tzen.  Dadurch, dass Sie die
	Passw&ouml;rter Ihrer Mitarbeiter als ung&uuml;ltig markiert
	haben, stellen Sie sicher, dass sich die Mitarbeiter nur mit
	den sicheren Methoden, die Sie aufgesetzt haben, anmelden k&ouml;nnen.
	Dies zwingt alle Mitarbeiter, verschl&uuml;sselte Verbindungen
	f&uuml;r ihre Sitzungen zu verwenden, und schlie&szlig;t ein
	wichtiges Loch, dass gerne von Angreifern ausgenutzt wird:
	Das Abh&ouml;ren des Netzwerks von einer anderen weniger gesicherten
	Maschine.</para>

      <para>Die indirekten Sicherheitsmechanismen setzen voraus, dass
	Sie sich von einer restriktiven Maschine auf einer weniger restriktiven
	Maschine anmelden.  Wenn zum Beispiel auf Ihrem Hauptrechner alle
	m&ouml;glichen Arten von Servern laufen, so sollten auf Ihrer
	Workstation keine Server laufen.  Um Ihre Workstation vern&uuml;nftig
	abzusichern, sollten auf Ihr so wenig Server wie m&ouml;glich bis hin
	zu keinem Server laufen.  Sie sollten zudem &uuml;ber einen
	Bildschirmschoner verf&uuml;gen, der mit einem Passwort
	gesichert ist.  Nat&uuml;rlich kann ein Angreifer, der physikalischen
	Zugang zu einer Maschine hat, jede Art von Sicherheitsmechanismen
	umgehen.  Dieses Problem sollten Sie daher auch in Ihren
	&Uuml;berlegungen ber&uuml;cksichtigen.  Beachten Sie dabei aber,
	dass der Gro&szlig;teil der Einbr&uuml;che &uuml;ber das
	Netzwerk erfolgt und die Einbrecher keinen Zugang zu der Maschine
	besitzen.</para>
      <indexterm><primary>Kerberos</primary></indexterm>

      <para>Mit <application>Kerberos</application> k&ouml;nnen Sie das
	Passwort eines Mitarbeiters an einer Stelle &auml;ndern
	und alle Maschinen, auf denen der Mitarbeiter einen Account hat,
	beachten die &Auml;nderung sofort.  Wird der Account eines
	Mitarbeiters einmal kompromittiert, so sollte die F&auml;higkeit, das
	Passwort mit einem Schlag auf allen Maschinen zu &auml;ndern,
	nicht untersch&auml;tzt werden.  Mit einzelnen Passw&ouml;rtern
	wird es schwierig, das Passwort auf N Maschinen zu &auml;ndern.
	Mit <application>Kerberos</application> k&ouml;nnen Sie auch
	Beschr&auml;nkungen f&uuml;r Passw&ouml;rter festlegen:
	Nicht nur das Ticket kann nach einiger Zeit ung&uuml;ltig werden,
	Sie k&ouml;nnen auch festlegen, dass ein Benutzer nach einer
	bestimmten Zeit, z.B. nach einem Monat, das Passwort wechseln
	muss.</para>

    <sect2>
      <title>Absichern von unter <username>root</username> laufenden
        Servern und SUID/SGID Programmen</title>

      <indexterm>
        <primary><command>ntalk</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>comsat</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>finger</command></primary>
      </indexterm>
      <indexterm>
        <primary>Sandk&auml;sten</primary>
      </indexterm>
      <indexterm>
        <primary><application>sshd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>telnetd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>rshd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>rlogind</application></primary>
      </indexterm>

      <para>Ein kluger Systemadministrator l&auml;sst nur die
	Dienste, die er wirklich braucht, laufen; nicht mehr und auch
	nicht weniger.  Beachten Sie, dass Server von Dritten die
	fehleranf&auml;lligsten sind.  Wenn Sie z.B. eine alte Version von
	<application>imapd</application> oder <application>popper</application>
	laufen lassen, ist das so, als w&uuml;rden Sie der ganzen Welt
	freien Zugang zu <username>root</username> geben.  Lassen Sie keine
	Server laufen, die Sie vorher nicht genau &uuml;berpr&uuml;ft haben.
	Viele Server m&uuml;ssen nicht unter <username>root</username>
	laufen, zum Beispiel k&ouml;nnen <application>ntalk</application>,
	<application>comsat</application> und <application>finger</application>
        in speziellen <firstterm>Sandk&auml;sten</firstterm> unter
	einem Benutzer laufen.  Ein Sandkasten ist keine perfekte L&ouml;sung,
	wenn Sie nicht eine Menge Arbeit in die Konfiguration investieren,
	doch bew&auml;hrt sich hier das Prinzip, die Sicherheit in Schichten
	aufzubauen.  Wenn es einem Angreifer gelingt, in einen Server,
	der in einem Sandkasten l&auml;uft, einzubrechen, dann muss
	er immer noch aus dem Sandkasten selber ausbrechen.  Je mehr Schichten
	der Angreifer zu durchbrechen hat, desto kleiner sind seine Aussichten
	auf Erfolg.  In der Vergangenheit wurden praktisch in jedem
	Server, der unter <username>root</username> l&auml;uft, L&uuml;cken
	gefunden, die zu einem <username>root</username> Zugriff f&uuml;hrten.
	Dies betrifft selbst die grundlegenden Systemdienste.  Wenn Sie eine
	Maschine betreiben, auf der man sich nur mit
	<application>sshd</application> anmelden kann, dann stellen Sie die
	Dienste <application>telnetd</application>,
	<application>rshd</application> oder <application>rlogind</application>
	ab!</para>

      <para>In der Voreinstellung laufen unter FreeBSD
	<application>ntalkd</application>, <application>comsat</application>
	und <application>finger</application> nun in einem Sandkasten.  Ein
	weiteres Programm, das in einem Sandkasten laufen sollte, ist
	&man.named.8;.  In <filename>/etc/defaults/rc.conf</filename> sind
	die notwendigen Argumente, um <application>named</application> in
	einem Sandkasten laufen zu lassen, in kommentierter Form schon
	enthalten.  Abh&auml;ngig davon, ob Sie ein neues System installieren
	oder ein altes System aktualisieren, sind die hierf&uuml;r
	ben&ouml;tigten Benutzer noch nicht installiert.
	Ein kluger Systemadministrator sollte immer nach M&ouml;glichkeiten
	suchen, Server in einem Sandkasten laufen zu lassen.</para>
      <indexterm>
        <primary><application>sendmail</application></primary>
      </indexterm>

      <para>Einige Server wie <application>sendmail</application>,
	<application>popper</application>, <application>imapd</application>
	und <application>ftpd</application> werden normalerweise nicht in
	Sandk&auml;sten betrieben.  Zu einigen Servern gibt es Alternativen,
	aber diese wollen Sie vielleicht wegen der zus&auml;tzlich n&ouml;tigen
	Arbeit nicht installieren (ein weiteres Beispiel f&uuml;r den
	Widerspruch zwischen Sicherheit und Benutzerfreundlichkeit).
	In diesem Fall m&uuml;ssen Sie die
	Server unter <username>root</username> laufen lassen und auf die
	eingebauten Mechanismen vertrauen, Einbr&uuml;che zu entdecken.</para>

      <para>Weitere potentielle L&ouml;cher, die zu einem
	<username>root</username>-Zugriff f&uuml;hren k&ouml;nnen, sind
        die auf dem System installierten SUID- und SGID-Programme.  Die
	meisten dieser Programme wie <application>rlogin</application> stehen
	in <filename>/bin</filename>, <filename>/sbin</filename>,
	<filename>/usr/bin</filename>, oder <filename>/usr/sbin</filename>.
	Obwohl nichts 100% sicher ist, k&ouml;nnen Sie davon ausgehen,
	dass die SUID- und SGID-Programme des Basissystems ausreichend
	sicher sind.  Allerdings werden ab und an in diesen Programmen
	L&ouml;cher gefunden.  1998 wurde in <literal>Xlib</literal> ein
	Loch gefunden, das <application>xterm</application>, der
	normal mit SUID installiert wird, verwundbar machte.  Es ist besser
	auf der sicheren Seite zu sein, als sich sp&auml;ter zu beklagen,
	darum wird ein kluger Systemadministrator den Zugriff auf
	SUID-Programme mit einer Gruppe, auf die nur Mitarbeiter zugreifen
	k&ouml;nnen, beschr&auml;nken.  SUID-Programme, die niemand benutzt,
	sollten mit <command>chmod 000</command> deaktiviert werden.  Zum
	Beispiel braucht ein Server ohne Bildschirm kein
	<application>xterm</application> Programm.  SGID-Programme sind
	vergleichbar gef&auml;hrlich.  Wenn ein Einbrecher Zugriff auf
	SGID-<groupname>kmem</groupname> Programm erh&auml;lt, kann er
	vielleicht <filename>/dev/kmem</filename> und damit die
	verschl&uuml;sselte Passwortdatei lesen.  Dies kompromittiert
	unter Umst&auml;nden jeden Account, der mit einem Passwort
	gesch&uuml;tzt ist.  Alternativ kann ein Einbrecher, der in die
	Gruppe <groupname>kmem</groupname> eingebrochen ist, die
	Tastendr&uuml;cke auf PTYs verfolgen.  Dies schlie&szlig;t
	auch PTYs mit ein, auf denen sich ein Benutzer mit sicheren
	Methoden anmeldet.  Ein Einbrecher, der Zugriff auf die
	<groupname>tty</groupname> Gruppe hat, kann auf fast jeden Terminal
	anderer Benutzer schreiben.  Wenn der Benutzer einen Terminal-Emulator
	benutzt, der &uuml;ber eine Tastatur-Simulation verf&uuml;gt,
	k&ouml;nnte der Angreifer Daten generieren, die den Terminal
	veranlassen, ein Kommando unter diesem Benutzer laufen zu lassen.</para>
    </sect2>

    <sect2 id="secure-users">
      <title>Absichern von Accounts</title>

      <para>Accounts sind f&uuml;r gew&ouml;hnlich sehr schwierig
	abzusichern.  W&auml;hrend Sie drakonische Beschr&auml;nkungen
	f&uuml;r Ihre Mitarbeiter einrichten und deren Passw&ouml;rter
	als ung&uuml;ltig markieren k&ouml;nnen, werden Sie das
	vielleicht bei den normalen Accounts nicht durchsetzen.
	Wenn Sie &uuml;ber ausreichend Macht verf&uuml;gen, gelingt es Ihnen
	vielleicht doch, ansonsten m&uuml;ssen Sie diese Accounts
	aufmerksam &uuml;berwachen.  Wegen der zus&auml;tzlichen
	Administrationsarbeit und der n&ouml;tigen technischen
	Unterst&uuml;tzung ist die Verwendung von
	<application>ssh</application> und <application>Kerberos</application>
	mit normalen Accounts erschwert, obwohl das nat&uuml;rlich
	sicherer als die Verwendung von verschl&uuml;sselten
	Passw&ouml;rtern ist.</para>
    </sect2>

    <sect2>
      <title>Absichern der Passwort-Datei</title>

      <para>Der einzig sichere Weg ist, so viele Accounts wie m&ouml;glich als
	ung&uuml;ltig zu markieren und <application>ssh</application> oder
	<application>Kerberos</application> zu benutzen, um auf sie
	zuzugreifen.  Obwohl die Datei <filename>/etc/spwd.db</filename>,
	die die verschl&uuml;sselten Passw&ouml;rter enth&auml;lt,
	nur von <username>root</username> gelesen werden kann, mag ein
	Angreifer lesenden Zugriff auf diese Datei erlangen, ohne die
	F&auml;higkeit sie auch zu beschreiben.</para>

      <para>Ihre &Uuml;berwachungsskripten sollten &Auml;nderungen
	an der Passwort-Datei melden (siehe <link
	linkend="security-integrity">&Uuml;berpr&uuml;fen der
	Integrit&auml;t von Dateien</link> weiter unten).</para>
    </sect2>

    <sect2>
      <title>Absichern des Kernels, der Ger&auml;te und von
        Dateisystemen</title>

      <para>Wenn ein Angreifer <username>root</username>-Zugriff erlangt,
	kann er so ziemlich alles mit Ihrem System anstellen, doch sollten Sie
	es ihm nicht zu leicht machen.  Die meisten modernen Kernel haben
	zum Beispiel einen Ger&auml;tetreiber, der es erlaubt, Pakete
	abzuh&ouml;ren.  Unter FreeBSD wird das Ger&auml;t
	<devicename>bpf</devicename> genannt.  F&uuml;r gew&ouml;hnlich
	wird ein Angreifer versuchen, dieses Ger&auml;t zu nutzen, um
	Pakete abzuh&ouml;ren.  Sie sollten ihm diese Gelegenheit nicht
	geben und auf den meisten Systemen ist das Ger&auml;t
	<devicename>bpf</devicename> nicht n&ouml;tig.</para>

      <indexterm>
        <primary><command>sysctl</command></primary>
      </indexterm>
      <para>Auch wenn Sie <devicename>bpf</devicename> nicht verwenden,
	m&uuml;ssen Sie sich immer noch um <devicename>/dev/mem</devicename>
	und <devicename>/dev/kmem</devicename> sorgen.  Au&szlig;erdem
	kann der Angreifer immer noch auf die rohen Ger&auml;te
	(<foreignphrase>raw devices</foreignphrase>)
	schreiben.  Weiterhin gibt es ein Programm zum Nachladen von
	Modulen in den Kernel: &man.kldload.8;.  Ein unternehmungslustiger
	Angreifer kann dies benutzen, um sein eigenes
	<devicename>bpf</devicename> oder ein anderes zum Abh&ouml;ren
	geeignetes Ger&auml;t in den laufenden Kernel einzubringen.  Um diese
	Probleme zu vermeiden, m&uuml;ssen Sie den Kernel auf einer
	h&ouml;heren Sicherheitsstufe, mindestens <literal>1</literal>,
	laufen lassen.  Die Sicherheitsstufe wird durch die Variable
	<varname>kern.securelevel</varname>, die mit <command>sysctl</command>
	gesetzt werden kann, angegeben.  Nachdem Sie die Sicherheitsstufe
	auf <literal>1</literal> gesetzt haben, sind schreibende Zugriffe
	auf rohe Ger&auml;te verboten und die speziellen
	<command>chflags</command> Optionen, wie <literal>schg</literal>
	werden erzwungen.  Sie m&uuml;ssen sicherstellen, dass die
	<literal>schg</literal> Option auf allen kritischen Programmen,
	Verzeichnissen und Skripten, die bis zum Setzen der Option laufen,
	aktiviert ist.  Das mag &uuml;bertrieben sein da eine Migration
	des Systems erschwert wird, wenn Sie auf einer h&ouml;heren
	Sicherheitsstufe arbeiten.  Sie k&ouml;nnen einen Kompromiss
	erreichen, indem Sie das System auf einer erh&ouml;hten
	Sicherheitsstufe laufen lassen, aber die <literal>schg</literal>
	Option nicht f&uuml;r jede Datei und jedes Verzeichnis auf der Welt
	setzen.  Eine andere M&ouml;glichkeit besteht darin,
	<filename>/</filename> und <filename>/usr</filename> einfach
	schreibgesch&uuml;tzt einzuh&auml;ngen.  Bedenken Sie, dass
	Sie das Aufdecken eines Einbruchs vielleicht verhindern, wenn
	Sie zu drastische Ma&szlig;nahmen zum Schutz Ihres Systems
	verwenden.</para>
    </sect2>

    <sect2 id="security-integrity">
      <title>&Uuml;berpr&uuml;fen der Integrit&auml;t von Dateien</title>

      <para>Sie k&ouml;nnen die Systemkonfiguration und die Dateien
	nur so weit sch&uuml;tzen, wie es die Benutzbarkeit des
	Systems nicht einschr&auml;nkt.  Wenn Sie zum Beispiel
	mit <command>chflags</command> die Option <literal>schg</literal>
	auf die meisten Dateien in <filename>/</filename> und
	<filename>/usr</filename> setzen, kann das Ihre Arbeit mehr behindern
	als n&uuml;tzen.  Die Ma&szlig;nahme sch&uuml;tzt zwar die
	Dateien, schlie&szlig;t aber auch eine M&ouml;glichkeit,
	Ver&auml;nderungen zu entdecken, aus.  Die letzte Schicht des
	Sicherheitsmodells &ndash; das Aufdecken von Einbr&uuml;chen &ndash;
	ist sicherlich die wichtigste.  Alle Sicherheitsma&szlig;nahmen sind
	nichts wert, oder wiegen Sie in falscher Sicherheit, wenn Sie
	nicht in der Lage sind, einen m&ouml;glichen Einbruch zu entdecken.
	Die H&auml;lfte der Sicherheitsma&szlig;nahmen hat die Aufgabe,
        einen Einbruch zu verlangsamen, um es zu erm&ouml;glichen, den
	Einbrecher auf frischer Tat zu ertappen.</para>

      <para>Der beste Weg, einen Einbruch zu entdecken, ist es, nach
	ver&auml;nderten, fehlenden oder unerwarteten Dateien zu suchen.
	Der wiederum beste Weg, nach ver&auml;nderten Dateien zu suchen, ist
	es, die Suche von einem anderen (oft zentralen) besonders
	gesch&uuml;tzten System durchzuf&uuml;hren.  Es ist wichtig, dass
	Ihre Sicherheits&uuml;berpr&uuml;fungen vor einem Angreifer
	verborgen bleiben und daher sind sie auf einem besonders
	gesch&uuml;tzten System gut aufgehoben.  Um dies optimal auszunutzen,
	m&uuml;ssen Sie dem besonders gesch&uuml;tzten System Zugriffsrechte
	auf die zu sch&uuml;tzenden Systeme geben.  Sie k&ouml;nnen die
	Dateisysteme der zu sch&uuml;tzenden Systeme schreibgesch&uuml;tzt
	f&uuml;r das besonders gesch&uuml;tzte System exportieren, oder
	Sie k&ouml;nnen der besonders gesch&uuml;tzten Maschine
	<application>ssh</application> auf die anderen Maschinen erlauben,
	indem Sie <application>ssh</application> Schl&uuml;sselpaare
	installieren.  Mit Ausnahme des verursachten Netzwerkverkehrs
	ist die NFS-Methode die am wenigsten sichtbare.  Sie erlaubt es Ihnen,
	nahezu unentdeckt die Dateisysteme der Clients zu beobachten.  Wenn
	Ihr besonders gesch&uuml;tztes System mit den Clients &uuml;ber
	einen Switch verbunden ist, ist die NFS-Methode oft das Mittel der
	Wahl.  Wenn das besonders gesch&uuml;tzte System allerdings
	mit einem Hub verbunden ist, oder der Zugriff &uuml;ber mehrere
	Router geschieht, ist die NFS-Methode aus der Netzwerksicht zu
	unsicher.  In einem solchen Fall ist <application>ssh</application>
	besser geeignet, auch wenn es deutliche Spuren
	hinterl&auml;sst.</para>

      <para>Wenn das besonders gesch&uuml;tzte System lesenden Zugriff
        auf die Clients hat, m&uuml;ssen Sie Skripten schreiben, die die
	&Uuml;berwachung durchf&uuml;hren.  Wenn Sie die NFS-Methode
	verwenden, k&ouml;nnen Sie dazu einfache Systemwerkzeuge wie
	&man.find.1; und &man.md5.1; benutzen.  Am besten berechnen
	Sie einmal am Tag MD5-Pr&uuml;fsummen der Dateien, Konfigurationsdateien
	in <filename>/etc</filename> und <filename>/usr/local/etc</filename>
	sollten &ouml;fter &uuml;berpr&uuml;ft werden.  Wenn Unstimmigkeiten
	zwischen den auf der besonders gesch&uuml;tzten Maschine gehaltenen
	MD5-Pr&uuml;fsummen und den ermittelten Pr&uuml;fsummen festgestellt
	werden, sollte Ihr System einen Systemadministrator benachrichtigen,
	der den Unstimmigkeiten dann nachgehen sollte.  Ein gutes Skript
	&uuml;berpr&uuml;ft das System auch auf verd&auml;chtige
	SUID-Programme sowie gel&ouml;schte oder neue Dateien in
	<filename>/</filename> und <filename>/usr</filename>.</para>

      <para>Wenn Sie <application>ssh</application> anstelle von NFS
	benutzen, wird das Erstellen der Skripten schwieriger.  Sie m&uuml;ssen
	die Skripten und die Programme wie <command>find</command> mit
	<command>scp</command> auf den Client kopieren.  Damit machen
	Sie die &Uuml;berpr&uuml;fung f&uuml;r einen Angreifer sichtbar.
	Au&szlig;erdem kann der <command>ssh</command>-Client auf dem
	Zielsystem schon kompromittiert sein.  Zusammenfassend, kann der
	Einsatz von <application>ssh</application> n&ouml;tig sein,
	wenn Sie &uuml;ber ungesicherte Verbindungen arbeiten, aber
	der Umgang mit dieser Methode ist auch sehr viel schwieriger.</para>

      <para>Ein gutes Sicherheitsskript wird auch Dateien von Benutzern,
	die den Zugriff auf ein System erm&ouml;glichen, wie
	<filename>.rhosts</filename>, <filename>.shosts</filename>,
	<filename>.ssh/authorized_keys</filename> usw., auf
	Ver&auml;nderungen untersuchen, die &uuml;ber die M&ouml;glichkeiten
	einer &Uuml;berpr&uuml;fung mit <literal>MD5</literal>,
	die ja nur Ver&auml;nderungen feststellen kann, hinausgehen.</para>

      <para>Wenn Sie &uuml;ber gro&szlig;e Partitionen verf&uuml;gen, kann
	es zu lange dauern, jede Datei zu &uuml;berpr&uuml;fen.  In diesem
	Fall sollten Sie beim Einh&auml;ngen des Dateisystems Optionen
	setzen, die das Ausf&uuml;hren von SUID-Programmen und den
	Zugriff auf Ger&auml;te verbieten.  &man.mount.8; stellt dazu
	die Optionen <option>nodev</option> und <option>nosuid</option>
	zur Verf&uuml;gung.  Sie sollten diese Dateien aber trotzdem
	mindestens einmal die Woche &uuml;berpr&uuml;fen, da das Ziel
	dieser Schicht das Aufdecken eines Einbruchs, auch wenn er nicht
	erfolgreich war, ist.</para>

      <para>Die Prozess&uuml;berwachung (siehe &man.accton.8;)
	des Betriebssystems steht ein g&uuml;nstiges Werkzeug zur
	Verf&uuml;gung, dass sich bei der Analyse eines Einbruchs
	als n&uuml;tzlich erweisen kann.  Insbesondere k&ouml;nnen Sie
	damit herausfinden, wie der Einbrecher in das System eingedrungen ist,
	vorausgesetzt die Dateien der Prozess&uuml;berwachung sind
	noch alle intakt.</para>

      <para>Schlie&szlig;lich sollten die Sicherheitsskripten die Logdateien
	analysieren.  Dies sollte so sicher wie m&ouml;glich durchgef&uuml;hrt
	werden, n&uuml;tzlich ist das Schreiben von Logdateien auf
	entfernte Systeme mit <command>syslog</command>.  Ein Einbrecher
	wird versuchen, seine Spuren zu verwischen.  Die Logdateien
	sind wichtig f&uuml;r den Systemadministrator, da er aus ihnen
	den Zeitpunkt und die Art des Einbruchs bestimmen kann.  Eine
	M&ouml;glichkeit, die Logdateien unver&auml;ndert aufzuheben,
	ist es, die Systemkonsole auf einen seriellen Port zu legen
	und die Informationen dort von einer gesicherten Maschine
	auszulesen.</para>
    </sect2>

    <sect2>
      <title>Paranoia</title>

      <para>Es schadet nicht, ein bisschen paranoid zu sein.
	Grunds&auml;tzlich darf ein Systemadministrator jede
	Sicherheitsma&szlig;nahme treffen, die die Bedienbarkeit des
	Systems nicht einschr&auml;nkt.  Er kann auch Ma&szlig;nahmen
	treffen, die die Bedienbarkeit einschr&auml;nken,
	wenn er diese vorher genau durchdacht hat.  Was noch wichtiger
	ist: Halten Sie sich nicht sklavisch an dieses Dokument, sondern
	f&uuml;hren Sie eigene Ma&szlig;nahmen ein, um nicht einem
	k&uuml;nftigen Angreifer, der auch Zugriff auf dieses Dokument
	hat, alle Ihre Methoden zu verraten.</para>
    </sect2>

    <sect2>
      <title>Denial of Service Angriffe</title>
      <indexterm><primary>Denial of Service (DoS)</primary></indexterm>

      <para>Dieser Abschnitt behandelt Denial of Service Angriffe (DoS).
	Ein DoS-Angriff findet typischerweise auf der Paketebene statt.
	W&auml;hrend Sie nicht viel gegen moderne Angriffe mit falschen
	Paketen, die das Netzwerk s&auml;ttigen, ausrichten k&ouml;nnen,
	k&ouml;nnen Sie allerdings den Schaden in der Hinsicht begrenzen,
	dass Ihre Server von einem solchen Angriff nicht gestoppt
	werden.</para>

      <orderedlist>
	<listitem>
	  <para>Begrenzen von <function>fork()</function> Aufrufen.</para>
	</listitem>

	<listitem>
	  <para>Begrenzen von Sprungbrett-Angriffen (ICMP response Angriffen,
	    <application>ping</application> zu Broadcast-Adressen usw.).</para>
	</listitem>

	<listitem>
	  <para>Kernel-Cache f&uuml;r Routen.</para>
	</listitem>
      </orderedlist>

      <para>Ein h&auml;ufiger DoS-Angriff gegen forkende Server versucht
	den Server dazu zu bringen, m&ouml;glichst viele Prozesse, viele
	Dateideskriptoren und viel Speicher zu verbrauchen, bis hin zu
	dem Punkt, an dem die Maschine ausf&auml;llt.  &man.inetd.8;
	besitzt einige Optionen, um diese Art von Angriffen zu begrenzen.
	Beachten Sie bitte, dass es m&ouml;glich ist, einen
	Ausfall einer Maschine zu verhindern, doch ist es generell nicht
	m&ouml;glich, den Ausfall eines Dienstes bei dieser Art
	von Angriffen zu verhindern.  Lesen Sie sich bitte die Manualpages
	von <application>inetd</application> gut durch und achten Sie speziell
	auf die Optionen <option>-c</option>, <option>-C</option> und
	<option>-R</option>.  Angriffe mit gef&auml;lschten IP-Adressen
	umgehen <option>-C</option>, so dass normalerweise eine
	Kombination der Optionen benutzt werden muss.  Manche Server,
	die nicht von <application>inetd</application> gestartet werden,
	besitzen Optionen, um den Start &uuml;ber <function>fork()</function>
	einzuschr&auml;nken.</para>

      <para><application>Sendmail</application> besitzt die Option
	<option>-OMaxDaemonChildren</option>, die besser als die
	eingebauten Optionen zur Begrenzung der Systemauslastung funktioniert.
	Sie sollten beim Start von <application>sendmail</application>
	<literal>MaxDaemonChildren</literal> so hoch setzen, dass Sie
	die erwartete Auslastung gut abfangen k&ouml;nnen.  Allerdings
	sollten Sie den Wert nicht so hoch setzen, dass der
	Rechner &uuml;ber seine eigenen F&uuml;&szlig;e f&auml;llt.
	Es ist auch klug, <application>sendmail</application> im
	Queue-Modus (<option>-ODeliveryMode=queued</option>) laufen zu
	lassen.  Der D&aelig;mon (<command>sendmail -bd</command>) sollte
	getrennt von den Queue-L&auml;ufen (<command>sendmail -q15m</command>)
	laufen.  Wenn Sie trotzdem eine sofortige Auslieferung der Post
	w&uuml;nschen, k&ouml;nnen Sie die Queue in einem geringeren
	Intervall, etwa <option>-q1m</option>, abarbeiten.  Geben Sie
	f&uuml;r <emphasis>dieses</emphasis>
	<application>sendmail</application> aber einen vern&uuml;nftigen
	Wert f&uuml;r <literal>MaxDaemonChildren</literal> an, um
	Fehler zu verhindern.</para>

      <para><application>Syslogd</application> kann direkt angegriffen
	werden.  Daher empfehlen wir Ihnen unbedingt die Option
	<option>-s</option> zu benutzen.  Sollte das nicht m&ouml;glich
	sein, benutzen Sie bitte <option>-a</option>.

      <para>Vorsicht ist auch mit Diensten geboten, die automatisch
	eine R&uuml;ckverbindung er&ouml;ffnen, wie der
	reverse-identd der <application>tcpwrapper</application>.
        Diese Funktion der <application>tcpwrapper</application>
	sollten Sie normalerweise nicht benutzen.</para>

      <para>Es empfiehlt sich sehr, interne Dienste vor externen Zugriffen
	durch eine Firewall an der Grenze Ihres Netzwerks zu sch&uuml;tzen.
	Dahinter steckt mehr die Idee, das Netzwerk vor &Uuml;berlastung
	durch Angriffe von au&szlig;en zu sch&uuml;tzen, als interne
	Dienste vor einem <username>root</username>-Zugriff aus dem Netz
	zu sch&uuml;tzen.  Konfigurieren Sie immer eine Firewall, die
	alle Zugriffe blockiert, das hei&szlig;t blockieren Sie
	<emphasis>alles</emphasis> au&szlig;er den Ports A, B, C, D
	und M-Z.  Damit k&ouml;nnen Sie Zugriffe auf alle niedrigen
	Ports blockieren und Zugriffe auf spezielle Dienste wie
	<application>named</application>, wenn Sie den prim&auml;ren
	Namensdienst f&uuml;r eine Zone anbieten,
	<application>ntalkd</application> oder
	<application>sendmail</application> erlauben.  Wenn Sie die
	Firewall so konfigurieren, das sie in der Voreinstellung alle
	Zugriffe erlaubt, ist es sehr wahrscheinlich, dass Sie
	vergessen, eine Reihe von Diensten zu blockieren bzw. einen
	internen Dienst einf&uuml;hren und dann vergessen die Firewall
	zu aktualisieren.  Sie k&ouml;nnen immer die h&ouml;heren
	Portnummern &ouml;ffnen, ohne die niedrigen Portnummern,
	die nur von <username>root</username> benutzt werden d&uuml;rfen,
	zu kompromittieren.  Beachten Sie bitte auch, dass es
	FreeBSD erlaubt, die Portnummern, die f&uuml;r dynamische
	Verbindungen zur Verf&uuml;gung stehen, zu konfigurieren.
	Mit <command>sysctl</command> lassen sich verschiedene
	Bereiche der <varname>net.inet.ip.portrange</varname> Variablen
	setzen (eine Liste erhalten Sie mit <command>sysctl -a | fgrep
	portrange</command>).
	So k&ouml;nnen Sie zum Beispiel die Portnummern 4000 bis 5000
	f&uuml;r den normalen Bereich und die Nummern 49152 bis 65535
	f&uuml;r den hohen Bereich vorsehen.  Dies erleichtert Ihnen
	die Konfiguration der Firewall, da Sie nun Zugriffe auf Ports
	unterhalb von 4000, mit Ausnahme der Dienste, die von au&szlig;en
	erreichbar sein sollen, blockieren k&ouml;nnen.</para>

      <indexterm><primary>ICMP_BANDLIM</primary></indexterm>

      <para>Eine andere Form eines DoS-Angriffs nutzt einen Server
	als Sprungbrett, der Server wird dabei so angegriffen, dass
	seine Antworten ihn selber, das lokale Netzwerk oder einen
	anderen Server &uuml;berlasten.  Der am h&auml;ufigsten verwendete
	Angriff dieser Art ist der <emphasis>ICMP ping broadcast
	Angriff</emphasis>.  Der Angreifer f&auml;lscht dazu
	<application>ping</application>-Pakete, die zu der Broadcast-Adresse
	Ihres LANs gesendet werden, indem er darin als Quelladresse
	die Adresse des Opfers einsetzt.  Wenn die Router an der Grenze
	Ihres Netzwerks <application>ping</application>-Pakete auf
	Broadcast-Adressen nicht abwehren, wird Ihr LAN gen&uuml;gend
	Netzwerkverkehr generieren, um das Ziel des Angriffs zu
	&uuml;berlasten.  Dies kann besonders effektiv sein, wenn der
	Angreifer diese Methode mit mehreren Dutzend Broadcast-Adressen
	&uuml;ber mehrere Netzwerke einsetzt.  Es wurden schon
	Broadcast-Angriffe mit &uuml;ber 120&nbsp;Megabit pro Sekunde
	gemessen.  Ein zweiter Sprungbrett-Angriff wird gegen
	das Fehlerbehandlungssystem von ICMP eingesetzt.  Indem ein Angreifer
	Pakete konstruiert, die eine ICMP-Fehlermeldung hervorrufen, kann
	er das einkommende Netzwerk des Servers s&auml;ttigen und diesen
	wiederum veranlassen sein ausgehendes Netzwerk mit ICMP-Antworten
	zu s&auml;ttigen.  Diese Art des Angriffs kann alle mbuf-Strukturen
	auf dem Server aufbrauchen und damit den Server stilllegen,
	insbesondere wenn der Server nicht in der Lage ist, die generierten
	ICMP-Antworten schnell genug abzuf&uuml;hren.  Der FreeBSD-Kernel
	besitzt eine neue Option <option>ICMP_BANDLIM</option>, die die
	Auswirkungen von solchen Angriffen begrenzen kann.  Die letzte
	weit verbreitete Form von Sprungbrett-Angriffen verwendet
	interne <application>inetd</application>-Dienste wie den
	UDP <application>echo</application>-Dienst.  Der Angreifer f&auml;lscht
	dazu einfach ein UDP-Paket, indem er als Quellport den
	<application>echo</application>-Port von Server A
	und als Zielport den <application>echo</application>-Port von
	Server B angibt, wobei beide
	Server in Ihrem LAN stehen.  Die beiden Server werden nun
        dieses Paket zwischen sich hin und her schicken.  Der Angreifer
	kann die beiden Server und das LAN einfach damit &uuml;berlasten,
	dass er mehrere Pakete dieser Art generiert.  &Auml;hnliche
	Probleme gibt es mit dem internen
	<application>chargen</application>-Port, daher sollten Sie
	die internen <application>inetd</application>-Testdienste
	abstellen.</para>

      <para>Gef&auml;lschte IP-Pakete k&ouml;nnen dazu benutzt werden,
	den Kernel-Cache f&uuml;r Routen zu &uuml;berlasten.  Schauen Sie
	sich bitte die  <command>sysctl</command>-Parameter
	<varname>net.inet.ip.rtexpire</varname>, <varname>rtminexpire</varname>
	und <varname>rtmaxcache</varname> an.  Ein Angriff der gef&auml;lschte
	Pakete mit zuf&auml;lligen Quelladressen einsetzt, bewirkt, dass
	der Kernel eine Route im Route-Cache anlegt, die Sie sich mit
	<command>netstat -rna | fgrep W3</command> ansehen k&ouml;nnen.
	Diese Routen verfallen f&uuml;r gew&ouml;hnlich nach 1600 Sekunden.
	Wenn der Kernel feststellt, dass die Routingtabelle im Cache
	zu gro&szlig; geworden ist, wird er dynamisch den Wert von
	<varname>rtexpire</varname> verringern.  Dieser Wert wird aber nie
	kleiner werden als <varname>rtminexpire</varname>.  Daraus
	ergeben sich zwei Probleme:</para>

      <orderedlist>
	<listitem>
	  <para>Der Kernel reagiert nicht schnell genug, wenn ein
	    Server mit einer niedrigen Grundlast pl&ouml;tzlich angegriffen
	    wird.</para>
	</listitem>

	<listitem>
	  <para><varname>rtminexpire</varname> ist nicht klein genug,
	    um einen anhaltenden Angriff zu &uuml;berstehen.</para>
	</listitem>
      </orderedlist>

      <para>Wenn Ihre Server &uuml;ber eine T3 oder eine noch schnellere
	Leitung mit dem Internet verbunden sind, ist es klug, mit
        &man.sysctl.8; die Werte f&uuml;r <varname>rtexpire</varname> und
	<varname>rtminexpire</varname> h&auml;ndisch zu setzen.  Setzen
	Sie bitte keinen der Werte auf Null, au&szlig;er Sie wollen die
	Maschine zum Erliegen bringen.  Ein Wert von 2&nbsp;Sekunden f&uuml;r
	beide Parameter sollte ausreichen, um die Routingtabelle vor
	einem Angriff zu sch&uuml;tzen.</para>
    </sect2>

    <sect2>
      <title>Anmerkungen zum Zugriff mit Kerberos und ssh</title>
      <indexterm><primary><command>ssh</command></primary></indexterm>
      <indexterm><primary>Kerberos</primary></indexterm>

      <para>Es gibt ein paar Punkte, die Sie beachten sollten, wenn Sie
	<application>Kerberos</application> oder <application>ssh</application>
	einsetzen wollen.  <application>Kerberos V</application> ist ein
	ausgezeichnetes Authentifizierungsprotokoll.  Leider gibt es
	Fehler, in den f&uuml;r <application>Kerberos</application>
	angepassten Versionen von <application>telnet</application> und
	<application>rlogin</application>, die sie ungeeignet f&uuml;r den
	Umgang mit bin&auml;ren Datenstr&ouml;men machen.  Weiterhin
	verschl&uuml;sselt <application>Kerberos</application> Ihre Sitzung
	nicht, wenn Sie nicht die <option>-x</option> Option verwenden,
	mit <application>ssh</application> wird dagegen alles
	verschl&uuml;sselt.</para>

      <para>Ein Problem mit SSH sind Weiterleitungen von Verbindungen.
	Wenn Sie von einer sicheren Maschine, auf der sich Ihre
	Schl&uuml;ssel  befinden, eine Verbindung zu einer
	ungesicherten Maschine aufmachen, wird f&uuml;r die Dauer der
	Sitzung ein Port f&uuml;r Weiterleitungen ge&ouml;ffnet.
	Ein Angreifer, der auf der unsicheren Maschine Zugang zu
	<username>root</username> hat, kann diesen Port
	benutzen, um Zugriff auf andere Maschinen zu
	erlangen, die mit Ihren Schl&uuml;sseln zug&auml;nglich
	sind.</para>

      <para>Wir empfehlen Ihnen, f&uuml;r die Logins Ihrer Mitarbeiter immer
	<application>ssh</application> zusammen mit
	<application>Kerberos</application> einzusetzen.  Damit reduzieren
	Sie die Abh&auml;ngigkeit von potentiell gef&auml;hrdeten
	Schl&uuml;sseln und sch&uuml;tzen gleichzeitig die Passw&ouml;rter
	mit <application>Kerberos</application>.
	<application>ssh</application>-Schl&uuml;sselpaare sollten nur
	f&uuml;r automatisierte Aufgaben von einem besonders gesicherten
	Server eingesetzt werden (<application>Kerberos</application>
	kann f&uuml;r diese Art von Aufgaben nicht eingesetzt werden).
	Weiterhin empfehlen wir Ihnen, das Weiterreichen von Schl&uuml;sseln
	in der <application>ssh</application>-Konfiguration abzustellen bzw.
	die <literal>from=IP/DOMAIN</literal> Option in
	<filename>authorized_keys</filename> zu verwenden, die den
	Schl&uuml;ssel nur von bestimmten Maschinen aus nutzbar macht.</para>
    </sect2>
  </sect1>

  <sect1 id="crypt">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Swingle</surname>
	  <contrib>Teile umgeschrieben und aktualisiert von </contrib>
	</author>
      </authorgroup>
      <!-- 21 Mar 2000 -->
    </sect1info>

    <title>DES, MD5, und <function>crypt()</function></title>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary><function>crypt()</function></secondary>
    </indexterm>

    <indexterm><primary><function>crypt()</function></primary></indexterm>
    <indexterm><primary>DES</primary></indexterm>
    <indexterm><primary>MD5</primary></indexterm>

    <para>Jedem Benutzer eines &unix; Systems ist ein Passwort zugeordnet.
      Es scheint offensichtlich, dass das Passwort nur dem Benutzer
      und dem System bekannt sein muss.  Um die Passw&ouml;rter
      geheim zu halten, werden sie mit einer nicht umkehrbaren Hash-Funktion
      verschl&uuml;sselt, das hei&szlig;t sie k&ouml;nnen leicht
      verschl&uuml;sselt aber nicht entschl&uuml;sselt werden.  Was wir
      gerade als offensichtlich dargestellt haben, ist also nicht wahr: Das
      Betriebssystem kennt das Passwort <emphasis>wirklich</emphasis>
      nicht, es kennt nur das <emphasis>verschl&uuml;sselte</emphasis>
      Passwort.  Die einzige M&ouml;glichkeit, das originale Passwort
      herauszufinden, besteht darin, alle m&ouml;glichen Passw&ouml;rter
      auszuprobieren (<foreignphrase>brute force</foreignphrase> Suche).</para>

    <para>Zu der Zeit als &unix; entstanden ist, war die einzig sichere
      M&ouml;glichkeit Passw&ouml;rter zu verschl&uuml;sseln, leider
      DES (Data Encryption Standard).  F&uuml;r die Einwohner der USA
      stellte das kein Problem dar, aber da der Quellcode von DES nicht aus
      den USA exportiert werden durfte, musste ein Weg gefunden werden,
      der die Gesetze der USA nicht verletzte und gleichzeitig die
      Kompatibilit&auml;t mit anderen &unix; Systemen, die immer noch DES
      benutzten, wahrte.</para>

    <para>Die L&ouml;sung bestand darin, die Verschl&uuml;sselungsbibliotheken
      aufzuspalten.  Benutzer in den USA konnten die DES-Bibliotheken
      installieren und nutzen.  In der Grundeinstellung benutzt FreeBSD
      MD5 als Verschl&uuml;sselungsmethode, das exportiert werden durfte
      und damit von jedem genutzt werden konnte.  Es wird davon ausgegangen,
      dass MD5 sicherer als DES ist, so dass DES nur aus
      Kompatibilit&auml;tsgr&uuml;nden installiert werden sollte.</para>

    <sect2>
      <title>Erkennen der Verschl&uuml;sselungsmethode</title>

      <para>Vor FreeBSD&nbsp;4.4 war <filename>libcrypt.a</filename> ein
        symbolischer Link, der auf die Library zeigte, die die
	Verschl&uuml;sselungsroutinen enthielt.  Seit FreeBSD&nbsp;4.4 enth&auml;lt
	<filename>libcrypt.a</filename> verschiedene Hash-Funktionen, deren
	Anwendung sich konfigurieren l&auml;sst.  Momentan werden
	DES-, MD5- und Blowfish-Hash Funktionen unterst&uuml;tzt.  In der
	Voreinstellung benutzt FreeBSD die MD5-Hash Funktion.</para>

      <para>Sie k&ouml;nnen leicht herausfinden, welche
	Verschl&uuml;sselungsmethode von FreeBSD verwendet wird.  Ein Weg
	besteht darin, die verschl&uuml;sselten Passw&ouml;rter in
	<filename>/etc/master.passwd</filename> zu untersuchen.
	Passw&ouml;rter, die mit MD5 verschl&uuml;sselt wurden,
	sind l&auml;nger als die mit DES verschl&uuml;sselten und
	beginnen mit den Zeichen <literal>&dollar;1&dollar;</literal>.
	Passw&ouml;rter, die mit <literal>&dollar;2&dollar;</literal>
	anfangen, wurden mit der Blowfish-Funktion verschl&uuml;sselt.
	DES Passw&ouml;rter besitzen keine offensichtlichen Merkmale,
	an denen sie identifiziert werden k&ouml;nnten.  Sie sind aber
	k&uuml;rzer als MD5-Passw&ouml;rter und sind in einem
	64 Zeichen umfassenden Alphabet kodiert, das das
	<literal>&dollar;</literal>-Zeichen nicht enth&auml;lt.  Ein relativ
	kurzes Passwort, das nicht mit einem
	<literal>&dollar;</literal>-Zeichen anf&auml;ngt, ist wahrscheinlich
	ein DES-Passwort.</para>

      <para>Die Verschl&uuml;sselungsmethode f&uuml;r neue
        Passw&ouml;rter wird durch <option>passwd_format</option> in
	<filename>/etc/login.conf</filename> bestimmt.  Der Wert dieser
	Variablen kann entweder <literal>des</literal>, <literal>md5</literal>
	oder <literal>blf</literal> sein.  N&auml;heres schlagen Sie bitte
	in &man.login.conf.5; nach.</para>
    </sect2>
  </sect1>

  <sect1 id="skey">
    <title>S/Key</title>
    <indexterm><primary>S/Key</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>S/Key</secondary>
    </indexterm>

    <para>S/Key ist ein Einmal-Passwort System, das auf einer nicht
      umkehrbaren Hash-Funktion basiert.  Aus Kompatibilit&auml;tsgr&uuml;nden
      benutzt FreeBSD MD4-Hashes, andere Systeme benutzen MD5 und DES-MAC.
      S/Key ist seit Version 1.1.5 Teil des FreeBSD Basissystems und wird
      auch auf einer wachsenden Anzahl anderer Systeme benutzt.  S/Key
      ist eine gesch&uuml;tzte Warenmarke von
      Bell Communications Research, Inc.</para>

    <para>Ab der FreeBSD Version 5.0 wurde S/Key durch OPIE
      (Onetime Passwords In Everything), das die gleichen Funktionen
      bietet, abgel&ouml;st.  OPIE benutzt MD5 Hash-Funktionen.</para>

    <para>In der folgenden Diskussion werden drei verschiedene
      Passw&ouml;rter verwendet.  Das Erste ist Ihr normales System- oder
      Kerberos-Passwort und wird im Folgenden <quote>System-Passwort</quote>
      genannt.  Das Zweite ist das Einmal-Passwort, das bei S/Key
      von <command>key</command> oder bei OPIE von
      <command>opiekey</command> generiert wird.  Dieses Passwort wird von
      den Programmen <command>keyinit</command> oder
      <command>opiepasswd</command> und dem Login-Programm akzeptiert.  Im
      Folgenden wird es <quote>Einmal-Passwort</quote> genannt.  Das Dritte
      Passwort ist das geheime Passwort, das Sie mit den Programmen
      <command>key</command>/<command>opiekey</command> (manchmal auch mit
      <command>keyinit</command>/<command>opiepasswd</command>) zum Erstellen
      der Einmal-Passw&ouml;rter verwenden.  Dieses Passwort
      werden wir im Folgenden <quote>geheimes Passwort</quote>
      oder schlicht <quote>Passwort</quote> nennen.</para>

    <para>Das geheime Passwort steht in keiner Beziehung zu Ihrem
      System-Passwort, beide k&ouml;nnen gleich sein, obwohl das nicht
      empfohlen wird.  Die geheimen Passw&ouml;rter von S/Key oder
      OPIE sind nicht auf eine L&auml;nge von 8&nbsp;Zeichen beschr&auml;nkt.
      Sie k&ouml;nnen so lang sein, wie Sie wollen.  Gebr&auml;uchlich sind
      Passw&ouml;rter, die sich aus sechs bis sieben W&ouml;rtern
      zusammensetzen.  Das S/Key oder OPIE System arbeitet
      gr&ouml;&szlig;tenteils unabh&auml;ngig von den
      auf &unix; Systemen verwendeten Passwort-Mechanismen.</para>

    <para>Neben dem Passwort gibt es noch zwei Werte, die f&uuml;r
      S/Key und OPIE wichtig sind.  Der erste ist der
      <quote>Initialwert</quote> (engl. <foreignphrase>seed</foreignphrase>
      oder <foreignphrase>key</foreignphrase>), der aus zwei Buchstaben
      und f&uuml;nf Ziffern besteht.  Der andere Wert ist der
      <quote>Iterationsz&auml;hler</quote>, der eine Zahl zwischen
      1 und 100 ist.  S/Key generiert das Einmal-Passwort, indem
      es den Initialwert und das geheime Passwort aneinander h&auml;ngt
      und dann die MD4/MD5 Hash-Funktion so oft, wie durch den
      Iterationsz&auml;hler gegeben, anwendet.  Das Ergebnis wird in
      sechs englische W&ouml;rter umgewandelt, die Ihr Einmal-Passwort
      sind.  Das Authentifizierungssystem (meistens PAM) merkt sich das
      zuletzt benutzte Einmal-Passwort und Sie sind authentisiert,
      wenn die Hash-Funktion des Passworts dem vorigen Passwort
      entspricht.  Da nicht umkehrbare Hash-Funktionen benutzt werden,
      ist es unm&ouml;glich, aus einem bekannten Passwort weitere
      g&uuml;ltige Einmal-Passw&ouml;rter zu berechnen.  Der
      Iterationsz&auml;hler wird nach jeder erfolgreichen Anmeldung um
      eins verringert und stellt so die Synchronisation zwischen Benutzer
      und Login-Programm sicher.  Wenn der Iterationsz&auml;hler den
      Wert 1 erreicht, m&uuml;ssen S/Key und OPIE neu initialisiert
      werden.</para>

    <para>In jedem System werden drei Programme verwendet, die weiter unten
      beschrieben werden.  Die Programme <command>key</command> und
      <command>opiekey</command> verlangen einen Iterationsz&auml;hler,
      einen Initialwert und ein geheimes Passwort.  Daraus generieren
      sie ein Einmal-Passwort oder eine Liste von
      Einmal-Passw&ouml;rtern.  Die Programme <command>keyinit</command>
      und <command>opiepasswd</command> werden benutzt, um S/Key bzw.
      OPIE zu initialisieren.  Mit ihnen k&ouml;nnen Passw&ouml;rter,
      Iterationsz&auml;hler oder Initialwerte ge&auml;ndert werden.
      Als Parameter verlangen sie entweder ein geheimes Passwort
      oder einen Iterationsz&auml;hler oder einen Initialwert und ein
      Einmal-Passwort.  Die Programme <command>keyinfo</command>
      und <command>opieinfo</command> geben den momentanen
      Iterationsz&auml;hler und Initialwert eines Benutzers aus.  Diese
      werden aus den Dateien <filename>/etc/skeykeys</filename> bzw.
      <filename>/etc/opiekeys</filename> ermittelt.</para>
      <!-- Credential Dateien -->

    <para>Im Folgenden werden vier verschiedene T&auml;tigkeiten beschrieben.
      Zuerst wird erl&auml;utert, wie <command>keyinit</command> oder
      <command>opiepasswd</command> &uuml;ber eine gesicherte Verbindung
      eingesetzt werden, um Einmal-Passw&ouml;rter das erste Mal
      zu konfigurieren oder das Passwort oder den Initialwert
      zu &auml;ndern.  Als n&auml;chstes wird erkl&auml;rt, wie
      <command>keyinit</command> oder <command>opiepasswd</command>
      &uuml;ber eine nicht gesicherte Verbindung, zusammen mit
      <command>key</command> oder <command>opiekey</command> &uuml;ber eine
      gesicherte Verbindung, eingesetzt werden, um dasselbe zu erreichen.
      Als drittes wird beschrieben, wie
      <command>key</command>/<command>opiekey</command> genutzt werden,
      um sich &uuml;ber eine nicht gesicherte Verbindung anzumelden.
      Die vierte T&auml;tigkeit beschreibt, wie mit <command>key</command>
      oder <command>opiekey</command> eine Reihe von Schl&uuml;sseln
      generiert werden, die Sie sich aufschreiben oder ausdrucken k&ouml;nnen,
      um sich von Orten anzumelden, die &uuml;ber keine gesicherten
      Verbindungen verf&uuml;gen.</para>

    <sect2>
      <title>Einrichten &uuml;ber eine gesicherte Verbindung</title>

      <para>Benutzen Sie <command>keyinit</command> um S/Key das erste
	Mal einzurichten, das Passwort oder den Initialwert
	zu &auml;ndern, w&auml;hrend Sie &uuml;ber eine gesicherte
	Verbindung, das hei&szlig;t an der Konsole oder &uuml;ber ssh
	angemeldet, sind:</para>

      <screen>&prompt.user; <userinput>keyinit</userinput>
Adding unfurl:
Reminder - Only use this method if you are directly connected.
If you are using telnet or rlogin exit with no password and use keyinit -s.
Enter secret password:
Again secret password:

ID unfurl s/key is 99 to17757
DEFY CLUB PRO NASH LACE SOFT</screen>

      <para>Mit OPIE benutzen Sie stattdessen
	<command>opiepasswd</command>:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
</screen>

      <para>Nach der Aufforderung <prompt>Enter new secret pass phrase:</prompt>
	oder <prompt>Enter secret password:</prompt> geben Sie bitte Ihr
	Passwort ein.  Dies ist nicht das Passwort, mit dem Sie sich
	anmelden, sondern es wird genutzt, um das Einmal-Passwort
	zu generieren.  Die Zeile, die mit <quote>ID</quote> anf&auml;ngt,
	enth&auml;lt Ihren Login-Namen, den Iterationsz&auml;hler und den
	Initialwert.  Diese Werte m&uuml;ssen Sie sich nicht behalten, da
	das System sie zeigen wird, wenn Sie sich anmelden.  In der letzten
	Zeile steht das Einmal-Passwort, das aus diesen Parametern
	und Ihrem geheimen Passwort ermittelt wurde.  Wenn sie sich jetzt
	wieder anmelden wollten, dann m&uuml;ssten Sie dieses
	Passwort benutzen.</para>
    </sect2>

    <sect2>
      <title>Einrichten &uuml;ber eine nicht gesicherte Verbindung</title>

      <para>Um Einmal-Passw&ouml;rter &uuml;ber eine nicht gesicherte
	Verbindung einzurichten, oder das geheime Passwort zu &auml;ndern,
        m&uuml;ssen Sie &uuml;ber eine gesicherte Verbindung zu einer Stelle
	verf&uuml;gen, an der Sie die Kommandos <command>key</command>
	oder <command>opiekey</command> ausf&uuml;hren.  Dies kann
	ein <quote>Desk Accessory</quote> auf einem Macintosh oder
	die Eingabeaufforderung auf einer Maschine, der Sie vertrauen, sein.
	Zudem m&uuml;ssen Sie einen Iterationsz&auml;hler vorgeben (100
	ist ein guter Wert) und einen Initialwert w&auml;hlen, wobei
	Sie auch einen zuf&auml;llig generierten benutzen k&ouml;nnen.
	Benutzen Sie <command>keyinit -s</command> &uuml;ber die ungesicherte
	Verbindung zu der Maschine, die Sie einrichten wollen:</para>

      <screen>&prompt.user; <userinput>keyinit -s</userinput>
Updating unfurl:
Old key: to17758
Reminder you need the 6 English words from the key command.
Enter sequence count from 1 to 9999: <userinput>100</userinput>
Enter new key [default to17759]:
s/key 100 to 17759
s/key access password:
s/key access password:<userinput>CURE MIKE BANE HIM RACY GORE</userinput>
</screen>

      <para>Mit OPIE benutzen Sie <command>opiepasswd</command>:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
</screen>

      <para>Dr&uuml;cken Sie <keycap>Return</keycap>, um die Vorgabe
	f&uuml;r den Initialwert, der von <command>keyinit</command>
	<literal>key</literal> genannt wird, zu akzeptieren.  Bevor
	Sie nun das Zugriffspasswort
	(engl. <foreignphrase>access password</foreignphrase>)
	eingeben, rufen Sie &uuml;ber die gesicherte Verbindung
	<command>key</command> mit denselben Parametern auf:</para>

      <screen>&prompt.user; <userinput>key 100 to17759</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;secret password&gt;</userinput>
CURE MIKE BANE HIM RACY GORE</screen>

      <para>Mit OPIE benutzen Sie <command>opiekey</command>:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</screen>

      <para>Gehen Sie nun zur&uuml;ck zu der nicht gesicherten Verbindung
	und geben dort das eben generierte Einmal-Passwort ein.</para>
    </sect2>

    <sect2>
      <title>Erzeugen eines einzelnen Einmal-Passwortes</title>

      <para>Nachdem Sie S/Key oder OPIE eingerichtet haben, werden Sie beim
	n&auml;chsten Anmelden wie folgt begr&uuml;&szlig;t:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: </screen>

      <para>OPIE begr&uuml;&szlig;t Sie wie folgt:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para>Anmerkung: S/Key und OPIE besitzen eine n&uuml;tzliche Eigenschaft,
	die hier nicht gezeigt ist.  Wenn Sie an der Eingabeaufforderung
	<keycap>Return</keycap> eingeben, wird die echo-Funktion eingeschaltet,
	das hei&szlig;t Sie sehen, was Sie tippen.  Dies ist besonders
	n&uuml;tzlich, wenn Sie ein generiertes Passwort von einem
	Ausdruck abtippen m&uuml;ssen.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>Jetzt m&uuml;ssen Sie Ihr Einmal-Passwort generieren,
	um der Anmeldeaufforderung nachzukommen.  Dies muss auf
	einem gesicherten System geschehen, auf dem Sie <command>key</command>
	oder <command>opiekey</command> ausf&uuml;hren k&ouml;nnen.
	Diese Programme gibt es &uuml;brigens auch f&uuml;r DOS, Windows und
	MacOS.  Beide Programme ben&ouml;tigen den Iterationsz&auml;hler
	sowie den Initialwert als Parameter, die Sie mittels
	<quote>cut-and-paste</quote> direkt von der Login Aufforderung
	nehmen k&ouml;nnen.</para>

      <para>Auf dem sicheren System:</para>

      <screen>&prompt.user; <userinput>key 97 fw13894</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password:
WELD LIP ACTS ENDS ME HAAG</screen>

      <para>Mit OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Mit dem jetzt generierten Einmal-Passwort k&ouml;nnen
	Sie die Anmeldeprozedur fortsetzen:</para>

      <screen>login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: <userinput>&lt;return to enable echo&gt;</userinput>
s/key 97 fw13894
Password [echo on]: WELD LIP ACTS ENDS ME HAAG
Last login: Tue Mar 21 11:56:41 from 10.0.0.2 ...</screen>

    </sect2>

    <sect2>
      <title>Erzeugen von mehreren Einmal-Passw&ouml;rtern</title>

      <para>Manchmal m&uuml;ssen Sie sich an Orte begeben, an denen
	Sie keinen Zugriff auf eine sichere Maschine oder eine
	sichere Verbindung haben.  In diesem Fall k&ouml;nnen Sie
	vorher mit <command>key</command> einige Einmal-Passw&ouml;rter
	generieren, die Sie sich ausdrucken und mitnehmen k&ouml;nnen.
	Zum Beispiel:</para>

      <screen>&prompt.user; <userinput>key -n 5 30 zz99999</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;secret password&gt;</userinput>
26: SODA RUDE LEA LIND BUDD SILT
27: JILT SPY DUTY GLOW COWL ROT
28: THEM OW COLA RUNT BONG SCOT
29: COT MASH BARR BRIM NAN FLAG
30: CAN KNEE CAST NAME FOLK BILK</screen>

      <para>Mit <option>-n 5</option> fordern Sie f&uuml;nf
	Passw&ouml;rter der Reihe nach an.  Der letzte
	Iterationsz&auml;hler wird durch <option>30</option> gegeben.
	Beachten Sie bitte, dass die Passw&ouml;rter in der
	<emphasis>umgekehrten</emphasis> Reihenfolge, in der sie
	zu benutzen sind, ausgeben werden.  Wenn Sie wirklich paranoid
	sind, schreiben Sie sich jetzt die Passw&ouml;rter auf,
	ansonsten drucken Sie sie mit <command>lpr</command> aus.
	Beachten Sie, dass jede Zeile den Iterationsz&auml;hler
	und das Einmal-Passwort zeigt, trotzdem finden Sie es
	vielleicht hilfreich, eine Zeile nach Gebrauch durchzustreichen.</para>
    </sect2>

    <sect2>
      <title>Einschr&auml;nken der Benutzung von
	System-Passw&ouml;rtern</title>

      <para>Basierend auf dem Hostnamen, Benutzernamen, Terminal oder
	IP-Adresse, k&ouml;nnen Sie die Verwendung von
	System-Passw&ouml;rtern einschr&auml;nken.  Die Beschr&auml;nkungen
	werden in <filename>/etc/skey.access</filename> definiert.  Die
	Manualpage &man.skey.access.5; beschreibt das Format dieser
	Datei sowie einige Vorsichtsma&szlig;nahmen,
	die Sie treffen sollten, bevor Sie diese Datei einsetzen.</para>

      <para>Wenn <filename>/etc/skey.access</filename> nicht existiert und
	das ist unter FreeBSD die Vorgabe, dann d&uuml;rfen sich alle Benutzer
	mit ihren System-Passw&ouml;rtern anmelden.  Wenn die Datei existiert,
	dann m&uuml;ssen alle Benutzer S/Key zum Anmelden benutzen.  Ausnahmen
	m&uuml;ssen explizit in <filename>skey.access</filename> konfiguriert
	werden.  In allen F&auml;llen werden System-Passw&ouml;rter
	beim Anmelden auf der Konsole erlaubt.</para>

      <para>Das folgende Beispiel zeigt die drei h&auml;ufigsten
	Ausnahmen:</para>

      <programlisting>permit internet 192.168.0.0 255.255.0.0
permit user fnord
permit port ttyd0</programlisting>

      <para>Die erste Zeile (<literal>permit internet</literal>) erlaubt
	es Benutzern, deren IP-Adresse, die immer noch gef&auml;lscht werden
	kann, mit dem angegebenen Wert und der angegebenen Maske
	&uuml;bereinstimmt, System-Passw&ouml;rter zu benutzen.  Dies
	sollte nicht als Sicherheitsmechanismus missverstanden werden,
	sondern sollte autorisierte Benutzer daran erinnern, dass sie
	ein ungesichertes Netzwerk benutzen und sich mit S/Key anmelden
	m&uuml;ssen.</para>

      <para>Die zweite Zeile (<literal>permit user</literal>) erlaubt
	es dem angegebenen Benutzer, hier <username>fnord</username>,
	jederzeit System-Passw&ouml;rter zu verwenden.  Dies sollte
	allerdings nur f&uuml;r Benutzer konfiguriert werden, die das
	<command>key</command> Programm nicht benutzen k&ouml;nnen (Leute
	mit <quote>dumb</quote> Terminals oder wirklich uneinsichtige).

      <para>Die dritte Zeile (<literal>permit port</literal>) erlaubt allen
	Benutzern, die sich an dem angegebenen Terminal anmelden,
	System-Passw&ouml;rter zu benutzen.  Sie sollte f&uuml;r
	Einw&auml;hlverbindungen genutzt werden.</para>
    </sect2>
  </sect1>

  <sect1 id="kerberos">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Murray</surname>
	  <contrib>Beigesteuert von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Dapoz</surname>
	  <contrib>Basiert auf einem Beitrag von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Kerberos</title>
    <indexterm><primary>Kerberos</primary></indexterm>

    <para>Kerberos ist ein zus&auml;tzliches Netzwerkprotokoll, das es
      Benutzern erlaubt, sich &uuml;ber einen sicheren Server zu
      authentifizieren.  Dienste wie <application>rlogin</application>,
      <application>rcp</application> oder das sichere Kopieren von Dateien
      zwischen Systemen und andere risikoreiche T&auml;tigkeiten werden
      durch Kerberos erheblich sicherer und kontrollierbarer.</para>

    <para>Die folgende Anleitung kann nur als Wegweiser dazu dienen, wie
      Sie Kerberos f&uuml;r FreeBSD konfigurieren.  F&uuml;r eine komplette
      Beschreibung des Systems, sollten Sie sich auf jeden Fall die
      entsprechenden Manualpage ansehen.</para>

    <sect2>
      <title>Installation von Kerberos</title>

      <indexterm><primary>MIT</primary></indexterm>
      <indexterm>
	<primary>Kerberos</primary>
	<secondary>Installation</secondary>
      </indexterm>
      <para>Kerberos ist eine optionale Komponente von FreeBSD.  Am leichtesten
	installieren Sie die Software, wenn Sie bei der ersten Installation
	von FreeBSD in <application>sysinstall</application> die
	Distribution 'krb4' oder 'krb5' ausw&auml;hlen.  Damit installieren
	Sie entweder die 'eBones' (KerberosIV) oder 'Heimdal' (Kerberos5)
	Version von Kerberos.  Beide Versionen werden mit FreeBSD ausgeliefert,
	da sie au&szlig;erhalb von den USA oder Kanada entwickelt werden.
	Sie unterliegen deshalb auch nicht den restriktiven
	Exportbeschr&auml;nkungen der USA und sind auch f&uuml;r
	Bewohner anderer L&auml;nder zug&auml;nglich.</para>

      <para>Als Alternative steht die MIT Variante von Kerberos in der
	Ports-Kollektion unter <filename role="package">security/krb5</filename> zur
	Verf&uuml;gung.</para>
    </sect2>

    <sect2>
      <title>Erstellen der initialen Datenbank</title>

      <para>Die folgenden Schritte werden nur auf dem Kerberos-Server
	durchgef&uuml;hrt.  Stellen Sie bitte vorher sicher, dass
	keine alten Kerberos-Datenbanken mehr vorhanden sind.  Im
	Verzeichnis <filename>/etc/kerberosIV</filename> sollten sich nur
	die folgenden Dateien befinden:</para>

      <screen>&prompt.root; <userinput>cd /etc/kerberosIV</userinput>
&prompt.root; <userinput>ls</userinput>
README		krb.conf        krb.realms</screen>

      <para>Wenn noch andere Dateien, wie <filename>principal.*</filename>
	oder <filename>master_key</filename>, existieren, m&uuml;ssen
	Sie die alte Kerberos-Datenbank mit <command>kdb_destroy</command>
	l&ouml;schen.  Wenn Kerberos nicht l&auml;uft, k&ouml;nnen Sie
	die Dateien auch einfach l&ouml;schen.</para>

      <para>Sie sollten nun die Dateien <filename>krb.conf</filename> und
	<filename>krb.realms</filename> editieren, um Ihr Kerberos-Realm zu
	definieren.  Das folgende Beispiel zeigt dies f&uuml;r das Realm
	<filename>EXAMPLE.COM</filename> auf dem Server
	<hostid role="fqdn">grunt.example.com</hostid>.
	<filename>krb.conf</filename> sollte wie folgt aussehen:</para>

      <screen>&prompt.root; <userinput>cat krb.conf</userinput>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</screen>

      <para>Die zus&auml;tzlich aufgef&uuml;hrten Realms brauchen Sie nicht
	anzulegen.  Sie zeigen hier nur, wie man Kerberos dazu bringt, andere
	Realms zu erkennen.  Sie k&ouml;nnen Sie also auch weglassen.</para>

      <para>Die erste Zeile benennt das Realm, in dem das System arbeitet.
	Die anderen Zeilen enthalten Realm/Host Paare.  Der erste Wert jeder
	Zeile ist das Realm, der zweite Teil ein Host, der in diesem
	Realm <quote>Key Distribution Center</quote> ist.  Die
	Schl&uuml;sselw&ouml;rter <literal>admin server</literal> nach einem
	Hostnamen bedeuten, dass dieser Host auch einen administrativen
	Datenbankserver zur Verf&uuml;gung stellt.  Weitere Erkl&auml;rungen zu
	diesen Begriffen finden Sie in den Kerberos Manualpages.</para>

      <para>Als n&auml;chstes muss
	<hostid role="fqdn">grunt.example.com</hostid> in das Realm
	<filename>EXAMPLE.COM</filename> aufgenommen werden.  Des Weiteren
	erstellen wir einen Eintrag, der alle Rechner der Dom&auml;ne
	<hostid role="domainname">.example.com</hostid> in das Realm
	<filename>EXAMPLE.COM</filename>  aufnimmt.
	<filename>krb.realms</filename> sollte danach so aussehen:</para>

      <screen>&prompt.root; <userinput>cat krb.realms</userinput>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</screen>

      <para>Die zus&auml;tzlichen Realms sind hier wieder als Beispiel
	gedacht.  Sie k&ouml;nnen sie der Einfachheit halber auch
	weglassen.</para>

      <para>Die erste Zeile nimmt ein <emphasis>einzelnes</emphasis> System
	in das Realm auf.  Die anderen Zeilen zeigen, wie bestimmte
	Subdom&auml;nen einem bestimmten Realm zugeordnet werden.</para>

      <para>Das folgende Kommando muss nur auf dem Kerberos-Server
	(oder <quote>Key Distribution Center</quote>) laufen.  Mit
	<command>kdb_init</command> k&ouml;nnen wir die Datenbank
	anlegen:</para>

      <screen>&prompt.root; <userinput>kdb_init</userinput>
<prompt>Realm name [default  ATHENA.MIT.EDU ]:</prompt> <userinput>EXAMPLE.COM</userinput>
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.

<prompt>Enter Kerberos master key:</prompt> </screen>

      <para>Anschlie&szlig;end muss der Schl&uuml;ssel gespeichert
	werden, damit Server auf der lokalen Maschine darauf zugreifen
	k&ouml;nnen.  Dies geschieht mit <command>kstash</command>:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!</screen>

      <para>Das verschl&uuml;sselte Master-Passwort wurde in
	<filename>/etc/kerberosIV/master_key</filename> gesichert.</para>
    </sect2>

    <sect2>
      <title>Anlegen von Prinzipals</title>

      <para>F&uuml;r <emphasis>jedes</emphasis> System, das mit Kerberos
	gesichert werden soll, m&uuml;ssen zwei Prinzipale in die
	Datenbank eingetragen werden.  Ihre Namen sind
	<literal>kpasswd</literal> und <literal>rcmd</literal>.  Beide
	Prinzipale m&uuml;ssen f&uuml;r jedes System angelegt werden, wobei
	die Instanz der Name des jeweiligen Systems ist.</para>

      <para>Die D&aelig;monen <command>kpasswd</command> und
	<command>rcmd</command> erlauben es anderen Systemen,
	Kerberos-Passw&ouml;rter zu &auml;ndern und Kommandos wie
	<command>rcp</command>, <command>rlogin</command> und
	<command>rsh</command> laufen zu lassen.</para>

      <para>Beide Eintr&auml;ge werden im Folgenden angelegt:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>passwd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: passwd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- geben Sie hier Zufallswerte ein
Verifying password

<prompt>New Password:</prompt> &lt;---- geben Sie hier Zufallswerte ein

<prompt>Random password [y] ?</prompt> <userinput>y</userinput>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt> <userinput>rcmd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt>

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>		&lt;---- geben Sie hier Zufallswerte ein
Verifying password

<prompt>New Password:</prompt>           &lt;---- geben Sie hier Zufallswerte ein

<prompt>Random password [y] ?</prompt>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>         &lt;---- geben Sie nichts an, um das Programm zu verlassen</screen>
    </sect2>

    <sect2>
      <title>Erstellen der Server-Datei</title>

      <para>Wir m&uuml;ssen nun f&uuml;r jede Maschine die Instanzen,
	die Dienste definieren, aus der Datenbank mit
	<command>ext_srvtab</command> extrahieren.  Die erstelle Datei
	muss auf einem <emphasis>sicheren Weg</emphasis> in das
	<filename>/etc/kerberosIV</filename> Verzeichnis jedes Clients
	kopiert werden.  Die Datei muss auf jedem Server und auf
	jedem Client vorhanden sein und ist unabdingbar f&uuml;r
	Kerberos.</para>

      <screen>&prompt.root; <userinput>ext_srvtab grunt</userinput>
<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating 'grunt-new-srvtab'....</screen>

      <para>Das Kommando erzeugt Dateien mit einem tempor&auml;ren Namen,
	der es anderen Servern erlaubt, ihre Datei abzuholen.  Die Datei
	muss auf dem entsprechenden System in <filename>srvtab</filename>
	umbenannt werden.  Auf dem originalen System k&ouml;nnen Sie
	<command>mv</command> benutzen, um die Datei umzubenennen:</para>

      <screen>&prompt.root; <userinput>mv grunt-new-srvtab srvtab</userinput></screen>

      <para>Wenn die Datei f&uuml;r ein Client-System bestimmt ist und das
	Netzwerk nicht sicher ist, kopieren Sie die Datei auf ein bewegliches
	Medium und transportieren sie physikalisch.  Kopieren Sie die Datei
	auf den Client in das Verzeichnis <filename>/etc/kerberosIV</filename>.
	Benennen Sie die Datei in <filename>srvtab</filename> um und setzen Sie
	schlie&szlig;lich noch die Berechtigungen auf 600:</para>

      <screen>&prompt.root; <userinput>mv grumble-new-srvtab srvtab</userinput>
&prompt.root; <userinput>chmod 600 srvtab</userinput></screen>
    </sect2>

    <sect2>
      <title>F&uuml;llen der Datenbank</title>

      <para>Wir k&ouml;nnen nun Benutzer in der Datenbank anlegen.  Mit
	<command>kdb_edit</command> legen wir zuerst die Benutzerin
	<username>jane</username> an:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: jane, Instance: , kdc_key_ver: 1
<prompt>New Password:</prompt>                &lt;---- geben Sie ein sicheres Passwort ein
Verifying password

<prompt>New Password:</prompt>                &lt;---- wiederholen Sie die Eingabe
Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		   &lt;---- geben Sie nichts an, um das Programm zu verlassen</screen>
    </sect2>

    <sect2>
      <title>Testen</title>

      <para>Zuerst m&uuml;ssen die Kerberos-D&aelig;monen gestartet sein.
	Wenn Sie <filename>/etc/rc.conf</filename> richtig angepasst haben,
	passiert das automatisch, wenn Sie booten.  Dieser Schritt ist nur
	auf dem Kerberos-Server notwendig, die Clients bekommen alles
	was sie brauchen aus dem <filename>/etc/kerberosIV</filename>
	Verzeichnis.</para>

      <screen>&prompt.root; <userinput>kerberos &amp;</userinput>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
&prompt.root; <userinput>kadmind -n &amp;</userinput>
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>Jetzt k&ouml;nnen wir mit <command>kinit</command> versuchen,
	ein Ticket f&uuml;r die ID <username>jane</username>, die wir
	oben angelegt haben, zu erhalten:</para>

      <screen>&prompt.user; <userinput>kinit jane</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane"
<prompt>Password:</prompt> </screen>

      <para>Mit <command>klist</command> k&ouml;nnen Sie sich vergewissern,
	dass Sie die Tickets auch erhalten haben:</para>

      <screen>&prompt.user; <userinput>klist</userinput>
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>

      <para>Versuchen Sie nun das Passwort mit <command>passwd</command>
	zu &auml;ndern, um zu &uuml;berpr&uuml;fen, dass der
	<application>kpasswd</application> D&aelig;mon auch auf der
	Kerberos-Datenbank autorisiert ist:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
realm EXAMPLE.COM
<prompt>Old password for jane:</prompt>
<prompt>New Password for jane:</prompt>
Verifying password
<prompt>New Password for jane:</prompt>
Password changed.</screen>
    </sect2>

    <sect2>
      <title>Anlegen von <command>su</command> Privilegien</title>

      <para>Mit Kerberos kann <emphasis>jedem</emphasis> Benutzer, der
	<username>root</username>-Privilegien braucht, ein
	<emphasis>eigenes</emphasis> Passwort f&uuml;r
	<command>su</command> zugewiesen werden.  Dies wird dadurch
	erreicht, dass die Instanz eines Prinzipals
	<username>root</username> ist.  Mit <command>kbd_edit</command>
	legen wir nun den Eintrag <literal>jane.root</literal> in der
	Kerberos-Datenbank an:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt> <userinput>root</userinput>

&lt;Not found&gt;, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- geben Sie ein sicheres Passwort ein
Verifying password

<prompt>New Password:</prompt>    	 	 &lt;---- geben Sie das Passwort erneut ein

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt> <userinput>12</userinput> &lt;--- Keep this short!
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		         &lt;---- geben Sie nichts an, um das Programm zu verlassen</screen>

      <para>Versuchen Sie nun, f&uuml;r diesen Prinzipal Tickets zu
	bekommen:</para>

      <screen>&prompt.root; <userinput>kinit jane.root</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane.root"
<prompt>Password:</prompt></screen>

      <para>Als n&auml;chstes f&uuml;gen wir den Prinzipal in
	<filename>.klogin</filename> von <username>root</username> ein:</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>Jetzt benutzen wir <command>su</command>:</para>

      <screen>&prompt.user; <userinput>su</userinput>
Password:</screen>

      <para>und kontrollieren, welche Tickets wir haben:</para>

      <screen>&prompt.root; <userinput>klist</userinput>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>
    </sect2>

    <sect2>
      <title>Weitere Kommandos</title>

      <para>In einem der Beispiele haben wir einen Prinzipal mit
	dem Namen <literal>jane</literal> und der Instanz
	<literal>root</literal> angelegt.  Der Prinzipal entstand aus
	einem Benutzer mit dem gleichen Namen.  Unter Kerberos ist es
	Standard, dass ein
	<replaceable>principal.instance</replaceable> der Form
	<replaceable>username.</replaceable><username>root</username> es dem
	Benutzer <replaceable>username</replaceable> erlaubt, mit
	<command>su</command> <username>root</username> zu werden, wenn die
	entsprechenden Eintr&auml;ge in <filename>.klogin</filename> von
	<username>root</username> existieren:</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>Das gilt auch f&uuml;r die <filename>.klogin</filename>-Datei
	im Heimatverzeichnis eines Benutzers:</para>

      <screen>&prompt.user; <userinput>cat ~/.klogin</userinput>
jane@EXAMPLE.COM
jack@EXAMPLE.COM</screen>

      <para>Die Eintr&auml;ge erlauben jedem, der sich im Realm
	<filename>EXAMPLE.COM</filename> als <username>jane</username> oder
	<username>jack</username> mit <command>kinit</command> authentifiziert
	hat, &uuml;ber <command>rlogin</command>, <command>rsh</command>
	oder <command>rcp</command> Zugriff auf den Account
	<username>jane</username> und dessen Dateien.</para>

      <para>Im folgenden Beispiel meldet sich <username>jane</username>
	mit Kerberos auf <hostid>grunt</hostid> an:</para>

	    <screen>&prompt.user; <userinput>kinit</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
&prompt.user; <userinput>rlogin grunt</userinput>
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>

      <para>Im folgenden Beispiel wurde der Prinzipal <literal>jack</literal>
	mit einer Instanz <literal>null</literal> angelegt.  Mit der obigen
	<filename>.klogin</filename>-Datei kann er sich nun auf derselben
	Maschine als <username>jane</username> anmelden:</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
&prompt.user; <userinput>rlogin grunt -l jane</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
    </sect2>
  </sect1>

  <sect1 id="firewalls">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Gary</firstname>
	  <surname>Palmer</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
	<author>
	  <firstname>Alex</firstname>
	  <surname>Nash</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>Firewalls</title>
    <indexterm><primary>Firewall</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>Firewalls</secondary>
    </indexterm>

    <para>Firewalls sind sehr wichtig f&uuml;r Leute, die mit dem Internet
      verbunden sind.  Weiterhin halten sie Einzug in private Netzwerke, um
      dort die Sicherheit zu verbessern.  Dieser Abschnitt erkl&auml;rt,
      was Firewalls sind, wie sie benutzt werden und wie man die
      M&ouml;glichkeiten von FreeBSD benutzen kann, um eine Firewall zu
      implementieren.</para>

    <note>
      <para>Es wird oft gedacht, dass eine Firewall zwischen dem internen
	Netzwerk und dem <quote>weiten, schlechten Internet</quote>
	alle Sicherheitsprobleme l&ouml;st.  Eine Firewall kann die Sicherheit
	erh&ouml;hen, doch eine schlecht aufgesetzte Firewall ist ein
	gr&ouml;&szlig;eres Sicherheitsrisiko als gar keine Firewall.  Eine
	Firewall ist nur eine weitere Sicherheitsschicht, sie verhindert
	aber nicht, dass ein wirklich entschlossener Cracker in
	Ihr internes Netz eindringt.  Wenn Sie Ihre interne Sicherheit
	vernachl&auml;ssigen, weil Sie Ihre Firewall f&uuml;r undurchdringlich
	halten, machen Sie den Crackern die Arbeit leichter.</para>
    </note>

    <sect2>
      <title>Was ist eine Firewall?</title>

      <para>Auf dem Internet sind momentan zwei Arten von Firewalls
	gebr&auml;uchlich.  Die erste Art ist ein
	<emphasis>Paketfilter</emphasis>, in dem ein Kernel auf einer
	Maschine mit mehreren Netzwerkverbindungen auf Grund von Regeln
	entscheidet, ob er ein Paket weiterleitet oder nicht.  Der zweite
	Typ sind <emphasis>Proxy-Server</emphasis>, die auf D&aelig;monen
	angewiesen sind.  Die D&aelig;monen authentifizieren Benutzer
	und leiten Pakete weiter, das hei&szlig;t sie k&ouml;nnen auf
	Maschinen mit mehreren Netzwerkverbindungen laufen, auf denen
        das Weiterleiten von Paketen durch den Kernel ausgeschaltet ist.</para>

      <para>Manchmal werden beide Arten einer Firewall kombiniert und es
	ist nur einer besonderen Maschine, die
	<emphasis>Bastion Host</emphasis> genannt wird, erlaubt, Pakete
	in das interne Netzwerk &uuml;ber einen Paketfilter zu schicken.
	Auf dem Bastion Host laufen Proxy-Dienste, die im Allgemeinen
	sicherer als normale Authentifizierungsmechanismen sind.</para>

      <para>FreeBSD besitzt einen Kernel-Paketfilter (IPFW), der im Rest
	dieses Abschnitts behandelt wird.  Proxy-Server k&ouml;nnen
	mit Hilfe von Software von Drittherstellern auf FreeBSD realisiert
	werden, doch gibt es so viele Proxy-Server, dass deren
	Behandlung den Rahmen dieses Abschnitts sprengen w&uuml;rde.</para>

      <sect3 id="firewalls-packet-filters">
	<title>Paket-Filter</title>

	<para>Ein Router ist eine Maschine, die Pakete zwischen zwei oder
	  mehr Netzwerken weiterleitet.  Ein Paketfilter ist ein spezieller
	  Router, der extra Code im Kernel hat, der es im erlaubt, die
          Pakete mit Regeln zu vergleichen, bevor er das Paket weiterleitet.
	  Um die Filter zu aktivieren, m&uuml;ssen Sie zuerst die Regeln
	  definieren, die festlegen, ob ein Paket weitergeleitet wird oder
	  nicht.</para>

	<para>Um zu entscheiden, ob ein Paket weitergeleitet wird, sucht der
	  Code des Paketfilters eine Regel, die auf den Inhalt des Paketheaders
	  passt.  Wenn eine passende Regel gefunden wurde, wird die Aktion
	  der Regel ausgef&uuml;hrt.  Die Aktion kann das Paket blockieren,
	  weiterleiten oder auch dem Sender eine ICMP-Nachricht schicken.
	  Die Regeln werden der Reihenfolge nach durchsucht und nur die
	  erste passende Regel wird angewandt.  Daher wird auch von einer
	  <quote>Regelkette</quote> gesprochen.</para>

	<para>Die Kriterien, nach denen Sie ein Paket spezifizieren
	  k&ouml;nnen, h&auml;ngen von der eingesetzten Software ab.
	  Typischerweise k&ouml;nnen Sie Pakete nach der Quell IP-Adresse,
	  der Ziel IP-Adresse, dem Quellport, dem Zielport (bei Protokollen,
	  die diese unterscheiden) oder dem Pakettyp (UDP, TCP, ICMP)
	  unterscheiden.</para>
      </sect3>

      <sect3 id="firewalls-proxy-servers">
	<title>Proxy-Server</title>

	<para>Auf Proxy-Servern werden die normalen Systemdienste
	  (<application>telnetd</application>, <application>ftpd</application>,
	  usw.) durch besondere Server ersetzt.  Diese Server werden
	  <emphasis>Proxy-Server</emphasis> genannt, da sie normalerweise
	  nur weitergehende Verbindungen erlauben
	  (<foreignphrase>proxy</foreignphrase> engl. f&uuml;r
	  Stellvertreter).  Zum Beispiel k&ouml;nnen Sie auf Ihrer
	  Firewall einen Proxy-Telnet Server laufen lassen, der es Personen
	  erlaubt, aus dem Internet auf die Firewall eine Telnet-Verbindung
	  zu &ouml;ffnen.  Dort laufen Sie durch einen
	  Authentifizierungsmechanismus und haben dann Zugriff auf Ihr
	  internes Netzwerk.  F&uuml;r den umgekehrten Weg k&ouml;nnen Sie
	  nat&uuml;rlich auch Proxy-Server einsetzen.</para>

	<para>Proxy-Server sind in aller Regel sicherer als normale Server
	  und bieten oft eine Reihe von Authentifizierungsmechanismen.  Dazu
	  geh&ouml;ren Einmal-Passwort Systeme, bei denen das zum
	  Anmelden verwendete Passwort sofort ung&uuml;ltig wird und
	  nicht zu einer weiteren Anmeldung benutzt werden kann, auch wenn
	  es abgeh&ouml;rt wurde.  Da Proxy-Server den Benutzern keinen
	  Zugang zu dem System geben, wird es f&uuml;r einen Angreifer
	  sehr schwer, Hintert&uuml;ren zur Umgehung Ihres Sicherheitssystems
	  zu installieren.</para>

	<para>Mit Proxy-Servern lassen sich die Zugriffe meist noch weiter
	  beschr&auml;nken.  Der Zugriff kann auf bestimmte Rechner
	  eingeschr&auml;nkt werden und oft ist es m&ouml;glich,
	  festzulegen, welcher Benutzer mit welcher Zielmaschine kommunizieren
	  darf.  Welche M&ouml;glichkeiten Sie haben, h&auml;ngt stark
	  von der Proxy-Software ab, die Sie einsetzen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Was kann ich mit IPFW machen?</title>
      <indexterm><primary><command>ipfw</command></primary></indexterm>

      <para>IPFW, das von FreeBSD zur Verf&uuml;gung gestellt wird,
	ist ein Paketfilter und ein Accounting-System, das im Kernel
	l&auml;uft und mit &man.ipfw.8; ein Werkzeug im Userland
	zur Verf&uuml;gung stellt.  Beide Teile zusammen erlauben es Ihnen,
	die Regeln f&uuml;r Routing Entscheidungen im Kernel zu definieren
	oder abzufragen.</para>

      <para>In IPFW gibt es zwei zusammenh&auml;ngende Teile.  Mit der
	Firewall k&ouml;nnen Sie einen Paketfilter konfigurieren.  Das
	IP-Accounting Modul erlaubt es Ihnen, mit &auml;hnlichen Regeln
	wie den Firewall-Regeln, die Nutzung Ihres Routers zu &uuml;berwachen.
	Damit k&ouml;nnen Sie zum Beispiel sehen, wie viel Verkehr auf
	Ihrem Router von einer bestimmten Maschine kommt oder wie viel
	WWW (World Wide Web) Verkehr durch Ihren Router geht.</para>

      <para>Durch das Design von IPFW k&ouml;nnen Sie IPFW auch auf
	Maschinen, die keine Router sind, einsetzen und einen Paketfilter
	f&uuml;r eingehende und ausgehende Verbindungen konfigurieren.
	Dies ist ein Spezialfall der normalen Verwendung von IPFW
	und daher werden dieselben Kommandos und Techniken benutzt.</para>
    </sect2>

    <sect2>
      <title>Aktivieren von IPFW</title>
      <indexterm>
        <primary><command>ipfw</command></primary>
        <secondary>aktivieren</secondary>
      </indexterm>

      <para>Der gr&ouml;&szlig;te Teil des IPFW-Systems befindet sich im
	Kernel, daher m&uuml;ssen Sie die Konfigurationsdatei des Kernels
	editieren und anschlie&szlig;end den Kernel neu &uuml;bersetzen.
	Das Kapitel <link linkend="kernelconfig">Konfiguration des
	  FreeBSD Kernels</link> beschreibt, wie Sie dazu
	vorzugehen haben.</para>

      <warning>
	<para>In der Voreinstellung verbietet IPFW
	  <emphasis>alle</emphasis> Verbindungen.  <emphasis>Sie
	    haben sich ausgesperrt</emphasis>, wenn Sie den Kernel mit
	  Firewall-Unterst&uuml;tzung starten und keine eigenen Regeln,
	  die einen Zugriff erlauben, definiert haben.  Zum ersten
	  &Uuml;berpr&uuml;fen der Firewall-Funktion k&ouml;nnen Sie die
	  Firewall &ouml;ffnen, indem Sie
	  <literal>firewall_type=open</literal> in
	  <filename>/etc/rc.conf</filename> eintragen und danach, wenn
	  alles funktioniert hat, die Regeln in
	  <filename>/etc/rc.firewall</filename> anpassen.  Um zu vermeiden,
	  dass Sie sich aus Versehen aussperren, konfigurieren Sie die
	  Firewall nicht &uuml;ber eine
	  <application>ssh</application>-Verbindung sondern an der Konsole.
	  Sie k&ouml;nnen auch in der Voreinstellung alle Verbindungen
	  zulassen, indem Sie die Option
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal> in die
	  Kernelkonfiguration aufnehmen.</para>
      </warning>

      <para>Momentan gibt es vier Optionen in der Kernelkonfiguration, die
	IPFW betreffen:</para>

      <variablelist>
	<varlistentry>
	  <term><literal>options IPFIREWALL</literal></term>

	  <listitem>
	    <para>F&uuml;gt den Paketfilter-Code in den Kernel ein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options IPFIREWALL_VERBOSE</literal></term>

	  <listitem>
	    <para>Aktiviert das Loggen von Paketen mit &man.syslogd.8;.
	      Ohne diese Option werden keine Pakete geloggt, auch wenn Sie
	      in den Filterregeln das Loggen angeben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options IPFIREWALL_VERBOSE_LIMIT=10</literal></term>

	  <listitem>
	    <para>Begrenzt die Anzahl der &uuml;ber &man.syslogd.8;
	      geschriebenen Eintr&auml;ge.  Die Option ist in Umgebungen
	      mit hoher Aktivit&auml;t n&uuml;tzlich, in denen Sie die
	      Firewall Aktivit&auml;ten loggen m&ouml;chten, aber einem
	      Angreifer nicht die M&ouml;glichkeit eines Denial of Service
	      Angriffs durch das &Uuml;berlasten von syslog geben
	      wollen.</para>

	    <para>Erreicht eine Regel der Regelkette die angegebene Grenze,
	      so wird f&uuml;r diesen Eintrag das Loggen abgestellt.  Um
	      das Loggen von Paketen wieder zu aktivieren, m&uuml;ssen Sie
	      den Z&auml;hler mit &man.ipfw.8; zur&uuml;cksetzen:</para>

	    <screen>&prompt.root; <userinput>ipfw zero 4500</userinput></screen>
	    <para>Hier ist <literal>4500</literal> die Nummer der Regel in
	      der Regelkette, f&uuml;r die Sie das Log weiterf&uuml;hren
	      m&ouml;chten.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options IPFIREWALL_DEFAULT_TO_ACCEPT</literal></term>

	  <listitem>
	    <para>&Auml;ndert die Voreinstellung der Firewall, sodass alle
	      Verbindungen erlaubt anstatt verboten sind.  Diese
	      Einstellung vermeidet, dass Sie sich aussperren, wenn Sie
	      einen Kernel mit <literal>IPFIREWALL</literal> und ohne
	      eigene Regeln starten.  Wenn Sie &man.ipfw.8; wie einen
	      Filter zum L&ouml;sen spezieller Probleme bei deren
	      Auftreten verwenden, kann diese Option sehr n&uuml;tzlich
	      sein.  Diese Einstellung &ouml;ffnet die Firewall und
	      ver&auml;ndert ihre Arbeitsweise.  Gehen Sie daher sehr
	      vorsichtig mit ihr um.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note><para>Fr&uuml;here Versionen von FreeBSD stellten die Option
        <literal>IPFIREWALL_ACCT</literal> zur Verf&uuml;gung.  Die Option
	ist mittlerweile &uuml;berholt, da der Firewall Code automatisch
	Accounting M&ouml;glichkeiten bereitstellt.</para>
      </note>
    </sect2>

    <sect2>
      <title>Konfiguration von IPFW</title>
      <indexterm>
        <primary><command>ipfw</command></primary>
        <secondary>Konfiguration</secondary>
      </indexterm>

      <para>Mit &man.ipfw.8; konfigurieren Sie die IPFW-Software.  Die
        Syntax dieses Kommandos sieht ziemlich kompliziert aus, doch wenn
	Sie einmal den Aufbau der Kommandos verstanden haben, ist es sehr
	einfach.</para>

      <para>Das Kommando unterst&uuml;tzt vier verschiedene Operationen:
        Hinzuf&uuml;gen/L&ouml;schen, Anzeigen und Zur&uuml;cksetzen von
	Regeln, sowie das Zur&uuml;cksetzen von Paketz&auml;hlern.  Die
	Operationen Hinzuf&uuml;gen/L&ouml;schen werden genutzt, um die
	Regeln, nach denen Pakete akzeptiert, blockiert oder geloggt
	werden, zu erstellen.  Die Operation Anzeigen zeigt die Regelkette
	und die Paketz&auml;hler an.  Die Operation Zur&uuml;cksetzen
	l&ouml;scht alle Regeln der Regelkette.  Mit der letzten Operation
	k&ouml;nnen Sie ein oder mehrere Paketz&auml;hler auf den Wert Null
	zur&uuml;cksetzen.</para>

      <sect3>
	<title>&Auml;ndern der IPFW-Regeln</title>

	<para>Die Syntax f&uuml;r diese Operation lautet:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg>-N</arg>
	    <arg choice="plain">Kommando</arg>
	    <arg>index</arg>
	    <arg choice="plain">Aktion</arg>
	    <arg>log</arg>
	    <arg choice="plain">Protokoll</arg>
	    <arg choice="plain">Adressen</arg>
	    <arg>Optionen</arg>
	  </cmdsynopsis></para>

	<para>Dieser Aufruf unterst&uuml;tzt eine Option:</para>

	<variablelist>
	  <varlistentry>
	    <term>-N</term>

	    <listitem>
	      <para>L&ouml;st Adressen und Namen von Diensten in der
	        Ausgabe auf.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para><emphasis>Kommando</emphasis> kann auf die k&uuml;rzeste
	  eindeutige L&auml;nge reduziert werden.  G&uuml;ltig sind die
	  Werte:</para>

	<variablelist>
	  <varlistentry>
	    <term>add</term>

	    <listitem>
	      <para>F&uuml;gt einen Eintrag in die Firewall/Accounting
	        Regelkette ein.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>delete</term>

	    <listitem>
	      <para>L&ouml;scht einen Eintrag in der Firewall/Accounting
	        Regelkette.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Fr&uuml;here Versionen von IPFW verf&uuml;gten &uuml;ber
	  getrennte Firewall- und Accounting-Eintr&auml;ge in der Regelkette.
	  In der jetzigen Version steht das Accounting f&uuml;r jeden
	  Eintrag in der Firewall-Regelkette zur Verf&uuml;gung.</para>

	<para>Wenn ein Wert f&uuml;r <emphasis>index</emphasis> angegeben
	  ist, so wird die Regel an entsprechender Stelle in die Regelkette
	  eingef&uuml;gt.  Ansonsten wird die Regel an das Ende der Kette
	  gestellt, wobei der Index um 100 gr&ouml;&szlig;er ist als der
	  Index der letzten Regel (die voreingestellte letzte Regel mit der
	  Nummer <literal>65535</literal> wird in diesem Verfahren nicht
	  ber&uuml;cksichtigt).</para>

	<para>Wenn der Kernel mit <literal>IPFIREWALL_VERBOSE</literal>
	  erstellt wurde, gibt die Regel mit der Option
	  <literal>log</literal> Meldungen auf der Systemkonsole
	  aus.</para>

	<para>G&uuml;ltige Werte f&uuml;r <emphasis>Aktion</emphasis>
	  sind:</para>

	<variablelist>
	  <varlistentry>
	    <term>reject</term>

	    <listitem>
	      <para>Blockiert das Paket und schickt dem Sender die
		ICMP-Nachricht <quote>host or port unreachable</quote>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>allow</term>

	    <listitem>
	      <para>Leitet das Paket normal weiter.  Zul&auml;ssige Aliase
	        sind <literal>pass</literal> und
		<literal>accept</literal>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>deny</term>

	    <listitem>
	      <para>Blockiert das Paket und benachrichtigt den Sender
	        <emphasis>nicht</emphasis> mit einer ICMP-Nachricht.  Dem
		Sender kommt es so vor, als h&auml;tte das Paket sein Ziel
		nie erreicht.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>count</term>

	    <listitem>
	      <para>Erh&ouml;ht den Paketz&auml;hler f&uuml;r diese Regel,
	        trifft aber keine Entscheidung wie mit dem Paket zu
		verfahren ist, das hei&szlig;t die n&auml;chste Regel der
		Kette wird auf das Paket angewendet.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Es ist m&ouml;glich, die k&uuml;rzeste eindeutige Form der
	  Aktion anzugeben.</para>

	<para>F&uuml;r <emphasis>Protokoll</emphasis> k&ouml;nnen die
	  folgenden Werte angegeben werden:</para>

	<variablelist>
	  <varlistentry>
	    <term>all</term>

	    <listitem>
	      <para>Trifft auf jedes IP-Paket zu.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>icmp</term>

	    <listitem>
	      <para>Passt auf jedes ICMP-Paket.<para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>tcp</term>

	    <listitem>
	      <para>Passt auf jedes TCP-Paket.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>udp</term>

	    <listitem>
	      <para>Trifft auf jedes UDP-Paket zu.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Die Syntax f&uuml;r <emphasis>Adresse</emphasis>
	  lautet:</para>

	<cmdsynopsis>
	  <arg choice="plain">from</arg>
	  <arg choice="plain"><replaceable>Adresse/Maske</replaceable></arg><arg><replaceable>Port</replaceable></arg>
	  <arg choice="plain">to</arg>
	  <arg choice="plain"><replaceable>Adresse/Maske</replaceable></arg><arg><replaceable>Port</replaceable></arg>
	  <arg>via <replaceable>Interface</replaceable></arg>
	</cmdsynopsis>

	<para><replaceable>Port</replaceable> k&ouml;nnen Sie nur angeben,
	  wenn das <emphasis>Protokoll</emphasis> auch Ports
	  unterst&uuml;tzt (UDP und TCP).</para>

	<para><option>via</option> ist optional und gibt die IP-Adresse,
	  den Domainnamen eines lokalen Interfaces oder den Namen des
	  Interfaces (z.B. <devicename>ed0</devicename>) an und trifft nur
	  auf Pakete zu, die durch dieses Interface gehen.  Die Nummern der
	  Interfaces k&ouml;nnen mit einem Platzhalter angegeben werden,
	  <literal>ppp*</literal> trifft auf alle Kernel-PPP Interfaces
	  zu.</para>

	<para><replaceable>Adresse/Maske</replaceable> k&ouml;nnen Sie wie
	  folgt angeben:

	  <screen><replaceable>Adresse</replaceable></screen>

	  oder

	  <screen><replaceable>Adresse</replaceable>/<replaceable>Bitmaske</replaceable></screen>

	  oder

	  <screen><replaceable>Adresse</replaceable>:<replaceable>Maskenmuster</replaceable></screen>
	</para>

	<para>Anstelle einer IP-Adresse k&ouml;nnen Sie einen g&uuml;ltigen
	  Hostnamen angeben.
	  <option><replaceable>Bitmaske</replaceable></option> ist eine
	  dezimale Zahl, die angibt, wie viele Bits in der Adressmaske
	  gesetzt werden sollen.  Die Angabe
	  <hostid role="netmask">192.216.222.1/24</hostid> erstellt
	  eine Maske, die auf jede Adresse des Klasse C Subnetzes
	  <hostid role="ipaddr">192.216.222</hostid> zutrifft.
	  Das <option><replaceable>Maskenmuster</replaceable></option>
	  wird mit der gegebenen IP-Adresse logisch UND verkn&uuml;pft.
	  Das Schl&uuml;sselwort <literal>any</literal> trifft auf jede
	  IP-Adresse zu.</para>

	<para>Die Portnummern werden wie folgt angegeben:

	  <cmdsynopsis>
	    <arg choice="plain"><replaceable>Port</replaceable><arg>,<replaceable>Port</replaceable><arg>,<replaceable>Port</replaceable><arg>&hellip;</arg></arg></arg></arg>
	  </cmdsynopsis>

	  Dies gibt entweder einen Port oder eine Liste von Ports an.

	  <cmdsynopsis>
	    <arg choice="plain"><replaceable>Port</replaceable>-<replaceable>Port</replaceable></arg>
	  </cmdsynopsis>

	  Gibt einen Portbereich an.  Sie k&ouml;nnen einen einzelnen
	  Bereich mit einer Liste kombinieren, m&uuml;ssen aber den Bereich
	  immer zuerst angeben.</para>

	<para>Die verf&uuml;gbaren <emphasis>Optionen</emphasis>
	  sind:</para>

	<variablelist>
	  <varlistentry>
	    <term>frag</term>

	    <listitem>
	      <para>Trifft auf Pakete zu, die nicht das erste Fragment
	        eines Datagrams sind.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>in</term>

	    <listitem>
	      <para>Trifft auf eingehende Pakete zu.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>out</term>

	    <listitem>
	      <para>Trifft auf ausgehende Pakete zu.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>ipoptions <replaceable>spec</replaceable></term>

	    <listitem>
	      <para>Trifft auf alle IP-Pakete zu, deren Header die in
		<replaceable>spec</replaceable> angegebenen, durch Kommata
		separierte, Optionen enthalten.  Die unterst&uuml;tzten
		IP-Optionen sind: <literal>ssrr</literal> (strict source
		route), <literal>lsrr</literal> (loose source route),
		<literal>rr</literal> (record packet route), und
		<literal>ts</literal> (time stamp).  Ein f&uuml;hrendes
		<literal>!</literal> trifft auf alle Pakete zu, die diese
		Option nicht gesetzt haben.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>established</term>

	    <listitem>
	      <para>Trifft auf alle Pakete zu, die zu einer schon
	        bestehenden TCP-Verbindung geh&ouml;ren, das hei&szlig;t
		das RST- oder ACK-Bit ist gesetzt.  Sie k&ouml;nnen den
		Durchsatz der Firewall verbessern, wenn Sie die
		<emphasis>established</emphasis> Regeln soweit wie
		m&ouml;glich an den Anfang der Regelkette stellen.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>setup</term>

	    <listitem>
	      <para>Passt auf alle Pakete, die versuchen eine
	        TCP-Verbindung aufzubauen, das hei&szlig;t das SYN-Bit ist
		gesetzt und das ACK-Bit ist nicht gesetzt.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>tcpflags <replaceable>flags</replaceable></term>

	    <listitem>
	      <para>Trifft auf alle Pakete zu, die im TCP-Header eine der
	        durch Kommata getrennten Option gesetzt haben.  Die
		g&uuml;ltigen Optionen sind: <literal>fin</literal>,
		<literal>syn</literal>, <literal>rst</literal>,
		<literal>psh</literal>, <literal>ack</literal> und
		<literal>urg</literal>.  Mit einem f&uuml;hrenden
		<literal>!</literal> kann die Abwesenheit einer Option
		angegeben werden.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>icmptypes <replaceable>types</replaceable></term>

	    <listitem>
	      <para>Trifft auf ICMP-Pakete vom Typ
	        <replaceable>types</replaceable>.  Hier kann eine
		Kommata separierte Aufz&auml;hlung von Bereichen oder
		einzelnen Typen angegeben werden.  Gebr&auml;uchliche Typen
		sind: <literal>0</literal> echo reply (ping reply),
		<literal>3</literal> destination unreachable,
		<literal>5</literal> redirect, <literal>8</literal> echo
		request (ping request) und <literal>11</literal> time
		exceeded, das die &Uuml;berschreitung der TTL angibt und
		zum Beispiel von &man.traceroute.8; genutzt wird.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>Anzeigen der IPFW-Regeln</title>

	<para>Die Syntax f&uuml;r dieses Kommando lautet:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg>-a</arg>
	    <arg>-c</arg>
	    <arg>-d</arg>
	    <arg>-e</arg>
	    <arg>-t</arg>
	    <arg>-N</arg>
	    <arg>-S</arg>
	    <arg choice="plain">list</arg>
	  </cmdsynopsis></para>

	<para>Sieben Optionen sind f&uuml;r diese Form g&uuml;ltig:</para>

	<variablelist>
	  <varlistentry>
	    <term>-a</term>

	    <listitem>
	      <para>Zeigt die Paketz&auml;hler zu den Regeln an.  Diese
	        Option ist die einzige M&ouml;glichkeit, die Z&auml;hler zu
		sehen.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-c</term>

	    <listitem>
	      <para>Zeigt die Regeln in einer kompakten
		Darstellung an.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-d</term>

	    <listitem>
	      <para>Zeigt zus&auml;tzlich zu den statischen Regeln
		die dynamischen Regeln an.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-e</term>

	    <listitem>
	      <para>Zeigt auch abgelaufene dynamische Regeln an, wenn
		die Option zusammen mit <option>-d</option> angegeben
		wird.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-t</term>

	    <listitem>
	      <para>Zeigt die Zeit, zu der die Regel zuletzt aktiviert
	        wurde.  Die Syntax dieser Ausgabe ist nicht kompatibel mit
		der Eingabesyntax von &man.ipfw.8;.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-N</term>

	    <listitem>
	      <para>Versucht Adressen und Namen von Diensten
	        aufzul&ouml;sen.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>-S</term>

	    <listitem>
	      <para>Zeigt den Regelsatz an, zu dem die Regel geh&ouml;rt.
		Inaktive Regeln werden ohne diesen Schalter nicht
		angezeigt.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>Zur&uuml;cksetzen der IPFW-Regeln</title>

	<para>Die Regeln setzen Sie wie folgt zur&uuml;ck:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg choice="plain">flush</arg>
	  </cmdsynopsis></para>

	<para>Damit werden alle Regeln der Regelkette, mit Ausnahme der
	  Vorgaberegel <literal>65535</literal> gel&ouml;scht.  Seien Sie
	  vorsichtig, wenn Sie die Regeln zur&uuml;cksetzen.  Die Vorgabe
	  f&uuml;r die Regel <literal>65535</literal> ist es, alle Pakete
	  zu blockieren, das hei&szlig;t, das System ist solange vom
	  Netzwerk abgeschnitten, bis wieder neue Regeln in die Kette
	  eingef&uuml;gt werden.</para>
      </sect3>

      <sect3>
	<title>Zur&uuml;cksetzen der Paketz&auml;hler</title>

	<para>Um einen oder mehrere Paketz&auml;hler zur&uuml;ckzusetzen,
	  verwenden Sie folgende Syntax:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg choice="plain">zero</arg>
	    <arg choice="opt"><replaceable>index</replaceable></arg>
	  </cmdsynopsis></para>

	<para>Wenn Sie das Argument <replaceable>index</replaceable> nicht
	  angeben, werden alle Paketz&auml;hler zur&uuml;ckgesetzt.  Wenn
	  Sie das Argument angeben, wird nur der Z&auml;hler der
	  angegebenen Regel zur&uuml;ckgesetzt.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Beispiel f&uuml;r <application>ipfw</application>
        Kommandozeilen</title>

      <para>Das folgende Kommando blockiert alle Pakete, die von dem Host
        <hostid role="fqdn">evil.crackers.org</hostid> auf den Telnet-Port
	von <hostid role="fqdn">nice.people.org</hostid> gehen:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from evil.crackers.org to nice.people.org 23</userinput></screen>

      <para>Das n&auml;chste Beispiel verbietet jeden IP-Verkehr von dem
        ganzen <hostid role="domainname">crackers.org</hostid> Klasse C
	Netzwerk zu der Maschine <hostid
	role="fqdn">nice.people.org</hostid>:</para>

      <screen>&prompt.root; <userinput>ipfw add deny log tcp from evil.crackers.org/24 to nice.people.org</userinput></screen>

      <para>Wenn Sie X-Sitzungen zu Ihrem internen Netzwerk, einem Subnetz
        eines C Klasse Netzwerkes, verbieten wollen, wenden Sie das
	folgende Kommando an:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from any to my.org/28 6000 setup</userinput></screen>

      <para>Um die Accounting Eintr&auml;ge zu sehen:

	<screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

	oder k&uuml;rzer

	<screen>&prompt.root; <userinput>ipfw -a l</userinput></screen>
      </para>

      <para>Den Zeitpunkt, an dem eine Regel das letzte Mal aktiviert
        wurde, sehen Sie mit:</para>

      <screen>&prompt.root; <userinput>ipfw -at l</userinput></screen>
    </sect2>

    <sect2>
      <title>Aufbau einer Firewall mit Paketfiltern</title>

      <note>
	<para>Beachten Sie bitte, dass die folgenden Vorschl&auml;ge
	  wirklich nur Vorschl&auml;ge sind.  Die Anforderungen jeder
	  Firewall sind verschieden und wir k&ouml;nnen Ihnen wirklich
	  nicht sagen, wie Sie Ihre ma&szlig;geschneiderte Firewall einrichten
	  m&uuml;ssen.</para>
      </note>

      <para>Wenn Sie Ihre Firewall au&szlig;erhalb eines kontrollierten
        Testumfelds aufbauen, empfehlen wir Ihnen dringend, das Loggen der
	Regeln im Kernel zu aktivieren und Regeln zu verwenden, die loggen.
	Das macht es Ihnen leichter, Fehler zu finden und diese ohne
	gro&szlig;e Unterbrechungen zu beheben.  Auch nachdem Sie die
	Firewall aufgesetzt haben, empfehlen wir Ihnen, die `deny'-Regeln
	zu loggen.  Dies macht es leichter, Angriffen nachzugehen und das
	Regelwerk Ihrer Firewall zu &auml;ndern, wenn sich die Anforderungen
	einmal &auml;ndern.</para>

      <note>
	<para>Wenn Sie Pakete der <command>accept</command>-Regel loggen,
	  denken Sie bitte daran, dass Sie leicht <emphasis>sehr
	  gro&szlig;e</emphasis> Datenmengen erzeugen k&ouml;nnen, da jedes
	  durchgelassene Paket einen Eintrag im Log generiert.  Es kann
	  vorkommen, das gro&szlig;e FTP oder HTTP &Uuml;bertragungen das
	  System langsamer machen.  Weiterhin wird f&uuml;r jedes der
	  betroffenen Pakete die Latenzzeit erh&ouml;ht, da von Seiten des
	  Kernels mehr Arbeit zum Weiterleiten des Paketes erforderlich ist.
	  Da alle Daten auf die Platte ausgeschrieben werden wird
	  <application>syslogd</application> auch mehr Prozessorzeit
	  beanspruchen und es kann leicht passieren, dass die
	  Partition, die <filename>/var/log</filename> enth&auml;lt voll
	  l&auml;uft.</para>
      </note>

      <para>Sie sollten Ihre Firewall aus
        <filename>/etc/rc.conf.local</filename> oder
	<filename>/etc/rc.conf</filename> aktivieren.  Die entsprechende
	Manualpage zeigt Ihnen, welche Einstellungen Sie vornehmen
	m&uuml;ssen und zeigt einige vorgegebene Firewall-Konfigurationen.
	Wenn Sie keine der Vorgaben verwenden, k&ouml;nnen Sie Ihre
	Regelkette mit <command>ipfw list</command> in eine Datei ausgeben
	und diese Datei in <filename>/etc/rc.conf</filename> angeben.  Wenn
	sie weder <filename>/etc/rc.conf.local</filename> oder
	<filename>/etc/rc.conf</filename> benutzen, um Ihre Firewall zu
	aktivieren, stellen Sie bitte sicher, dass die Firewall
	aktiviert ist, bevor die IP-Interfaces konfiguriert werden.</para>

      <para>Als n&auml;chstes m&uuml;ssen Sie festlegen, was Ihre Firewall
        machen soll.  Das wird sehr stark davon abh&auml;ngen welche
	Zugriffe Sie von au&szlig;en auf Ihr Netzwerk erlauben wollen und
	welche Zugriffe von innen nach au&szlig;en erlaubt sein sollen.
	Einige gebr&auml;uchliche Regeln sind:</para>

      <itemizedlist>
	<listitem>
	  <para>Blockieren Sie jeden einkommenden Zugriff auf Ports unter
	    1024 f&uuml;r TCP.  Dort befinden sich die meisten der
	    sicherheitsrelevanten Dienste wie finger, SMTP (Post) und
	    telnet.</para>
	</listitem>

	<listitem>
	  <para>Blockieren Sie <emphasis>jeden</emphasis> einkommenden
	    UDP-Verkehr.  Es gibt wenige n&uuml;tzliche UDP-Dienste und
	    die, die n&uuml;tzlich sind, stellen meist eine Bedrohung der
	    Sicherheit dar (z.B. die RPC- und NFS-Protokolle von Sun).
	    Dies bringt allerdings auch Nachteile mit sich.  Da UDP ein
	    verbindungsloses Protokoll ist, verbieten Sie auch die
	    Antworten auf ausgehende UDP-Pakete, wenn Sie eingehende
	    UDP-Verbindungen blockieren.  Dies kann zum Beispiel Probleme
	    f&uuml;r Anwender des internen Netzwerks hervorrufen, wenn
	    diese einen externen Archie-Server (prospero) verwenden.  Wenn
	    Sie den Zugriff auf Archie erlauben wollen, m&uuml;ssen Sie
	    Pakete von den Ports 191 und 1525 zu jedem internen UDP-Port
	    durch Ihre Firewall lassen.  Ein anderer Dienst, den Sie
	    vielleicht erlauben wollen, ist <application>ntp</application>,
	    der vom Port 123 ausgeht.</para>
	</listitem>

	<listitem>
	  <para>Verbieten Sie Verkehr von au&szlig;en zum Port 6000.  Der
	    Port 6000 wird f&uuml;r den Zugriff auf X-Server genutzt und
	    kann eine Bedrohung der Sicherheit darstellen, insbesondere
	    wenn die Anwender gewohnt sind <command>xhost +</command> zu
	    benutzen.  Tats&auml;chlich kann X einen Bereich von Ports
	    verwenden, der bei 6000 anf&auml;ngt.  Die Obergrenze ist durch
	    die Anzahl der Displays, die auf einer Maschine laufen, gegeben.
	    Laut RFC&nbsp;1700 (Assigned Numbers) hat der h&ouml;chst
	    m&ouml;gliche Port die Nummer 6063.</para>
	</listitem>

	<listitem>
	  <para>&Uuml;berpr&uuml;fen Sie, welche Ports von internen Servern
	    (z.B. SQL-Servern) benutzt werden.  Da diese normalerweise aus
	    dem oben angesprochenen Bereich von 1-1024 fallen, ist es
	    wahrscheinlich gut, diese Ports ebenfalls zu blockieren.</para>
	</listitem>
      </itemizedlist>

      <para>Eine Checkliste zum Aufbau einer Firewall ist vom CERT unter
	<ulink
	  url="http://www.cert.org/tech_tips/packet_filtering.html">http://www.cert.org/tech_tips/packet_filtering.html</ulink>
	  erh&auml;ltlich.</para>

      <para>Wie oben schon gesagt, k&ouml;nnen wir Ihnen nur
        <emphasis>Richtlinien</emphasis> geben.  Sie m&uuml;ssen selbst
	entscheiden, welche Regeln Sie auf Ihrer Firewall einsetzen wollen.
	Wir &uuml;bernehmen <emphasis>keine</emphasis> Verantwortung
	daf&uuml;r, dass jemand in Ihr Netzwerk eindringt, auch wenn
	Sie die obigen Ratschl&auml;ge befolgt haben.</para>
    </sect2>

    <sect2 id="ipfw-overhead">
      <title>IPFW Overhead und Optimierungen</title>

      <para>Viele Leute wollen wissen, wie viel zus&auml;tzliche Last IPFW
        auf einem System erzeugt.  Haupts&auml;chlich h&auml;ngt dies von
	der Art der Regelkette und der Geschwindigkeit des Prozessors ab.
	F&uuml;r die meisten Anwendungen mit einer kleinen Regelkette auf
	einem Ethernet ist der Aufwand vernachl&auml;ssigbar klein.  Wenn
	Sie genaue Zahlen brauchen, lesen Sie bitte weiter.</para>

      <para>Die folgenden Messungen wurden auf einem 486-66 mit
	2.2.5-STABLE durchgef&uuml;hrt.  Obwohl sich IPFW in
	sp&auml;teren FreeBSD Versionen leicht ge&auml;ndert hat, l&auml;uft
	es doch mit vergleichbarer Geschwindigkeit.  Zur Durchf&uuml;hrung
	der Messungen wurde in IPFW die verbrauchte Zeit in der Routine
	<literal>ip_fw_chk</literal> gemessen.  Die Ergebnisse wurden alle
	1000 Pakete auf der Konsole ausgegeben.</para>

      <para>Zwei Regels&auml;tze mit je 1000 Regeln wurden getestet.  Der
        erste Regelsatz sollte den schlimmsten Fall durch wiederholte
	Anwendung der folgenden Regel demonstrieren:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from any to any 55555</userinput></screen>

      <para>Da ein Gro&szlig;teil der Routine, die die Pakete
        &uuml;berpr&uuml;ft, durchlaufen werden muss, bevor
	entschieden werden kann, ob das Paket wegen der Portnummer nicht
	auf die Regel passt, wird mit dieser Regel der schlimmste Fall gut
	simuliert.  Nach 999 Wiederholungen dieser Regel folgte die Regel
	<literal>allow ip from any to any</literal>.</para>

      <para>Der zweite Regelsatz wurde so entworfen, dass die
        &Uuml;berpr&uuml;fung der Regel schnell abgeschlossen werden
        kann:</para>

      <screen>&prompt.root; <userinput>ipfw add deny ip from 1.2.3.4 to 1.2.3.4</userinput></screen>

      <para>Die Regel kann aufgrund einer nicht passenden IP-Adresse sehr
        schnell verlassen werden.  Nach 999 Wiederholungen dieser Regel
	folgte wie im ersten Fall die Regel <literal>allow ip from any to
	any</literal>.</para>

      <para>Im ersten Fall betrug der zus&auml;tzliche Aufwand 2,703&nbsp;ms pro
        Paket also ungef&auml;hr 2,7&nbsp;&micro;s pro Regel.  Damit k&ouml;nnten
	maximal ungef&auml;hr 370 Pakete pro Sekunde verarbeitet werden.
	Mit einem 10&nbsp;Mbps Ethernet und Paketen, die ungef&auml;hr 1500
	Bytes gro&szlig; sind, entspricht dies einer Ausnutzung von 55% der zur
	Verf&uuml;gung stehenden Bandbreite.</para>

      <para>Im letzten Fall wurde jedes Paket in 1,172&nbsp;ms abgearbeitet, was
	ungef&auml;hr 1,2&nbsp;&micro;s pro Regel entspricht.  In diesem Fall
	k&ouml;nnten maximal 853 Pakete pro Sekunde verarbeitet werden, was
	die Bandbreite eines 10&nbsp;Mbps Ethernet vollst&auml;ndig
	ausnutzt.</para>

      <para>Die gro&szlig;e Anzahl und die Beschaffenheit der Regeln in den
	Beispielen entsprechen nicht der Wirklichkeit.  Die Regeln dienten
	nur der Messung der Geschwindigkeit.  Wenn Sie eine effiziente
	Regelkette aufbauen wollen, sollten Sie die folgenden
	Ratschl&auml;ge ber&uuml;cksichtigen:</para>

      <itemizedlist>
	<listitem>
	  <para>Setzen Sie eine <literal>established</literal> Regel so
	    fr&uuml;h wie m&ouml;glich in die Regelkette, um den
	    Gro&szlig;teil des TCP Verkehrs abzudecken.  Vor dieser Regel
	    sollten Sie keine <literal>allow tcp</literal> Regeln stehen
	    haben.</para>
	</listitem>

	<listitem>
	  <para>Plazieren Sie h&auml;ufig benutzte Regeln vor selten
	    benutzten Regeln, ohne dabei den Sinn der Regelkette zu
	    &auml;ndern.  Welche Regeln h&auml;ufig durchlaufen werden,
	    k&ouml;nnen Sie den Paketz&auml;hlern mit <command>ipfw
	      -a l</command> entnehmen.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="openssl">
    <title>OpenSSL</title>
    <indexterm>
      <primary>security</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>
    <indexterm><primary>OpenSSL</primary></indexterm>

    <para>Das OpenSSL-Toolkit ist seit FreeBSD&nbsp;4.0 Teil des Basissystems.
      <ulink url="http://www.openssl.org/">OpenSSL</ulink> stellt eine
      universale Kryptographie Bibliothek sowie die Protokolle Secure
      Sockets Layer v2/v3 (SSLv2/SSLv3) und Transport Layer Security v1
      (TLSv1) zur Verf&uuml;gung.</para>

    <para>Einer der Algorithmen, namentlich IDEA, in OpenSSL ist durch
      Patente in den USA und anderswo gesch&uuml;tzt und daher nicht frei
      verf&uuml;gbar.  IDEA ist Teil des Quellcodes von OpenSSL wird aber
      in der Voreinstellung nicht kompiliert.  Wenn Sie den Algorithmus
      benutzen wollen und die Lizenzbedingungen erf&uuml;llen, k&ouml;nnen
      Sie <literal>MAKE_IDEA</literal> in
      <filename>/etc/make.conf</filename> aktivieren und das System mit
      <command>make world</command> neu bauen.</para>

    <para>Der RSA-Algorithmus ist heute in den USA und anderen L&auml;ndern
      frei verf&uuml;gbar.  Fr&uuml;her wurde er ebenfalls durch ein Patent
      gesch&uuml;tzt.</para>

    <indexterm>
      <primary>OpenSSL</primary>
      <secondary>Installation</secondary>
    </indexterm>

    <sect2>
      <title>Installation des Quellcodes</title>

      <para>OpenSSL ist Teil der <literal>src-crypto</literal> und
        <literal>src-secure</literal> CVSup-Kollektionen.  Mehr Informationen
        &uuml;ber die Erh&auml;ltlichkeit und das Aktualisieren des FreeBSD
	Quellcodes erhalten Sie im Abschnitt
	<link linkend="mirrors">Bezugsquellen f&uuml;r FreeBSD</link>.</para>
    </sect2>
  </sect1>

  <sect1 id="ipsec">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Yoshinobu</firstname>
	  <surname>Inoue</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
	<!-- 5 Mar 2000 -->
      </authorgroup>
    </sect1info>

    <title>IPsec</title>
    <indexterm><primary>IPsec</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>IPsec</secondary>
    </indexterm>

    <note>
      <title>Abschlie&szlig;ende Zeichen</title>
      <para>Am Ende der Beispiele in diesem und anderen Abschnitten werden
        Sie oft ein <quote>^D</quote> sehen.  Das bedeutet, dass Sie
	die <keycap>Control</keycap>-Taste zusammen mit der Taste
	<keycap>D</keycap> dr&uuml;cken sollen.  Eine weiterere h&auml;ufig
	genutzte Kombination ist <quote>^C</quote>.  Hier dr&uuml;cken Sie
	die Taste <keycap>Control</keycap> zusammen mit der
	<keycap>C</keycap>-Taste.</para>
    </note>

    <tip>
      <para>HOWTOs, die die Implementierung von IPsec in FreeBSD
        beschreiben, finden Sie unter <ulink
	  url="http://www.daemonnews.org/200101/ipsec-howto.html"></ulink>
	und <ulink
	  url="http://www.freebsddiary.org/ipsec.php"></ulink>.</para>
    </tip>

    <para>IPsec stellt eine sichere Kommunikation auf IP- und Socket-Ebene
      zur Verf&uuml;gung.  Der folgende Abschnitt zeigt wie Sie IPsec
      benutzen.  Weitere Einzelheiten k&ouml;nnen Sie dem
      <ulink url="../../../../doc/en_US.ISO8859-1/books/developers-handbook/ipv6.html">
        FreeBSD Developers' Handbook</ulink> entnehmen.</para>

    <para>Die aktuelle Version von IPsec unterst&uuml;tzt den
      Transport-Modus sowie den Tunnel-Modus, wobei der Tunnel-Modus einige
      Beschr&auml;nkungen besitzt.  Unter <ulink
        url="http://www.kame.net/newsletter/">http://www.kame.net/newsletter/</ulink>
      finden Sie weitere Beispiele.</para>

    <para>Um IPsec benutzen zu k&ouml;nnen, m&uuml;ssen Sie folgende
      Optionen in Ihren Kernel kompiliert haben:</para>

    <programlisting>options          IPSEC              #IP security
options          IPSEC_ESP          #IP security (crypto; define w/IPSEC)</programlisting>

    <sect2>
      <title>Transport-Modus mit IPv4</title>

      <para>Um zwischen zwei Rechnern, im folgenden Beispiel HOST A
        (<hostid role="ipaddr">10.2.3.4</hostid>) und  HOST B
	(<hostid role="ipaddr">10.6.7.8</hostid>) sicher zu kommunizieren,
	m&uuml;ssen wir zuerst eine
	<firstterm>Sicherheitsassoziation</firstterm> einrichten.  Das
	folgende Beispiel benutzt den alten AH (Authentication Header)
	von HOST A zu HOST B.  F&uuml;r die Kommunikation von HOST B
	zu HOST A wird der neue AH mit dem neuen ESP (Encapsulating
	Security Payload) kombiniert.</para>

      <para>Zu den Verfahren <quote>AH</quote>, <quote>neuer AH</quote>,
	<quote>ESP</quote> und <quote>neuem ESP</quote> m&uuml;ssen nun
	Algorithmen ausgew&auml;hlt werden.  Die zur Verf&uuml;gung
	stehenden Algorithmen werden in &man.setkey.8; erl&auml;utert.  Wir
	entschieden uns f&uuml;r die Kombinationen MD5 f&uuml;r AH,
	new-HMAC-SHA1 f&uuml;r neuen AH und new-DES-expIV mit 8 Byte IV
	f&uuml;r den neuen ESP.</para>

      <para>Die Schl&uuml;ssell&auml;nge h&auml;ngt stark vom
        gew&auml;hlten Algorithmus ab.  F&uuml;r MD5 betr&auml;gt sie 16
	Bytes, f&uuml;r new-HMAC-SHA1 20 Bytes und 8 Bytes f&uuml;r
	new-DES-expIV.  Wie w&auml;hlten jeweils die Schl&uuml;ssel
	<quote>MYSECRETMYSECRET</quote>,
	<quote>KAMEKAMEKAMEKAMEKAME</quote> und <quote>PASSWORD</quote>.</para>

      <para>Als n&auml;chstes m&uuml;ssen wir jedem Protokoll einen SPI
        (Security Parameter Index) zuweisen.  Beachten Sie bitte, dass
	wir drei SPIs ben&ouml;tigen, da drei Header erzeugt werden (einer
	f&uuml;r die Kommunikation von HOST A zu HOST B und zwei f&uuml;r
	die Kommunikation von HOST B zu HOST A).  Beachten Sie weiterhin,
	dass die SPIs gr&ouml;&szlig;er oder gleich 256 sein
	m&uuml;ssen.  Im folgenden Beispiel haben wir uns f&uuml;r 1000,
	2000 und 3000 entschieden.</para>

      <screen>
	         (1)
	HOST A ------> HOST B

	(1)PROTO=AH
		ALG=MD5(RFC1826)
		KEY=MYSECRETMYSECRET
		SPI=1000

	         (2.1)
	HOST A <------ HOST B
	       <------
	         (2.2)

	(2.1)
	PROTO=AH
		ALG=new-HMAC-SHA1(new AH)
		KEY=KAMEKAMEKAMEKAMEKAME
		SPI=2000

	(2.2)
	PROTO=ESP
		ALG=new-DES-expIV(new ESP)
			IV length = 8
		KEY=PASSWORD
		SPI=3000
</screen>

      <para>Um die Sicherheitsassoziation einzurichten, f&uuml;hren Sie
        &man.setkey.8; auf HOST A und HOST B aus:</para>

      <screen>&prompt.root; <userinput>setkey -c
add 10.2.3.4 10.6.7.8 ah-old  1000 -m transport -A keyed-md5 "MYSECRETMYSECRET" ;
add 10.6.7.8 10.2.3.4 ah  2000 -m transport -A hmac-sha1 "KAMEKAMEKAMEKAMEKAME" ;
add 10.6.7.8 10.2.3.4 esp 3000 -m transport -E des-cbc "PASSWORD" ;
^D</userinput>
</screen>

     <para>Bevor Sie die Kommunikation mit IPsec benutzen k&ouml;nnen,
       m&uuml;ssen Sie noch eine Sicherheits-Policy auf beiden Rechnern
       einrichten:</para>

     <screen>
Auf Host A:

&prompt.root; <userinput>setkey -c
spdadd 10.2.3.4 10.6.7.8 any -P out ipsec
	ah/transport/10.2.3.4-10.6.7.8/require ;
^D</userinput>

Auf Host B:

&prompt.root; <userinput>setkey -c
spdadd 10.6.7.8 10.2.3.4 any -P out ipsec
	esp/transport/10.6.7.8-10.2.3.4/require ;
spdadd 10.6.7.8 10.2.3.4 any -P out ipsec
	ah/transport/10.6.7.8-10.2.3.4/require ;
^D</userinput>


   HOST A --------------------------------------> HOST E
  10.2.3.4                                       10.6.7.8
          |                                     |
          ========== old AH keyed-md5 ==========>

          <========= new AH hmac-sha1 ===========
          <========= new ESP des-cbc ============
</screen>
    </sect2>

    <sect2>
      <title>Transport-Modus mit IPv6</title>

      <para>Das folgende Beispiel zeigt die Nutzung von IPsec mit
        IPv6.</para>

      <para>Das folgende Beispiel richtet den ESP Transport-Modus f&uuml;r
	TCP Verbindungen zwischen HOST B Port 110 und HOST A ein.</para>

      <screen>
              ============ ESP ============
              |                           |
           Host-A                        Host-B
          fec0::10 -------------------- fec0::11
</screen>

      <para>Der Algorithmus zum Verschl&uuml;sseln ist blowfish-cbc, der
        zugeh&ouml;rige Schl&uuml;ssel ist <quote>kamekame</quote>.
	F&uuml;r die Authentifizierung wird hmac-sha1 mit dem
	Schl&uuml;ssel <quote>this is the test key</quote> verwendet.  Auf
	HOST A geben Sie die folgenden Befehle ein:</para>

      <screen>
        &prompt.root; <userinput>setkey -c &lt;&lt;EOF
        spdadd fec0::10[any] fec0::11[110] tcp -P out ipsec
                esp/transport/fec0::10-fec0::11/use ;
        spdadd fec0::11[110] fec0::10[any] tcp -P in ipsec
                esp/transport/fec0::11-fec0::10/use ;
        add fec0::10 fec0::11 esp 0x10001
                -m transport
                -E blowfish-cbc "kamekame"
                -A hmac-sha1 "this is the test key" ;
        add fec0::11 fec0::10 esp 0x10002
                -m transport
                -E blowfish-cbc "kamekame"
                -A hmac-sha1 "this is the test key" ;
        EOF</userinput>
</screen>

      <para>Entsprechend auf HOST B:</para>

      <screen>&prompt.root; <userinput>setkey -c &lt;&lt;EOF
        spdadd fec0::11[110] fec0::10[any] tcp -P out ipsec
                esp/transport/fec0::11-fec0::10/use ;
        spdadd fec0::10[any] fec0::11[110] tcp -P in ipsec
                esp/transport/fec0::10-fec0::11/use ;
        add fec0::10 fec0::11 esp 0x10001 -m transport
                -E blowfish-cbc "kamekame"
                -A hmac-sha1 "this is the test key" ;
        add fec0::11 fec0::10 esp 0x10002 -m transport
                -E blowfish-cbc "kamekame"
                -A hmac-sha1 "this is the test key" ;
        EOF</userinput>
</screen>

      <para>Beachten Sie bitte die Richtung der erstellen Security
        Policy.</para>
    </sect2>

    <sect2>
      <title>Tunnel-Modus mit IPv4</title>

      <para>Das folgende Beispiel baut einen Tunnel zwischen zwei Gateways
        auf.</para>

      <para>Als Protokoll wird der alte AH Tunnel-Modus (RFC 1826)
        verwendet.  Zur Authentifizierung wird keyed-md5 mit dem
	Schl&uuml;ssel <quote>this is the test</quote> verwendet.</para>

      <screen>
                             ======= AH =======
                             |                |
         Network-A       Gateway-A        Gateway-B        Network-B
        10.0.1.0/24 ---- 172.16.0.1 ----- 172.16.0.2 ---- 10.0.2.0/24
</screen>

      <para>Der Gateway A wird wie folgt konfiguriert:</para>

      <screen>
        &prompt.root; <userinput>setkey -c &lt;&lt;EOF
        spdadd 10.0.1.0/24 10.0.2.0/24 any -P out ipsec
                ah/tunnel/172.16.0.1-172.16.0.2/require ;
        spdadd 10.0.2.0/24 10.0.1.0/24 any -P in ipsec
                ah/tunnel/172.16.0.2-172.16.0.1/require ;
        add 172.16.0.1 172.16.0.2 ah-old 0x10003 -m any
                -A keyed-md5 "this is the test" ;
        add 172.16.0.2 172.16.0.1 ah-old 0x10004 -m any
                -A keyed-md5 "this is the test" ;

        EOF</userinput>
</screen>

      <para>Wenn wie oben die Portnummer weggelassen wird, wird
        <literal>[any]</literal> verwendet.  Mit <literal>-m</literal> wird
	der Modus der Sicherheitsassoziation angegeben.
	<literal>-m any</literal> gilt f&uuml;r den Transport- sowie den
	Tunnel-Modus.</para>

      <para>Auf Gateway B geben Sie Folgendes ein:</para>

      <screen>
        &prompt.root; <userinput>setkey -c &lt;&lt;EOF
        spdadd 10.0.2.0/24 10.0.1.0/24 any -P out ipsec
                ah/tunnel/172.16.0.2-172.16.0.1/require ;
        spdadd 10.0.1.0/24 10.0.2.0/24 any -P in ipsec
                ah/tunnel/172.16.0.1-172.16.0.2/require ;
        add 172.16.0.1 172.16.0.2 ah-old 0x10003 -m any
                -A keyed-md5 "this is the test" ;
        add 172.16.0.2 172.16.0.1 ah-old 0x10004 -m any
                -A keyed-md5 "this is the test" ;

        EOF</userinput>
</screen>
    </sect2>

    <sect2>
      <title>Tunnel-Modus mit IPv6</title>

      <para>Transport- und Tunnel-Modus zwischen zwei Gateways</para>

      <para>Zwischen Gateway A und Gateway B soll der AH Transport-Modus
        und der ESP Tunnel-Modus eingerichtet werden.  In diesem Fall wird
	zuerst der ESP-Tunnel eingerichtet, danach folgt das Einrichten des
	AH Transport-Modus.</para>

      <screen>
                            ========== AH =========
                            |  ======= ESP =====  |
                            |  |               |  |
       Network-A          Gateway-A        Gateway-B           Network-B
    fec0:0:0:1::/64 --- fec0:0:0:1::1 ---- fec0:0:0:2::1 --- fec0:0:0:2::/64
</screen>

      <para>F&uuml;r ESP wird 3des-cbc zur Verschl&uuml;sselung und hmac-sha1
	zur Authentifizierung verwendet.  Bei AH wird zur Authentifizierung
	hmac-md5 benutzt.  Auf Gateway A sieht die Konfiguration wie folgt
	aus:</para>

      <screen>
        &prompt.root; <userinput>setkey -c &lt;&lt;EOF
        spdadd fec0:0:0:1::/64 fec0:0:0:2::/64 any -P out ipsec
                esp/tunnel/fec0:0:0:1::1-fec0:0:0:2::1/require
                ah/transport/fec0:0:0:1::1-fec0:0:0:2::1/require ;
        spdadd fec0:0:0:2::/64 fec0:0:0:1::/64 any -P in ipsec
                esp/tunnel/fec0:0:0:2::1-fec0:0:0:1::1/require
                ah/transport/fec0:0:0:2::1-fec0:0:0:1::1/require ;
        add fec0:0:0:1::1 fec0:0:0:2::1 esp 0x10001 -m tunnel
                -E 3des-cbc "kamekame12341234kame1234"
                -A hmac-sha1 "this is the test key" ;
        add fec0:0:0:1::1 fec0:0:0:2::1 ah 0x10001 -m transport
                -A hmac-md5 "this is the test" ;
        add fec0:0:0:2::1 fec0:0:0:1::1 esp 0x10001 -m tunnel
                -E 3des-cbc "kamekame12341234kame1234"
                -A hmac-sha1 "this is the test key" ;
        add fec0:0:0:2::1 fec0:0:0:1::1 ah 0x10001 -m transport
                -A hmac-md5 "this is the test" ;

        EOF</userinput>
</screen>

      <para>Im Folgenden werden zwei Sicherheitsassoziationen mit
        unterschiedlichen Endpunkten erstellt.</para>

      <para>Zwischen Host A und Gateway A soll ein ESP-Tunnel eingerichtet
        werden.  Zur Verschl&uuml;sselung wird cast128-cbc und zur
	Authentifizierung wird hmac-sha1 verwendet.  Zus&auml;tzlich wird
	zwischen Host A und Host B der ESP Transport-Modus eingerichtet.
	Zur Verschl&uuml;sselung wird rc5-cbc verwendet.  Die
	Authentifizierung verwendet hmac-md5.</para>

      <screen>
              ================== ESP =================
              |  ======= ESP =======                 |
              |  |                 |                 |
             Host-A            Gateway-A           Host-B
          fec0:0:0:1::1 ---- fec0:0:0:2::1 ---- fec0:0:0:2::2
</screen>

      <para>Host A wird wie folgt konfiguriert:</para>

      <screen>
        &prompt.root; <userinput>setkey -c &lt;&lt;EOF
        spdadd fec0:0:0:1::1[any] fec0:0:0:2::2[80] tcp -P out ipsec
                esp/transport/fec0:0:0:1::1-fec0:0:0:2::2/use
                esp/tunnel/fec0:0:0:1::1-fec0:0:0:2::1/require ;
        spdadd fec0:0:0:2::1[80] fec0:0:0:1::1[any] tcp -P in ipsec
                esp/transport/fec0:0:0:2::2-fec0:0:0:l::1/use
                esp/tunnel/fec0:0:0:2::1-fec0:0:0:1::1/require ;
        add fec0:0:0:1::1 fec0:0:0:2::2 esp 0x10001
                -m transport
                -E cast128-cbc "12341234"
                -A hmac-sha1 "this is the test key" ;
        add fec0:0:0:1::1 fec0:0:0:2::1 esp 0x10002
                -E rc5-cbc "kamekame"
                -A hmac-md5 "this is the test" ;
        add fec0:0:0:2::2 fec0:0:0:1::1 esp 0x10003
                -m transport
                -E cast128-cbc "12341234"
                -A hmac-sha1 "this is the test key" ;
        add fec0:0:0:2::1 fec0:0:0:1::1 esp 0x10004
                -E rc5-cbc "kamekame"
                -A hmac-md5 "this is the test" ;

        EOF</userinput>
</screen>
    </sect2>
  </sect1>

  <sect1 id="openssh">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </sect1info>

    <title>OpenSSH</title>
    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para>Secure Shell stellt Werkzeuge bereit, um sicher auf entfernte
      Maschinen zuzugreifen.  Die Kommandos <command>rlogin</command>,
      <command>rsh</command>, <command>rcp</command> und
      <command>telnet</command> k&ouml;nnen durch ssh ersetzt werden.
      Zus&auml;tzlich k&ouml;nnen andere TCP/IP-Verbindungen sicher durch
      ssh weitergeleitet (getunnelt) werden.  Mit ssh werden alle
      Verbindungen verschl&uuml;sselt, dadurch wird verhindert, dass
      die Verbindung zum Beispiel abgeh&ouml;rt oder &uuml;bernommen
      (<foreignphrase>Hijacking</foreignphrase>) werden kann.</para>

    <para>OpenSSH wird vom OpenBSD Projekt gepflegt und basiert auf
      SSH&nbsp;v1.2.12 mit allen aktuellen Fixen und Aktualisierungen.  OpenSSH
      ist mit den SSH Protokollen der Versionen 1 und 2 kompatibel.  Seit
      FreeBSD&nbsp;4.0 ist die OpenSSH Teil des Basissystems.</para>

    <sect2>
      <title>Vorteile von OpenSSH</title>

      <para>Mit &man.telnet.1; oder &man.rlogin.1; werden Daten in einer
        unverschl&uuml;sselten Form &uuml;ber das Netzwerk gesendet.  Daher
	besteht die Gefahr, das Benutzer/Passwort Kombinationen
	oder alle Daten an
	beliebiger Stelle zwischen dem Client und dem Server abgeh&ouml;rt
	werden.  Mit OpenSSH stehen eine Reihe von Authentifizierungs- und
	Verschl&uuml;sselungsmethoden zur Verf&uuml;gung, um das zu
	verhindern.</para>
    </sect2>

    <sect2>
      <title>Aktivieren von sshd</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Aktivieren</secondary>
      </indexterm>

      <para>Stellen Sie sicher, dass <filename>/etc/rc.conf</filename>
        die folgende Zeile enth&auml;lt:</para>
      <screen>sshd_enable="YES"</screen>
      <para>Der <application>ssh</application> D&aelig;mon wird damit bei
        dem n&auml;chsten Neustart des Systems geladen.  Alternativ
	k&ouml;nnen Sie den D&aelig;mon auch h&auml;ndisch starten.</para>
    </sect2>

    <sect2>
      <title>SSH Client</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Client</secondary>
      </indexterm>

      <para>&man.ssh.1; arbeitet &auml;hnlich wie &man.rlogin.1;:</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para>Der Anmeldevorgang wird danach, wie von
        <command>rlogin</command> oder <command>telnet</command> gewohnt,
	weiterlaufen.  SSH speichert einen Fingerabdruck des
	Serverschl&uuml;ssels.  Die Aufforderung, <literal>yes</literal>
	einzugeben, erscheint nur bei der ersten Verbindung zu einem
	Server.  Weitere Verbindungen zu dem Server werden gegen den
	gespeicherten Fingerabdruck des Schl&uuml;ssels gepr&uuml;ft und
	der Client gibt eine Warnung aus, wenn sich der empfangene
	Fingerabdruck von dem gespeicherten unterscheidet.  Die
	Fingerabdr&uuml;cke der Version 1 werden in
	<filename>~/.ssh/known_hosts</filename>, die der Version 2 in
	<filename>~/.ssh/known_hosts2</filename>  gespeichert.</para>

      <para>In der Voreinstellung akzeptieren OpenSSH Server Verbindungen
        mit SSH v1 und SSH v2.  Die Clients k&ouml;nnen sich aber das
	Protokoll ausw&auml;hlen, dabei wird das Protokoll der Version 2
	als robuster und sicherer als die Vorg&auml;ngerversion
	angesehen.</para>

      <para>Mit den Optionen <option>-1</option> oder <option>-2</option>
        kann die Protokollversion, die <command>ssh</command> verwendet,
	erzwungen werden.</para>
    </sect2>

    <sect2>
      <title>Secure Copy</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>secure copy</secondary>
      </indexterm>
      <indexterm><primary><command>scp</command></primary></indexterm>

      <para>Mit <command>scp</command> lassen sich Dateien analog wie mit
        <command>rcp</command> auf entfernte Maschinen kopieren.  Mit
	<command>scp</command> werden die Dateien allerdings in einer
	sicheren Weise &uuml;bertragen.</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@example.com's password:
COPYRIGHT            100% |*****************************|  4735
00:00
&prompt.root;</screen>
      <para>Da der Fingerabdruck schon im vorigen Beispiel abgespeichert
        wurde, wird er bei der Verwendung von <command>scp</command> in
	diesem Beispiel &uuml;berpr&uuml;ft.  Da die Fingerabdr&uuml;cke
	&uuml;bereinstimmen, wird keine Warnung ausgegeben.</para>

      <para>Die Argumente, die <command>scp</command> &uuml;bergeben
        werden, gleichen denen von <command>cp</command> in der Beziehung,
	dass die ersten Argumente die zu kopierenden Dateien sind und
	das letzte Argument den Bestimmungsort angibt.  Da die Dateien
	&uuml;ber das Netzwerk kopiert werden, k&ouml;nnen ein oder mehrere
	Argumente die Form
	<option>user@host:&lt;path_to_remote_file></option>
	besitzen.</para>

    </sect2>

    <sect2>
      <title>Konfiguration</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Konfiguration</secondary>
      </indexterm>

      <para>Die f&uuml;r das ganze System g&uuml;ltigen
        Konfigurationsdateien des OpenSSH D&aelig;mons und des Clients
	finden sich in dem Verzeichnis
	<filename>/etc/ssh</filename>.</para>

      <para>Die Client-Konfiguration befindet sich in
        <filename>ssh_config</filename>, die des Servers befindet sich in
	<filename>sshd_config</filename>.</para>

      <para>Das SSH-System l&auml;sst sich weiterhin &uuml;ber die
        Anweisungen <option>sshd_program</option> (Vorgabe ist
	<filename>/usr/sbin/sshd</filename>) und
	<option>sshd_flags</option> in <filename>/etc/rc.conf</filename>
	konfigurieren.</para>
    </sect2>

    <sect2>
      <title>ssh-keygen</title>

      <para>Mit &man.ssh-keygen.1; k&ouml;nnen RSA-Schl&uuml;ssel f&uuml;r
        einen Benutzer erzeugt werden, die anstelle von
	Passw&ouml;rtern verwendet werden k&ouml;nnen.</para>

      <screen>&prompt.user; <userinput>ssh-keygen</userinput>
Initializing random number generator...
Generating p:  .++ (distance 66)
Generating q:  ..............................++ (distance 498)
Computing the keys...
Key generation complete.
Enter file in which to save the key (/home/user/.ssh/identity):
Enter passphrase:
Enter the same passphrase again:
Your identification has been saved in /home/user/.ssh/identity.
...</screen>

      <para>&man.ssh-keygen.1; erzeugt einen &ouml;ffentlichen und einen
        privaten Schl&uuml;ssel f&uuml;r die Authentifizierung.  Der private
	Schl&uuml;ssel wird in <filename>~/.ssh/identity</filename>, der
	&ouml;ffentliche Schl&uuml;ssel in
	<filename>~/.ssh/identity.pub</filename> gespeichert.  Damit die
	RSA-Schl&uuml;ssel zur Authentifizierung verwendet werden
	k&ouml;nnen, muss der &ouml;ffentliche Schl&uuml;ssel in der
	Datei <filename>~/.ssh/authorized_keys</filename> auf der
	entfernten Maschine abgelegt werden.</para>

      <para>Damit werden Verbindungen zu der entfernten Maschine &uuml;ber
	den RSA-Mechanismus anstelle von Passw&ouml;rtern
	authentifiziert.</para>

      <para>Wenn bei der Erstellung der Schl&uuml;ssel mit
	&man.ssh-keygen.1; ein Passwort angegeben wurde, wird der
	Benutzer bei jeder Anmeldung zur Eingabe des Passworts
	aufgefordert.</para>

      <para>Zum gleichen Zweck kann ein DSA-Schl&uuml;ssel zur Verwendung
        mit SSH v2 erstellt werden.  Dazu rufen Sie das Kommando
	<command>ssh-keygen -d</command> oder <command>ssh-keygen -t
	dsa</command> mit FreeBSD &os.current; auf.  Sie erzeugen damit ein
	DSA-Schl&uuml;sselpaar, das nur in SSH v2 Verbindungen genutzt
	wird.  Der &ouml;ffentliche Schl&uuml;ssel wird in
	<filename>~/.ssh/id_dsa.pub</filename>, der private Schl&uuml;ssel
	in <filename>~/.ssh/id_dsa</filename> gespeichert.</para>

      <para>Die &ouml;ffentlichen DSA-Schl&uuml;ssel werden in
        <filename>~/.ssh/authorized_keys2</filename> auf der entfernten
        Maschine abgelegt.</para>

      <para>Mit &man.ssh-agent.1; und &man.ssh-add.1; k&ouml;nnen Sie
        mehrere durch Passw&ouml;rter gesch&uuml;tzte private
	Schl&uuml;ssel verwalten.</para>
    </sect2>

    <sect2>
      <title>SSH Tunnel</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Tunnel</secondary>
      </indexterm>

      <para>Mit OpenSSH ist es m&ouml;glich, einen Tunnel zu erstellen, in
        dem ein anderes Protokoll verschl&uuml;sselt &uuml;bertragen
	wird.</para>

      <para>Das folgende Kommando erzeugt einen Tunnel f&uuml;r
        <application>telnet</application>:</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

      <para>Dabei wurden die folgenden Optionen von <command>ssh</command>
        verwendet:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>

	  <listitem>
	    <para>Erzwingt die Version 2 des Protokolls (Benutzen Sie die
	      Option nicht mit langsamen
	      <application>ssh</application>-Servern).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>Zeigt an, dass ein Tunnel erstellt werden soll.
	      Ohne diese Option w&uuml;rde <command>ssh</command> eine
	      normale Sitzung &ouml;ffnen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Zwingt <command>ssh</command> im Hintergrund zu
	      laufen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Ein lokaler Tunnel wird in der Form
	      <replaceable>localport:remotehost:remoteport</replaceable>
	      angegeben.  Die Verbindung wird dabei von dem lokalen Port
	      <replaceable>localport</replaceable> auf einen entfernten
	      Rechner weitergeleitet.</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>Gibt den entfernten SSH server an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>


       <para>Ein SSH-Tunnel erzeugt ein Socket auf
         <hostid>localhost</hostid> und dem angegebenen Port.  Jede
	 Verbindung, die auf dem angegebenen Socket aufgemacht wird, wird
	 dann auf den spezifizierten entfernten Rechner und Port
	 weitergeleitet.</para>

       <para>Im Beispiel wird der Port <replaceable>5023</replaceable> auf
	 die entfernte Maschine und dort auf <hostid>localhost</hostid>
	 Port <replaceable>23</replaceable> weitergeleitet.  Da der Port
	 <replaceable>23</replaceable> f&uuml;r Telnet reserviert ist,
	 erzeugt das eine sichere Telnet Verbindung durch einen
	 SSH-Tunnel.</para>

       <para>Diese Vorgehensweise kann genutzt werden, um jedes unsichere
         TCP-Protokoll wie SMTP, POP3, FTP, usw. weiterzuleiten.</para>

       <example>
       <title>Mit SSH einen sicheren Tunnel f&uuml;r SMTP erstellen</title
       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>

       <para>Zusammen mit &man.ssh-keygen.1; und zus&auml;tzlichen
         Benutzer-Accounts k&ouml;nnen Sie leicht benutzbare SSH-Tunnel
	 aufbauen.  Anstelle von Passw&ouml;rtern k&ouml;nnen Sie
	 Schl&uuml;ssel benutzen und jeder Tunnel kann unter einem eigenen
	 Benutzer laufen.</para>
       </example>

      <sect3>
	<title>Beispiel f&uuml;r SSH-Tunnel</title>

	<sect4>
	  <title>Sicherer Zugriff auf einen POP3-Server</title>

	  <para>Nehmen wir an, an Ihrer Arbeitsstelle gibt es einen
	    SSH-Server, der Verbindungen von au&szlig;en akzeptiert.  Auf
	    dem Netzwerk Ihrer Arbeitsstelle soll sich zudem noch ein
	    Mail-Server befinden, der POP3 spricht.  Das Netzwerk oder die
	    Verbindung von Ihrem Haus zu Ihrer Arbeitsstelle ist unsicher
	    und daher m&uuml;ssen Sie Ihre E-Mail &uuml;ber eine gesicherte
	    Verbindung abholen k&ouml;nnen.  Die L&ouml;sung zu diesem
	    Problem besteht darin, eine SSH-Verbindung von Ihrem Haus zu
	    dem SSH-Server an Ihrer Arbeitsstelle aufzubauen, und von dort
	    weiter zum Mail-Server zu tunneln.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Wenn Sie den Tunnel eingerichtet haben, konfigurieren Sie
	    Ihren Mail-Client so, dass er POP3 Anfragen zu
	    <hostid>localhost</hostid> Port 2110 sendet.  Die Verbindung
	    wird dann sicher zu <hostid>mail.example.com</hostid>
	    weitergeleitet.</para>
	</sect4>

	<sect4>
	  <title>Umgehen einer strengen Firewall</title>

	  <para>Einige Netzwerkadministratoren stellen sehr drakonische
	    Firewall-Regeln auf, die nicht nur einkommende Verbindungen
	    filtern, sondern auch ausgehende.  Es kann sein, dass Sie
	    externe Maschinen nur &uuml;ber die Ports 22 und 80 (SSH und
	    Web) erreichen.</para>

	  <para>Sie wollen auf einen Dienst, der vielleicht nichts mit
	    Ihrer Arbeit zu tun hat, wie einen Ogg Vorbis Musik-Server,
	    zugreifen.  Wenn der Ogg Vorbis Server nicht auf den Ports 22
	    oder 80 l&auml;uft, k&ouml;nnen Sie aber nicht auf ihn
	    zugreifen.</para>

	  <para>Die L&ouml;sung hier ist es, eine SSH-Verbindung zu einer
	    Maschine au&szlig;erhalb der Firewall aufzumachen und durch
	    diese zum Ogg Vorbis Server zu tunneln.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled.myserver.com</replaceable></userinput>
user@unfirewalled.myserver.com's password: <userinput>*******</userinput></screen>

	  <para>Konfigurieren Sie Ihren Client so, dass er
	    <hostid>localhost</hostid> und Port 8888 benutzt.  Die Verbindung
	    wird dann zu <hostid>music.example.com</hostid> Port 8000
	    weitergeleitet und Sie haben die Firewall erfolgreich
	    umgangen.</para>
      </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Weiterf&uuml;hrende Informationen:</title>
      <para><ulink url="http://www.openssh.com/">OpenSSH</ulink></para>
      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1;
        &man.ssh-agent.1; &man.ssh-add.1;</para>
      <para>&man.sshd.8; &man.sftp-server.8;</para>
    </sect2>
  </sect1>

  <sect1 id="mac">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Robert</firstname>
	  <surname>Watson</surname>
	  <contrib>Gef&ouml;rdert von DARPA und Network Associates Laboratories.
	    Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>MAC</primary>
    </indexterm>
    <title>Vorgeschriebene Zugriffskontrolle (MAC)</title>

    <para>In FreeBSD&nbsp;5.0 wurde ein neues kernelbasiertes
      Sicherheitssystem eingef&uuml;hrt: das TrustedBSD-MAC-Framework.
      Das MAC-Framework erlaubt die Erweiterung der Zugriffskontrollen des
      Kernels beim &Uuml;bersetzen, beim Systemstart und zur Laufzeit.
      Damit lassen sich Module laden, die vorgeschriebene Zugriffskontrollen
      (<foreignphrase>Mandatory Access Control</foreignphrase>,
      <acronym>MAC</acronym>) bereitstellen, oder angepasste Module laden,
      die zur Systemh&auml;rtung eingesetzt werden k&ouml;nnen.  Das
      MAC-Framework befindet sich noch im Teststadium und sollte daher
      erst nach sorgf&auml;ltigen &Uuml;berlegungen auf produktiven Systemen
      eingesetzt werden.  Voraussichtlich wird das MAC-Framework ab
      FreeBSD&nbsp;5.2 produktionsreif sein.</para>

    <para>Wenn das MAC-Framework im Kernel aktiviert ist, k&ouml;nnen
      Sicherheitsmodule die Zugriffskontrollen des Kernels erweitern und
      damit Zugriffe auf Systemdienste oder Systemobjekte
      einschr&auml;nken.  Beispielsweise erweitert das
      &man.mac.bsdextended.4;-Modul die Zugriffskontrollen
      auf Dateisysteme und erlaubt es, Regels&auml;tze, wie sie analog
      in Firewalls verwendet werden, aufzustellen, die Zugriffe auf
      Dateisystemobjekte anhand der Benutzer-ID und der Zugeh&ouml;rigkeit
      zu Gruppen regeln.  Einige Module, wie das
      &man.mac.seeotheruids.4;-Modul, m&uuml;ssen gar nicht
      oder nur minimal konfiguriert werden, andere Module, wie das
      &man.mac.biba.4;-Modul oder das
      &man.mac.mls.4;-Modul, sind aufw&auml;ndig zu
      konfigurieren, da sie Objekte systemweit kennzeichnen.</para>

    <para>F&uuml;gen Sie die nachstehende Zeile der Kernelkonfiguration
      hinzu, um das MAC-Framework zu aktivieren:</para>

    <programlisting>options MAC</programlisting>

    <para>Die Sicherheitsmodule des Basissystems k&ouml;nnen Sie mit
      &man.kldload.8; oder w&auml;hrend des Systemstarts mit &man.loader.8;
      laden oder mit den nachstehenden Optionen fest in den Kernel
      einbinden.</para>

    <para>Die Zugriffsrichtlinien (<foreignphrase>policy</foreignphrase>)
      der Module werden unterschiedlich konfiguriert.  Oft l&auml;sst sich
      ein Modul &uuml;ber den Namensraum <varname>security.mac</varname>
      der &man.sysctl.8;-<acronym>MIB</acronym> konfigurieren.  Richtlinien,
      die vom Dateisystem oder bestimmten Kennzeichen abh&auml;ngen,
      erfordern vielleicht eine initiale Konfiguration, in der
      Systemobjekten Kennzeichen zugeordnet werden m&uuml;ssen oder eine
      Konfigurationsdatei f&uuml;r die Richtlinie erstellt werden muss.
      Die erforderlichen Schritte werden in den Hilfeseiten des
      betreffenden Moduls beschrieben.</para>

    <para>Zur Konfiguration des MAC-Frameworks und der Kennzeichen, die von
      verschiedenen Richtlinien verwendet werden, stehen eine Reihe von
      Werkzeugen zur Verf&uuml;gung.  Das Anmeldeverfahren und die
      Verwaltung von Berechtigungsnachweisen (&man.setusercontext.3;)
      wurden erweitert, so dass Kennzeichen f&uuml;r Benutzerkonten mit
      &man.login.conf.5; eingerichtet werden k&ouml;nnen.  Um Kennzeichen
      auf Prozessen, Dateien und Adaptern lesen und schreiben zu
      k&ouml;nnen, wurden &man.su.1;, &man.ps.1;, &man.ls.1; und
      &man.ifconfig.8; ge&auml;ndert.  Zur Verwaltung der Kennzeichen
      wurden neue Werkzeuge eingef&uuml;hrt, beispielsweise &man.getfmac.8;,
      &man.setfmac.8; und &man.setfsmac.8; zur Verwaltung von
      Dateikennzeichen  oder &man.getpmac.8; und &man.setpmac.8;.</para>

    <para>Die folgende Aufstellung beschreibt alle mit FreeBSD&nbsp;5.0
      ausgelieferten Sicherheitsmodule.</para>
    <sect2 id="mac-policy-biba">
      <title>Biba-Richtlinie zur Sicherung der Integrit&auml;t
	(mac_biba)</title>
      <indexterm>
	<primary>Richtlinie</primary>
	<secondary>Biba-Richtlinie,
	  <foreignphrase>Biba Integrity Policy</foreignphrase></secondary>
      </indexterm>
      <para>Hersteller: TrustedBSD Project</para>
      <para>Modulname: <filename>mac_biba.ko</filename></para>
      <para>Kerneloption: <literal>MAC_BIBA</literal></para>
      <para>Die Biba-Richtlinie (<foreignphrase>Biba Integrity
          Policy</foreignphrase>, &man.mac.biba.4;) kennzeichnet die
	Integrit&auml;t aller Systemobjekte (die Kennzeichnung kann
	hierarchisch oder nicht-hierarchisch erfolgen) und erzwingt
	einen Informationsflu&szlig;, der verhindert, dass Objekte
	mit hoher Integrit&auml;t von Subjekten mit niedriger Integrit&auml;t
	ver&auml;ndert werden.  Die Integrit&auml;t der Objekte wird
	dadurch sichergestellt, dass Subjekte mit hoher Integrit&auml;t
	(&uuml;blicherweise Prozesse) nicht lesend auf Objekte niedrigerer
	Integrit&auml;t (h&auml;ufig Dateien) zugreifen d&uuml;rfen
	und Subjekte niedrigerer Integrit&auml;t nicht schreibend auf
	Objekte h&ouml;herer Integrit&auml;t zugreifen d&uuml;rfen.
	Diese Richtlinie dient h&auml;ufig zum Schutz der
	<foreignphrase>Trusted Code Base</foreignphrase> in
	kommerziellen Sicherheitssystemen.  Da die Biba-Richtlinie
	systemweite Kennzeichen zur Verf&uuml;gung stellt, muss Sie
	fest in den Kernel integriert sein oder zum Zeitpunkt des
	Systemstarts geladen werden.</para>
    </sect2>

    <sect2 id="mac-policy-bsdextended">
      <title>Dateisystem-Richtlinie (mac_bsdextended)</title>
      <indexterm>
	<primary>Richtlinie</primary>
	<secondary>Dateisystem-Richtlinie,
	  <foreignphrase>File System Firewall Policy</foreignphrase></secondary>
      </indexterm>
      <para>Hersteller: TrustedBSD Project</para>
      <para>Modulname: <filename>mac_bsdextended.ko</filename></para>
      <para>Kerneloption: <literal>MAC_BSDEXTENDED</literal></para>
      <para>Die Dateisystem-Richtlinie (<foreignphrase>File System Firewall
          Policy</foreignphrase>, &man.mac.bsdextended.4;) erweitert
	die Zugriffsrechte des BSD-Dateisystems.  Ein Administrator kann
	f&uuml;r Zugriffe auf Dateisystemobjekte anderer Benutzer
	und Gruppen Regels&auml;tze, analog den von Firewalls verwendeten,
	definieren.  Die Regels&auml;tze, die mit &man.ugidfw.8; verwaltet
	werden, beschr&auml;nken den Zugriff auf Dateien und Verzeichnisse
	aufgrund der UID und der GID des zugreifenden Prozesses sowie dem
	Besitzer und der Gruppe des Objekts auf das zugegriffen werden
	soll.  Da alle Regeln die m&ouml;glichen Zugriffe beschr&auml;nken,
	k&ouml;nnen sie in beliebiger Reihenfolge angelegt werden.  Diese
	Richtlinie erfordert keine gesonderte Konfiguration oder die
	Vergabe von Kennzeichen und mag f&uuml;r Mehrbenutzer-Umgebungen
	geeignet sein, in denen vorgeschriebene Zugriffskontrollen f&uuml;r
	den Datenaustausch zwischen Benutzern erforderlich sind.  Seien Sie
	vorsichtig, wenn Sie die Zugriffe auf Dateien von
	<username>root</username> oder anderen System-Accounts
	einschr&auml;nken.  Viele n&uuml;tzliche Programme und
	Verzeichnisse geh&ouml;ren diesen Benutzern und die falsche
	Anwendung der Dateisystem-Richtlinie kann, wie ein falscher
	Regelsatz einer Firewall, das System unbrauchbar machen.  Mithilfe
	der Bibliothek &man.libugidfw.3; k&ouml;nnen leicht neue Werkzeuge zur
	Verwaltung der Regels&auml;tze geschrieben werden.</para>
    </sect2>

    <sect2 id="mac-policy-ifoff">
      <title>Interface-silencing-Richtlinie (mac_ifoff)</title>
      <indexterm>
	<primary>Richtlinie</primary>
	<secondary>Interface-silencing-Richtlinie,
	  <foreignphrase>Interface Silencing Policy</foreignphrase></secondary>
      </indexterm>
      <para>Hersteller: TrustedBSD Project</para>
      <para>Modulname: mac_ifoff.ko</para>
      <para>Kerneloption: <literal>MAC_IFOFF</literal></para>
      <para>Die Interface-silencing-Richtlinie (&man.mac.ifoff.4;)
	verhindert, das die Netzwerkkarte vom Systemstart an bis zu dem
	Zeitpunkt, an dem sie explizit aktiviert wird, benutzt werden kann.
	Damit verhindert die Richtlinie ungewollte Antworten auf
	eingehende Pakete.  Diese Richtlinie eignet sich f&uuml;r
	Umgebungen, in denen der Netzverkehr passiv, das hei&szlig;t ohne
	eigene Pakete zu erzeugen, beobachtet werden soll.</para>
    </sect2>

    <sect2 id="mac-policy-lomac">
      <title>Low-Watermark Mandatory Access Control (mac_lomac)</title>
      <indexterm>
	<primary>Richtlinie</primary>
	<secondary>Low-Watermark Mandatory Access Control (LOMAC)</secondary>
      </indexterm>
      <indexterm>
	<primary>LOMAC</primary>
      </indexterm>
      <para>Hersteller: Network Associates Laboratories</para>
      <para>Modulname: <filename>mac_lomac.ko</filename></para>
      <para>Kerneloption: <literal>MAC_LOMAC</literal></para>
      <para>Wie die Biba-Richtlinie kennzeichnet die LOMAC-Richtlinie
        (&man.mac.lomac.4;) systemweit die Integrit&auml;t aller Objekte.
        Im Gegensatz zur Biba-Richtlinie k&ouml;nnen allerdings Subjekte
	hoher Integrit&auml;t lesend auf Objekte niedrigerer
	Integrit&auml;t zugreifen.  In diesem Fall wird aber die
	Integrit&auml;t des lesenden Subjekts heruntergesetzt, damit dieses
	nicht mehr schreibend auf Objekte mit hoher Integrit&auml;t
	zugreifen kann.  Diese Richtlinie ist leichter als die
	Biba-Richtlinie zu benutzen und zu konfigurieren.  Da sie
	allerdings systemweit die Objekte kennzeichnet, muss sie, wie die
	Biba-Richtlinie, fest in den Kernel eingebunden sein oder beim
	Systemstart geladen werden.</para>
    </sect2>

    <sect2 id="mac-policy-mls">
      <title>Multi-Level-Security Richtlinie (mac_mls)</title>
      <indexterm>
	<primary>Richtlinie</primary>
	<secondary>Multi-Level-Security Richtlinie (MLS)</secondary>
      </indexterm>
      <indexterm>
	<primary>MLS</primary>
      </indexterm>
      <para>Hersteller: TrustedBSD Project</para>
      <para>Modulname: <filename>mac_mls.ko</filename></para>
      <para>Kerneloption: <literal>MAC_MLS</literal></para>
      <para>Die Multi-Level-Security Richtlinie (<acronym>MLS</acronym>,
        &man.mac.mls.4;) stellt systemweit hierarchische und
	nicht-hierarchische Kennzeichen zur Markierung der Vertraulichkeit
	von Objekten zur Verf&uuml;gung.  Die Richtlinie stellt einen
	Informationsflu&szlig; sicher, der garantiert, dass vertrauliche
	Daten nicht unberechtigt weitergeleitet werden.  Die MLS-Richtlinie
	wird h&auml;ufig zusammen mit der Biba-Richtlinie in sicheren
	kommerziellen Mehrbenutzerumgebungen verwendet.
	Mit hierarchischen Kennzeichen k&ouml;nnen Zugangsberechtigungen zu
	Verschlusssachen (Einteilung in <quote>streng geheim</quote>,
	<quote>geheim</quote>, usw.) abgebildet werden.  Nicht-hierarchische
	Kennzeichen dienen zur Verwirklichung des Prinzips <quote>Kenntnis
	nur, wenn n&ouml;tig</quote> (<foreignphrase>need to
	  know</foreignphrase>).  Alle Systemobjekte m&uuml;ssen wie bei
	der Biba-Richtlinie vorher gekennzeichnet werden, so dass die
	Richtlinie fest in den Kernel eingebunden werden muss oder beim
	Systemstart als Modul geladen werden muss.  Der
	Konfigurationsaufwand der MLS-Richtlinie kann analog zur
	Biba-Richtlinie sehr hoch sein.</para>
    </sect2>

    <sect2 id="mac-policy-none">
      <title>Rumpf-Richtlinie (mac_none)</title>
      <indexterm>
	<primary>Richtlinie</primary>
	<secondary>Rumpf-Richtlinie,
	  <foreignphrase>MAC Stub Policy</foreignphrase></secondary>
      </indexterm>
      <para>Hersteller: TrustedBSD Project</para>
      <para>Modulname: <filename>mac_none.ko</filename></para>
      <para>Kerneloption: <literal>MAC_NONE</literal></para>
      <para>Die Rumpf-Richtlinie (<foreignphrase>MAC Stub
          Policy</foreignphrase>, &man.mac.none.4;) ist als Beispiel
        f&uuml;r Entwickler gedacht.  Sie stellt alle ben&ouml;tigten
	Funktionen zur Verf&uuml;gung, ohne die Zugriffsrechte im System zu
	ver&auml;ndern.  Auf einem Produktionssystem ist die Anwendung
	dieser Richtlinie nicht sehr sinnvoll.</para>
    </sect2>

    <sect2 id="mac-policy-partition">
      <title>Partitions-Richtlinie (mac_partition)</title>
      <indexterm>
	<primary>Richtlinie</primary>
	<secondary>Partitions-Richtlinie,
	  <foreignphrase>Process Partition Policy</foreignphrase></secondary>
      </indexterm>
      <para>Hersteller: TrustedBSD Project</para>
      <para>Modulname: <filename>mac_partition.ko</filename></para>
      <para>Kerneloption: <literal>MAC_PARTITION</literal></para>
      <para>Die Partitions-Richtlinie (<foreignphrase>Process Partition
          Policy</foreignphrase>, &man.mac.partition.4;) schr&auml;nkt
	die Sichtbarkeit von Prozessen ein, indem Prozessen Partitionsnummern
	zugewiesen werden.  Besitzt ein Prozess keine Partitionsnummer,
	so kann er alle Prozesse auf dem System sehen, besitzt er hingegen
	eine Partitionsnummer, so kann er nur Prozesse in derselben
	Partition sehen.  Die Richtlinie kann
	fest in den Kernel eingebunden werden, beim Systemstart oder zur
	Laufzeit geladen werden.</para>
    </sect2>

    <sect2 id="mac-policy-seeotheruids">
      <title>See Other Uids (mac_seeotheruids)</title>
      <indexterm>
	<primary>Richtlinie
	<secondary><foreignphrase>See Other Uids</foreignphrase></secondary>
      </indexterm>
      <para>Hersteller: TrustedBSD Project</para>
      <para>Modulname: <filename>mac_seeotheruids.ko</filename></para>
      <para>Kerneloption: <literal>MAC_SEEOTHERUIDS</literal></para>
      <para>Die Richtlinie <foreignphrase>See Other Uids</foreignphrase>
        (&man.mac.seeotheruids.4;) schr&auml;nkt wie &man.mac.partition.4;
	die Sichtbarkeit von Prozessen ein.  Allerdings wird die
	Sichtbarkeit anderer Prozesse von den Berechtigungen eines
	Prozesses anstelle einer Partitionsnummer bestimmt.  Die Richtlinie
	kann so konfiguriert werden, dass sie f&uuml;r bestimmte Accounts
	oder Gruppen nicht gilt, so dass beispielsweise Systemverwalter
	alle Prozesse sehen k&ouml;nnen.  Die Richtlinie kann
	fest in den Kernel eingebunden werden, beim Systemstart oder zur
	Laufzeit geladen werden.</para>
    </sect2>

    <sect2 id="mac-policy-test">
      <title>Test-Richtlinie (mac_test)</title>
      <indexterm>
	<primary>Richtlinie</primary>
	<secondary>Test-Richtlinie,
	  <foreignphrase>MAC Framework Test Policy</foreignphrase></secondary>
      </indexterm>
      <para>Hersteller: TrustedBSD Project</para>
      <para>Modulname: <filename>mac_test.ko</filename></para>
      <para>Kerneloption: <literal>MAC_TEST</literal></para>
      <para>Die Test-Richtlinie (<foreignphrase>MAC Framework Test
          Policy</foreignphrase>, &man.mac.test.4;) stellt einen
        Regressions-Test f&uuml;r das MAC-Framework bereit.  Die Richtlinie
	f&uuml;hrt zu einem Systemstopp f&uuml;r den Fall, dass interne
	Pr&uuml;fungen auf korrekte Kennzeichen fehlschlagen.  Sie kann
	fest in den Kernel eingebunden werden, beim Systemstart oder zur
	Laufzeit geladen werden.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

