<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     Original Revision 1.7
     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/users/chapter.sgml,v 1.5 2001/12/14 17:48:39 mheinen Exp $
-->

<chapter id="users">
  <title>Benutzer und grundlegende Account-Verwaltung</title>
  
  <sect1 id="users-synopsis">
    <title>&Uuml;bersicht</title>
    
    <para><emphasis>Beigesteuert von &a.nbm; im Februar 2000. &Uuml;bersetzt
      von &a.de.robert; im Juli 2000.</emphasis></para>
    
    <para>Jeder Zugriff auf das System geschieht &uuml;ber Accounts und alle
      Prozesse werden von Benutzern gestartet, also sind Benutzer- und
      Account-Verwaltung von wesentlicher Bedeutung in FreeBSD-Systemen.</para>

    <para>Es gibt drei Haupttypen von Accounts: Der
      <link linkend="users-superuser">Superuser</link>,
      <link linkend="users-system">Systembenutzer</link> und
      <link linkend="users-user">Benutzer-Accounts</link>.  Der
      Superuser-Account, normalerweise <username>root</username> genannt, wird
      benutzt, um das System ohne Beschr&auml;nkungen auf Privilegien zu
      verwalten.  Systembenutzer starten Dienste.  Abschliessend werden
      Benutzer-Accounts von echten Menschen genutzt, die sich einloggen, Mails
      lesen und so weiter.</para>
  </sect1>
    
  <sect1 id="users-superuser">
    <title>Der Superuser-Account</title>
    
    <para>Der Superuser-Account, normalerweise <username>root</username>
      genannt, ist vorkonfiguriert und erleichtert die Systemverwaltung, sollte
      aber nicht f&uuml;r allt&auml;gliche Aufgaben wie verschicken und
      empfangen von Mails, Entdecken des Systems oder Programmierung benutzt
      werden.</para>
      
    <para>Das ist so, da der Superuser im Gegensatz zu normalen
      Benutzer-Accounts ohne Beschr&auml;nkungen operiert und falsche
      Anwendung des Superuser-Accounts in spektakul&auml;ren Katastrophen
      resultieren kann.  Benutzer-Accounts sind nicht f&auml;hig das System
      versehentlich zu zerst&ouml;ren, deswegen ist es generell am besten
      normale Benutzer-Accounts zu verwenden, solange man nicht
      haupts&auml;chlich die extra Privililegien ben&ouml;tigt.</para>

    <para>Zus&auml;tzlich sollten Sie Kommandos, die Sie als Superuser
      eingeben, immer doppelt und dreifach &uuml;berpr&uuml;fen, da ein
      zus&auml;tzliches Leerzeichen oder ein fehlender Buchstabe irreparablen
      Datenverlust bedeuten kann. Diese zus&auml;tzlichen Privilegien, die Sie
      ben&ouml;tigten, als Sie zu dem Superuser-Account gewechselt haben,
      bedeuten, dass die Absicherung Ihres normalen Benutzer-Accounts nicht
      mehr g&uuml;ltig ist.</para>

    <para>Das erste, das Sie tun sollten, nachdem Sie dieses Kapitel gelesen
      haben, ist einen unprivilegierten Benutzer f&uuml;r Ihre eigene normale
      Benutzung zu erstellen, wenn Sie das nicht bereits getan haben.  Das
      trifft immer zu, egal ob Sie ein Mehrbenutzer-System oder ein System
      laufen haben, welches Sie alleine benutzen.  Sp&auml;ter in diesem
      Kapitel besprechen wir, wie man zus&auml;tzliche Accounts erstellt und
      wie man zwischen dem normalen Benutzer und dem Superuser wechselt.</para>
  </sect1>
    
  <sect1 id="users-system">
    <title>System-Accounts</title>

    <para>Systembenutzer starten Dienste wie DNS, mail, Web-Server und so
      weiter.  Der Grund daf&uuml;r ist die Sicherheit; wenn die Programme
      von dem Superuser gestartet werden, k&ouml;nnen Sie ohne
      Einschr&auml;nkungen handeln.</para>

    <para>Beispiele von Systembenutzern sind <username>daemon</username>,
      <username>operator</username>, <username>bind</username> (f&uuml;r den
      Domain Name Service) und <username>news</username>.  Oft erstellen
      Systemadministratoren den Benutzer <username>httpd</username>, um
      Web-Server laufen zu lassen, die sie installieren.</para>

    <para><username>nobody</username> ist der generische unprivilegierte
      Systembenutzer, aber je mehr Dienste nobody benutzen, um so
      privilegierter wird er.</para>
  </sect1>

  <sect1 id="users-user">
    <title>Benutzer-Accounts</title>

    <para>Benutzer-Account sind das prim&auml;re Mittel des Zugriffs f&uuml;r
      echte Menschen auf das System und isolieren Benutzer und Umgebung,
      sch&uuml;tzen die Benutzer davor das System oder Daten anderer Benutzer
      zu besch&auml;digen und erlauben Benutzern ihre Umgebung selbst
      einzurichten, ohne das sich dies auf andere auswirkt.</para>

    <para>Jede Person, die auf Ihr System zugreift, sollte ihren eigenen
      Account besitzen.  Das erlaubt Ihnen herauszufinden, wer was macht
      und h&auml;lt Leute davon ab, die Einstellungen der anderen zu
      ver&auml;ndern oder mails zu lesen, die nicht f&uuml;r sie bestimmt
      waren.</para>

    <para>Jeder Benutzer kann seine eigene Umgebung einstellen, um sie
      der Benutzung auf dem System anzupassen: Alternative Shells, Editoren,
      Tastaturbelegungen und Sprache.</para>
  </sect1>

  <sect1 id="users-modifying">
    <title>Accounts ver&auml;ndern</title>

    <para><application>pw</application> ist ein m&auml;chtiges und flexibles
      Mittel zum &Auml;ndern von Accounts, aber <application>adduser
      </application> wird empfohlen zum Erstellen und <application>rmuser
      </application> zum L&ouml;schen von Accounts.</para>

    <para><application>chpass</application> erlaubt dem Systemadministrator
      und normalen Benutzern Passw&ouml;rter, Shells und personelle
      Informationen einzustellen.  Jedoch ist <application>passwd</application>
      das gew&ouml;hnlichere Mittel, um Passw&ouml;rter im speziellen zu
      &auml;ndern.</para>

    <sect2 id="users-adduser">
      <title>adduser</title>

      <para><application>adduser</application> ist ein einfaches Programm
        um neue Benutzer hinzuzuf&uuml;gen.  Es erstellt <filename>passwd
        </filename> und <filename>group</filename> Eintr&auml;ge f&uuml;r den
        Benutzer, genauso wie ein home Verzeichnis, kopiert ein paar
        vorgegebene dotfiles aus <filename>/usr/share/skel</filename> und kann
        optional dem Benutzer eine ,,Willkommen``-Nachricht zuschicken.</para>

      <para>Um die anf&auml;ngliche Konfigurationsdatei zu erstellen,
        benutzen Sie: <command>adduser -s -config_create</command>.
        <footnote>
          <para>Das <option>-s</option> bringt <application>adduser
            </application> dazu, weniger Fragen und Fehlermeldungen auszugeben.
            Wir benutzen <option>-v</option> sp&auml;ter, wenn wir die
            Voreinstellungen &auml;ndern wollen.</para>
        </footnote>
        Zun&auml;chst konfigurieren wir addusers Voreinstellungen und
        erstellen unseren ersten Benutzer-Account, da es b&ouml;se und
        unangenehm ist, root f&uuml;r normale Aufgaben zu verwenden.</para>
      <example>
        <title>Die Konfiguration f&uuml;r adduser &auml;ndern</title>

        <screen>&prompt.root; <userinput>adduser -v</userinput>
Use option ``-silent'' if you don't want to see all warnings and questions.
Check /etc/shells
Check /etc/master.passwd
Check /etc/group
Enter your default shell: csh date no sh tcsh [sh]: <userinput>tcsh</userinput>
Your default shell is: tcsh -> /usr/local/bin/tcsh
Enter your default HOME partition: [/home]:
Copy dotfiles from: /usr/share/skel no [/usr/share/skel]: 
Send message from file: /etc/adduser.message no 
[/etc/adduser.message]: <userinput>no</userinput>
Do not send message
Use passwords (y/n) [y]: <userinput>y</userinput>

Write your changes to /etc/adduser.conf? (y/n) [n]: <userinput>y</userinput>

Ok, let's go.
Don't worry about mistakes. I will give you the chance later to correct any input.
Enter username [a-z0-9_-]: <userinput>jru</userinput>
Enter full name []: <userinput>J. Random User</userinput>
Enter shell csh date no sh tcsh [tcsh]: 
Enter home directory (full path) [/home/jru]: 
Uid [1001]: 
Enter login class: default []: 
Login group jru [jru]: 
Login group is ``jru''. Invite jru into other groups: guest no 
[no]: <userinput>wheel</userinput>
Enter password []: 
Enter password again []: 

Name:     jru
Password: ****
Fullname: J. Random User
Uid:      1007
Gid:      1007 (jru)
Class:
Groups:   jru wheel
HOME:     /home/jru
Shell:    /usr/local/bin/tcsh
OK? (y/n) [y]: <userinput>y</userinput>
Added user ``jru''
Copy files from /usr/share/skel to /home/jru
Add another user? (y/n) [y]: <userinput>n</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <para>Zusammengefasst haben wir die vorgegebene Shell in
        <application>tcsh</application> (eine zus&auml;tzliche Shell aus
        den Packages) ge&auml;ndert und das Senden einer
        ,,Willkommen``-Nachricht an neue Benutzer abgeschaltet.
        Danach haben wir die Konfiguration abgespeichert und anschliessend
        einen Account f&uuml;r <username>jru</username> eingerichtet
        und sichergestellt, dass <username>jru</username> in der
        Gruppe <username>wheel</username> ist (was sp&auml;ter wichtig ist,
        wie wir sehen werden).</para>
      <note>
        <para>Wenn Sie das Passwort eingeben, werden weder Passwort noch
          Sternchen angezeigt.  Passen Sie auf, dass Sie das Passwort nicht
          zweimal falsch eingeben. :-)</para>
      </note>
      <note>
        <para>Benutzen Sie ab jetzt <command>adduser</command> ohne Argumente,
          dann m&uuml;ssen Sie nicht jedes mal die Vorgaben neu einstellen.
          Wenn das Programm Sie fragt, ob Sie die Vorgaben &auml;ndern wollen,
          verlassen und starten Sie es erneut mit der <option>-s</option>
          Option.</para>
      </note>
    </sect2>

    <sect2 id="users-rmuser">
      <title>rmuser</title>

      <para><application>rmuser</application> entfernt Benutzer aus dem System,
        inklusive der Spuren ausserhalb der Benutzer-Datenbank.</para>

      <para><application>rmuser</application> f&uuml;hrt die folgenden
        Schritte durch:</para>

      <procedure>
        <step>
          <para>Enfernt den &man.crontab.1; Eintrag des Benutzers (wenn dieser
            existiert).</para>
        </step>
        <step>
          <para>Entfernt alle &man.at.1; jobs, die dem Benutzer geh&ouml;ren.
          </para>
        </step>
        <step>
          <para>Schliesst alle Prozesse des Benutzers.</para>
        </step>
        <step>
          <para>Entfernt den Benutzer aus der lokalen Passwort-Datei des
            Systems.</para>
        </step>
        <step>
          <para>Entfernt das home Verzeichnis des Benutzers (falls es dem
            Benutzer geh&ouml;rt).</para>
        </step>
        <step>
          <para>Entfernt die eingegangen mails, die dem Benutzer geh&ouml;ren,
          aus <filename>/var/mail</filename>.</para>
        </step>
        <step>
          <para>Entfernt alle Dateien des Benutzers aus tempor&auml;ren
            Dateispeicherbereichen wie <filename>/tmp</filename>.</para>
        </step>
        <step>
          <para>Entfernt den Benutzernamen von allen Gruppen, zu denen er
            geh&ouml;rt, aus <filename>/etc/group</filename>.

            <note>
              <para>Wenn eine Gruppe leer wird und der Gruppenname mit dem
                Benutzernamen identisch ist, wird die Gruppe entfernt; das
                erg&auml;nzt sich mit den einzelnen Benutzer-Gruppen, die von
                &man.adduser.8; f&uuml;r jeden neuen Benutzer erstellt werden.
              </para>
            </note>
          </para>
        </step>
      </procedure>

      <para><application>rmuser</application> kann nicht daf&uuml;r benutzt
        werden Superuser-Accounts zu entfernen, da dies nahezu immer ein
        Zeichen f&uuml;r eine massive Verw&uuml;stung ist.</para>

      <para>Als Vorgabe wird ein interaktiver Modus benutzt, der
        sicherzustellen versucht, dass Sie wissen, was Sie tun.</para>

      <example>
        <title>interaktives Account-Entfernen mit rmuser</title>

        <screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1000:1000::0:0:J. Random User:/home/jru:/usr/local/bin/tcsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-pw">
      <title>pw</title>

      <para><application>pw</application> ist ein Kommandozeilenprogramm, mit
        dem man Benutzer und Gruppen erstellen, entfernen und anzeigen kann,
        und fungiert als Editor der Benutzer- und Gruppendateien des Systems.
      </para>

      <para>Es wurde entworfen um n&uuml;tzlich als direkt ausgef&uuml;hrter
        Befehl und f&uuml;r die Benutzung in Shell-Scripts zu sein.</para>

      <para>Informationen dar&uuml;ber gibt es in &man.pw.8;.</para>
    </sect2>

    <sect2 id="users-chpass">
      <title>chpass</title>

      <para><application>chpass</application> &auml;ndert Informationen der
        Benutzerdatenbank wie Passw&ouml;rter, Shells und personelle
        Informationen.</para>

      <para>Nur Systemadministratoren, als Superuser, k&ouml;nnen die
        Informationen und Passw&ouml;rter der anderen Benutzer mit
        <application>chpass</application> ver&auml;ndern.</para>

      <para>Werden keine Optionen neben dem optionalen Benutzernamen
        angegeben, zeigt <application>chpass</application> einen Editor
        mit Benutzerinformationen an und wenn dieser Editor beendet wird,
        versucht es die Informationen in der Benutzerdatenbank zu
        ver&auml;ndern.</para>

      <example>
        <title>Interaktives chpass des Superusers</title>

        <screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1000
Gid [# or name]: 1000
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>Der normale Benutzer kann nur einen kleinen Teil dieser
        Informationen ver&auml;ndern und nat&uuml;rlich nur f&uuml;r sich
        selbst.</para>

      <example>
        <title>Interaktives chpass eines normalen Benutzers</title>

        <screen>#Changing user database information for jru.
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
        <para><command>chfn</command> und <command>chsh</command> sind
          nur Verweise auf <command>chpass</command>, genauso wie
          <command>ypchpass</command>, <command>ypchfn</command> und
          <command>ypchsh</command>.  NIS wird automatisch unterst&uuml;tzt,
          deswegen ist es nicht notwendig das <literal>yp</literal> vor dem
          Kommando einzugeben.</para>
      </note>
    </sect2>
    <sect2 id="users-passwd">
      <title>passwd</title>

      <para><application>passwd</application> ist der &uuml;bliche Weg Ihr
        eigenes Passwort als Benutzer zu &auml;ndern oder das Passwort eines
        anderen Benutzers als Superuser.</para>

      <note>
        <para>Benutzer m&uuml;ssen ihr urspr&uuml;ngliches Passwort eingeben,
          bevor sie es wechseln, um eine unauthorisierte Person davon
          abzuhalten ihr Passwort zu &auml;ndern, wenn der Benutzer gerade
          nicht an seinem Ger&auml;t ist.</para>
      </note>

      <example>
        <title>passwd</title>

        <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done

&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
        <para><command>yppasswd</command> ist nur ein Verweis zu
          <command>passwd</command>.  NIS wird automatisch
          unterst&uuml;tzt, also ist es nicht notwendig, <literal>yp</literal>
          vor dem Kommando einzugeben.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="users-limiting">
    <title>Benutzer einschr&auml;nken</title>

    <para>Wenn Sie ein System mit mehreren Benutzern laufen lassen, ist es
      wahrscheinlich, dass Sie nicht allen Benutzern vertrauen das System
      nicht zu besch&auml;digen.  FreeBSD bietet dem Systemadministrator
      mehrere M&ouml;glichkeiten die System-Ressourcen einzuschr&auml;nken,
      die ein einzelner Benutzer verwenden kann.  Diese Limitierungen sind
      in zwei Kategorien eingeteilt: Festplattenkontingente und andere
      Ressourcenbeschr&auml;nkungen.  Kontingente werden in
<!--
<xref linkend="quotas"> diskutiert.</para>
-->
      einem noch nicht &uuml;bersetzen Kapitel diskutiert.</para>

    <para>Festplatten-Kontingente sind ein Weg f&uuml;r den
      Systemadministrator dem Dateisystem mitzuteilen, wieviel Speicher
      ein Benutzer verwenden darf.  Mit ihrer Hilfe kann man auch die
      Gr&ouml;&szlig;e des von einem Benutzer verwendeten Platzes
      &uuml;berpr&uuml;fen, ohne jedes mal neu berechnen zu m&uuml;ssen.
      </para>

    <para>Die Login-Klassen werden in <filename>/etc/login.conf</filename>
      definiert.  Auf die pr&auml;zisen Semantiken gehen wir hier nicht
      weiter ein, sie k&ouml;nnen jedoch in der &man.login.conf.5; manpage
      nachgelesen werden.  Es ist ausreichend zu sagen, dass jeder
      Benutzer einer Login-Klasse zugewiesen wird (standardm&auml;ssig
      <literal>default</literal>) und dass jede Login-Klasse mit einem Satz
      von Login-F&auml;higkeiten verbunden ist.  Eine Login-F&auml;higkeit
      ist ein <literal><replaceable>Name</replaceable>=<replaceable>Wert
      </replaceable></literal> Paar, in dem <replaceable>Name</replaceable>
      die F&auml;higkeit bezeichnet und <replaceable>Wert</replaceable>
      ein willk&uuml;rlicher Text ist, der je nach <replaceable>Name
      </replaceable> entsprechend verarbeitet wird.  Login-Klassen und
      -F&auml;higkeiten zu definieren ist fast schon selbsterkl&auml;rend
      und wird auch in &man.login.conf.5; beschrieben.</para> 

    <para>Ressourcenbeschr&auml;nkungen unterscheiden sich von normalen
      Login-F&auml;higkeiten zweifach.  Erstens gibt es f&uuml;r jede
      Beschr&auml;nkung ein aktuelles und ein maximales Limit.  Das
      aktuelle Limit kann vom Benutzer oder einer Anwendung beliebig
      bis zum maximalem Limit ver&auml;ndert werden.  Letzteres kann
      der Benutzer nur heruntersetzen.  Zweitens gelten die meisten
      Ressourcenbeschr&auml;nkungen f&uuml;r jeden vom Benutzer
      gestarteten Prozess, nicht f&uuml;r den Benutzer selbst.
      Beachten Sie jedoch, dass diese Unterschiede durch das spezifische
      Einlesen der Limits und nicht durch die Implementation der
      Login-F&auml;higkeiten entstehen (das heisst, sie sind kein
      <emphasis>wirklich</emphasis> spezieller Fall der
      Login-F&auml;higkeiten).</para> 

    <para>Hier befinden sich die am h&auml;ufigsten benutzten
      Ressourcenbeschr&auml;nkungen (der Rest kann zusammen mit den
      anderen Login-F&auml;higkeiten in &man.login.conf.5; gefunden
      werden):</para>

    <variablelist>
      <varlistentry>
	<term><literal>coredumpsize</literal></term>

	<listitem>
          <para>Das Limit der Gr&ouml;&szlig;e einer core-Datei, die
	    von einem Programm generiert wird, unterliegt aus
	    offensichtlichen Gr&uuml;nden anderen Limits der
	    Festplattenbenutzung (zum Beispiel <literal>filesize</literal>
	    oder Festplattenkontingenten).  Es wird aber trotzdem
	    oft als weniger harte Methode zur Kontrolle des
	    Festplattenplatz-Verbrauchs verwendet: Da Benutzer die
	    core-Dateien nicht selbst erstellen, und sie oft nicht
	    l&ouml;schen, kann sie diese Option davor retten, dass
	    ihnen kein Festplattenspeicher mehr zur Verf&uuml;gung
	    steht, sollte ein grosses Programm (wie Emacs)
	    abst&uuml;rzen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>cputime</literal></term>

	<listitem>
	  <para>Die maximale Rechenzeit, die ein Prozess eines Benutzers
	    verbrauchen darf.  &Uuml;berschreitet der Prozess diesen Wert,
	    wird er vom Kernel beendet. 
	    <note>
	      <para>Die Rechen<emphasis>zeit</emphasis> wird limitiert,
		nicht die prozentuale Prozessorenbenutzung, wie es in
		einigen Feldern in &man.top.1; und &man.ps.1; dargestellt
		wird.  Letzteres war zu der Zeit, als dies hier geschrieben
		wurde nicht m&ouml;glich und w&uuml;rde eher nutzlos sein:
		Ein Compiler&mdash;ein wahrscheinlich legitimer
		Vorgang&mdash; kann leicht fast 100% des Prozessors in
		Anspruch nehmen.</para>
	    </note>
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>filesize</literal></term>

	<listitem>
	  <para>Hiermit l&auml;sst sich die maximale gr&ouml;sse einer Datei
	    bestimmen, die der Benutzer besitzen darf.  Im Gegensatz zu
<!--
 <link linkend="quotas">Festplattenkontingenten</link> ist diese
-->
Festplattenkontingenten ist diese

	    Beschr&auml;nkung nur f&uuml;r jede einzelne Datei g&uuml;ltig
	    und nicht f&uuml;r den Platz, den alle Dateien eines Benutzers
	    verwenden.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>maxproc</literal></term>

	<listitem>
	  <para>Das ist die maximale Anzahl von Prozessen, die ein
	    Benutzer starten darf, und beinhaltet sowohl Vordergrund-
	    als auch Hintergrundprozesse.  Nat&uuml;rlich darf dieser
	    Wert nicht h&ouml;her sein als das System-Limit, das in
	    <literal>kern.maxproc</literal> angegeben ist.  Vergessen
	    Sie auch nicht, dass ein zu kleiner Wert den Benutzer in
	    seiner Produktivit&auml;t einschr&auml;nken k&ouml;nnte;
	    es ist oft n&uuml;tzlich mehrfach eingeloggt zu sein, oder
	    <foreignphrase>Pipelines</foreignphrase>
	      <footnote>
		<para><foreignphrase>Pipeline</foreignphrase> =
		  <emphasis>Leitung</emphasis>.
		  Mit <foreignphrase>Pipes</foreignphrase> sind Verbindungen
		  zwischen zwei Sockets in meistens zwei verschiedenen
		  Prozessen gemeint.</para>
	      </footnote>
	    zu verwenden.  Ein paar Aufgaben, wie die Kompilierung eines
	    grossen Programms, starten mehrere Prozesse (zum Beispiel
	    &man.make.1;, &man.cc.1; und andere).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>memorylocked</literal></term>

	<listitem>
	  <para>Dieses Limit gibt an, wie viel virtueller Speicher von einem
	    Prozess maximal im Arbeitsspeicher festgesetzt werden kann.
	    (siehe auch &man.mlock.2;).  Ein paar systemkritische Programme,
	    wie &man.amd.8;, verhindern damit einen Systemzusammenbruch, der
	    auftreten k&ouml;nnte, wenn sie aus dem Speicher genommen werden.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>memoryuse</literal></term>

	<listitem>
	  <para>Bezeichnet den maximalen Speicher, den ein Prozess benutzen
	    darf und beinhaltet sowohl Arbeitsspeicher-, als auch Swap-
	    Benutzung.  Es ist kein all&uuml;bergreifendes Limit f&uuml;r
	    den Speicherverbrauch, aber ein guter Anfang.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>openfiles</literal></term>

	<listitem>
	  <para>Mit diesem Limit l&auml;sst sich die maximale Anzahl
	    der von einem Prozess des Benutzers ge&ouml;ffneten Dateien
	    festlegen.  In FreeBSD werden Dateien auch verwendet, um Sockets
	    und <foreignphrase>IPC</foreignphrase>-Kan&auml;le
	    <footnote>
	      <para><foreignphrase>IPC</foreignphrase> steht f&uuml;r
		<foreignphrase>Interprocess Communication</foreignphrase>.
		</para>
	    </footnote>
	    darzustellen.  Setzen Sie es deshalb nicht zu niedrig.  Das
	    System-Limit ist im <literal>kern.maxfiles</literal> sysctl
	    definiert.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>sbsize</literal></term>

	<listitem>
	  <para>Dieses Limit beschr&auml;nkt den Netzwerk-Speicher, und damit
	    die mbufs, die ein Benutzer verbrauchen darf.  Es stammt aus einer
	    Antwort auf einen DoS-Angriff, bei dem viele Netzwerk-Sockets
	    ge&ouml;ffnet wurden, kann aber generell dazu benutzt werden
	    Netzwerk-Verbindungen zu beschr&auml;nken.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>stacksize</literal></term>

	<listitem>
	  <para>Das ist die maximale Gr&ouml;&szlig;e, auf die der Stack
	    eines Prozesses heranwachsen darf.  Das allein ist nat&uuml;rlich
	    nicht genug um den Speicher zu beschr&auml;nken, den ein Programm
	    verwenden darf.  Es sollte deshalb in Verbindung mit anderen
	    Limits gesetzt werden.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Beim Setzen von Ressourcenbeschr&auml;nkungen sind noch andere
      Dinge zu beachten.  Nachfolgend ein paar generelle Tipps, Empfehlungen
      und verschiedene Kommentare.</para>

    <itemizedlist>
      <listitem>
	<para>Von <filename>/etc/rc</filename> beim Hochfahren des Systems
	  gestartete Prozesse werden der <literal>daemon</literal>
	  Login-Klasse zugewiesen.</para>
      </listitem>

      <listitem>
	<para>Obwohl das mitgelieferte <filename>/etc/login.conf</filename>
	  eine Quelle von vern&uuml;nftigen Limits darstellt, k&ouml;nnen nur
	  Sie, der Administrator, wissen, was f&uuml;r Ihr System angebracht
	  ist.  Ein Limit zu hoch anzusetzen k&ouml;nnte Ihr System f&uuml;r
	  Missbrauch &ouml;ffnen, und ein zu niedriges Limit der
	  Produktivit&auml;t einen Riegel vorschieben.</para>
      </listitem>

      <listitem>
	<para>Benutzer des X-Window Systems (X11) sollten wahrscheinlich
	  mehr Ressourcen zugeteilt bekommen als andere Benutzer.  X11
	  beansprucht selbst schon eine Menge Ressourcen, verleitet die
	  Benutzer aber auch, mehrere Programme gleichzeitig laufen zu
	  lassen.</para>
      </listitem>

      <listitem>
	<para>Bedenken Sie, dass viele Limits f&uuml;r einzelne Prozesse
	  gelten und nicht f&uuml;r den Benutzer selbst.  Setzt man
	  zum Beispiel <literal>openfiles</literal> auf 50, kann jeder
	  Prozess des Benutzers bis zu 50 Dateien &ouml;ffnen.  Dadurch
	  ist die maximale Anzahl von Dateien, die von einem Benutzer
	  ge&ouml;ffnet werden k&ouml;nnen, <literal>openfiles</literal>
	  mal <literal>maxproc</literal>.  Das gilt auch f&uuml;r den
	  Speicherverbrauch.</para>
      </listitem>
    </itemizedlist>

    <para>F&uuml;r weitere Informationen &uuml;ber
      Ressourcenbeschr&auml;nkungen, Login-Klassen und -F&auml;higkeiten
      generell, sehen Sie sich die entsprechenden Manual Pages an:
      &man.cap.mkdb.1;, &man.getrlimit.2; und &man.login.conf.5;.</para>
  </sect1>

  <sect1 id="users-personalizing">
    <title>Benutzer personalisieren</title>

    <para>Die Lokalisierung ist eine Umgebung, die vom Systemadministrator
      oder Benutzer eingerichtet wird, um verschiedene Sprachen,
      Zeichens&auml;tze, Datum- und Zeitstandards und so weiter
      unterzubringen.  Dies wird im Kapitel &uuml;ber die
<!--
      <link linkend="l10n">Lokalisierung</link>
-->
      Lokalisierung
      besprochen.</para>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
