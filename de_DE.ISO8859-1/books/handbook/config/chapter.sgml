<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     Original version 1.29
     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/config/chapter.sgml,v 1.7 2001/12/14 17:48:35 mheinen Exp $
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Geschrieben von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Nach einem Tutorial von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Basiert ebenfalls auf tuning(7) von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Konfiguration und Tuning</title>

  <sect1>
    <title>&Uuml;bersicht</title>

    <indexterm><primary>System-Konfiguration/Optimierung</primary></indexterm>

    <para>Ein korrekt konfiguriertes System kann die Arbeit,
      die bei der zuk&uuml;nftigen Pflege und bei Migrationen des Systems
      entsteht, erheblich reduzieren.
      Dieses Kapitel beschreibt Aspekte der administrativen
      Konfiguration von FreeBSD Systemen.</para>

    <para>Es werden zudem einige Parameter beschrieben, die gesetzt
      werden k&ouml;nnen, um aus einem FreeBSD System die optimale
      Leistung zu holen.</para>

    <para>Nachdem Sie dieses Kapitel durchgearbeitet haben,
      werden Sie folgendes wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Warum und wie Sie effizient Dateisysteme und
	  Swap-Partitionen auf Ihrer Festplatte einrichten.</para>
      </listitem>
      <listitem>
	<para>Die Grundlagen der Konfiguration mit
	  <filename>rc.conf</filename> und des Systems zum Starten
	  von Applikationen in <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>
      <listitem>
	<para>Wie Sie virtuelle Hosts und Netzwerkger&auml;te
	  konfigurieren.</para>
      </listitem>
      <listitem>
	<para>Wie Sie die verschiedenen Konfigurationsdateien
	  in <filename>/etc</filename> benutzen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie mit <command>sysctl</command> Variablen FreeBSD
	  einstellen k&ouml;nnen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie die Platten Performance einstellen und Kernel Parameter
	  modifizieren k&ouml;nnen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>
    <itemizedlist>
      <listitem>
	<para>die Grundlagen von Unix und FreeBSD (<xref linkend="basics">)
	  verstehen.</para>
      </listitem>
      <listitem>
	<para>Damit vertraut sein, wie Sie die FreeBSD-Quellen aktuell
	  halten 
	  <!--
	  (<xref linkend="cutting-edge">)
          -->
	  und wissen, wie Sie einen
	  Kernel konfigurieren und kompilieren.</para>
	  <!--
	  (<xref linkend="kernelconfig">)
	  -->
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Vorbereitende Konfiguration</title>

    <sect2>
      <title>Layout von Partitionen</title>

      <indexterm><primary>Layout von Partitionen</primary></indexterm>
      <indexterm><primary><filename>/etc</filename></primary></indexterm>
      <indexterm><primary><filename>/var</filename></primary></indexterm>
      <indexterm><primary><filename>/usr</filename></primary></indexterm>

      <sect3>
	<title>Partitionen</title>

	<para>Wenn Sie Dateisysteme mit &man.disklabel.8; oder
	  &man.sysinstall.8; anlegen, sollten Sie beachten, da&szlig;
	  Festplatten auf Daten in den &auml;u&szlig;eren Spuren
	  schneller zugreifen k&ouml;nnen als auf Daten in den
	  inneren Spuren.  Daher sollten die kleineren oft benutzten
	  Dateisysteme, wie das Root-Dateisystem oder die Swap-Partition,
	  an den &auml;u&szlig;eren Rand der Platte gelegt werden.
	  Die gr&ouml;&szlig;eren Partitionen wie <filename>/usr</filename>
	  sollten in die inneren Bereiche gelegt werden.
	  Es empfiehlt sich, die Partitionen in einer &auml;hnlichen
	  Reihenfolge wie Root-Partition, Swap, <filename>/var</filename>
	  und <filename>/usr</filename> anzulegen.</para>

	<para>Die Gr&ouml;&szlig;e der <filename>/var</filename>-Partition
	  ist abh&auml;ngig vom Zweck der Maschine.
	  <filename>/var</filename> enth&auml;lt haupts&auml;chlich
	  Postf&auml;cher, den Spoolbereich zum Drucken und Logdateien.
	  Abh&auml;ngig von der Anzahl der Systembenutzer und der
	  Aufbewahrungszeit f&uuml;r Logdateien, k&ouml;nnen gerade
	  die Postf&auml;cher und Logdateien zu ungeahnten Gr&ouml;&szlig;en
	  wachsen.  Wenn Sie beabsichtigen, einen Mailserver zu betreiben,
	  kann eine <filename>/var</filename>-Partition mit einer
	  Gr&ouml;&szlig;e von einem Gigabyte und mehr passend sein.
	  Zudem sollte <filename>/var/tmp</filename> gro&szlig; genug sein,
	  um Pakete, die Sie installieren wollen, aufzunehmen.</para>

	<para>Die <filename>/usr</filename>-Partition enth&auml;lt den
	  Hauptteil der Dateien des Systems und das darin enthaltene
	  Unterverzeichnis <filename>/usr/local</filename> enth&auml;lt
	  den Hauptteil der Dateien, die aus der &man.ports.7;
	  Hierarchie installiert wurden.  Wenn Sie nicht vorhaben,
	  viele Ports zu benutzen und nicht beabsichtigen, den
	  Quellcode des Systems in <filename>/usr/src</filename> zu halten,
	  dann reicht eine 1 Gigabyte gro&szlig;e 
	  <filename>/usr</filename>-Partition.  Wenn Sie aber viele
	  Ports, insbesondere Fenstermanager und die Linux-Emulation,
	  installieren, dann empfehlen wir mindestens eine zwei Gigabyte
	  gro&szlig;e Partition f&uuml;r <filename>/usr</filename>.
	  Wenn Sie au&szlig;erdem noch den Quellcode f&uuml;r das
	  System installieren, empfehlen wir eine drei Gigabyte
	  <filename>/usr</filename>-Partition.  Untersch&auml;tzen
	  Sie bitte nicht den Platz, den Sie f&uuml;r diese Partition
	  brauchen, sie kann unmerklich anwachsen und Sie 
	  &uuml;berraschen.</para>

	<para>Wenn Sie die Gr&ouml;&szlig;e der Partitionen festlegen,
	  beachten Sie bitte das Wachstum Ihres Systems.  Es kann
	  sehr frustrierend sein, wenn Sie den Platz in einer Partition
	  vollst&auml;ndig verbraucht haben, dagegen in einer
	  anderen Partition noch sehr viel Platz zur Verf&uuml;gung
	  haben.</para>

	<note><para>Einige Benutzer, die in &man.sysinstall.8; die
	  Partitionen mit <literal>Auto-defaults</literal> automatisch
	  angelegt haben, wurden sp&auml;ter von einer zu kleinen
	  Root- oder <filename>/var</filename>-Partition &uuml;berrascht.
	  Partitionieren Sie weise und gro&szlig;z&uuml;gig.</para></note>

      </sect3>

      <sect3>
	<title>Swap Partition</title> 

	<indexterm><primary>Gr&ouml;&szlig;e der
	  Swap-Partition</primary></indexterm>
	<indexterm><primary>Swap-Partition</primary></indexterm>

	<para>Als Daumenregel sollten Sie doppelt soviel Speicher
	  f&uuml;r die Swap-Partition vorsehen, als Sie Hauptspeicher
	  haben.  Verf&uuml;gt die Maschine beispielsweise &uuml;ber
	  128 Megabyte Hauptspeicher, sollten Sie 256 Megabyte f&uuml;r
	  den Swap-Bereich vorsehen.  Systeme mit weniger Speicher
	  werden wahrscheinlich mit viel mehr Swap mehr leisten.  Es
	  wird nicht empfohlen, weniger als 256 Megabyte Swap einzurichten.
	  Au&szlig;erdem sollten Sie k&uuml;nftige Speichererweiterungen
	  beachten, wenn Sie die Swap-Partition einrichten.  Die
	  VM-Paging-Algorithmen im Kernel sind so eingestellt, da&szlig;
	  Sie am besten laufen, wenn die Swap-Partition mindestens
	  doppelt so gro&szlig; wie der Hauptspeicher ist.  Zu wenig
	  Swap kann zu einer Leistungsverminderung im 
	  <quote>VM page scanning</quote>
	  Code f&uuml;hren sowie Probleme verursachen, wenn Sie sp&auml;ter
	  mehr Speicher in Ihre Maschine bauen.<para>

	<para>Auf gr&ouml;&szlig;eren Systemen mit mehreren SCSI-Laufwerken
	  (oder mehreren IDE-Laufwerken an unterschiedlichen Controllern)
	  empfehlen wir Ihnen w&auml;rmstens, Swap-Bereiche auf bis zu
	  vier Laufwerken einzurichten.  Diese Swap-Partitionen sollten
	  ungef&auml;hr dieselbe Gr&ouml;&szlig;e haben.  Der Kernel
	  kann zwar mit beliebigen Gr&ouml;&szlig;en umgehen, aber
	  die internen Datenstrukturen skalieren bis zur vierfachen
	  Gr&ouml;&szlig;e der gr&ouml;&szlig;ten Partition.  Ungef&auml;hr
	  gleich gro&szlig;e Swap-Partitionen erlauben es dem Kernel,
	  den Swap-Bereich optimal &uuml;ber die Laufwerke zu verteilen.
	  Machen Sie sich keine Gedanken, etwas zu &uuml;bertreiben,
	  ausreichend Swap kann unter Unix die Lage retten.  Ausreichend
	  Swap, auch wenn Sie ihn normal nicht brauchen, kann Ihnen
	  die Zeit geben, sich von einem wild gewordenen Programm
	  zu erholen, bevor Sie zu einem Reboot gezwungen werden.</para>
      </sect3>

      <sect3>
	<title>Warum partitionieren?</title>

	<para>Warum soll ich &uuml;berhaupt partitionieren?  Eine
	  gro&szlig;e Root-Partition reicht doch und man kann
	  sich bei den Gr&ouml;&szlig;en nicht versch&auml;tzen!</para>

	<para>Dagegen sprechen mehrere Gr&uuml;nde.  Jede Partition
	  hat im Betrieb unterschiedliche Eigenschaften und die
	  Trennung der Partitionen erlaubt es, die Dateisysteme
	  an diese Eigenschaften anzupassen.  Die Root- und
	  <filename>/usr</filename>-Partitionen weisen meist nur
	  lesende Zugriffe auf, w&auml;hrend <filename>/var</filename>
	  und <filename>/var/tmp</filename> haupts&auml;chlich
	  beschrieben werden.</para>

	<para>Indem Sie Ihr System richtig partitionieren, verhindern
	  Sie, da&szlig; eine Fragmentierung in den h&auml;ufig beschriebenen
	  Partitionen auf die meist nur gelesenen Partitionen 
	  &uuml;bergreift.  Wenn Sie weiterhin die h&auml;ufig beschriebenen
	  Partitionen an den Rand der Platte, z.B. vor die wirklich
	  gro&szlig;en Partitionen, legen, dann wird die I/O-Leistung
	  auf den Partitionen, auf denen sie am meisten gebraucht wird,
	  steigen.  Nat&uuml;rlich brauchen Sie die I/O-Leistung auch auf
	  den gr&ouml;&szlig;eren Partitionen, aber da diese so gro&szlig;
	  sind, bringt es keine signifikante Steigerung der Leistung,
	  wenn Sie sie an den Rand schieben.  Im Gegensatz dazu, kann
	  es einen gro&szlig;en Einflu&szlig; haben, wenn Sie
	  <filename>/var</filename> an den Rand der Platte legen.
	  Schlie&szlig;lich sollten Sie noch die Sicherheit beachten.
	  Eine kleine Root-Partition, auf die meist nur lesend
	  zugegriffen wird, &uuml;berlebt einen schlimmen Absturz
	  wahrscheinlich eher als eine gro&szlig;e Partition.</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Basiskonfiguration</title>

    <indexterm>
      <primary>rc Dateien</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>Informationen zur Systemkonfiguration sind haupts&auml;chlich
      in <filename>/etc/rc.conf</filename>, die meist beim Start
      des Systems verwendet wird, abgelegt.  Der Name der Datei zeigt
      ihren Zweck an: Sie enth&auml;lt die Konfigurationen f&uuml;r
      die <filename>rc*</filename> Dateien.</para>

    <para>In <filename>rc.conf</filename> werden die Vorgabewerte aus
      <filename>/etc/defaults/rc.conf</filename> &uuml;berschrieben.
      Die Vorgabedatei sollte nicht nach <filename>/etc</filename>
      kopiert werden, da sie die Vorgabewerte und keine Beispiele 
      enth&auml;lt.  Jede systemspezifische &Auml;nderung wird
      in <filename>rc.conf</filename> vorgenommen.</para>

    <para>Um den administrativen Aufwand gering zu halten, existieren
      in geclusterten Applikationen mehrere Strategien,
      globale Konfigurationen von systemspezifischen Konfigurationen
      zu trennen.  Der empfohlene Weg h&auml;lt die globale Konfiguration
      in einer separaten Datei z.B. <filename>rc.conf.site</filename>.
      Diese Datei wird dann in <filename>/etc/rc.conf</filename>,
      die nur systemspezifische Informationen enth&auml;lt, eingebunden.</para>

    <para>Da <filename>rc.conf</filename> von &man.sh.1; gelesen
      wird, ist das einfach zu erreichen:</para>

    <itemizedlist>
      <listitem><para>rc.conf:</para>
<programlisting>	. rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"</programlisting></listitem>
      <listitem><para>rc.conf.site:</para>
<programlisting>	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"</programlisting></listitem>
    </itemizedlist>

    <para><filename>rc.conf.site</filename> kann dann auf jedes
      System mit <command>rsync</command> verteilt werden,
      <filename>rc.conf</filename> bleibt dabei systemspezifisch.</para>

    <para>Bei einem Upgrade des Systems mit &man.sysinstall.8; oder
      <command>make world</command> wird <filename>rc.conf</filename>
      nicht &uuml;berschrieben, so da&szlig; die Systemkonfiguration
      erhalten bleibt.</para>

  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Konfiguration von Applikationen</title>

    <para>Installierte Applikationen haben typischerweise
      eigene Konfigurationsdateien, die eine eigene Syntax
      verwenden.  Damit diese Dateien leicht von der
      Paketverwaltung gefunden und verwaltet werden k&ouml;nnen,
      ist es wichtig, sie vom Basissystem zu trennen.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>F&uuml;r gew&ouml;hnlich werden diese Dateien in 
      <filename>/usr/local/etc</filename> installiert.  Besitzt
      eine Applikation viele Konfigurationsdateien, werden
      diese in einem separaten Unterverzeichnis abgelegt.</para>

    <para>Wenn ein Port oder ein Paket installiert wird, werden
      normalerweise auch Beispiele f&uuml;r die Konfigurationsdateien
      installiert.  Diese erkennt man gew&ouml;hnlich an dem
      Suffix <quote>.default</quote>.  Wenn keine Konfigurationsdateien
      f&uuml;r eine Applikation existieren, werden sie durch
      Kopieren der .default Dateien erstellt.</para>

    <para>Als Beispiel sei <filename>/usr/local/etc/apache</filename>
      gezeigt:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Anhand der Dateigr&ouml;&szlig;e erkennen Sie, da&szlig; sich
      nur <filename>srm.conf</filename> ge&auml;ndert hat.  Ein
      sp&auml;terer Update des Apache Ports w&uuml;rde diese
      Datei nicht &uuml;berschreiben.</para>

  </sect1>

  <sect1 id="configtuning-starting-services">
    <title>Start von Diensten</title>

    <indexterm><primary>Dienste</primary></indexterm>

    <para>Es ist &uuml;blich, da&szlig; ein System mehrere Dienste
      zur Verf&uuml;gung stellt.  Diese k&ouml;nnen auf verschiedene
      Weisen, die jeweils andere Vorteile haben, gestartet werden.</para>

    <indexterm><primary>/usr/local/etc/rc.d</primary></indexterm>

    <para>Software, die von einem Port oder einem Paket installiert
      wurde, wird oft ein Skript in <filename>/usr/local/etc/rc.d</filename>
      stellen.  Dieses wird beim Hochfahren des Systems mit dem
      Argument <option>start</option> und beim Herunterfahren mit
      dem Argument <option>stop</option> aufgerufen.  Das ist der empfohlene
      Weg, systemweite Dienste, die unter <username>root</username> laufen
      oder unter <username>root</username> gestartet werden, zu starten.
      Die Skripte werden bei der Installation des Paketes registriert
      und entfernt, wenn das Paket entfernt wird.</para>

    <para>Ein typisches Skript in <filename>/usr/local/etc/rc.d</filename>
      sieht wie folgt aus:</para>

    <programlisting>#!/bin/sh
echo -n ' FooBar'

case "$1" in
start)
        /usr/local/bin/foobar
        ;;
stop)
        kill -9 `cat /var/run/foobar.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0
    </programlisting>

    <para>Um die passenden Aktionen auszuf&uuml;hren, wird das Skript
      beim Start des Systems mit <option>start</option>
      und mit <option>stop</option> beim Herunterfahren aufgerufen.</para>

    <para>Manche Dienste werden von &man.inetd.8; aufgerufen, wenn
      eine Verbindung auf dem passenden Port aufgebaut wird.  &Uuml;blich
      ist das f&uuml;r Server von Mail-Clients (POP, IMAP, usw.).  Diese
      Dienste werden durch das Editieren von 
      <filename>/etc/inetd.conf</filename> aktiviert.  Details dazu
      finden sich in &man.inetd.8;.</para>

    <para>Weitere Systemdienste werden vielleicht nicht von
      <filename>/etc/rc.conf</filename> abgedeckt.  Diese werden
      traditionell durch Kommandos in <filename>/etc/rc.local</filename>
      aktiviert.  Seit FreeBSD 3.1 existiert keine Vorgabe f&uuml;r
      <filename>/etc/rc.local</filename> mehr.  Wenn die Datei allerdings
      von einem Administrator angelegt wird, so wird sie auch
      ausgef&uuml;hrt.  Beachten Sie bitte, da&szlig; 
      <filename>/etc/rc.local</filename> als der letzte Weg, einen
      Dienst zu starten, angesehen wird.  Wenn es eine andere
      M&ouml;glichkeit gibt, den Dienst zu starten, nehmen Sie diese
      bitte wahr.</para>

    <note><para>F&uuml;gen Sie bitte <emphasis>keine</emphasis> Kommandos
      in <filename>/etc/rc.conf</filename> ein.  Starten Sie stattdessen
      D&aelig;mons oder Kommandos beim Hochfahren mit Skripten in
      <filename>/usr/local/etc/rc.d</filename>.</para></note>

    <para>Systemdienste k&ouml;nnen auch mit &man.cron.8; gestartet
      werden.  Dieser Ansatz hat einige Vorteile; nicht zuletzt, weil
      &man.cron.8; die Prozesse unter dem Eigent&uuml;mer der
      <command>crontab</command> startet, ist es m&ouml;glich, da&szlig;
      Dienste von nicht-<username>root</username> Benutzern gestartet
      und gepflegt werden k&ouml;nnen.</para>

    <para>Dies nutzt eine Eigenschaft von &man.cron.8;:
      F&uuml;r die Zeitangabe kann <literal>@reboot</literal>
      eingesetzt werden.  Damit wird das Kommando gestartet, wenn
      &man.cron.8; kurz nach dem Systemboot gestartet wird.</para>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Virtual Hosts</title>

    <indexterm><primary>virtual hosts</primary></indexterm>
    <indexterm><primary>IP Aliase</primary></indexterm>

    <para>Ein gebr&auml;uchlicher Zweck von FreeBSD ist das
      virtuelle Hosting, bei dem ein Server im Netzwerk wie
      mehrere Server aussieht.  Dies wird dadurch erreicht,
      da&szlig; einem Netzwerkinterface mehrere Netzwerk-Adressen
      zugewiesen werden.</para>

    <para>Ein Netzwerkinterface hat eine <quote>echte</quote>
      Adresse und kann beliebig viele <quote>alias</quote> Adressen
      haben.  Die Aliase werden durch entsprechende alias Eintr&auml;ge
      in <filename>/etc/rc.conf</filename> festgelegt.</para>

    <para>Ein alias Eintrag f&uuml;r das Interface 
      <devicename>fxp0</devicename> sieht wie folgt aus:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Beachten Sie, da&szlig; die alias Eintr&auml;ge mit alias0
      anfangen m&uuml;ssen und dann weiter hochgez&auml;hlt werden,
      das hei&szlig;t _alias1, _alias2, usw.
      Die Konfiguration der Aliase h&ouml;rt bei der ersten
      fehlenden Zahl auf.</para>

    <para>Die Berechnung der Alias-Netzwerkmasken ist wichtig, doch
      zum Gl&uuml;ck einfach.  F&uuml;r jedes Interface mu&szlig; es
      eine Adresse geben, die die Netzwerkmaske des Netzwerkes richtig
      beschreibt.  Alle anderen Adressen in diesem Netzwerk haben dann
      eine Netzwerkmaske, die mit 1 gef&uuml;llt ist.</para>

    <para>Als Beispiel betrachten wir den Fall, in dem
      <devicename>fxp0</devicename> mit zwei Netzwerken verbunden
      ist: dem Netzwerk 10.1.1.0 mit der Netzwerkmaske 255.255.255.0
      und dem Netzwerk 202.0.75.16 mit der Netzwerkmaske 255.255.255.240.
      Das System soll die Adressen 10.1.1.1 bis 10.1.1.5 und
      202.0.75.17 bis 202.0.75.20 belegen.</para>

    <para>Die folgenden Eintr&auml;ge konfigurieren den Adapter
      entsprechend dem Beispiel:</para>

<programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Konfigurationsdateien</title>

    <sect2>
      <title><filename>/etc</filename> Layout</title>
      <para>Konfigurationsdateien finden sich in einigen Verzeichnissen
	unter anderem in:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>Enth&auml;lt generelle Konfigurationsinformationen,
		die Daten hier sind systemspezifisch.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>Default Versionen der Konfigurationsdateien.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>Enth&auml;lt die &man.sendmail.8; Konfiguration
		und weitere MTA Konfigurationsdateien.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>Hier findet sich die Konfiguration f&uuml;r
		die User- und Kernel-ppp Programme.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>Das Vorgabeverzeichnis, in dem Daten von
		&man.named.8; gehalten werden.  Normalerweise
		steht hier die Bootdatei, die mittels einer Direktive
		auf weitere Daten in <filename>/var/db</filename>
		verweist.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc</filename></entry> 
	      <entry>Installierte Applikationen legen hier ihre
		Konfigurationsdateien ab.  Dieses Verzeichnis kann
		Unterverzeichnisse f&uuml;r bestimmte Applikationen
		enthalten.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>Ort f&uuml;r Start- und Stopskripte installierter
		Applikationen.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>Best&auml;ndige systemspezifische Daten z.B.
		&man.named.8; Zonendaten, Datenbanken usw.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Hostnamen</title>

      <indexterm><primary>hostname</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm><primary><filename>resolv.conf</filename></primary></indexterm>

	<para>Wie der FreeBSD Resolver auf das Internet Domain Name
	  System (DNS) zugreift, wird in <filename>/etc/resolv.conf</filename>
	  festgelegt.</para>

	<para>Die gebr&auml;uchlichsten Eintr&auml;ge in
	  <filename>/etc/resolv.conf</filename> sind:</para>
      
	<informaltable frame="none">
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry> 
		<entry>Die IP-Adresse eines Nameservers, den
		  der Resolver abfragen soll.  Bis zu drei Server werden
		  in der Reihenfolge, in der sie aufgez&auml;hlt
		  sind, abgefragt.
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Suchliste mit Domain-Namen zum Aufl&ouml;sen von
		  Hostnamen.  Die Liste wird normalerweise durch den
		  Domain-Teil des lokalen Hostnamens festgelegt.
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Der lokale Domain-Name</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Beispiel f&uuml;r eine typische
	  <filename>resolv.conf</filename>:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30
	</programlisting>

	<para>Wenn Sie DHCP benutzen, &uuml;berschreibt &man.dhclient.8;
	  f&uuml;r gew&ouml;hnlich <filename>resolv.conf</filename>
	  mit den Informationen vom DHCP-Server.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>
	
	<para><filename>/etc/hosts</filename> ist eine einfache textbasierte
	  Datenbank, die aus alten Internetzeiten stammt.  Zusammen
	  mit DNS und NIS stellt sie eine Abbildung zwischen Namen und
	  IP-Adressen zur Verf&uuml;gung.  Anstatt &man.named.8;
	  zu konfigurieren, k&ouml;nnen hier lokale Rechner, die &uuml;ber
	  ein LAN verbunden sind, eingetragen werden.  Lokale Eintr&auml;ge
	  f&uuml;r gebr&auml;uchliche Internet-Adressen in
	  <filename>/etc/hosts</filename> verhindern die Abfrage eines
	  externen Servers und beschleunigen die Namensaufl&ouml;sung.</para>

	<programlisting># &dollar;FreeBSD$
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#</programlisting>

	<para><filename>/etc/hosts</filename> hat ein einfaches Format:</para>
	<programlisting>[Internet Adresse] [Offizieller Hostname] [Alias1] [Alias2] ...</programlisting>

	<para>Zum Beispiel:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Weitere Informationen entnehmen Sie bitte &man.hosts.5;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Konfiguration von Logdateien</title>
     
      <indexterm><primary>Logdateien</primary></indexterm>
      
      <sect3>
	<title><filename>syslog.conf</filename></title>
	
	<indexterm><primary>syslog.conf</primary></indexterm>
	
	<para><filename>syslog.conf</filename> ist die Konfigurationsdatei
	  von &man.syslogd.8;.  Sie legt fest, welche <command>syslog</command>
	  Meldungen in welche Logdateien geschrieben werden.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

	<para>Weitere Informationen enth&auml;lt &man.syslog.conf.5;.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>
	
	<para>Die Konfigurationsdatei f&uuml;r &man.newsyslog.8;, das
	  normalerweise von &man.cron.8; aufgerufen wird, ist
	  <filename>newsyslog.conf</filename>.  &man.newsyslog.8;
	  stellt fest, ob Logdateien archiviert oder verschoben
	  werden m&uuml;ssen.  So wird <filename>logfile</filename>
	  nach <filename>logfile.0</filename> geschoben und
	  <filename>logfile.0</filename> nach <filename>logfile.1</filename>
	  usw.  Zudem k&ouml;nnen Logdateien mit &man.gzip.1;
	  komprimiert werden.  Die Namen der Logdateien sind dann
	  <filename>logfile.0.gz</filename>, <filename>logfile.1.gz</filename>
	  usw.</para>

	<para><filename>newsyslog.conf</filename> legt fest, welche
	  Logdateien bearbeitet werden, wie viele Dateien behalten werden
	  und wann die Dateien angefa&szlig;t werden.  Logdateien
	  k&ouml;nnen auf Basis ihrer Gr&ouml;&szlig;e oder zu
	  einem gewissen Zeitpunkt archiviert bzw. umbenannt werden.</para>
	
	<programlisting># configuration file for newsyslog
# &dollar;FreeBSD&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

	<para>Um mehr zu erfahren, lesen Sie bitte &man.newsyslog.8;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> sieht &auml;hnlich
	wie <filename>rc.conf</filename> aus.  Werte werden in der
	Form <literal>Variable=Wert</literal> gesetzt.
	Die angegebenen Werte werden
	gesetzt, nachdem sich das System im Multi-User Modus befindet,
	das hei&szlig;t nicht alle Werte k&ouml;nnen in
	diesem Modus gesetzt werden.</para>

      <para>In der folgenden <filename>sysctl.conf</filename>  wird das
	Loggen von fatalen Signalen abgestellt und Linux Programmen
	wird klar gemacht, da&szlig; sie in Wirklichkeit unter
	FreeBSD laufen.</para>

      <programlisting>kern.logsigexit=0       # Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=FreeBSD
compat.linux.osrelease=4.3-STABLE</programlisting>

    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Einstellungen mit sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm><primary>Einstellungen mit sysctl</primary></indexterm>
    
    <para>Mit &man.sysctl.8; k&ouml;nnen Sie &Auml;nderungen an
      einem laufenden FreeBSD System vornehmen.  Unter anderem
      k&ouml;nnen Optionen des TCP/IP-Stacks oder des
      virtuellen Speichermanagements ver&auml;ndert werden.  Unter
      der Hand eines erfahrenen Systemadministrators kann dies
      die Systemperformance erheblich verbessern.  &Uuml;ber 500
      Variablen k&ouml;nnen mit &man.sysctl.8; gelesen und gesetzt
      werden.</para>
    
    <para>Der Hauptzweck von &man.sysctl.8; besteht darin, Systemeinstellungen
      zu lesen und zu ver&auml;ndern.</para>

    <para>Alle auslesbaren Variablen werden wie folgt angezeigt:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>
    
    <para>Sie k&ouml;nnen auch eine spezielle Variable, z.B.
      <varname>kern.maxproc</varname> lesen:</para>
    
    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Um eine Variable zu setzen, benutzen Sie die Syntax
      <replaceable>Variable</replaceable>=
      <replaceable>Wert</replaceable>:</para>
    
    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>Mit sysctl k&ouml;nnen Sie Strings, Zahlen oder
      Boolean-Werte setzen.  Bei Boolean-Werten setzen sie <literal>1</literal>
      f&uuml;r wahr und <literal>0</literal> f&uuml;r falsch.</para>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Tuning von Laufwerken</title>

    <sect2>
      <title>Sysctl Variablen</title>
      
      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>
     
	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>
	
	<para>Die Variable <varname>vfs.vmiodirenable</varname> besitzt
	  in der Voreinstellung den Wert 0 (in K&uuml;rze wird sie
	  auf den Wert 1 gesetzt).  Die Variable kann auf den Wert
	  0 (ausgeschaltet) oder 1 (angeschaltet) gesetzt werden.  Sie 
	  kontrolliert, wie Verzeichnisse vom System zwischengespeichert
	  werden.  Die meisten Verzeichnisse sind klein und nutzen
	  nur ein einzelnes Fragment, typischerweise 1K, im Dateisystem.
	  Im Buffer-Cache verbrauchen sie mit 512 Bytes noch weniger
	  Platz.  In der Voreinstellung wird der Buffer-Cache nur
	  eine limitierte Anzahl Verzeichnisse zwischenspeichern, auch
	  wenn das System &uuml;ber sehr viel Speicher verf&uuml;gt.
	  Wenn Sie diese Variable aktivieren, kann der Buffer-Cache den
	  VM-Page-Cache benutzen, um Verzeichnisse zwischenzuspeichern.
	  Der ganze Speicher steht damit zum Zwischenspeichern von
	  Verzeichnissen zur Verf&uuml;gung.  Der Nachteil bei dieser
	  Vorgehensweise ist, da&szlig; zum Zwischenspeichern eines
	  Verzeichnisses mindestens eine physikalische Seite im Speicher,
	  die normalerweise 4K gro&szlig; ist, anstelle von 512 Bytes
	  gebraucht wird.  Wir empfehlen diese Option zu aktivieren,
	  wenn Sie Dienste zur Verf&uuml;gung stellen, die eine
	  gro&szlig;e Zahl von Dateien manipulieren.  Beispiele f&uuml;r
	  solche Dienste sind Web-Caches, gro&szlig;e Mail-Systeme oder
	  Netnews.  Trotz des verschwendeten Speichers vermindert
	  das Aktivieren dieser Variable in aller Regel nicht die
	  Leistung des Systems, obwohl Sie das nachpr&uuml;fen sollten.</para>
      </sect3>
     
      <sect3>
	<title><varname>hw.ata.wc</varname></title>
      
	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>In FreeBSD 4.3 wurde versucht, den IDE Schreib-Zwischenspeicher
	  abzustellen.  Obwohl dies die Bandbreite zum Schreiben auf
	  IDE-Platten verringerte, wurde es aus Gr&uuml;nden der
	  Datenkonsistenz als notwenig angesehen.  Der Kern des
	  Problems ist, da&szlig; IDE-Platten keine zuverl&auml;ssige
	  Aussage &uuml;ber das Ende eines Schreibvorgangs treffen.
	  Wenn der Schreib-Zwischenspeicher aktiviert ist, werden die Daten
	  nicht in der Reihenfolge ihres Eintreffens geschrieben.  Es kann
	  sogar passieren, da&szlig; das Schreiben mancher Bl&ouml;cke
	  im Fall von starker Plattenaktivit&auml;t auf unbefristete
	  Zeit verz&ouml;gert wird.  Ein Absturz oder Stromausfall
	  zu dieser Zeit kann die Dateisysteme erheblich besch&auml;digen.
	  Wir entschieden uns daher f&uuml;r die sichere Variante
	  und stellten den Schreib-Zwischenspeicher ab.  Leider war
	  damit auch ein gro&szlig;er Leistungsverlust verbunden, so
	  da&szlig; wir klein beigeben mu&szlig;ten und die Variable
	  nach dem Release wieder aktiviert haben.  Sie sollten den
	  Wert der Variable <varname>hw.ata.wc</varname> auf Ihrem
	  System &uuml;berpr&uuml;fen.  Wenn der Schreib-Zwischenspeicher
	  abgestellt ist, k&ouml;nnen Sie ihn aktivieren, indem Sie die
	  Variable auf den Wert 1 setzen.  Dies mu&szlig; zum Zeitpunkt
	  des Systemstarts im Boot-Loader geschehen.  Eine &Auml;nderung
	  der Variable, nachdem der Kernel gestartet ist, hat keine
	  Auswirkungen.</para>
	
	<para>Weitere Informationen finden Sie in &man.ata.4;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>
      
      <para>Mit &man.tunefs.8; lassen sich Feineinstellungen an
	Dateisystemen vornehmen.  Das Programm hat verschiedene Optionen,
	von denen hier nur Soft Updates betrachtet werden.  Soft Updates
	werden wie folgt ein- und ausgeschaltet:</para>

      <screen>&prompt.root; tunefs -n enable /filesystem
&prompt.root; tunefs -n disable /filesystem</screen>

      <para>Ein eingh&auml;ngtes Dateisystem kann nicht mit &man.tunefs.8;
	modifiziert werden.  Soft Updates werden am besten im Single-User
	Modus aktiviert, bevor Partitionen eingehangen sind.</para>

      <para>Durch Einsatz eines Zwischenspeichers wird die Performance
	im Bereich der Metadaten, vorwiegend beim Anlegen und L&ouml;schen
	von Dateien, gesteigert.  Wir empfehlen, Soft Updates auf allen
	Dateisystemen zu aktivieren.  Allerdings sollten Sie sich &uuml;ber
	die zwei Nachteile von Soft Updates bewu&szlig;t sein:
	Erstens garantieren Soft Updates zwar die Konsistenz der Daten
	im Fall eines Absturzes, aber es kann leicht passieren, da&szlig;
	das Dateisystem &uuml;ber mehrere Sekunden oder gar eine Minute
	nicht synchronisiert wurde.  Im Fall eines Absturzes verlieren
	Sie mit Soft Updates unter Umst&auml;nden mehr Daten als ohne.
	Zweitens verz&ouml;gern Soft Updates die Freigabe von 
	Datenbl&ouml;cken.  Eine gr&ouml;&szlig;ere Aktualisierung
	eines fast vollen Dateisystems, wie dem root-Dateisystem,
	z.B. w&auml;hrend eines <command>make installworld</command>,
	kann das Dateisystem vollaufen lassen.  Dadurch w&uuml;rde
	die Aktualisierung fehlschlagen.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Einstellungen von Kernel Limits</title>

    <indexterm><primary>Einstellungen von Kernel Limits</primary></indexterm>
    
    <sect2>
      <title>Datei und Proze&szlig; Limits</title>

      <sect3>
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>
	
	<para>Abh&auml;ngig von den Anforderungen Ihres Systems
	  kann <varname>kern.maxfiles</varname> erh&ouml;ht oder
	  erniedrigt werden.  Die Variable legt die maximale
	  Zahl von Dateideskriptoren auf Ihrem System fest.  Wenn
	  die Dateideskriptoren aufgebraucht sind, werden Sie
	  die Meldung <literal>file: table is full</literal>
	  wiederholt im Puffer f&uuml;r Systemmeldungen sehen.  Den
	  Inhalt des Puffers k&ouml;nnen Sie sich mit <command>dmesg</command>
	  anzeigen lassen.</para>

	<para>Jede offene Datei, jedes Socket und jede FIFO verbraucht
	  einen Dateideskriptor.  Auf <quote>dicken</quote> Produktionsservern
	  k&ouml;nnen leicht Tausende Dateideskriptoren ben&ouml;tigt
	  werden, abh&auml;ngig von der Art und Zahl der gleichzeitig
	  laufenden Dienste.</para>

	<para>Die Voreinstellung von <varname>kern.maxfile</varname>
	  wird von <option>maxusers</option> aus Ihrer Kernelkonfiguration
	  bestimmt.  <varname>kern.maxfiles</varname> w&auml;chst
	  proportional mit dem Wert von <option>maxusers</option>.
	  Wenn Sie einen angepa&szlig;ten Kernel kompilieren, empfiehlt es sich
	  diese Option entsprechend der maximalen Benutzerzahl Ihres
	  Systems einzustellen.  Obwohl auf einer Produktionsmaschine
	  vielleicht nicht 256 Benutzer gleichzeitig angemeldet sind,
	  k&ouml;nnen die ben&ouml;tigten Ressourcen &auml;hnlich denen
	  eines gro&szlig;en Webservers sein.</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Netzwerk Limits</title>

      <para>Die Kerneloption <varname>NMBCLUSTERS</varname> schreibt
	die Anzahl der Netzwerkpuffer (MBUFs) fest, die das System besitzt.
	Eine zu geringe Zahl MBUFs auf einem Server mit viel Netzwerkverkehr
	verringert die Leistung von FreeBSD.  Jeder MBUF Cluster nimmt
	ungef&auml;hr 2K Speicher in Anspruch, so da&szlig; ein Wert
	von 1024 insgesamt 2 Megabyte Speicher f&uuml;r Netzwerkpuffer
	im System reserviert.  Wieviele Cluster ben&ouml;tigt werden,
	l&auml;&szlig;t sich durch eine einfache Berechnung herausfinden.
	Wenn Sie einen Webserver besitzen, der maximal 1000 gleichzeitige
	Verbindungen servieren soll und jede der Verbindungen je einen
	16 K gro&szlig;en Puffer zum Senden und Empfangen braucht, brauchen
	Sie ungef&auml;hr 32 MB Speicher f&uuml;r Netzwerkpuffer.  Als
	Daumenregel multiplizieren Sie diese Zahl mit 2, so da&szlig; sich
	f&uuml;r <varname>NMBCLUSTERS</varname> der Wert 
	32MBx2 = 64MB/2K = 32768 ergibt.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
