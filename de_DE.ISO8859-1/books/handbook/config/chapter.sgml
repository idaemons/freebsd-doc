<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     Original version 1.44
     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/config/chapter.sgml,v 1.16 2002/03/17 18:10:19 mheinen Exp $
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Geschrieben von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Nach einem Tutorium von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Basiert ebenfalls auf tuning(7) von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Konfiguration und Tuning</title>

  <sect1>
    <title>&Uuml;bersicht</title>

    <indexterm><primary>System-Konfiguration/Optimierung</primary></indexterm>

    <para>Ein korrekt konfiguriertes System kann die Arbeit,
      die bei der zuk&uuml;nftigen Pflege und bei Migrationen des Systems
      entsteht, erheblich reduzieren.
      Dieses Kapitel beschreibt Aspekte der administrativen
      Konfiguration von FreeBSD Systemen.</para>

    <para>Es werden zudem einige Parameter beschrieben, die gesetzt
      werden k&ouml;nnen, um aus einem FreeBSD System die optimale
      Leistung zu holen.</para>

    <para>Nachdem Sie dieses Kapitel durchgearbeitet haben,
      werden Sie folgendes wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Warum und wie Sie effizient Dateisysteme und
	  Swap-Partitionen auf Ihrer Festplatte einrichten.</para>
      </listitem>
      <listitem>
	<para>Die Grundlagen der Konfiguration mit
	  <filename>rc.conf</filename> und des Systems zum Starten
	  von Applikationen in <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>
      <listitem>
	<para>Wie Sie virtuelle Hosts und Netzwerkger&auml;te
	  konfigurieren.</para>
      </listitem>
      <listitem>
	<para>Wie Sie die verschiedenen Konfigurationsdateien
	  in <filename>/etc</filename> benutzen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie mit <command>sysctl</command> Variablen FreeBSD
	  einstellen k&ouml;nnen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie die Platten Performance einstellen und Kernel Parameter
	  modifizieren k&ouml;nnen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>
    <itemizedlist>
      <listitem>
	<para>die Grundlagen von Unix und FreeBSD (<xref linkend="basics">)
	  verstehen.</para>
      </listitem>
      <listitem>
	<para>Damit vertraut sein, wie Sie die FreeBSD-Quellen aktuell
	  halten 
	  <!--
	  (<xref linkend="cutting-edge">)
          -->
	  und wissen, wie Sie einen
	  Kernel konfigurieren und kompilieren (<xref
	    linkend="kernelconfig">) .</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Vorbereitende Konfiguration</title>

    <sect2>
      <title>Layout von Partitionen</title>

      <indexterm><primary>Layout von Partitionen</primary></indexterm>
      <indexterm><primary><filename>/etc</filename></primary></indexterm>
      <indexterm><primary><filename>/var</filename></primary></indexterm>
      <indexterm><primary><filename>/usr</filename></primary></indexterm>

      <sect3>
	<title>Partitionen</title>

	<para>Wenn Sie Dateisysteme mit &man.disklabel.8; oder
	  &man.sysinstall.8; anlegen, sollten Sie beachten, da&szlig;
	  Festplatten auf Daten in den &auml;u&szlig;eren Spuren
	  schneller zugreifen k&ouml;nnen als auf Daten in den
	  inneren Spuren.  Daher sollten die kleineren oft benutzten
	  Dateisysteme, wie das Root-Dateisystem oder die Swap-Partition,
	  an den &auml;u&szlig;eren Rand der Platte gelegt werden.
	  Die gr&ouml;&szlig;eren Partitionen wie <filename>/usr</filename>
	  sollten in die inneren Bereiche gelegt werden.
	  Es empfiehlt sich, die Partitionen in einer &auml;hnlichen
	  Reihenfolge wie Root-Partition, Swap, <filename>/var</filename>
	  und <filename>/usr</filename> anzulegen.</para>

	<para>Die Gr&ouml;&szlig;e der <filename>/var</filename>-Partition
	  ist abh&auml;ngig vom Zweck der Maschine.
	  <filename>/var</filename> enth&auml;lt haupts&auml;chlich
	  Postf&auml;cher, den Spoolbereich zum Drucken und Logdateien.
	  Abh&auml;ngig von der Anzahl der Systembenutzer und der
	  Aufbewahrungszeit f&uuml;r Logdateien, k&ouml;nnen gerade
	  die Postf&auml;cher und Logdateien zu ungeahnten Gr&ouml;&szlig;en
	  wachsen.  Wenn Sie beabsichtigen, einen Mailserver zu betreiben,
	  kann eine <filename>/var</filename>-Partition mit einer
	  Gr&ouml;&szlig;e von einem Gigabyte und mehr passend sein.
	  Zudem sollte <filename>/var/tmp</filename> gro&szlig; genug sein,
	  um Pakete, die Sie installieren wollen, aufzunehmen.</para>

	<para>Die <filename>/usr</filename>-Partition enth&auml;lt den
	  Hauptteil der Dateien des Systems und das darin enthaltene
	  Unterverzeichnis <filename>/usr/local</filename> enth&auml;lt
	  den Hauptteil der Dateien, die aus der &man.ports.7;
	  Hierarchie installiert wurden.  Wenn Sie nicht vorhaben,
	  viele Ports zu benutzen und nicht beabsichtigen, den
	  Quellcode des Systems in <filename>/usr/src</filename> zu halten,
	  dann reicht eine 1 Gigabyte gro&szlig;e 
	  <filename>/usr</filename>-Partition.  Wenn Sie aber viele
	  Ports, insbesondere Fenstermanager und die Linux-Emulation,
	  installieren, dann empfehlen wir mindestens eine zwei Gigabyte
	  gro&szlig;e Partition f&uuml;r <filename>/usr</filename>.
	  Wenn Sie au&szlig;erdem noch den Quellcode f&uuml;r das
	  System installieren, empfehlen wir eine drei Gigabyte
	  <filename>/usr</filename>-Partition.  Untersch&auml;tzen
	  Sie bitte nicht den Platz, den Sie f&uuml;r diese Partition
	  brauchen, sie kann unmerklich anwachsen und Sie 
	  &uuml;berraschen.</para>

	<para>Wenn Sie die Gr&ouml;&szlig;e der Partitionen festlegen,
	  beachten Sie bitte das Wachstum Ihres Systems.  Es kann
	  sehr frustrierend sein, wenn Sie den Platz in einer Partition
	  vollst&auml;ndig verbraucht haben, dagegen in einer
	  anderen Partition noch sehr viel Platz zur Verf&uuml;gung
	  haben.</para>

	<note><para>Einige Benutzer, die in &man.sysinstall.8; die
	  Partitionen mit <literal>Auto-defaults</literal> automatisch
	  angelegt haben, wurden sp&auml;ter von einer zu kleinen
	  Root- oder <filename>/var</filename>-Partition &uuml;berrascht.
	  Partitionieren Sie weise und gro&szlig;z&uuml;gig.</para></note>

      </sect3>

      <sect3 id="swap-design">
	<title>Swap Partition</title> 

	<indexterm><primary>Gr&ouml;&szlig;e der
	  Swap-Partition</primary></indexterm>
	<indexterm><primary>Swap-Partition</primary></indexterm>

	<para>Als Daumenregel sollten Sie doppelt soviel Speicher
	  f&uuml;r die Swap-Partition vorsehen, als Sie Hauptspeicher
	  haben.  Verf&uuml;gt die Maschine beispielsweise &uuml;ber
	  128 Megabyte Hauptspeicher, sollten Sie 256 Megabyte f&uuml;r
	  den Swap-Bereich vorsehen.  Systeme mit weniger Speicher
	  werden wahrscheinlich mit viel mehr Swap mehr leisten.  Es
	  wird nicht empfohlen, weniger als 256 Megabyte Swap einzurichten.
	  Au&szlig;erdem sollten Sie k&uuml;nftige Speichererweiterungen
	  beachten, wenn Sie die Swap-Partition einrichten.  Die
	  VM-Paging-Algorithmen im Kernel sind so eingestellt, da&szlig;
	  Sie am besten laufen, wenn die Swap-Partition mindestens
	  doppelt so gro&szlig; wie der Hauptspeicher ist.  Zu wenig
	  Swap kann zu einer Leistungsverminderung im 
	  <quote>VM page scanning</quote>
	  Code f&uuml;hren sowie Probleme verursachen, wenn Sie sp&auml;ter
	  mehr Speicher in Ihre Maschine bauen.<para>

	<para>Auf gr&ouml;&szlig;eren Systemen mit mehreren SCSI-Laufwerken
	  (oder mehreren IDE-Laufwerken an unterschiedlichen Controllern)
	  empfehlen wir Ihnen w&auml;rmstens, Swap-Bereiche auf bis zu
	  vier Laufwerken einzurichten.  Diese Swap-Partitionen sollten
	  ungef&auml;hr dieselbe Gr&ouml;&szlig;e haben.  Der Kernel
	  kann zwar mit beliebigen Gr&ouml;&szlig;en umgehen, aber
	  die internen Datenstrukturen skalieren bis zur vierfachen
	  Gr&ouml;&szlig;e der gr&ouml;&szlig;ten Partition.  Ungef&auml;hr
	  gleich gro&szlig;e Swap-Partitionen erlauben es dem Kernel,
	  den Swap-Bereich optimal &uuml;ber die Laufwerke zu verteilen.
	  Machen Sie sich keine Gedanken, etwas zu &uuml;bertreiben,
	  ausreichend Swap kann unter Unix die Lage retten.  Ausreichend
	  Swap, auch wenn Sie ihn normal nicht brauchen, kann Ihnen
	  die Zeit geben, sich von einem wild gewordenen Programm
	  zu erholen, bevor Sie zu einem Reboot gezwungen werden.</para>
      </sect3>

      <sect3>
	<title>Warum partitionieren?</title>

	<para>Warum soll ich &uuml;berhaupt partitionieren?  Eine
	  gro&szlig;e Root-Partition reicht doch und man kann
	  sich bei den Gr&ouml;&szlig;en nicht versch&auml;tzen!</para>

	<para>Dagegen sprechen mehrere Gr&uuml;nde.  Jede Partition
	  hat im Betrieb unterschiedliche Eigenschaften und die
	  Trennung der Partitionen erlaubt es, die Dateisysteme
	  an diese Eigenschaften anzupassen.  Die Root- und
	  <filename>/usr</filename>-Partitionen weisen meist nur
	  lesende Zugriffe auf, w&auml;hrend <filename>/var</filename>
	  und <filename>/var/tmp</filename> haupts&auml;chlich
	  beschrieben werden.</para>

	<para>Indem Sie Ihr System richtig partitionieren, verhindern
	  Sie, da&szlig; eine Fragmentierung in den h&auml;ufig beschriebenen
	  Partitionen auf die meist nur gelesenen Partitionen 
	  &uuml;bergreift.  Wenn Sie weiterhin die h&auml;ufig beschriebenen
	  Partitionen an den Rand der Platte, z.B. vor die wirklich
	  gro&szlig;en Partitionen, legen, dann wird die I/O-Leistung
	  auf den Partitionen, auf denen sie am meisten gebraucht wird,
	  steigen.  Nat&uuml;rlich brauchen Sie die I/O-Leistung auch auf
	  den gr&ouml;&szlig;eren Partitionen, aber da diese so gro&szlig;
	  sind, bringt es keine signifikante Steigerung der Leistung,
	  wenn Sie sie an den Rand schieben.  Im Gegensatz dazu, kann
	  es einen gro&szlig;en Einflu&szlig; haben, wenn Sie
	  <filename>/var</filename> an den Rand der Platte legen.
	  Schlie&szlig;lich sollten Sie noch die Sicherheit beachten.
	  Eine kleine Root-Partition, auf die meist nur lesend
	  zugegriffen wird, &uuml;berlebt einen schlimmen Absturz
	  wahrscheinlich eher als eine gro&szlig;e Partition.</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Basiskonfiguration</title>

    <indexterm>
      <primary>rc Dateien</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>Informationen zur Systemkonfiguration sind haupts&auml;chlich
      in <filename>/etc/rc.conf</filename>, die meist beim Start
      des Systems verwendet wird, abgelegt.  Der Name der Datei zeigt
      ihren Zweck an: Sie enth&auml;lt die Konfigurationen f&uuml;r
      die <filename>rc*</filename> Dateien.</para>

    <para>In <filename>rc.conf</filename> werden die Vorgabewerte aus
      <filename>/etc/defaults/rc.conf</filename> &uuml;berschrieben.
      Die Vorgabedatei sollte nicht nach <filename>/etc</filename>
      kopiert werden, da sie die Vorgabewerte und keine Beispiele 
      enth&auml;lt.  Jede systemspezifische &Auml;nderung wird
      in <filename>rc.conf</filename> vorgenommen.</para>

    <para>Um den administrativen Aufwand gering zu halten, existieren
      in geclusterten Applikationen mehrere Strategien,
      globale Konfigurationen von systemspezifischen Konfigurationen
      zu trennen.  Der empfohlene Weg h&auml;lt die globale Konfiguration
      in einer separaten Datei z.B. <filename>rc.conf.site</filename>.
      Diese Datei wird dann in <filename>/etc/rc.conf</filename>,
      die nur systemspezifische Informationen enth&auml;lt, eingebunden.</para>

    <para>Da <filename>rc.conf</filename> von &man.sh.1; gelesen
      wird, ist das einfach zu erreichen:</para>

    <itemizedlist>
      <listitem><para>rc.conf:</para>
<programlisting>	. rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"</programlisting></listitem>
      <listitem><para>rc.conf.site:</para>
<programlisting>	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"</programlisting></listitem>
    </itemizedlist>

    <para><filename>rc.conf.site</filename> kann dann auf jedes
      System mit <command>rsync</command> verteilt werden,
      <filename>rc.conf</filename> bleibt dabei systemspezifisch.</para>

    <para>Bei einem Upgrade des Systems mit &man.sysinstall.8; oder
      <command>make world</command> wird <filename>rc.conf</filename>
      nicht &uuml;berschrieben, so da&szlig; die Systemkonfiguration
      erhalten bleibt.</para>

  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Konfiguration von Applikationen</title>

    <para>Installierte Applikationen haben typischerweise
      eigene Konfigurationsdateien, die eine eigene Syntax
      verwenden.  Damit diese Dateien leicht von der
      Paketverwaltung gefunden und verwaltet werden k&ouml;nnen,
      ist es wichtig, sie vom Basissystem zu trennen.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>F&uuml;r gew&ouml;hnlich werden diese Dateien in 
      <filename>/usr/local/etc</filename> installiert.  Besitzt
      eine Applikation viele Konfigurationsdateien, werden
      diese in einem separaten Unterverzeichnis abgelegt.</para>

    <para>Wenn ein Port oder ein Paket installiert wird, werden
      normalerweise auch Beispiele f&uuml;r die Konfigurationsdateien
      installiert.  Diese erkennt man gew&ouml;hnlich an dem
      Suffix <quote>.default</quote>.  Wenn keine Konfigurationsdateien
      f&uuml;r eine Applikation existieren, werden sie durch
      Kopieren der .default Dateien erstellt.</para>

    <para>Als Beispiel sei <filename>/usr/local/etc/apache</filename>
      gezeigt:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Anhand der Dateigr&ouml;&szlig;e erkennen Sie, da&szlig; sich
      nur <filename>srm.conf</filename> ge&auml;ndert hat.  Ein
      sp&auml;terer Update des Apache Ports w&uuml;rde diese
      Datei nicht &uuml;berschreiben.</para>

  </sect1>

  <sect1 id="configtuning-starting-services">
    <title>Start von Diensten</title>

    <indexterm><primary>Dienste</primary></indexterm>

    <para>Es ist &uuml;blich, da&szlig; ein System mehrere Dienste
      zur Verf&uuml;gung stellt.  Diese k&ouml;nnen auf verschiedene
      Weisen, die jeweils andere Vorteile haben, gestartet werden.</para>

    <indexterm><primary>/usr/local/etc/rc.d</primary></indexterm>

    <para>Software, die von einem Port oder einem Paket installiert
      wurde, wird oft ein Skript in <filename>/usr/local/etc/rc.d</filename>
      stellen.  Dieses wird beim Hochfahren des Systems mit dem
      Argument <option>start</option> und beim Herunterfahren mit
      dem Argument <option>stop</option> aufgerufen.  Das ist der empfohlene
      Weg, systemweite Dienste, die unter <username>root</username> laufen
      oder unter <username>root</username> gestartet werden, zu starten.
      Die Skripte werden bei der Installation des Paketes registriert
      und entfernt, wenn das Paket entfernt wird.</para>

    <para>Ein typisches Skript in <filename>/usr/local/etc/rc.d</filename>
      sieht wie folgt aus:</para>

    <programlisting>#!/bin/sh
echo -n ' FooBar'

case "$1" in
start)
        /usr/local/bin/foobar
        ;;
stop)
        kill -9 `cat /var/run/foobar.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0
    </programlisting>

    <para>Um die passenden Aktionen auszuf&uuml;hren, wird das Skript
      beim Start des Systems mit <option>start</option>
      und mit <option>stop</option> beim Herunterfahren aufgerufen.</para>

    <para>Manche Dienste werden von &man.inetd.8; aufgerufen, wenn
      eine Verbindung auf dem passenden Port aufgebaut wird.  &Uuml;blich
      ist das f&uuml;r Server von Mail-Clients (POP, IMAP, usw.).  Diese
      Dienste werden durch das Editieren von 
      <filename>/etc/inetd.conf</filename> aktiviert.  Details dazu
      finden sich in &man.inetd.8;.</para>

    <para>Weitere Systemdienste werden vielleicht nicht von
      <filename>/etc/rc.conf</filename> abgedeckt.  Diese werden
      traditionell durch Kommandos in <filename>/etc/rc.local</filename>
      aktiviert.  Seit FreeBSD 3.1 existiert keine Vorgabe f&uuml;r
      <filename>/etc/rc.local</filename> mehr.  Wenn die Datei allerdings
      von einem Administrator angelegt wird, so wird sie auch
      ausgef&uuml;hrt.  Beachten Sie bitte, da&szlig; 
      <filename>/etc/rc.local</filename> als der letzte Weg, einen
      Dienst zu starten, angesehen wird.  Wenn es eine andere
      M&ouml;glichkeit gibt, den Dienst zu starten, nehmen Sie diese
      bitte wahr.</para>

    <note><para>F&uuml;gen Sie bitte <emphasis>keine</emphasis> Kommandos
      in <filename>/etc/rc.conf</filename> ein.  Starten Sie stattdessen
      D&aelig;mons oder Kommandos beim Hochfahren mit Skripten in
      <filename>/usr/local/etc/rc.d</filename>.</para></note>

    <para>Systemdienste k&ouml;nnen auch mit &man.cron.8; gestartet
      werden.  Dieser Ansatz hat einige Vorteile; nicht zuletzt, weil
      &man.cron.8; die Prozesse unter dem Eigent&uuml;mer der
      <command>crontab</command> startet, ist es m&ouml;glich, da&szlig;
      Dienste von nicht-<username>root</username> Benutzern gestartet
      und gepflegt werden k&ouml;nnen.</para>

    <para>Dies nutzt eine Eigenschaft von &man.cron.8;:
      F&uuml;r die Zeitangabe kann <literal>@reboot</literal>
      eingesetzt werden.  Damit wird das Kommando gestartet, wenn
      &man.cron.8; kurz nach dem Systemboot gestartet wird.</para>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Virtual Hosts</title>

    <indexterm><primary>virtual hosts</primary></indexterm>
    <indexterm><primary>IP Aliase</primary></indexterm>

    <para>Ein gebr&auml;uchlicher Zweck von FreeBSD ist das
      virtuelle Hosting, bei dem ein Server im Netzwerk wie
      mehrere Server aussieht.  Dies wird dadurch erreicht,
      da&szlig; einem Netzwerkinterface mehrere Netzwerk-Adressen
      zugewiesen werden.</para>

    <para>Ein Netzwerkinterface hat eine <quote>echte</quote>
      Adresse und kann beliebig viele <quote>alias</quote> Adressen
      haben.  Die Aliase werden durch entsprechende alias Eintr&auml;ge
      in <filename>/etc/rc.conf</filename> festgelegt.</para>

    <para>Ein alias Eintrag f&uuml;r das Interface 
      <devicename>fxp0</devicename> sieht wie folgt aus:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Beachten Sie, da&szlig; die alias Eintr&auml;ge mit alias0
      anfangen m&uuml;ssen und dann weiter hochgez&auml;hlt werden,
      das hei&szlig;t _alias1, _alias2, usw.
      Die Konfiguration der Aliase h&ouml;rt bei der ersten
      fehlenden Zahl auf.</para>

    <para>Die Berechnung der Alias-Netzwerkmasken ist wichtig, doch
      zum Gl&uuml;ck einfach.  F&uuml;r jedes Interface mu&szlig; es
      eine Adresse geben, die die Netzwerkmaske des Netzwerkes richtig
      beschreibt.  Alle anderen Adressen in diesem Netzwerk haben dann
      eine Netzwerkmaske, die mit 1 gef&uuml;llt ist.</para>

    <para>Als Beispiel betrachten wir den Fall, in dem
      <devicename>fxp0</devicename> mit zwei Netzwerken verbunden
      ist: dem Netzwerk 10.1.1.0 mit der Netzwerkmaske 255.255.255.0
      und dem Netzwerk 202.0.75.16 mit der Netzwerkmaske 255.255.255.240.
      Das System soll die Adressen 10.1.1.1 bis 10.1.1.5 und
      202.0.75.17 bis 202.0.75.20 belegen.</para>

    <para>Die folgenden Eintr&auml;ge konfigurieren den Adapter
      entsprechend dem Beispiel:</para>

<programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Konfigurationsdateien</title>

    <sect2>
      <title><filename>/etc</filename> Layout</title>
      <para>Konfigurationsdateien finden sich in einigen Verzeichnissen
	unter anderem in:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>Enth&auml;lt generelle Konfigurationsinformationen,
		die Daten hier sind systemspezifisch.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>Default Versionen der Konfigurationsdateien.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>Enth&auml;lt die &man.sendmail.8; Konfiguration
		und weitere MTA Konfigurationsdateien.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>Hier findet sich die Konfiguration f&uuml;r
		die User- und Kernel-ppp Programme.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>Das Vorgabeverzeichnis, in dem Daten von
		&man.named.8; gehalten werden.  Normalerweise
		steht hier die Bootdatei, die mittels einer Direktive
		auf weitere Daten in <filename>/var/db</filename>
		verweist.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc</filename></entry> 
	      <entry>Installierte Applikationen legen hier ihre
		Konfigurationsdateien ab.  Dieses Verzeichnis kann
		Unterverzeichnisse f&uuml;r bestimmte Applikationen
		enthalten.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>Ort f&uuml;r Start- und Stopskripte installierter
		Applikationen.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>Best&auml;ndige systemspezifische Daten z.B.
		&man.named.8; Zonendaten, Datenbanken usw.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Hostnamen</title>

      <indexterm><primary>hostname</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm><primary><filename>resolv.conf</filename></primary></indexterm>

	<para>Wie der FreeBSD Resolver auf das Internet Domain Name
	  System (DNS) zugreift, wird in <filename>/etc/resolv.conf</filename>
	  festgelegt.</para>

	<para>Die gebr&auml;uchlichsten Eintr&auml;ge in
	  <filename>/etc/resolv.conf</filename> sind:</para>
      
	<informaltable frame="none">
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry> 
		<entry>Die IP-Adresse eines Nameservers, den
		  der Resolver abfragen soll.  Bis zu drei Server werden
		  in der Reihenfolge, in der sie aufgez&auml;hlt
		  sind, abgefragt.
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Suchliste mit Domain-Namen zum Aufl&ouml;sen von
		  Hostnamen.  Die Liste wird normalerweise durch den
		  Domain-Teil des lokalen Hostnamens festgelegt.
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Der lokale Domain-Name</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Beispiel f&uuml;r eine typische
	  <filename>resolv.conf</filename>:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note><para>Nur eine der Anweisungen <literal>search</literal>
	  oder <literal>domain</literal> sollte benutzt werden.</para></note>

	<para>Wenn Sie DHCP benutzen, &uuml;berschreibt &man.dhclient.8;
	  f&uuml;r gew&ouml;hnlich <filename>resolv.conf</filename>
	  mit den Informationen vom DHCP-Server.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>
	
	<para><filename>/etc/hosts</filename> ist eine einfache textbasierte
	  Datenbank, die aus alten Internetzeiten stammt.  Zusammen
	  mit DNS und NIS stellt sie eine Abbildung zwischen Namen und
	  IP-Adressen zur Verf&uuml;gung.  Anstatt &man.named.8;
	  zu konfigurieren, k&ouml;nnen hier lokale Rechner, die &uuml;ber
	  ein LAN verbunden sind, eingetragen werden.  Lokale Eintr&auml;ge
	  f&uuml;r gebr&auml;uchliche Internet-Adressen in
	  <filename>/etc/hosts</filename> verhindern die Abfrage eines
	  externen Servers und beschleunigen die Namensaufl&ouml;sung.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#</programlisting>

	<para><filename>/etc/hosts</filename> hat ein einfaches Format:</para>
	<programlisting>[Internet Adresse] [Offizieller Hostname] [Alias1] [Alias2] ...</programlisting>

	<para>Zum Beispiel:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Weitere Informationen entnehmen Sie bitte &man.hosts.5;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Konfiguration von Logdateien</title>
     
      <indexterm><primary>Logdateien</primary></indexterm>
      
      <sect3>
	<title><filename>syslog.conf</filename></title>
	
	<indexterm><primary>syslog.conf</primary></indexterm>
	
	<para><filename>syslog.conf</filename> ist die Konfigurationsdatei
	  von &man.syslogd.8;.  Sie legt fest, welche <command>syslog</command>
	  Meldungen in welche Logdateien geschrieben werden.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

	<para>Weitere Informationen enth&auml;lt &man.syslog.conf.5;.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>
	
	<para>Die Konfigurationsdatei f&uuml;r &man.newsyslog.8;, das
	  normalerweise von &man.cron.8; aufgerufen wird, ist
	  <filename>newsyslog.conf</filename>.  &man.newsyslog.8;
	  stellt fest, ob Logdateien archiviert oder verschoben
	  werden m&uuml;ssen.  So wird <filename>logfile</filename>
	  nach <filename>logfile.0</filename> geschoben und
	  <filename>logfile.0</filename> nach <filename>logfile.1</filename>
	  usw.  Zudem k&ouml;nnen Logdateien mit &man.gzip.1;
	  komprimiert werden.  Die Namen der Logdateien sind dann
	  <filename>logfile.0.gz</filename>, <filename>logfile.1.gz</filename>
	  usw.</para>

	<para><filename>newsyslog.conf</filename> legt fest, welche
	  Logdateien bearbeitet werden, wie viele Dateien behalten werden
	  und wann die Dateien angefa&szlig;t werden.  Logdateien
	  k&ouml;nnen auf Basis ihrer Gr&ouml;&szlig;e oder zu
	  einem gewissen Zeitpunkt archiviert bzw. umbenannt werden.</para>
	
	<programlisting># configuration file for newsyslog
# &dollar;FreeBSD&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

	<para>Um mehr zu erfahren, lesen Sie bitte &man.newsyslog.8;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> sieht &auml;hnlich
	wie <filename>rc.conf</filename> aus.  Werte werden in der
	Form <literal>Variable=Wert</literal> gesetzt.
	Die angegebenen Werte werden
	gesetzt, nachdem sich das System im Multi-User Modus befindet,
	das hei&szlig;t nicht alle Werte k&ouml;nnen in
	diesem Modus gesetzt werden.</para>

      <para>In der folgenden <filename>sysctl.conf</filename>  wird das
	Loggen von fatalen Signalen abgestellt und Linux Programmen
	wird klar gemacht, da&szlig; sie in Wirklichkeit unter
	FreeBSD laufen.</para>

      <programlisting>kern.logsigexit=0       # Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=FreeBSD
compat.linux.osrelease=4.3-STABLE</programlisting>

    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Einstellungen mit sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm><primary>Einstellungen mit sysctl</primary></indexterm>
    
    <para>Mit &man.sysctl.8; k&ouml;nnen Sie &Auml;nderungen an
      einem laufenden FreeBSD System vornehmen.  Unter anderem
      k&ouml;nnen Optionen des TCP/IP-Stacks oder des
      virtuellen Speichermanagements ver&auml;ndert werden.  Unter
      der Hand eines erfahrenen Systemadministrators kann dies
      die Systemperformance erheblich verbessern.  &Uuml;ber 500
      Variablen k&ouml;nnen mit &man.sysctl.8; gelesen und gesetzt
      werden.</para>
    
    <para>Der Hauptzweck von &man.sysctl.8; besteht darin, Systemeinstellungen
      zu lesen und zu ver&auml;ndern.</para>

    <para>Alle auslesbaren Variablen werden wie folgt angezeigt:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>
    
    <para>Sie k&ouml;nnen auch eine spezielle Variable, z.B.
      <varname>kern.maxproc</varname> lesen:</para>
    
    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Um eine Variable zu setzen, benutzen Sie die Syntax
      <replaceable>Variable</replaceable>=
      <replaceable>Wert</replaceable>:</para>
    
    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>Mit sysctl k&ouml;nnen Sie Strings, Zahlen oder
      Boolean-Werte setzen.  Bei Boolean-Werten setzen sie <literal>1</literal>
      f&uuml;r wahr und <literal>0</literal> f&uuml;r falsch.</para>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Tuning von Laufwerken</title>

    <sect2>
      <title>Sysctl Variablen</title>
      
      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>
     
	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>
	
	<para>Die Variable <varname>vfs.vmiodirenable</varname> besitzt
	  in der Voreinstellung den Wert 1.  Die Variable kann auf den Wert
	  0 (ausgeschaltet) oder 1 (angeschaltet) gesetzt werden.  Sie 
	  kontrolliert, wie Verzeichnisse vom System zwischengespeichert
	  werden.  Die meisten Verzeichnisse sind klein und nutzen
	  nur ein einzelnes Fragment, typischerweise 1K, im Dateisystem.
	  Im Buffer-Cache verbrauchen sie mit 512 Bytes noch weniger
	  Platz.  In der Voreinstellung wird der Buffer-Cache nur
	  eine limitierte Anzahl Verzeichnisse zwischenspeichern, auch
	  wenn das System &uuml;ber sehr viel Speicher verf&uuml;gt.
	  Wenn Sie diese Variable aktivieren, kann der Buffer-Cache den
	  VM-Page-Cache benutzen, um Verzeichnisse zwischenzuspeichern.
	  Der ganze Speicher steht damit zum Zwischenspeichern von
	  Verzeichnissen zur Verf&uuml;gung.  Der Nachteil bei dieser
	  Vorgehensweise ist, da&szlig; zum Zwischenspeichern eines
	  Verzeichnisses mindestens eine physikalische Seite im Speicher,
	  die normalerweise 4K gro&szlig; ist, anstelle von 512 Bytes
	  gebraucht wird.  Wir empfehlen diese Option zu aktivieren,
	  wenn Sie Dienste zur Verf&uuml;gung stellen, die eine
	  gro&szlig;e Zahl von Dateien manipulieren.  Beispiele f&uuml;r
	  solche Dienste sind Web-Caches, gro&szlig;e Mail-Systeme oder
	  Netnews.  Trotz des verschwendeten Speichers vermindert
	  das Aktivieren dieser Variable in aller Regel nicht die
	  Leistung des Systems, obwohl Sie das nachpr&uuml;fen sollten.</para>
      </sect3>
     
      <sect3>
	<title><varname>hw.ata.wc</varname></title>
      
	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>In FreeBSD 4.3 wurde versucht, den IDE Schreib-Zwischenspeicher
	  abzustellen.  Obwohl dies die Bandbreite zum Schreiben auf
	  IDE-Platten verringerte, wurde es aus Gr&uuml;nden der
	  Datenkonsistenz als notwenig angesehen.  Der Kern des
	  Problems ist, da&szlig; IDE-Platten keine zuverl&auml;ssige
	  Aussage &uuml;ber das Ende eines Schreibvorgangs treffen.
	  Wenn der Schreib-Zwischenspeicher aktiviert ist, werden die Daten
	  nicht in der Reihenfolge ihres Eintreffens geschrieben.  Es kann
	  sogar passieren, da&szlig; das Schreiben mancher Bl&ouml;cke
	  im Fall von starker Plattenaktivit&auml;t auf unbefristete
	  Zeit verz&ouml;gert wird.  Ein Absturz oder Stromausfall
	  zu dieser Zeit kann die Dateisysteme erheblich besch&auml;digen.
	  Wir entschieden uns daher f&uuml;r die sichere Variante
	  und stellten den Schreib-Zwischenspeicher ab.  Leider war
	  damit auch ein gro&szlig;er Leistungsverlust verbunden, so
	  da&szlig; wir die Variable
	  nach dem Release wieder aktiviert haben.  Sie sollten den
	  Wert der Variable <varname>hw.ata.wc</varname> auf Ihrem
	  System &uuml;berpr&uuml;fen.  Wenn der Schreib-Zwischenspeicher
	  abgestellt ist, k&ouml;nnen Sie ihn aktivieren, indem Sie die
	  Variable auf den Wert 1 setzen.  Dies mu&szlig; zum Zeitpunkt
	  des Systemstarts im Boot-Loader geschehen.  Eine &Auml;nderung
	  der Variable, nachdem der Kernel gestartet ist, hat keine
	  Auswirkungen.</para>
	
	<para>Weitere Informationen finden Sie in &man.ata.4;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>
      
      <para>Mit &man.tunefs.8; lassen sich Feineinstellungen an
	Dateisystemen vornehmen.  Das Programm hat verschiedene Optionen,
	von denen hier nur Soft Updates betrachtet werden.  Soft Updates
	werden wie folgt ein- und ausgeschaltet:</para>

      <screen>&prompt.root; tunefs -n enable /filesystem
&prompt.root; tunefs -n disable /filesystem</screen>

      <para>Ein eingeh&auml;ngtes Dateisystem kann nicht mit &man.tunefs.8;
	modifiziert werden.  Soft Updates werden am besten im Single-User
	Modus aktiviert, bevor Partitionen eingehangen sind.</para>

      <note><para>Ab FreeBSD 4.5 k&ouml;nnen Sie Soft Updates mit der
        Option <literal>-U</literal> von &man.newfs.8; beim Anlegen der
	Dateisysteme aktivieren.</para></note>

      <para>Durch Einsatz eines Zwischenspeichers wird die Performance
	im Bereich der Metadaten, vorwiegend beim Anlegen und L&ouml;schen
	von Dateien, gesteigert.  Wir empfehlen, Soft Updates auf allen
	Dateisystemen zu aktivieren.  Allerdings sollten Sie sich &uuml;ber
	die zwei Nachteile von Soft Updates bewu&szlig;t sein:
	Erstens garantieren Soft Updates zwar die Konsistenz der Daten
	im Fall eines Absturzes, aber es kann leicht passieren, da&szlig;
	das Dateisystem &uuml;ber mehrere Sekunden oder gar eine Minute
	nicht synchronisiert wurde.  Im Fall eines Absturzes verlieren
	Sie mit Soft Updates unter Umst&auml;nden mehr Daten als ohne.
	Zweitens verz&ouml;gern Soft Updates die Freigabe von 
	Datenbl&ouml;cken.  Eine gr&ouml;&szlig;ere Aktualisierung
	eines fast vollen Dateisystems, wie dem root-Dateisystem,
	z.B. w&auml;hrend eines <command>make installworld</command>,
	kann das Dateisystem vollaufen lassen.  Dadurch w&uuml;rde
	die Aktualisierung fehlschlagen.</para>
      
      <sect3>
	<title>Details &uuml;ber Soft Updates</title>

	<indexterm><primary>Soft Updates (Details)</primary></indexterm>

	<para>Es gibt zwei klassische Herangehensweisen, wie
	  man die Metadaten des Dateisystems (also Daten
	  &uuml;ber Dateien, wie inode Bereiche oder Verzeichniseintr&auml;ge)
	  aktualisiert auf die Platte zur&uuml;ckschreibt:</para>

	<para>Das historisch &uuml;bliche Verfahren waren synchrone
	  Updates der Metadaten, d. h. wenn eine &Auml;nderung an
	  einem Verzeichnis n&ouml;tig war, wurde anschlie&szlig;end
	  gewartet, bis diese &Auml;nderung tats&auml;chlich auf die
	  Platte zur&uuml;ckgeschrieben worden war.  Der
	  <emphasis>Inhalt</emphasis> der Dateien wurde im
	  <quote>Buffer Cache</quote> zwischengespeichert und
	  asynchron irgendwann sp&auml;ter auf die Platte geschrieben.
	  Der Vorteil dieser Implementierung ist, da&szlig; sie
	  sicher funktioniert.  Wenn w&auml;hrend eines Updates ein
	  Ausfall erfolgt, haben die Metadaten immer einen
	  konsistenten Zustand.  Eine Datei ist entweder komplett
	  angelegt oder gar nicht.  Wenn die Datenbl&ouml;cke einer
	  Datei im Fall eines Absturzes noch nicht den Weg aus dem
	  <quote>Buffer Cache</quote> auf die Platte gefunden haben,
	  kann &man.fsck.8; das Dateisystem reparieren, indem es die
	  Dateil&auml;nge einfach auf 0 setzt.  Au&szlig;erdem
	  ist die Implementierung einfach und &uuml;berschaubar.  Der
	  Nachteil ist, da&szlig; &Auml;nderungen der Metadaten sehr
	  langsam vor sich gehen.  Ein <command>rm -r</command>
	  beispielsweise fa&szlig;t alle Dateien eines Verzeichnisses
	  der Reihe nach an, aber jede dieser &Auml;nderungen am
	  Verzeichnis (L&ouml;schen einer Datei) wird einzeln synchron
	  auf die Platte geschrieben.  Gleiches beim Auspacken
	  gro&szlig;er Hierarchien (<command>tar -x</command>).</para>
	  
	<para>Der zweite Fall sind asynchrone Metadaten-Updates.  Das
	  ist z. B. der Standard bei Linux/ext2fs oder die Variante
	  <command>mount -o async</command> f&uuml;r *BSD UFS.  Man
	  schickt die Updates der Metadaten einfach auch noch
	  &uuml;ber den <quote>Buffer Cache</quote>, sie werden also
	  zwischen die Updates der normalen Daten eingeschoben.
	  Vorteil ist, da&szlig; man nun nicht mehr auf jeden Update
	  warten mu&szlig;, Operationen mit vielen
	  Metadaten&auml;nderungen werden also viel schneller.  Auch
	  hier ist die Implementierung sehr einfach und wenig
	  anf&auml;llig f&uuml;r Fehler.  Nachteil ist, da&szlig;
	  keinerlei Konsistenz des Dateisystems mehr gesichert ist.
	  Wenn mitten in einer Operation, die viele Metadaten
	  &auml;ndert, ein Ausfall erfolgt (Stromausfall, dr&uuml;cken
	  des Reset-Tasters), dann ist das Dateisystem
	  anschlie&szlig;end in einem unbestimmten Zustand.  Niemand
	  kann genau sagen, was noch geschrieben worden ist und was
	  nicht mehr; die Datenbl&ouml;cke einer Datei k&ouml;nnen
	  schon auf der Platte stehen, w&auml;hrend die inode Tabelle
	  oder das zugeh&ouml;rige Verzeichnis nicht mehr aktualisiert
	  worden ist.  Man kann praktisch kein <command>fsck</command>
	  mehr implementieren, das diesen Zustand
	  wieder reparieren kann, da die dazu n&ouml;tigen
	  Informationen einfach auf der Platte fehlen.  Wenn ein
	  Dateisystem derart besch&auml;digt worden ist, kann man es
	  nur neu erzeugen (<command>newfs</command>) und die Daten
	  vom Backup zur&uuml;ckspielen.
	  </para>

	<para>Der historische Ausweg aus diesem Dilemma war ein
  	  <emphasis>dirty region logging</emphasis> (auch als
  	  <emphasis>Journalling</emphasis> bezeichnet, wenngleich
  	  dieser Begriff nicht immer gleich benutzt und manchmal auch
  	  f&uuml;r andere Formen von Transaktionsprotokollen gebraucht
  	  wird).  Man schreibt die Metadaten-Updates zwar synchron,
  	  aber nur in einen kleinen Plattenbereich, die
  	  <emphasis>logging area</emphasis>.  Von da aus werden sie
  	  dann asynchron auf ihre eigentlichen Bereiche verteilt.  Da
  	  die <emphasis>logging area</emphasis> ein kleines
  	  zusammenh&auml;ngendes St&uuml;ckchen ist, haben die
  	  Schreibk&ouml;pfe der Platte bei massiven Operationen auf
  	  Metadaten keine allzu gro&szlig;en Wege zur&uuml;ckzulegen,
  	  so da&szlig; alles ein ganzes St&uuml;ck schneller geht als
  	  bei klassischen synchronen Updates.  Die Komplexit&auml;t
  	  der Implementierung h&auml;lt sich ebenfalls in Grenzen,
  	  somit auch die Anf&auml;lligkeit f&uuml;r Fehler.  Als
  	  Nachteil ergibt sich, da&szlig; Metadaten zweimal auf die
  	  Platte geschrieben werden m&uuml;ssen (einmal in die
  	  <emphasis>logging area</emphasis>, einmal an die richtige
  	  Stelle), so da&szlig; das im Falle regul&auml;rer
  	  Arbeit (also keine geh&auml;uften Metadatenoperationen) eine
  	  <quote>Pessimisierung</quote> des Falls der synchronen
  	  Updates eintritt, es wird alles langsamer.  Daf&uuml;r hat man
  	  als Vorteil, da&szlig; im Falle eines Crashes der
  	  konsistente Zustand dadurch erzielbar ist, da&szlig; die
  	  angefangenen Operationen aus dem <emphasis>dirty region
  	  log</emphasis> entweder zu Ende ausgef&uuml;hrt oder
  	  komplett verworfen werden, wodurch das Dateisystem schnell
  	  wieder zur Verf&uuml;gung steht.
	  </para>
	  
	<para>Die L&ouml;sung von Kirk McKusick, dem Sch&ouml;pfer von
  	  Berkeley FFS, waren <emphasis>Soft Updates</emphasis>: die
  	  notwendigen Updates der Metadaten werden im Speicher
  	  gehalten und dann sortiert auf die Platte geschrieben
  	  (<quote>ordered metadata updates</quote>).  Dadurch hat man
  	  den Effekt, da&szlig; im Falle massiver
  	  Metadaten-&Auml;nderungen sp&auml;tere Operationen die
  	  vorhergehenden, noch nicht auf die Platte geschriebenen
  	  Updates desselben Elements im Speicher
  	  <quote>einholen</quote>.  Alle Operationen, auf ein
  	  Verzeichnis beispielsweise, werden also in der Regel noch im
  	  Speicher abgewickelt, bevor der Update &uuml;berhaupt auf
  	  die Platte geschrieben wird (die dazugeh&ouml;rigen
  	  Datenbl&ouml;cke werden nat&uuml;rlich auch so sortiert,
  	  da&szlig; sie nicht vor ihren Metadaten auf der Platte
  	  sind).  Im Fall eines Absturzes hat man ein implizites <quote>log
  	    rewind</quote>: alle Operationen, die noch nicht den Weg auf
  	  die Platte gefunden haben, sehen danach so aus, als
  	  h&auml;tten sie nie stattgefunden.  Man hat so also den
  	  konsistenten Zustand von ca. 30 bis 60 Sekunden fr&uuml;her
  	  sichergestellt.  Der verwendete Algorithmus garantiert
  	  dabei, da&szlig; alle tats&auml;chlich benutzten Ressourcen
  	  auch in den entsprechenden Bitmaps (Block- und inode
  	  Tabellen) als belegt markiert sind.  Der einzige Fehler, der
  	  auftreten kann, ist, da&szlig; Ressourcen noch als
  	  <quote>belegt</quote> markiert sind, die tats&auml;chlich
  	  <quote>frei</quote> sind.  &man.fsck.8; erkennt dies und
  	  korrigiert diese nicht mehr belegten Resourcen.  Die
  	  Notwendigkeit eines Dateisystem-Checks darf aus diesem
  	  Grunde auch ignoriert und das Dateisystem mittels
  	  <command>mount -f</command> zwangsweise eingebunden werden.
  	  Um noch allozierte Ressourcen freizugeben mu&szlig;
  	  sp&auml;ter ein &man.fsck.8; nachgeholt werden.  Das ist
  	  dann auch die Idee des <emphasis>background fsck</emphasis>:
  	  beim Starten des Systems wird lediglich ein
  	  <emphasis>Schnappschu&szlig;</emphasis> des Filesystems
  	  gemacht, mit dem &man.fsck.8; dann sp&auml;ter arbeiten
  	  kann.  Alle Dateisysteme d&uuml;rfen <quote>unsauber</quote>
  	  eingebunden werden und das System kann sofort in den
  	  Multiuser-Modus gehen.  Danach wird ein
  	  Hintergrund-<command>fsck</command> f&uuml;r die
  	  Dateisysteme gestartet, die dies ben&ouml;tigen, um
  	  m&ouml;glicherweise irrt&uuml;mlich belegte Resourcen
  	  freizugeben. (Dateisysteme ohne <emphasis>Soft
  	    Updates</emphasis> ben&ouml;tigen nat&uuml;rlich immer noch
  	  den &uuml;blichen (Vordergrund-)<command>fsck</command>,
  	  bevor sie eingebunden werden k&ouml;nnen.)</para>

	<para>Der Vorteil ist, da&szlig; die Metadaten-Operationen
  	  beinahe so schnell ablaufen wie im asynchronen Fall (also
  	  durchaus auch schneller als beim <quote>logging</quote>, das
  	  ja die Metadaten immer zweimal schreiben mu&szlig;).  Als
  	  Nachteil stehen dem die Komplexit&auml;t des Codes (mit
  	  einer erh&ouml;hten Fehlerwahrscheinlichkeit in einem
  	  bez&uuml;glich Datenverlust hoch sensiblen Bereich) und ein
  	  erh&ouml;hter Speicherverbrauch entgegen.  Au&szlig;erdem
  	  mu&szlig; man sich an einige Eigenheiten
  	  gew&ouml;hnen: Nach einem Absturz ist ein etwas &auml;lterer
  	  Stand auf der Platte &mdash; statt einer leeren, aber bereits
  	  angelegten Datei (wie nach einem herk&ouml;mmlichen
  	  <command>fsck</command> Lauf) ist auf einem Dateisystem mit
  	  <emphasis>Soft Updates</emphasis> keine Spur der
  	  entsprechenden Datei mehr zu sehen, da weder die Metadaten
  	  noch der Dateiinhalt je auf die Platte geschrieben wurden.
  	  Weiterhin kann der Platz nach einem <command>rm -r</command>
  	  nicht sofort wieder als verf&uuml;gbar markiert werden,
  	  sondern erst dann, wenn der Update auch auf die Platte
  	  vermittelt worden ist.  Dies kann besonders dann Probleme
  	  bereiten, wenn gro&szlig;e Datenmengen in einem Dateisystem
  	  ersetzt werden, das nicht gen&uuml;gend Platz hat, um alle
  	  Dateien zweimal unterzubringen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Einstellungen von Kernel Limits</title>

    <indexterm><primary>Einstellungen von Kernel Limits</primary></indexterm>
    
    <sect2 id="file-process-limits">
      <title>Datei und Proze&szlig; Limits</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>
	
	<para>Abh&auml;ngig von den Anforderungen Ihres Systems
	  kann <varname>kern.maxfiles</varname> erh&ouml;ht oder
	  erniedrigt werden.  Die Variable legt die maximale
	  Zahl von Dateideskriptoren auf Ihrem System fest.  Wenn
	  die Dateideskriptoren aufgebraucht sind, werden Sie
	  die Meldung <errorname>file: table is full</errorname>
	  wiederholt im Puffer f&uuml;r Systemmeldungen sehen.  Den
	  Inhalt des Puffers k&ouml;nnen Sie sich mit <command>dmesg</command>
	  anzeigen lassen.</para>

	<para>Jede offene Datei, jedes Socket und jede FIFO verbraucht
	  einen Dateideskriptor.  Auf <quote>dicken</quote> Produktionsservern
	  k&ouml;nnen leicht Tausende Dateideskriptoren ben&ouml;tigt
	  werden, abh&auml;ngig von der Art und Zahl der gleichzeitig
	  laufenden Dienste.</para>

	<para>Die Voreinstellung von <varname>kern.maxfile</varname>
	  wird von <option>MAXUSERS</option> aus Ihrer Kernelkonfiguration
	  bestimmt.  <varname>kern.maxfiles</varname> w&auml;chst
	  proportional mit dem Wert von <option>MAXUSERS</option>.
	  Wenn Sie einen angepa&szlig;ten Kernel kompilieren, empfiehlt es sich
	  diese Option entsprechend der maximalen Benutzerzahl Ihres
	  Systems einzustellen.  Obwohl auf einer Produktionsmaschine
	  vielleicht nicht 256 Benutzer gleichzeitig angemeldet sind,
	  k&ouml;nnen die ben&ouml;tigten Ressourcen &auml;hnlich denen
	  eines gro&szlig;en Webservers sein.</para>

	<note><para>Ab FreeBSD 4.5 k&ouml;nnen Sie <option>MAXUSERS</option>
	  in der Kernelkonfiguration auf <literal>0</literal> setzen.  Das
	  System setzt dann automatisch einen passenden Wert, der von der
	  Gr&ouml;&szlig;e Ihres Hauptspeichers abh&auml;ngt,
	  ein.</para></note>

      </sect3>
    </sect2>
    <sect2>
      <title>Netzwerk Limits</title>

      <para>Die Kerneloption <option>NMBCLUSTERS</option> schreibt
	die Anzahl der Netzwerkpuffer (MBUFs) fest, die das System besitzt.
	Eine zu geringe Zahl MBUFs auf einem Server mit viel Netzwerkverkehr
	verringert die Leistung von FreeBSD.  Jeder MBUF Cluster nimmt
	ungef&auml;hr 2K Speicher in Anspruch, so da&szlig; ein Wert
	von 1024 insgesamt 2 Megabyte Speicher f&uuml;r Netzwerkpuffer
	im System reserviert.  Wieviele Cluster ben&ouml;tigt werden,
	l&auml;&szlig;t sich durch eine einfache Berechnung herausfinden.
	Wenn Sie einen Webserver besitzen, der maximal 1000 gleichzeitige
	Verbindungen servieren soll und jede der Verbindungen je einen
	16 K gro&szlig;en Puffer zum Senden und Empfangen braucht, brauchen
	Sie ungef&auml;hr 32 MB Speicher f&uuml;r Netzwerkpuffer.  Als
	Daumenregel multiplizieren Sie diese Zahl mit 2, so da&szlig; sich
	f&uuml;r <varname>NMBCLUSTERS</varname> der Wert 
	32MBx2 = 64MB/2K = 32768 ergibt.</para>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Hinzuf&uuml;gen von Swap-Bereichen</title>

    <para>Egal wie vorausschauend Sie planen, entspricht ein System
      manchmal nicht Ihren Erwartungen.  Es ist leicht, mehr Swap-Bereiche
      hinzuzuf&uuml;gen.  Dazu stehen Ihnen drei Wege offen:  Sie
      k&ouml;nnen eine neue Platte einbauen, den Swap-Bereich &uuml;ber NFS
      ansprechen oder eine Swap-Datei auf einer existierenden Partition
      einrichten.</para>

    <sect2 id="new-drive-swap">
      <title>Swap auf einer neuen Festplatte</title>

      <para>Der einfachste Weg, zus&auml;tzlich einen Swap-Bereich
        einzurichten, ist der Einbau einer neuen Platte, da Sie ja immer
	eine neue Platte einbauen k&ouml;nnen.  Nachdem Sie das getan
	haben, lesen Sie bitte noch einmal den Abschnitt
	<ulink url="configtuning-initial.html#SWAP-DESIGN">Swap
	Partition</ulink> aus dem Kapitel <ulink
	  url="configtuning-initial.html">Vorbereitende Konfiguration</ulink>
	des Handbuchs.  Dort finden Sie Vorschl&auml;ge, wie Sie den
	Swap-Bereich am besten einrichten.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Swapping over NFS</title>

      <para>Swap-Bereiche &uuml;ber NFS sollten Sie nur dann nutzen, wenn
        Sie &uuml;ber keine lokale Platte verf&uuml;gen.  In FreeBSD
	Versionen vor 4.X ist dies zudem sehr langsam und nicht effizient.
	Ab FreeBSD 4.0 ist das Nutzen von Swap &uuml;ber NFS gen&uuml;gend
	schnell und effizient, doch wird es durch die zur Verf&uuml;gung
	stehende Bandbreite limitiert und belastet zus&auml;tzlich den
	NFS-Server.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>Swap-Dateien</title>

      <para>Sie k&ouml;nnen eine Datei festgelegter Gr&ouml;&szlig;e als
        Swap-Bereich nutzen.  Im folgenden Beispiel werden wir eine 64 MB
	gro&szlig;e Datei mit dem Namen <filename>/usr/swap0</filename>
	benutzen, Sie k&ouml;nnen nat&uuml;rlich einen beliebigen Namen
	f&uuml;r den Swap-Bereich benutzen.</para>

      <example>
	<title>Erstellen einer Swap-Datei</title>

        <orderedlist>
	  <listitem>
            <para>Zuerst stellen Sie bitte sicher, da&szlig; Ihr Kernel den
              vnode-Treiber enth&auml;lt.  In neueren Versionen von
      	      <filename>GENERIC</filename> ist dieser
	      <emphasis>nicht</emphasis> enthalten.</para>

            <programlisting>pseudo-device   vn 1   #Vnode driver (turns a file into a device)</programlisting>
	  </listitem>

	  <listitem>
	    <para>Erstellen Sie das vn-Ger&auml;t:</para>
	    <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Legen Sie die Swap-Datei <filename>/usr/swap0</filename>
	      an:</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Setzen Sie die richtigen Berechtigungen f&uuml;r
	      <filename>/usr/swap0</filename>:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Aktivieren Sie die Swap-Datei in
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	  </listitem>

	  <listitem>
	    <para>Um die Swap-Datei zu aktivieren, f&uuml;hren Sie
	      entweder einen Reboot durch oder geben das folgende Kommando
	      ein:</para> 

            <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
	  </listitem>
        </orderedlist>
      </example>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
