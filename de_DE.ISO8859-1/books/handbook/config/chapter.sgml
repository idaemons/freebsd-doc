<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/config/chapter.sgml,v 1.47 2002/10/16 20:09:41 mheinen Exp $
     basiert auf: 1.69
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Geschrieben von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Nach einem Tutorium von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Basiert ebenfalls auf tuning(7) von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Martin</firstname>
	<surname>Heinen</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Konfiguration und Tuning</title>

  <sect1>
    <title>&Uuml;bersicht</title>

    <indexterm><primary>System-Konfiguration/Optimierung</primary></indexterm>

    <para>Ein korrekt konfiguriertes System kann die Arbeit,
      die bei der zuk&uuml;nftigen Pflege und bei Migrationen des Systems
      entsteht, erheblich reduzieren.  Dieses Kapitel beschreibt die
      Konfiguration von FreeBSD sowie Ma&szlig;nahmen zur Leistungssteigerung
      von FreeBSD Systemen.</para>

    <para>Nachdem Sie dieses Kapitel durchgearbeitet haben,
      werden Sie folgendes wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Wie Sie effizient Dateisysteme und
	  Swap-Partitionen auf Ihrer Festplatte einrichten.</para>
      </listitem>
      <listitem>
	<para>Die Grundlagen der Konfiguration mit
	  <filename>rc.conf</filename> und des Systems zum Starten
	  von Anwendungen in <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>
      <listitem>
	<para>Wie Sie virtuelle Hosts und Netzwerkger&auml;te
	  konfigurieren.</para>
      </listitem>
      <listitem>
	<para>Wie Sie die verschiedenen Konfigurationsdateien
	  in <filename>/etc</filename> benutzen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie mit <command>sysctl</command>-Variablen FreeBSD
	  einstellen k&ouml;nnen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie die Platten Performance einstellen und Kernel Parameter
	  modifizieren k&ouml;nnen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>
    <itemizedlist>
      <listitem>
	<para>die Grundlagen von Unix und FreeBSD (<xref linkend="basics">)
	  verstehen.</para>
      </listitem>
      <listitem>
	<para>Damit vertraut sein, wie Sie die FreeBSD-Quellen aktuell
	  halten (<xref linkend="cutting-edge">) und wissen, wie Sie einen
	  Kernel konfigurieren und kompilieren
	  (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Vorbereitende Konfiguration</title>

    <sect2>
      <title>Layout von Partitionen</title>

      <indexterm><primary>Layout von Partitionen</primary></indexterm>
      <indexterm><primary><filename>/etc</filename></primary></indexterm>
      <indexterm><primary><filename>/var</filename></primary></indexterm>
      <indexterm><primary><filename>/usr</filename></primary></indexterm>

      <sect3>
	<title>Partitionen</title>

	<para>Wenn Sie Dateisysteme mit &man.disklabel.8; oder
	  &man.sysinstall.8; anlegen, sollten Sie beachten, da&szlig;
	  Festplatten auf Daten in den &auml;u&szlig;eren Spuren
	  schneller zugreifen k&ouml;nnen als auf Daten in den
	  inneren Spuren.  Daher sollten die kleineren oft benutzten
	  Dateisysteme, wie das Root-Dateisystem oder die Swap-Partition,
	  an den &auml;u&szlig;eren Rand der Platte gelegt werden.
	  Die gr&ouml;&szlig;eren Partitionen wie <filename>/usr</filename>
	  sollten in die inneren Bereiche gelegt werden.
	  Es empfiehlt sich, die Partitionen in einer &auml;hnlichen
	  Reihenfolge wie Root-Partition, Swap, <filename>/var</filename>
	  und <filename>/usr</filename> anzulegen.</para>

	<para>Die Gr&ouml;&szlig;e von <filename>/var</filename>
	  ist abh&auml;ngig vom Zweck der Maschine.
	  <filename>/var</filename> enth&auml;lt haupts&auml;chlich
	  Postf&auml;cher, den Spoolbereich zum Drucken und Logdateien.
	  Abh&auml;ngig von der Anzahl der Systembenutzer und der
	  Aufbewahrungszeit f&uuml;r Logdateien, k&ouml;nnen gerade
	  die Postf&auml;cher und Logdateien zu ungeahnten Gr&ouml;&szlig;en
	  wachsen.  Oft werden Sie mit weniger als einem Gigabyte
	  auskommen, doch beachten Sie, da&szlig;
	  <filename>/var/tmp</filename> f&uuml;r Pakete ausreichend
	  dimensioniert ist.</para>

	<para>Die <filename>/usr</filename>-Partition enth&auml;lt den
	  Hauptteil des Systems, die Ports-Sammlung (empfohlen) und die
	  Quellen (optional).  Im Laufe der Installation haben Sie die
	  M&ouml;glichkeit, die Quellen und die Ports-Sammlung gleich mit
	  zu installieren.  F&uuml;r die
	  <filename>/usr</filename>-Partition sollten Sie mindestens
	  2&nbsp;Gigabyte vorsehen.</para>

	<para>Wenn Sie die Gr&ouml;&szlig;e der Partitionen festlegen,
	  beachten Sie bitte das Wachstum Ihres Systems.  Wenn Sie den
	  Platz auf einer Partition vollst&auml;ndig aufgebraucht haben,
	  eine andere Partition aber kaum benutzen, kann die Handhabung des
	  Systems schwierig werden.</para>

	<note><para>Die automatische Partitionierung von &man.sysinstall.8;
	  mit <literal>Auto-defaults</literal> legt manchmal zu kleine
	  <filename>/</filename> und <filename>/var</filename>-Partition an.
	  Partitionieren Sie weise und gro&szlig;z&uuml;gig.</para></note>

      </sect3>

      <sect3 id="swap-design">
	<title>Swap Partition</title> 

	<indexterm><primary>Gr&ouml;&szlig;e der
	  Swap-Partition</primary></indexterm>
	<indexterm><primary>Swap-Partition</primary></indexterm>

	<para>Als Daumenregel sollten Sie doppelt soviel Speicher
	  f&uuml;r die Swap-Partition vorsehen, als Sie Hauptspeicher
	  haben.  Verf&uuml;gt die Maschine beispielsweise &uuml;ber
	  128&nbsp;Megabyte Hauptspeicher, sollten Sie 256&nbsp;Megabyte
	  f&uuml;r den Swap-Bereich vorsehen.  Systeme mit weniger Speicher
	  werden wahrscheinlich mit viel mehr Swap mehr leisten.  Es
	  wird nicht empfohlen, weniger als 256&nbsp;Megabyte Swap einzurichten.
	  Au&szlig;erdem sollten Sie k&uuml;nftige Speichererweiterungen
	  beachten, wenn Sie die Swap-Partition einrichten.  Die
	  VM-Paging-Algorithmen im Kernel sind so eingestellt, da&szlig;
	  Sie am besten laufen, wenn die Swap-Partition mindestens
	  doppelt so gro&szlig; wie der Hauptspeicher ist.  Zu wenig
	  Swap kann zu einer Leistungsverminderung im 
	  <foreignphrase>VM page scanning</foreignphrase>
	  Code f&uuml;hren, sowie Probleme verursachen, wenn Sie sp&auml;ter
	  mehr Speicher in Ihre Maschine bauen.<para>

	<para>Auf gr&ouml;&szlig;eren Systemen mit mehreren SCSI-Laufwerken
	  (oder mehreren IDE-Laufwerken an unterschiedlichen Controllern)
	  empfehlen wir Ihnen, Swap-Bereiche auf bis zu
	  vier Laufwerken einzurichten.  Diese Swap-Partitionen sollten
	  ungef&auml;hr dieselbe Gr&ouml;&szlig;e haben.  Der Kernel
	  kann zwar mit beliebigen Gr&ouml;&szlig;en umgehen, aber
	  die internen Datenstrukturen skalieren bis zur vierfachen
	  Gr&ouml;&szlig;e der gr&ouml;&szlig;ten Partition.  Ungef&auml;hr
	  gleich gro&szlig;e Swap-Partitionen erlauben es dem Kernel,
	  den Swap-Bereich optimal &uuml;ber die Laufwerke zu verteilen.
	  Gro&szlig;e Swap-Bereiche, auch wenn sie nicht oft gebraucht
	  werden, sind n&uuml;tzlich, da sich ein speicherfressendes
	  Programm unter Umst&auml;nden auch ohne einen Neustart des Systems
	  beenden l&auml;&szlig;t.</para>
      </sect3>

      <sect3>
	<title>Warum partitionieren?</title>

	<para>Gegen eine einzelne Partition sprechen mehrere Gr&uuml;nde.
	  Jede Partition hat im Betrieb unterschiedliche Eigenschaften
	  und die Trennung der Partitionen erlaubt es, die Dateisysteme
	  an diese Eigenschaften anzupassen.  Die Root- und
	  <filename>/usr</filename>-Partitionen weisen meist nur
	  lesende Zugriffe auf, w&auml;hrend <filename>/var</filename>
	  und <filename>/var/tmp</filename> haupts&auml;chlich
	  beschrieben werden.</para>

	<para>Indem Sie ein System richtig partitionieren, verhindern
	  Sie, da&szlig; eine Fragmentierung in den h&auml;ufig beschriebenen
	  Partitionen auf die meist nur gelesenen Partitionen 
	  &uuml;bergreift.  Wenn Sie die h&auml;ufig beschriebenen
	  Partitionen an den Rand der Platte, legen, dann wird die
	  I/O-Leistung diesen Partitionen steigen.
	  Die I/O-Leistung ist nat&uuml;rlich auch f&uuml;r gro&szlig;e
	  Partitionen wichtig, doch erzielen Sie eine gr&ouml;&szlig;ere
	  Leistungssteigerung, wenn Sie <filename>/var</filename> an den
	  Rand der Platte legen.  Schlie&szlig;lich sollten Sie
	  noch die Stabilit&auml;t des Systems beachten.
	  Eine kleine Root-Partition, auf die meist nur lesend
	  zugegriffen wird, &uuml;berlebt einen schlimmen Absturz
	  wahrscheinlich eher als eine gro&szlig;e Partition.</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Basiskonfiguration</title>

    <indexterm>
      <primary>rc Dateien</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>Informationen zur Systemkonfiguration sind haupts&auml;chlich
      in <filename>/etc/rc.conf</filename>, die meist beim Start
      des Systems verwendet wird, abgelegt.  Der Name der Datei zeigt
      ihren Zweck an: Sie enth&auml;lt die Konfigurationen f&uuml;r
      die <filename>rc*</filename> Dateien.</para>

    <para>In <filename>rc.conf</filename> werden die Vorgabewerte aus
      <filename>/etc/defaults/rc.conf</filename> &uuml;berschrieben.
      Die Vorgabedatei sollte nicht nach <filename>/etc</filename>
      kopiert werden, da sie die Vorgabewerte und keine Beispiele 
      enth&auml;lt.  Jede systemspezifische &Auml;nderung wird
      in <filename>rc.conf</filename> vorgenommen.</para>

    <para>Um den administrativen Aufwand gering zu halten, existieren
      in geclusterten Anwendungen mehrere Strategien,
      globale Konfigurationen von systemspezifischen Konfigurationen
      zu trennen.  Der empfohlene Weg h&auml;lt die globale Konfiguration
      in einer separaten Datei z.B. <filename>rc.conf.site</filename>.
      Diese Datei wird dann in <filename>/etc/rc.conf</filename>,
      die nur systemspezifische Informationen enth&auml;lt, eingebunden.</para>

    <para>Da <filename>rc.conf</filename> von &man.sh.1; gelesen
      wird, ist das einfach zu erreichen:</para>

    <itemizedlist>
      <listitem><para>rc.conf:</para>
<programlisting>	. rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"</programlisting></listitem>
      <listitem><para>rc.conf.site:</para>
<programlisting>	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"</programlisting></listitem>
    </itemizedlist>

    <para><filename>rc.conf.site</filename> kann dann auf jedes
      System mit <command>rsync</command> verteilt werden,
      <filename>rc.conf</filename> bleibt dabei systemspezifisch.</para>

    <para>Bei einem Upgrade des Systems mit &man.sysinstall.8; oder
      <command>make world</command> wird <filename>rc.conf</filename>
      nicht &uuml;berschrieben, so da&szlig; die Systemkonfiguration
      erhalten bleibt.</para>

  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Konfiguration von Anwendungen</title>

    <para>Installierte Anwendungen haben typischerweise
      eigene Konfigurationsdateien, die eine eigene Syntax
      verwenden.  Damit diese Dateien leicht von der
      Paketverwaltung gefunden und verwaltet werden k&ouml;nnen,
      ist es wichtig, sie vom Basissystem zu trennen.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>F&uuml;r gew&ouml;hnlich werden diese Dateien in 
      <filename>/usr/local/etc</filename> installiert.  Besitzt
      eine Anwendung viele Konfigurationsdateien, werden
      diese in einem separaten Unterverzeichnis abgelegt.</para>

    <para>Wenn ein Port oder ein Paket installiert wird, werden
      normalerweise auch Beispiele f&uuml;r die Konfigurationsdateien
      installiert.  Diese erkennt man gew&ouml;hnlich an dem
      Suffix <filename>.default</filename>.  Wenn keine Konfigurationsdateien
      f&uuml;r eine Anwendung existieren, werden sie durch
      Kopieren der <filename>.default</filename> Dateien erstellt.</para>

    <para>Als Beispiel sei <filename>/usr/local/etc/apache</filename>
      gezeigt:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Anhand der Dateigr&ouml;&szlig;e erkennen Sie, da&szlig; sich
      nur <filename>srm.conf</filename> ge&auml;ndert hat.  Ein
      sp&auml;terer Update des <application>Apache</application> Ports
      w&uuml;rde diese Datei nicht &uuml;berschreiben.</para>

  </sect1>

  <sect1 id="configtuning-starting-services">
    <title>Start von Diensten</title>

    <indexterm><primary>Dienste</primary></indexterm>

    <para>Es ist &uuml;blich, da&szlig; ein System mehrere Dienste
      zur Verf&uuml;gung stellt.  Diese k&ouml;nnen auf verschiedene
      Weisen, die jeweils andere Vorteile haben, gestartet werden.</para>

    <indexterm><primary>/usr/local/etc/rc.d</primary></indexterm>

    <para>Software, die von einem Port oder einem Paket installiert
      wurde, wird oft ein Skript in <filename>/usr/local/etc/rc.d</filename>
      stellen.  Dieses wird beim Hochfahren des Systems mit dem
      Argument <option>start</option> und beim Herunterfahren mit
      dem Argument <option>stop</option> aufgerufen.  Das ist der empfohlene
      Weg, systemweite Dienste, die unter <username>root</username> laufen
      oder unter <username>root</username> gestartet werden, zu starten.
      Die Skripten werden bei der Installation des Paketes registriert
      und entfernt, wenn das Paket entfernt wird.</para>

    <para>Ein typisches Skript in <filename>/usr/local/etc/rc.d</filename>
      sieht wie folgt aus:</para>

    <programlisting>#!/bin/sh
echo -n ' FooBar'

case "$1" in
start)
        /usr/local/bin/foobar
        ;;
stop)
        kill -9 `cat /var/run/foobar.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0
    </programlisting>

    <para>Die Startskripten von FreeBSD suchen in
      <filename>/usr/local/etc/rc.d</filename> nach Dateien mit dem Suffix
      <literal>.sh</literal>, die von <username>root</username>
      ausgef&uuml;hrt werden k&ouml;nnen.  Die gefundenen Skripten werden
      beim Hochfahren des Systems mit der Option <option>start</option> und
      beim Herunterfahren mit der Option <option>stop</option> aufgerufen,
      damit sie die passenden Aktionen ausf&uuml;hren k&ouml;nnen.  Wenn
      Sie das vorige Beispiel beim Systemstart verwenden wollen, sollten
      Sie es also als <filename>FooBar.sh</filename> in
      <filename>/usr/local/etc/rc.d</filename> speichern und sicherstellen,
      das das Skript ausf&uuml;hrbar ist.  Benutzen Sie &man.chmod.1;, um
      das Skript ausf&uuml;hrbar zu machen:</para>

    <screen>&prompt.root; <userinput>chmod 755 <replaceable>FooBar.sh</replaceable></userinput></screen>

    <para>Manche Dienste werden von &man.inetd.8; aufgerufen, wenn
      eine Verbindung auf dem passenden Port aufgebaut wird.  &Uuml;blich
      ist das f&uuml;r Server von Mail-Clients (POP, IMAP, usw.).  Diese
      Dienste werden durch das Editieren von 
      <filename>/etc/inetd.conf</filename> aktiviert.  Details dazu
      finden sich in &man.inetd.8;.</para>

    <para>Weitere Systemdienste werden vielleicht nicht von
      <filename>/etc/rc.conf</filename> abgedeckt.  Diese werden
      traditionell durch Kommandos in <filename>/etc/rc.local</filename>
      aktiviert.  Seit FreeBSD&nbsp;3.1 existiert keine Vorgabe f&uuml;r
      <filename>/etc/rc.local</filename> mehr.  Wenn die Datei allerdings
      von einem Administrator angelegt wird, so wird sie auch
      ausgef&uuml;hrt.  Beachten Sie bitte, da&szlig; 
      <filename>/etc/rc.local</filename> als der letzte Weg, einen
      Dienst zu starten, angesehen wird.  Wenn es eine andere
      M&ouml;glichkeit gibt, den Dienst zu starten, nehmen Sie diese
      bitte wahr.</para>

    <note><para>F&uuml;gen Sie bitte <emphasis>keine</emphasis> Kommandos
      in <filename>/etc/rc.conf</filename> ein.  Starten Sie stattdessen
      D&aelig;mons oder Kommandos beim Hochfahren mit Skripten in
      <filename>/usr/local/etc/rc.d</filename>.</para></note>

    <para>Systemdienste k&ouml;nnen auch mit &man.cron.8; gestartet
      werden.  Dieser Ansatz hat einige Vorteile; nicht zuletzt, weil
      &man.cron.8; die Prozesse unter dem Eigent&uuml;mer der
      <command>crontab</command> startet, ist es m&ouml;glich, da&szlig;
      Dienste von nicht-<username>root</username> Benutzern gestartet
      und gepflegt werden k&ouml;nnen.</para>

    <para>Dies nutzt eine Eigenschaft von &man.cron.8;:
      F&uuml;r die Zeitangabe kann <literal>@reboot</literal>
      eingesetzt werden.  Damit wird das Kommando gestartet, wenn
      &man.cron.8; kurz nach dem Systemboot gestartet wird.</para>
  </sect1>

  <sect1>
    <sect1info>
      <authorgroup>
        <author>
	 <firstname>Marc</firstname>
	 <surname>Fonvieille</surname>
	 <contrib>Beigetragen von </contrib>
	 <!-- 6 October 2002 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>Einrichten von Netzwerkkarten</title>

    <indexterm><primary>Netzwerkkarten</primary></indexterm>

    <para>Ein Rechner ohne Netzanschlu&szlig; ist heute nicht mehr
      vorstellbar.  Die Konfiguration einer Netzwerkkarte geh&ouml;rt zu
      den allt&auml;glichen Aufgaben eines FreeBSD Administrators.</para>

    <sect2>
      <title>Bestimmen des richtigen Treibers</title>

      <indexterm>
        <primary>Netzwerkkarten</primary>
        <secondary>Treiber</secondary>
      </indexterm>

      <para>Bevor Sie anfangen, sollten Sie das Modell Ihrer Karte kennen,
        wissen welchen Chip die Karte benutzt und bestimmen, ob es sich
	um eine PCI- oder ISA-Karte handelt.  Eine Aufz&auml;hlung der
	unterst&uuml;tzten PCI- und ISA-Karten finden Sie in der
	Liste der unterst&uuml;tzen Ger&auml;te.  Schauen Sie nach, ob Ihre
	Karte dort aufgef&uuml;hrt ist.</para>

      <para>Wenn Sie wissen, da&szlig; Ihre Karte unterst&uuml;tzt wird,
        m&uuml;ssen Sie den Treiber f&uuml;r Ihre Karte bestimmen.
	<filename>/usr/src/sys/i386/conf/LINT</filename> enth&auml;lt eine
	Liste der verf&uuml;gbaren Treiber mit Informationen zu den
	unterst&uuml;tzten Chips&auml;tzen und Karten.  Wenn Sie sich nicht
	sicher sind, ob Sie den richtigen Treiber ausgew&auml;hlt haben,
	lesen Sie die Hilfeseite des Treibers.  Die Hilfeseite enth&auml;lt
	weitere Informationen &uuml;ber die unterst&uuml;tzten Ger&auml;te
	und macht auch auf m&ouml;gliche Probleme aufmerksam.</para>

      <para>Wenn Sie eine gebr&auml;uchliche Karte besitzen, brauchen Sie
        meistens nicht lange nach dem passenden Treiber zu suchen.  Die
	Treiber zu diesen Karten sind schon im
	<filename>GENERIC</filename>-Kernel enthalten und die Karte sollte
	w&auml;hrend des Systemstarts erkannt werden:</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</screen>

      <para>Im Beispiel erkennt das System zwei Karten, die den
        &man.dc.4; Treiber benutzen.</para>

      <para>Der richtige Treiber mu&szlig; geladen sein, damit eine
        Netzwerkkarte benutzt werden kann.  Der Treiber kann auf zwei Arten
	geladen werden:  Am einfachsten laden Sie das Kernelmodul f&uuml;r
	Ihre Karte mit &man.kldload.8;.  F&uuml;r manche Netzwerkkarten
	gibt es kein Kernelmodul (beispielsweise f&uuml;r ISA-Karten, die
	den &man.ed.4; Treiber benutzen).  Die zweite M&ouml;glichkeit ist,
	die Unterst&uuml;tzung f&uuml;r Ihre Karte fest in den Kernel
	einzubinden.  Schauen Sie sich dazu
	<filename>/usr/src/sys/i386/conf/LINT</filename> und die Hilfeseite
	des Treibers, den Sie in den Kernel einbinden m&ouml;chten, an.
	Die &Uuml;bersetzung des Kernels wird in
	<xref linkend="kernelconfig"> beschrieben.  Wenn Ihre Karte
	w&auml;hrend des Systemstarts vom Kernel
	(<filename>GENERIC</filename>) erkannt wurde, m&uuml;ssen Sie den
	Kernel nicht neu &uuml;bersetzen.</para>
    </sect2>

    <sect2>
      <title>Konfiguration von Netzwerkkarten</title>

      <indexterm>
        <primary>Netzwerkkarten</primary>
        <secondary>konfigurieren</secondary>
      </indexterm>

      <para>Nachdem der richtige Treiber f&uuml;r die Karte geladen ist,
        mu&szlig; die Karte konfiguriert werden.  Unter Umst&auml;nden ist
	die Karte schon w&auml;hrend der Installation mit
	<application>sysinstall</application> konfiguriert worden.</para>

      <para>Das nachstehende Kommando zeigt die Konfiguration der Karten
        eines Systems an:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</screen>

      <note>
	<para>In alten Versionen von FreeBSD m&uuml;ssen Sie vielleicht
	  noch <option>-a</option> auf der Kommandozeile von &man.ifconfig.8;
	  angeben.  Hinweise zum Gebrauch von &man.ifconfig.8; entnehmen
	  Sie bitte der Hilfeseite.  Beachten Sie, da&szlig; in diesem
	  Beispiel die IPv6-Ausgaben (<literal>inet6</literal> etc.)
	  ausgelassen wurden.</para>
      </note>

      <para>Im Beispiel werden Informationen zu den folgenden Ger&auml;ten
        angezeigt:</para>

      <itemizedlist>
	<listitem>
	  <para><devicename>dc0</devicename>: Der erste
	    Ethernet-Adapter</para>
	</listitem>

	<listitem>
	  <para><devicename>dc1</devicename>: Der zweite
	    Ethernet-Adapter</para>
	</listitem>

	<listitem>
	  <para><devicename>lp0</devicename>: Die parallele
	    Schnittstelle</para>
	</listitem>

	<listitem>
	  <para><devicename>lo0</devicename>: Das Loopback-Ger&auml;t</para>
	</listitem>

	<listitem>
	  <para><devicename>tun0</devicename>: Das von
	    <application>ppp</application> benutzte Tunnel-Ger&auml;t</para>
	</listitem>
      </itemizedlist>

      <para>Der Name der Netzwerkkarte wird aus dem Namen des Treibers und
        einer Zahl zusammengesetzt.  Die Zahl gibt die Reihenfolge an, in
	der die Ger&auml;te beim Systemstart erkannt wurden.  Die dritte
	Karte, die den &man.sis.4; Treiber benutzt, w&uuml;rde
	beispielsweise <devicename>sis2</devicename> hei&szlig;en.</para>

      <para>Der Adapter <devicename>dc0</devicename> aus dem Beispiel ist
        aktiv.  Sie erkennen das an den folgenden Hinweisen:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> bedeutet, da&szlig; die Karte
	    konfiguriert und aktiv ist.</para>
	</listitem>

	<listitem>
	  <para>Der Karte wurde die Internet-Adresse (<literal>inet</literal>)
	    <hostid role="ipaddr">192.168.1.3</hostid> zugewiesen.</para>
	</listitem>

	<listitem>
	  <para>Die Subnetzmaske ist richtig
	    (<hostid role="netmask">0xffffff00</hostid> entspricht
	    <hostid role="netmask">255.255.255.0</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Die Broadcast-Adresse <hostid
	    role="ipaddr">192.168.1.255</hostid> ist richtig.</para>
	</listitem>

	<listitem>
	  <para>Die MAC-Adresse der Karte (<literal>ether</literal>)
	    lautet <hostid role="mac">00:a0:cc:da:da:da</hostid>.</para>
	</listitem>

	<listitem>
	  <para>Die automatische Medienerkennung ist aktiviert
	    (<literal>media: Ethernet autoselect (100baseTX
	      &lt;full-duplex&gt;)</literal>).  Der Adapter
	    <devicename>dc1</devicename> benutzt das Medium
	    <literal>10baseT/UTP</literal>.  Weitere Informationen
	    &uuml;ber die einstellbaren Medien entnehmen
	    Sie bitte der Hilfeseite des Treibers.</para>
	</listitem>

	<listitem>
	  <para>Der Verbindungsstatus (<literal>status</literal>) ist
	    <literal>active</literal>, das hei&szlig;t es wurde ein
	    Tr&auml;gersignal entdeckt.  F&uuml;r
	    <devicename>dc1</devicename> wird <literal>status: no
	      carrier</literal> angezeigt.  Das ist normal, wenn kein Kabel
	    an der Karte angeschlossen ist.</para>
	</listitem>
      </orderedlist>

      <para>W&auml;re die Karte nicht konfiguriert, w&uuml;rde die Ausgabe
        von &man.ifconfig.8; so aussehen:</para>

<screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
	        ether 00:a0:cc:da:da:da</screen>

      <para>Sie brauchen die Berechtigungen von <username>root</username>, um
        Ihre Karte zu konfigurieren.  Die Konfiguration kann auf der
	Kommandozeile mit &man.ifconfig.8; erfolgen, allerdings
	m&uuml;&szlig;te sie dann nach jedem Neustart wiederholt werden.
	Dauerhaft wird die Karte in <filename>/etc/rc.conf</filename>
	konfiguriert.</para>

      <para>&Ouml;ffnen Sie <filename>/etc/rc.conf</filename> mit Ihrem
        Lieblingseditor und f&uuml;gen Sie f&uuml;r jede Karte Ihres
	Systems eine Zeile hinzu.  In dem hier diskutierten Fall wurden
	die nachstehenden Zeilen eingef&uuml;gt:</para>

<programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>Ersetzen Sie <devicename>dc0</devicename>,
        <devicename>dc1</devicename> usw. durch die Ger&auml;tenamen Ihrer
	Karten und setzen Sie die richtigen IP-Adressen ein.  Die
	Hilfeseiten des Treibers und &man.ifconfig.8; enthalten weitere
	Einzelheiten &uuml;ber verf&uuml;gbare Optionen.  Die Syntax von
	<filename>/etc/rc.conf</filename> wird in &man.rc.conf.5;
	erkl&auml;rt.</para>

      <para>Wenn Sie das Netz w&auml;hrend der Installation
        konfiguriert haben, existieren vielleicht schon Eintr&auml;ge
	f&uuml;r Ihre Karten.  &Uuml;berpr&uuml;fen Sie
	<filename>/etc/rc.conf</filename> bevor Sie weitere Zeilen
	hinzuf&uuml;gen.</para>

      <para>In <filename>/etc/hosts</filename> k&ouml;nnen Sie die Namen
        und IP-Adressen der Rechner Ihres LANs eintragen.  Weitere
	Informationen entnehmen Sie bitte &man.hosts.5; und
	<filename>/usr/share/examples/etc/hosts</filename>.</para>
    </sect2>

    <sect2>
      <title>Test und Fehlersuche</title>

      <para>Nachdem Sie die notwendigen &Auml;nderungen in
        <filename>/etc/rc.conf</filename> vorgenommen haben, f&uuml;hren
	Sie einen Neustart Ihres Systems durch.  Dadurch werden die Adapter
	konfiguriert und Sie stellen sicher, da&szlig; der Start ohne
	Konfigurationsfehler erfolgt.</para>

      <para>Wenn das System gestartet ist, sollten Sie die Netzwerkkarten
	testen.</para>

      <sect3>
	<title>Test der Ethernet-Karte</title>

        <indexterm>
          <primary>Netzwerkkarten</primary>
          <secondary>Test</secondary>
        </indexterm>

	<para>Mit zwei Tests k&ouml;nnen Sie pr&uuml;fen, ob die
	  Ethernet-Karte richtig konfiguriert ist.  Testen Sie zuerst mit
	  <command>ping</command> den Adapter selbst und sprechen Sie dann
	  eine andere Maschine im LAN an.</para>

	<para>Zuerst, der Test des Adapters:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

	<para>Jetzt versuchen wir, eine andere Maschine im LAN zu
	  erreichen:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

	<para>Sie k&ouml;nnen auch den Namen der Maschine anstelle von
	  <hostid role="ipaddr">192.168.1.2</hostid> benutzen, wenn Sie
	  <filename>/etc/hosts</filename> entsprechend eingerichtet
	  haben.</para>
      </sect3>

      <sect3>
	<title>Fehlersuche</title>

        <indexterm>
          <primary>Netzwerkkarten</primary>
          <secondary>Fehlersuche</secondary>
        </indexterm>

	<qandaset>
	  <qandaentry>
	    <question>
	      <para>Wo finde ich Informationen &uuml;ber m&ouml;gliche
	        Probleme mit meiner Karte?</para>
	    </question>

	    <answer>
	      <para>Zuerst sollten Sie die Hilfeseiten des Treibers lesen.
		Die Archive der Mailinglisten k&ouml;nnen ebenfalls
		hilfreich sein.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question>
	      <para>Wenn ich versuche mit <command>ping</command> einen anderen
	        Rechner im LAN zu erreichen, erhalte ich die Meldung:
		<errorname>ping: sendto: Permission
		  denied</errorname>.</para>
	    </question>

	    <answer>
	      <para>Sie d&uuml;rfen keine ICMP-Pakete verschicken.
	        Pr&uuml;fen Sie, ob auf der Maschine eine Firewall
		l&auml;uft, die ICMP verbietet.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question>
	      <para>In den Systemprotokollen finden sich viele
	        <errorname>watchdog timeout</errorname> Meldungen.  Bei dem
		Versuch andere Rechner im LAN zu erreichen, gibt
		<command>ping</command> die Meldung <errorname>ping:
		  sendto: No route to host</errorname> aus.</para>
	    </question>

	    <answer>
	      <para>Kontrollieren Sie zuerst das Netzkabel.
	        &Uuml;berpr&uuml;fen Sie dann, ob der PCI-Steckplatz der
		Karte Bus Mastering unterst&uuml;tzt.  Auf einigen
		&auml;lteren Motherboards ist das nur f&uuml;r einen
		Steckplatz (meistens Steckplatz 0) der Fall.  Lesen Sie
		in der Dokumentation Ihrer Karte und Ihres Motherboards
		nach, ob das vielleicht die Ursache des Problems sein
		k&ouml;nnte.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question>
	      <para>Ich finde viele <errorname>device timeout</errorname>
		Meldungen in den Systemprotokollen und meine Karte
		funktioniert nicht.</para>
	    </question>

	    <answer>
	      <para>Je nach Karte k&ouml;nnen mal ein oder zwei
	        dieser Meldungen auftauchen.  Wenn sie aber immer wieder
		kommen und sich das Netz nicht benutzen l&auml;&szlig;t,
		pr&uuml;fen Sie das Netzkabel.  Stellen Sie zudem sicher,
		da&szlig; es keinen IRQ-Konflikt zwischen der Netzwerkkarte
		und anderen Ger&auml;ten Ihres Systems gibt.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question>
	      <para>Die Leistung der Karte ist schlecht.  Wie kann ich das
	        &auml;ndern?</para>
	    </question>

	    <answer>
	      <para>Das ist schwer zu beantworten, was genau verstehen Sie
	        unter <quote>Leistung</quote>?  &Uuml;berpr&uuml;fen Sie
		die Konfiguration und lesen Sie &man.tuning.7;.  Kaufen Sie
		auch keine billigen Netzwerkkarten.  Viele Benutzer
		berichten, da&szlig; die automatische Medienerkennung
		(<literal>autoselect</literal>) mit mancher Hardware
		zu Leistungseinbr&uuml;chen f&uuml;hrt.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question>
	      <para>Welche Karten soll ich einsetzen und welche
	        nicht?</para>
	    </question>

	    <answer>
	      <para>Setzen Sie keine billigen Karten ein.  Diese Karten
		benutzen oft fehlerhafte Chips&auml;tze und die meisten
		sind nicht sehr leistungsf&auml;hig.  Viele FreeBSD
		Anwender benutzen den &man.fxp.4; Chipsatz, das hei&szlig;t
		aber nicht, da&szlig; die anderen Chips&auml;tze schlecht
		sind.</para>
	    </answer>
	  </qandaentry>
	</qandaset>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Virtual Hosts</title>

    <indexterm><primary>virtual hosts</primary></indexterm>
    <indexterm><primary>IP Aliase</primary></indexterm>

    <para>Ein gebr&auml;uchlicher Zweck von FreeBSD ist das
      virtuelle Hosting, bei dem ein Server im Netzwerk wie
      mehrere Server aussieht.  Dies wird dadurch erreicht,
      da&szlig; einem Netzwerkinterface mehrere Netzwerk-Adressen
      zugewiesen werden.</para>

    <para>Ein Netzwerkinterface hat eine <quote>echte</quote>
      Adresse und kann beliebig viele <quote>alias</quote> Adressen
      haben.  Die Aliase werden durch entsprechende alias Eintr&auml;ge
      in <filename>/etc/rc.conf</filename> festgelegt.</para>

    <para>Ein alias Eintrag f&uuml;r das Interface 
      <devicename>fxp0</devicename> sieht wie folgt aus:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Beachten Sie, da&szlig; die alias Eintr&auml;ge mit alias0
      anfangen m&uuml;ssen und dann weiter hochgez&auml;hlt werden,
      das hei&szlig;t _alias1, _alias2, usw.
      Die Konfiguration der Aliase h&ouml;rt bei der ersten
      fehlenden Zahl auf.</para>

    <para>Die Berechnung der Alias-Netzwerkmasken ist wichtig, doch
      zum Gl&uuml;ck einfach.  F&uuml;r jedes Interface mu&szlig; es
      eine Adresse geben, die die Netzwerkmaske des Netzwerkes richtig
      beschreibt.  Alle anderen Adressen in diesem Netzwerk haben dann
      eine Netzwerkmaske, die mit 1 gef&uuml;llt ist.</para>

    <para>Als Beispiel betrachten wir den Fall, in dem
      <devicename>fxp0</devicename> mit zwei Netzwerken verbunden
      ist: dem Netzwerk <hostid role="ipaddr">10.1.1.0</hostid> mit der
      Netzwerkmaske <hostid role="netmask">255.255.255.0</hostid>
      und dem Netzwerk <hostid role="ipaddr">202.0.75.16</hostid> mit der
      Netzwerkmaske <hostid role="netmask">255.255.255.240</hostid>.
      Das System soll die Adressen <hostid role="ipaddr">10.1.1.1</hostid>
      bis <hostid role="ipaddr">10.1.1.5</hostid> und
      <hostid role="ipaddr">202.0.75.17</hostid> bis
      <hostid role="ipaddr">202.0.75.20</hostid> belegen.</para>

    <para>Die folgenden Eintr&auml;ge konfigurieren den Adapter
      entsprechend dem Beispiel:</para>

<programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Konfigurationsdateien</title>

    <sect2>
      <title><filename>/etc</filename> Layout</title>
      <para>Konfigurationsdateien finden sich in einigen Verzeichnissen
	unter anderem in:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>Enth&auml;lt generelle Konfigurationsinformationen,
		die Daten hier sind systemspezifisch.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>Default Versionen der Konfigurationsdateien.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>Enth&auml;lt die &man.sendmail.8; Konfiguration
		und weitere MTA Konfigurationsdateien.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>Hier findet sich die Konfiguration f&uuml;r
		die User- und Kernel-ppp Programme.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>Das Vorgabeverzeichnis, in dem Daten von
		&man.named.8; gehalten werden.  Normalerweise
		werden hier <filename>named.conf</filename> und Zonendaten
		abgelegt.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc</filename></entry> 
	      <entry>Installierte Anwendungen legen hier ihre
		Konfigurationsdateien ab.  Dieses Verzeichnis kann
		Unterverzeichnisse f&uuml;r bestimmte Anwendungen
		enthalten.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>Ort f&uuml;r Start- und Stopskripten installierter
		Anwendungen.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>Automatisch generierte systemspezifische Datenbanken,
	        wie die Paket-Datenbank oder die
		<command>locate</command>-Datenbank.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Hostnamen</title>

      <indexterm><primary>hostname</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm><primary><filename>resolv.conf</filename></primary></indexterm>

	<para>Wie der FreeBSD Resolver auf das Internet Domain Name
	  System (DNS) zugreift, wird in <filename>/etc/resolv.conf</filename>
	  festgelegt.</para>

	<para>Die gebr&auml;uchlichsten Eintr&auml;ge in
	  <filename>/etc/resolv.conf</filename> sind:</para>
      
	<informaltable frame="none">
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry> 
		<entry>Die IP-Adresse eines Nameservers, den
		  der Resolver abfragen soll.  Bis zu drei Server werden
		  in der Reihenfolge, in der sie aufgez&auml;hlt
		  sind, abgefragt.
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Suchliste mit Domain-Namen zum Aufl&ouml;sen von
		  Hostnamen.  Die Liste wird normalerweise durch den
		  Domain-Teil des lokalen Hostnamens festgelegt.
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Der lokale Domain-Name.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Beispiel f&uuml;r eine typische
	  <filename>resolv.conf</filename>:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note><para>Nur eine der Anweisungen <literal>search</literal>
	  oder <literal>domain</literal> sollte benutzt werden.</para></note>

	<para>Wenn Sie DHCP benutzen, &uuml;berschreibt &man.dhclient.8;
	  f&uuml;r gew&ouml;hnlich <filename>resolv.conf</filename>
	  mit den Informationen vom DHCP-Server.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>
	
	<para><filename>/etc/hosts</filename> ist eine einfache textbasierte
	  Datenbank, die aus alten Internetzeiten stammt.  Zusammen
	  mit DNS und NIS stellt sie eine Abbildung zwischen Namen und
	  IP-Adressen zur Verf&uuml;gung.  Anstatt &man.named.8;
	  zu konfigurieren, k&ouml;nnen hier lokale Rechner, die &uuml;ber
	  ein LAN verbunden sind, eingetragen werden.  Lokale Eintr&auml;ge
	  f&uuml;r gebr&auml;uchliche Internet-Adressen in
	  <filename>/etc/hosts</filename> verhindern die Abfrage eines
	  externen Servers und beschleunigen die Namensaufl&ouml;sung.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#</programlisting>

	<para><filename>/etc/hosts</filename> hat ein einfaches Format:</para>
	<programlisting>[Internet Adresse] [Offizieller Hostname] [Alias1] [Alias2] ...</programlisting>

	<para>Zum Beispiel:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Weitere Informationen entnehmen Sie bitte &man.hosts.5;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Konfiguration von Logdateien</title>
     
      <indexterm><primary>Logdateien</primary></indexterm>
      
      <sect3>
	<title><filename>syslog.conf</filename></title>
	
	<indexterm><primary>syslog.conf</primary></indexterm>
	
	<para><filename>syslog.conf</filename> ist die Konfigurationsdatei
	  von &man.syslogd.8;.  Sie legt fest, welche
	  <application>syslog</application> Meldungen in welche
	  Logdateien geschrieben werden.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

	<para>Weitere Informationen enth&auml;lt &man.syslog.conf.5;.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>
	
	<para>Die Konfigurationsdatei f&uuml;r &man.newsyslog.8;, das
	  normalerweise von &man.cron.8; aufgerufen wird, ist
	  <filename>newsyslog.conf</filename>.  &man.newsyslog.8;
	  stellt fest, ob Logdateien archiviert oder verschoben
	  werden m&uuml;ssen.  So wird <filename>logfile</filename>
	  nach <filename>logfile.0</filename> geschoben und
	  <filename>logfile.0</filename> nach <filename>logfile.1</filename>
	  usw.  Zudem k&ouml;nnen Logdateien mit &man.gzip.1;
	  komprimiert werden.  Die Namen der Logdateien sind dann
	  <filename>logfile.0.gz</filename>, <filename>logfile.1.gz</filename>
	  usw.</para>

	<para><filename>newsyslog.conf</filename> legt fest, welche
	  Logdateien bearbeitet werden, wie viele Dateien behalten werden
	  und wann die Dateien angefa&szlig;t werden.  Logdateien
	  k&ouml;nnen auf Basis ihrer Gr&ouml;&szlig;e oder zu
	  einem gewissen Zeitpunkt archiviert bzw. umbenannt werden.</para>
	
	<programlisting># configuration file for newsyslog
# &dollar;FreeBSD&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

	<para>Um mehr zu erfahren, lesen Sie bitte &man.newsyslog.8;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> sieht &auml;hnlich
	wie <filename>rc.conf</filename> aus.  Werte werden in der
	Form <literal>Variable=Wert</literal> gesetzt.
	Die angegebenen Werte werden
	gesetzt, nachdem sich das System im Mehrbenutzer Modus befindet,
	das hei&szlig;t nicht alle Werte k&ouml;nnen in
	diesem Modus gesetzt werden.</para>

      <para>In der folgenden <filename>sysctl.conf</filename>  wird das
	Loggen von fatalen Signalen abgestellt und Linux Programmen
	wird klar gemacht, da&szlig; sie in Wirklichkeit unter
	FreeBSD laufen:</para>

      <programlisting>kern.logsigexit=0       # Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=FreeBSD
compat.linux.osrelease=4.3-STABLE</programlisting>

    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Einstellungen mit sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm><primary>Einstellungen mit sysctl</primary></indexterm>
    
    <para>Mit &man.sysctl.8; k&ouml;nnen Sie &Auml;nderungen an
      einem laufenden FreeBSD System vornehmen.  Unter anderem
      k&ouml;nnen Optionen des TCP/IP-Stacks oder des
      virtuellen Speichermanagements ver&auml;ndert werden.  Unter
      der Hand eines erfahrenen Systemadministrators kann dies
      die Systemperformance erheblich verbessern.  &Uuml;ber 500
      Variablen k&ouml;nnen mit &man.sysctl.8; gelesen und gesetzt
      werden.</para>
    
    <para>Der Hauptzweck von &man.sysctl.8; besteht darin, Systemeinstellungen
      zu lesen und zu ver&auml;ndern.</para>

    <para>Alle auslesbaren Variablen werden wie folgt angezeigt:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>
    
    <para>Sie k&ouml;nnen auch eine spezielle Variable, z.B.
      <varname>kern.maxproc</varname> lesen:</para>
    
    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Um eine Variable zu setzen, benutzen Sie die Syntax
      <replaceable>Variable</replaceable>=
      <replaceable>Wert</replaceable>:</para>
    
    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>Mit sysctl k&ouml;nnen Sie Strings, Zahlen oder
      Boolean-Werte setzen.  Bei Boolean-Werten setzen sie <literal>1</literal>
      f&uuml;r wahr und <literal>0</literal> f&uuml;r falsch.</para>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Tuning von Laufwerken</title>

    <sect2>
      <title>Sysctl Variablen</title>
      
      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>
     
	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>
	
	<para>Die Variable <varname>vfs.vmiodirenable</varname> besitzt
	  in der Voreinstellung den Wert 1.  Die Variable kann auf den Wert
	  0 (ausgeschaltet) oder 1 (angeschaltet) gesetzt werden.  Sie 
	  steuert, wie Verzeichnisse vom System zwischengespeichert
	  werden.  Die meisten Verzeichnisse sind klein und benutzen
	  nur ein einzelnes Fragment, typischerweise 1&nbsp;kB, im Dateisystem.
	  Im Buffer-Cache verbrauchen sie mit 512&nbsp;Bytes noch weniger
	  Platz.  In der Voreinstellung wird der Buffer-Cache nur
	  eine limitierte Anzahl Verzeichnisse zwischenspeichern, auch
	  wenn das System &uuml;ber sehr viel Speicher verf&uuml;gt.
	  Wenn Sie diese Variable aktivieren, kann der Buffer-Cache den
	  VM-Page-Cache benutzen, um Verzeichnisse zwischenzuspeichern.
	  Der ganze Speicher steht damit zum Zwischenspeichern von
	  Verzeichnissen zur Verf&uuml;gung.  Der Nachteil bei dieser
	  Vorgehensweise ist, da&szlig; zum Zwischenspeichern eines
	  Verzeichnisses mindestens eine physikalische Seite im Speicher,
	  die normalerweise 4&nbsp;kB gro&szlig; ist, anstelle von 512&nbsp;Bytes
	  gebraucht wird.  Wir empfehlen diese Option zu aktivieren,
	  wenn Sie Dienste zur Verf&uuml;gung stellen, die viele
	  Dateien manipulieren.  Beispiele f&uuml;r
	  solche Dienste sind Web-Caches, gro&szlig;e Mail-Systeme oder
	  Netnews.  Trotz des verschwendeten Speichers vermindert
	  das Aktivieren dieser Variable in aller Regel nicht die
	  Leistung des Systems, obwohl Sie das nachpr&uuml;fen sollten.</para>
      </sect3>
     
      <sect3>
	<title><varname>hw.ata.wc</varname></title>
      
	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>In FreeBSD&nbsp;4.3 wurde versucht, den IDE Schreib-Zwischenspeicher
	  abzustellen.  Obwohl dies die Bandbreite zum Schreiben auf
	  IDE-Platten verringerte, wurde es aus Gr&uuml;nden der
	  Datenkonsistenz als notwenig angesehen.  Der Kern des
	  Problems ist, da&szlig; IDE-Platten keine zuverl&auml;ssige
	  Aussage &uuml;ber das Ende eines Schreibvorgangs treffen.
	  Wenn der Schreib-Zwischenspeicher aktiviert ist, werden die Daten
	  nicht in der Reihenfolge ihres Eintreffens geschrieben.  Es kann
	  sogar passieren, da&szlig; das Schreiben mancher Bl&ouml;cke
	  im Fall von starker Plattenaktivit&auml;t auf unbefristete
	  Zeit verz&ouml;gert wird.  Ein Absturz oder Stromausfall
	  zu dieser Zeit kann die Dateisysteme erheblich besch&auml;digen.
	  Wir entschieden uns daher f&uuml;r die sichere Variante
	  und stellten den Schreib-Zwischenspeicher ab.  Leider war
	  damit auch ein gro&szlig;er Leistungsverlust verbunden, so
	  da&szlig; wir die Variable
	  nach dem Release wieder aktiviert haben.  Sie sollten den
	  Wert der Variable <varname>hw.ata.wc</varname> auf Ihrem
	  System &uuml;berpr&uuml;fen.  Wenn der Schreib-Zwischenspeicher
	  abgestellt ist, k&ouml;nnen Sie ihn aktivieren, indem Sie die
	  Variable auf den Wert 1 setzen.  Dies mu&szlig; zum Zeitpunkt
	  des Systemstarts im Boot-Loader geschehen.  Eine &Auml;nderung
	  der Variable, nachdem der Kernel gestartet ist, hat keine
	  Auswirkungen.</para>
	
	<para>Weitere Informationen finden Sie in &man.ata.4;.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>
      
      <para>Mit &man.tunefs.8; lassen sich Feineinstellungen an
	Dateisystemen vornehmen.  Das Programm hat verschiedene Optionen,
	von denen hier nur Soft Updates betrachtet werden.  Soft Updates
	werden wie folgt ein- und ausgeschaltet:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Ein eingeh&auml;ngtes Dateisystem kann nicht mit &man.tunefs.8;
	modifiziert werden.  Soft Updates werden am besten im Single-User
	Modus aktiviert, bevor Partitionen eingehangen sind.</para>

      <note><para>Ab FreeBSD&nbsp;4.5 k&ouml;nnen Sie Soft Updates mit der
        Option <literal>-U</literal> von &man.newfs.8; beim Anlegen der
	Dateisysteme aktivieren.</para></note>

      <para>Durch Einsatz eines Zwischenspeichers wird die Performance
	im Bereich der Metadaten, vorwiegend beim Anlegen und L&ouml;schen
	von Dateien, gesteigert.  Wir empfehlen, Soft Updates auf allen
	Dateisystemen zu aktivieren.  Allerdings sollten Sie sich &uuml;ber
	die zwei Nachteile von Soft Updates bewu&szlig;t sein:
	Erstens garantieren Soft Updates zwar die Konsistenz der Daten
	im Fall eines Absturzes, aber es kann leicht passieren, da&szlig;
	das Dateisystem &uuml;ber mehrere Sekunden oder gar eine Minute
	nicht synchronisiert wurde.  Im Fall eines Absturzes verlieren
	Sie mit Soft Updates unter Umst&auml;nden mehr Daten als ohne.
	Zweitens verz&ouml;gern Soft Updates die Freigabe von 
	Datenbl&ouml;cken.  Eine gr&ouml;&szlig;ere Aktualisierung
	eines fast vollen Dateisystems, wie dem Root-Dateisystem,
	z.B. w&auml;hrend eines <command>make installworld</command>,
	kann das Dateisystem vollaufen lassen.  Dadurch w&uuml;rde
	die Aktualisierung fehlschlagen.</para>
      
      <sect3>
	<title>Details &uuml;ber Soft Updates</title>

	<indexterm><primary>Soft Updates (Details)</primary></indexterm>

	<para>Es gibt zwei klassische Herangehensweisen, wie
	  man die Metadaten des Dateisystems (also Daten
	  &uuml;ber Dateien, wie inode Bereiche oder Verzeichniseintr&auml;ge)
	  aktualisiert auf die Platte zur&uuml;ckschreibt:</para>

	<para>Das historisch &uuml;bliche Verfahren waren synchrone
	  Updates der Metadaten, d. h. wenn eine &Auml;nderung an
	  einem Verzeichnis n&ouml;tig war, wurde anschlie&szlig;end
	  gewartet, bis diese &Auml;nderung tats&auml;chlich auf die
	  Platte zur&uuml;ckgeschrieben worden war.  Der
	  <emphasis>Inhalt</emphasis> der Dateien wurde im
	  <quote>Buffer Cache</quote> zwischengespeichert und
	  asynchron irgendwann sp&auml;ter auf die Platte geschrieben.
	  Der Vorteil dieser Implementierung ist, da&szlig; sie
	  sicher funktioniert.  Wenn w&auml;hrend eines Updates ein
	  Ausfall erfolgt, haben die Metadaten immer einen
	  konsistenten Zustand.  Eine Datei ist entweder komplett
	  angelegt oder gar nicht.  Wenn die Datenbl&ouml;cke einer
	  Datei im Fall eines Absturzes noch nicht den Weg aus dem
	  <quote>Buffer Cache</quote> auf die Platte gefunden haben,
	  kann &man.fsck.8; das Dateisystem reparieren, indem es die
	  Dateil&auml;nge einfach auf 0 setzt.  Au&szlig;erdem
	  ist die Implementierung einfach und &uuml;berschaubar.  Der
	  Nachteil ist, da&szlig; &Auml;nderungen der Metadaten sehr
	  langsam vor sich gehen.  Ein <command>rm -r</command>
	  beispielsweise fa&szlig;t alle Dateien eines Verzeichnisses
	  der Reihe nach an, aber jede dieser &Auml;nderungen am
	  Verzeichnis (L&ouml;schen einer Datei) wird einzeln synchron
	  auf die Platte geschrieben.  Gleiches beim Auspacken
	  gro&szlig;er Hierarchien (<command>tar -x</command>).</para>
	  
	<para>Der zweite Fall sind asynchrone Metadaten-Updates.  Das
	  ist z. B. der Standard bei Linux/ext2fs oder die Variante
	  <command>mount -o async</command> f&uuml;r *BSD UFS.  Man
	  schickt die Updates der Metadaten einfach auch noch
	  &uuml;ber den <quote>Buffer Cache</quote>, sie werden also
	  zwischen die Updates der normalen Daten eingeschoben.
	  Vorteil ist, da&szlig; man nun nicht mehr auf jeden Update
	  warten mu&szlig;, Operationen mit vielen
	  Metadaten&auml;nderungen werden also viel schneller.  Auch
	  hier ist die Implementierung sehr einfach und wenig
	  anf&auml;llig f&uuml;r Fehler.  Nachteil ist, da&szlig;
	  keinerlei Konsistenz des Dateisystems mehr gesichert ist.
	  Wenn mitten in einer Operation, die viele Metadaten
	  &auml;ndert, ein Ausfall erfolgt (Stromausfall, dr&uuml;cken
	  des Reset-Tasters), dann ist das Dateisystem
	  anschlie&szlig;end in einem unbestimmten Zustand.  Niemand
	  kann genau sagen, was noch geschrieben worden ist und was
	  nicht mehr; die Datenbl&ouml;cke einer Datei k&ouml;nnen
	  schon auf der Platte stehen, w&auml;hrend die inode Tabelle
	  oder das zugeh&ouml;rige Verzeichnis nicht mehr aktualisiert
	  worden ist.  Man kann praktisch kein <command>fsck</command>
	  mehr implementieren, das diesen Zustand
	  wieder reparieren kann, da die dazu n&ouml;tigen
	  Informationen einfach auf der Platte fehlen.  Wenn ein
	  Dateisystem derart besch&auml;digt worden ist, kann man es
	  nur neu erzeugen (&man.newfs.8;) und die Daten
	  vom Backup zur&uuml;ckspielen.
	  </para>

	<para>Der historische Ausweg aus diesem Dilemma war ein
	  <emphasis>dirty region logging</emphasis> (auch als
	  <emphasis>Journalling</emphasis> bezeichnet, wenngleich
	  dieser Begriff nicht immer gleich benutzt und manchmal auch
	  f&uuml;r andere Formen von Transaktionsprotokollen gebraucht
	  wird).  Man schreibt die Metadaten-Updates zwar synchron,
	  aber nur in einen kleinen Plattenbereich, die
	  <emphasis>logging area</emphasis>.  Von da aus werden sie
	  dann asynchron auf ihre eigentlichen Bereiche verteilt.  Da
	  die <emphasis>logging area</emphasis> ein kleines
	  zusammenh&auml;ngendes St&uuml;ckchen ist, haben die
	  Schreibk&ouml;pfe der Platte bei massiven Operationen auf
	  Metadaten keine allzu gro&szlig;en Wege zur&uuml;ckzulegen,
	  so da&szlig; alles ein ganzes St&uuml;ck schneller geht als
	  bei klassischen synchronen Updates.  Die Komplexit&auml;t
	  der Implementierung h&auml;lt sich ebenfalls in Grenzen,
	  somit auch die Anf&auml;lligkeit f&uuml;r Fehler.  Als
	  Nachteil ergibt sich, da&szlig; Metadaten zweimal auf die
	  Platte geschrieben werden m&uuml;ssen (einmal in die
	  <emphasis>logging area</emphasis>, einmal an die richtige
	  Stelle), so da&szlig; das im Falle regul&auml;rer
	  Arbeit (also keine geh&auml;uften Metadatenoperationen) eine
	  <quote>Pessimisierung</quote> des Falls der synchronen
	  Updates eintritt, es wird alles langsamer.  Daf&uuml;r hat man
	  als Vorteil, da&szlig; im Falle eines Crashes der
	  konsistente Zustand dadurch erzielbar ist, da&szlig; die
	  angefangenen Operationen aus dem <emphasis>dirty region
	  log</emphasis> entweder zu Ende ausgef&uuml;hrt oder
	  komplett verworfen werden, wodurch das Dateisystem schnell
	  wieder zur Verf&uuml;gung steht.</para>
	  
	<para>Die L&ouml;sung von Kirk McKusick, dem Sch&ouml;pfer von
	  Berkeley FFS, waren <emphasis>Soft Updates</emphasis>: die
	  notwendigen Updates der Metadaten werden im Speicher
	  gehalten und dann sortiert auf die Platte geschrieben
	  (<quote>ordered metadata updates</quote>).  Dadurch hat man
	  den Effekt, da&szlig; im Falle massiver
	  Metadaten-&Auml;nderungen sp&auml;tere Operationen die
	  vorhergehenden, noch nicht auf die Platte geschriebenen
	  Updates desselben Elements im Speicher
	  <quote>einholen</quote>.  Alle Operationen, auf ein
	  Verzeichnis beispielsweise, werden also in der Regel noch im
	  Speicher abgewickelt, bevor der Update &uuml;berhaupt auf
	  die Platte geschrieben wird (die dazugeh&ouml;rigen
	  Datenbl&ouml;cke werden nat&uuml;rlich auch so sortiert,
	  da&szlig; sie nicht vor ihren Metadaten auf der Platte
	  sind).  Im Fall eines Absturzes hat man ein implizites <quote>log
	    rewind</quote>: alle Operationen, die noch nicht den Weg auf
	  die Platte gefunden haben, sehen danach so aus, als
	  h&auml;tten sie nie stattgefunden.  Man hat so also den
	  konsistenten Zustand von ca. 30 bis 60&nbsp;Sekunden fr&uuml;her
	  sichergestellt.  Der verwendete Algorithmus garantiert
	  dabei, da&szlig; alle tats&auml;chlich benutzten Ressourcen
	  auch in den entsprechenden Bitmaps (Block- und inode
	  Tabellen) als belegt markiert sind.  Der einzige Fehler, der
	  auftreten kann, ist, da&szlig; Ressourcen noch als
	  <quote>belegt</quote> markiert sind, die tats&auml;chlich
	  <quote>frei</quote> sind.  &man.fsck.8; erkennt dies und
	  korrigiert diese nicht mehr belegten Ressourcen.  Die
	  Notwendigkeit eines Dateisystem-Checks darf aus diesem
	  Grunde auch ignoriert und das Dateisystem mittels
	  <command>mount -f</command> zwangsweise eingebunden werden.
	  Um noch allozierte Ressourcen freizugeben mu&szlig;
	  sp&auml;ter ein &man.fsck.8; nachgeholt werden.  Das ist
	  dann auch die Idee des <emphasis>background fsck</emphasis>:
	  beim Starten des Systems wird lediglich ein
	  <emphasis>Schnappschu&szlig;</emphasis> des Filesystems
	  gemacht, mit dem &man.fsck.8; dann sp&auml;ter arbeiten
	  kann.  Alle Dateisysteme d&uuml;rfen <quote>unsauber</quote>
	  eingebunden werden und das System kann sofort in den
	  Multiuser-Modus gehen.  Danach wird ein
	  Hintergrund-<command>fsck</command> f&uuml;r die
	  Dateisysteme gestartet, die dies ben&ouml;tigen, um
	  m&ouml;glicherweise irrt&uuml;mlich belegte Ressourcen
	  freizugeben.  (Dateisysteme ohne <emphasis>Soft
	  Updates</emphasis> ben&ouml;tigen nat&uuml;rlich immer noch
	  den &uuml;blichen (Vordergrund-)<command>fsck</command>,
	  bevor sie eingebunden werden k&ouml;nnen.)</para>

	<para>Der Vorteil ist, da&szlig; die Metadaten-Operationen
	  beinahe so schnell ablaufen wie im asynchronen Fall (also
	  durchaus auch schneller als beim <quote>logging</quote>, das
	  ja die Metadaten immer zweimal schreiben mu&szlig;).  Als
	  Nachteil stehen dem die Komplexit&auml;t des Codes (mit
	  einer erh&ouml;hten Fehlerwahrscheinlichkeit in einem
	  bez&uuml;glich Datenverlust hoch sensiblen Bereich) und ein
	  erh&ouml;hter Speicherverbrauch entgegen.  Au&szlig;erdem
	  mu&szlig; man sich an einige Eigenheiten
	  gew&ouml;hnen: Nach einem Absturz ist ein etwas &auml;lterer
	  Stand auf der Platte &mdash; statt einer leeren, aber bereits
	  angelegten Datei (wie nach einem herk&ouml;mmlichen
	  <command>fsck</command> Lauf) ist auf einem Dateisystem mit
	  <emphasis>Soft Updates</emphasis> keine Spur der
	  entsprechenden Datei mehr zu sehen, da weder die Metadaten
	  noch der Dateiinhalt je auf die Platte geschrieben wurden.
	  Weiterhin kann der Platz nach einem <command>rm -r</command>
	  nicht sofort wieder als verf&uuml;gbar markiert werden,
	  sondern erst dann, wenn der Update auch auf die Platte
	  vermittelt worden ist.  Dies kann besonders dann Probleme
	  bereiten, wenn gro&szlig;e Datenmengen in einem Dateisystem
	  ersetzt werden, das nicht gen&uuml;gend Platz hat, um alle
	  Dateien zweimal unterzubringen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Einstellungen von Kernel Limits</title>

    <indexterm><primary>Einstellungen von Kernel Limits</primary></indexterm>
    
    <sect2 id="file-process-limits">
      <title>Datei und Proze&szlig; Limits</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>
	
	<para>Abh&auml;ngig von den Anforderungen Ihres Systems
	  kann <varname>kern.maxfiles</varname> erh&ouml;ht oder
	  erniedrigt werden.  Die Variable legt die maximale
	  Anzahl von Dateideskriptoren auf Ihrem System fest.  Wenn
	  die Dateideskriptoren aufgebraucht sind, werden Sie
	  die Meldung <errorname>file: table is full</errorname>
	  wiederholt im Puffer f&uuml;r Systemmeldungen sehen.  Den
	  Inhalt des Puffers k&ouml;nnen Sie sich mit <command>dmesg</command>
	  anzeigen lassen.</para>

	<para>Jede offene Datei, jedes Socket und jede FIFO verbraucht
	  einen Dateideskriptor.  Auf <quote>dicken</quote> Produktionsservern
	  k&ouml;nnen leicht Tausende Dateideskriptoren ben&ouml;tigt
	  werden, abh&auml;ngig von der Art und Anzahl der gleichzeitig
	  laufenden Dienste.</para>

	<para>Die Voreinstellung von <varname>kern.maxfile</varname>
	  wird von <option>MAXUSERS</option> aus Ihrer Kernelkonfiguration
	  bestimmt.  <varname>kern.maxfiles</varname> w&auml;chst
	  proportional mit dem Wert von <option>MAXUSERS</option>.
	  Wenn Sie einen angepa&szlig;ten Kernel kompilieren, empfiehlt es sich
	  diese Option entsprechend der maximalen Benutzerzahl Ihres
	  Systems einzustellen.  Obwohl auf einer Produktionsmaschine
	  vielleicht nicht 256 Benutzer gleichzeitig angemeldet sind,
	  k&ouml;nnen die ben&ouml;tigten Ressourcen &auml;hnlich denen
	  eines gro&szlig;en Webservers sein.</para>

	<note><para>Ab FreeBSD&nbsp;4.5 k&ouml;nnen Sie <option>MAXUSERS</option>
	  in der Kernelkonfiguration auf <literal>0</literal> setzen.  Das
	  System setzt dann automatisch einen passenden Wert, der von der
	  Gr&ouml;&szlig;e Ihres Hauptspeichers abh&auml;ngt,
	  ein.</para></note>

      </sect3>
    </sect2>
    <sect2>
      <title>Netzwerk Limits</title>

      <para>Die Kerneloption <option>NMBCLUSTERS</option> schreibt
	die Anzahl der Netzwerkpuffer (MBUFs) fest, die das System besitzt.
	Eine zu geringe Anzahl MBUFs auf einem Server mit viel Netzwerkverkehr
	verringert die Leistung von FreeBSD.  Jeder MBUF Cluster nimmt
	ungef&auml;hr 2&nbsp;kB Speicher in Anspruch, so da&szlig; ein Wert
	von 1024 insgesamt 2&nbsp;Megabyte Speicher f&uuml;r Netzwerkpuffer
	im System reserviert.  Wieviele Cluster ben&ouml;tigt werden,
	l&auml;&szlig;t sich durch eine einfache Berechnung herausfinden.
	Wenn Sie einen Webserver besitzen, der maximal 1000 gleichzeitige
	Verbindungen servieren soll und jede der Verbindungen je einen
	16&nbsp;kB gro&szlig;en Puffer zum Senden und Empfangen braucht, brauchen
	Sie ungef&auml;hr 32&nbsp;MB Speicher f&uuml;r Netzwerkpuffer.  Als
	Daumenregel verdoppeln Sie diese Zahl, so da&szlig; sich
	f&uuml;r <varname>NMBCLUSTERS</varname> der Wert 
	2x32&nbsp;MB&nbsp;/&nbsp;2&nbsp;kB&nbsp;= 32768 ergibt.</para>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Hinzuf&uuml;gen von Swap-Bereichen</title>

    <para>Egal wie vorausschauend Sie planen, manchmal entspricht ein System
      einfach nicht Ihren Erwartungen.  Es ist leicht, mehr Swap-Bereiche
      hinzuzuf&uuml;gen.  Dazu stehen Ihnen drei Wege offen:  Sie
      k&ouml;nnen eine neue Platte einbauen, den Swap-Bereich &uuml;ber NFS
      ansprechen oder eine Swap-Datei auf einer existierenden Partition
      einrichten.</para>

    <sect2 id="new-drive-swap">
      <title>Swap auf einer neuen Festplatte</title>

      <para>Der einfachste Weg, zus&auml;tzlich einen Swap-Bereich
        einzurichten, ist der Einbau einer neuen Platte, da Sie ja immer
	eine neue Platte einbauen k&ouml;nnen.  Nachdem Sie das getan
	haben, lesen Sie bitte noch einmal den Abschnitt
	<ulink url="configtuning-initial.html#SWAP-DESIGN">Swap
	Partition</ulink> aus dem Kapitel <ulink
	  url="configtuning-initial.html">Vorbereitende Konfiguration</ulink>
	des Handbuchs.  Dort finden Sie Vorschl&auml;ge, wie Sie den
	Swap-Bereich am besten einrichten.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Swap-Bereiche &uuml;ber NFS</title>

      <para>Swap-Bereiche &uuml;ber NFS sollten Sie nur dann einsetzen, wenn
        Sie &uuml;ber keine lokale Platte verf&uuml;gen.  In FreeBSD
	Versionen vor 4.X ist dies zudem sehr langsam und nicht effizient.
	Ab FreeBSD&nbsp;4.0 ist das Nutzen von Swap &uuml;ber NFS gen&uuml;gend
	schnell und effizient, doch wird es durch die zur Verf&uuml;gung
	stehende Bandbreite limitiert und belastet zus&auml;tzlich den
	NFS-Server.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>Swap-Dateien</title>

      <para>Sie k&ouml;nnen eine Datei festgelegter Gr&ouml;&szlig;e als
        Swap-Bereich nutzen.  Im folgenden Beispiel werden wir eine 64&nbsp;MB
	gro&szlig;e Datei mit dem Namen <filename>/usr/swap0</filename>
	benutzen, Sie k&ouml;nnen nat&uuml;rlich einen beliebigen Namen
	f&uuml;r den Swap-Bereich benutzen.</para>

      <example>
	<title>Erstellen einer Swap-Datei</title>

        <orderedlist>
	  <listitem>
            <para>Zuerst stellen Sie bitte sicher, da&szlig; Ihr Kernel den
              vnode-Treiber enth&auml;lt.  In neueren Versionen von
	      <filename>GENERIC</filename> ist dieser
	      <emphasis>nicht</emphasis> enthalten.</para>

            <programlisting>pseudo-device   vn 1   #Vnode driver (turns a file into a device)</programlisting>
	  </listitem>

	  <listitem>
	    <para>Erstellen Sie das vn-Ger&auml;t:</para>
	    <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Legen Sie die Swap-Datei <filename>/usr/swap0</filename>
	      an:</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Setzen Sie die richtigen Berechtigungen f&uuml;r
	      <filename>/usr/swap0</filename>:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Aktivieren Sie die Swap-Datei in
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	  </listitem>

	  <listitem>
	    <para>Um die Swap-Datei zu aktivieren, f&uuml;hren Sie
	      entweder einen Reboot durch oder geben das folgende Kommando
	      ein:</para> 

            <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
	  </listitem>
        </orderedlist>
      </example>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
