<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/advanced-networking/chapter.sgml,v 1.160 2006/10/21 15:25:27 jkois Exp $
     basiert auf: 1.387
-->

<chapter id="advanced-networking">
  <chapterinfo>
    <authorgroup>
      <author>
	  <firstname>Johann</firstname>
	  <surname>Kois</surname>
	  <contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Weiterf&uuml;hrende Netzwerkthemen</title>

  <sect1 id="advanced-networking-synopsis">

    <title>&Uuml;bersicht</title>

    <para>Dieses Kapitel beschreibt verschiedene
      weiterf&uuml;hrende Netzwerkthemen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen von Gateways und Routen kennen.</para>
      </listitem>

      <listitem>
	<para>Bluetooth- sowie drahtlose, der Norm IEEE&nbsp;802.11
	  entsprechende, Ger&auml;te mit FreeBSD verwenden
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Eine Bridge unter FreeBSD einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Einen plattenlosen Rechner &uuml;ber das Netzwerk starten
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man NAT (Network Address Translation)
	  einrichtet.</para>
      </listitem>

      <listitem>
	<para>Zwei Computer &uuml;ber PLIP verbinden k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>IPv6 auf einem FreeBSD-Rechner einrichten
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>ATM einrichten k&ouml;nnen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen der <filename>/etc/rc</filename>-Skripte
	  verstanden haben.</para>
      </listitem>

      <listitem>
	<para>Mit der grundlegenden Netzwerkterminologie vertraut
	  sein.</para>
      </listitem>

      <listitem>
	<para>Einen neuen FreeBSD-Kernel konfigurieren und installieren
	  k&ouml;nnen (<xref linkend="kernelconfig">).</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man zus&auml;tzliche Softwarepakete von
	  Drittherstellern installiert (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="network-routing">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Coranth</firstname>
	  <surname>Gryphon</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Gateways und Routen</title>

    <indexterm>
      <primary>Routing</primary>
    </indexterm>
    <indexterm>
      <primary>Gateway</primary>
    </indexterm>
    <indexterm>
      <primary>Subnetz</primary>
    </indexterm>

    <para>Damit ein Rechner einen anderen &uuml;ber ein Netzwerk
      finden kann, muss ein Mechanismus vorhanden sein, der
      beschreibt, wie man von einem Rechner zum anderen gelangt.
      Dieser Vorgang wird als <firstterm>Routing</firstterm>
      bezeichnet.  Eine <quote>Route</quote> besteht aus einem
      definierten Adressenpaar: Einem <quote>Ziel</quote> und einem
      <quote>Gateway</quote>.  Dieses Paar zeigt an, dass Sie
      &uuml;ber das <emphasis>Gateway</emphasis> zum
      <emphasis>Ziel</emphasis> gelangen wollen.  Es gibt drei Arten
      von Zielen: Einzelne Rechner (Hosts), Subnetze und das
      <quote>Standard</quote>ziel.  Die <quote>Standardroute</quote>
      wird verwendet, wenn keine andere Route zutrifft.  Wir werden
      Standardrouten sp&auml;ter etwas genauer behandeln.
      Au&szlig;erdem gibt es drei Arten von Gateways: Einzelne Rechner
      (Hosts), Schnittstellen (Interfaces, auch als <quote>Links</quote>
      bezeichnet), sowie Ethernet Hardware-Adressen (MAC-Adressen).
    </para>

    <sect2>
      <title>Ein Beispiel</title>

      <para>Um die verschiedenen Aspekte des Routings zu
	veranschaulichen, verwenden wir folgende Ausgaben von
	<command>netstat</command>:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination               Gateway            Flags       Refs     Use     Netif Expire

default                   outside-gw         UGSc        37       418     ppp0
localhost                 localhost          UH          0        181     lo0
test0                     0:e0:b5:36:cf:4f   UHLW        5        63288   ed0    77
10.20.30.255              link#1             UHLW        1        2421
example.com               link#1             UC          0        0
host1                     0:e0:a8:37:8:1e    UHLW        3        4601    lo0
host2                     0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>
host2.example.com         link#1             UC          0        0
224                       link#1             UC          0        0
</screen>

      <indexterm>
	<primary>Defaultroute</primary>
      </indexterm>

      <para>Die ersten zwei Zeilen geben die Standardroute (die wir
	im <link linkend="network-routing-default"> n&auml;chsten
	Abschnitt</link> behandeln), sowie die
	<hostid>localhost</hostid> Route an.</para>

      <indexterm>
	<primary>Loopback-Ger&auml;t</primary>
      </indexterm>

      <para>Das in der Routingtabelle f&uuml;r
	<literal>localhost</literal> festgelegte Interface
	(<literal>Netif</literal>-Spalte)
	<devicename>lo0</devicename>, ist auch als loopback-Ger&auml;t
	(Pr&uuml;fschleife) bekannt.  Das hei&szlig;t, dass der ganze
	Datenverkehr f&uuml;r dieses Ziel intern (innerhalb des
	Ger&auml;tes) bleibt, anstatt ihn &uuml;ber ein Netzwerk (LAN)
	zu versenden, da das Ziel dem Start entspricht.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC-Adresse</secondary>
      </indexterm>

      <para>Der n&auml;chste auff&auml;llige Punkt sind die mit
	<hostid role="mac">0:e0:</hostid> beginnenden Adressen.  Es
	handelt sich dabei um Ethernet Hardwareadressen, die auch als
	MAC-Adressen bekannt sind.  FreeBSD identifiziert Rechner im
	lokalen Netz automatisch (im Beispiel <hostid>test0</hostid>)
	und f&uuml;gt eine direkte Route zu diesem Rechner hinzu.  Dies
	passiert &uuml;ber die Ethernet-Schnittstelle
	<devicename>ed0</devicename>.  Au&szlig;erdem existiert ein Timeout
	(in der Spalte <literal>Expire</literal>) f&uuml;r diese Art
	von Routen, der verwendet wird, wenn dieser Rechner in einem
	definierten Zeitraum nicht reagiert.  Wenn dies passiert, wird
	die Route zu diesem Rechner automatisch gel&ouml;scht.
	Rechner im lokalen Netz werden durch einen als RIP (Routing
	Information Protocol) bezeichneten Mechanismus identifiziert,
	der den k&uuml;rzesten Weg zu den jeweiligen Rechnern
	bestimmt.</para>

      <indexterm>
	<primary>Subnetz</primary>
      </indexterm>

      <para>FreeBSD f&uuml;gt au&szlig;erdem Subnetzrouten f&uuml;r das
	lokale Subnetz hinzu (<hostid
	role="ipaddr">10.20.30.255</hostid> ist die Broadcast-Adresse
	f&uuml;r das Subnetz <hostid role="ipaddr">10.20.30</hostid>,
	<hostid role="domainname">example.com</hostid> ist der zu
	diesem Subnetz geh&ouml;rige Domainname).  Das Ziel
	<literal>link#1</literal> bezieht sich auf die erste
	Ethernet-Karte im Rechner.  Sie k&ouml;nnen auch feststellen,
	dass keine zus&auml;tzlichen Schnittstellen angegeben
	sind.</para>

      <para>Routen f&uuml;r Rechner im lokalen Netz und lokale
	Subnetze werden automatisch durch den
	<application>routed</application> Daemon konfiguriert.  Ist
	dieser nicht gestartet, sind nur statisch definierte
	(explizit eingegebene) Routen vorhanden.</para>

      <para>Die Zeile <literal>host1</literal> bezieht sich auf
	unseren Rechner, der durch seine Ethernetadresse bekannt ist.
	Da unser Rechner der Sender ist, verwendet FreeBSD automatisch
	das Loopback-Ger&auml;t (<devicename>lo0</devicename>),
	anstatt den Datenverkehr &uuml;ber die Ethernetschnittstelle
	zu senden.</para>

      <para>Die zwei <literal>host2</literal> Zeilen sind ein Beispiel
	daf&uuml;r, was passiert, wenn wir ein &man.ifconfig.8; Alias
	verwenden (Lesen Sie dazu den Abschnitt &uuml;ber Ethernet,
	wenn Sie wissen wollen, warum wir das tun sollten.).  Das
	Symbol <literal>=&gt;</literal> (nach der
	<devicename>lo0</devicename>-Schnittstelle) sagt aus, dass wir
	nicht nur das Loopbackger&auml;t verwenden (da sich die
	Adresse auf den lokalen Rechner bezieht), sondern dass es sich
	zus&auml;tzlich auch um ein Alias handelt.  Solche Routen sind
	nur auf Rechnern vorhanden, die den Alias bereitstellen;
	alle anderen Rechner im lokalen Netz haben f&uuml;r solche
	Routen nur eine einfache <literal>link#1</literal>
	Zeile.</para>

      <para>Die letzte Zeile (Zielsubnetz <literal>224</literal>)
	behandelt das Multicasting, das wir in einem anderen Abschnitt
	besprechen werden.</para>

      <para>Schlie&szlig;lich gibt es f&uuml;r Routen noch
	verschiedene Attribute, die Sie in der Spalte
	<literal>Flags</literal> finden.  Nachfolgend finden Sie eine
	kurze &Uuml;bersicht von einigen dieser Flags und ihrer
	Bedeutung:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
          <colspec colwidth="1*">
          <colspec colwidth="4*">

	  <tbody>
	    <row>
	      <entry>U</entry>

	      <entry>Up: Die Route ist aktiv.</entry>
	    </row>

	    <row>
	      <entry>H</entry>

	      <entry>Host: Das Ziel der Route ist ein einzelner
		Rechner (Host).</entry>
	    </row>

	    <row>
	      <entry>G</entry>

	      <entry>Gateway: Alle Daten, die an dieses Ziel gesendet
		werden, werden von diesem System an ihr jeweiliges
		Ziel weitergeleitet.</entry>
	    </row>

	    <row>
	      <entry>S</entry>

	      <entry>Static: Diese Route wurde manuell konfiguriert,
		das hei&szlig;t sie wurde <emphasis>nicht</emphasis>
		automatisch vom System erzeugt.</entry>
	    </row>

	    <row>
	      <entry>C</entry>

	      <entry>Clone: Erzeugt eine neue Route, basierend auf der
		Route f&uuml;r den Rechner, mit dem wir uns verbinden.
		Diese Routenart wird normalerweise f&uuml;r lokale
		Netzwerke verwendet.</entry>
	    </row>

	    <row>
	      <entry>W</entry>

	      <entry>WasCloned: Eine Route, die automatisch
		konfiguriert wurde.  Sie basiert auf einer lokalen
		Netzwerkroute (Clone).</entry>
	    </row>

	    <row>
	      <entry>L</entry>

	      <entry>Link: Die Route beinhaltet einen Verweis auf eine
		Ethernetkarte (MAC-Adresse).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 id="network-routing-default">
      <title>Standardrouten</title>

      <indexterm>
	<primary>Defaultroute</primary>
      </indexterm>

      <indexterm>
	<primary>Standardroute</primary>
	<see>Defaultroute</see>
      </indexterm>

      <para>Wenn sich der lokale Rechner mit einem entfernten Rechner
	verbinden will, wird die Routingtabelle &uuml;berpr&uuml;ft,
	um festzustellen, ob bereits ein bekannter Pfad vorhanden ist.
	Geh&ouml;rt dieser entfernte Rechner zu einem Subnetz, dessen
	Pfad uns bereits bekannt ist
	(<foreignphrase>Cloned route</foreignphrase>), dann versucht der
	lokale Rechner &uuml;ber diese Schnittstelle eine Verbindung
	herzustellen.</para>

      <para>Wenn alle bekannten Pfade nicht funktionieren, hat der
	lokale Rechner eine letzte M&ouml;glichkeit: Die
	Standardroute (Defaultroute).  Bei dieser
	Route handelt es sich um eine spezielle Gateway-Route
	(gew&ouml;hnlich die einzige im System vorhandene), die im
	Flags-Feld immer mit <literal>C</literal> gekennzeichnet ist.
	F&uuml;r Rechner im lokalen Netzwerk ist dieses Gateway auf
	<emphasis>welcher Rechner auch immer eine Verbindung nach
	au&szlig;en hat</emphasis> gesetzt (entweder &uuml;ber eine
	PPP-Verbindung, DSL, ein Kabelmodem, T1 oder eine beliebige
	andere Netzwerkverbindung).</para>

      <para>Wenn Sie die Standardroute f&uuml;r einen Rechner
	konfigurieren, der selbst als Gateway zur Au&szlig;enwelt
	funktioniert, wird die Standardroute zum Gateway-Rechner Ihres
	Internetanbieter (ISP) gesetzt.</para>

      <para>Sehen wir uns ein Beispiel f&uuml;r Standardrouten an.  So
	sieht eine &uuml;bliche Konfiguration aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/net-routing">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
	  </literallayout>
	</textobject>
      </mediaobject>

      <para>Die Rechner <hostid>Local1</hostid> und
	<hostid>Local2</hostid> befinden sich auf Ihrer Seite.
	<hostid>Local1</hostid> ist mit einem ISP &uuml;ber eine
	PPP-Verbindung verbunden.  Dieser PPP-Server ist &uuml;ber ein
	lokales Netzwerk mit einem anderen Gateway-Rechner verbunden,
	der &uuml;ber eine Schnittstelle die Verbindung des ISP zum
	Internet herstellt.</para>

      <para>Die Standardrouten f&uuml;r Ihre Maschinen lauten:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Host</entry>

	      <entry>Standard Gateway</entry>

	      <entry>Schnittstelle</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>

	      <entry>Local1</entry>

	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>

	      <entry>T1-GW</entry>

	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Eine h&auml;ufig gestellte Frage lautet: <quote>Warum (oder
	wie) sollten wir <hostid>T1-GW</hostid> als Standard-Gateway
	f&uuml;r <hostid>Local1</hostid> setzen, statt den (direkt
	verbundenen) ISP-Server zu verwenden?</quote>.</para>

      <para>Bedenken Sie, dass die PPP-Schnittstelle f&uuml;r die
	Verbindung eine Adresse des lokalen Netzes des ISP verwendet.
	Daher werden Routen f&uuml;r alle anderen Rechner im lokalen
	Netz des ISP automatisch erzeugt.  Daraus folgt, dass Sie
	bereits wissen, wie Sie <hostid>T1-GW</hostid> erreichen
	k&ouml;nnen!  Es ist also unn&ouml;tig, einen Zwischenschritt
	&uuml;ber den ISP-Server zu machen.</para>

      <para>Es ist &uuml;blich, die Adresse <hostid
	role="ipaddr">X.X.X.1</hostid> als Gateway-Adresse f&uuml;r
	ihr lokales Netzwerk zu verwenden.  F&uuml;r unser Beispiel
	bedeutet dies Folgendes: Wenn Ihr lokaler Klasse-C-Adressraum
	<hostid role="ipaddr">10.20.30</hostid> ist und Ihr ISP
	<hostid role="ipaddr">10.9.9</hostid> verwendet, sehen die
	Standardrouten so aus:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Rechner (Host)</entry>

	      <entry>Standardroute</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>

	      <entry>Local1 (10.20.30.1)</entry>
	    </row>

	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>

	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Sie k&ouml;nnen die Standardroute ganz einfach in der Datei
	<filename>/etc/rc.conf</filename> festlegen.  In unserem
	Beispiel wurde auf dem Rechner <hostid>Local2</hostid>
	folgende Zeile in <filename>/etc/rc.conf</filename>
	eingef&uuml;gt:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>Die Standardroute kann &uuml;ber &man.route.8; auch direkt
	gesetzt werden:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>Weitere Informationen zum Bearbeiten von
	Netzwerkroutingtabellen finden Sie in &man.route.8;.</para>
    </sect2>

    <sect2>
      <title>Rechner mit zwei Heimatnetzen</title>

      <indexterm>
	<primary>Dual-Homed-Hosts</primary>
      </indexterm>

      <para>Es gibt noch eine Konfigurationsm&ouml;glichkeit, die wir
	besprechen sollten, und zwar Rechner, die sich in zwei
	Netzwerken befinden.  Technisch gesehen, z&auml;hlt jeder als
	Gateway arbeitende Rechner zu den Rechnern mit zwei
	Heimatnetzen (im obigen Beispiel unter Verwendung einer
	PPP-Verbindung).  In der Praxis meint man damit allerdings nur
	Rechner, die sich in zwei lokalen Netzen befinden.</para>

      <para>Entweder verf&uuml;gt der Rechner &uuml;ber zwei
	Ethernetkarten und jede dieser Karten hat eine Adresse in
	einem separaten Subnetz, oder der Rechner hat nur eine
	Ethernetkarte und verwendet &man.ifconfig.8; Aliasing.  Die
	erste M&ouml;glichkeit wird verwendet, wenn zwei physikalisch
	getrennte Ethernet-Netzwerke vorhanden sind, die zweite, wenn
	es nur ein physikalisches Ethernet-Netzwerk gibt, das aber aus
	zwei logisch getrennten Subnetzen besteht.</para>

      <para>In beiden F&auml;llen werden Routingtabellen erstellt,
	damit jedes Subnetz wei&szlig;, dass dieser Rechner als Gateway
	zum anderen Subnetz arbeitet (<foreignphrase>inbound
	route</foreignphrase>).  Diese Konfiguration (der
	Gateway-Rechner arbeitet als Router zwischen den Subnetzen) wird
	h&auml;ufig verwendet, wenn es darum geht, Paketfilterung oder
	eine Firewall (in eine oder beide Richtungen) zu implementieren.
      </para>

      <para>Soll dieser Rechner Pakete zwischen den beiden
	Schnittstellen weiterleiten, m&uuml;ssen Sie diese Funktion
	manuell konfigurieren und aktivieren.  Lesen Sie den
	n&auml;chsten Abschnitt, wenn Sie weitere Informationen zu
	diesem Thema ben&ouml;tigen.</para>
    </sect2>

    <sect2 id="network-dedicated-router">
      <title>Einen Router konfigurieren</title>

      <indexterm>
	<primary>Router</primary>
      </indexterm>

      <para>Ein Netzwerkrouter ist einfach ein System, das Pakete von
	einer Schnittstelle zur anderen weiterleitet.
	Internetstandards und gute Ingenieurspraxis sorgten
	daf&uuml;r, dass diese Funktion in FreeBSD in der Voreinstellung
	deaktiviert ist.  Sie k&ouml;nnen diese Funktion aktivieren,
	indem Sie in &man.rc.conf.5;  folgende &Auml;nderung
	durchf&uuml;hren:</para>

      <programlisting>gateway_enable=YES          # Auf YES setzen, wenn der Rechner als Gateway arbeiten soll</programlisting>

      <para>Diese Option setzt die &man.sysctl.8;-Variable
	<varname>net.inet.ip.forwarding</varname> auf
	<literal>1</literal>.  Wenn Sie das Routing kurzzeitig
	unterbrechen wollen, k&ouml;nnen Sie die Variable auf
	<literal>0</literal> setzen.</para>

      <indexterm><primary>BGP</primary></indexterm>
      <indexterm><primary>RIP</primary></indexterm>
      <indexterm><primary>OSPF</primary></indexterm>

      <para>Ihr neuer Router ben&ouml;tigt nun noch Routen, um zu
	wissen, wohin er den Verkehr senden soll.  Haben Sie ein
	(sehr) einfaches Netzwerk, k&ouml;nnen Sie statische Routen
	verwenden.  FreeBSD verf&uuml;gt &uuml;ber den Standard
	BSD-Routing-Daemon &man.routed.8;, der RIP (sowohl Version 1
	als auch Version 2) und IRDP versteht.  BGP&nbsp;v4,
	OSPF&nbsp;v2 und andere Protokolle werden von
	<filename role="package">net/zebra</filename>
	unterst&uuml;tzt.  Es stehen auch kommerzielle Produkte
	wie <application>gated</application> zur Verf&uuml;gung.</para>
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Al</firstname>
	    <surname>Hoang</surname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Statische Routen einrichten</title>

      <sect3>
	<title>Manuelle Konfiguration</title>

	<para>Nehmen wir an, dass wir &uuml;ber folgendes Netzwerk
	  verf&uuml;gen:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/static-routes">
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) Default Router to Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (FreeBSD gateway)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Internal Net 1      | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Internal Net 2
            </literallayout>
          </textobject>
        </mediaobject>

	<para><hostid>RouterA</hostid>, ein &os;-Rechner, dient als
	  Router f&uuml;r den Zugriff auf das Internet.  Die
	  Standardroute ist auf <hostid role="ipaddr">10.0.0.1</hostid>
	  gesetzt, damit ein Zugriff auf das Internet m&ouml;glich wird.
	  Wir nehmen nun an, dass <hostid>RouterB</hostid> bereits
	  konfiguriert ist und daher wei&szlig;, wie er andere Rechner
	  erreichen kann.  Dazu wird die Standardroute von
	  <hostid>RouterB</hostid> auf
	  <hostid role="ipaddr">192.168.1.1</hostid> gesetzt, da dieser
	  Rechner als Gateway fungiert.</para>

	<para>Sieht man sich die Routingtabelle f&uuml;r
	  <hostid>RouterA</hostid> an, erh&auml;lt man folgende Ausgabe:
	</para>

	<screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</screen>

	<para>Mit dieser Routingtabelle kann <hostid>RouterA</hostid>
	  unser internes Netz 2 nicht erreichen, da keine Route zum
	  Rechner <hostid role="ipaddr">192.168.2.0/24</hostid>
	  vorhanden ist.  Um dies zu korrigieren, kann die Route manuell
	  gesetzt werden.  Durch den folgenden Befehl wird das
	  interne Netz 2 in die Routingtabelle des Rechners
	  <hostid>RouterA</hostid> aufgenommen, indem
	  <hostid role="ipaddr">192.168.1.2</hostid> als n&auml;chster
	  Zwischenschritt verwenden wird:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Ab sofort kann <hostid>RouterA</hostid> alle Rechner des
	  Netzwerks <hostid role="ipaddr">192.168.2.0/24</hostid>
	  erreichen.</para>
      </sect3>

      <sect3>
	<title>Routen dauerhaft einrichten</title>

	<para>Das obige Beispiel ist f&uuml;r die Konfiguration einer
	  statischen Route auf einem laufenden System geeignet.  Diese
	  Information geht jedoch verloren, wenn der &os;-Rechner neu
	  gestartet werden muss.  Um dies zu verhindern, wird diese
	  Route in <filename>/etc/rc.conf</filename> eingetragen:</para>

	<programlisting># Add Internal Net 2 as a static route
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</programlisting>

	<para>Die Variable <literal>static_routes</literal> enth&auml;lt
	  eine Reihe von Strings, die durch Leerzeichen getrennt sind.
	  Jeder String bezieht sich auf den Namen einer Route.  In
	  unserem Beispiel hat <literal>static_routes</literal>
	  <replaceable>internalnet2</replaceable> als einzigen String.
	  Zus&auml;tzlich verwendet man die Konfigurationsvariable
	  <literal>route_<replaceable>internalnet2</replaceable></literal>,
	  in der alle sonstigen an &man.route.8; zu &uuml;bergebenden
	  Parameter festgelegt werden.  In obigen Beispiel h&auml;tte
	  man folgenden Befehl verwendet:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Daher wird
	  <literal>"-net 192.168.2.0/24 192.168.1.2"</literal> als
	  Parameter der Variable <literal>route_</literal> angegeben.
	</para>

	<para>Wie bereits erw&auml;hnt, k&ouml;nnen bei
	  <literal>static_routes</literal> auch mehrere Strings
	  angegeben werden.  Dadurch lassen sich mehrere statische
	  Routen anlegen.  Durch folgende Zeilen werden auf einem
	  imagin&auml;ren Rechner statische Routen zu den Netzwerken
	  <hostid role="ipaddr">192.168.0.0/24</hostid> sowie <hostid
	  role="ipaddr">192.168.1.0/24</hostid> definiert:</para>

	<programlisting>static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Verteilung von Routing-Informationen</title>

      <indexterm>
	<primary>routing propagation</primary>
      </indexterm>

      <para>Wir haben bereits dar&uuml;ber gesprochen, wie wir unsere
	Routen zur Au&szlig;enwelt definieren, aber nicht dar&uuml;ber,
	wie die Au&szlig;enwelt uns finden kann.</para>

      <para>Wir wissen bereits, dass Routing-Tabellen so erstellt
	werden k&ouml;nnen, dass s&auml;mtlicher Verkehr f&uuml;r
	einen bestimmten Adressraum (in unserem Beispiel ein
	Klasse-C-Subnetz) zu einem bestimmten Rechner in diesem
	Netzwerk gesendet wird, der die eingehenden Pakete im Subnetz
	verteilt.</para>

      <para>Wenn Sie einen Adressraum f&uuml;r Ihre Seite zugewiesen
	bekommen, richtet Ihr Diensteanbieter seine Routingtabellen so
	ein, dass der ganze Verkehr f&uuml;r Ihr Subnetz entlang Ihrer
	PPP-Verbindung zu Ihrer Seite gesendet wird.  Aber woher
	wissen die Seiten in der Au&szlig;enwelt, dass sie die Daten an
	Ihren ISP senden sollen?</para>

      <para>Es gibt ein System (&auml;hnlich dem verbreiteten DNS),
	das alle zugewiesenen Adressr&auml;ume verwaltet und ihre
	Verbindung zum Internet-Backbone definiert und dokumentiert.
	Der <quote>Backbone</quote> ist das Netz aus
	Hauptverbindungen, die den Internetverkehr in der ganzen Welt
	transportieren und verteilen.  Jeder Backbone-Rechner
	verf&uuml;gt &uuml;ber eine Kopie von Haupttabellen, die den
	Verkehr f&uuml;r ein bestimmtes Netzwerk hierarchisch vom
	Backbone &uuml;ber eine Kette von Diensteanbietern bis hin zu
	Ihrer Seite leiten.</para>

      <para>Es ist die Aufgabe Ihres Diensteanbieters, den
	Backbone-Seiten mitzuteilen, dass sie mit Ihrer Seite
	verbunden wurden.  Durch diese Mitteilung der Route ist nun
	auch der Weg zu Ihnen bekannt.  Dieser Vorgang wird als
	<emphasis>Bekanntmachung von Routen</emphasis>
	(<foreignphrase>routing propagation</foreignphrase>)
	bezeichnet.</para>
    </sect2>

    <sect2>
      <title>Problembehebung</title>

      <indexterm>
	<primary><command>traceroute</command></primary>
      </indexterm>

      <para>Manchmal kommt es zu Problemen bei der Bekanntmachung von
	Routen, und einige Seiten sind nicht in der Lage, Sie zu
	erreichen.  Vielleicht der n&uuml;tzlichste Befehl, um
	festzustellen, wo das Routing nicht funktioniert, ist
	&man.traceroute.8;.  Er ist au&szlig;erdem sehr n&uuml;tzlich,
	wenn Sie einen entfernten Rechner nicht erreichen k&ouml;nnen
	(lesen Sie dazu auch &man.ping.8;).</para>

      <para>&man.traceroute.8; wird mit dem zu erreichenden Rechner
	(Host) ausgef&uuml;hrt.  Angezeigt werden die Gateway-Rechner
	entlang des Verbindungspfades.  Schlie&szlig;lich wird der
	Zielrechner erreicht oder es kommt zu einem Verbindungsabbruch
	(beispielsweise durch Nichterreichbarkeit eines
	Gateway-Rechners).</para>

      <para>Weitere Informationen finden Sie in
	&man.traceroute.8;.</para>
    </sect2>

    <sect2>
      <title>Multicast-Routing</title>

      <indexterm>
	<primary>Multicast-Routing</primary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>MROUTING</secondary>
      </indexterm>

      <para>&os; unterst&uuml;tzt sowohl Multicast-Anwendungen als
	auch Multicast-Routing.  Multicast-Anwendungen m&uuml;ssen
	nicht konfiguriert werden, sie laufen einfach.
	Multicast-Routing muss in der Kernelkonfiguration aktiviert
	werden:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Zus&auml;tzlich muss &man.mrouted.8;, der
	Multicast-Routing-Daemon, &uuml;ber die Datei
	<filename>/etc/mrouted.conf</filename> eingerichtet werden,
	um Tunnel und <acronym>DVMRP</acronym> zu aktivieren.  Weitere
	Informationen zu diesem Thema finden Sie in
	&man.mrouted.8;.</para>
    </sect2>
  </sect1>

  <sect1 id="network-wireless">
    <title>Drahtlose Netzwerke</title>

    <para>Dieses Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      daher bitte <ulink
      url="&url.books.handbook.en;/network-wireless.html">
      das Original in englischer Sprache</ulink>.  Wenn Sie helfen
      wollen, dieses Kapitel fertig zu &uuml;bersetzen, senden Sie
      bitte eine E-Mail an die Mailingliste &a.de.translators;.</para>
  </sect1>

  <sect1 id="network-bluetooth">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Pav</firstname>
          <surname>Lucistnik</surname>
          <contrib>Beigetragen von </contrib>
          <affiliation>
            <address><email>pav@FreeBSD.org</email></address>
          </affiliation>
        </author>
      </authorgroup>
    </sect1info>

    <title>Bluetooth</title>

    <indexterm><primary>Bluetooth</primary></indexterm>

    <sect2>
      <title>&Uuml;bersicht</title>

      <para>Bluetooth erm&ouml;glicht die Bildung von pers&ouml;nlichen
	Netzwerken &uuml;ber drahtlose Verbindungen bei einer maximalen
	Reichweite von 10 Metern und operiert im unlizensierten
	2,4-GHz-Band.  Solche Netzwerke werden normalerweise spontan
	gebildet, wenn sich mobile Ger&auml;te, wie Mobiltelefone,
	Handhelds oder Notebooks miteinander verbinden.  Im Gegensatz zu
	Wireless LAN erm&ouml;glicht Bluetooth auch h&ouml;herwertige
	Dienste, wie FTP-&auml;hnliche Dateiserver, Filepushing,
	Sprach&uuml;bertragung, Emulation von seriellen Verbindungen
	und andere mehr.</para>

      <para>Der Bluetooth-Stack von &os; verwendet das
	Netgraph-Framework (&man.netgraph.4;).  Viele
	Bluetooth-USB-Adapter werden durch den &man.ng.ubt.4;-Treiber
	unterst&uuml;tzt.  Auf dem Chip BCM2033
	von Broadcom basierende	Bluetooth-Ger&auml;te werden von den
	Treibern &man.ubtbcmfw.4; sowie &man.ng.ubt.4; unterst&uuml;tzt.
	Die Bluetooth-PC-Card 3CRWB60-A von 3Com verwendet den
	&man.ng.bt3c.4;-Treiber.  Serielle sowie auf UART basierende
	Bluetooth-Ger&auml;te werden von &man.sio.4;, &man.ng.h4.4;
	sowie &man.hcseriald.8;	unterst&uuml;tzt.  Dieses Kapitel
	beschreibt die Verwendung von USB-Bluetooth-Adaptern.</para>
    </sect2>

    <sect2>
      <title>Die Bluetooth-Unterst&uuml;tzung aktivieren</title>

      <para>Bluetooth-Unterst&uuml;tzung ist in der Regel als
	Kernelmodul verf&uuml;gbar.  Damit ein Ger&auml;t funktioniert,
	muss der entsprechende Treiber im Kernel geladen werden:</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Ist das Bluetooth-Ger&auml;t beim Systemstart angeschlossen,
        kann das entsprechende Modul auch von
        <filename>/boot/loader.conf</filename> geladen werden:</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Schlie&szlig;en Sie Ihren USB-Adapter an, sollte eine
	Meldung &auml;hnlich der folgenden auf der Konsole (oder in
	syslog) erscheinen:</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <note>
	<para>Verwenden Sie &os; 6.0 oder eine 5.X-Version vor 5.5,
	  m&uuml;ssen Sie den Bluetooth-Stack manuell starten.  Ab
	  &os; 5.5 beziehungsweise 6.1 und neuer wird der Stack hingegen
	  automatisch von &man.devd.8; gestartet.</para>

      <para>Kopieren Sie
	<filename>/usr/share/examples/netgraph/bluetooth/rc.bluetooth</filename>
	nach <filename>/etc/rc.bluetooth</filename>.  &Uuml;ber dieses
	Skript wird der Bluetooth-Stack gestartet und beendet.  Es ist
	empfehlenswert, den Bluetooth-Stack zu beenden, bevor Sie den
	Adapter entfernen.  Selbst wenn Sie dies nicht tun, kommt es
	(normalerweise) zu keinem fatalen Fehler.  Wenn Sie den
	Bluetooth-Stack starten, erhalten Sie eine Meldung &auml;hnlich
	der folgenden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>
      </note>
    </sect2>

    <indexterm><primary>HCI</primary></indexterm>

    <sect2>
      <title>Das Host Controller Interface (HCI)</title>

      <para>Das <foreignphrase>Host Controller Interface</foreignphrase>
	(HCI) bietet eine Befehlsschnittstelle zum Basisbandcontroller
	und Linkmanager, sowie Zugriff auf den Hardwarestatus und die
	Kontrollregister.  Dadurch wird ein einheitlicher Zugriff auf
	die F&auml;higkeiten des Bluetooth-Basisbands m&ouml;glich.  Die
	HCI-Layer des Rechners tauschen Daten und Befehle mit der
	HCI-Firmware der Bluetooth-Ger&auml;te aus.  &Uuml;ber den
	Host Controller Transport Layer-Treiber (also den physikalischen
	Bus) k&ouml;nnen beide HCI-Layer miteinander
	kommunizieren.</para>

      <para>Eine einzelne Netgraph-Ger&auml;tedatei vom Typ
	<emphasis>hci</emphasis> wird f&uuml;r ein einzelnes
	Bluetooth-Ger&auml;t erzeugt.  Die HCI-Ger&auml;tedatei ist
	normalerweise mit der Bluetooth-Ger&auml;tetreiberdatei
	(downstream) sowie der L2CAP-Ger&auml;tedatei (upstream)
	verbunden.  Alle HCI-Operationen m&uuml;ssen &uuml;ber die
	HCI-Ger&auml;tedatei und nicht &uuml;ber die Treiberdatei
	erfolgen.  Der Standardname f&uuml;r die HCI-Ger&auml;tedatei
	(die in &man.ng.hci.4; beschrieben wird) lautet
	<quote>devicehci</quote>.</para>

      <para>Eine der wichtigsten Aufgaben ist das Auffinden von sich
	in Reichweite befindenden Bluetooth-Ger&auml;ten.  Diese
	Funktion wird als <emphasis>inquiry</emphasis> bezeichnet.
	Inquiry sowie andere mit HCI in Verbindung stehende Funktionen
	werden von &man.hccontrol.8; zur Verf&uuml;gung gestellt.  Das
	folgende Beispiel zeigt, wie man herausfindet, welche
	Bluetooth-Ger&auml;te sich in Reichweite befinden.  Eine solche
	Abfrage dauert nur wenige Sekunden.  Beachten Sie, dass ein
	Ger&auml;t nur dann antwortet, wenn es sich im Modus
	<emphasis>discoverable</emphasis> befindet.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para><literal>BD_ADDR</literal> stellt, &auml;hnlich der
	MAC-Adresse einer Netzkarte, die eindeutige Adresse eines
	Bluetooth-Ger&auml;tes dar.  Diese Adresse ist f&uuml;r die
	Kommunikation mit dem Ger&auml;t n&ouml;tig.  Es ist aber auch
	m&ouml;glich, BD_ADDR einen Klartextnamen zuzuweisen.  Die
	Datei <filename>/etc/bluetooth/hosts</filename> enth&auml;lt
	Informationen &uuml;ber die bekannten Bluetooth-Rechner.  Das
	folgende Beispiel zeigt, wie man den Klartextnamen eines
	entfernten Ger&auml;ts in Erfahrung bringen kann:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>Wenn Sie ein entferntes Bluetooth-Ger&auml;t abfragen, wird
	dieses Ihren Rechner unter dem Namen
	<quote>your.host.name (ubt0)</quote> finden.  Dieser Name kann
	aber jederzeit ge&auml;ndert werden.</para>

      <para>Bluetooth erm&ouml;glicht Punkt-zu-Punkt-Verbindungen (an
	denen nur zwei Bluetooth-Ger&auml;te beteiligt sind), aber auch
	Punkt-zu-Multipunkt-Verbindungen, bei denen eine Verbindung von
	mehreren Bluetooth-Ger&auml;ten gemeinsam genutzt wird.  Das
	folgende Beispiel zeigt, wie man die aktiven
	Basisbandverbindungen des lokalen Ger&auml;tes anzeigen kann:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>Ein <emphasis>connection handle</emphasis> ist f&uuml;r die
	Beendigung einer Basisbandverbindung n&uuml;tzlich.  Im
	Normalfall werden inaktive Verbindungen aber automatisch vom
	Bluetooth-Stack getrennt.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Rufen Sie <command>hccontrol help</command> auf, wenn Sie
	eine komplette Liste aller verf&uuml;gbaren HCI-Befehle
	ben&ouml;tigen.  Die meisten dieser Befehle m&uuml;ssen nicht
	als <username>root</username> ausgef&uuml;hrt werden.</para>
    </sect2>

    <indexterm><primary>L2CAP</primary></indexterm>

    <sect2>
      <title>Das Logical Link Control and Adaptation Protocol (L2CAP)</title>

      <para>Das <foreignphrase>Logical Link Control and Adaptation
	Protocol</foreignphrase> (L2CAP) bietet
	h&ouml;herwertigen Protokollen verbindungsorientierte und
	verbindungslose Datendienste an.  Dazu geh&ouml;ren auch
	Protokollmultiplexing, Segmentierung und Reassemblierung.
	L2CAP erlaubt h&ouml;herwertigen Protokollen und Programmen den
	Versand und Empfang von L2CAP-Datenpaketen mit einer L&auml;nge
	von bis zu 64 Kilobytes.</para>

      <para>L2CAP arbeitet <emphasis>kanal</emphasis>basiert.  Ein
	Kanal ist eine logische Verbindung innerhalb einer
	Basisbandverbindung.  Jeder Kanal ist dabei an ein einziges
	Protokoll gebunden.  Mehrere Ger&auml;te k&ouml;nnen an das
	gleiche Protokoll gebunden sein, es ist	aber nicht m&ouml;glich,
	einen Kanal an mehrere Protokolle zu binden.  Jedes &uuml;ber
	einen Kanal ankommende L2CAP-Paket wird an das entsprechende
	h&ouml;herwertige Protokoll weitergeleitet.  Mehrere Kan&auml;le
	k&ouml;nnen sich die gleiche Basisbandverbindung teilen.</para>

      <para>Eine einzelne Netgraph-Ger&auml;tedatei vom Typ
	<emphasis>l2cap</emphasis> wird f&uuml;r ein einzelnes
	Bluetooth-Ger&auml;t erzeugt.  Die L2CAP-Ger&auml;tedatei ist
	normalerweise mit der Bluetooth-HCI-Ger&auml;tedatei
	(downstream) sowie der Bluetooth-Socket-Ger&auml;tedatei
	(upstream) verbunden.  Der Standardname f&uuml;r die
	L2CAP-Ger&auml;tedatei, die in &man.ng.l2cap.4; beschrieben
	wird, lautet <quote>devicel2cap</quote>.</para>

      <para>Ein n&uuml;tzlicher Befehl zum Anpingen von anderen
	Ger&auml;ten ist &man.l2ping.8;.  Einige Bluetooth-Ger&auml;te
	senden allerdings nicht alle erhaltenen Daten zur&uuml;ck.  Die
	Ausgabe <literal>0 bytes</literal> ist also kein Fehler:</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>Das Programm &man.l2control.8; liefert Informationen
	&uuml;ber L2CAP-Dateien.  Das folgende Beispiel zeigt, wie man
	die Liste der logischen Verbindungen (Kan&auml;le) sowie die
	Liste der Basisbandverbindungen abfragen kann:</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

      <para>&man.btsockstat.1; ist ein weiteres Diagnoseprogramm.  Es
	funktioniert analog zu &man.netstat.1;, arbeitet aber mit
	Bluetooth-Datenstrukturen.  Das folgende Beispiel zeigt die
	gleiche Liste der logischen Verbindungen wie &man.l2control.8;
	im vorherigen Beispiel.</para>

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>

    </sect2>

    <sect2>
      <title>Das RFCOMM-Protokoll</title>

      <indexterm><primary>RFCOMM</primary></indexterm>

      <para>Das RFCOMM-Protokoll emuliert serielle Verbindungen
	&uuml;ber das L2CAP-Protokoll.  Es basiert auf dem ETSI-Standard
	TS 07.10.  Bei RFCOMM handelt es sich um ein einfaches
	Transportprotokoll, das um Funktionen zur Emulation der
	9poligen Schaltkreise von mit RS-232 (EIATIA-232-E) kompatiblen
	seriellen Ports erg&auml;nzt wurde.  RFCOMM erlaubt bis zu 60
	simultane Verbindungen (RFCOMM-Kan&auml;e) zwischen zwei
	Bluetooth-Ger&auml;ten.</para>

      <para>Eine RFCOMM-Kommunikation besteht aus zwei Anwendungen (den
	Kommunikationsendpunkten), die &uuml;ber das
	Kommunikationssegment miteinander verbunden sind.  RFCOMM
	unterst&uuml;tzt Anwendungen, die auf serielle Ports angewiesen
	sind.  Das Kommunikationssegment entspricht der (direkten)
	Bluetooth-Verbindung zwischen den beiden Ger&auml;ten.</para>

      <para>RFCOMM k&uuml;mmert sich um die direkte Verbindung von zwei
	Ger&auml;ten, oder um die Verbindung zwischen einem Ger&auml;t
	und einem Modem (Netzwerkverbindung).  RFCOMM unterst&uuml;tzt
	auch andere Konfigurationen.  Ein Beispiel daf&uuml;r sind
	Module, die drahtlose Bluetooth-Ger&auml;te mit einer
	verkabelten Schnittstelle verbinden k&ouml;nnen.</para>

      <para>Unter &os; wurde das RFCOMM-Protokoll im Bluetooth Socket-Layer
	implementiert.</para>
    </sect2>

    <indexterm><primary>Pairing</primary></indexterm>

    <sect2>
      <title>Erstmaliger Verbindungsaufbau zwischen zwei
	Bluetooth-Ger&auml;ten (<foreignphrase>Pairing</foreignphrase>)
      </title>

      <para>In der Voreinstellung nutzt Bluetooth keine
	Authentifizierung, daher kann sich jedes Bluetoothger&auml;t mit
	jedem anderen Ger&auml;t verbinden.  Ein Bluetoothger&auml;t
	(beispielsweise ein Mobiltelefon) kann jedoch f&uuml;r einen
	bestimmten Dienst (etwa eine Einw&auml;hlverbindung) eine
	Authentifizierung anfordern.  Bluetooth verwendet zu diesem
	Zweck <emphasis>PIN-Codes</emphasis>.  Ein PIN-Code ist ein
	maximal 16 Zeichen langer ASCII-String.  Damit eine Verbindung
	zustande kommt, muss auf beiden Ger&auml;ten der gleiche
	PIN-Code verwendet werden.  Nachdem der Code eingegeben wurde,
	erzeugen beide Ger&auml;te einen <emphasis>link key</emphasis>,
	der auf den Ger&auml;ten gespeichert wird.  Beim n&auml;chsten
	Verbindungsaufbau wird der zuvor erzeugte Link Key verwendet.
	Diesen Vorgang bezeichnet man als
	<foreignphrase>Pairing</foreignphrase>.  Geht der Link Key auf
	einem Ger&auml;t verloren, muss das Pairing wiederholt
	werden.</para>

      <para>Der &man.hcsecd.8;-Daemon verarbeitet alle
	Bluetooth-Authentifzierungsanforderungen und wird &uuml;ber die
	Datei <filename>/etc/bluetooth/hcsecd.conf</filename>
	konfiguriert.  Der folgende Ausschnitt dieser Datei zeigt die
	Konfiguration f&uuml;r ein Mobiltelefon, das den PIN-Code
	<quote>1234</quote> verwendet:</para>

      <programlisting>device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</programlisting>

      <para>Von der L&auml;nge abgesehen, unterliegen PIN-Codes keinen
	Einschr&auml;nkungen.  Einige Ger&auml;te, beispielsweise
	Bluetooth-Headsets, haben einen festen PIN-Code eingebaut.  Die
	Option <option>-d</option> sorgt daf&uuml;r, dass der
	&man.hcsecd.8;-Daemon im Vordergrund l&auml;uft.  Dadurch kann
	der Ablauf einfach verfolgt werden.  Stellen Sie das entfernte
	Ger&auml;t auf <foreignphrase>receive pairing</foreignphrase>
	und initiieren Sie die Bluetoothverbindung auf dem entfernten
	Ger&auml;t.  Sie erhalten die Meldung, dass Pairing akzeptiert
	wurde und der PIN-Code ben&ouml;tigt wird.  Geben Sie den
	gleichen PIN-Code ein, den Sie in
	<filename>hcsecd.conf</filename> festgelegt haben.  Ihr Computer
	und das entfernte Ger&auml;t sind nun miteinander verbunden.
	Alternativ k&ouml;nnen Sie das Pairing auch auf dem entfernten
	Ger&auml;t initiieren.</para>

      <para>Unter &os; 5.5, 6.1 und neuer k&ouml;nnen Sie
	<application>hcsecd</application> durch das Einf&uuml;gen der
	folgenden Zeile in <filename>/etc/rc.conf</filename>
	beim Systemstart automatisch aktivieren:</para>

      <programlisting>hcsecd_enable="YES"</programlisting>

      <para>Es folgt nun eine beispielhafte Ausgabe
	des <application>hcsecd</application>-Daemons:</para>

<programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>

    </sect2>

    <indexterm><primary>SDP</primary></indexterm>

    <sect2>
      <title>Das Service Discovery Protocol (SDP)</title>

      <para>Das <foreignphrase>Service Discovery Protocol</foreignphrase>
	(SDP) erlaubt es Clientanwendungen, von Serveranwendungen
	angebotene Dienste sowie deren Eigenschaften abzufragen.  Zu
	diesen Eigenschaften geh&ouml;ren die Art oder die Klasse der
	angebotenen Dienste sowie der Mechanismus oder das Protokoll,
	die zur Nutzung des Dienstes notwendig sind.</para>

      <para>SDP erm&ouml;glicht Verbindungen zwischen einem SDP-Server
	und einem SDP-Client.  Der Server enth&auml;lt eine Liste mit
	den Eigenschaften der vom Server angebotenen Dienste.  Jeder
	Eintrag beschreibt jeweils einen einzigen Serverdienst.  Ein
	Client kann diese Informationen durch eine SDP-Anforderung
	vom SDP-Server beziehen.  Wenn der Client oder eine Anwendung
	des Clients einen Dienst nutzen will, muss eine seperate
	Verbindung mit dem Dienstanbieter aufgebaut werden.  SDP bietet
	einen Mechanismus zum Auffinden von Diensten und deren
	Eigenschaften an, es bietet aber keine Mechanismen zur Verwendung
	dieser Dienste.</para>

      <para>Normalerweise sucht ein SDP-Client nur nach Diensten, die
	bestimmte geforderte Eigenschaften erf&uuml;llen.  Es ist aber
	auch m&ouml;glich, anhand der Dienstbeschreibungen eine
	allgemeine Suche nach den von einem Server angebotenen Diensten
	durchzuf&uuml;hren.  Diesen Vorgang bezeichnet man als
        <foreignphrase>Browsing</foreignphrase>.</para>

      <para>Der Bluetooth-SDP-Server &man.sdpd.8; und der
	Kommandozeilenclient &man.sdpcontrol.8; sind bereits in der
	Standardinstallation von &os; enthalten.  Das folgende Beispiel
	zeigt, wie eine SDP-Abfrage durchgef&uuml;hrt wird:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec browse</userinput>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</screen>

      <para>... und so weiter.  Beachten Sie, dass jeder Dienst eine
	Liste seiner Eigenschaften (etwa den RFCOMM-Kanal)
	zur&uuml;ckgibt.  Je nach dem, welche Dienste Sie
	ben&ouml;tigen, sollten Sie sich einige dieser Eigenschaften
	notieren.  Einige Bluetooth-Implementationen unterst&uuml;tzen
	kein <foreignphrase>Service Browsing</foreignphrase> und geben
	daher eine leere Liste zur&uuml;ck.  Ist dies der Fall, ist es
	dennoch m&ouml;glich, nach einem bestimmten Dienst zu suchen.
	Das folgende Beispiel demonstriert die Suche nach dem
	OBEX Object Push (OPUSH) Dienst:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</userinput></screen>

      <para>Unter &os; ist es die Aufgabe des &man.sdpd.8;-Servers,
	Bluetooth-Clients verschiedene Dienste anzubieten.  Unter
	&os; 5.5, 6.1 und neuer k&ouml;nnen Sie dazu die folgende
	Zeile in die Datei <filename>/etc/rc.conf</filename>
	einf&uuml;gen:</para>

      <programlisting>sdpd_enable="YES"</programlisting>

      <para>Nun kann der <application>sdpd</application>-Daemon durch
	folgene Eingabe gestartet werden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sdpd start</userinput></screen>

      <para>Unter &os; 6.0 und &os; 5.X-Versionen vor 5.5 ist
	<application>sdpd</application> nicht in die &os;-Startskripten
	integriert.  Daher m&uuml;ssen Sie den Damon durch folgende
	Eingabe manuell starten:</para>

      <screen>&prompt.root; <userinput>sdpd</userinput></screen>

      <para>Der lokale Server, der den entfernten Clients
	Bluetooth-Dienste anbieten soll, bindet diese Dienste an den
	lokalen SDP-Daemon.  Ein Beispiel f&uuml;r eine solche
	Anwendung ist &man.rfcomm.pppd.8;.  Einmal gestartet, wird der
	Bluetooth-LAN-Dienst an den lokalen SDP-Daemon gebunden.</para>

      <para>Die Liste der vorhandenen Dienste, die am lokalen SDP-Server
	registriert sind, l&auml;sst sich durch eine SDP-Abfrage
	&uuml;ber einen lokalen Kontrollkanal abfragen:</para>

      <screen>&prompt.root; <userinput>sdpcontrol -l browse</userinput></screen>

    </sect2>

    <sect2>
      <title>Einwahlverbindungen (Dial-Up Networking (DUN)) oder
	Netzwerkverbindungen mit PPP (LAN)-Profilen einrichten</title>

      <para>Das
	<foreignphrase>Dial-Up Networking (DUN)</foreignphrase>-Profil
	wird vor allem f&uuml;r Modems und Mobiltelefone verwendet.
	Dieses Profil erm&ouml;glicht folgende Szenarien:</para>

      <itemizedlist>
        <listitem><para>Die Verwendung eines Mobiltelefons oder eines
	  Modems durch einen Computer als drahtloses Modem, um sich
	  &uuml;ber einen Einwahlprovider mit dem Internet zu verbinden
	  oder andere Einwahldienste zu benutzen.</para>
	</listitem>

        <listitem><para>Die Verwendung eines Mobiltelefons oder eines
	  Modems durch einen Computers, um auf Datenabfragen zu
	  reagieren.</para>
	</listitem>
      </itemizedlist>

      <para>Der Zugriff auf ein Netzwerk &uuml;ber das PPP (LAN)-Profil
	kann in folgenden Situationen verwendet werden:</para>

      <itemizedlist>
        <listitem><para>Den LAN-Zugriff f&uuml;r ein einzelnes
	  Bluetooth-Ger&auml;t</para>
	</listitem>

        <listitem><para>Den LAN-Zugriff f&uuml;r mehrere
	  Bluetooth-Ger&auml;te</para>
	</listitem>

        <listitem><para>Eine PC-zu-PC-Verbindung (unter Verwendung
	  einer PPP-Verbindung &uuml;ber eine emulierte serielle
	  Verbindung)</para>
	</listitem>
      </itemizedlist>

      <para>Beide Profile werden unter &os; durch &man.ppp.8; sowie
	&man.rfcomm.pppd.8; implementiert - einem Wrapper, der
	RFCOMM Bluetooth-Verbindungen unter PPP nutzbar macht.  Bevor
	ein Profil verwendet werden kann, muss ein neuer PPP-Abschnitt
	in <filename>/etc/ppp/ppp.conf</filename> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	&man.rfcomm.pppd.8;.</para>

      <para>Im folgenden Beispiel verwenden wir &man.rfcomm.pppd.8;, um
	eine RFCOMM-Verbindung zu einem entfernten Ger&auml;t mit der
	<literal>BD_ADDR 00:80:37:29:19:a4</literal> auf dem
	RFCOMM-Kanal <literal>DUN</literal> aufzubauen.  Die aktuelle
	RFCOMM-Kanalnummer erhalten Sie vom entfernten Ger&auml;t
	&uuml;ber SDP.  Es ist auch m&ouml;glich, manuell einen
	RFCOMM-Kanal festzulegen.  In diesem Fall f&uuml;hrt
	&man.rfcomm.pppd.8; keine SDP-Abfrage durch.  Verwenden Sie
	&man.sdpcontrol.8;, um die RFCOMM-Kan&auml;le des entfernten
	Ger&auml;ts herauszufinden.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>Der &man.sdpd.8;-Server muss laufen, damit ein Netzzugriff
	mit dem PPP (LAN)-Profil m&ouml;glich ist.  Au&szlig;erdem muss
	f&uuml;r den LAN-Client ein neuer Eintrag in
	<filename>/etc/ppp/ppp.conf</filename> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	&man.rfcomm.pppd.8;.  Danach starten Sie den RFCOMM PPP-Server
	&uuml;ber eine g&uuml;ltige RFCOMM-Kanalnummer.  Der
	RFCOMM PPP-Server bindet dadurch den Bluetooth-LAN-Dienst an den
	lokalen SDP-Daemon.  Das folgende Beispiel zeigt Ihnen, wie man
	den RFCOMM PPP-Server startet.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>

    </sect2>

    <indexterm><primary>OBEX</primary></indexterm>

    <sect2>
      <title>Das Profil OBEX-Push (OPUSH)</title>

      <para>OBEX ist ein h&auml;ufig verwendetes Protokoll f&uuml;r den
	Dateitransfer zwischen Mobilger&auml;ten.  Sein Hauptzweck ist
	die Kommunikation &uuml;ber die Infrarotschnittstelle.  Es dient
	daher zum Datentransfer zwischen Notebooks oder PDAs sowie zum
	Austausch von Visitenkarten oder Kalendereintr&auml;gen zwischen
	Mobiltelefonen und anderen Ger&auml;ten mit PIM-Funktionen.</para>

      <para>Server und Client von OBEX werden durch das Softwarepaket
	<application>obexapp</application> bereitgestellt, das als Port
	<filename role="package">comms/obexapp</filename> verf&uuml;gbar
	ist.</para>

      <para>Mit dem OBEX-Client werden Objekte zum OBEX-Server geschickt
	oder angefordert.  Ein Objekt kann etwa eine Visitenkarte oder
	ein Termin sein.  Der OBEX-Client fordert &uuml;ber SDP die
	Nummer des RFCOMM-Kanals vom entfernten Ger&auml;t an.  Dies
	kann auch durch die Verwendung des Servicenamens anstelle der
	RFCOMM-Kanalnummer erfolgen.  Folgende Dienste werden
	unterst&uuml;tzt:  IrMC, FTRN und OPUSH.  Es ist m&ouml;glich,
	den RFCOMM-Kanal als Nummer anzugeben.  Es folgt nun ein
	Beispiel f&uuml;r eine OBEX-Sitzung, bei der ein
	Informationsobjekt vom Mobiltelefon angefordert und ein neues
	Objekt (hier eine Visitenkarte) an das Telefonbuch des
	Mobiltelefons geschickt wird:</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get telecom/devinfo.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>Um OBEX-Push-Dienste anbieten zu k&ouml;nnen, muss der
	<application>sdpd</application>-Server gestartet sein.  Ein
	Wurzelverzeichnis, in dem alle ankommenden Objekt gespeichert
	werden, muss zus&auml;tzlich angelegt werden.  In der
	Voreinstellung ist dies <filename>/var/spool/obex</filename>.
	Starten Sie den OBEX-Server mit einer g&uuml;ltigen Kanalnummer.
	Der OBEX-Server registriert nun den OBEX-Push-Dienst mit dem
	lokalen SDP-Daemon.  Um den OBEX-Server zu starten, geben Sie
	Folgendes ein:</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>

    </sect2>

    <sect2>
      <title>Das Profil Serial-Port (SPP)</title>

      <para>Durch dieses Profil k&ouml;nnen Bluetooth-Ger&auml;te RS232-
	(oder damit kompatible) serielle Kabelverbindungen emulieren.
	Anwendungen sind dadurch in der Lage, &uuml;ber eine virtuelle
	serielle Verbindung Bluetooth als Ersatz f&uuml;r eine
	Kabelverbindung zu nutzen.</para>

      <para>Das Profil Serial-Port wird durch &man.rfcomm.sppd.1;
	verwirklicht.  Pseudo-tty wird hier als virtuelle serielle
	Verbindung verwendet.  Das folgende Beispiel zeigt, wie man sich
	mit einem entfernten Serial-Port-Dienst verbindet.  Beachten
	Sie, dass Sie den RFCOMM-Kanal nicht angeben m&uuml;ssen, da
	&man.rfcomm.sppd.1; diesen &uuml;ber SDP vom entfernten
	Ger&auml;t abfragen kann.  Wenn Sie dies nicht wollen,
	k&ouml;nnen Sie einen RFCOMM-Kanal auch manuell festlegen.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Sobald die Verbindung hergestellt ist, kann pseudo-tty als
        serieller Port verwenden werden.</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>
    </sect2>

    <sect2>
      <title>Problembehandlung</title>

      <sect3>
        <title>Ein entferntes Ger&auml;t kann keine Verbindung
	  aufbauen</title>

	<para>Einige &auml;ltere Bluetooth-Ger&auml;te unterst&uuml;tzen
	  keinen Rollentausch.  Wenn &os; eine neue Verbindung
	  akzeptiert, wird versucht, die Rolle zu tauschen, um zum
	  Master zu werden.  Ger&auml;te, die dies nicht
	  unterst&uuml;tzen, k&ouml;nnen keine Verbindung aufbauen.
	  Beachten Sie, dass der Rollentausch ausgef&uuml;hrt wird,
	  sobald eine neue Verbindung aufgebaut wird, daher ist es
	  nicht m&ouml;glich, das entfernte Ger&auml;t zu fragen, ob es
	  den Rollentausch unterst&uuml;tzt.  Dieses Verhalten von &os;
	  kann aber durch eine HCI-Option ge&auml;ndert werden:</para>

        <screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>

      </sect3>

      <sect3>
        <title>Wo finde ich genaue Informationen dar&uuml;ber, was
	  schiefgelaufen ist?</title>

	<para>Verwenden Sie <application>hcidump</application>,
	  das Sie &uuml;ber den Port <filename
	  role="package">comms/hcidump</filename> installieren
	  k&ouml;nnen.  <application>hcidump</application> hat
	  &Auml;hnlichkeiten mit &man.tcpdump.1;.  Es dient zur Anzeige
	  der Bluetooth-Pakete in einem Terminal oder zur Speicherung
	  der Pakete in einer Datei (Dump).</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-bridging">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Steve</firstname>
	  <surname>Peterson</surname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>LAN-Kopplung mit einer Bridge</title>

    <sect2>
      <title>Einf&uuml;hrung</title>

      <indexterm><primary>Subnetz</primary></indexterm>
      <indexterm><primary>Bridge</primary></indexterm>

      <para>Manchmal ist es n&uuml;tzlich, ein physikalisches Netzwerk
	(wie ein Ethernetsegment) in zwei separate Netzwerke
	aufzuteilen, ohne gleich IP-Subnetze zu erzeugen, die &uuml;ber
	einen Router miteinander verbunden sind.  Ein Ger&auml;t, das
	zwei Netze auf diese Weise verbindet, wird als
	<emphasis>Bridge</emphasis> bezeichnet.  Jedes FreeBSD-System
	mit zwei Netzkarten kann als Bridge fungieren.</para>

      <para>Die Bridge arbeitet, indem sie die MAC Layeradressen
	(Ethernet Adressen) der Ger&auml;te in ihren Netzsegmenten
	lernt.  Der Verkehr wird nur dann zwischen zwei Netzsegmenten
	weitergeleitet, wenn sich Sender und Empf&auml;nger in
	verschiedenen Netzsegmenten befinden.</para>

      <para>In vielerlei Hinsicht entspricht eine Bridge daher einem
        Ethernet-Switch mit sehr wenigen Ports.</para>
    </sect2>

    <sect2>
      <title>Situationen, in denen <emphasis>Bridging</emphasis>
	angebracht ist</title>

      <para>Eine Bridge wird vor allem in folgenden zwei Situationen
	verwendet:</para>

      <sect3>
	<title>Hohes Datenaufkommen in einem Segment</title>

	<para>In der ersten Situation wird Ihr physisches Netz
	  mit Datenverkehr &uuml;berschwemmt.  Aus irgendwelchen
	  Gr&uuml;nden wollen Sie allerdings keine Subnetze verwenden,
	  die &uuml;ber einen Router miteinander verbunden sind.</para>

	<para>Stellen Sie sich einen Zeitungsverlag vor, in dem sich die
	  Redaktions- und Produktionsabteilungen in verschiedenen
	  Subnetzen befinden.  Die Redaktionsrechner verwenden den
	  Server <hostid>A</hostid> f&uuml;r Dateioperationen, und die
	  Produktionsrechner verwenden den Server <hostid>B</hostid>.
	  Alle Benutzer sind &uuml;ber ein gemeinsames Ethernet-LAN
	  miteinander verbunden.  Durch das hohe Datenaufkommen sinkt
	  die Geschwindigkeit des gesamten Netzwerks.</para>

	<para>W&uuml;rde man die Redaktionsrechner und die
	  Produktionsrechner in separate Netzsegmente auslagern,
	  k&ouml;nnte man diese beiden Segmente &uuml;ber eine Bridge
	  verbinden.  Nur der f&uuml;r Rechner im jeweils
	  <emphasis>anderen</emphasis> Segment bestimmte Verkehr wird
	  dann &uuml;ber die Brigde in das andere Netzsegment geleitet.
	  Dadurch verringert sich das Gesamtdatenaufkommen in beiden
	  Segmenten.</para>
      </sect3>

      <sect3>
	<title>Filtering/Traffic Shaping Firewall</title>

	<indexterm><primary>Firewall</primary></indexterm>
	<indexterm><primary>NAT</primary></indexterm>

	<para>Die zweite h&auml;ufig anzutreffende Situation tritt auf,
	  wenn Firewallfunktionen ben&ouml;tigt werden, ohne dass
	  <foreignphrase>Network Adress Translation</foreignphrase>
	  (NAT) verwendet wird.</para>

	<para>Ein Beispiel daf&uuml;r w&auml;re ein kleines Unternehmen,
	  das &uuml;ber DSL oder ISDN an seinen ISP angebunden ist.  Es
	  verf&uuml;gt &uuml;ber 13 weltweit erreichbare IP-Adressen,
	  sein Netzwerk besteht aus 10 Rechnern.  In dieser Situation
	  ist die Verwendung von Subnetzen sowie einer routerbasierten
	  Firewall schwierig.</para>

	<indexterm><primary>Router</primary></indexterm>
	<indexterm><primary>DSL</primary></indexterm>
	<indexterm><primary>ISDN</primary></indexterm>

	<para>Eine brigdebasierte Firewall kann konfiguriert und in den
	  ISDN/DSL-Downstreampfad ihres Routers eingebunden werden, ohne
	  sich um IP-Adressen k&uuml;mmern zu m&uuml;ssen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Die LAN-Kopplung konfigurieren</title>

      <sect3>
	<title>Auswahl der Netzkarten</title>

	<para>Eine Bridge ben&ouml;tigt mindestens zwei Netzkarten.
	  Leider sind unter FreeBSD nicht alle verf&uuml;gbaren
	  Netzkarten daf&uuml;r geeignet.  Lesen Sie &man.bridge.4;
	  f&uuml;r Informationen zu unterst&uuml;tzten Karten.</para>

	<para>Installieren und testen Sie beide Netzkarten, bevor Sie
	  fortfahren.</para>
      </sect3>

      <sect3>
	<title>Anpassen der Kernelkonfiguration</title>

	<indexterm>
	  <primary>Kerneloptionen</primary>
	  <secondary>BRIDGE</secondary>
	</indexterm>

	<para>Um die Kernelunterst&uuml;tzung f&uuml;r die LAN-Kopplung
	  zu aktivieren, f&uuml;gen Sie</para>

	<programlisting>options BRIDGE</programlisting>

	<para>in Ihre Kernelkonfigurationsdatei ein, und erzeugen einen
	  neuen Kernel.</para>
      </sect3>

      <sect3>
	<title>Firewallunterst&uuml;tzung</title>

	<indexterm><primary>Firewall</primary></indexterm>

	<para>Wenn Sie die Bridge als Firewall verwenden wollen,
	  m&uuml;ssen Sie zus&auml;tzlich die Option
	  <literal>IPFIREWALL</literal> einf&uuml;gen.  Die
	  Konfiguration einer Firewall wird in
	  <xref linkend="firewalls"> des Handbuchs beschrieben.</para>

	<para>Wenn Sie Nicht-IP-Pakete (wie ARP-Pakete) durch Ihre
	  Bridge leiten wollen, haben Sie drei M&ouml;glichkeiten.
	  Eine M&ouml;gleichkeit w&auml;re es, die folgende Option
	  in Ihre Kernelkonfigurationsdatei aufzunehmen und den
	  Kernel neu zu bauen:</para>

	<programlisting>option IPFIREWALL_DEFAULT_TO_ACCEPT</programlisting>

	<para>Alternativ k&ouml;nnen Sie den Firewall-Typ in der Datei
	  <filename>rc.conf</filename> auf "open" setzen:</para>

	<programlisting>firewall_type="open"</programlisting>

	<para>Beachten Sie aber, dass Ihre Firewall durch diese Optionen
	  per Voreinstellung alle Pakete und Verbindungen akzeptiert!
	  Der Einsatz dieser Optionen erfordert also umfangreiche
	  Anpassungen Ihrer Firewallregeln.</para>

	<para>Die dritte M&ouml;glichkeit ist der Einsatz der folgenden
	  &man.ipfw.8;-Regel:</para>

	<screen>&prompt.root; <userinput>ipfw add allow mac-type arp layer2</userinput></screen>

	<para>Diese Regel k&ouml;nnen Sie auch in Ihren bereits
	  existierenden Regelsatz aufnehmen.  Da diese Regel
	  &man.arp.8;-Pakete durchlassen soll, muss Sie am Beginn
	  Ihrer Firewallregeln platziert werden.</para>
      </sect3>

      <sect3>
	<title>Unterst&uuml;tzung f&uuml;r Traffic Shaping</title>

	<para>Wenn Sie die Bridge als Traffic-Shaper verwenden wollen,
	  m&uuml;ssen Sie die Option <literal>DUMMYNET</literal> in
	  Ihre Kernelkonfigurationsdatei einf&uuml;gen.  Lesen Sie
	  &man.dummynet.4;, um weitere Informationen zu erhalten.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Die LAN-Kopplung aktivieren</title>

      <para>F&uuml;gen Sie die Zeile</para>

      <programlisting>net.link.ether.bridge.enable=1</programlisting>

      <para>in <filename>/etc/sysctl.conf</filename> ein, um die Bridge
        zur Laufzeit zu aktivieren, sowie die Zeile</para>

      <programlisting>net.link.ether.bridge.config=<replaceable>if1</replaceable>,<replaceable>if2</replaceable></programlisting>

      <para>um die LAN-Kopplung f&uuml;r die festgelegten Ger&auml;te
	zu erm&ouml;glichen (ersetzen Sie dazu
	<replaceable>if1</replaceable> und
	<replaceable>if2</replaceable> durch die Namen Ihrer
	Netzkarten).  Wenn Sie die Datenpakete via &man.ipfw.8; filtern
	wollen, sollten Sie zus&auml;tzlich folgende Zeile
	einf&uuml;gen:</para>

      <programlisting>net.link.ether.bridge.ipfw=1</programlisting>

      <para>Vor &os;&nbsp;5.2-RELEASE verwenden Sie die
	folgenden Zeilen:</para>

      <programlisting>net.link.ether.bridge=1
net.link.ether.bridge_cfg=<replaceable>if1</replaceable>,<replaceable>if2</replaceable>
net.link.ether.bridge_ipfw=1</programlisting>
    </sect2>

    <sect2>
      <title>Sonstige Informationen</title>

      <para>Wenn Sie via &man.ssh.1; auf die Bridge zugreifen wollen,
	k&ouml;nnen Sie einer der Netzkarten eine IP-Adresse zuzuweisen.
	Es besteht Einigkeit dar&uuml;ber, dass es eine schlechte Idee
	ist, beiden Karten eine IP-Adresse zuzuweisen.
      </para>

      <para>Wenn Sie verschiedene Bridges in Ihrem Netzwerk haben, kann
	es dennoch nicht mehr als einen Weg zwischen zwei
	Arbeitspl&auml;tzen geben.  Das hei&szlig;t,
	<foreignphrase>Spanning tree link Management</foreignphrase>
	wird nicht unterst&uuml;tzt.</para>

      <para>Eine Bridge kann, besonders f&uuml;r Verkehr &uuml;ber
	Segmente, die Laufzeiten von Paketen erh&ouml;hen.</para>
    </sect2>
  </sect1>

  <sect1 id="network-diskless">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Jean-Fran&ccedil;ois</firstname>
          <surname>Dock&egrave;s</surname>
          <contrib>Aktualisiert von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
	<author>
	  <firstname>Alex</firstname>
	  <surname>Dupre</surname>
	  <contrib>Reorganisiert und erweitert von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Start und Betrieb von FreeBSD &uuml;ber ein Netzwerk</title>

    <indexterm>
      <primary>plattenloser Arbeitsplatz</primary>
    </indexterm>
    <indexterm>
      <primary>plattenloser Betrieb</primary>
    </indexterm>

    <para>FreeBSD kann &uuml;ber ein Netzwerk starten und arbeiten, ohne
      eine lokale Festplatte zu verwenden, indem es Dateisysteme eines
      <acronym>NFS</acronym>-Servers in den eigenen Verzeichnisbaum
      einh&auml;ngt.  Dazu sind, von den Standardkonfigurationsdateien
      abgesehen, keine System&auml;nderungen n&ouml;tig.  Ein solches
      System kann leicht installiert werden, da alle notwendigen
      Elemente bereits vorhanden sind:</para>

    <itemizedlist>
      <listitem>
        <para>Es gibt mindestens zwei M&ouml;glichkeiten, den Kernel
          &uuml;ber das Netzwerk zu laden:</para>

        <itemizedlist>
          <listitem>
	    <para><acronym>PXE</acronym>: Das
              <quote>Preboot eXecution Environment System</quote> von
	      &intel; ist eine Art intelligentes Boot-ROM, das in
	      einigen Netzkarten oder Hauptplatinen verwendet wird.
	      Weitere Informationen finden Sie in &man.pxeboot.8;.
	    </para>
          </listitem>

          <listitem>
            <para>Der Port
	      <application>Etherboot</application>
	      (<filename role="package">net/etherboot</filename>)
	      erzeugt ROM-f&auml;higen Code, um einen Kernel &uuml;ber
	      das Netzwerk zu laden.  Dieser Code kann entweder auf ein
              Boot-PROM einer Netzkarte gebrannt werden, was von vielen
              Netzkarten unterst&uuml;tzt wird.  Oder er kann von einer
              lokalen Diskette, Festplatte oder von einem laufenden
              &ms-dos;-System geladen werden.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Das Beispielskript
	  <filename>/usr/share/examples/diskless/clone_root</filename>
	  erleichtert die Erzeugung und die Wartung des
	  root-Dateisystems auf dem Server.  Das Skript muss
	  wahrscheinlich angepasst werden, dennoch werden Sie schnell zu
	  einem Ergebnis kommen.</para>
      </listitem>

      <listitem>
        <para>Die Startdateien, die einen plattenlosen Systemstart
          erkennen und unterst&uuml;tzen, sind nach der Installation
          in <filename>/etc</filename> vorhanden.</para>
      </listitem>

      <listitem>
	<para>Dateiauslagerungen k&ouml;nnen sowohl via
	  <acronym>NFS</acronym> als auch auf die lokale Platte
	  erfolgen.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt verschiedene Wege, einen plattenlosen Rechner
      einzurichten.  Viele Elemente sind daran beteiligt, die fast
      immer an den pers&ouml;nlichen Geschmack angepasst werden
      k&ouml;nnen.  Im folgenden Abschnitt wird die Installation
      eines kompletten Systems beschrieben, wobei der
      Schwerpunkt auf Einfachheit und Kompatibilit&auml;t zu den
      Standardstartskripten von FreeBSD liegt.  Das beschriebene
      System hat folgende Eigenschaften:</para>

    <itemizedlist>
      <listitem>
        <para>Die plattenlosen Rechner haben ein gemeinsames
          <filename>/</filename>- sowie ein gemeinsames
          <filename>/usr</filename>-Dateisystem, die jeweils
          schreibgesch&uuml;tzt sind.</para>

        <para>Das root-Dateisystem ist eine Kopie
          eines Standardwurzelverzeichnisses von FreeBSD
          (&uuml;blicherweise das des Servers), bei dem einige
          Konfigurationsdateien durch f&uuml;r den plattenlosen
          Betrieb geeignete Versionen ersetzt wurden.</para>

        <para>F&uuml;r die Bereiche des root-Dateisystems, die
          beschreibbar sein m&uuml;ssen, werden mit &man.md.4;
          virtuelle Dateisysteme erzeugt.  Dies bedeutet aber auch, dass
          alle Ver&auml;nderungen verloren gehen, wenn das System neu
          gestartet wird.</para>
      </listitem>

      <listitem>
	<para>Der Kernel wird, in Abh&auml;ngigkeit von der jeweiligen
	  Situation, entweder von <application>Etherboot</application>
	  oder von <acronym>PXE</acronym> transferiert und geladen.
	</para>
      </listitem>
    </itemizedlist>

    <caution><para>Das hier beschriebene System ist nicht sicher.  Es
      sollte nur in einem gesicherten Bereich eines Netzwerks verwendet
      werden und f&uuml;r andere Rechner nicht erreichbar sein.</para>
    </caution>

    <para>Alle Informationen in diesem Abschnitt wurden unter
      &os;&nbsp;5.2.1-RELEASE getestet.</para>

    <sect2>
      <title>Hintergrundinformationen</title>

      <para>Die Einrichtung von plattenlosen Rechnern ist einfach, aber
	auch fehleranf&auml;llig.  Der Grund daf&uuml;r sind auftretende
	Fehler, die sich oft nur schwer zuordnen lassen.  Unter anderem
	sind daf&uuml;r folgende Umst&auml;nde verantwortlich:</para>

      <itemizedlist>
	<listitem>
	  <para>Kompilierte Optionen haben zur Laufzeit unterschiedliche
	    Auswirkungen.</para>
	</listitem>

	<listitem>
	  <para>Fehlermeldungen sind oft kryptisch oder fehlen
	    vollst&auml;ndig.</para>
	</listitem>
      </itemizedlist>

      <para>Daher ist es n&uuml;tzlich, &uuml;ber die im Hintergrund
	ablaufenden Mechanismen Bescheid zu wissen.  Dadurch wird es
	einfacher, eventuell auftretende Fehler zu beheben.</para>

      <para>Verschiedene Operationen m&uuml;ssen ausgef&uuml;hrt werden,
	um ein System erfolgreich zu starten:</para>

      <itemizedlist>
	<listitem>
	  <para>Der Rechner ben&ouml;tigt einige Startparameter, wie
	    seine IP-Adresse, die Namen ausf&uuml;hrbarer Dateien, den
	    Servernamen sowie den root-Pfad.  F&uuml;r die
	    &Uuml;bermittlung dieser Informationen wird entweder das
	    <acronym>DHCP</acronym>- oder das BOOTP-Protokoll verwendet.
	    Bei <acronym>DHCP</acronym> handelt es sich um eine
	    abw&auml;rtskompatible Erweiterung von BOOTP, die die
	    gleichen Portnummern und das gleiche Paketformat verwendet.
	  </para>

	  <para>Es ist m&ouml;glich, das System so zu konfigurieren,
	    dass es nur BOOTP verwendet.  Das Serverprogramm
	    &man.bootpd.8; ist bereits im &os;-Basissystem enthalten.
	  </para>

	  <para><acronym>DHCP</acronym> hat im Vergleich zu BOOTP
	    allerdings mehrere Vorteile (bessere Konfigurationsdateien,
	    die M&ouml;glichkeit zur Verwendung von
	    <acronym>PXE</acronym>, sowie viele andere, die nicht in
	    direktem Zusammenhang mit dem plattenlosen Betrieb stehen).
	    Dieser Abschnitt beschreibt die Konfiguration mittels
	    <acronym>DHCP</acronym>.  Wenn m&ouml;glich, werden aber
	    entsprechende Beispiele f&uuml;r &man.bootpd.8;
	    angef&uuml;hrt.  Die Beispielkonfiguration nutzt das
	    Softwarepaket <application>ISC DHCP</application>.</para>
	</listitem>

	<listitem>
	  <para>Der Rechner muss ein oder mehrere Programme in den
	    lokalen Speicher laden.  Dazu wird entweder
	    <acronym>TFTP</acronym> oder <acronym>NFS</acronym>
	    verwendet.  Die Auswahl zwischen <acronym>TFTP</acronym> und
	    <acronym>NFS</acronym> erfolgt &uuml;ber das Setzen von
	    verschiedenen Kompilieroptionen.  Ein h&auml;ufig gemachter
	    Fehler ist es, Dateinamen f&uuml;r das falsche Protokoll
	    anzugeben:  <acronym>TFTP</acronym> transferiert
	    normalerweise alle Dateien aus einem einzigen Verzeichnis
	    des Servers, und erwartet einen Pfad relativ zu diesem
	    Verzeichnis.  <acronym>NFS</acronym> verlangt hingegen
	    absolute Dateipfade.</para>
	</listitem>

	<listitem>
	  <para>Die m&ouml;glichen Bootstrap-Programme und der Kernel
	    m&uuml;ssen initialisiert und ausgef&uuml;hrt werden.  Dabei
	    gibt es zwei M&ouml;glichkeiten:</para>

	  <itemizedlist>
	    <listitem>
	      <para><acronym>PXE</acronym> l&auml;dt &man.pxeboot.8;.
	        Dabei handelt es sich um eine modifizierte Version des
	        &os;-Laders der Boot-Phase drei.  Der &man.loader.8;
	        beschafft alle f&uuml;r den Systemstart notwendigen
	        Parameter, und hinterlegt diese in der Kernelumgebung,
	        bevor er die Kontrolle &uuml;bergibt.  Es ist hier
	        m&ouml;glich, den <filename>GENERIC</filename>-Kernel
	        zu verwenden.</para>
	    </listitem>

	    <listitem>
	      <para><application>Etherboot</application> l&auml;dt den
	        Kernel hingegen direkt.  Daf&uuml;r m&uuml;ssen Sie
	        allerdings einen Kernel mit spezifischen Optionen
	        erzeugen.</para>
	    </listitem>
	  </itemizedlist>

	  <para><acronym>PXE</acronym> und
	    <application>Etherboot</application> sind zwar im
	    Gro&szlig;en und Ganzen gleichwertig, da der Kernel
	    aber viele Aufgaben an &man.loader.8; &uuml;bergibt, sollte
	    bevorzugt <acronym>PXE</acronym> eingesetzt werden.</para>

	  <para>Wenn Ihr <acronym>BIOS</acronym> und Ihre Netzkarten
	    <acronym>PXE</acronym> unterst&uuml;tzen, sollten Sie es
	    auch verwenden.</para>
	</listitem>

	<listitem>
	   <para>Zuletzt muss der Rechner auf seine Dateisysteme
	     zugreifen k&ouml;nnen.  Daf&uuml;r wird stets
	     <acronym>NFS</acronym> verwendet.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Informationen finden Sie in &man.diskless.8;.</para>
    </sect2>

    <sect2>
      <title>Installationsanweisungen</title>

      <sect3>
	<title>Konfiguration unter Verwendung von
	  <application>ISC DHCP</application></title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

	<para>Der <application>ISC DHCP</application>-Server kann
	  Anfragen sowohl von BOOTP als auch von DHCP beantworten.
	</para>

	<para><application>isc-dhcp 3.0</application> ist nicht Teil
	  des Basissystems.  Sie m&uuml;ssen es daher zuerst
	  installieren.  Verwenden Sie dazu den Port
	  <filename role="package">net/isc-dhcp3-server</filename>
	  oder das entsprechende Paket.</para>

	<para>Nachdem <application>ISC DHCP</application> installiert
	  ist, muss das Programm konfiguriert werden (normalerweise in
	  <filename>/usr/local/etc/dhcpd.conf</filename>).  Im
	  folgenden Beispiel verwendet Rechner <hostid>margaux</hostid>
	  <application>Etherboot</application>, w&auml;hrend Rechner
	  <hostid>corbieres</hostid> <acronym>PXE</acronym> verwendet:
	</para>

	<programlisting>          default-lease-time 600;
          max-lease-time 7200;
          authoritative;

          option domain-name "example.com";
          option domain-name-servers 192.168.4.1;
          option routers 192.168.4.1;

          subnet 192.168.4.0 netmask 255.255.255.0 {
            use-host-decl-names on; <co id="co-dhcp-host-name">
            option subnet-mask 255.255.255.0;
            option broadcast-address 192.168.4.255;

            host margaux {
              hardware ethernet 01:23:45:67:89:ab;
              fixed-address margaux.example.com;
              next-server 192.168.4.4;<co id="co-dhcp-next-server">
              filename "/tftpboot/kernel.diskless";<co id="co-dhcp-filename">
              option root-path "192.168.4.4:/data/misc/diskless";<co id="co-dhcp-root-path">
            }
           host corbieres {
             hardware ethernet 00:02:b3:27:62:df;
              fixed-address corbieres.example.com;
              next-server 192.168.4.4;
              filename "pxeboot";
              option root-path "192.168.4.4:/data/misc/diskless";
            }
          }
        </programlisting>

	<calloutlist>
	  <callout arearefs="co-dhcp-host-name"><para>Diese Option
	    weist <application>dhcpd</application> an, den Wert der
	    <literal>host</literal>-Deklaration als Rechnernamen des
	    plattenlosen Rechners zu senden.  Alternativ kann man der
	    <literal>host</literal>-Deklaration Folgendes
	    hinzuf&uuml;gen: <literal>option host-name
	    <replaceable>margaux</replaceable></literal></para>
	  </callout>

	  <callout arearefs="co-dhcp-next-server"><para>Die Anweisung
	    <literal>next-server</literal> bestimmt den
	    <acronym>TFTP</acronym>- oder
	    <acronym>NFS</acronym>-Server, von dem der Loader oder
	    der Kernel geladen werden (in der Voreinstellung ist das
	    der <acronym>DHCP</acronym>-Server selbst).</para>
	  </callout>

	  <callout arearefs="co-dhcp-filename"><para>Die Anweisung
	    <literal>filename</literal> bestimmt die Datei, die
	    <application>Etherboot</application> als n&auml;chstes
	    l&auml;dt.  Das genaue Format h&auml;ngt von der
	    gew&auml;hlten Transfermethode ab.
	    <application>Etherboot</application> kann sowohl mit
	    <acronym>NFS</acronym> als auch mit
	    <acronym>TFTP</acronym> kompiliert werden.  In der
	    Voreinstellung wird der &os;-Port mit
	    <acronym>NFS</acronym>-Unterst&uuml;tzung kompiliert.
	    <acronym>PXE</acronym> verwendet <acronym>TFTP</acronym>,
	    daher wird im Beispiel ein relativer Dateipfad verwendet.
	    Dies kann aber, je nach Konfiguration des
	    <acronym>TFTP</acronym>-Servers, auch anders sein.
	    Beachten Sie, dass <acronym>PXE</acronym>
	    <filename>pxeboot</filename> l&auml;dt, und nicht den
	    Kernel.  Es ist auch m&ouml;glich, das Verzeichnis
	    <filename class="directory">/boot</filename> einer
	    &os;-CD-ROM von <filename>pxeboot</filename> laden zu
	    lassen.  &man.pxeboot.8; kann einen
	    <filename>GENERIC</filename>-Kernel laden, dadurch ist es
	    m&ouml;glich, <acronym>PXE</acronym> von einer entfernten
	    CD-ROM zu starten.</para>
	  </callout>

	  <callout arearefs="co-dhcp-root-path"><para>Die Option
	    <literal>root-path</literal> bestimmt den Pfad des
	    root-Dateisystems in normaler NFS-Schreibweise.  Wird
	    <acronym>PXE</acronym> verwendet, ist es m&ouml;glich,
	    die IP-Adresse des Rechners wegzulassen, solange nicht
	    die Kerneloption BOOTP aktiviert wird.  Der
	    <acronym>NFS</acronym>-Server entspricht in diesem Fall
	    dem <acronym>TFTP</acronym>-Server.</para>
	  </callout>
	</calloutlist>
      </sect3>

      <sect3>
	<title>Konfiguration bei Verwendung von BOOTP</title>

	<indexterm>
	  <primary>BOOTP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

	<para>Es folgt nun eine der Konfiguration von DHCP
	  entsprechende Konfiguration (f&uuml;r einen Client) f&uuml;r
	  <application>bootpd</application>.  Zu finden ist die
	  Konfigurationsdatei unter <filename>/etc/bootptab</filename>.
	</para>

	<para>Beachten Sie bitte, dass
	  <application>Etherboot</application> mit der Option
	  <literal>NO_DHCP_SUPPORT</literal> kompiliert werden muss,
	  damit BOOTP verwendet werden kann.  <acronym>PXE</acronym>
	  hingegen <emphasis>ben&ouml;tigt</emphasis>
	  <acronym>DHCP</acronym>.  Der einzige offensichtliche
	  Vorteil von <application>bootpd</application> ist, dass es
	  bereits im Basissystem vorhanden ist.</para>

	<programlisting>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100</programlisting>
      </sect3>

      <sect3>
        <title>Ein Startprogramm unter Verwendung von
          <application>Etherboot</application> erstellen</title>

        <indexterm>
          <primary>Etherboot</primary>
        </indexterm>

	<para>Die <ulink url="http://etherboot.sourceforge.net">
	  Internetseite von Etherboot</ulink> enth&auml;lt
	  <ulink url="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
          ausf&uuml;hrliche Informationen</ulink>, die zwar vor allem
          f&uuml;r Linux gedacht sind, aber dennoch n&uuml;tzliche
          Informationen enthalten.  Im Folgenden wird daher nur grob
          beschrieben, wie Sie <application>Etherboot</application> auf
          einem FreeBSD-System einsetzen k&ouml;nnen.</para>

        <para>Als Erstes m&uuml;ssen Sie
          <filename role="package">net/etherboot</filename> als Paket
          oder als Port installieren.</para>

	<para>Sie k&ouml;nnen <application>Etherboot</application> so
	  konfigurieren, dass <acronym>TFTP</acronym> anstelle von
	  <acronym>NFS</acronym> verwendet wird, indem Sie die Datei
	  <filename>Config</filename> im Quellverzeichnis von
	  <application>Etherboot</application> bearbeiten.</para>

        <para>F&uuml;r unsere Installation verwenden wir eine
          Startdiskette.  F&uuml;r Informationen zu anderen Methoden
	  (PROM oder &ms-dos;-Programme) lesen Sie bitte die
	  Dokumentation zu <application>Etherboot</application>.</para>

        <para>Um eine Startdiskette zu erzeugen, legen Sie eine Diskette
          in das Laufwerk des Rechners ein, auf dem Sie
          <application>Etherboot</application> installiert haben.  Danach
          wechseln Sie in das Verzeichnis <filename>src</filename> des
          <application>Etherboot</application>-Verzeichnisbaums und geben
          Folgendes ein:</para>

	<screen>&prompt.root; <userinput>gmake bin32/<replaceable>devicetype</replaceable>.fd0</userinput></screen>

        <para><replaceable>devicetype</replaceable> h&auml;ngt vom Typ
          der Ethernetkarte ab, &uuml;ber die der plattenlose Rechner
          verf&uuml;gt.  Lesen Sie dazu <filename>NIC</filename> im
          gleichen Verzeichnis, um den richtigen Wert f&uuml;r
        <replaceable>devicetype</replaceable> zu bestimmen.</para>
      </sect3>

      <sect3>
	<title>Das System mit <acronym>PXE</acronym> starten</title>

	<para>In der Voreinstellung l&auml;dt der
	  &man.pxeboot.8;-Loader den Kernel &uuml;ber
	  <acronym>NFS</acronym>.  Soll stattdessen
	  <acronym>TFTP</acronym> verwendet werden, muss beim
	  Kompilieren die Option
	  <literal>LOADER_TFTP_SUPPORT</literal> in der Datei
	  <filename>/etc/make.conf</filename> eingetragen sein. Sehen
	  Sie sich die Datei
	  <filename>/usr/share/examples/etc/make.conf</filename>
	  f&uuml;r weitere Anweisungen an.</para>

	<para>Es gibt zwei Optionen f&uuml;r
	  <filename>make.conf</filename>, die n&uuml;tzlich sein
	  k&ouml;nnen, wenn Sie eine plattenlose serielle Konsole
	  einrichten wollen:
	  <literal>BOOT_PXELDR_PROBE_KEYBOARD</literal>, und
	  <literal>BOOT_PXELDR_ALWAYS_SERIAL</literal>.</para>

	<para>Um <acronym>PXE</acronym> beim Systemstart zu verwenden,
	  m&uuml;ssen Sie im <acronym>BIOS</acronym> des Rechner die
	  Option <literal>&Uuml;ber das Netzwerk starten</literal>
	  aktivieren.  Alternativ k&ouml;nnen Sie w&auml;hrend der
	  PC-Initialisierung auch eine Funktionstaste dr&uuml;cken.
	</para>
      </sect3>

      <sect3>
	<title>Serverkonfiguration - <acronym>TFTP</acronym> und
	  <acronym>NFS</acronym></title>

        <indexterm>
          <primary>TFTP</primary>
          <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <indexterm>
          <primary>NFS</primary>
          <secondary>plattenloser Betrieb</secondary>
        </indexterm>

	<para>Wenn Sie <acronym>PXE</acronym> oder
	  <application>Etherboot</application> so konfiguriert haben,
	  dass diese <acronym>TFTP</acronym> verwenden, m&uuml;ssen
	  Sie auf dem Dateiserver <application>tftpd</application>
	  aktivieren:</para>

        <procedure>
          <step>
            <para>Erzeugen Sie ein Verzeichnis, in dem
	      <application>tftpd</application> seine Dateien ablegt,
              beispielsweise <filename>/tftpboot</filename>.</para>
          </step>

          <step>
            <para>F&uuml;gen Sie folgende Zeile in
              <filename>/etc/inetd.conf</filename> ein:</para>

            <programlisting>tftp    dgram   udp     wait    root  /usr/libexec/tftpd    tftpd -s /tftpboot</programlisting>

            <note><para>Anscheinend ben&ouml;tigen zumindest einige
	      <acronym>PXE</acronym>-Versionen die
	      <acronym>TCP</acronym>-Version von
	      <acronym>TFTP</acronym>.  Sollte dies bei Ihnen der
              Fall sein, f&uuml;gen Sie eine zweite Zeile ein, in der
              Sie <literal>dgram udp</literal> durch
              <literal>stream tcp</literal> ersetzen.</para>
            </note>
          </step>

          <step>
	    <para>Weisen Sie <application>inetd</application> an, seine
	      Konfiguration erneut einzulesen (Damit der folgende
	      Befehl funktioniert, muss die Option
	      <option>inetd_enable="YES"</option> in der Datei
	      <filename>/etc/rc.conf</filename> vorhanden sein.):</para>

            <screen>&prompt.root; <userinput>/etc/rc.d/inetd restart</userinput></screen>
          </step>
        </procedure>

        <para>Sie k&ouml;nnen das Verzeichnis
          <filename>/tftpboot</filename> an einem beliebigen Ort auf dem
          Server ablegen.  Stellen Sie aber sicher, dass Sie diesen Ort
          sowohl in <filename>inetd.conf</filename> als auch in
	  <filename>dhcpd.conf</filename> eingetragen haben.</para>

        <para>Au&szlig;erdem m&uuml;ssen Sie NFS aktivieren und die
          entsprechenden Verzeichnisse exportieren.</para>

        <procedure>
          <step>
            <para>F&uuml;gen Sie folgende Zeile in
              <filename>/etc/rc.conf</filename> ein:</para>

            <programlisting>nfs_server_enable="YES"</programlisting>
          </step>

          <step>
            <para>Exportieren Sie das Verzeichnis, in dem sich das
              Wurzelverzeichnis f&uuml;r den plattenlosen Betrieb
              befindet, indem Sie folgende Zeile in
              <filename>/etc/exports</filename> einf&uuml;gen (passen
	      Sie dabei den <foreignphrase>mountpoint</foreignphrase>
	      an und ersetzen Sie
	      <replaceable>margaux corbieres</replaceable> durch den
	      Namen Ihres plattenlosen Rechners):</para>

            <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux</replaceable></programlisting>
          </step>

          <step>
	    <para>Weisen sie nun <application>mountd</application> an,
	      seine Konfigurationsdatei erneut einzulesen.  Wenn Sie
	      <acronym>NFS</acronym> erst in der Datei
	      <filename>/etc/rc.conf</filename> aktivieren mussten,
              sollten Sie stattdessen den Rechner neu starten.  Dadurch
              wird die Konfigurationsdatei ebenfalls neu eingelesen.
            </para>

            <screen>&prompt.root; <userinput>/etc/rc.d/mountd restart</userinput></screen>
          </step>
        </procedure>
      </sect3>

      <sect3>
        <title>Einen plattenlosen Kernel erzeugen</title>

        <indexterm>
          <primary>plattenloser Betrieb</primary>
          <secondary>Kernelkonfiguration</secondary>
        </indexterm>

	<para>Wenn Sie <application>Etherboot</application> verwenden,
	  m&uuml;ssen Sie in die Kernelkonfigurationsdatei Ihres
	  plattenlosen Clients zus&auml;tzlich folgende Optionen
	  einf&uuml;gen:</para>

        <programlisting>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root file system using BOOTP info</programlisting>

        <para>Au&szlig;erdem k&ouml;nnen Sie die Optionen
	  <literal>BOOTP_NFSV3</literal>,
	  <literal>BOOT_COMPAT</literal> sowie
          <literal>BOOTP_WIRED_TO</literal> verwenden (sehen Sie sich
	  dazu auch die Datei <filename>NOTES</filename> an).</para>

	 <para>Die Namen dieser Optionen sind historisch bedingt.
	   Sie erm&ouml;glichen eine unterschiedliche Verwendung von
	   <acronym>DHCP</acronym> und BOOTP innerhalb des Kernels.
	   Es ist auch m&ouml;glich, eine strikte Verwendung von BOOTP
	   oder <acronym>DHCP</acronym> zu erzwingen.</para>

        <para>Erzeugen Sie den neuen Kernel (lesen Sie dazu auch
	  <xref linkend="kernelconfig">) und kopieren Sie ihn an den
	  in <filename>dhcpd.conf</filename> festgelegten Ort.</para>

	<note><para>Wenn Sie <acronym>PXE</acronym> verwenden, ist die
	    Erzeugung eines Kernels zwar nicht unbedingt n&ouml;tig, sie
	    wird allerdings dennoch empfohlen.  Die Aktivierung dieser
	    Optionen bewirkt, dass die Anzahl der m&ouml;glichen
	    <acronym>DHCP</acronym>-Anforderungen w&auml;hrend des
	    Kernelstarts erh&ouml;ht wird.  Ein kleiner Nachteil sind
	    eventuell auftretende Inkonsistenzen zwischen den neuen
	    Werten und den von &man.pxeboot.8; erhaltenen Werten.  Der
	    gro&szlig;e Vorteil dieser Variante ist es, dass dabei der
	    Rechnername gesetzt wird, den Sie ansonsten durch eine
	    andere Methode, beispielsweise in einer clientspezifischen
	    <filename>rc.conf</filename>-Datei festlegen m&uuml;ssten.
	  </para>
	</note>

	<note><para>Damit der Kernel von
	    <application>Etherboot</application> geladen werden kann,
	    m&uuml;ssen <foreignphrase>device hints</foreignphrase> im
	    Kernel einkompiliert sein.  Dazu setzen Sie normalerweise
	    folgende Option in die Kernelkonfigurationsdatei (sehen Sie
	    sich dazu auch die kommentierte Datei
	    <filename>NOTES</filename> an):</para>

	  <programlisting>hints         "GENERIC.hints"</programlisting>
	</note>
      </sect3>

      <sect3>
        <title>Das root-Dateisystem erzeugen</title>

        <indexterm>
          <primary>Root-Dateisystem</primary>
	  <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <para>Sie m&uuml;ssen f&uuml;r den plattenlosen Rechner ein
          root-Dateisystem erzeugen, und zwar an dem in
          <filename>dhcpd.conf</filename> als
	  <literal>root-path</literal> festgelegten Ort.</para>

	<sect4>
	  <title><command>make world</command> zum F&uuml;llen des
	    Dateisystems einsetzen</title>

	  <para>Diese schnelle Methode installiert ein komplettes
	    <quote>jungfr&auml;uliches</quote> System (und nicht nur ein
	    root-Dateisystem) nach <envar>DESTDIR</envar>.  Dazu
	    m&uuml;ssen Sie lediglich das folgende Skript
	    ausf&uuml;hren:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
cd /usr/src/etc; make distribution</programlisting>

	  <para>Danach m&uuml;ssen Sie noch die dadurch in
	    <envar>DESTDIR</envar> erzeugten Dateien
	    <filename>/etc/rc.conf</filename> sowie
	    <filename>/etc/fstab</filename> Ihren W&uuml;nschen
	    anpassen.</para>
	</sect4>
      </sect3>

      <sect3>
        <title>Den Auslagerungsbereich konfigurieren</title>

	<para>Falls n&ouml;tig, kann eine auf dem
	  <acronym>NFS</acronym>-Server liegende Datei als
	  Auslagerungsdatei eingerichtet werden.</para>

	<sect4>
	  <title>Eine <acronym>NFS</acronym>-Auslagerungsdatei
	    einrichten</title>

	  <para>Der Kernel unterst&uuml;tzt beim Systemstart keine
	    <acronym>NFS</acronym>-Auslagerungsdatei.  Diese muss daher
	    in den Startskripten aktiviert werden, indem ein
	    beschreibbares Dateisystem eingeh&auml;ngt wird, um dort
	    die Auslagerungsdatei zu erzeugen und zu aktivieren.  Um
	    eine Auslagerungsdatei zu erzeugen, gehen Sie wie folgt
	    vor:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/path/to/swapfile</replaceable> bs=1k count=1 oseek=<replaceable>100000</replaceable></userinput></screen>

	  <para>Um die Auslagerungsdatei zu aktivieren, f&uuml;gen Sie
	    folgende Zeile in <filename>rc.conf</filename> ein:</para>

	  <programlisting>swapfile=<replaceable>/path/to/swapfile</replaceable></programlisting>
	</sect4>
      </sect3>

      <sect3>
        <title>Verschiedenes</title>

        <sect4>
          <title>Schreibgesch&uuml;tztes Dateisystem
	    <filename>/usr</filename></title>

          <indexterm>
            <primary>plattenloser Betrieb</primary>
            <secondary>/usr schreibgesch&uuml;tzt</secondary>
          </indexterm>

          <para>Wenn am plattenlosen Rechner X l&auml;uft, m&uuml;ssen
            Sie die Konfigurationsdatei von
            <application>XDM</application> anpassen, da Fehlermeldungen
            in der Voreinstellung auf <filename>/usr</filename>
            geschrieben werden.</para>
        </sect4>

        <sect4>
          <title>Der Server l&auml;uft nicht unter FreeBSD</title>

	  <para>Wenn das root-Dateisystem nicht auf einem
	    FreeBSD-Rechner liegt, muss das Dateisystem zuerst unter
	    FreeBSD erzeugt werden.  Anschlie&szlig;end wird es
	    beispielsweise mit <command>tar</command> oder
	    <command>cpio</command> an den gew&uuml;nschten Ort
	    kopiert.</para>

	  <para>Dabei kann es Probleme mit den Ger&auml;tedateien
	    in <filename>/dev</filename> geben, die durch eine
	    unterschiedliche Darstellung der  Major- und Minor-Number
	    von Ger&auml;ten auf beiden Systemen hervorgerufen werden.
	    Eine Probleml&ouml;sung besteht darin, das root-Verzeichnis
	    auf einem FreeBSD-Rechner einzuh&auml;ngen und die
	    Ger&auml;tedateien dort mit &man.devfs.5; zu erzeugen.</para>
        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-isdn">
    <title>ISDN &ndash; diensteintegrierendes digitales Netzwerk</title>

    <indexterm>
      <primary>ISDN</primary>
    </indexterm>

    <para>Eine gute Quelle f&uuml;r Informationen zu ISDN ist die
      <ulink url="http://www.alumni.caltech.edu/~dank/isdn/">
      ISDN-Seite</ulink> von Dan Kegel.</para>

    <para>Welche Informationen finden Sie in diesem Abschnitt?</para>

    <itemizedlist>
      <listitem>
        <para>Wenn Sie in Europa leben, k&ouml;nnte der Abschnitt
          &uuml;ber ISDN-Karten f&uuml;r Sie interessant sein.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie ISDN haupts&auml;chlich dazu verwenden wollen, um
          sich &uuml;ber einen Anbieter ins Internet einzuw&auml;hlen,
          sollten Sie den Abschnitt &uuml;ber Terminaladapter lesen.
          Dies ist die flexibelste Methode, die auch die wenigsten
          Probleme verursacht.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie zwei Netzwerke miteinander verbinden, oder sich
          &uuml;ber eine ISDN-Standleitung mit dem Internet verbinden
          wollen, finden Sie entsprechende Informationen im Abschnitt
          &uuml;ber Router und Bridges.</para>
      </listitem>
    </itemizedlist>

    <para>Bei der Wahl der gew&uuml;nschten L&ouml;sung sind die
      entstehenden Kosten ein entscheidender Faktor.  Die folgenden
      Beschreibungen reichen von der billigsten bis zur teuersten
      Variante.</para>

    <sect2 id="network-isdn-cards">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Hellmuth</firstname>
            <surname>Michaelis</surname>
            <contrib>Beigetragen von </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>ISDN-Karten</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Karten</secondary>
      </indexterm>

      <para>Das ISDN-Subsystem von FreeBSD unterst&uuml;tzt den
        DSS1/Q.931- (oder Euro-ISDN)-Standard nur f&uuml;r passive
        Karten.  Zus&auml;tzlich werden aber auch einige
        aktive Karten unterst&uuml;tzt, bei denen die Firmware auch
        andere Signalprotokolle unterst&uuml;tzt;  dies schlie&szlig;t
        auch die erste ISDN-Karte mit
        Prim&auml;rmultiplex-Unterst&uuml;tzung mit ein.</para>

      <para><application>isdn4bsd</application> erm&ouml;glicht es
	Ihnen, sich unter Nutzung von
	<emphasis>IP over raw HDLC</emphasis> oder
        <emphasis>synchronem PPP</emphasis> mit anderen ISDN-Routern zu
        verbinden.  Dazu verwenden Sie entweder Kernel-&man.ppp.8;
	(via <literal>isppp</literal>, einem modifizierten
	sppp-Treiber), oder Sie benutzen User-&man.ppp.8;.  Wenn Sie
	User-&man.ppp.8; verwenden, k&ouml;nnen Sie zwei oder mehrere
	ISDN-B-Kan&auml;le b&uuml;ndeln.  Im Paket enthalten ist auch
	ein Programm mit Anrufbeantworterfunktion sowie verschiedene
	Werkzeuge, wie ein Softwaremodem, das 300&nbsp;Baud
	unterst&uuml;tzt.</para>

      <para>FreeBSD unterst&uuml;tzt eine st&auml;ndig wachsende Anzahl
        von PC-ISDN-Karten, die weltweit erfolgreich eingesetzt werden.
      </para>

      <para>Von FreeBSD unterst&uuml;tzte passive ISDN-Karten enthalten
        fast immer den ISAC/HSCX/IPAC ISDN-Chipsatz von Infineon
        (ehemals Siemens).  Unterst&uuml;tzt werden aber auch Karten mit
        Cologne Chip (diese allerdings nur f&uuml;r den ISA-Bus),
        PCI-Karten mit Winbond W6692 Chipsatz, einige Karten mit dem
        Tiger 300/320/ISAC Chipsatz sowie einige Karten mit einem
        herstellerspezifischen Chipsatz, wie beispielsweise die
        Fritz!Card PCI V.1.0 und die Fritz!Card PnP von AVM.</para>

      <para>An aktiven ISDN-Karten werden derzeit die AVM B1 BRI-Karten
        (ISA und PCI-Version) sowie die AVM T1 PRI-Karten (PCI-Version)
        unterst&uuml;tzt.</para>

      <para>Informationen zu <application>isdn4bsd</application> finden
	Sie im Verzeichnis
	<filename>/usr/share/examples/isdn/</filename> Ihres
	FreeBSD-Systems, oder auf der
        <ulink url="http://www.freebsd-support.de/i4b/">Internetseite</ulink>
        von <application>isdn4bsd</application>.  Dort finden Sie auch
        Verweise zu Tipps, Korrekturen, sowie weiteren Informationen,
        wie dem
        <ulink url="http://people.FreeBSD.org/~hm/">isdn4bsd-Handbuch</ulink>.
      </para>

      <para>Falls Sie an der Unterst&uuml;tzung eines zus&auml;tzlichen
        ISDN-Protokolls, einer weiteren ISDN-Karte oder an einer anderen
        Erweiterung von <application>isdn4bsd</application> interessiert
        sind, wenden Sie sich bitte an &a.hm;.</para>

      <para>F&uuml;r Fragen zur Installation, Konfiguration und zu
        sonstigen Problemen von <application>isdn4bsd</application> gibt
        es die Mailingliste &a.isdn.name;.</para>
    </sect2>

    <sect2>
      <title>ISDN-Terminaladapter</title>

      <indexterm>
        <primary>Terminaladapter</primary>
      </indexterm>

      <para>Terminaladapter (TA) sind f&uuml;r ISDN, was Modems f&uuml;r
        analoge Telefonleitungen sind.</para>

      <indexterm>
        <primary>Modem</primary>
      </indexterm>

      <para>Die meisten Terminaladapter verwenden den
	Standardbefehlssatz f&uuml;r Modems von Hayes (AT-Kommandos) und
	k&ouml;nnen daher als Modemersatz verwendet werden.</para>

      <para>Ein Terminaladapter funktioniert prinzipiell wie ein Modem,
	allerdings erfolgt der Verbindungsaufbau um einiges schneller.
	Die Konfiguration von <link linkend="ppp">PPP</link> entspricht
	dabei exakt der eines Modems.  Stellen Sie dabei allerdings
	die serielle Geschwindigkeit so hoch wie m&ouml;glich ein.
      </para>

      <indexterm>
        <primary>PPP</primary>
      </indexterm>

      <para>Der Hauptvorteil bei der Verwendung eines Terminaladapters
	zur Verbindung mit einem Internetanbieter ist die
	M&ouml;glichkeit zur Nutzung von dynamischem PPP.  Da
	IP-Adressen immer knapper werden, vergeben die meisten Provider
	keine statischen IP-Adressen mehr.  Die meisten Router
	unterst&uuml;tzen allerdings keine dynamische Zuweisung von
	IP-Adressen.</para>

      <para>Der PPP-Daemon bestimmt die Stabilit&auml;t und
	Eigenschaften der Verbindung, wenn Sie einen Terminaladapter
	verwenden.  Daher k&ouml;nnen Sie unter FreeBSD einfach von
	einer Modemverbindung auf eine ISDN-Verbindung wechseln, wenn
	Sie PPP bereits konfiguriert haben.  Allerdings bedeutet
	dies auch, das bereits bestehende Probleme mit PPP auch unter
	ISDN auftreten werden.</para>

      <para>Wenn Sie an maximaler Stabilit&auml;t interessiert sind,
        verwenden Sie Kernel-<link linkend="ppp">PPP</link>, und
	nicht das <link linkend="userppp">User-PPP</link>.</para>

      <para>Folgende Terminaladapter werden von FreeBSD
	unterst&uuml;tzt:</para>

      <itemizedlist>
        <listitem>
          <para>Motorola BitSurfer und Bitsurfer Pro</para>
        </listitem>

        <listitem>
          <para>Adtran</para>
        </listitem>
      </itemizedlist>

      <para>Die meisten anderen Terminaladapter werden wahrscheinlich
	ebenfalls funktionieren, da die Hersteller von Terminaladaptern
	darauf achten, dass ihre Produkte den Standardbefehlssatz
	m&ouml;glichst gut unterst&uuml;tzen.</para>

      <para>Das wirkliche Problem mit einem externen Terminaladapter ist,
        dass, &auml;hnlich wie bei Modems, eine gute serielle Karte
        eine Grundvoraussetzung ist.</para>

      <para>Sie sollten sich die
        <ulink url="&url.articles.serial-uart.en;/index.html">
        Anleitung f&uuml;r die Nutzung serieller Ger&auml;te unter
        FreeBSD</ulink> ansehen, wenn Sie detaillierte Informationen
        &uuml;ber serielle Ger&auml;te und die Unterschiede zwischen
	asynchronen und synchronen seriellen Ports ben&ouml;tigen.
      </para>

      <para>Ein Terminaladapter, der an einem (asynchronen)
	seriellen Standardport angeschlossen ist, beschr&auml;nkt
	Sie auf 115,2&nbsp;Kbs.  Dies
        selbst dann, wenn Sie eine Verbindung mit 128&nbsp;Kbs haben.
        Um die volle Leistungsf&auml;higkeit von ISDN (128&nbsp;Kbs)
        nutzen zu k&ouml;nnen, m&uuml;ssen Sie den Terminaladapter
	daher an eine synchrone serielle Karte anschlie&szlig;en.</para>

      <para>Kaufen Sie keinen internen Terminaladapter in der Hoffnung,
        damit das synchron/asynchron-Problem vermeiden zu k&ouml;nnen.
	Interne Terminaladapter haben einen (asynchronen) seriellen
	Standardportchip eingebaut.  Der einzige Vorteil interner
	Terminaladapter ist es, dass Sie ein serielles sowie ein
	Stromkabel weniger ben&ouml;tigen.</para>

      <para>Eine synchrone Karte mit einem Terminaladapter ist
	mindestens so schnell wie ein autonomer ISDN-Router,
	und, in Kombination mit einem einfachen 386-FreeBSD-System,
	wahrscheinlich flexibler.</para>

      <para>Die Entscheidung zwischen synchroner Karte/Terminaladapter
	und einem autonomen ISDN-Router ist beinahe eine religi&ouml;se
        Angelegenheit.  Zu diesem Thema gibt es viele Diskussionen
        in den Mailinglisten.  Suchen Sie in den
        <ulink url="&url.base;/search/index.html"> Archiven</ulink>
        danach, wenn Sie an der kompletten Diskussion interessiert
        sind.</para>
    </sect2>

    <sect2>
      <title>ISDN-Bridges und Router</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Autonome Bridge/Router</secondary>
      </indexterm>

      <para>ISDN-Bridges und Router sind keine Eigenheit von
        FreeBSD oder eines anderen Betriebssystems.  F&uuml;r eine
        vollst&auml;ndigere Beschreibung von Routing und
        Netzwerkkopplungen mit einer Bridge informieren Sie sich
        bitte durch weiterf&uuml;hrende Literatur.</para>

      <para>In diesem Abschnitt werden die Begriffe Router und
        Bridge synonym verwendet.</para>

      <para>ISDN-Router und Bridges werden immer g&uuml;nstiger und
	damit auch immer beliebter.  Ein ISDN-Router ist eine kleine
	Box, die direkt an Ihr lokales Ethernet-Netzwerk angeschlossen
	wird und sich mit einem Router oder einer Bridge verbindet.
	Die eingebaute Software erm&ouml;glicht die Kommunikation
	&uuml;ber PPP oder andere beliebte Protokolle.</para>

      <para>Ein Router erm&ouml;glicht einen deutlich h&ouml;heren
        Datendurchsatz als ein herk&ouml;mmlicher Terminaladapter,
	da er eine vollsynchrone ISDN-Verbindung nutzt.</para>

      <para>Das Hauptproblem mit ISDN-Routern und Bridges ist,
        dass die Zusammenarbeit zwischen Ger&auml;ten verschiedener
        Hersteller nach wie vor ein Problem ist.  Wenn Sie sich auf
        diese Weise mit einem Internetanbieter verbinden wollen,
        kl&auml;ren Sie daher vorher ab, welche Anforderungen Ihre
        Ger&auml;te erf&uuml;llen m&uuml;ssen.</para>

      <para>Eine ISDN-Bridge ist eine einfache und wartungsarme
	L&ouml;sung, zwei Netze, beispielsweise Ihr privates Netz
	und Ihr Firmennetz, miteinander zu verbinden.  Da Sie die
        technische Ausstattung f&uuml;r beide Seiten kaufen m&uuml;ssen,
        ist sichergestellt, dass die Verbindung funktionieren
        wird.</para>

      <para>Um beispielsweise einen privaten Computer oder eine
        Zweigstelle mit dem Hauptnetzwerk zu verbinden, k&ouml;nnte
        folgende Konfiguration verwendet werden:</para>

      <example>
        <title>Kleines Netzwerk (Privatnetz)</title>

        <indexterm>
          <primary>10 base 2</primary>
        </indexterm>

        <para>Das Netzwerk basiert auf der Bustopologie mit 10base2
          Ethernet (<quote>Thinnet</quote>).  Falls n&ouml;tig, stellen
          Sie die Verbindung zwischen Router und Netzwerkkabel mit einem
          AUI/10BT-Transceiver her.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-bus">
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
---Sun Workstation
|
---FreeBSD Rechner
|
---Windows 95
|
Autonomer Router
   |
ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>10Base2 - Ethernet</phrase>
          </textobject>
        </mediaobject>

        <para>Wenn Sie nur einen einzelnen Rechner verbinden wollen,
          k&ouml;nnen Sie auch ein Twisted-Pair-Kabel (Cross-Over)
          verwenden, das direkt an den Router angeschlossen wird.</para>
      </example>

      <example>
        <title>Gro&szlig;es Netzwerk (Firmennetz)</title>

        <indexterm>
          <primary>10 base T</primary>
        </indexterm>

        <para>Dieses Netzwerk basiert auf der Sterntopologie und 10baseT
          Ethernet (<quote>Twisted Pair</quote>).</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-twisted-pair">
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
-------Novell Server
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---Autonomer Router
                |
        ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>ISDN Netzwerkdiagramm</phrase>
          </textobject>
        </mediaobject>
      </example>

      <para>Ein gro&szlig;er Vorteil der meisten Router und Bridges
	ist es, dass man <emphasis>gleichzeitig</emphasis> zwei
	<emphasis>unabh&auml;ngige</emphasis> PPP-Verbindungen
	zu zwei verschiedenen Zielen aufbauen kann.  Diese
        Funktion bieten die meisten Terminaladapter nicht.  Die
        Ausnahme sind spezielle (meist teure) Modelle, die &uuml;ber
        zwei getrennte serielle Ports verf&uuml;gen.  Verwechseln Sie
        dies aber nicht mit Kanalb&uuml;ndelung oder MPP.</para>

      <para>Dies kann sehr n&uuml;tzlich sein, wenn Sie eine
        ISDN-Standleitung in Ihrem B&uuml;ro haben, die sie
        aufteilen wollen, ohne eine zus&auml;tzliche ISDN-Leitung
        zu installieren.  Ein ISDN-Router kann &uuml;ber einen B-Kanal
        (64&nbsp;Kbps) eine dedizierte Verbindung ins Internet aufbauen,
        und gleichzeitig den anderen B-Kanal f&uuml;r eine separate
        Datenverbindung nutzen.  Der zweite B-Kanal kann beispielsweise
        f&uuml;r ein- oder ausgehende Verbindungen verwendet werden.
        Sie k&ouml;nnen ihn aber auch dynamisch mit dem ersten B-Kanal
        b&uuml;ndeln, um Ihre Bandbreite zu erh&ouml;hen.</para>

      <indexterm>
        <primary>IPX/SPX</primary>
      </indexterm>

      <para>Eine Ethernet-Bridge kann Daten nicht nur im IP-Protokoll,
        sondern auch in beliebigen anderen Protokollen versenden.</para>
    </sect2>
  </sect1>

  <sect1 id="network-natd">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Beigetragen von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>NAT - Network Address Translation</title>

    <sect2 id="network-natoverview">
      <title>&Uuml;berblick</title>

      <indexterm>
        <primary><application>natd</application></primary>
      </indexterm>

      <para>&man.natd.8;, der Network-Address-Translation-Daemon von
        FreeBSD, akzeptiert ankommende Raw-IP-Pakete, &auml;ndert den
        Sender der Daten in den eigenen Rechner und leitet diese Pakete
        in den ausgehenden IP-Paketstrom um, indem IP-Adresse und Port
        des Senders so ge&auml;ndert werden, dass bei einer Antwort der
        urspr&uuml;ngliche Sender wieder bestimmt und die Daten an
        ihn weitergeleitet werden k&ouml;nnen.</para>

      <indexterm><primary>Internet connection sharing</primary></indexterm>

      <indexterm><primary>NAT</primary></indexterm>

      <para>Der h&auml;ufigste Grund f&uuml;r die Verwendung von NAT ist
        die gemeinsame Nutzung einer Internetverbindung.</para>
    </sect2>

    <sect2 id="network-natsetup">
      <title>Einrichtung</title>

      <para>Wegen der begrenzten Verf&uuml;gbarkeit von IPv4-Adressen
        und der gestiegenen Anzahl von Breitbandverbindungen &uuml;ber
        Kabelmodem oder DSL, wird die gemeinsame Nutzung von
        Internetverbindungen immer wichtiger.  Der &man.natd.8;-Daemon
        erm&ouml;glicht die Anbindung von mehreren Rechnern an das
        Internet unter Nutzung einer gemeinsamen Verbindung und einer
        IP-Adresse.</para>

      <para>H&auml;ufig soll ein &uuml;ber Kabelmodem oder DSL und eine
        IP-Adresse an das Internet angebundener Rechner mehreren
        Rechnern eines lokalen Netzwerks Internetdienste anbieten.</para>

      <para>Um dies zu erm&ouml;glichen, muss der FreeBSD-Rechner als
        Gateway fungieren.  Dazu sind zwei Netzkarten notwendig.  Eine
        f&uuml;r die Verbindung zum Internet, die zweite f&uuml;r die
        Verbindung mit dem lokalen Netzwerk.  S&auml;mtliche Rechner
        des lokalen Netzwerks sind &uuml;ber einen Hub oder einen Switch
        miteinander verbunden.</para>

      <note>
        <para>Es gibt verschiedene M&ouml;glichkeiten, ein LAN &uuml;ber
          ein &os;-Gateway an das Internet anzubinden.  Das folgende
          Beispiel beschreibt ein Gateway, das zumindest zwei
          Netzwerkkarten enth&auml;lt.</para>
      </note>

      <mediaobject>
        <imageobject>
          <imagedata fileref="advanced-networking/natd">
        </imageobject>

        <textobject>
         <literallayout class="monospaced">  _______       __________       ________
 |       |     |          |     |        |
 |  Hub  |-----| Client B |-----| Router |----- Internet
 |_______|     |__________|     |________|
     |
 ____|_____
|          |
| Client A |
|__________|</literallayout>
        </textobject>

        <textobject>
          <phrase>Network Layout</phrase>
        </textobject>
      </mediaobject>

      <para>Eine derartige Netzwerkkonfiguration wird vor allem zur
        gemeinsamen Nutzung einer Internetverbindung verwendet.  Ein
        Rechner des lokalen Netzwerks (<acronym>LAN</acronym>) ist mit
        dem Internet verbunden.  Alle anderen Rechner des lokalen
        Netzwerks haben nur &uuml;ber diesen
        <quote>Gateway</quote>-Rechner Zugriff auf das Internet.</para>
    </sect2>

    <sect2 id="network-natdkernconfiguration">
      <indexterm>
        <primary>Kernel</primary>
        <secondary>Konfiguration</secondary>
      </indexterm>

      <title>Kernelkonfiguration</title>

      <para>Folgende Optionen m&uuml;ssen in die
        Kernelkonfigurationsdatei eingetragen werden:</para>

      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>Die folgende Optionen k&ouml;nnen ebenfalls eingetragen
        werden:</para>

       <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>

      <para>In <filename>/etc/rc.conf</filename> tragen Sie Folgendes
        ein:</para>

      <programlisting>gateway_enable="YES" <co id="co-natd-gateway-enable">
firewall_enable="YES" <co id="co-natd-firewall-enable">
firewall_type="OPEN" <co id="co-natd-firewall-type">
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>" <co id="co-natd-natd-interface">
natd_flags="" <co id="co-natd-natd-flags"></programlisting>

      <calloutlist>
        <callout arearefs="co-natd-gateway-enable">
          <para>Richtet den Rechner als Gateway ein.  Die
            Ausf&uuml;hrung von
            <command>sysctl net.inet.ip.forwarding=1</command>
            h&auml;tte den gleichen Effekt.</para>
        </callout>

        <callout arearefs="co-natd-firewall-enable">
          <para>Aktiviert die Firewallregeln in
            <filename>/etc/rc.firewall</filename> beim
            Systemstart.</para>
        </callout>

        <callout arearefs="co-natd-firewall-type">
          <para>Ein vordefinierter Satz von Firewallregeln, der alle
            Pakete durchl&auml;sst.  Sehen Sie sich
            <filename>/etc/rc.firewall</filename> an, wenn Sie diese
            Option verwenden wollen.</para>
        </callout>

        <callout arearefs="co-natd-natd-interface">
          <para>Die Netzkarte, die Pakete weiterleitet (und mit dem
            Internet verbunden ist).</para>
        </callout>

        <callout arearefs="co-natd-natd-flags">
          <para>Zus&auml;tzliche Konfigurationsoptionen, die beim
            Systemstart an &man.natd.8; &uuml;bergeben werden.</para>
        </callout>
      </calloutlist>

      <para>Durch die Definition dieser Optionen in
        <filename>/etc/rc.conf</filename> wird die Anweisung
        <command>natd -interface fxp0</command> beim Systemstart
        ausgef&uuml;hrt.  Dies kann aber auch manuell erfolgen.</para>

      <note>
        <para>Falls Sie viele Optionen an &man.natd.8; &uuml;bergeben
          m&uuml;ssen, k&ouml;nnen Sie auch eine Konfigurationsdatei
          verwenden.  Dazu f&uuml;gen Sie folgende Zeile in
          <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

      <para>Die Datei <filename>/etc/natd.conf</filename> enth&auml;lt
        verschiedene Konfigurationsoptionen, wobei jede Option in einer
        Zeile steht.  Das Beispiel im n&auml;chsten Abschnitt w&uuml;rde
        folgende Konfigurationsdatei verwenden:</para>

      <programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>Wenn Sie eine Konfigurationsdatei verwenden wollen, sollten
        Sie sich die Handbuchseite zu &man.natd.8; durchlesen,
        insbesondere den Abschnitt &uuml;ber die Nutzung der Option
        <option>-f</option>.</para>
      </note>

      <para>Jedem Rechner und jeder Schnittstelle des lokalen Netzwerks
        sollte eine IP-Adresse des im <ulink
        url="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC 1918</ulink>
        definierten privaten Adressraums zugewiesen werden.  Der
        Standardgateway entspricht der internen IP-Adresse des
        <application>natd</application>-Rechners.</para>

      <para>Im Beispiel werden den LAN-Clients <hostid>A</hostid> und
        <hostid>B</hostid> die IP-Adressen
        <hostid role="ipaddr">192.168.0.2</hostid> und
        <hostid role="ipaddr">192.168.0.3</hostid> zugewiesen,
        w&auml;hrend die LAN-Netzkarte des
        <application>natd</application>-Rechners die IP-Adresse
        <hostid role="ipaddr">192.168.0.1</hostid> erh&auml;lt.  Der
        <application>natd</application>-Rechner mit der IP-Adresse
        <hostid role="ipaddr">192.168.0.1</hostid> wird als
        Standardgateway f&uuml;r die Clients <hostid>A</hostid> und
        <hostid>B</hostid> gesetzt.  Die externe Netzkarte des
        <application>natd</application>-Rechners muss f&uuml;r die
        korrekte Funktion von &man.natd.8; nicht konfiguriert
        werden.</para>
    </sect2>

    <sect2 id="network-natdport-redirection">
      <title>Ports umleiten</title>

      <para>Wenn Sie &man.natd.8; verwenden, sind Ihre LAN-Clients von
        aussen nicht erreichbar.  LAN-Clients k&ouml;nnen zwar
        Verbindungen nach aussen aufbauen, sind aber f&uuml;r
        ankommende Verbindungen nicht erreichbar.  Wenn Sie
        Internetdienste auf einem LAN-Client anbieten wollen, haben Sie
        daher ein Problem.  Eine einfache L&ouml;sung ist die Umleitung
        von bestimmten Internetports des
        <application>natd</application>-Rechners auf einen LAN-Client.</para>

      <para>Beispielsweise k&ouml;nnte ein IRC-Server auf Client
        <hostid>A</hostid> und ein Webserver auf Client
        <hostid>B</hostid> laufen.  Damit diese Konfiguration
        funktioniert, m&uuml;ssen Verbindungen, die auf den Ports 6667
        (IRC) und 80 (Web) ankommen, auf die entsprechenden Clients
        umgeleitet werden.</para>

      <para>Dazu wird die Option <option>-redirect_port</option> unter
        Nutzung folgender Syntax an &man.natd.8; &uuml;bergeben:</para>

      <programlisting>     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

      <para>F&uuml;r unser Beispiel hei&szlig;t das:</para>

      <programlisting>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>Dadurch werden die entsprechenden
        <emphasis>tcp</emphasis>-Ports auf die jeweiligen LAN-Clients
        umgeleitet.</para>

      <para>Mit <option>-redirect_port</option> k&ouml;nnen auch ganze
        Portbereiche statt einzelner Ports umgeleitet werden.  So werden
        mit <replaceable>tcp 192.168.0.2:2000-3000
        2000-3000</replaceable> alle Verbindungen, die auf den Ports
        2000 bis 3000 ankommen, auf die entsprechenden Ports des Clients
        <hostid>A</hostid> umgeleitet.</para>

      <para>Diese Optionen k&ouml;nnen w&auml;hrend des Betriebs von
        &man.natd.8; oder &uuml;ber die Option
        <literal>natd_flags=""</literal> in
        <filename>/etc/rc.conf</filename> gesetzt werden.</para>

      <para>Eine ausf&uuml;hrliche Konfigurationsanleitung finden Sie
        in &man.natd.8;.</para>
    </sect2>

    <sect2 id="network-natdaddress-redirection">
      <title>Adressen umleiten</title>

      <indexterm><primary>address redirection</primary></indexterm>

      <para>Die Umleitung von Adressen ist n&uuml;tzlich, wenn mehrere
        IP-Adressen verf&uuml;gbar sind, die aber alle auf einem Rechner
        verbleiben sollen.  In diesem Fall kann &man.natd.8; jedem
        LAN-Client eine eigene externe IP-Adresse zuweisen.  Ausgehende
        Pakete eines LAN-Clients werden so der entsprechenden
        externen IP-Adresse des Clients zugeordnet.  Ankommender Verkehr
        f&uuml;r diese IP-Adresse wird automatisch an den entsprechenden
        LAN-Client weitergeleitet.  Diesen Vorgang bezeichnet man
        auch als statisches NAT.  Dem
        <application>natd</application>-Gatewayrechner k&ouml;nnten
        beispielsweise die IP-Adressen
        <hostid role="ipaddr">128.1.1.1</hostid>,
        <hostid role="ipaddr">128.1.1.2</hostid> sowie
        <hostid role="ipaddr">128.1.1.3</hostid> zugewiesen werden.
        <hostid role="ipaddr">128.1.1.1</hostid> wird als die externe
        IP-Adresse des <application>natd</application>-Gatewayrechners
        verwendet, w&auml;hrend <hostid role="ipaddr">128.1.1.2</hostid>
        und <hostid role="ipaddr">128.1.1.3</hostid> an die LAN-Clients
        <hostid>A</hostid> und <hostid>B</hostid> weitergegeben werden.
      </para>

      <para><option>-redirect_address</option> benutzt folgende
        Syntax:</para>

      <programlisting>-redirect_address localIP publicIP</programlisting>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>localIP</entry>

              <entry>Die interne IP-Adresse des LAN-Clients</entry>
            </row>
            <row>
              <entry>publicIP</entry>

              <entry>Die externe IP-Adresse des LAN-Clients</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>F&uuml;r unser Beispiel hie&szlig;e dies:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>Analog zur Option <option>-redirect_port</option>
        k&ouml;nnen Sie diese Argumente auch in der Option
        <literal>natd_flags=""</literal> in
        <filename>/etc/rc.conf</filename> angeben.  Bei der Nutzung
        der Adressumleitung ist die Portumleitung &uuml;berfl&uuml;ssig,
        weil alle f&uuml;r eine bestimmte IP-Adresse ankommenden Daten
        umgeleitet werden.</para>

      <para>Die externe IP-Adresse des
        <application>natd</application>-Rechners muss aktiv sein und
        der externen Netzkarte zugewiesen sein.  Weitere Informationen
         zu diesem Thema finden Sie in &man.rc.conf.5;.</para>
    </sect2>
  </sect1>

  <sect1 id="network-plip">
    <title>PLIP &ndash; Parallel Line IP</title>

    <indexterm>
      <primary>PLIP</primary>
    </indexterm>

    <indexterm>
      <primary>Parallel Line IP</primary>
      <see>PLIP</see>
    </indexterm>

    <para>PLIP erm&ouml;glicht TCP/IP-Verbindungen zwischen zwei
      Rechnern, die &uuml;ber ihre parallelen Schnittstellen
      verbunden sind.  Eine solche Verbindung ist n&uuml;tzlich,
      wenn zwei Rechner nicht mit Netzkarten ausgestattet sind,
      oder wenn eine Installation auf einem Laptop erfolgen soll.
      Dieser Abschnitt behandelt folgende Themen:</para>

    <itemizedlist>
      <listitem>
	<para>Die Herstellung eines parallelen (Laplink-) Kabels</para>
      </listitem>

      <listitem>
	<para>Die Verbindung von zwei Computern &uuml;ber PLIP</para>
      </listitem>
    </itemizedlist>

    <sect2 id="network-create-parallel-cable">
      <title>Ein paralleles Kabel herstellen</title>

      <para>Ein paralleles (Laplink-)Kabel k&ouml;nnen Sie in fast jedem
	Computergesch&auml;ft kaufen.  Falls dies nicht m&ouml;glich
	sein sollte, oder Sie einfach wissen wollen, wie ein solches
	Kabel aufgebaut ist, sollten Sie sich die folgende Tabelle
	ansehen.  Sie beschreibt die Herstellung eines parallelen
	Netzwerkkabels aus einem gew&ouml;hnlichen parallelen
	Druckerkabel.</para>

      <table frame="none">
	<title>Die Netzwerk-Verdrahtung eines parallelen Kabels</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>A-Name</entry>

	      <entry>A-Ende</entry>

	      <entry>B-Ende</entry>

	      <entry>Beschreibung</entry>

	      <entry>Post/Bit</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literallayout>DATA0
-ERROR</literallayout></entry>

	      <entry><literallayout>2
15</literallayout></entry>

	      <entry><literallayout>15
2</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA1
+SLCT</literallayout></entry>

	      <entry><literallayout>3
13</literallayout></entry>

	      <entry><literallayout>13
3</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA2
+PE</literallayout></entry>

	      <entry><literallayout>4
12</literallayout></entry>

	      <entry><literallayout>12
4</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA3
-ACK</literallayout></entry>

	      <entry><literallayout>5
10</literallayout></entry>

	      <entry><literallayout>10
5</literallayout></entry>

	      <entry>Strobe</entry>

	      <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA4
BUSY</literallayout></entry>

	      <entry><literallayout>6
11</literallayout></entry>

	      <entry><literallayout>11
6</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
	    </row>

	    <row>
	      <entry>GND</entry>

	      <entry>18-25</entry>

	      <entry>18-25</entry>

	      <entry>GND</entry>

	      <entry>-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2 id="network-plip-setup">
      <title>PLIP einrichten</title>

      <para>Als Erstes ben&ouml;tigen Sie ein Laplink-Kabel.  Danach
	m&uuml;ssen Sie sicherstellen, dass beide Computerkernel den
	&man.lpt.4;-Treiber unterst&uuml;tzen:</para>

      <screen>&prompt.root; <userinput>grep lp /var/run/dmesg.boot</userinput>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</screen>

      <para>Der Parallelport muss Interrupt-gesteuert sein, daher
	sollte die Datei <filename>/boot/device.hints</filename>
	zwei Zeilen &auml;hnlich den folgenden enthalten:</para>

      <programlisting>hint.ppc.0.at="isa"
hint.ppc.0.irq="7"</programlisting>

      <para>Danach &uuml;berpr&uuml;fen Sie, ob die
	Kernelkonfigurationsdatei die Zeile
	<literal>device plip</literal> enth&auml;lt, oder ob das
	Kernelmodul <filename>plip.ko</filename> geladen wurde. In
	beiden F&auml;llen sollte die parallele Schnittstelle
	von &man.ifconfig.8; angezeigt werden:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <para>Verbinden Sie die parallelen Schnittstellen der beiden
	Computer &uuml;ber das (Laplink-)Kabel.</para>

      <para>Konfigurieren Sie die Netzwerkparameter auf beiden Rechnern
	als <username>root</username>.  Wenn Sie beispielsweise den Rechner
	<hostid>host1</hostid> mit dem Rechner <hostid>host2</hostid>
	verbinden wollen, gehen Sie folgenderma&szlig;en vor:</para>

      <programlisting>                 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</programlisting>

      <para>Richten Sie die parallele Schnittstelle von
	<hostid>host1</hostid> ein, indem Sie Folgendes eingeben:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.1 10.0.0.2</userinput></screen>

      <para>Danach richten Sie die parallele Schnittstelle von
	<hostid>host2</hostid> ein:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.2 10.0.0.1</userinput></screen>

      <para>Sie sollten nun &uuml;ber eine funktionierende Verbindung
	verf&uuml;gen.  Bei Problemen lesen Sie bitte die Hilfeseiten
	&man.lp.4; sowie &man.lpt.4;.</para>

      <para>Zus&auml;tzlich sollten beide Rechner in
	<filename>/etc/hosts</filename> eingetragen werden:</para>

      <programlisting>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain</programlisting>

      <para>Um die Verbindung zu &uuml;berpr&uuml;fen, pingen Sie jeden
	Rechner vom anderen Rechner aus an.  Auf <hostid>host1</hostid>
	gehen Sie dazu folgenderma&szlig;en vor:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       plip0
&prompt.root; <userinput>ping -c 4 host2</userinput>
PING host2 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- host2 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>
    </sect2>
  </sect1>

  <sect1 id="network-ipv6">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Aaron</firstname>
          <surname>Kaplan</surname>
          <contrib>Beigetragen von </contrib>
         </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
          <contrib>&Uuml;berarbeitet und erweitert von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Brad</firstname>
          <surname>Davis</surname>
          <contrib>Erweitert von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>IPv6 &ndash; Internet Protocol Version 6</title>

    <para>Bei IPv6 (auch als IPng oder
      <foreignphrase>IP next generation</foreignphrase>
      bekannt) handelt es sich um die neueste Version des bekannten
      IP-Protokolls (das auch als <acronym>IPv4</acronym> bezeichnet
      wird).  FreeBSD enth&auml;lt, genauso wie die anderen frei
      erh&auml;ltlichen BSD-Systeme, die IPv6-Referenzimplementation
      von KAME.  FreeBSD erf&uuml;llt damit bereits
      alle f&uuml;r die Nutzung von IPv6 n&ouml;tigen Voraussetzungen.
      Dieser Abschnitt konzentriert sich daher auf die Konfiguration
      und den Betrieb von IPv6.</para>

    <para>Anfang der 90er Jahre wurde man auf den stark steigenden
      Verbrauch von IPv4-Adressen aufmerksam.  Im Hinblick auf das
      Wachstums des Internets gab es zwei Hauptsorgen:</para>

    <itemizedlist>
      <listitem>
        <para>Die drohende Knappheit von IPv4-Adressen.  Dieses Problem
          konnte durch die Einf&uuml;hrung von privaten
          Adressr&auml;umen gem&auml;&szlig; RFC1918 (mit Adressen wie
          <hostid role="ipaddr">10.0.0.0/8</hostid>,
          <hostid role="ipaddr">172.16.0.0/12</hostid>, oder
          <hostid role="ipaddr">192.168.0.0/16</hostid>) sowie der
          Entwicklung von <foreignphrase>Network Address
          Translation</foreignphrase> (<acronym>NAT</acronym>)
          weitestgehend entsch&auml;rft werden.</para>
      </listitem>

      <listitem>
        <para>Die immer gr&ouml;&szlig;er werdenden Eintr&auml;ge in
          Router-Tabellen.  Dieses Problem ist auch heute noch
          aktuell.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 ist in der Lage, diese, aber auch viele andere Probleme
      zu l&ouml;sen:</para>

    <itemizedlist>
      <listitem>
        <para>IPv6 hat einen 128&nbsp;Bit gro&szlig;en Adressraum. Es sind
          also theoretisch
          340.282.366.920.938.463.463.374.607.431.768.211.456 Adressen
          verf&uuml;gbar.  In anderen Worten: F&uuml;r jeden
          Quadratmeter der Erdoberfl&auml;che sind etwa
          6,67&nbsp;*&nbsp;10^27 IPv6-Adressen verf&uuml;gbar.</para>
      </listitem>

      <listitem>
        <para>Router speichern nur noch Netzwerk-Aggregationsadressen in
          Ihren Routingtabellen.  Dadurch reduziert sich die
          durchschnittliche Gr&ouml;&szlig;e  einer Routingtabelle auf
          8192&nbsp;Eintr&auml;ge.</para>
      </listitem>
    </itemizedlist>

    <para>Weitere n&uuml;tzliche Eigenschaften von IPv6 sind:</para>

    <itemizedlist>
      <listitem>
        <para>Die automatische Konfiguration von Adressen, die im
          <ulink url="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</ulink>
          beschrieben wird.</para>
      </listitem>

      <listitem>
        <para>Anycast-Adressen (<quote>eine-von-vielen</quote>)</para>
      </listitem>

      <listitem>
        <para>Verpflichtende Multicast-Adressen</para>
      </listitem>

      <listitem>
        <para>Die Unterst&uuml;tzung von IPsec (IP-Security)</para>
      </listitem>

      <listitem>
        <para>Eine vereinfachte Headerstruktur</para>
      </listitem>

      <listitem>
        <para>Mobile <acronym>IP</acronym>-Adressen</para>
      </listitem>

      <listitem>
        <para>Die Umwandlung von IPv4- in IPv6-Adressen</para>
      </listitem>
    </itemizedlist>

    <para>Weitere Informationsquellen:</para>

    <itemizedlist>
      <listitem>
        <para>Beschreibung von IPv6 auf
          <ulink url="http://playground.sun.com/pub/ipng/html/ipng-main.html">playground.sun.com</ulink>
        </para>
      </listitem>

      <listitem>
        <para><ulink url="http://www.kame.net">KAME.net</ulink></para>
      </listitem>

      <listitem>
        <para><ulink url="http://www.6bone.net">6bone.net</ulink></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Hintergrundinformationen zu IPv6-Adressen</title>

      <para>Es gibt verschiedene Arten von IPv6-Adressen: Unicast-,
        Anycast- und Multicast-Adressen.</para>

      <para>Unicast-Adressen sind die herk&ouml;mlichen Adressen. Ein
        Paket, das an eine Unicast-Adresse gesendet wird, kommt nur an
        der Schnittstelle an, die dieser Adresse zugeordnet ist.</para>

      <para>Anycast-Adressen unterscheiden sich in ihrer Syntax nicht
        von Unicast-Adressen, sie w&auml;hlen allerdings aus
	mehreren Schnittstellen eine Schnittstelle aus.
	Ein f&uuml;r eine Anycast-Adresse
	bestimmtes Paket kommt an der n&auml;chstgelegenen
	(entsprechend der Router-Metrik) Schnittstelle
        an.  Anycast-Adressen werden nur von Routern verwendet.</para>

      <para>Multicast-Adressen bestimmen Gruppen, denen mehrere
        Schnittstellen angeh&ouml;ren.  Ein
        Paket, das an eine Multicast-Adresse geschickt wird, kommt an
        allen Schnittstellen an, die zur Multicast-Gruppe geh&ouml;ren.</para>

        <note><para>Die von IPv4 bekannte Broadcast-Adresse
          (normalerweise
          <hostid role="ipaddr">xxx.xxx.xxx.255</hostid>) wird bei IPv6
          durch Multicast-Adressen verwirklicht.</para></note>

      <table frame="none">
        <title>Reservierte IPv6-Adressen</title>

        <tgroup cols="4">
          <thead>
            <row>
              <entry>IPv6-Adresse</entry>
              <entry>Pr&auml;fixl&auml;nge</entry>
              <entry>Beschreibung</entry>
              <entry>Anmerkungen</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><hostid role="ip6addr">::</hostid></entry>
              <entry>128 Bit</entry>
              <entry>nicht festgelegt</entry>
              <entry>entspricht <hostid role="ipaddr">0.0.0.0</hostid>
                bei IPv4</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">::1</hostid></entry>
              <entry>128 Bit</entry>
              <entry>Loopback-Adresse</entry>
              <entry>entspricht <hostid role="ipaddr">127.0.0.1</hostid>
                bei IPv4</entry>
            </row>

            <row>
              <entry><hostid
                role="ip6addr">::00:xx:xx:xx:xx</hostid></entry>
              <entry>96 Bit</entry>
              <entry>Eingebettete IPv4-Adresse</entry>
              <entry>Die niedrigen 32&nbsp;Bit entsprechen der IPv4-Adresse.
                Wird auch als <quote>IPv4-kompatible IPv6-Adresse
                bezeichnet</quote>.</entry>
	    </row>

            <row>
              <entry><hostid
                role="ip6addr">::ff:xx:xx:xx:xx</hostid></entry>
              <entry>96 Bit</entry>
	      <entry>Eine auf IPv6 abgebildete IPv4-Adresse</entry>
              <entry>Die niedrigen 32&nbsp;Bit entsprechen der IPv4-Adresse.
                Notwendig f&uuml;r Rechner, die IPv6 nicht
                unterst&uuml;tzen.</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">fe80::</hostid> - <hostid
                role="ip6addr">feb::</hostid></entry>
              <entry>10 Bit</entry>
              <entry><foreignphrase>link-local</foreignphrase></entry>
              <entry>Entspricht der Loopback-Adresse bei IPv4</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">fec0::</hostid> - <hostid
                role="ip6addr">fef::</hostid></entry>
              <entry>10 Bit</entry>
              <entry><foreignphrase>site-local</foreignphrase></entry>
              <entry>&nbsp;</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">ff::</hostid></entry>
              <entry>8 Bit</entry>
              <entry>Multicast</entry>
              <entry>&nbsp;</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">001</hostid>
		(im Dualsystem)</entry>
              <entry>3 Bit</entry>
              <entry>Globaler Unicast</entry>
              <entry>Alle globalen Unicastadressen stammen aus diesem
                Pool.  Die ersten 3&nbsp;Bit lauten <quote>001</quote>.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2>
      <title>IPv6-Adressen verstehen</title>

      <para>Die kanonische Form von IPv6-Adressen lautet
        <hostid role="ip6addr">x:x:x:x:x:x:x:x</hostid>, jedes
        <quote>x</quote> steht dabei f&uuml;r einen
        16-Bit-Hexadezimalwert.  Ein Beispiel f&uuml;r eine IPv6-Adresse
        w&auml;re etwa
        <hostid
        role="ip6addr">FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</hostid>.</para>

      <para>Eine IPv6-Adresse enth&auml;lt oft Teilzeichenfolgen aus lauter
        Nullen.  Eine solche Zeichenfolge kann zu <quote>::</quote>
        verk&uuml;rzt werden.  Bis zu drei f&uuml;hrende Nullen eines
        Hexquads k&ouml;nnen ebenfalls weggelassen werden.
        <hostid role="ip6addr">fe80::1</hostid> entspricht also der Adresse
        <hostid role="ip6addr">fe80:0000:0000:0000:0000:0000:0000:0001</hostid>.
      </para>

      <para>Eine weitere M&ouml;glichkeit ist die Darstellung der
        letzten 32&nbsp;Bit in  der bekannten (dezimalen) IPv4-Darstellung,
        bei der Punkte (<quote>.</quote>) zur Trennung verwendet werden.
        <hostid role="ip6addr">2002::10.0.0.1</hostid> ist also nur eine
        andere Schreibweise f&uuml;r die (hexadezimale) kanonische Form
        <hostid role="ip6addr">2002:0000:0000:0000:0000:0000:0a00:0001</hostid>,
        die wiederum der Adresse
        <hostid role="ip6addr">2002::a00:1</hostid> entspricht.</para>

      <para>Sie sollten nun in der Lage sein, die folgende Ausgabe zu
        verstehen:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput>
rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</screen>

      <para>Bei
        <hostid role="ip6addr">fe80::200:21ff:fe03:8e1%rl0</hostid>
        handelt es sich um eine automatisch konfigurierte
        <foreignphrase>link-local</foreignphrase>-Adresse.  Sie
        wird im Rahmen der automatischen Konfiguration aus der
        MAC-Adresse erzeugt.</para>

      <para>Weitere Informationen zum Aufbau von IPv6-Adressen finden
        Sie im <ulink url="http://www.ietf.org/rfc/rfc3513.txt">
        RFC3513</ulink>.</para>
    </sect2>

    <sect2>
      <title>Eine IPv6-Verbindung herstellen</title>

      <para>Es gibt derzeit vier M&ouml;glichkeiten, sich mit anderen
        IPv6-Rechnern oder Netzwerken zu verbinden:</para>

      <itemizedlist>
        <listitem>
          <para>Die Teilnahme am experimentellen 6bone.</para>
        </listitem>

        <listitem>
          <para>Die Teilnahme am IPv6-Netzwerk Ihres Providers.
            Wenn Sie daran interessiert sind, wenden Sie sich an Ihren
            Provider.</para>
        </listitem>

        <listitem>
          <para>Die Verwendung eines 6-nach-4-Tunnels
            (<ulink
            url="http://www.ietf.org/rfc/rfc3068.txt">RFC3068</ulink>).</para>
        </listitem>

        <listitem>
          <para>Die Verwendung des Ports
            <filename>/usr/ports/net/freenet6</filename> bei der Einwahl
            ins Internet.</para>
        </listitem>
      </itemizedlist>

      <para>In diesem Abschnitt wird die Einrichtung einer Verbindung
        zum 6bone beschrieben, da dies derzeit der beliebteste Weg ist.</para>

      <para>Suchen Sie sich zuerst auf der Internetseite des
	<ulink url="http://www.6bone.net">6bone-Projekts</ulink>
	einen 6bone-Knoten in Ihrer N&auml;he.  Schreiben Sie an
	die verantwortliche Person und mit etwas Gl&uuml;ck erhalten
	Sie entsprechende Anweisungen, um Ihre Verbindung einzurichten.
	Dazu geh&ouml;rt &uuml;blicherweise die Einrichtung
	eines GRE-(gif)-Tunnels.</para>

      <para>Typischerweise wird ein  &man.gif.4;-Tunnels wie folgt
	eingerichtet:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput>
&prompt.root; <userinput>ifconfig gif0</userinput>
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>MY_IPv4_ADDR MY_IPv4_REMOTE_TUNNEL_ENDPOINT_ADDR</replaceable></userinput>
&prompt.root; <userinput>ifconfig gif0 inet6 alias <replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</replaceable></userinput></screen>

      <para>Ersetzen Sie die in Gro&szlig;buchstaben geschriebenen
        Werte durch die Informationen, die Sie f&uuml;r Ihren
        6bone-Knoten erhalten haben.</para>

      <para>Die gezeigten Befehle bauen den Tunnel auf.
        &Uuml;berpr&uuml;fen Sie die korrekte Funktion, indem Sie
        <hostid role="ip6addr">ff02::1%gif0</hostid> an&man.ping6.8;en.
        Sie sollten zwei Antworten erhalten.</para>

      <note>
	<para>Bei <hostid role="ip6addr">ff02:1%gif0</hostid>
          handelt es sich um eine Multicast-Adresse.
          <literal>%gif0</literal> legt fest, dass die Multicast-Adresse
          der Schnittstelle <devicename>gif0</devicename> verwendet
          werden soll.  Da wir
          eine Multicast-Adresse ange&man.ping6.8;t haben, sollte der
          andere Endpunkt des Tunnels ebenfalls antworten.</para>
      </note>

      <para>Eine Route zu Ihrem 6bone-Knoten k&ouml;nnen Sie
	einfach wie folgt einrichten:</para>

      <screen>&prompt.root; <userinput>route add -inet6 default -interface gif0</userinput>
&prompt.root; <userinput>ping6 -n <replaceable>MY_UPLINK</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>traceroute6 www.jp.FreeBSD.org</userinput>
(3ffe:505:2008:1:2a0:24ff:fe57:e561) from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1  atnet-meta6  14.147 ms  15.499 ms  24.319 ms
     2  6bone-gw2-ATNET-NT.ipv6.tilab.com  103.408 ms  95.072 ms *
     3  3ffe:1831:0:ffff::4  138.645 ms  134.437 ms  144.257 ms
     4  3ffe:1810:0:6:290:27ff:fe79:7677  282.975 ms  278.666 ms  292.811 ms
     5  3ffe:1800:0:ff00::4  400.131 ms  396.324 ms  394.769 ms
     6  3ffe:1800:0:3:290:27ff:fe14:cdee  394.712 ms  397.19 ms  394.102 ms</screen>

      <para>Diese Ausgabe kann auf Ihrem Rechner unterschiedlich sein.
        Sie sollten aber jetzt die IPv6-Seite
        <ulink url="http://www.kame.net">www.kame.net</ulink> erreichen
        und die tanzende Schildkr&ouml;te sehen k&ouml;nnen &ndash;
        vorausgesetzt, Sie haben einen IPv6-f&auml;higen Browser wie
        <filename role="package">www/mozilla</filename>,
        <application>Konqueror</application> (als Teil des Pakets
        <filename role="package">x11/kdebase3</filename>) oder
        <filename role="package">www/epiphany</filename>
        installiert.</para>
    </sect2>

    <sect2>
      <title>DNS in der IPv6-Welt</title>

      <para>Urspr&uuml;nglich gab es zwei verschiedene DNS-Eintr&auml;ge
        f&uuml;r IPv6.  Da A6-Eintr&auml;ge von der IETF f&uuml;r
        obsolet erkl&auml;rt wurden, sind AAAA-Eintr&auml;ge nun
        Standard.</para>

      <para>Weisen Sie die erhaltene IPv6-Adresse Ihrem Rechnernamen zu,
        indem Sie den Eintrag</para>

      <programlisting>MYHOSTNAME           AAAA    MYIPv6ADDR</programlisting>

      <para>in Ihre prim&auml;re DNS-Zonendatei einf&uuml;gen.  Falls
        Sie nicht f&uuml;r Ihre <acronym>DNS</acronym>-Zone
        verantwortlich sind, bitten Sie den daf&uuml;r
        Zust&auml;ndigen, diese &Auml;nderung durchzuf&uuml;hren.
        Die aktuellen Versionen von <application>bind</application>
        (Version&nbsp;8.3 oder 9) sowie
        <filename role="package">dns/djbdns</filename> (bei Verwendung
        des IPv6-Patches) unterst&uuml;tzen AAAA-Eintr&auml;ge.</para>
    </sect2>

    <sect2>
      <title><filename>/etc/rc.conf</filename> f&uuml;r die Nutzung von
        IPv6 anpassen</title>

      <sect3>
        <title>Einen Client unter IPv6 einrichten</title>

        <para>Dieser Abschnitt beschreibt die Konfiguration eines
          Rechners, der in Ihrem LAN als Client, aber nicht als Router
          verwendet wird.  Um die Schnittstelle w&auml;hrend des
          Systemstarts mit &man.rtsol.8; automatisch einzurichten,
          f&uuml;gen Sie folgende Zeile in
          <filename>/etc/rc.conf</filename> ein:</para>

        <programlisting>ipv6_enable="YES"</programlisting>

        <para>Durch die folgende Zeile weisen Sie Ihrer Schnittstelle
          <devicename>fxp0</devicename> die statische IP-Adresse <hostid
          role="ip6addr">2001:471:1f11:251:290:27ff:fee0:2093</hostid>
          zu:</para>

        <programlisting>ipv6_ifconfig_fxp0="2001:471:1f11:251:290:27ff:fee0:2093"</programlisting>

        <para>Um <hostid role="ip6addr">2001:471:1f11:251::1</hostid>
          als Standardrouter festzulegen, f&uuml;gen Sie folgende Zeile
          in <filename>/etc/rc.conf</filename> ein:</para>

        <programlisting>ipv6_defaultrouter="2001:471:1f11:251::1"</programlisting>
      </sect3>

      <sect3>
        <title>Gateways und Router unter IPv6 einrichten</title>

        <para>Dieser Abschnitt beschreibt, wie Sie Ihren Rechner mit
          Hilfe der von Ihrem Tunnel-Anbieter, beispielsweise
          <ulink url="http://www.6bone.net/">6bone</ulink>, erhaltenen
          Anweisungen dauerhaft f&uuml;r die Nutzung von IPv6
          einrichten.  Um den Tunnel beim Systemstart
          wiederherzustellen, passen Sie
          <filename>/etc/rc.conf</filename> wie folgt an:</para>

        <para>Listen Sie die einzurichtenden Tunnelschnittstellen
          (hier <devicename>gif0</devicename>) auf:</para>

        <programlisting>gif_interfaces="gif0"</programlisting>

        <para>Um den lokalen Endpunkt
          <replaceable>MY_IPv4_ADDR</replaceable> &uuml;ber diese
          Schnittstelle mit dem entfernten Endpunkt
          <replaceable>REMOTE_IPv4_ADDR</replaceable> zu
          verbinden, verwenden Sie folgende Zeile:</para>

        <programlisting>gifconfig_gif0="<replaceable>MY_IPv4_ADDR REMOTE_IPv4_ADDR</replaceable>"</programlisting>

        <para>Um die Ihnen zugewiesene IPv6-Adresse als Endpunkt Ihres
          IPv6-Tunnels zu verwenden, f&uuml;gen Sie folgende Zeile
          ein:</para>

        <programlisting>ipv6_ifconfig_gif0="<replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>

        <para>Nun m&uuml;ssen Sie nur noch die IPv6-Standardroute
          angeben.  Diese legt das andere Ende des IPv6-Tunnels
          fest.</para>

        <programlisting>ipv6_defaultrouter="<replaceable>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>
      </sect3>

      <sect3>
        <title>Einen IPv6-Tunnel einrichten</title>

        <para>Wenn Ihr Server IPv6-Verkehr zwischen Ihrem Netzwerk und
          der Au&szlig;enwelt routen muss, ben&ouml;tigen Sie
          zus&auml;tzlich die folgenden Zeilen in Ihrer
          <filename>/etc/rc.conf</filename>:</para>

        <programlisting>ipv6_gateway_enable="YES"</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Bekanntmachung von Routen und automatische
        Rechnerkonfiguration</title>

      <para>Dieser Abschnitt beschreibt die Einrichtung von
        &man.rtadvd.8;, das Sie bei der Bekanntmachung der
        IPv6-Standardroute unterst&uuml;tzt.</para>

      <para>Um &man.rtadvd.8; zu aktivieren, f&uuml;gen Sie folgende
        Zeile in <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>rtadvd_enable="YES"</programlisting>

      <para>Es ist wichtig, die Schnittstelle anzugeben, &uuml;ber die
        IPv6-Routen bekanntgemacht werden sollen.  Soll &man.rtadvd.8;
        <devicename>fxp0</devicename> verwenden, ist folgender Eintrag
        n&ouml;tig:</para>

      <programlisting>rtadvd_interfaces="fxp0"</programlisting>

      <para>Danach erzeugen Sie die Konfigurationsdatei
        <filename>/etc/rtadvd.conf</filename>.  Dazu ein Beispiel:</para>

      <programlisting>fxp0:\
    :addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:</programlisting>

      <para>Ersetzen Sie dabei <devicename>fxp0</devicename> durch die
        zu verwendende Schnittstelle.</para>

      <para>Anschlie&szlig;end ersetzen Sie
        <hostid role="ip6addr">2001:471:1f11:246::</hostid> durch das
        Pr&auml;fix der Ihnen zugewiesenen Verbindung.</para>

      <para>Wenn Sie eine <hostid role="netmask">/64</hostid>-Netzmaske
        verwenden, m&uuml;ssen Sie keine weiteren Anpassungen vornehmen.
        Anderenfalls m&uuml;ssen Sie <literal>prefixlen#</literal>
        auf den korrekten Wert setzen.</para>
    </sect2>
  </sect1>

  <sect1 id="network-atm">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Harti</firstname>
          <surname>Brandt</surname>
          <contrib>Beigetragen von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>ATM - Asynchronous Transfer Mode</title>

    <sect2>
      <title><foreignphrase>Classical IP over ATM</foreignphrase>
        als PVC-Verbindung einrichten</title>

      <para><foreignphrase>Classical IP over ATM</foreignphrase>
        (<acronym>CLIP</acronym>) ist die einfachste M&ouml;glichkeit,
        um IP-Verkehr &uuml;ber ATM (<foreignphrase>Asynchronous
        Transfer Mode</foreignphrase>-Verbindungen zu &uuml;bertragen.
        CLIP kann sowohl mit geschalteten Verbindungen (SVCs) als auch
        mit permanenten Verbindungen (PVCs) verwendet werden.  Dieser
        Abschnitt beschreibt die Einrichtung eines PVC-basierten
        Netzwerks.</para>

      <sect3>
        <title>Ein vollst&auml;ndig vermaschtes Netzwerk aufbauen</title>

        <para>Bei einem vollst&auml;ndig vermaschten
          (<foreignphrase>fully meshed</foreignphrase>) Netzwerk ist
          jeder Rechner &uuml;ber eine dezidierte Verbindung mit jedem
          anderen Rechner des Netzwerks verbunden.  Die Konfiguration
          ist - vor allem f&uuml;r kleinere Netzwerke - relativ einfach.
          Unser Beispielnetzwerk besteht aus vier Rechnern, die jeweils
          &uuml;ber eine
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Adapterkarte
          mit dem
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Netzwerk
          verbunden sind.  Als ersten Konfigurationsschritt planen wir
          die Vergabe von IP-Adressen sowie die anzulegenden
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Verbindungen:
        </para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="1*">
	    <thead>
	      <row>
		<entry>Rechner</entry>
		<entry>IP-Adresse</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><hostid>hostA</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.1</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.2</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostC</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.3</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostD</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.4</hostid></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Um ein vollst&auml;ndiges Netz aufzubauen, ben&ouml;tigen
          wir f&uuml;r jedes Rechnerpaar eine eigene ATM-Verbindung:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="1*">
	    <thead>
	      <row>
		<entry>Rechnerpaar</entry>
		<entry>VPI.VCI-Paar</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostB</hostid></entry>
		<entry>0.100</entry>
	      </row>

	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostC</hostid></entry>
		<entry>0.101</entry>
	      </row>

	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.102</entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid> - <hostid>hostC</hostid></entry>
		<entry>0.103</entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.104</entry>
	      </row>

	      <row>
		<entry><hostid>hostC</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.105</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Die Werte VPI und VCI an den Verbindungsenden k&ouml;nnen
          nat&uuml;rlich unterschiedlich sein.  Wir nehmen hier aber an,
          dass sie gleich sind.  Nun m&uuml;ssen wir die
          ATM-Schnittstellen auf jedem Rechner einrichten:</para>

        <screen>hostA&prompt.root; <userinput>ifconfig hatm0 192.168.173.1 up</userinput>
hostB&prompt.root; <userinput>ifconfig hatm0 192.168.173.2 up</userinput>
hostC&prompt.root; <userinput>ifconfig hatm0 192.168.173.3 up</userinput>
hostD&prompt.root; <userinput>ifconfig hatm0 192.168.173.4 up</userinput></screen>

        <para>Dabei setzen wir voraus, dass
          <devicename>hatm0</devicename> auf allen Rechnern die
          ATM-Schnittstelle darstellt.  Danach werden, beginnend mit
          <hostid>hostA</hostid>, die PVCs auf den einzelnen Rechnern
          eingerichtet (Wir nehmen an, dass die PVCs auf den
          ATM-Switches bereits eingerichet sind.  Lesen Sie die
          entsprechenden Handb&uuml;cher, wenn Sie einen Switch
          einrichten m&uuml;ssen.):</para>

        <screen>hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr</userinput>

hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr</userinput>

hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr</userinput>

hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</userinput></screen>

        <para>Statt UBR k&ouml;nnen auch andere
          <foreignphrase>traffic contracts</foreignphrase> verwendet
          werden.  Voraussetzung ist allerdings, dass diese von Ihrem
          ATM-Adapter unterst&uuml;tzt werden.  Ist dies der Fall,
          folgen auf den Namen des
          <foreignphrase>traffic contracts</foreignphrase> die
          entsprechenden Konfigurationsparameter.  Weitere Informationen
          zur Konfiguration von ATM-Adapterkarten erhalten Sie &uuml;ber
          den Befehl</para>

        <screen>&prompt.root; <userinput>atmconfig help natm add</userinput></screen>

        <para>oder durch das Lesen von &man.atmconfig.8;.</para>

        <para>Die Konfiguration von ATM-Adaptern kann auch &uuml;ber die
          Datei <filename>/etc/rc.conf</filename> erfolgen.  F&uuml;r
          <hostid>hostA</hostid> s&auml;he die Konfiguration so
          aus:</para>

        <programlisting>network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"</programlisting>

        <para>Mit dem folgenden Befehl l&auml;sst sich der derzeitige
          Status aller <acronym>CLIP</acronym>-Routen anzeigen:</para>

        <screen>hostA&prompt.root; <userinput>atmconfig natm show</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
