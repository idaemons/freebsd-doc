<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/advanced-networking/chapter.sgml,v 1.57 2003/05/27 00:30:55 mheinen Exp $
     basiert auf: 1.222
-->

<chapter id="advanced-networking">
  <chapterinfo>
    <authorgroup>
      <author>
	  <firstname>Johann</firstname>
	  <surname>Kois</surname>
	  <contrib>&Uuml;bersetzt von </contrib>
	  <!-- j.kois@web.de, 02. Februar 2003 -->
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Weiterf&uuml;hrende Netzwerkthemen</title>

  <sect1 id="advanced-networking-synopsis">

    <title>&Uuml;bersicht</title>

    <para>Dieses Kapitel beschreibt einige der h&auml;ufiger
      verwendeten Netzwerkdienste auf UNIX-Systemen.  Es wird
      beschrieben, wie die von FreeBSD verwendeten Netzwerkdienste
      installiert, getestet und gewartet werden.  Zus&auml;tzlich sind
      im ganzen Kapitel Beispielkonfigurationsdateien vorhanden, von
      denen Sie sicherlich profitieren werden.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen von Gateways und Routen kennen.</para>
      </listitem>

      <listitem>
	<para>Eine Bridge unter FreeBSD einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Ein Netzwerkdateisystem (NFS) einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Einen plattenlosen Rechner &uuml;ber das Netzwerk starten
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Einen Netzwerkinformationsserver (NIS) f&uuml;r gemeinsame
	  Benutzerkonten einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Automatische Netzwerkeinstellungen mittels DHCP vornehmen
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Einen Domain Name Server (DNS) einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Unter Verwendung des NTP-Protokolls Uhrzeit und Datum
	  synchronisieren, sowie einen Zeitserver einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man NAT (Network Address Translation)
	  einrichtet.</para>
      </listitem>

      <listitem>
	<para>In der Lage sein, den <command>inetd</command>-Daemon
	  einzurichten.</para>
      </listitem>

      <listitem>
	<para>Zwei Computer &uuml;ber PLIP verbinden k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>IPv6 auf einem FreeBSD-Rechner einrichten k&ouml;nnen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen der <filename>/etc/rc</filename>-Skripte
	  verstanden haben.</para>
      </listitem>

      <listitem>
	<para>Mit der grundlegenden Netzwerkterminologie vertraut
	  sein.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="network-routing">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Coranth</firstname>
	  <surname>Gryphon</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Gateways und Routen</title>

    <indexterm>
      <primary>Routing</primary>
    </indexterm>
    <indexterm>
      <primary>Gateway</primary>
    </indexterm>
    <indexterm>
      <primary>Subnetz</primary>
    </indexterm>

    <para>Damit ein Rechner einen anderen &uuml;ber ein Netzwerk
      finden kann, muss ein Mechanismus vorhanden sein, der
      beschreibt, wie man von einem Rechner zum anderen gelangt.
      Dieser Vorgang wird als <firstterm>Routing</firstterm>
      bezeichnet.  Eine <quote>Route</quote> besteht aus einem
      definierten Adressenpaar: Einem <quote>Ziel</quote> und einem
      <quote>Gateway</quote>.  Dieses Paar zeigt an, dass Sie
      &uuml;ber den <emphasis>Gateway</emphasis> zum
      <emphasis>Ziel</emphasis> gelangen wollen.  Es gibt drei Arten
      von Zielen: Einzelne Rechner (Hosts), Subnetze und das
      <quote>Standard</quote>ziel.  Die <quote>Standardroute</quote>
      wird verwendet, wenn keine andere Route zutrifft.  Wir werden
      Standardrouten sp&auml;ter etwas genauer behandeln.  Au&szlig;erdem
      gibt es drei Arten von Gateways: Einzelne Rechner (Hosts),
      Schnittstellen (Interfaces, auch als <quote>Links</quote>
      bezeichnet), sowie Ethernet Hardware-Adressen (MAC
      Adressen).</para>

    <sect2>
      <title>Ein Beispiel</title>

      <para>Um die verschiedenen Aspekte des Routings zu
	veranschaulichen, verwenden wir folgende Ausgaben von
	<command>netstat</command>:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination               Gateway            Flags       Refs     Use     Netif Expire

default                   outside-gw         UGSc        37       418     ppp0
localhost                 localhost          UH          0        181     lo0
test0                     0:e0:b5:36:cf:4f   UHLW        5        63288   ed0    77
10.20.30.255              link#1             UHLW        1        2421
example.com               link#1             UC          0        0
host1                     0:e0:a8:37:8:1e    UHLW        3        4601    lo0
host2                     0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>
host2.example.com         link#1             UC          0        0
224                       link#1             UC          0        0
</screen>

      <indexterm>
	<primary>Default-Route</primary>
      </indexterm>
      <indexterm>
	<primary>Standardroute</primary>
      </indexterm>

      <para>Die ersten zwei Zeilen geben die Standardroute (die wir
	im <link linkend="network-routing-default"> n&auml;chsten
	Abschnitt</link> behandeln), sowie die
	<hostid>localhost</hostid> Route an.</para>

      <indexterm>
	<primary>Loopback-Ger&auml;t</primary>
      </indexterm>

      <para>Das in der Routingtabelle f&uuml;r
	<literal>localhost</literal> festgelegte Interface
	(<literal>Netif</literal>-Spalte)
	<devicename>lo0</devicename>, ist auch als loopback-Ger&auml;t
	(Pr&uuml;fschleife) bekannt.  Das hei&szlig;t, dass der ganze
	Datenverkehr f&uuml;r dieses Ziel intern (innerhalb des
	Ger&auml;tes) bleibt, anstatt ihn &uuml;ber ein Netzwerk (LAN)
	zu versenden, da das Ziel dem Start entspricht.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC-Adresse</secondary>
      </indexterm>

      <para>Der n&auml;chste auff&auml;llige Punkt sind die mit
	<hostid role="mac">0:e0:</hostid> beginnenden Adressen.  Es
	handelt sich dabei um Ethernet Hardwareadressen, die auch als
	MAC-Adressen bekannt sind.  FreeBSD identifiziert Rechner im
	lokalen Netz automatisch (im Beispiel <hostid>test0</hostid>)
	und f&uuml;gt eine direkte Route zu diesem Rechner hinzu.  Dies
	passiert &uuml;ber die Ethernet Schnittstelle
	<devicename>ed0</devicename>.  Au&szlig;erdem existiert ein Timeout
	(in der Spalte <literal>Expire</literal>) f&uuml;r diese Art
	von Routen, der verwendet wird, wenn dieser Rechner in einem
	definierten Zeitraum nicht reagiert.  Wenn dies passiert, wird
	die Route zu diesem Rechner automatisch gel&ouml;scht.
	Rechner im lokalen Netz werden durch einen als RIP (Routing
	Information Protocol) bezeichneten Mechanismus identifiziert,
	der den k&uuml;rzesten Weg zu den jeweiligen Rechnern
	bestimmt.</para>

      <indexterm>
	<primary>Subnetz</primary>
      </indexterm>

      <para>FreeBSD f&uuml;gt au&szlig;erdem Subnetzrouten f&uuml;r das
	lokale Subnetz hinzu (<hostid
	role="ipaddr">10.20.30.255</hostid> ist die Broadcast-Adresse
	f&uuml;r das Subnetz <hostid role="ipaddr">10.20.30</hostid>,
	<hostid role="domainname">example.com</hostid> ist der zu
	diesem Subnetz geh&ouml;rige Domainname).  Das Ziel
	<literal>link#1</literal> bezieht sich auf die erste
	Ethernet-Karte im Rechner.  Sie k&ouml;nnen auch feststellen,
	dass keine zus&auml;tzlichen Schnittstellen angegeben
	sind.</para>

      <para>Routen f&uuml;r Rechner im lokalen Netz und lokale
	Subnetze werden automatisch durch den
	<application>routed</application> Daemon konfiguriert.  Ist
	dieser nicht gestartet, sind nur statisch definierte
	(explizit eingegebene) Routen vorhanden.</para>

      <para>Die Zeile <literal>host1</literal> bezieht sich auf
	unseren Rechner, der durch seine Ethernetadresse bekannt ist.
	Da unser Rechner der Sender ist, verwendet FreeBSD automatisch
	das Loopback-Ger&auml;t (<devicename>lo0</devicename>),
	anstatt den Datenverkehr &uuml;ber die Ethernetschnittstelle
	zu senden.</para>

      <para>Die zwei <literal>host2</literal> Zeilen sind ein Beispiel
	daf&uuml;r, was passiert, wenn wir ein &man.ifconfig.8; Alias
	verwenden (Lesen Sie dazu den Abschnitt &uuml;ber Ethernet,
	wenn Sie wissen wollen, warum wir das tun sollten.).  Das
	Symbol <literal>=&gt;</literal> (nach der
	<devicename>lo0</devicename> Schnittstelle) sagt aus, dass wir
	nicht nur das Loopbackger&auml;t verwenden (da sich die
	Adresse auf den lokalen Rechner bezieht), sondern dass es sich
	zus&auml;tzlich auch um ein Alias handelt.  Solche Routen sind
	nur auf Rechnern vorhanden, die den Alias bereitstellen;
	alle anderen Rechner im lokalen Netz haben f&uuml;r solche
	Routen nur eine einfache <literal>link#1</literal>
	Zeile.</para>

      <para>Die letzte Zeile (Ziel Subnetz <literal>224</literal>)
	behandelt das Multicasting, das wir in einem anderen Abschnitt
	besprechen werden.</para>

      <para>Schlie&szlig;lich gibt es f&uuml;r Routen noch
	verschiedene Attribute, die Sie in der Spalte
	<literal>Flags</literal> finden.  Nachfolgend finden Sie eine
	kurze &Uuml;bersicht von einigen dieser Flags und ihrer
	Bedeutung:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>U</entry>

	      <entry>Up: Die Route ist aktiv.</entry>
	    </row>

	    <row>
	      <entry>H</entry>

	      <entry>Host: Das Ziel der Route ist ein einzelner
		Rechner (Host).</entry>
	    </row>

	    <row>
	      <entry>G</entry>

	      <entry>Gateway: Alle Daten, die an dieses Ziel gesendet
		werden, werden von diesem System an ihr jeweiliges
		Ziel weitergeleitet.</entry>
	    </row>

	    <row>
	      <entry>S</entry>

	      <entry>Static: Diese Route wurde manuell konfiguriert,
		das hei&szlig;t sie wurde <emphasis>nicht</emphasis>
		automatisch vom System erzeugt.</entry>
	    </row>

	    <row>
	      <entry>C</entry>

	      <entry>Clone: Erzeugt eine neue Route, basierend auf der
		Route f&uuml;r den Rechner, mit dem wir uns verbinden.
		Diese Routenart wird normalerweise f&uuml;r lokale
		Netzwerke verwendet.</entry>
	    </row>

	    <row>
	      <entry>W</entry>

	      <entry>WasCloned: Eine Route, die automatisch
		konfiguriert wurde.  Sie basiert auf einer lokalen
		Netzwerkroute (Clone).</entry>
	    </row>

	    <row>
	      <entry>L</entry>

	      <entry>Link: Die Route beinhaltet einen Verweis auf eine
		Ethernetkarte (MAC-Adresse).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 id="network-routing-default">
      <title>Standardrouten</title>

      <indexterm>
	<primary>Default-Route</primary>
      </indexterm>
      <indexterm>
	<primary>Standardroute</primary>
      </indexterm>

      <para>Wenn sich der lokale Rechner mit einem entfernten Rechner
	verbinden will, wird die Routingtabelle &uuml;berpr&uuml;ft,
	um festzustellen, ob bereits ein bekannter Pfad vorhanden ist.
	Geh&ouml;rt dieser entfernte Rechner zu einem Subnetz, dessen
	Pfad uns bereits bekannt ist (Cloned route), dann versucht der
	lokale Rechner &uuml;ber diese Schnittstelle eine Verbindung
	herzustellen.</para>

      <para>Wenn alle bekannten Pfade nicht funktionieren, hat der
	lokale Rechner eine letzte M&ouml;glichkeit: Die
	Standardroute (Default-Route).  Bei dieser
	Route handelt es sich um eine spezielle Gateway-Route
	(gew&ouml;hnlich die einzige im System vorhandene), die im
	Flags-Feld immer mit <literal>C</literal> gekennzeichnet ist.
	F&uuml;r Rechner im lokalen Netzwerk ist dieser Gateway auf
	<emphasis>welcher Rechner auch immer eine Verbindung nach
	au&szlig;en hat</emphasis> gesetzt (entweder &uuml;ber eine
	PPP-Verbindung, DSL, ein Kabelmodem, T1 oder eine beliebige
	andere Netzwerkverbindung).</para>

      <para>Wenn Sie die Standardroute f&uuml;r einen Rechner
	konfigurieren, der selbst als Gateway zur Au&szlig;enwelt
	funktioniert, wird die Standardroute zum Gateway-Rechner Ihres
	Internetanbieter (ISP) gesetzt.</para>

      <para>Sehen wir uns ein Beispiel f&uuml;r Standardrouten an.  So
	sieht eine &uuml;bliche Konfiguration aus:</para>

      <literallayout>
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
      </literallayout>

      <para>Die Rechner <hostid>Local1</hostid> und
	<hostid>Local2</hostid> befinden sich auf Ihrer Seite.
	<hostid>Local1</hostid> ist mit einem ISP &uuml;ber eine
	PPP-Verbindung verbunden.  Dieser PPP-Server ist &uuml;ber ein
	lokales Netzwerk mit einem anderen Gateway-Rechner verbunden,
	der &uuml;ber eine Schnittstelle die Verbindung des ISP zum
	Internet herstellt.</para>

      <para>Die Standardrouten f&uuml;r Ihre Maschinen lauten:</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Host</entry>

	      <entry>Standard Gateway</entry>

	      <entry>Schnittstelle</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>

	      <entry>Local1</entry>

	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>

	      <entry>T1-GW</entry>

	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Eine h&auml;ufig gestellte Frage lautet: <quote>Warum (oder wie)
	sollten wir <hostid>T1-GW</hostid> als Standard-Gateway
	f&uuml;r <hostid>Local1</hostid> setzen,
	statt den (direkt verbundenen) ISP-Server zu
	verwenden?</quote>.</para>

      <para>Bedenken Sie, dass die PPP-Schnittstelle f&uuml;r die
	Verbindung eine Adresse des lokalen Netzes des ISP verwendet.
	Daher werden Routen f&uuml;r alle anderen Rechner im lokalen
	Netz des ISP automatisch erzeugt.  Daraus folgt, dass Sie
	bereits wissen, wie Sie <hostid>T1-GW</hostid> erreichen
	k&ouml;nnen!  Es ist also unn&ouml;tig, einen Zwischenschritt
	&uuml;ber den ISP-Server zu machen.</para>

      <para>Es ist &uuml;blich, die Adresse <hostid
	role="ipaddr">X.X.X.1</hostid> als Gateway-Adresse f&uuml;r
	ihr lokales Netzwerk zu verwenden.  F&uuml;r unser Beispiel
	bedeutet dies Folgendes: Wenn Ihr lokaler Klasse-C-Adressraum
	<hostid role="ipaddr">10.20.30</hostid> ist und Ihr ISP
	<hostid role="ipaddr">10.9.9</hostid> verwendet, sehen die
	Standardrouten so aus:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Rechner (Host)</entry>

	      <entry>Standardroute</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>

	      <entry>Local1 (10.20.30.1)</entry>
	    </row>

	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>

	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Rechner mit zwei Heimatnetzen</title>

      <indexterm>
	<primary>Dual-Homed-Hosts</primary>
      </indexterm>

      <para>Es gibt noch eine Konfigurationsm&ouml;glichkeit, die wir
	besprechen sollten, und zwar Rechner, die sich in zwei
	Netzwerken befinden.  Technisch gesehen, z&auml;hlt jeder als
	Gateway arbeitende Rechner zu den Rechnern mit zwei
	Heimatnetzen (im obigen Beispiel unter Verwendung einer
	PPP-Verbindung).  In der Praxis meint man damit allerdings nur
	Rechner, die sich in zwei lokalen Netzen befinden.</para>

      <para>Entweder verf&uuml;gt der Rechner &uuml;ber zwei
	Ethernetkarten und jede dieser Karten hat eine Adresse in
	einem separaten Subnetz, oder der Rechner hat nur eine
	Ethernetkarte und verwendet &man.ifconfig.8; Aliasing.  Die
	erste M&ouml;glichkeit wird verwendet, wenn zwei physikalisch
	getrennte Ethernet-Netzwerke vorhanden sind, die zweite, wenn
	es nur ein physikalisches Ethernet-Netzwerk gibt, das aber aus
	zwei logisch getrennten Subnetzen besteht.</para>

      <para>In beiden F&auml;llen werden Routingtabellen erstellt,
	damit jedes Subnetz wei&szlig;, dass dieser Rechner als Gateway zum
	anderen Subnetz arbeitet (<foreignphrase>inbound
	  route</foreignphrase>).  Diese Konfiguration
	(der Gateway-Rechner arbeitet als Router zwischen den
	Subnetzen) wird h&auml;ufig verwendet, wenn es darum geht,
	Paketfilterung oder eine Firewall (in eine oder beide
	Richtungen) zu implementieren.</para>

      <para>Wenn Sie m&ouml;chten, dass dieser Rechner Pakete zwischen
	den beiden Schnittstellen weiterleitet, m&uuml;ssen Sie diese
	Funktion manuell konfigurieren und aktivieren.</para>
    </sect2>

    <sect2 id="network-dedicated-router">
      <title>Einen Router konfigurieren</title>

      <indexterm>
	<primary>Router</primary>
      </indexterm>

      <para>Ein Netzwerkrouter ist einfach ein System, das Pakete von
	einer Schnittstelle zur anderen weiterleitet.
	Internetstandards und gute Ingenieurspraxis sorgten
	daf&uuml;r, dass diese Funktion in FreeBSD per Voreinstellung
	deaktiviert ist.  Sie k&ouml;nnen diese Funktion aktivieren,
	indem Sie in &man.rc.conf.5;  folgende &Auml;nderung
	durchf&uuml;hren:</para>

      <programlisting>gateway_enable=YES          # Auf YES setzen, wenn der Rechner als Gateway arbeiten soll</programlisting>

      <para>Diese Option setzt die &man.sysctl.8;-Variable
	<varname>net.inet.ip.forwarding</varname> auf
	<literal>1</literal>.  Wenn Sie das Routing kurzzeitig
	unterbrechen wollen, k&ouml;nnen Sie die Variable auf
	<literal>0</literal> setzen.</para>

      <indexterm><primary>BGP</primary></indexterm>
      <indexterm><primary>RIP</primary></indexterm>
      <indexterm><primary>OSPF</primary></indexterm>

      <para>Ihr neuer Router ben&ouml;tigt nun noch Routen, um zu
	wissen, wohin er den Verkehr senden soll.  Haben Sie ein
	(sehr) einfaches Netzwerk, k&ouml;nnen Sie statische Routen
	verwenden.  FreeBSD verf&uuml;gt &uuml;ber den Standard
	BSD-Routing-Daemon &man.routed.8;, der RIP (sowohl Version 1
	als auch Version 2) und IRDP versteht.  BGP&nbsp;v4,
	OSPF&nbsp;v2 und andere Protokolle werden von
	<filename role="package">net/zebra</filename>
	unterst&uuml;tzt.  Es stehen auch kommerzielle Produkte
	wie <application>gated</application> zur Verf&uuml;gung.</para>

      <para>Selbst wenn FreeBSD auf diese Art konfiguriert wurde,
	entspricht es den Standardanforderungen an Internet-Router
	nicht vollst&auml;ndig.  F&uuml;r den
	<emphasis>normalen</emphasis> Gebrauch kommt es den Standards
	aber nahe genug.</para>
    </sect2>

    <sect2>
      <title>Verteilung von Routing-Informationen</title>

      <indexterm>
	<primary>routing propagation</primary>
      </indexterm>

      <para>Wir haben bereits dar&uuml;ber gesprochen, wie wir unsere
	Routen zur Au&szlig;enwelt definieren, aber nicht dar&uuml;ber, wie
	die Au&szlig;enwelt uns finden kann.</para>

      <para>Wir wissen bereits, dass Routing-Tabellen so erstellt
	werden k&ouml;nnen, dass s&auml;mtlicher Verkehr f&uuml;r
	einen bestimmten Adressraum (in unserem Beispiel ein
	Klasse-C-Subnetz) zu einem bestimmten Rechner in diesem
	Netzwerk gesendet wird, der die eingehenden Pakete im Subnetz
	verteilt.</para>

      <para>Wenn Sie einen Adressraum f&uuml;r Ihre Seite zugewiesen
	bekommen, richtet Ihr Diensteanbieter seine Routingtabellen so
	ein, dass der ganze Verkehr f&uuml;r Ihr Subnetz entlang Ihrer
	PPP-Verbindung zu Ihrer Seite gesendet wird.  Aber woher
	wissen die Seiten in der Au&szlig;enwelt, dass sie die Daten an
	Ihren ISP senden sollen?</para>

      <para>Es gibt ein System (&auml;hnlich dem verbreiteten DNS),
	das alle zugewiesenen Adressr&auml;ume verwaltet und ihre
	Verbindung zum Internet-Backbone definiert und dokumentiert.
	Der <quote>Backbone</quote> ist das Netz aus
	Hauptverbindungen, die den Internetverkehr in der ganzen Welt
	transportieren und verteilen.  Jeder Backbone-Rechner
	verf&uuml;gt &uuml;ber eine Kopie von Haupttabellen, die den
	Verkehr f&uuml;r ein bestimmtes Netzwerk &uuml;ber
	hierarchisch vom Backbone &uuml;ber eine Kette von
	Diensteanbietern bis hin zu Ihrer Seite leiten.</para>

      <para>Es ist die Aufgabe Ihres Diensteanbieters, den
	Backbone-Seiten mitzuteilen, dass sie mit Ihrer Seite
	verbunden wurden.  Durch diese Mitteilung der Route ist nun
	auch der Weg zu Ihnen bekannt.  Dieser Vorgang wird als
	<emphasis>Bekanntmachung von Routen</emphasis>
	(<foreignphrase>routing propagation</foreignphrase>)
	bezeichnet.</para>
    </sect2>

    <sect2>
      <title>Problembehebung</title>

      <indexterm>
	<primary><command>traceroute</command></primary>
      </indexterm>

      <para>Manchmal kommt es zu Problemen bei der Bekanntmachung von
	Routen, und einige Seiten sind nicht in der Lage, Sie zu
	erreichen.  Vielleicht der n&uuml;tzlichste Befehl, um
	festzustellen, wo das Routing nicht funktioniert, ist
	&man.traceroute.8;.  Er ist au&szlig;erdem sehr n&uuml;tzlich, wenn
	Sie einen entfernten Rechner nicht erreichen k&ouml;nnen
	(sehen Sie dazu auch &man.ping.8;).</para>

      <para>&man.traceroute.8; wird mit dem zu erreichenden Rechner
	(Host) ausgef&uuml;hrt.  Angezeigt werden die Gateway-Rechner
	entlang des Verbindungspfades.  Schlie&szlig;lich wird der
	Zielrechner erreicht oder es kommt zu einem Verbindungsabbruch
	(beispielsweise durch Nichterreichbarkeit eines
	Gateway-Rechners).</para>

      <para>F&uuml;r weitere Informationen lesen Sie bitte die
	Dokumentation zu &man.traceroute.8;.</para>
    </sect2>
  </sect1>

  <sect1 id="network-wireless">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Anderson</surname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Drahtlose Netzwerke</title>
    <indexterm>
      <primary>drahtlose Netzwerke</primary>
    </indexterm>
    <indexterm>
      <primary>802.11</primary>
      <see>drahtlose Netzwerke</see>
    </indexterm>

    <sect2>
      <title>Einf&uuml;hrung</title>

      <para>Es kann sehr n&uuml;tzlich sein, einen Computer zu
	verwenden, ohne sich die ganze Zeit mit einem Netzwerkkabel
	herum&auml;rgern zu m&uuml;ssen.  FreeBSD kann auf drahtlose
	Netzwerke (<foreignphrase>wireless LAN</foreignphrase>)
	zugreifen und sogar als <quote>Zugangspunkt </quote>
	(<foreignphrase>access point</foreignphrase>) f&uuml;r
	drahtlose Netzwerke verwendet werden.</para>
    </sect2>

    <sect2>
      <title>Betriebsmodi drahtloser Ger&auml;te</title>

      <para>Drahtlose Ger&auml;te k&ouml;nnen in zwei Modi konfiguriert
        werden: BSS und IBSS.</para>

     <sect3>
       <title>BSS-Modus</title>
       <para>&Uuml;berlicherweise wird der BSS-Modus, der auch
         Infrastruktur-Modus genannt wird, verwendet.  In diesem Modus
	 sind die Zugangspunkte (<foreignphrase>access
	   points</foreignphrase> mit einem Kabel-Netzwerk verbunden.  Jedes
	 drahtlose Netzwerk besitzt einen Namen, der als die SSID des
	 Netzwerks bezeichnet wird.</para>

       <para>Drahtlose Clients benutzen ein im IEEE-802.11-Standard
         beschriebenes Protokoll, um sich mit den Zugangspunkten zu
         verbinden.  Durch die Angabe einer SSID kann sich der Client das
	 Netzwerk, mit dem er sich verbinden will, aussuchen.  Gibt der
	 Client keine SSID an, so wird er mit irgendeinem Netzwerk
	 verbunden.</para>
     </sect3>

     <sect3>
       <title>IBSS-Modus</title>
       <para>Der IBSS-Modus, der auch ad-hoc-Modus genannt wird, wurde
         f&uuml;r Punkt-zu-Punkt-Verbindungen entworfen.  Tats&auml;chlich
	 gibt es zwei Modi: Der IBSS-Modus, auch ad-hoc- oder
	 IEEE-ad-hoc-Modus, der im IEEE-802.11-Standard definiert wird
	 und der demo-ad-hoc-Modus oder Lucent-adhoc-Modus (der zur
	 Verwirrung auch schon mal ad-hoc-Modus genannt wird).  Der letzte
	 Modus stammt aus der Zeit vor IEEE&nbsp;802.11 und sollte nur noch
	 mit alten Installationen verwendet werden.  Im folgenden wird
	 keiner der ad-hoc-Modi behandelt.</para>
     </sect3>
   </sect2>

   <sect2>
     <title>Infrastruktur-Modus</title>

      <sect3>
	<title>Zugangspunkte</title>

	<para>Zugangspunkte sind drahtlose Netzwerkger&auml;te, die es
	  einem oder mehreren Clients erm&ouml;glichen, diesen als
	  einen zentralen Verteiler (Hub) zu benutzen.  Wenn ein
	  Zugangspunkt verwendet wird, kommunizieren alle Clients
	  &uuml;ber diesen Zugangspunkt.  Oft werden mehrere
	  Zugangspunkte kombiniert, um ein ganzes Gebiet, wie ein
	  Haus, ein Unternehmen oder einen Park mit einem drahtlosen
	  Netzwerk zu versorgen.</para>

	<para>&Uuml;blicherweise haben Zugangspunkte mehrere
	  Netzwerkverbindungen: Die drahtlose Karte, sowie eine oder
	  mehrere Ethernetkarten, &uuml;ber die die Verbindung mit dem
	  restlichen Netzwerk hergestellt wird.</para>

	<para>Sie k&ouml;nnen einen vorkonfigurierten Zugangspunkt
	  kaufen, oder Sie k&ouml;nnen sich unter Verwendung von
	  FreeBSD und einer unterst&uuml;tzten drahtlosen Karte einen
	  eigenen bauen.  Es gibt verschiedene Hersteller, die sowohl
	  Zugangspunkte als auch drahtlose Karten mit verschiedensten
	  Eigenschaften vertreiben.</para>
      </sect3>

      <sect3>
	<title>Einen FreeBSD Zugangspunkt installieren</title>
	<indexterm>
	  <primary>drahtlose Netzwerke</primary>
	  <secondary>Zugangspunkte</secondary>
	</indexterm>

	<sect4>
	  <title>Voraussetzungen</title>

	  <para>Um einen drahtlosen Zugangspunkt unter FreeBSD
	    einzurichten, m&uuml;ssen Sie &uuml;ber eine drahtlose
	    Karte verf&uuml;gen.  Zurzeit werden daf&uuml;r von
	    FreeBSD nur Karten mit Prism-Chipsatz unterst&uuml;tzt.
	    Zus&auml;tzlich ben&ouml;tigen Sie eine von FreeBSD
	    unterst&uuml;tzte Ethernetkarte (diese sollte nicht schwer
	    zu finden sein, da FreeBSD eine Vielzahl von verschiedenen
	    Karten unterst&uuml;tzt).  F&uuml;r die weiteren
	    Erl&auml;uterungen nehmen wir an, dass Sie den ganzen
	    Verkehr zwischen dem drahtlosen Ger&auml;t und dem an die
	    Ethernetkarte angeschlossenen Kabel-Netzwerk &uuml;ber
	    die &man.bridge.4;-Funktion realisieren wollen.</para>

	 <para>Die hostap-Funktion, mit der FreeBSD Zugangspunkte
	   implementiert, l&auml;uft am besten mit bestimmten
	   Firmware-Versionen.  Prism&nbsp;2-Karten sollten die
	   Version&nbsp;1.3.4 oder neuer der Firmware verwenden.
	   Prism&nbsp;2.5- und Prism&nbsp;3-Karten sollten die
	   Version&nbsp;1.4.9 der Firmware verwenden.  Es kann sein, dass
	   auch &auml;ltere Versionen funktionieren.  Zurzeit ist es nur
	   mit Windows-Werkzeugen der Hersteller m&ouml;glich, die Firmware
	   zu aktualisieren.</para>
	</sect4>

	<sect4>
	  <title>Einrichtung</title>

	  <para>Stellen Sie als erstes sicher, dass Ihr System die
	    drahtlose Karte erkennt:</para>

	  <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
        status: no carrier
        ssid ""
        stationname "FreeBSD Wireless node"
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</screen>

	  <para>K&uuml;mmern Sie sich jetzt noch nicht um die Details,
	    sondern stellen Sie nur sicher, dass ihre drahtlose Karte
	    &uuml;berhaupt erkannt und angezeigt wird.</para>

	  <para>Danach m&uuml;ssen Sie ein Modul laden, um die
	    Bridge-Funktion von FreeBSD f&uuml;r den Zugangspunkt
	    vorzubereiten.  Um das &man.bridge.4;-Modul zu laden,
	    machen Sie Folgendes:</para>

	  <screen>&prompt.root; <userinput>kldload bridge</userinput></screen>

	  <para>Dabei sollten beim Laden des Moduls keine
	    Fehlermeldungen auftreten.  Geschieht dies doch, kann es
	    sein, dass Sie die Bridge-Funktion (&man.bridge.4;)
	    in Ihren Kernel kompilieren m&uuml;ssen.  Der Abschnitt
	    <link linkend="network-bridging">LAN-Kopplung mit einer
	      Bridge</link> sollte Ihnen bei dieser Aufgabe
	    behilflich sein.</para>

	  <para>Wenn die Bridge-Funktion aktiviert ist,
	    m&uuml;ssen wir FreeBSD mitteilen, welche Schnittstellen
	    &uuml;ber die Bridge verbunden werden sollen.  Dazu
	    verwenden wir &man.sysctl.8;:</para>

	  <screen>&prompt.root; <userinput>sysctl net.link.ether.bridge=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge_cfg="wi0 xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	  <para>Nun ist es an der Zeit, die drahtlose Karte zu
	    installieren.</para>

	  <para>Der folgende Befehl konfiguriert einen Zugangspunkt:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 ssid my_net channel 11 media DS/11Mbps mediaopt hostap up stationname "FreeBSD AP"</userinput></screen>

	  <para>Die &man.ifconfig.8; Zeile aktiviert das
	    <devicename>wi0</devicename>-Ger&auml;t, und setzt die
	    SSID auf <literal>my_net</literal> sowie den Namen des
	    Zugangspunkts auf <literal>FreeBSD AP</literal>
	    Mit <option>media DS/11Mbps</option> wird die Karte in den
	    11&nbsp;Mbps-Modus versetzt.  Diese Option ist n&ouml;tig,
	    damit <option>mediaopt</option>-Optionen wirksam werden.  Mit
	    <option>mediaopt hostap</option> wird die Schnittstelle als
	    Zugangspunkt konfiguriert.  Der zu benutzende 802.11b-Kanal
	    wird mit <option>channel 11</option> festgelegt.  In der
	    Hilfeseite &man.wicontrol.8; werden weitere Kan&auml;le
	    <!-- f&uuml;r die regulatory domain -->
	    aufgez&auml;hlt.</para>

	  <para>Nun sollten Sie &uuml;ber einen voll
	    funktionsf&auml;higen und laufenden Zugangspunkt
	    verf&uuml;gen.  F&uuml;r weitere Informationen lesen Sie
	    bitte die Dokumentationen zu &man.wicontrol.8;,
	    &man.ifconfig.8; und &man.wi.4;.</para>

	  <para>Au&szlig;erdem ist es empfehlenswert, den folgenden
	    Abschnitt zu lesen, um sich &uuml;ber die Sicherung bzw.
	    Verschl&uuml;sselung von Zugangspunkten zu
	    informieren.</para>
	</sect4>

       <sect4>
         <title>Status Informationen</title>
	 <para>Wenn der Zugangspunkt eingerichtet ist und l&auml;uft,
	   k&ouml;nnen Sie die verbundenen Clients mit dem nachstehenden
	   Kommando abfragen:</para>

         <screen>&prompt.root; <userinput>wicontrol -l</userinput>
1 station:
00:09:b7:7b:9d:16  asid=04c0, flags=3&lt;ASSOC,AUTH&gt;, caps=1&lt;ESS&gt;, rates=f&lt;1M,2M,5.5M,11M&gt;, sig=38/15
</screen>

	 <para>Das Beispiel zeigt eine verbundene Station und die
	   dazugeh&ouml;renden Verbindungsparameter.  Die angegebene
	   Signalst&auml;rke sollte nur relativ interpretiert werden, da
	   die Umrechnung in dBm oder andere Einheiten abh&auml;ngig von
	   der Firmware-Version ist.</para>
       </sect4>
      </sect3>

      <sect3>
	<title>Clients</title>

	<para>Ein drahtloser Client ist ein System, das direkt auf
	  einen Zugangspunkt oder einen anderen Client
	  zugreift.</para>

	<para>&Uuml;blicherweise haben drahtlose Clients nur ein
	  Netzwerkger&auml;t, die drahtlose Netzkarte.</para>

	<para>Es gibt verschiedene M&ouml;glichkeiten, einen
	  drahtlosen Client zu konfigurieren.  Diese h&auml;ngen von
	  den verschiedenen drahtlosen Betriebsmodi ab.  Man
	  unterscheidet vor allem zwischen BSS (Infrastrukturmodus,
	  erfordert einen Zugangspunkt) und IBSS (ad-hoc,
	  Peer-to-Peer-Modus, zwischen zwei Clients, ohne
	  Zugangspunkt).  In unserem Beispiel verwenden wir den weiter
	  verbreiteten BSS-Modus, um einen Zugangspunkt anzusprechen.
	  </para>

	<sect4>
	  <title>Voraussetzungen</title>

	  <para>Es gibt nur eine Voraussetzung, um FreeBSD als
	    drahtlosen Client betreiben zu k&ouml;nnen: Sie brauchen
	    eine von FreeBSD unterst&uuml;tzte drahtlose
	    Karte.</para>
	</sect4>

	<sect4>
	  <title>Einen drahtlosen FreeBSD Client einrichten</title>

	  <para>Sie m&uuml;ssen ein paar Dinge &uuml;ber das drahtlose
	    Netzwerk wissen, mit dem Sie sich verbinden wollen, bevor
	    Sie starten k&ouml;nnen.  In unserem Beispiel verbinden
	    wir uns mit einem Netzwerk, das den Namen
	    <literal>my_net</literal> hat, und bei dem die
	    Verschl&uuml;sselung deaktiviert ist.</para>

	  <para>Anmerkung: In unserem Beispiel verwenden wir keine
	    Verschl&uuml;sselung.  Dies ist eine gef&auml;hrliche
	    Situation.  Im n&auml;chsten Abschnitt werden Sie daher
	    lernen, wie man die Verschl&uuml;sselung aktiviert, warum
	    es wichtig ist, dies zu tun, und warum einige
	    Verschl&uuml;sselungstechnologien Sie trotzdem nicht
	    v&ouml;llig sch&uuml;tzen.</para>

	  <para>Stellen Sie sicher, dass Ihre Karte von FreeBSD
	    erkannt wird:</para>

	  <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
        status: no carrier
        ssid ""
        stationname "FreeBSD Wireless node"
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</screen>

	  <para>Nun werden wir die Einstellungen der Karte unserem
	    Netzwerk anpassen:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net</userinput></screen>

	  <para>Ersetzen Sie <hostid
	    role="IPAddr">192.168.0.20</hostid> und <hostid
	    role="Netmask">255.255.255.0</hostid> mit einer
	    g&uuml;ltigen IP-Adresse und Netzmaske ihres
	    Kabel-Netzwerks.  Bedenken Sie au&szlig;erdem, dass unser
	    Zugangspunkt als Bridge zwischen dem drahtlosen und
	    dem Kabel-Netzwerk fungiert.  F&uuml;r die anderen
	    Rechner Ihres Netzwerks befinden Sie sich, genauso wie
	    diese, im gleichen Kabel-Netzwerk, obwohl Sie zum
	    drahtlosen Netzwerk geh&ouml;ren.</para>

	  <para>Nachdem Sie dies erledigt haben, sollten Sie andere
	    Rechner (Hosts) im Kabel-Netzwerk anpingen k&ouml;nnen.
	    Dies genauso, wie wenn Sie &uuml;ber eine
	    Standardkabelverbindung mit ihnen verbunden
	    w&auml;ren.</para>

	  <para>Wenn Probleme mit Ihrer drahtlosen Verbindung
	    auftreten, stellen Sie sicher, dass Sie mit dem
	    Zugangspunkt verbunden sind:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0</userinput></screen>

	  <para>sollte einige Informationen ausgeben und Sie sollten
	    Folgendes sehen:</para>

	  <screen>status: associated</screen>

	  <para>Wird dies nicht angezeigt, sind Sie entweder
	    au&szlig;erhalb der Reichweite des Zugangspunktes, haben die
	    Verschl&uuml;sselung deaktiviert, oder Sie haben ein
	    anderes Konfigurationsproblem.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Verschl&uuml;sselung</title>
	<indexterm>
	  <primary>drahtlose Netzwerke</primary>
	  <secondary>Verschl&uuml;sselung</secondary>
	</indexterm>

	<para>Verschl&uuml;sselung ist in einem drahtlosen Netzwerk
	  wichtig, da Sie das Netzwerk nicht l&auml;nger in einem
	  gesch&uuml;tzten Bereich betreiben k&ouml;nnen.  Ihre Daten
	  verbreiten sich in der ganzen Nachbarschaft, das hei&szlig;t
	  jeder, der es will, kann Ihre Daten lesen.  Deshalb gibt es die
	  Verschl&uuml;sselung.  Durch die Verschl&uuml;sselung der durch
	  die Luft versendeten Daten machen Sie es einem Dritten sehr
	  viel schwerer, Ihre Daten abzufangen oder auf diese
	  zuzugreifen.</para>

	<para>Die gebr&auml;uchlichsten Methoden, um Daten zwischen
	  Ihrem Client und dem Zugangspunkt zu verschl&uuml;sseln,
	  sind WEP und &man.ipsec.4;.</para>

	<sect4>
	  <title>WEP</title>
	  <indexterm>
	    <primary>WEP</primary>
	  </indexterm>

	  <para>WEP ist die Abk&uuml;rzung f&uuml;r Wired Equivalency
	    Protocol ("Verkabelung entsprechendes Protokoll").  WEP
	    war ein Versuch, drahtlose Netzwerke genauso sicher und
	    gesch&uuml;tzt zu machen wie verkabelte Netzwerke.
	    Ungl&uuml;cklicherweise wurde es bereits geknackt, und ist
	    relativ einfach auszuhebeln.  Sie sollten sich also nicht
	    darauf verlassen, wenn Sie sensible Daten
	    verschl&uuml;sseln wollen.</para>

	  <para>Allerdings ist eine schlechte Verschl&uuml;sselung
	    noch immer besser als gar keine Verschl&uuml;sselung.
	    Aktivieren Sie daher WEP f&uuml;r Ihren neuen FreeBSD
	    Zugangspunkt:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 inet up ssid my_net wepmode on wepkey 0x1234567890 media DS/11Mbps mediaopt hostap</userinput></screen>

	  <para>Auf dem Client k&ouml;nnen Sie WEP wie folgt
	    aktivieren:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net wepmode on wepkey 0x1234567890</userinput></screen>

	  <para>Beachten Sie bitte, dass Sie
	    <literal>0x1234567890</literal> durch einen besseren
	    Schl&uuml;ssel ersetzen sollten.</para>
	</sect4>

	<sect4>
	  <title>IPsec</title>

	  <para>&man.ipsec.4; ist ein viel besseres und robusteres
	    Werkzeug, um Daten in einem Netzwerk zu
	    verschl&uuml;sseln und ist auch der bevorzugte Weg,
	    Daten in einem drahtlosen Netzwerk zu verschl&uuml;sseln.
	    F&uuml;r weitere Informationen &uuml;ber
	    &man.ipsec.4;-Sicherheit, und dessen Implementierung
	    lesen Sie Abschnitt <link linkend="ipsec">IPsec</link>
	    des Handbuches.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Werkzeuge</title>

	<para>Es gibt einige Werkzeuge, die dazu dienen, Ihr
	  drahtloses Netzwerk zu installieren, und auftretende
	  Probleme zu beheben.  Wir werden nun versuchen, einige davon
	  zu beschreiben.</para>

	<sect4>
	  <title><application>bsd-airtools</application></title>

	  <para>Das Paket <application>bsd-airtools</application>
	    enth&auml;lt einen kompletten Werkzeugsatz zum
	    Herausfinden von WEP-Schl&uuml;sseln, zum Auffinden von
	    Zugangspunkten, usw.</para>

	  <para>Die <application>bsd-airtools</application>
	    k&ouml;nnen Sie &uuml;ber den <filename
	    role="package">net/bsd-airtools</filename> Port
	    installieren.  F&uuml;r weitere Informationen zum
	    Installieren von Ports lesen Sie bitte <xref
	    linkend="ports"> des Handbuchs.</para>

	  <para>Das Programm <command>dstumbler</command> ist ein
	    Werkzeug, das Sie beim Auffinden von Zugangspunkten
	    unterst&uuml;tzt, und das Signal-Rausch-Verh&auml;ltnis
	    graphisch darstellen kann.  Wenn Sie Probleme beim
	    Einrichten und Betreiben Ihres Zugangspunktes haben,
	    k&ouml;nnte <command>dstumbler</command> genau das
	    Richtige f&uuml;r Sie sein.</para>

	  <para>Um die Sicherheit Ihres drahtlosen Netzwerks zu
	    &uuml;berpr&uuml;fen, k&ouml;nnten Sie das Paket
	    <quote>dweputils</quote> (<command>dwepcrack</command>,
	    <command>dwepdump</command> und
	    <command>dwepkeygen</command>) verwenden, um
	    festzustellen, ob WEP Ihren Sicherheitsanspr&uuml;chen
	    gen&uuml;gt.</para>
	</sect4>

	<sect4>
	  <title>wicontrol, ancontrol, raycontrol</title>

	  <para>Dies sind Werkzeuge, um das Verhalten Ihrer drahtlosen
	    Karte im drahtlosen Netzwerk zu kontrollieren.  In den
	    obigen Beispielen haben wir &man.wicontrol.8; verwendet,
	    da es sich bei unser drahtlosen Karte um ein Ger&auml;t
	    der <devicename>wi0</devicename>-Schnittstelle handelt.
	    H&auml;tten Sie eine drahtlose Karte von Cisco,
	    w&uuml;rden Sie diese &uuml;ber
	    <devicename>an0</devicename> ansprechen, und daher
	    &man.ancontrol.8; verwenden.</para>
	</sect4>

	<sect4>
	  <title>ifconfig</title>
	  <indexterm>
	    <primary>ifconfig</primary>
	  </indexterm>

	  <para>&man.ifconfig.8; kennt zwar viele Optionen von
	    &man.wicontrol.8;, einige fehlen jedoch.  Lesen Sie die
	    Dokumentation zu &man.ifconfig.8; f&uuml;r weitere
	    Informationen zu Parametern und Optionen.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Unterst&uuml;tzte Karten</title>

	<sect4>
	  <title>Zugangspunkt</title>

	  <para>Die einzigen Karten, die im BSS-Modus (das hei&szlig;t als
	    Zugangspunkt) derzeit unterst&uuml;tzt werden, sind solche
	    mit Prism&nbsp;2-, 2.5- oder 3-Chipsatz.  F&uuml;r eine
	    komplette &Uuml;bersicht lesen Sie bitte &man.wi.4;.</para>
	</sect4>

	<sect4>
	  <title>Clients</title>

	  <para>Beinahe alle 802.11b drahtlosen Karten werden von
	    FreeBSD unterst&uuml;tzt.  Die meisten dieser Karten von
	    Prism, Spectrum24, Hermes, Aironet und Raylink arbeiten
	    als drahtlose Netzkarten im IBSS-Modus (ad-hoc,
	    Peer-to-Peer und BSS).</para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-bridging">
  <sect1info>
    <authorgroup>
      <author>
        <firstname>Steve</firstname>
	<surname>Peterson</surname>
	<contrib>Geschrieben von </contrib>
      </author>
    </authorgroup>
  </sect1info>
    <title>LAN-Kopplung mit einer Bridge</title>

    <sect2>
      <title>Einf&uuml;hrung</title>

      <indexterm><primary>Subnetz</primary></indexterm>
      <indexterm><primary>Bridge</primary></indexterm>

      <para>Manchmal ist es n&uuml;tzlich, ein physikalisches Netzwerk
        (wie ein Ethernetsegment) in zwei separate Netzwerke aufzuteilen,
        ohne gleich IP-Subnetze zu erzeugen, die &uuml;ber einen Router
	miteinander verbunden sind.  Ein Ger&auml;t, das zwei Netze
	auf diese Weise verbindet, wird als <emphasis>Bridge</emphasis>
	bezeichnet.  Jedes FreeBSD-System mit zwei Netzkarten kann
	als Bridge fungieren.</para>

      <para>Die Bridge arbeitet, indem sie die MAC Layeradressen (Ethernet
        Adressen) der Ger&auml;te in ihren Netzsegmenten lernt.  Der
	Verkehr wird nur dann zwischen zwei Netzsegmenten weitergeleitet,
        wenn sich Sender und Empf&auml;nger in verschiedenen Netzsegmenten
	befinden.</para>

      <para>In vielerlei Hinsicht entspricht eine Bridge daher einem
        Ethernet-Switch mit sehr wenigen Ports.</para>
    </sect2>

    <sect2>
      <title>Situationen, in denen <emphasis>Bridging</emphasis> angebracht
        ist</title>

      <para>Eine Bridge wird vor allem in folgenden zwei Situationen
        verwendet.</para>

      <sect3>
	<title>Hohes Datenaufkommen in einem Segment</title>

	<para>In der ersten Situation wird Ihr physikalisches Netz
	  mit Datenverkehr &uuml;berschwemmt.  Aus irgendwelchen
	  Gr&uuml;nden wollen Sie allerdings keine Subnetze verwenden,
	  die &uuml;ber einen Router miteinander verbunden sind.</para>

	<para>Stellen Sie sich einen Zeitungsverlag vor, in dem sich die
	  Redaktions- und Produktionsabteilungen in verschiedenen Subnetzen
	  befinden.  Die Redaktionsrechner verwenden den Server A f&uuml;r
	  Dateioperationen, und die Produktionsrechner verwenden den
	  Server B.  Alle Benutzer sind &uuml;ber ein gemeinsames
	  Ethernet-LAN miteinander verbunden.  Durch den hohen Datenverkehr
	  sinkt die Geschwindigkeit des gesamten Netzwerks.</para>

	<para>W&uuml;rde man die Redaktionsrechner und die
	  Produktionsrechner in separate Netzsegmente auslagern,
	  k&ouml;nnte man diese beiden Segmente &uuml;ber eine Bridge
	  verbinden.  Nur der f&uuml;r Rechner im <emphasis>anderen</emphasis>
	  Segment bestimmte Verkehr wird dann &uuml;ber die Brigde in
	  das andere Netzsegment geleitet.  Dadurch verringert sich das
	  Gesamtdatenaufkommen in beiden Segmenten.</para>
      </sect3>

      <sect3>
	<title>Filtering/Traffic Shaping Firewall</title>

	<indexterm><primary>Firewall</primary></indexterm>
	<indexterm><primary>IP-Masquerading</primary></indexterm>

	<para>Die zweite h&auml;ufig anzutreffende Situation tritt auf,
	  wenn Firewallfunktionen ben&ouml;tigt werden, ohne dass
	  IP-Maskierung (NAT &ndash; Network Adress Translation)
	  verwendet wird.</para>

	<para>Ein Beispiel daf&uuml;r w&auml;re ein kleines Unternehmen,
	  das &uuml;ber DSL oder ISDN an ihren ISP angebunden ist.  Es
	  verf&uuml;gt &uuml;ber 13 weltweit erreichbare IP-Adressen, und
	  sein Netzwerk besteht aus 10 Rechnern.  In dieser Situation ist
	  die Verwendung von Subnetzen sowie einer routerbasierten Firewall
	  schwierig.</para>

	<indexterm><primary>Router</primary></indexterm>
	<indexterm><primary>DSL</primary></indexterm>
	<indexterm><primary>ISDN</primary></indexterm>

	<para>Eine brigdebasierte Firewall kann konfiguriert und in den
	  ISDN/DSL-Downstreampfad ihres Routers eingebunden werden, ohne
	  sich um IP-Adressen k&uuml;mmern zu m&uuml;ssen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Die LAN-Kopplung konfigurieren</title>

      <sect3>
	<title>Auswahl der Netzkarten</title>

	<para>Eine Bridge ben&ouml;tigt mindestens zwei Netzkarten.
	  Leider sind unter FreeBSD&nbsp;4.x nicht alle verf&uuml;gbaren
	  Netzkarten daf&uuml;r geeignet.  Lesen Sie &man.bridge.4;, um
	  sich &uuml;ber Details der unterst&uuml;tzten Karten zu
	  informieren.</para>

	<para>Installieren und testen Sie beide Netzkarten, bevor Sie
	  fortfahren.</para>
      </sect3>

      <sect3>
	<title>Anpassen der Kernelkonfiguration</title>

	<indexterm><primary>Kernelkonfiguration</primary></indexterm>
	<indexterm>
	  <primary>Kernelkonfiguration</primary>
	  <secondary>options BRIDGE</secondary>
	</indexterm>

	<para>Um die Kernelunterst&uuml;tzung f&uuml;r die LAN-Kopplung
	  zu aktivieren, f&uuml;gen Sie</para>

	<programlisting>options BRIDGE</programlisting>

	<para>in Ihre Kernelkonfigurationsdatei ein, und erzeugen einen
	  neuen Kernel.</para>
      </sect3>

      <sect3>
	<title>Firewallunterst&uuml;tzung</title>

	<indexterm><primary>Firewall</primary></indexterm>

	<para>Wenn Sie die Bridge als Firewall verwenden wollen, m&uuml;ssen
	  Sie zus&auml;tzlich die Option <varname>IPFIREWALL</varname>
	  einf&uuml;gen.  F&uuml;r weitere Informationen zur Konfiguration
	  der Bridge als Firewall lesen Sie bitte den entsprechenden Abschnitt
	  des Handbuchs (<xref linkend="firewalls">).</para>

	<para>Wenn Sie Nicht-IP-Pakete (wie ARP-Pakete) durch Ihre
	  Bridge leiten wollen, m&uuml;ssen Sie eine zus&auml;tzliche,
	  undokumentierte Option verwenden.  Es handelt sich um
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal>.
	  Beachten Sie aber, dass Ihre Firewall durch diese Option per
	  Voreinstellung alle Pakete akzeptiert.  Sie sollten sich also
	  &uuml;ber die Auswirkungen dieser Option im Klaren sein,
	  bevor Sie sie verwenden.</para>
      </sect3>

      <sect3>
	<title>Unterst&uuml;tzung f&uuml;r Traffic Shaping</title>

	<para>Wenn Sie die Bridge als Traffic-Shaper verwenden wollen,
	  m&uuml;ssen Sie die Option <literal>DUMMYNET</literal> in
	  Ihre Kernelkonfigurationsdatei einf&uuml;gen.  Lesen Sie
	  &man.dummynet.4;, um weitere Informationen zu erhalten.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Die LAN-Kopplung aktivieren</title>

      <para>F&uuml;gen Sie die Zeile</para>

      <programlisting>net.link.ether.bridge=1</programlisting>

      <para>in <filename>/etc/sysctl.conf</filename> ein, um die Bridge
        zur Laufzeit zu aktivieren, sowie die Zeile</para>

      <programlisting>net.link.ether.bridge_cfg=<replaceable>if1</replaceable>,<replaceable>if2</replaceable></programlisting>

      <para>um die LAN-Kopplung f&uuml;r die festgelegten Ger&auml;te
        zu erm&ouml;glichen (ersetzen Sie dazu <replaceable>if1</replaceable>
        und <replaceable>if2</replaceable> mit den Namen Ihrer Netzkarten).
	Wenn Sie die Datenpakete via &man.ipfw.8; filtern wollen, sollten
	Sie zus&auml;tzlich Folgendes einf&uuml;gen:</para>

      <programlisting>net.link.ether.bridge_ipfw=1</programlisting>
    </sect2>

    <sect2>
      <title>Sonstige Informationen</title>

      <para>Wenn Sie via <command>telnet</command> auf die Bridge zugreifen
        wollen, ist es in Ordnung, einer der beiden Netzkarten eine IP-Adresse
	zuzuweisen.  Es besteht Einigkeit dar&uuml;ber, dass es eine schlechte
	Idee ist, beiden Karten eine IP-Adresse zuzuweisen.</para>

      <para>Wenn Sie verschiedene Bridges in Ihrem Netzwerk haben, kann es
        dennoch nicht mehr als einen Weg zwischen zwei Arbeitspl&auml;tzen
	geben.  Das hei&szlig;t, Spanning tree link Management wird nicht
	unterst&uuml;tzt.</para>

      <para>Eine Bridge kann, besonders f&uuml;r Verkehr &uuml;ber
	Segmente, die Laufzeiten von Paketen erh&ouml;hen.</para>
    </sect2>
  </sect1>

  <sect1 id="network-nfs">
    <!-- j.kois@web.de, 04. April 2003 -->
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
          <contrib>Reorganisiert und erweitert von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
	  <firstname>Bill</firstname>
	  <surname>Swingle</surname>
	  <contrib>Geschrieben von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>NFS &ndash; Network File System</title>

    <indexterm><primary>NFS</primary></indexterm>

    <para>Eines der vielen von FreeBSD unterst&uuml;tzten Dateisysteme
      ist das Netzwerkdateisystem, das auch als <acronym>NFS</acronym>
      bekannt ist.  <acronym>NFS</acronym> erm&ouml;glicht es einem
      System, Dateien und Verzeichnisse &uuml;ber ein Netzwerk mit anderen
      zu teilen.  &Uuml;ber <acronym>NFS</acronym> k&ouml;nnen Benutzer
      und Programme auf Daten entfernter Systeme zugreifen, und zwar
      genauso, wie wenn es sich um lokale Daten handeln w&uuml;rde.</para>

    <para>Einige der wichtigsten Vorteile von <acronym>NFS</acronym>
      sind:</para>

    <itemizedlist>
      <listitem>
	<para>Lokale Arbeitsstationen ben&ouml;tigen weniger Plattenplatz,
          da gemeinsam benutzte Daten nur auf einem einzigen Rechner
	  vorhanden sind.  Alle anderen Stationen greifen &uuml;ber das
	  Netzwerk auf diese Daten zu.</para>
      </listitem>

      <listitem>
	<para>Benutzer ben&ouml;tigen nur noch ein zentrales
	  Heimatverzeichnis auf einem <acronym>NFS</acronym>-Server.
	  Diese Verzeichnisse sind &uuml;ber das Netzwerk auf allen
	  Stationen verf&uuml;gbar.</para>
      </listitem>

      <listitem>
	<para>Speicherger&auml;te wie Disketten-, CD-ROM-
	  oder ZIP-Laufwerke k&ouml;nnen &uuml;ber das Netzwerk von
	  anderen Arbeitstationen genutzt werden.  Dadurch sind f&uuml;r
	  das gesamte Netzwerk deutlich weniger Speicherger&auml;te
	  n&ouml;tig.</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Wie funktioniert <acronym>NFS</acronym>?</title>

      <para><acronym>NFS</acronym> besteht aus zwei Hauptteilen: Einem
        Server und einem oder mehreren Clients.  Der Client greift
	&uuml;ber das Netzwerk auf die Daten zu, die auf dem Server
	gespeichert sind.  Damit dies korrekt funktioniert, m&uuml;ssen
	einige Prozesse konfiguriert und gestartet werden:</para>

      <para>Der Server ben&ouml;tigt folgende Daemonen:</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>Server</secondary>
      </indexterm>

      <indexterm>
        <primary><application>portmap</application></primary>
      </indexterm>

      <indexterm>
        <primary><application>mountd</application></primary>
      </indexterm>

      <indexterm>
        <primary><application>nfsd</application></primary>
      </indexterm>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Daemon</entry>

	      <entry>Beschreibung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>nfsd</entry>

	      <entry>Der <acronym>NFS</acronym>-Daemon.  Er bearbeitet
	        Anfragen der <acronym>NFS</acronym>-Clients.</entry>
	    </row>

	    <row>
	      <entry>mountd</entry>

	      <entry>Der <acronym>NFS</acronym>-Mount-Daemon.  Er
	        bearbeitet die Anfragen, die &man.nfsd.8; an ihn
		weitergibt.</entry>
	    </row>

	    <row>
	      <entry>portmap</entry>

	      <entry> Der Portmapper-Daemon.  Durch ihn erkennen die
	        <acronym>NFS</acronym>-Clients, welchen Port der
		<acronym>NFS</acronym>-Server verwendet.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Der Client kann ebenfalls einen Daemon aufrufen, und zwar den
        <application>nfsiod</application>-Daemon.  Der
	<application>nfsiod</application>-Daemon bearbeitet Anfragen vom
	<acronym>NFS</acronym>-Server.  Er ist optional und verbessert
	die Leistung des Netzwerks.  F&uuml;r eine normale und korrekte
	Arbeit ist er allerdings nicht erforderlich.  Lesen Sie
	&man.nfsiod.8;, wenn Sie weitere Informationen ben&ouml;tigen.</para>
    </sect2>

    <sect2 id="network-configuring-nfs">

      <title><acronym>NFS</acronym> einrichten</title>

      <indexterm>
        <primary>NFS</primary>
	<secondary>einrichten</secondary>
      </indexterm>

      <para><acronym>NFS</acronym> l&auml;&szlig;t sich leicht
        einrichten.  Die n&ouml;tigen Prozesse werden durch einige
	&Auml;nderungen in <filename>/etc/rc.conf</filename> bei
	jedem Systemstart gestartet.</para>

      <para>Stellen Sie sicher, dass auf dem <acronym>NFS</acronym>-Server
        folgende Optionen in <filename>/etc/rc.conf</filename>
	gesetzt sind:</para>

      <programlisting>
portmap_enable="YES"
nfs_server_enable="YES"
mountd_flags="-r"
      </programlisting>

      <para><command>mountd</command> l&auml;uft automatisch, wenn der
        <acronym>NFS</acronym>-Server aktiviert ist.</para>

      <para>Auf dem Client muss in <filename>/etc/rc.conf</filename>
        folgende Option gesetzt sein:</para>

      <programlisting>nfs_client_enable="YES"</programlisting>

      <para>
        <filename>/etc/exports</filename> legt fest, welche Dateisysteme
	<acronym>NFS</acronym> exportieren (manchmal auch als
	<quote>teilen</quote> bezeichnet) soll.  Jede Zeile in
	<filename>/etc/exports</filename> legt ein Dateisystem sowie
	die Arbeitsstationen, die darauf Zugriff haben, fest.  Au&szlig;erdem
	ist es m&ouml;glich, Zugriffsoptionen festzulegen.  Es gibt viele
	verschiedene Optionen, allerdings werden hier nur einige von
	ihnen erw&auml;hnt.  Wenn Sie Informationen &uuml;ber weitere
	Optionen ben&ouml;tigen, lesen Sie &man.exports.5;.</para>

      <para>Nun folgen einige Beispieleintr&auml;ge f&uuml;r
        <filename>/etc/exports</filename>:</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>Export von Dateisystemen</secondary>
      </indexterm>

      <para>Die folgenden Beispiele geben Ihnen Anhaltspunkte zum
        Exportieren von Dateisystemen, obwohl diese Einstellungen
	nat&uuml;rlich von Ihrer Arbeitsumgebung und Ihrer
	Netzwerkkonfiguration abh&auml;ngen.  Das n&auml;chste
	Beispiel exportiert das Verzeichnis <filename>/cdrom</filename>
	f&uuml;r drei Rechner, die sich in derselben Dom&auml;ne wie
	der Server befinden oder f&uuml;r die entsprechende Eintr&auml;ge
	in <filename>/etc/hosts</filename> existieren.
	Die Option <option>-ro</option> kennzeichnet das
	exportierte Dateisystem als schreibgesch&uuml;tzt.  Durch dieses
	Flag ist das entfernte System nicht in der Lage, das exportierte
	Dateisystem zu ver&auml;ndern.</para>

      <programlisting>/cdrom -ro host1 host2 host3</programlisting>

      <para>Die n&auml;chste Zeile exportiert <filename>/home</filename>
        auf drei durch IP-Adressen bestimmte Rechner.  Diese Einstellung
	ist n&uuml;tzlich, wenn Sie &uuml;ber ein privates Netzwerk ohne
	<acronym>DNS</acronym>-Server verf&uuml;gen.  Optional
	k&ouml;nnten interne Rechnernamen auch in
	<filename>/etc/hosts</filename>	konfiguriert werden.
	Ben&ouml;tigen Sie hierzu weitere Informationen, lesen Sie bitte
	&man.hosts.5;.  Durch das Flag <option>-alldirs</option> wird es
	m&ouml;glich, auch Unterverzeichnisse als Mountpunkte
	festzulegen.  Dies bedeutet aber nicht, dass alle
	Unterverzeichnisse eingeh&auml;ngt werden, vielmehr wird es dem
	Client erm&ouml;glicht, nur diejenigen	Verzeichnisse
	einzuh&auml;ngen, die auch ben&ouml;tigt werden.</para>

      <programlisting>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

      <para>Die n&auml;chste Zeile exportiert <filename>/a</filename>,
        damit Clients von verschiedenen Dom&auml;nen auf das Dateisystem
	zugreifen k&ouml;nnen.  Das <option>-maproot=root</option>-Flag
	erlaubt es dem Benutzer <username>root</username> des entfernten
	Systems, als <username>root</username> auf das exportierte
	Dateisystem zu schreiben.  Wenn dieses Flag nicht gesetzt ist,
	kann selbst <username>root</username> nicht auf das exportierte
	Dateisystem schreiben.</para>

      <programlisting>/a  -maproot=root  host.example.com box.example.org</programlisting>

      <para>Damit ein Client auf ein exportiertes Dateisystem zugreifen
        kann, muss ihm dies explizit gestattet werden.  Stellen Sie also
	sicher, dass der Client in <filename>/etc/exports</filename>
	aufgef&uuml;hrt wird.</para>

      <para>Jede Zeile in <filename>/etc/exports</filename> entspricht
        der Exportinformation f&uuml;r ein Dateisystem auf einen Rechner.
	Ein entfernter Rechner kann f&uuml;r jedes Dateisystem nur
	einmal festgelegt werden, und kann auch nur einen Standardeintrag
	haben.  Nehmen wir an, dass <filename>/usr</filename>
        ein einziges Dateisystem ist.  Dann w&auml;ren folgende Zeilen
	ung&uuml;ltig:</para>

      <programlisting>
/usr/src   client
/usr/ports client
      </programlisting>

      <para>Das Dateisystem <filename>/usr</filename> wird hier zweimal
	auf den selben Rechner (<hostid>client</hostid>)
	exportiert.  Dies ist aber nicht zul&auml;ssig.  Der richtige
	Eintrag sieht daher so aus:</para>

      <programlisting>/usr/src /usr/ports  client</programlisting>

      <para>Die Eigenschaften eines auf einen anderen Rechner
        exportierten Dateisystems m&uuml;ssen alle in einer Zeile
	stehen.  Zeilen, in denen kein Rechner festgelegt wird, werden
	als einzelner Rechner behandelt.  Dies schr&auml;nkt die
	M&ouml;glichkeiten zum Export von Dateisystemen ein, f&uuml;r
	die meisten Anwender ist dies aber kein Problem.</para>

      <para>Eine g&uuml;ltige Exportliste, in der
        <filename>/usr</filename> und <filename>/exports</filename>
	lokale Dateisysteme sind, sieht so aus:</para>

      <programlisting>
# Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports                  client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro
      </programlisting>

      <para>Sie m&uuml;ssen <command>mountd</command> nach jeder
        &Auml;nderung von <filename>/etc/exports</filename> neu
	starten, damit die &Auml;nderungen wirksam werden.  Dies
	kann durch das Senden des HUP-Signals an den
	<command>mountd</command>-Prozess erfolgen:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>

      <para>Alternativ k&ouml;nnen Sie auch das System neu starten.
        Dies ist allerdings nicht n&ouml;tig.  Wenn Sie die folgenden
	Befehle als <username>root</username> ausf&uuml;hren, sollte
	alles korrekt gestartet werden.</para>

      <para>Auf dem <acronym>NFS</acronym>-Server:</para>

      <screen>&prompt.root; <userinput>portmap</userinput>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput></screen>

      <para>Auf dem <acronym>NFS</acronym>-Client:</para>

      <screen>&prompt.root; <userinput>nfsiod -n 4</userinput></screen>

      <para>Nun sollte alles bereit sein, um ein entferntes Dateisystem
        einh&auml;ngen zu k&ouml;nnen.  In unseren Beispielen nennen wir
	den Server <literal>server</literal>, den Client
	<literal>client</literal>.  Wenn Sie ein entferntes Dateisystem
	nur zeitweise einh&auml;ngen wollen, oder nur Ihre Konfiguration
	testen m&ouml;chten, f&uuml;hren Sie auf dem Client als
	<username>root</username> einen Befehl &auml;hnlich dem
	folgenden aus:</para>

      <indexterm>
        <primary>NFS</primary>
	<secondary>Dateisysteme einh&auml;ngen</secondary>
      </indexterm>

      <screen>&prompt.root; <userinput>mount server:/home /mnt</userinput></screen>

      <para>Dadurch wird das Verzeichnis <filename>/home</filename> des
        Servers auf dem Client unter <filename>/mnt</filename> eingeh&auml;ngt.
	Wenn alles korrekt konfiguriert wurde, sehen Sie auf dem Client
	im Verzeichnis <filename>/mnt</filename> alle Dateien des
	Servers.</para>

      <para>Wenn Sie ein entferntes Dateisystem nach jedem Systemstart
        automatisch einh&auml;ngen wollen, f&uuml;gen Sie das Dateisystem
	in <filename>/etc/fstab</filename> ein.  Dazu ein Beispiel:</para>

      <programlisting>server:/home	/mnt	nfs	rw	0	0</programlisting>

      <para>F&uuml;r Informationen zu allen m&ouml;glichen Optionen lesen
        Sie bitte &man.fstab.5;.</para>
    </sect2>

    <sect2>
      <title>Praktische Anwendungen</title>

      <para><acronym>NFS</acronym> ist in vielen Situationen
        n&uuml;tzlich.  Einige Anwendungsbereiche finden Sie in der
	folgenden Liste:</para>

      <indexterm>
        <primary>NFS</primary>
	<secondary>Anwendungsbeispiele</secondary>
      </indexterm>

      <itemizedlist>
        <listitem>
	  <para>Mehrere Maschinen k&ouml;nnen sich ein CD-ROM-Laufwerk
	    oder andere Medien teilen.  Dies ist billiger und au&szlig;erdem
	    praktischer, um Programme auf mehreren Rechnern zu
	    installieren.</para>
	</listitem>

	<listitem>
	  <para>In gr&ouml;&szlig;eren Netzwerken ist es praktisch,
	    einen zentralen <acronym>NFS</acronym>-Server einzurichten,
	    auf dem die Heimatverzeichnisse der Benutzer gespeichert
	    werden.  Diese Heimatverzeichnisse werden &uuml;ber das
	    Netzwerk exportiert.  Dadurch haben die Benutzer immer das
	    gleiche Heimatverzeichnis zur Verf&uuml;gung,
	    unabh&auml;ngig davon, an welchem Arbeitsplatz sie sich
	    anmelden.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Rechner k&ouml;nnen auf ein gemeinsames
	    <filename>/usr/ports/distfiles</filename>-Verzeichnis
	    zugreifen.  Wenn Sie nun einen Port auf mehreren Rechnern
	    installieren wollen, greifen Sie einfach auf dieses
	    Verzeichnis zu, ohne die Quelldateien auf jede Maschine
	    zu kopieren.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="network-amd">
    <!-- j.kois@web.de, 05. April 2003 -->
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Wylie</firstname>
	    <surname>Stilwell</surname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>

	<authorgroup>
	  <author>
	    <firstname>Chern</firstname>
	    <surname>Lee</surname>
	    <contrib>&Uuml;berarbeitet von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>AMD</title>

      <indexterm><primary>amd</primary></indexterm>
      <indexterm><primary>Automatic Mounter Daemon</primary></indexterm>

      <para>&man.amd.8; (Automatic Mounter Daemon) h&auml;ngt ein
	entferntes Dateisystem automatisch ein,
	wenn auf eine Datei oder ein Verzeichnis in diesem Dateisystem
	zugegriffen wird.  Dateisysteme, die &uuml;ber einen gewissen
	Zeitraum inaktiv sind, werden von <application>amd</application>
	automatisch abgeh&auml;ngt.
	<application>amd</application> ist eine einfache
	Alternative zum dauerhaften Einh&auml;ngen von Dateisystemen
	in <filename>/etc/fstab</filename>.</para>

      <para>In der Voreinstellung stellt <application>amd</application>
	die Verzeichnisse <filename>/host</filename> und
	<filename>/net</filename> als NFS-Server bereit.  Wenn auf eine Datei
	in diesen Verzeichnissen zugegriffen wird, sucht
	<application>amd</application> den entsprechenden Mountpunkt
	und h&auml;ngt das Dateisystem automatisch ein.
	<filename>/net</filename> wird zum Einh&auml;ngen von
	exportierten Dateisystemen von einer IP-Adresse verwendet,
	w&auml;hrend <filename>/host</filename> zum Einh&auml;ngen
	von exportierten Dateisystemen eines durch seinen Namen
	festgelegten Rechners dient.</para>

      <para>Ein Zugriff auf eine Datei in
        <filename>/host/foobar/usr</filename> w&uuml;rde
	<application>amd</application> veranlassen,
	das von <hostid>foobar</hostid> exportierte Dateisystem
	<filename>/usr</filename> einzuh&auml;ngen.</para>

      <example>
	<title>Ein exportiertes Dateisystem mit
	  <application>amd</application> in den Verzeichnisbaum
	    einh&auml;ngen</title>

	<para>Sie k&ouml;nnen sich die verf&uuml;gbaren Mountpunkte
	  eines entfernten Rechners mit <command>showmount</command>
	  ansehen.  Wollen Sie sich die Mountpunkte des Rechners
	  <hostid>foobar</hostid> ansehen, so verwenden Sie:</para>

	<screen>&prompt.user; <userinput>showmount -e foobar</userinput>
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
&prompt.user; <userinput>cd /host/foobar/usr</userinput></screen>
      </example>

      <para>Wie Sie an diesem Beispiel erkennen k&ouml;nnen, zeigt
        <command>showmount</command> <filename>/usr</filename>
	als exportiertes Dateisystem an.  Wenn man in das Verzeichnis
	<filename>/host/foobar/usr</filename> wechselt, versucht
	<application>amd</application> den Rechnernamen
	<hostid>foobar</hostid>	aufzul&ouml;sen	und den gew&uuml;nschten
	Export in den Verzeichnisbaum einzuh&auml;ngen.</para>

      <para><application>amd</application> kann durch das Einf&uuml;gen
        der folgenden Zeile in <filename>/etc/rc.conf</filename>
	automatisch gestartet werden:</para>

      <programlisting>amd_enable="YES"</programlisting>

      <para>Mit der Option <varname>amd_flags</varname> kann
        <application>amd</application> angepasst werden.
	Die Voreinstellung f&uuml;r <varname>amd_flags</varname> sieht
	so aus:</para>

      <programlisting>amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"</programlisting>

      <para><filename>/etc/amd.map</filename> legt die Standardoptionen
        fest, mit denen exportierte Dateisysteme in den Verzeichnisbaum
	eingeh&auml;ngt werden.  <filename>/etc/amd.conf</filename>
	hingegen legt einige der erweiterten Optionen von
	<application>amd</application> fest.</para>

      <para>F&uuml;r weitere Informationen lesen Sie bitte &man.amd.8;
        und &man.amd.conf.5;.</para>
    </sect2>

    <sect2 id="network-nfs-integration">
      <!-- j.kois@web.de, 05. April 2003 -->
      <sect2info>
        <authorgroup>
          <author>
            <firstname>John</firstname>
            <surname>Lind</surname>
            <contrib>Beigetragen von </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Integrationsprobleme mit anderen Systemen</title>

      <para>Bestimmte ISA-Ethernetadapter haben Beschr&auml;nkungen, die
        zu ernsthaften Netzwerkproblemen, insbesondere mit NFS
	f&uuml;hren k&ouml;nnen.  Es handelt sich dabei nicht um ein
	FreeBSD-spezifisches Problem, aber FreeBSD-Systeme sind davon
	ebenfalls betroffen.</para>

      <para>Das Problem tritt fast ausschlie&szlig;lich dann auf, wenn
        (FreeBSD)-PC-Systeme mit Hochleistungsrechnern verbunden werden,
	wie Systemen von Silicon&nbsp;Graphics, Inc. oder
	Sun&nbsp;Microsystems, Inc.  Das Einh&auml;ngen via NFS funktioniert
	problemlos, auch einige	Dateioperationen k&ouml;nnen erfolgreich
	sein.  Pl&ouml;tzlich aber wird der Server nicht mehr auf den
	Client reagieren, obwohl Anfragen an und von anderen Rechnern
	weiter bearbeitet werden.  Dieses Problem betrifft stets den
	Client, egal ob es sich beim Client um das FreeBSD-System oder
	den Hochleistungsrechner handelt.  Auf vielen Systemen gibt es
	keine M&ouml;glichkeit mehr, den Client ordnungsgem&auml;&szlig;
	zu beenden.  Die einzige L&ouml;sung ist oft, den Rechner neu
	zu starten, da dieses NFS-Problem nicht mehr behoben werden kann.</para>

      <para>Die <quote>korrekte</quote> L&ouml;sung f&uuml;r dieses
        Problem ist es, sich eine schnellere Ethernetkarte f&uuml;r
	FreeBSD zu kaufen.  Allerdings gibt es auch eine einfache und
	meist zufriedenstellende L&ouml;sung, um dieses Problem zu
	umgehen.  Wenn es sich beim FreeBSD-System um den
	<emphasis>Server</emphasis> handelt, verwenden Sie beim
	Einh&auml;ngen in den Verzeichnisbaum auf der Clientseite
	zus&auml;tzlich die Option <option>-w=1024</option> .  Wenn es
	sich beim FreeBSD-System um den <emphasis>Client</emphasis>
	handelt, dann h&auml;ngen Sie das NFS-Dateisystem mit der
	zus&auml;tzlichen Option <option>-r=1024</option> ein.
	Diese Optionen k&ouml;nnen auf der Clientseite auch durch
	das vierte Feld der Eintr&auml;ge in <filename>/etc/fstab</filename>
	festgelegt werden, damit die Dateisysteme automatisch eingeh&auml;ngt
	werden.  Um die Dateisysteme manuell einzuh&auml;ngen, verwendet
	man bei <command>mount</command> zus&auml;tzlich die Option
	<option>-o</option>.</para>

      <para>Es gibt ein anderes Problem, das oft mit diesem verwechselt
        wird.  Dieses andere Problem tritt auf, wenn sich &uuml;ber NFS
	verbundene Server und Clients in verschiedenen Netzwerken
	befinden.  Wenn dies der Fall ist, stellen Sie
	<emphasis>sicher</emphasis>, dass Ihre Router die
	n&ouml;tigen UDP-Informationen weiterleiten, oder Sie werden
	nirgends hingelangen, egal was Sie machen.</para>

      <para>In den folgenden Beispielen ist <hostid>fastws</hostid> der
        Name des Hochleistungsrechners (bzw. dessen Schnittstelle),
	<hostid>freebox</hostid> hingegen ist der Name des
	FreeBSD-Systems, das &uuml;ber eine Netzkarte mit geringer
	Leistung verf&uuml;gt.  <filename>/sharedfs</filename> ist das
	exportierte NFS&nbsp;-Dateisystem (lesen Sie dazu auch
	&man.exports.5;).  Bei <filename>/project</filename> handelt es
	sich um den Mountpunkt, an dem das exportierte Dateisystem auf
	der Clientseite	eingeh&auml;ngt wird.  In allen F&auml;llen
	k&ouml;nnen zus&auml;tzliche Optionen, wie z.B.
	<option>hard</option>, <option>soft</option> oder
	<option>bg</option> w&uuml;nschenswert sein.</para>

      <para>FreeBSD als Client (eingetragen in
        <filename>/etc/fstab</filename> auf <hostid>freebox</hostid>):</para>

      <programlisting>fastws:/sharedfs /project nfs rw,-r=1024 0 0</programlisting>

      <para>Manuelles Einh&auml;ngen auf <hostid>freebox</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sharedfs /project</userinput></screen>

      <para>FreeBSD als Server (eingetragen in
        <filename>/etc/fstab</filename> auf <hostid>fastws</hostid>):</para>

      <programlisting>freebox:/sharedfs /project nfs rw,-w=1024 0 0</programlisting>

      <para>Manuelles Einh&auml;ngen auf <hostid>fastws</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sharedfs /project</userinput></screen>

      <para>Nahezu alle 16-bit Ethernetadapter erlauben Operationen
        ohne obengenannte Einschr&auml;nkungen auf die Lese- oder
	Schreibgr&ouml;&szlig;e.</para>

      <para>F&uuml;r alle technisch Interessierten wird nun beschrieben,
        was passiert, wenn dieser Fehler auftritt, und warum er
	irreversibel ist.  NFS arbeitet &uuml;blicherweise mit einer
	<quote>Blockgr&ouml;&szlig;e</quote> von 8&nbsp;kByte (obwohl
	es kleinere Fragmente zulassen w&uuml;rde).  Da die maximale
	Rahmengr&ouml;&szlig;e von Ethernet 1500&nbsp;Bytes
	betr&auml;gt, wird der NFS-<quote>Block</quote> in einzelne
	Ethernetrahmen aufgeteilt, obwohl es sich nach wie vor um eine
	Einheit handelt, die auch als Einheit empfangen, verarbeitet
	und <emphasis>best&auml;tigt</emphasis> werden muss.  Der
	Hochleistungsrechner verschickt die Pakete, aus denen der
	NFS-Block besteht, so eng hintereinander, wie es der Standard
	erlaubt.  Auf der anderen Seite (auf der sich die langsamere
	Netzkarte befindet), &uuml;berschreiben die sp&auml;teren
	Pakete ihre Vorg&auml;nger, bevor diese vom System verarbeitet
	werden (&Uuml;berlauf!).  Dies hat zur Folge, dass der NFS-Block
	nicht mehr rekonstruiert und best&auml;tigt werden kann.  Als
	Folge davon glaubt der Hochleistungsrechner, dass der andere
	Rechner nicht erreichbar ist (Timeout!) und versucht die
	Sendung zu wiederholen.  Allerdings wird wiederum der komplette
	NFS-Block verschickt, so dass sich der ganze Vorgang wiederholt,
	und zwar immer wieder (oder bis zum Systemneustart).</para>

      <para>Indem wir die Einheitengr&ouml;&szlig;e unter der maximalen
        Gr&ouml;&szlig;e der Ethernetpakete halten, k&ouml;nnen wir
	sicherstellen, dass jedes vollst&auml;ndig erhaltene
	Ethernetpaket individuell angesprochen werden kann und vermeiden
	die Blockierung des Systems.</para>

      <para>&Uuml;berl&auml;ufe k&ouml;nnen zwar nach wie vor auftreten,
        wenn ein Hochleistungsrechner Daten auf ein PC-System
	transferiert.  Durch die besseren (und schnelleren) Netzkarten
	treten solche &Uuml;berl&auml;ufe allerdings nicht mehr
	<emphasis>zwingend</emphasis> auf, wenn
	NFS-<quote>Einheiten</quote> &uuml;bertragen werden.  Tritt nun
	ein &Uuml;berlauf auf, wird die betroffene Einheit erneut
	verschickt, und es besteht eine gute Chance, dass sie nun
	erhalten, verarbeitet und best&auml;tigt werden kann.</para>
    </sect2>
  </sect1>

  <sect1 id="network-diskless">
    <!-- j.kois@web.de, 05.05.2003 -->
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Jean-Fran&ccedil;ois</firstname>
          <surname>Dock&egrave;s</surname>
          <contrib>Aktualisiert von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Start und Betrieb von FreeBSD &uuml;ber ein Netzwerk</title>

    <indexterm>
      <primary>plattenloser Arbeitsplatz</primary>
    </indexterm>
    <indexterm>
      <primary>plattenloser Betrieb</primary>
    </indexterm>

    <para>FreeBSD kann &uuml;ber ein Netzwerk starten und arbeiten, ohne
      eine lokale Festplatte zu verwenden, indem es Dateisysteme eines
      NFS-Servers in den eigenen Verzeichnisbaum einh&auml;ngt.  Dazu
      sind, von den Standardkonfigurationsdateien abgesehen, keine
      System&auml;nderungen n&ouml;tig.  Ein solches System kann leicht
      installiert werden, da alle notwendigen Elemente bereits vorhanden
      sind:</para>

    <itemizedlist>
      <listitem>
        <para>Es gibt mindestens zwei M&ouml;glichkeiten, den Kernel
          &uuml;ber das Netzwerk zu laden:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>PXE</emphasis>: Das
              <quote>Preboot Execution Environment System</quote> von
              Intel ist eine Art intelligentes Boot-ROM, das in einigen
              Netzkarten oder Hauptplatinen verwendet wird.  Lesen Sie
              &man.pxeboot.8; f&uuml;r weitere Informationen.</para>
          </listitem>

          <listitem>
            <para>Der Port
              <emphasis><application>etherboot </application></emphasis>
              (<filename role="package">net/etherboot</filename>) erzeugt
              ROM-f&auml;higen Code, um einen Kernel &uuml;ber das
              Netzwerk zu laden.  Dieser Code kann entweder auf ein
              Boot-PROM einer Netzkarte gebrannt werden, was von vielen
              Netzkarten unterst&uuml;tzt wird.  Oder er kann von einer
              lokalen Diskette, Festplatte oder von einem laufenden
              MS-DOS-System geladen werden.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Das Beispielskript
          (<filename>/usr/share/examples/diskless/clone_root</filename>)
          erleichtert die Erzeugung und die Wartung des root-Dateisystems
          auf dem Server.  Das Skript muss wahrscheinlich angepasst
          werden, dennoch werden Sie schnell zu einem Ergebnis kommen.
        </para>
      </listitem>

      <listitem>
        <para>Die Startdateien, die einen plattenlosen Systemstart
          erkennen und unterst&uuml;tzen, sind nach der Installation
          in <filename>/etc</filename> vorhanden.</para>
      </listitem>

      <listitem>
        <para>Dateiauslagerungen k&ouml;nnen sowohl via NFS als auch
          auf die lokale Platte erfolgen.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt verschiedene Wege, einen plattenlosen Rechner
      einzurichten.  Viele Elemente sind daran beteiligt, die fast
      immer an den pers&ouml;nlichen Geschmack angepasst werden
      k&ouml;nnen.  Die folgende Beschreibung erkl&auml;rt die
      Installation eines kompletten Systems, wobei der Schwerpunkt auf
      Einfachheit und Kompatibilit&auml;t zu den Standardstartskripten
      von FreeBSD liegt.  Das beschriebene System hat folgende
      Eigenschaften:</para>

    <itemizedlist>
      <listitem>
        <para>Die plattenlosen Rechner haben ein gemeinsames
          <filename>root</filename>- sowie ein gemeinsames
          <filename>/usr</filename>-Dateisystem, die jeweils
          schreibgesch&uuml;tzt sind.</para>

        <para>Das <filename>root</filename>-Dateisystem ist eine Kopie
          eines Standardwurzelverzeichnisses von FreeBSD
          (&uuml;blicherweise das des Servers), bei dem einige
          Konfigurationsdateien durch f&uuml;r den plattenlosen
          Betrieb geeignete Versionen ersetzt wurden.</para>

        <para>F&uuml;r die Bereiche von <filename>root</filename>, die
          beschreibbar sein m&uuml;ssen, werden mit &man.mfs.8;
          virtuelle Dateisysteme erzeugt.  Dies bedeutet aber auch, dass
          alle Ver&auml;nderungen verloren gehen, wenn das System neu
          gestartet wird.</para>
      </listitem>

      <listitem>
          <para>Der Kernel wird von <application>etherboot</application>
            geladen.  Dazu werden DHCP (oder BOOTP) und TFTP verwendet.</para>
      </listitem>
    </itemizedlist>

    <caution><para>Das hier beschriebene System ist nicht sicher.  Es
      sollte nur in einem gesicherten Bereich eines Netzwerks verwendet
      werden und f&uuml;r andere Rechner nicht erreichbar sein.</para>
    </caution>

    <sect2>
      <title>Installationsanweisungen</title>
      <indexterm>
	<primary>plattenloser Betrieb</primary>
	<secondary>Systemstart</secondary>
      </indexterm>

      <sect3>
        <title>DHCP/BOOTP konfigurieren</title>

        <para>Es gibt zwei h&auml;ufig verwendete Protokolle, um Rechner
          zu starten, die ihre Konfiguration &uuml;ber ein Netzwerk
          erhalten: BOOTP und DHCP.  Diese werden in verschiedenen
          Phasen des Startvorganges verwendet:</para>

        <itemizedlist>
          <listitem><para><application>etherboot</application> verwendet
            DHCP (Voreinstellung) oder BOOTP (muss vorher konfiguriert
            werden), um den Kernel zu finden (PXE verwendet DHCP).</para>
          </listitem>

          <listitem><para>Der Kernel verwendet BOOTP, um das
            NFS-Wurzelverzeichnis zu finden.</para>
          </listitem>
        </itemizedlist>

        <para>Es ist m&ouml;glich, das System so zu konfigurieren, dass
          es nur BOOTP verwendet.  Das &man.bootpd.8;-Serverprogramm ist
          bereits im Basissystem enthalten.</para>

        <para>DHCP hat im Vergleich zu BOOTP allerdings mehrere Vorteile
          (bessere Konfigurationsdateien, die M&ouml;glichkeit zur
          Verwendung von PXE, sowie viele andere, die nicht in direktem
          Zusammenhang mit dem plattenlosen Betrieb stehen), daher werden
          hier beide Methoden, die ausschlie&szlig;liche Verwendung von
          BOOTP sowie die gemeinsame Nutzung von BOOTP und DHCP
          beschrieben.  Der Schwerpunkt liegt dabei auf der Betrachtung
          von DHCP.  Dazu wird das Softwarepaket ISC-DHCP verwendet.</para>

        <sect4>
          <title>Konfiguration unter Verwendung von ISC DHCP</title>
          <indexterm>
            <primary>DHCP</primary>
	    <secondary>plattenloser Betrieb</secondary>
          </indexterm>

          <para>Der <application>isc-dhcp</application>-Server kann
            Anfragen sowohl von BOOTP als auch von DHCP beantworten.
          </para>

          <para><application>isc-dhcp 3.0</application> ist nicht Teil
            des Basissystems.  Sie m&uuml;ssen es daher zuerst
            installieren.  Verwenden Sie dazu den Port
            <filename role="package">net/isc-dhcp3</filename> oder das
            entsprechende Paket.  F&uuml;r allgemeine Informationen zu
            Ports und Paketen lesen Sie bitte <xref linkend="ports">.
          </para>

          <para>Nachdem <application>isc-dhcp</application> installiert
            ist, muss das Programm konfiguriert werden (normalerweise in
            <filename>/usr/local/etc/dhcpd.conf</filename>).  Nachfolgend
            finden Sie dazu ein kommentiertes Beispiel:</para>

          <programlisting>
          default-lease-time 600;
          max-lease-time 7200;
          authoritative;

          option domain-name "example.com";
          option domain-name-servers 192.168.4.1;
          option routers 192.168.4.1;

          subnet 192.168.4.0 netmask 255.255.255.0 {
            use-host-decl-names on; <co id="co-dhcp-host-name">
            option subnet-mask 255.255.255.0;
            option broadcast-address 192.168.4.255;

            host margaux {
              hardware ethernet 01:23:45:67:89:ab;
              fixed-address margaux.example.com;
              next-server 192.168.4.4;<co id="co-dhcp-next-server">
              filename "/tftpboot/kernel.diskless";<co id="co-dhcp-filename">
              option root-path "192.168.4.4:/data/misc/diskless";<co id="co-dhcp-root-path">
            }
          }
          </programlisting>

          <calloutlist>
            <callout arearefs="co-dhcp-host-name"><para>Diese Option
              weist <command>dhcpd</command> an, den Wert der
              <literal>host</literal>-Deklaration als Rechnernamen des
              plattenlosen Rechners zu senden.  Alternativ kann man der
              Hostdeklaration Folgendes hinzuf&uuml;gen:
              <literal>option host-name
              <replaceable>margaux</replaceable></literal></para>
            </callout>

            <callout arearefs="co-dhcp-next-server"><para>Die Anweisung
              <literal>next-server</literal> bestimmt den TFTP-Server
              (in der Voreinstellung ist das der DHCP-Server
	      selbst).</para>
            </callout>

            <callout arearefs="co-dhcp-filename"><para>Die Anweisung
              <literal>filename</literal> bestimmt die Datei, die
              <application>etherboot</application> als Kernel l&auml;dt.
                <note><para>PXE erfordert einen relativen Dateinamen und
                  l&auml;dt <command>pxeboot</command> (dies geschieht
                  also nicht &uuml;ber die Kerneloption
                  <literal>option filename "pxeboot"</literal>).</para>
                </note>
              </para>
            </callout>

            <callout arearefs="co-dhcp-root-path"><para>Die Option
              <literal>root-path</literal> bestimmt den Pfad des
              root-Dateisystems in normaler NFS-Schreibweise.</para>
            </callout>
          </calloutlist>
        </sect4>

        <sect4>
          <title>Konfiguration bei Verwendung von BOOTP</title>
          <indexterm>
            <primary>BOOTP</primary>
	    <secondary>plattenloser Betrieb</secondary>
          </indexterm>

          <para>Es folgt nun eine der Konfiguration von DHCP
            entsprechende Konfiguration f&uuml;r
            <command>bootpd</command>.  Zu finden ist die
            Konfigurationsdatei unter <filename>/etc/bootptab</filename>.
          </para>

          <para>Beachten Sie bitte, dass
            <application>etherboot</application> mit der Option
            <literal>NO_DHCP_SUPPORT</literal> kompiliert werden muss,
            damit BOOTP verwendet werden kann.  PXE hingegen
            <emphasis>ben&ouml;tigt</emphasis> DHCP.  Der einzige
            offensichtliche Vorteil von <application>bootpd</application>
            ist, dass es bereits im Basissystem vorhanden ist.</para>

          <programlisting>
            .def100:\
              :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
              :sm=255.255.255.0:\
              :ds=192.168.4.1:\
              :gw=192.168.4.1:\
              :hd="/tftpboot":\
              :bf="/kernel.diskless":\
              :rp="192.168.4.4:/data/misc/diskless":

            margaux:ha=0123456789ab:tc=.def100
          </programlisting>
        </sect4>
      </sect3>

      <sect3>
        <title>Ein Startprogramm unter Verwendung von
          <application>Etherboot</application> erstellen</title>

        <indexterm>
          <primary>Etherboot</primary>
        </indexterm>

        <para><ulink url="http://etherboot.sourceforge.net">
          Die Internetseite von Etherboot</ulink> enth&auml;lt
          <ulink url="http://etherboot.sourceforge.net/doc/html/userman.html">
          ausf&uuml;hrliche Informationen</ulink>, die zwar vor allem
          f&uuml;r Linux gedacht sind, aber dennoch n&uuml;tzliche
          Informationen enthalten.  Im Folgenden wird daher nur grob
          beschrieben, wie Sie <application>etherboot</application> auf
          einem FreeBSD-System einsetzen k&ouml;nnen.</para>

        <para>Als erstes m&uuml;ssen Sie
          <filename role="package">net/etherboot</filename> als Paket
          oder als Port installieren.  Der Port
          <application>etherboot</application> befindet sich unter
          <filename>/usr/ports/net/etherboot</filename>.  Wenn Sie
          die Portssammlung installiert haben, reicht es aus, in dieses
          Verzeichnis zu wechseln, und <command>make install</command>
          aufzurufen.
          Alles Weitere sollte automatisch ablaufen.  Ist dies nicht der
          Fall, lesen Sie bitte <xref linkend="ports">, das
          Informationen zu Ports und Paketen enth&auml;lt.</para>

        <para>F&uuml;r unsere Installation verwenden wir eine
          Startdiskette.  F&uuml;r Informationen zu anderen Methoden
          (PROM oder DOS-Programme) lesen Sie bitte die Dokumentation zu
          <application>etherboot</application>.</para>

        <para>Um eine Startdiskette zu erzeugen, legen Sie eine Diskette
          in das Laufwerk des Rechners ein, auf dem Sie
          <application>etherboot</application> installiert haben.  Danach
          wechseln Sie in das Verzeichnis <filename>src</filename> des
          <application>etherboot</application>-Verzeichnisbaums und geben
          Folgendes ein:</para>

        <screen>
          &prompt.root; <userinput>gmake bin32/<replaceable>devicetype</replaceable>.fd0</userinput>
        </screen>

        <para><replaceable>devicetype</replaceable> h&auml;ngt vom Typ
          der Ethernetkarte ab, &uuml;ber die der plattenlose Rechner
          verf&uuml;gt.  Lesen Sie dazu <filename>NIC</filename> im
          gleichen Verzeichnis, um den richtigen Wert f&uuml;r
        <replaceable>devicetype</replaceable> zu bestimmen.</para>
      </sect3>

      <sect3>
        <title>Serverkonfiguration - TFTP und NFS</title>

        <indexterm>
          <primary>TFTP</primary>
          <secondary>plattenloser Betrieb</secondary>
        </indexterm>
        <indexterm>
          <primary>NFS</primary>
          <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <para>Sie m&uuml;ssen auf dem TFTP-Server
          <command>tftpd</command> aktivieren:</para>

        <procedure>
          <step>
            <para>Erzeugen Sie ein Verzeichnis, in dem
              <command>tftpd</command> seine Dateien ablegt,
              beispielsweise <filename>/tftpboot</filename>.</para>
          </step>

          <step>
            <para>F&uuml;gen Sie folgende Zeile in
              <filename>/etc/inetd.conf</filename> ein:</para>

            <programlisting>tftp    dgram   udp     wait    root  /usr/libexec/tftpd    tftpd -s /tftpboot</programlisting>

            <note><para>Anscheinend ben&ouml;tigen zumindest einige
              PXE-Versionen die TCP-Version von TFTP.  Sollte dies der
              Fall sein, f&uuml;gen Sie eine zweite Zeile ein, in der
              Sie <literal>dgram udp</literal> durch
              <literal>stream tcp</literal> ersetzen.</para>
            </note>
          </step>

          <step>
            <para>Weisen Sie <command>inetd</command> an, seine
              Konfiguration erneut einzulesen:</para>

            <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
          </step>
        </procedure>

        <para>Sie k&ouml;nnen das Verzeichnis
          <filename>/tftpboot</filename> an einem beliebigen Ort auf dem
          Server ablegen.  Stellen Sie aber sicher, dass Sie diesen Ort
          sowohl in <filename>inetd.conf</filename> als auch in
          <filename>dhcpd.conf</filename> eingetragen.</para>

        <para>Au&szlig;erdem m&uuml;ssen Sie NFS aktivieren und die
          entsprechenden Verzeichnisse exportieren.</para>

        <procedure>
          <step>
            <para>F&uuml;gen Sie folgende Zeile in
              <filename>/etc/rc.conf</filename> ein:</para>

            <programlisting>nfs_server_enable="YES"</programlisting>
          </step>

          <step>
            <para>Exportieren Sie das Verzeichnis, in dem sich das
              Wurzelverzeichnis f&uuml;r den plattenlosen Betrieb
              befindet, indem Sie folgende Zeile in
              <filename>/etc/exports</filename> einf&uuml;gen (passen
              Sie dabei den Einh&auml;ngpunkt an und ersetzen Sie
              <replaceable>margaux</replaceable> durch den Namen Ihres
              plattenlosen Rechners):</para>

            <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux</replaceable></programlisting>
          </step>

          <step>
            <para>Weisen sie nun <command>mountd</command> an, seine
              Konfigurationsdatei erneut einzulesen.  Wenn Sie NFS erst
              in <filename>/etc/rc.conf</filename> aktivieren mussten,
              sollten Sie stattdessen den Rechner neu starten.  Dadurch
              wird die Konfigurationsdatei ebenfalls neu eingelesen.
            </para>

            <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>
          </step>
        </procedure>
      </sect3>

      <sect3>
        <title>Einen plattenlosen Kernel erzeugen</title>

        <indexterm>
          <primary>plattenloser Betrieb</primary>
          <secondary>Kernelkonfiguration</secondary>
        </indexterm>

        <para>F&uuml;gen Sie in Ihre Kernelkonfigurationsdatei
          zus&auml;tzlich folgende Optionen ein:</para>

        <programlisting>
          options     BOOTP          # Use BOOTP to obtain IP address/hostname
          options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info
          options     BOOTP_COMPAT   # Workaround for broken bootp daemons.
        </programlisting>

        <para>Au&szlig;erdem k&ouml;nnen Sie die Optionen
          <literal>BOOTP_NFSV3</literal> und
          <literal>BOOTP_WIRED_TO</literal> verwenden (sehen Sie sich
          dazu auch <filename>LINT</filename> an).</para>

        <para>Erzeugen Sie den neuen Kernel (lesen Sie dazu auch
          <xref linkend="kernelconfig">) und kopieren Sie ihn unter dem
          in <filename>dhcpd.conf</filename> angegebenen Namen ins
          TFTP-Verzeichnis.</para>
      </sect3>

      <sect3>
        <title>Das root-Dateisystem erzeugen</title>

        <indexterm>
          <primary>Root-Dateisystem</primary>
	  <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <para>Sie m&uuml;ssen f&uuml;r den plattenlosen Rechner ein
          root-Dateisystem erzeugen, und zwar an dem in
          <filename>dhcpd.conf</filename> als
          <literal>root-path</literal> festgelegten Ort.</para>

        <para>Der einfachste Weg, dies zu tun, ist die Verwendung des
          Shellskripts
          <filename>/usr/share/examples/diskless/clone_root</filename>.
          Dieses Skript muss von Ihnen allerdings noch angepasst werden.
          Unbedingt n&ouml;tig ist der Ort, an dem das Dateisystem
          erzeugt werden soll.  Dies geschieht &uuml;ber die Variable
          <literal>DEST</literal>.

        <para>Lesen Sie die Kommentare am Beginn des Skripts f&uuml;r
          weitere Informationen.  Dort wird erkl&auml;rt, wie das
          Basisdateisystem erzeugt wird und wie einzelne Dateien durch
          angepasste Versionen f&uuml;r den plattenlosen Betrieb,
	  f&uuml;r ein Subnetzwerk oder f&uuml;r einen speziellen
	  Rechner ersetzt werden.  Ebenfalls enthalten sind Beispiele
	  f&uuml;r <filename>/etc/fstab</filename> und
          <filename>/etc/rc.conf</filename>, die f&uuml;r den
          plattenlosen Betrieb angepasst sind.</para>

        <para>Die <filename>README</filename>-Dateien unter
          <filename>/usr/share/examples/diskless</filename> enthalten
          sehr viele interessante Hintergrundinformationen.  Gemeinsam
          mit den Beispielen im Verzeichnis <filename>diskless</filename>
          beschreiben sie allerdings eine Konfigurationsmethode, die von
          der in <filename>clone_root</filename> und
          <filename>/etc/rc.diskless[12]</filename> abweicht.  Dies kann
          etwas verwirrend sein.  Verwenden Sie diese Dateien also nur,
          wenn Sie weitere Informationen ben&ouml;tigen.  Es sei denn,
          Sie wollen die dort beschriebene Methode verwenden.  In diesem
          Fall m&uuml;ssen Sie allerdings die
          <filename>rc</filename>-Skripte anpassen.</para>
      </sect3>

      <sect3>
        <title>Den Auslagerungsbereich konfigurieren</title>

        <para>Falls n&ouml;tig, kann eine auf dem NFS-Server liegende
          Datei als Auslagerungsdatei eingerichtet werden.  Die
          genauen Optionen f&uuml;r <filename>bootptab</filename>
          oder <filename>dhcpd.conf</filename> sind zurzeit allerdings
          nicht vollst&auml;ndig dokumentiert.  Die folgenden
          Einstellungen wurden bereits auf einigen Systemen mit
          <filename>isc-dhcp 3.0rc11</filename> erfolgreich getestet.
        </para>

        <procedure>
          <step><para>F&uuml;gen Sie folgende Zeilen in
            <filename>dhcpd.conf</filename> ein:</para>

            <programlisting>
              # Global section
              option swap-path code 128 = string;
              option swap-size code 129 = integer 32;

              host margaux {
                ... # Standard lines, see above
                option swap-path <replaceable>"192.168.4.4:/netswapvolume/netswap"</replaceable>;
                option swap-size <replaceable>64000</replaceable>;
              }
            </programlisting>

            <para>Die Idee dahinter ist, dass es sich bei der Option 128
              von DHCP/BOOTP (zumindest auf einem FreeBSD-Client) um den
              Pfad zur NFS-Auslagerungsdatei handelt.  Option 129
              hingegen gibt die Gr&ouml;&szlig;e der Auslagerungsdatei
              in Kilobytes an.  &Auml;ltere Versionen von
              <command>dhcpd</command> erlaubten auch Folgendes:
              <literal>option option-128 "...</literal>.  Diese Option
              scheint allerdings nicht mehr zu funktionieren.</para>

            <para><filename>/etc/bootptab</filename> w&uuml;rde hingegen
              folgende Syntax verwenden:</para>

            <para>
              <literal>T128="192.168.4.4:/netswapvolume/netswap":T129=64000</literal>
            </para>
          </step>

          <step>
            <para>Erzeugen Sie die Auslagerungsdatei(en) auf dem
              NFS-Server.</para>

            <screen>
              &prompt.root; <userinput>mkdir <replaceable>/netswapvolume/netswap</replaceable></userinput>
              &prompt.root; <userinput>cd <replaceable>/netswapvolume/netswap</replaceable></userinput>
              &prompt.root; <userinput>dd if=/dev/zero bs=1024 count=<replaceable>64000</replaceable> of=swap.<replaceable>192.168.4.6</replaceable></userinput>
              &prompt.root; <userinput>chmod 0600 swap.<replaceable>192.168.4.6</replaceable></userinput>
            </screen>

            <para><replaceable>192.168.4.6</replaceable> ist die
              IP-Adresse des plattenlosen Clients.</para>
          </step>

          <step>
            <para>Auf dem NFS-Server, auf dem die Auslagerungsdatei
              liegt, f&uuml;gen Sie in <filename>/etc/exports</filename>
              folgende Zeile ein:</para>

            <programlisting>
              <replaceable>/netswapvolume</replaceable>  -maproot=0:10 -alldirs <replaceable>margaux</replaceable>
            </programlisting>

             <para>Anschlie&szlig;end weisen Sie (wie bereits
               beschrieben) <application>mountd</application> an, die
               Exportdatei erneut einzulesen.</para>
          </step>
        </procedure>
      </sect3>

      <sect3>
        <title>Verschiedenes</title>

        <sect4>
          <title>Schreibgesch&uuml;tztes Dateisystem
	    <filename>/usr</filename></title>

          <indexterm>
            <primary>/usr</primary>
            <secondary>plattenloser Betrieb</secondary>
            <tertiary>schreibgesch&uuml;tzt</tertiary>
          </indexterm>

          <para>Wenn am plattenlosen Rechner X l&auml;uft, m&uuml;ssen
            Sie die Konfigurationsdatei von <filename>xdm</filename>
            anpassen, da Fehlermeldungen per Voreinstellung auf
            <filename>/usr</filename> geschrieben werden.</para>
        </sect4>

        <sect4>
          <title>Der Server l&auml;uft nicht unter FreeBSD</title>

	  <para>Wenn das root-Dateisystem nicht auf einem FreeBSD-Rechner
	    liegt, muss das Dateisystem zuerst unter FreeBSD erzeugt
	    werden.  Anschlie&szlig;end wird es beispielsweise mit
	    <command>tar</command> oder <command>cpio</command>
	    an den gew&uuml;nschten Ort kopiert.</para>

	  <para>Dabei kann es Probleme mit den Ger&auml;tedateien
	    in <filename>/dev</filename> geben, die durch eine
	    unterschiedliche Darstellung der  Major- und Minor-Number
	    von Ger&auml;ten auf beiden Systemen hervorgerufen werden.
	    Eine Probleml&ouml;sung besteht darin, das root-Verzeichnis
	    auf einem FreeBSD einzuh&auml;ngen und die
	    Ger&auml;tedateien dort mit <command>MAKEDEV</command>
	    zu erzeugen (seit FreeBSD&nbsp;5.0
            werden Ger&auml;tedateien allerdings mit
            &man.devfs.5; erzeugt, ein Ausf&uuml;hren von
            <command>MAKEDEV</command> ist unter diesen Versionen
            daher sinnlos).</para>
        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-isdn">
    <!-- j.kois@web.de, 10. Mai 2003 -->
    <title>ISDN -  diensteintegrierendes digitales Netzwerk</title>

    <indexterm>
      <primary>ISDN</primary>
    </indexterm>

    <para>Eine gute Quelle f&uuml;r Informationen zu ISDN ist die
      <ulink url="http://alumni.caltech.edu/~dank/isdn/">
      ISDN-Seite</ulink> von Dan Kegel.</para>

    <para>Welche Informationen finden Sie in diesem Abschnitt?</para>

    <itemizedlist>
      <listitem>
        <para>Wenn Sie in Europa leben, k&ouml;nnte der Abschnitt
          &uuml;ber ISDN-Karten f&uuml;r Sie interessant sein.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie ISDN haupts&auml;chlich dazu verwenden wollen, um
          sich &uuml;ber einen Anbieter ins Internet einzuw&auml;hlen,
          sollten Sie den Abschnitt &uuml;ber Terminaladapter lesen.
          Dies ist die flexibelste Methode, die auch die wenigsten
          Probleme verursacht.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie zwei Netzwerke miteinander verbinden, oder sich
          &uuml;ber eine ISDN-Standleitung mit dem Internet verbinden
          wollen, finden Sie entsprechende Informationen im Abschnitt
          &uuml;ber Router und Bridges.</para>
      </listitem>
    </itemizedlist>

    <para>Bei der Wahl der gew&uuml;nschten L&ouml;sung sind die
      entstehenden Kosten ein entscheidender Faktor.  Die folgenden
      Beschreibungen reichen von der billigsten bis zur teuersten
      Variante.</para>

    <sect2 id="network-isdn-cards">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Hellmuth</firstname>
            <surname>Michaelis</surname>
            <contrib>Beigetragen von </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>ISDN-Karten</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Karten</secondary>
      </indexterm>

      <para>Die ISDN-Implementation von FreeBSD unterst&uuml;tzt den
        DSS1/Q.931- (oder Euro-ISDN)-Standard nur f&uuml;r passive
        Karten.  Beginnend mit FreeBSD&nbsp;4.4 werden auch einige
        aktive Karten unterst&uuml;tzt, bei denen die Firmware auch
        andere Signalprotokolle unterst&uuml;tzt;  dies schlie&szlig;t
        auch die erste ISDN-Karte mit
        Prim&auml;rmultiplex-Unterst&uuml;tzung mit ein.</para>

      <para><application>isdn4bsd</application> erlaubt es Ihnen, sich
        unter Verwendung von <emphasis>IP over raw HDLC</emphasis> oder
        <emphasis>synchronem PPP</emphasis> mit anderen ISDN-Routern zu
        verbinden.  Dazu verwenden Sie entweder Kernel-&man.ppp.8;
        (via isppp, einem modifizierten sppp-Treiber), oder Sie benutzen
        User-&man.ppp.8;.  Wenn Sie User-&man.ppp.8; verwenden,
        k&ouml;nnen Sie zwei oder mehrere ISDN-B-Kan&auml;le
        b&uuml;ndeln.  Im Paket enthalten ist auch ein Programm mit
        Anrufbeantworterfunktion sowie verschiedene Werkzeuge, wie ein
        Softwaremodem, das 300&nbsp;Baud unterst&uuml;tzt.</para>

      <para>FreeBSD unterst&uuml;tzt eine st&auml;ndig wachsende Anzahl
        von PC-ISDN-Karten, die weltweit erfolgreich eingesetzt werden.
      </para>

      <para>Von FreeBSD unterst&uuml;tzte passive ISDN-Karten enthalten
        fast immer den ISAC/HSCX/IPAC ISDN-Chipsatz von Infineon
        (ehemals Siemens).  Unterst&uuml;tzt werden aber auch Karten mit
        Cologne Chip (diese allerdings nur f&uuml;r den ISA-Bus),
        PCI-Karten mit Winbond W6692 Chipsatz, einige Karten mit dem
        Tiger 300/320/ISAC Chipsatz sowie einige Karten mit einem
        herstellerspezifischen Chipsatz, wie beispielsweise die
        Fritz!Card PCI V.1.0 und die Fritz!Card PnP von AVM.</para>

      <para>An aktiven ISDN-Karten werden derzeit die AVM B1 BRI-Karten
        (ISA und PCI-Version) sowie die AVM T1 PRI-Karten (PCI-Version)
        unterst&uuml;tzt.</para>

      <para>Informationen zu <application>isdn4bsd</application> finden
        Sie im Verzeichnis <filename>/usr/share/examples/isdn/</filename>
        Ihres FreeBSD-Systems, oder auf der
        <ulink url="http://www.freebsd-support.de/i4b/">Internetseite</ulink>
        von <application>isdn4bsd</application>.  Dort finden Sie auch
        Verweise zu Tipps, Korrekturen, sowie weiteren Informationen,
        wie dem
        <ulink url="http://people.FreeBSD.org/~hm/">isdn4bsd-Handbuch</ulink>.
      </para>

      <para>Falls Sie an der Unterst&uuml;tzung eines zus&auml;tzlichen
        ISDN-Protokolls, einer weiteren ISDN-Karte oder an einer anderen
        Erweiterung von <application>isdn4bsd</application> interessiert
        sind, wenden Sie sich bitte an &a.hm;.</para>

      <para>F&uuml;r Fragen zur Installation, Konfiguration und zu
        sonstigen Problemen von <application>isdn4bsd</application> gibt
        es die Mailingliste &a.isdn.name;.</para>
    </sect2>

    <sect2>
      <title>ISDN-Terminaladapter</title>

      <indexterm>
        <primary>Terminaladapter</primary>
      </indexterm>

      <para>Terminaladapter (TA) sind f&uuml;r ISDN, was Modems f&uuml;r
        analoge Telefonleitungen sind.</para>

      <indexterm>
        <primary>Modem</primary>
      </indexterm>

      <para>Die meisten Terminaladapter verwenden den Standardbefehlssatz
	f&uuml;r Modems von Hayes (AT-Kommandos) und k&ouml;nnen daher als
        Modemersatz verwendet werden.</para>

      <para>Ein Terminaladapter funktioniert prinzipiell wie ein Modem,
	allerdings erfolgt der Verbindungsaufbau um einiges schneller.  Die
        Konfiguration von <link linkend="ppp">PPP</link> entspricht
        dabei exakt der eines Modems.  Stellen Sie dabei allerdings
        die serielle Geschwindigkeit so hoch wie m&ouml;glich ein.</para>

      <indexterm>
        <primary>PPP</primary>
      </indexterm>

      <para>Der Hauptvorteil bei der Verwendung eines Terminaladapters zur
        Verbindung mit einem Internetanbieter ist die M&ouml;glichkeit
        zur Nutzung von dynamischem PPP.  Da IP-Adressen immer knapper
        werden, vergeben die meisten Provider keine statischen
        IP-Adressen mehr.  Die meisten Router unterst&uuml;tzen
        allerdings keine dynamische Zuweisung von IP-Adressen.</para>

      <para>Der PPP-Daemon bestimmt die Stabilit&auml;t und
	Eigenschaften der Verbindung, wenn Sie einen Terminaladapter
	verwenden.  Daher k&ouml;nnen Sie unter FreeBSD einfach von einer
	Modemverbindung auf eine ISDN-Verbindung wechseln, wenn
	Sie PPP bereits konfiguriert haben.  Allerdings bedeutet
	dies auch, das bereits bestehende Probleme mit PPP auch unter
	ISDN auftreten werden.</para>

      <para>Wenn Sie an maximaler Stabilit&auml;t interessiert sind,
        verwenden Sie Kernel-<link linkend="ppp">PPP</link>, und
        nicht das User-<link linkend="userppp">PPP</link>.
      </para>

      <para>Folgende Terminaladapter werden von FreeBSD
	unterst&uuml;tzt:</para>

      <itemizedlist>
        <listitem>
          <para>Motorola BitSurfer und Bitsurfer Pro</para>
        </listitem>

        <listitem>
          <para>Adtran</para>
        </listitem>
      </itemizedlist>

      <para>Die meisten anderen Terminaladapter werden wahrscheinlich
	ebenfalls funktionieren, da die Hersteller von Terminaladaptern
	darauf achten, dass ihre Produkte den Standardbefehlssatz
	m&ouml;glichst gut unterst&uuml;tzen.</para>

      <para>Das wirkliche Problem mit einem externen Terminaladapter ist,
        dass, &auml;hnlich wie bei Modems, eine gute serielle Karte
        eine Grundvoraussetzung ist.</para>

      <para>Sie sollten sich die
        <ulink url="http://www.freebsd.org/doc/en_US.ISO8859-1/articles/serial-uart/index.html">
        Anleitung f&uuml;r die Nutzung serieller Ger&auml;te unter
        FreeBSD</ulink> ansehen, wenn Sie detaillierte Informationen
        &uuml;ber serielle Ger&auml;te und die Unterschiede zwischen
        asynchronen und synchronen seriellen Ports ben&ouml;tigen.</para>

      <para>Ein Terminaladapter, der an einem (asynchronen)
	seriellen Standardport angeschlossen ist, beschr&auml;nkt
	Sie auf 115,2&nbsp;Kbs.  Dies
        selbst dann, wenn Sie eine Verbindung mit 128&nbsp;Kbs haben.
        Um die volle Leistungsf&auml;higkeit von ISDN (128&nbsp;Kbs)
        nutzen zu k&ouml;nnen, m&uuml;ssen Sie den Terminaladapter
	daher an eine synchrone serielle Karte anschlie&szlig;en.</para>

      <para>Kaufen Sie keinen internen Terminaladapter in der Hoffnung,
        damit das synchron/asynchron-Problem vermeiden zu k&ouml;nnen.
	Interne Terminaladapter haben einen (asynchronen) seriellen
	Standardportchip eingebaut.  Der einzige Vorteil interner
	Terminaladapter ist es, dass Sie sich den Kauf eines seriellen
	Kabels ersparen und dass Sie ein Stromkabel weniger haben.</para>

      <para>Eine synchrone Karte mit einem Terminaladapter ist
	mindestens so schnell wie ein autonomer ISDN-Router,
	und, in Kombination mit einem einfachen 386-FreeBSD-System,
	wahrscheinlich flexibler.</para>

      <para>Die Entscheidung zwischen synchroner Karte/Terminaladapter
	und einem autonomen ISDN-Router ist eine beinahe religi&ouml;se
        Angelegenheit.  Zu diesem Thema gibt es viele Diskussionen
        in den Mailinglisten.  Suchen Sie in den
        <ulink url="http://www.freebsd.org/search/index.html">
        Archiven</ulink> danach, wenn Sie an der kompletten Diskussion
        interessiert sind.</para>
    </sect2>

    <sect2>
      <title>ISDN-Bridges und Router</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Autonome Bridge/Router</secondary>
      </indexterm>

      <para>ISDN-Bridges und Router sind keine Eigenheit von
        FreeBSD oder eines anderen Betriebssystems.  F&uuml;r eine
        vollst&auml;ndigere Beschreibung von Routing und
        Netzwerkkopplungen mit einer Bridge informieren Sie sich
        bitte durch weiterf&uuml;hrende Literatur.</para>

      <para>In diesem Abschnitt werden die Begriffe Router und
        Bridge synonym verwendet.</para>

      <para>ISDN-Router und Bridges werden immer g&uuml;nstiger und damit
        auch immer beliebter.  Ein ISDN-Router ist eine kleine Box, die
        direkt an Ihr lokales Ethernet-Netzwerk angeschlossen wird und
        sich mit mit einem Router oder einer Bridge verbindet.  Die
        eingebaute Software erm&ouml;glicht die Kommunikation &uuml;ber
        PPP oder andere beliebte Protokolle.</para>

      <para>Ein Router erm&ouml;glicht einen deutlich h&ouml;heren
        Datendurchsatz als ein herk&ouml;mmlicher Terminaladapter,
	da er eine vollsynchrone ISDN-Verbindung nutzt.</para>

      <para>Das Hauptproblem mit ISDN-Routern und Bridges ist,
        dass die Zusammenarbeit zwischen Ger&auml;ten verschiedener
        Hersteller nach wie vor ein Problem ist.  Wenn Sie sich auf
        diese Weise mit einem Internetanbieter verbinden wollen,
        kl&auml;ren Sie daher vorher ab, welche Anforderungen Ihre
        Ger&auml;te erf&uuml;llen m&uuml;ssen.</para>

      <para>Eine ISDN-Bridge ist eine einfache und wartungsarme
	L&ouml;sung, zwei Netze, beispielsweise Ihr privates Netz
	und Ihr Firmennetz, miteinander zu verbinden.  Da Sie die
        technische Ausstattung f&uuml;r beide Seiten kaufen m&uuml;ssen,
        ist sichergestellt, dass die Verbindung funktionieren
        wird.</para>

      <para>Um beispielsweise einen privaten Computer oder eine
        Zweigstelle mit dem Hauptnetzwerk zu verbinden, k&ouml;nnte
        folgende Konfiguration verwendet werden:</para>

      <example>
        <title>Kleines Netzwerk (Privatnetz)</title>

        <indexterm>
          <primary>10 base 2</primary>
        </indexterm>

        <para>Das Netzwerk basiert auf der Bustopologie mit 10base2
          Ethernet (<quote>Thinnet</quote>).  Falls n&ouml;tig, stellen
          Sie die Verbindung zwischen Router und Netzwerkkabel mit einem
          AUI/10BT-Transceiver her.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-bus">
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
---Sun Workstation
|
---FreeBSD Rechner
|
---Windows 95
|
Autonomer Router
   |
ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>10Base2 - Ethernet</phrase>
          </textobject>
        </mediaobject>

        <para>Wenn Sie nur einen einzelnen Rechner verbinden wollen,
          k&ouml;nnen Sie auch ein Twisted-Pair-Kabel (Cross-Over)
          verwenden, das direkt an den Router angeschlossen wird.</para>
      </example>

      <example>
        <title>Gro&szlig;es Netzwerk (Firmennetz)</title>

        <indexterm>
          <primary>10 base T</primary>
        </indexterm>

        <para>Dieses Netzwerk basiert auf der Sterntopologie und 10baseT
          Ethernet (<quote>Twisted Pair</quote>).</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-twisted-pair">
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
-------Novell Server
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---Autonomer Router
                |
        ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>ISDN Netzwerkdiagramm</phrase>
          </textobject>
        </mediaobject>
      </example>

      <para>Ein gro&szlig;er Vorteil der meisten Router und Bridges
	ist es, dass man <emphasis>gleichzeitig</emphasis> zwei
	<emphasis>unabh&auml;ngige</emphasis> PPP-Verbindungen
	zu zwei verschiedenen Zielen aufbauen kann.  Diese
        Funktion bieten die meisten Terminaladapter nicht.  Die
        Ausnahme sind spezielle (meist teure) Modelle, die &uuml;ber
        zwei getrennte serielle Ports verf&uuml;gen.  Verwechseln Sie
        dies aber nicht mit Kanalb&uuml;ndelung oder MPP.</para>

      <para>Dies kann sehr n&uuml;tzlich sein, wenn Sie eine
        ISDN-Standleitung in Ihrem B&uuml;ro haben, die sie
        aufteilen wollen, ohne eine zus&auml;tzliche ISDN-Leitung
        zu installieren.  Ein ISDN-Router kann &uuml;ber einen B-Kanal
        (64&nbsp;Kbps) eine dedizierte Verbindung ins Internet aufbauen,
        und gleichzeitig den anderen B-Kanal f&uuml;r eine separate
        Datenverbindung nutzen.  Der zweite B-Kanal kann beispielsweise
        f&uuml;r ein- oder ausgehende Verbindungen verwendet werden.
        Sie k&ouml;nnen ihn aber auch dynamisch mit dem ersten B-Kanal
        b&uuml;ndeln, um Ihre Bandbreite zu erh&ouml;hen.</para>

      <indexterm>
        <primary>IPX/SPX</primary>
      </indexterm>

      <para>Eine Ethernet-Bridge kann Daten nicht nur im IP-Protokoll,
        sondern auch in beliebigen anderen Protokollen versenden.</para>
    </sect2>
  </sect1>

  <sect1 id="network-nis">
    <title>NIS / YP (Network Information Service)</title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/nis.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>

  <sect1 id="network-dhcp">
    <title>DHCP (Dynamic Host Configuration Protocol)</title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/dhcp.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>

  <sect1 id="network-dns">
    <title>DNS (Domain Name Service)</title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/dns.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>

  <sect1 id="network-ntp">
    <title>NTP (Network Time Protocol)</title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/ntp.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>

  <sect1 id="network-natd">
    <title>NATD (Network Address Translation Daemon)</title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/natd.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>

  <sect1 id="network-inetd">
    <title>inetd <quote>Super-Server</quote></title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/inetd.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>

  <sect1 id="network-plip">
    <title>Parallel Line IP (PLIP)</title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/plip.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>

  <sect1 id="network-ipv6">
    <title>IPv6</title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/ipv6.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
