<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/advanced-networking/chapter.sgml,v 1.100 2004/05/10 00:32:45 mheinen Exp $
     basiert auf: 1.293
-->

<chapter id="advanced-networking">
  <chapterinfo>
    <authorgroup>
      <author>
	  <firstname>Johann</firstname>
	  <surname>Kois</surname>
	  <contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Weiterf&uuml;hrende Netzwerkthemen</title>

  <sect1 id="advanced-networking-synopsis">

    <title>&Uuml;bersicht</title>

    <para>Dieses Kapitel beschreibt einige der h&auml;ufiger
      verwendeten Netzwerkdienste auf UNIX-Systemen.  Es wird
      beschrieben, wie die von FreeBSD verwendeten Netzwerkdienste
      installiert, getestet und gewartet werden.  Zus&auml;tzlich sind
      im ganzen Kapitel Beispielkonfigurationsdateien vorhanden, von
      denen Sie sicherlich profitieren werden.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen von Gateways und Routen kennen.</para>
      </listitem>

      <listitem>
	<para>Bluetooth- sowie drahtlose, der Norm IEEE&nbsp;802.11
	  entsprechende, Ger&auml;te mit FreeBSD verwenden
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Eine Bridge unter FreeBSD einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Ein Netzwerkdateisystem (NFS) einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Einen plattenlosen Rechner &uuml;ber das Netzwerk starten
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Einen Netzwerkinformationsserver (NIS) f&uuml;r gemeinsame
	  Benutzerkonten einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Automatische Netzwerkeinstellungen mittels DHCP vornehmen
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Einen Domain Name Server (DNS) einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Unter Verwendung des NTP-Protokolls Uhrzeit und Datum
	  synchronisieren, sowie einen Zeitserver einrichten
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man NAT (Network Address Translation)
	  einrichtet.</para>
      </listitem>

      <listitem>
	<para>In der Lage sein, den
	  <application>inetd</application>-Daemon einzurichten.</para>
      </listitem>

      <listitem>
	<para>Zwei Computer &uuml;ber PLIP verbinden k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>IPv6 auf einem FreeBSD-Rechner einrichten
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>ATM unter &os;&nbsp;5.X einrichten k&ouml;nnen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen der <filename>/etc/rc</filename>-Skripte
	  verstanden haben.</para>
      </listitem>

      <listitem>
	<para>Mit der grundlegenden Netzwerkterminologie vertraut
	  sein.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="network-routing">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Coranth</firstname>
	  <surname>Gryphon</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Gateways und Routen</title>

    <indexterm>
      <primary>Routing</primary>
    </indexterm>
    <indexterm>
      <primary>Gateway</primary>
    </indexterm>
    <indexterm>
      <primary>Subnetz</primary>
    </indexterm>

    <para>Damit ein Rechner einen anderen &uuml;ber ein Netzwerk
      finden kann, muss ein Mechanismus vorhanden sein, der
      beschreibt, wie man von einem Rechner zum anderen gelangt.
      Dieser Vorgang wird als <firstterm>Routing</firstterm>
      bezeichnet.  Eine <quote>Route</quote> besteht aus einem
      definierten Adressenpaar: Einem <quote>Ziel</quote> und einem
      <quote>Gateway</quote>.  Dieses Paar zeigt an, dass Sie
      &uuml;ber das <emphasis>Gateway</emphasis> zum
      <emphasis>Ziel</emphasis> gelangen wollen.  Es gibt drei Arten
      von Zielen: Einzelne Rechner (Hosts), Subnetze und das
      <quote>Standard</quote>ziel.  Die <quote>Standardroute</quote>
      wird verwendet, wenn keine andere Route zutrifft.  Wir werden
      Standardrouten sp&auml;ter etwas genauer behandeln.
      Au&szlig;erdem gibt es drei Arten von Gateways: Einzelne Rechner
      (Hosts), Schnittstellen (Interfaces, auch als <quote>Links</quote>
      bezeichnet), sowie Ethernet Hardware-Adressen (MAC-Adressen).
    </para>

    <sect2>
      <title>Ein Beispiel</title>

      <para>Um die verschiedenen Aspekte des Routings zu
	veranschaulichen, verwenden wir folgende Ausgaben von
	<command>netstat</command>:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination               Gateway            Flags       Refs     Use     Netif Expire

default                   outside-gw         UGSc        37       418     ppp0
localhost                 localhost          UH          0        181     lo0
test0                     0:e0:b5:36:cf:4f   UHLW        5        63288   ed0    77
10.20.30.255              link#1             UHLW        1        2421
example.com               link#1             UC          0        0
host1                     0:e0:a8:37:8:1e    UHLW        3        4601    lo0
host2                     0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>
host2.example.com         link#1             UC          0        0
224                       link#1             UC          0        0
</screen>

      <indexterm>
	<primary>Default-Route</primary>
      </indexterm>
      <indexterm>
	<primary>Standardroute</primary>
      </indexterm>

      <para>Die ersten zwei Zeilen geben die Standardroute (die wir
	im <link linkend="network-routing-default"> n&auml;chsten
	Abschnitt</link> behandeln), sowie die
	<hostid>localhost</hostid> Route an.</para>

      <indexterm>
	<primary>Loopback-Ger&auml;t</primary>
      </indexterm>

      <para>Das in der Routingtabelle f&uuml;r
	<literal>localhost</literal> festgelegte Interface
	(<literal>Netif</literal>-Spalte)
	<devicename>lo0</devicename>, ist auch als loopback-Ger&auml;t
	(Pr&uuml;fschleife) bekannt.  Das hei&szlig;t, dass der ganze
	Datenverkehr f&uuml;r dieses Ziel intern (innerhalb des
	Ger&auml;tes) bleibt, anstatt ihn &uuml;ber ein Netzwerk (LAN)
	zu versenden, da das Ziel dem Start entspricht.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC-Adresse</secondary>
      </indexterm>

      <para>Der n&auml;chste auff&auml;llige Punkt sind die mit
	<hostid role="mac">0:e0:</hostid> beginnenden Adressen.  Es
	handelt sich dabei um Ethernet Hardwareadressen, die auch als
	MAC-Adressen bekannt sind.  FreeBSD identifiziert Rechner im
	lokalen Netz automatisch (im Beispiel <hostid>test0</hostid>)
	und f&uuml;gt eine direkte Route zu diesem Rechner hinzu.  Dies
	passiert &uuml;ber die Ethernet-Schnittstelle
	<devicename>ed0</devicename>.  Au&szlig;erdem existiert ein Timeout
	(in der Spalte <literal>Expire</literal>) f&uuml;r diese Art
	von Routen, der verwendet wird, wenn dieser Rechner in einem
	definierten Zeitraum nicht reagiert.  Wenn dies passiert, wird
	die Route zu diesem Rechner automatisch gel&ouml;scht.
	Rechner im lokalen Netz werden durch einen als RIP (Routing
	Information Protocol) bezeichneten Mechanismus identifiziert,
	der den k&uuml;rzesten Weg zu den jeweiligen Rechnern
	bestimmt.</para>

      <indexterm>
	<primary>Subnetz</primary>
      </indexterm>

      <para>FreeBSD f&uuml;gt au&szlig;erdem Subnetzrouten f&uuml;r das
	lokale Subnetz hinzu (<hostid
	role="ipaddr">10.20.30.255</hostid> ist die Broadcast-Adresse
	f&uuml;r das Subnetz <hostid role="ipaddr">10.20.30</hostid>,
	<hostid role="domainname">example.com</hostid> ist der zu
	diesem Subnetz geh&ouml;rige Domainname).  Das Ziel
	<literal>link#1</literal> bezieht sich auf die erste
	Ethernet-Karte im Rechner.  Sie k&ouml;nnen auch feststellen,
	dass keine zus&auml;tzlichen Schnittstellen angegeben
	sind.</para>

      <para>Routen f&uuml;r Rechner im lokalen Netz und lokale
	Subnetze werden automatisch durch den
	<application>routed</application> Daemon konfiguriert.  Ist
	dieser nicht gestartet, sind nur statisch definierte
	(explizit eingegebene) Routen vorhanden.</para>

      <para>Die Zeile <literal>host1</literal> bezieht sich auf
	unseren Rechner, der durch seine Ethernetadresse bekannt ist.
	Da unser Rechner der Sender ist, verwendet FreeBSD automatisch
	das Loopback-Ger&auml;t (<devicename>lo0</devicename>),
	anstatt den Datenverkehr &uuml;ber die Ethernetschnittstelle
	zu senden.</para>

      <para>Die zwei <literal>host2</literal> Zeilen sind ein Beispiel
	daf&uuml;r, was passiert, wenn wir ein &man.ifconfig.8; Alias
	verwenden (Lesen Sie dazu den Abschnitt &uuml;ber Ethernet,
	wenn Sie wissen wollen, warum wir das tun sollten.).  Das
	Symbol <literal>=&gt;</literal> (nach der
	<devicename>lo0</devicename>-Schnittstelle) sagt aus, dass wir
	nicht nur das Loopbackger&auml;t verwenden (da sich die
	Adresse auf den lokalen Rechner bezieht), sondern dass es sich
	zus&auml;tzlich auch um ein Alias handelt.  Solche Routen sind
	nur auf Rechnern vorhanden, die den Alias bereitstellen;
	alle anderen Rechner im lokalen Netz haben f&uuml;r solche
	Routen nur eine einfache <literal>link#1</literal>
	Zeile.</para>

      <para>Die letzte Zeile (Zielsubnetz <literal>224</literal>)
	behandelt das Multicasting, das wir in einem anderen Abschnitt
	besprechen werden.</para>

      <para>Schlie&szlig;lich gibt es f&uuml;r Routen noch
	verschiedene Attribute, die Sie in der Spalte
	<literal>Flags</literal> finden.  Nachfolgend finden Sie eine
	kurze &Uuml;bersicht von einigen dieser Flags und ihrer
	Bedeutung:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>U</entry>

	      <entry>Up: Die Route ist aktiv.</entry>
	    </row>

	    <row>
	      <entry>H</entry>

	      <entry>Host: Das Ziel der Route ist ein einzelner
		Rechner (Host).</entry>
	    </row>

	    <row>
	      <entry>G</entry>

	      <entry>Gateway: Alle Daten, die an dieses Ziel gesendet
		werden, werden von diesem System an ihr jeweiliges
		Ziel weitergeleitet.</entry>
	    </row>

	    <row>
	      <entry>S</entry>

	      <entry>Static: Diese Route wurde manuell konfiguriert,
		das hei&szlig;t sie wurde <emphasis>nicht</emphasis>
		automatisch vom System erzeugt.</entry>
	    </row>

	    <row>
	      <entry>C</entry>

	      <entry>Clone: Erzeugt eine neue Route, basierend auf der
		Route f&uuml;r den Rechner, mit dem wir uns verbinden.
		Diese Routenart wird normalerweise f&uuml;r lokale
		Netzwerke verwendet.</entry>
	    </row>

	    <row>
	      <entry>W</entry>

	      <entry>WasCloned: Eine Route, die automatisch
		konfiguriert wurde.  Sie basiert auf einer lokalen
		Netzwerkroute (Clone).</entry>
	    </row>

	    <row>
	      <entry>L</entry>

	      <entry>Link: Die Route beinhaltet einen Verweis auf eine
		Ethernetkarte (MAC-Adresse).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 id="network-routing-default">
      <title>Standardrouten</title>

      <indexterm>
	<primary>Default-Route</primary>
      </indexterm>
      <indexterm>
	<primary>Standardroute</primary>
      </indexterm>

      <para>Wenn sich der lokale Rechner mit einem entfernten Rechner
	verbinden will, wird die Routingtabelle &uuml;berpr&uuml;ft,
	um festzustellen, ob bereits ein bekannter Pfad vorhanden ist.
	Geh&ouml;rt dieser entfernte Rechner zu einem Subnetz, dessen
	Pfad uns bereits bekannt ist
	(<foreignphrase>Cloned route</foreignphrase>), dann versucht der
	lokale Rechner &uuml;ber diese Schnittstelle eine Verbindung
	herzustellen.</para>

      <para>Wenn alle bekannten Pfade nicht funktionieren, hat der
	lokale Rechner eine letzte M&ouml;glichkeit: Die
	Standardroute (Default-Route).  Bei dieser
	Route handelt es sich um eine spezielle Gateway-Route
	(gew&ouml;hnlich die einzige im System vorhandene), die im
	Flags-Feld immer mit <literal>C</literal> gekennzeichnet ist.
	F&uuml;r Rechner im lokalen Netzwerk ist dieses Gateway auf
	<emphasis>welcher Rechner auch immer eine Verbindung nach
	au&szlig;en hat</emphasis> gesetzt (entweder &uuml;ber eine
	PPP-Verbindung, DSL, ein Kabelmodem, T1 oder eine beliebige
	andere Netzwerkverbindung).</para>

      <para>Wenn Sie die Standardroute f&uuml;r einen Rechner
	konfigurieren, der selbst als Gateway zur Au&szlig;enwelt
	funktioniert, wird die Standardroute zum Gateway-Rechner Ihres
	Internetanbieter (ISP) gesetzt.</para>

      <para>Sehen wir uns ein Beispiel f&uuml;r Standardrouten an.  So
	sieht eine &uuml;bliche Konfiguration aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/net-routing">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
	  </literallayout>
	</textobject>
      </mediaobject>

      <para>Die Rechner <hostid>Local1</hostid> und
	<hostid>Local2</hostid> befinden sich auf Ihrer Seite.
	<hostid>Local1</hostid> ist mit einem ISP &uuml;ber eine
	PPP-Verbindung verbunden.  Dieser PPP-Server ist &uuml;ber ein
	lokales Netzwerk mit einem anderen Gateway-Rechner verbunden,
	der &uuml;ber eine Schnittstelle die Verbindung des ISP zum
	Internet herstellt.</para>

      <para>Die Standardrouten f&uuml;r Ihre Maschinen lauten:</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Host</entry>

	      <entry>Standard Gateway</entry>

	      <entry>Schnittstelle</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>

	      <entry>Local1</entry>

	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>

	      <entry>T1-GW</entry>

	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Eine h&auml;ufig gestellte Frage lautet: <quote>Warum (oder
	wie) sollten wir <hostid>T1-GW</hostid> als Standard-Gateway
	f&uuml;r <hostid>Local1</hostid> setzen, statt den (direkt
	verbundenen) ISP-Server zu verwenden?</quote>.</para>

      <para>Bedenken Sie, dass die PPP-Schnittstelle f&uuml;r die
	Verbindung eine Adresse des lokalen Netzes des ISP verwendet.
	Daher werden Routen f&uuml;r alle anderen Rechner im lokalen
	Netz des ISP automatisch erzeugt.  Daraus folgt, dass Sie
	bereits wissen, wie Sie <hostid>T1-GW</hostid> erreichen
	k&ouml;nnen!  Es ist also unn&ouml;tig, einen Zwischenschritt
	&uuml;ber den ISP-Server zu machen.</para>

      <para>Es ist &uuml;blich, die Adresse <hostid
	role="ipaddr">X.X.X.1</hostid> als Gateway-Adresse f&uuml;r
	ihr lokales Netzwerk zu verwenden.  F&uuml;r unser Beispiel
	bedeutet dies Folgendes: Wenn Ihr lokaler Klasse-C-Adressraum
	<hostid role="ipaddr">10.20.30</hostid> ist und Ihr ISP
	<hostid role="ipaddr">10.9.9</hostid> verwendet, sehen die
	Standardrouten so aus:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Rechner (Host)</entry>

	      <entry>Standardroute</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>

	      <entry>Local1 (10.20.30.1)</entry>
	    </row>

	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>

	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Sie k&ouml;nnen die Standardroute ganz einfach in der Datei
	<filename>/etc/rc.conf</filename> festlegen.  In unserem
	Beispiel wurde auf dem Rechner <hostid>Local2</hostid>
	folgende Zeile in <filename>/etc/rc.conf</filename>
	eingef&uuml;gt:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>Die Standardroute kann &uuml;ber &man.route.8; auch direkt
	gesetzt werden:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>Weitere Informationen zum Bearbeiten von
	Netzwerkroutingtabellen finden Sie in &man.route.8;.</para>
    </sect2>

    <sect2>
      <title>Rechner mit zwei Heimatnetzen</title>

      <indexterm>
	<primary>Dual-Homed-Hosts</primary>
      </indexterm>

      <para>Es gibt noch eine Konfigurationsm&ouml;glichkeit, die wir
	besprechen sollten, und zwar Rechner, die sich in zwei
	Netzwerken befinden.  Technisch gesehen, z&auml;hlt jeder als
	Gateway arbeitende Rechner zu den Rechnern mit zwei
	Heimatnetzen (im obigen Beispiel unter Verwendung einer
	PPP-Verbindung).  In der Praxis meint man damit allerdings nur
	Rechner, die sich in zwei lokalen Netzen befinden.</para>

      <para>Entweder verf&uuml;gt der Rechner &uuml;ber zwei
	Ethernetkarten und jede dieser Karten hat eine Adresse in
	einem separaten Subnetz, oder der Rechner hat nur eine
	Ethernetkarte und verwendet &man.ifconfig.8; Aliasing.  Die
	erste M&ouml;glichkeit wird verwendet, wenn zwei physikalisch
	getrennte Ethernet-Netzwerke vorhanden sind, die zweite, wenn
	es nur ein physikalisches Ethernet-Netzwerk gibt, das aber aus
	zwei logisch getrennten Subnetzen besteht.</para>

      <para>In beiden F&auml;llen werden Routingtabellen erstellt,
	damit jedes Subnetz wei&szlig;, dass dieser Rechner als Gateway
	zum anderen Subnetz arbeitet (<foreignphrase>inbound
	route</foreignphrase>).  Diese Konfiguration (der
	Gateway-Rechner arbeitet als Router zwischen den Subnetzen) wird
	h&auml;ufig verwendet, wenn es darum geht, Paketfilterung oder
	eine Firewall (in eine oder beide Richtungen) zu implementieren.
      </para>

      <para>Soll dieser Rechner Pakete zwischen den beiden
	Schnittstellen weiterleiten, m&uuml;ssen Sie diese Funktion
	manuell konfigurieren und aktivieren.  Lesen Sie den
	n&auml;chsten Abschnitt, wenn Sie weitere Informationen zu
	diesem Thema ben&ouml;tigen.</para>
    </sect2>

    <sect2 id="network-dedicated-router">
      <title>Einen Router konfigurieren</title>

      <indexterm>
	<primary>Router</primary>
      </indexterm>

      <para>Ein Netzwerkrouter ist einfach ein System, das Pakete von
	einer Schnittstelle zur anderen weiterleitet.
	Internetstandards und gute Ingenieurspraxis sorgten
	daf&uuml;r, dass diese Funktion in FreeBSD in der Voreinstellung
	deaktiviert ist.  Sie k&ouml;nnen diese Funktion aktivieren,
	indem Sie in &man.rc.conf.5;  folgende &Auml;nderung
	durchf&uuml;hren:</para>

      <programlisting>gateway_enable=YES          # Auf YES setzen, wenn der Rechner als Gateway arbeiten soll</programlisting>

      <para>Diese Option setzt die &man.sysctl.8;-Variable
	<varname>net.inet.ip.forwarding</varname> auf
	<literal>1</literal>.  Wenn Sie das Routing kurzzeitig
	unterbrechen wollen, k&ouml;nnen Sie die Variable auf
	<literal>0</literal> setzen.</para>

      <indexterm><primary>BGP</primary></indexterm>
      <indexterm><primary>RIP</primary></indexterm>
      <indexterm><primary>OSPF</primary></indexterm>

      <para>Ihr neuer Router ben&ouml;tigt nun noch Routen, um zu
	wissen, wohin er den Verkehr senden soll.  Haben Sie ein
	(sehr) einfaches Netzwerk, k&ouml;nnen Sie statische Routen
	verwenden.  FreeBSD verf&uuml;gt &uuml;ber den Standard
	BSD-Routing-Daemon &man.routed.8;, der RIP (sowohl Version 1
	als auch Version 2) und IRDP versteht.  BGP&nbsp;v4,
	OSPF&nbsp;v2 und andere Protokolle werden von
	<filename role="package">net/zebra</filename>
	unterst&uuml;tzt.  Es stehen auch kommerzielle Produkte
	wie <application>gated</application> zur Verf&uuml;gung.</para>

      <para>Selbst wenn FreeBSD auf diese Art konfiguriert wurde,
	entspricht es den Standardanforderungen an Internet-Router
	nicht vollst&auml;ndig.  F&uuml;r den
	<emphasis>normalen</emphasis> Gebrauch kommt es den Standards
	aber nahe genug.</para>
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Al</firstname>
	    <surname>Hoang</surname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Statische Routen einrichten</title>

      <sect3>
	<title>Manuelle Konfiguration</title>

	<para>Nehmen wir an, dass wir &uuml;ber folgendes Netzwerk
	  verf&uuml;gen:</para>

	<literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) Default Router to Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (FreeBSD gateway)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Internal Net 1      | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Internal Net 2
        </literallayout>

	<para><hostid>RouterA</hostid>, ein &os;-Rechner, dient als
	  Router f&uuml;r den Zugriff auf das Internet.  Die
	  Standardroute ist auf <hostid role="ipaddr">10.0.0.1</hostid>
	  gesetzt, damit ein Zugriff auf das Internet m&ouml;glich wird.
	  Wir nehmen nun an, dass <hostid>RouterB</hostid> bereits
	  konfiguriert ist und daher wei&szlig;, wie er andere Rechner
	  erreichen kann.  Dazu wird die Standardroute von
	  <hostid>RouterB</hostid> auf
	  <hostid role="ipaddr">192.168.1.1</hostid> gesetzt, da dieser
	  Rechner als Gateway fungiert.</para>

	<para>Sieht man sich die Routingtabelle f&uuml;r
	  <hostid>RouterA</hostid> an, erh&auml;lt man folgende Ausgabe:
	</para>

	<screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</screen>

	<para>Mit dieser Routingtabelle kann <hostid>RouterA</hostid>
	  unser internes Netz 2 nicht erreichen, da keine Route zum
	  Rechner <hostid role="ipaddr">192.168.2.0/24</hostid>
	  vorhanden ist.  Um dies zu korrigieren, kann die Route manuell
	  gesetzt werden.  Durch den folgenden Befehl wird das
	  interne Netz 2 in die Routingtabelle des Rechners
	  <hostid>RouterA</hostid> aufgenommen, indem
	  <hostid role="ipaddr">192.168.1.2</hostid> als n&auml;chster
	  Zwischenschritt verwenden wird:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Ab sofort kann <hostid>RouterA</hostid> alle Rechner des
	  Netzwerks <hostid role="ipaddr">192.168.2.0/24</hostid>
	  erreichen.</para>
      </sect3>

      <sect3>
	<title>Routen dauerhaft einrichten</title>

	<para>Das obige Beispiel ist f&uuml;r die Konfiguration einer
	  statischen Route auf einem laufenden System geeignet.  Diese
	  Information geht jedoch verloren, wenn der &os;-Rechner neu
	  gestartet werden muss.  Um dies zu verhindern, wird diese
	  Route in <filename>/etc/rc.conf</filename> eingetragen:</para>

	<programlisting># Add Internal Net 2 as a static route
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</programlisting>

	<para>Die Variable <literal>static_routes</literal> enth&auml;lt
	  eine Reihe von Strings, die durch Leerzeichen getrennt sind.
	  Jeder String bezieht sich auf den Namen einer Route.  In
	  unserem Beispiel hat <literal>static_routes</literal>
	  <replaceable>internalnet2</replaceable> als einzigen String.
	  Zus&auml;tzlich verwendet man die Konfigurationsvariable
	  <literal>route_<replaceable>internalnet2</replaceable></literal>,
	  in der alle sonstigen an &man.route.8; zu &uuml;bergebenden
	  Parameter festgelegt werden.  In obigen Beispiel h&auml;tte
	  man folgenden Befehl verwendet:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Daher wird
	  <literal>"-net 192.168.2.0/24 192.168.1.2"</literal> als
	  Parameter der Variable <literal>route_</literal> angegeben.
	</para>

	<para>Wie bereits erw&auml;hnt, k&ouml;nnen bei
	  <literal>static_routes</literal> auch mehrere Strings
	  angegeben werden.  Dadurch lassen sich mehrere statische
	  Routen anlegen.  Durch folgende Zeilen werden auf einem
	  imagin&auml;ren Rechner statische Routen zu den Netzwerken
	  <hostid role="ipaddr">192.168.0.0/24</hostid> sowie <hostid
	  role="ipaddr">192.168.1.0/24</hostid> definiert:</para>

	<programlisting>static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Verteilung von Routing-Informationen</title>

      <indexterm>
	<primary>routing propagation</primary>
      </indexterm>

      <para>Wir haben bereits dar&uuml;ber gesprochen, wie wir unsere
	Routen zur Au&szlig;enwelt definieren, aber nicht dar&uuml;ber,
	wie die Au&szlig;enwelt uns finden kann.</para>

      <para>Wir wissen bereits, dass Routing-Tabellen so erstellt
	werden k&ouml;nnen, dass s&auml;mtlicher Verkehr f&uuml;r
	einen bestimmten Adressraum (in unserem Beispiel ein
	Klasse-C-Subnetz) zu einem bestimmten Rechner in diesem
	Netzwerk gesendet wird, der die eingehenden Pakete im Subnetz
	verteilt.</para>

      <para>Wenn Sie einen Adressraum f&uuml;r Ihre Seite zugewiesen
	bekommen, richtet Ihr Diensteanbieter seine Routingtabellen so
	ein, dass der ganze Verkehr f&uuml;r Ihr Subnetz entlang Ihrer
	PPP-Verbindung zu Ihrer Seite gesendet wird.  Aber woher
	wissen die Seiten in der Au&szlig;enwelt, dass sie die Daten an
	Ihren ISP senden sollen?</para>

      <para>Es gibt ein System (&auml;hnlich dem verbreiteten DNS),
	das alle zugewiesenen Adressr&auml;ume verwaltet und ihre
	Verbindung zum Internet-Backbone definiert und dokumentiert.
	Der <quote>Backbone</quote> ist das Netz aus
	Hauptverbindungen, die den Internetverkehr in der ganzen Welt
	transportieren und verteilen.  Jeder Backbone-Rechner
	verf&uuml;gt &uuml;ber eine Kopie von Haupttabellen, die den
	Verkehr f&uuml;r ein bestimmtes Netzwerk hierarchisch vom
	Backbone &uuml;ber eine Kette von Diensteanbietern bis hin zu
	Ihrer Seite leiten.</para>

      <para>Es ist die Aufgabe Ihres Diensteanbieters, den
	Backbone-Seiten mitzuteilen, dass sie mit Ihrer Seite
	verbunden wurden.  Durch diese Mitteilung der Route ist nun
	auch der Weg zu Ihnen bekannt.  Dieser Vorgang wird als
	<emphasis>Bekanntmachung von Routen</emphasis>
	(<foreignphrase>routing propagation</foreignphrase>)
	bezeichnet.</para>
    </sect2>

    <sect2>
      <title>Problembehebung</title>

      <indexterm>
	<primary><command>traceroute</command></primary>
      </indexterm>

      <para>Manchmal kommt es zu Problemen bei der Bekanntmachung von
	Routen, und einige Seiten sind nicht in der Lage, Sie zu
	erreichen.  Vielleicht der n&uuml;tzlichste Befehl, um
	festzustellen, wo das Routing nicht funktioniert, ist
	&man.traceroute.8;.  Er ist au&szlig;erdem sehr n&uuml;tzlich,
	wenn Sie einen entfernten Rechner nicht erreichen k&ouml;nnen
	(lesen Sie dazu auch &man.ping.8;).</para>

      <para>&man.traceroute.8; wird mit dem zu erreichenden Rechner
	(Host) ausgef&uuml;hrt.  Angezeigt werden die Gateway-Rechner
	entlang des Verbindungspfades.  Schlie&szlig;lich wird der
	Zielrechner erreicht oder es kommt zu einem Verbindungsabbruch
	(beispielsweise durch Nichterreichbarkeit eines
	Gateway-Rechners).</para>

      <para>Weitere Informationen finden Sie in
	&man.traceroute.8;.</para>
    </sect2>

    <sect2>
      <title>Multicast-Routing</title>
      <indexterm>
	<primary>Multicast-Routing</primary>
	<secondary>options MROUTING</secondary>
      </indexterm>

      <para>&os; unterst&uuml;tzt sowohl Multicast-Anwendungen als
	auch Multicast-Routing.  Multicast-Anwendungen m&uuml;ssen
	nicht konfiguriert werden, sie laufen einfach.
	Multicast-Routing muss in der Kernelkonfiguration aktiviert
	werden:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Zus&auml;tzlich muss &man.mrouted.8;, der
	Multicast-Routing-Daemon, &uuml;ber die Datei
	<filename>/etc/mrouted.conf</filename> eingerichtet werden,
	um Tunnel und DVMRP zu aktivieren.  Weitere Informationen
	zu diesem Thema finden Sie in &man.mrouted.8;.</para>
    </sect2>
  </sect1>

  <sect1 id="network-wireless">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Anderson</surname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Drahtlose Netzwerke</title>
    <indexterm>
      <primary>drahtlose Netzwerke</primary>
    </indexterm>
    <indexterm>
      <primary>802.11</primary>
      <see>drahtlose Netzwerke</see>
    </indexterm>

    <sect2>
      <title>Einf&uuml;hrung</title>

      <para>Es kann sehr n&uuml;tzlich sein, einen Computer zu
	verwenden, ohne sich die ganze Zeit mit einem Netzwerkkabel
	herum&auml;rgern zu m&uuml;ssen.  FreeBSD kann auf drahtlose
	Netzwerke (<foreignphrase>wireless LAN</foreignphrase>)
	zugreifen und sogar als <quote>Zugangspunkt</quote>
	(<foreignphrase>access point</foreignphrase>) f&uuml;r
	drahtlose Netzwerke verwendet werden.</para>
    </sect2>

    <sect2>
      <title>Betriebsmodi drahtloser Ger&auml;te</title>

      <para>Drahtlose 802.11-Ger&auml;te k&ouml;nnen in zwei Modi
	konfiguriert werden: BSS und IBSS.</para>

     <sect3>
       <title>BSS-Modus</title>

       <para>&Uuml;blicherweise wird der BSS-Modus, der auch
         Infrastruktur-Modus genannt wird, verwendet.  In diesem Modus
	 sind die Zugangspunkte (<foreignphrase>access
	 points</foreignphrase>) mit einem Kabel-Netzwerk verbunden.
	 Jedes drahtlose Netzwerk besitzt einen Namen, der als die SSID
	 des Netzwerks bezeichnet wird.</para>

       <para>Drahtlose Clients benutzen ein im IEEE-802.11-Standard
         beschriebenes Protokoll, um sich mit den Zugangspunkten zu
	 verbinden.  Durch die Angabe einer SSID kann sich der Client
	 das Netzwerk, mit dem er sich verbinden will, aussuchen.  Gibt
	 der Client keine SSID an, so wird er mit einem beliebigen
	 Netzwerk verbunden.</para>
     </sect3>

     <sect3>
       <title>IBSS-Modus</title>

       <para>Der IBSS-Modus, der auch ad-hoc-Modus genannt wird, wurde
	 f&uuml;r Punkt-zu-Punkt-Verbindungen entworfen.  Es gibt zwei
	 Modi: Den IBSS-Modus, auch ad-hoc- oder IEEE-ad-hoc-Modus
	 (definiert im IEEE-802.11-Standard) sowie den demo-ad-hoc-Modus
	 oder Lucent-adhoc-Modus (der manchmal ebenfalls als
	 ad-hoc-Modus bezeichnet wird).  Der zweite Modus stammt aus der
	 Zeit vor IEEE&nbsp;802.11 und sollte nur noch mit alten
	 Installationen verwendet werden.  Im folgenden wird keiner der
	 ad-hoc-Modi behandelt.</para>
     </sect3>
   </sect2>

   <sect2>
     <title>Infrastruktur-Modus</title>

      <sect3>
	<title>Zugangspunkte</title>

	<para>Zugangspunkte sind drahtlose Netzwerkger&auml;te, die es
	  einem oder mehreren Clients erm&ouml;glichen, diesen als
	  einen zentralen Verteiler (Hub) zu benutzen.  Wenn ein
	  Zugangspunkt verwendet wird, kommunizieren alle Clients
	  &uuml;ber diesen Zugangspunkt.  Oft werden mehrere
	  Zugangspunkte kombiniert, um ein ganzes Gebiet, wie ein
	  Haus, ein Unternehmen oder einen Park mit einem drahtlosen
	  Netzwerk zu versorgen.</para>

	<para>&Uuml;blicherweise haben Zugangspunkte mehrere
	  Netzwerkverbindungen: Die drahtlose Karte, sowie eine oder
	  mehrere Ethernetkarten, &uuml;ber die die Verbindung mit dem
	  restlichen Netzwerk hergestellt wird.</para>

	<para>Sie k&ouml;nnen einen vorkonfigurierten Zugangspunkt
	  kaufen, oder Sie k&ouml;nnen sich unter Verwendung von
	  FreeBSD und einer unterst&uuml;tzten drahtlosen Karte einen
	  eigenen bauen.  Es gibt verschiedene Hersteller, die sowohl
	  Zugangspunkte als auch drahtlose Karten mit verschiedensten
	  Eigenschaften vertreiben.</para>
      </sect3>

      <sect3>
	<title>Einen FreeBSD-Zugangspunkt installieren</title>

	<indexterm>
	  <primary>drahtlose Netzwerke</primary>
	  <secondary>Zugangspunkte</secondary>
	</indexterm>

	<sect4>
	  <title>Voraussetzungen</title>

	  <para>Um einen drahtlosen Zugangspunkt unter FreeBSD
	    einzurichten, m&uuml;ssen Sie &uuml;ber eine drahtlose
	    Karte verf&uuml;gen.  Zurzeit werden daf&uuml;r von
	    FreeBSD nur Karten mit Prism-Chipsatz unterst&uuml;tzt.
	    Zus&auml;tzlich ben&ouml;tigen Sie eine von FreeBSD
	    unterst&uuml;tzte Ethernetkarte (diese sollte nicht schwer
	    zu finden sein, da FreeBSD eine Vielzahl von verschiedenen
	    Karten unterst&uuml;tzt).  F&uuml;r die weiteren
	    Erl&auml;uterungen nehmen wir an, dass Sie den ganzen
	    Verkehr zwischen dem drahtlosen Ger&auml;t und dem an die
	    Ethernetkarte angeschlossenen Kabel-Netzwerk &uuml;ber
	    die &man.bridge.4;-Funktion realisieren wollen.</para>

	 <para>Die hostap-Funktion, mit der FreeBSD Zugangspunkte
	   implementiert, l&auml;uft am besten mit bestimmten
	   Firmware-Versionen.  Prism&nbsp;2-Karten sollten die
	   Firmwareversion&nbsp;1.3.4 oder neuer verwenden.
	   Prism&nbsp;2.5- und Prism&nbsp;3-Karten sollten die
	   Firmwareversion&nbsp;1.4.9 verwenden.  Es kann sein,
	   dass auch &auml;ltere Versionen funktionieren.  Zurzeit ist
	   es nur mit &windows;-Werkzeugen der Hersteller m&ouml;glich,
	   die Firmware zu aktualisieren.</para>
	</sect4>

	<sect4>
	  <title>Einrichtung</title>

	  <para>Stellen Sie als Erstes sicher, dass Ihr System die
	    drahtlose Karte erkennt:</para>

	  <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
        status: no carrier
        ssid ""
        stationname "FreeBSD Wireless node"
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</screen>

	  <para>K&uuml;mmern Sie sich jetzt noch nicht um die Details,
	    sondern stellen Sie nur sicher, dass ihre drahtlose Karte
	    &uuml;berhaupt erkannt und angezeigt wird.  Wenn es sich
	    um eine PC&nbsp;Card handelt, die &uuml;berhaupt nicht
	    erkannt wird, sollten Sie &man.pccardc.8; sowie
	    &man.pccardd.8; lesen.</para>

	  <para>Danach m&uuml;ssen Sie ein Modul laden, um die
	    Bridge-Funktion von FreeBSD f&uuml;r den Zugangspunkt
	    vorzubereiten.  Um das Modul &man.bridge.4; zu laden,
	    geben Sie Folgendes ein:</para>

	  <screen>&prompt.root; <userinput>kldload bridge</userinput></screen>

	  <para>Dabei sollten beim Laden des Moduls keine
	    Fehlermeldungen auftreten.  Geschieht dies doch, kann es
	    sein, dass Sie die Bridge-Funktion (&man.bridge.4;)
	    in Ihren Kernel kompilieren m&uuml;ssen.  Der Abschnitt
	    <link linkend="network-bridging">LAN-Kopplung mit einer
	    Bridge</link> dieses Handbuchs sollte Ihnen dabei
	    behilflich sein.</para>

	  <para>Wenn die Bridge-Funktion aktiviert ist,
	    m&uuml;ssen wir FreeBSD mitteilen, welche Schnittstellen
	    &uuml;ber die Bridge verbunden werden sollen.  Dazu
	    verwenden wir &man.sysctl.8;:</para>

	  <screen>&prompt.root; <userinput>sysctl net.link.ether.bridge=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge_cfg="wi0 xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	  <para>Ab &os;&nbsp;5.2-RELEASE m&uuml;ssen Sie
	    Folgendes eingeben:</para>

	  <screen>&prompt.root; <userinput>sysctl net.link.ether.bridge.enable=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge.config="wi0,xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	  <para>Nun ist es an der Zeit, die drahtlose Karte zu
	    installieren.  Der folgende Befehl konfiguriert einen
	    Zugangspunkt:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 ssid <replaceable>my_net</replaceable> channel 11 media DS/11Mbps mediaopt hostap up stationname "<replaceable>FreeBSD AP"</replaceable></userinput></screen>

	  <para>Durch diese Zeile aktiviert &man.ifconfig.8; das
	    Ger&auml;t <devicename>wi0</devicename>, setzt die SSID auf
	    <replaceable>my_net</replaceable> sowie den Namen des
	    Zugangspunkts auf <replaceable>FreeBSD AP</replaceable>.
	    Mit <option>media DS/11Mbps</option> wird die Karte in den
	    11&nbsp;Mbps-Modus versetzt.  Diese Option ist n&ouml;tig,
	    damit <option>mediaopt</option>-Optionen wirksam werden.
	    Durch <option>mediaopt hostap</option> wird die
	    Schnittstelle als Zugangspunkt konfiguriert.  Der zu
	    benutzende 802.11b-Kanal wird durch
	    <option>channel 11</option> festgelegt.  Weitere
	    Informationen zu g&uuml;ltigen Kanaloptionen finden Sie in
	    &man.wicontrol.8;.</para>

	  <para>Nun sollten Sie &uuml;ber einen voll
	    funktionsf&auml;higen und laufenden Zugangspunkt
	    verf&uuml;gen.  Weitere Informationen finden Sie
	    in den Hilfeseiten &man.wicontrol.8;, &man.ifconfig.8;
	    und &man.wi.4;.</para>

	  <para>Au&szlig;erdem ist es empfehlenswert, den folgenden
	    Abschnitt zu lesen, um sich &uuml;ber die Sicherung und
	    Verschl&uuml;sselung von Zugangspunkten zu
	    informieren.</para>
	</sect4>

       <sect4>
	  <title>Statusinformationen</title>

	  <para>Wenn der Zugangspunkt eingerichtet ist und l&auml;uft,
	    k&ouml;nnen Sie die verbundenen Clients mit dem nachstehenden
	    Kommando abfragen:</para>

          <screen>&prompt.root; <userinput>wicontrol -l</userinput>
1 station:
00:09:b7:7b:9d:16  asid=04c0, flags=3&lt;ASSOC,AUTH&gt;, caps=1&lt;ESS&gt;, rates=f&lt;1M,2M,5.5M,11M&gt;, sig=38/15</screen>

	  <para>Das Beispiel zeigt eine verbundene Station und die
	    dazugeh&ouml;renden Verbindungsparameter.  Die angegebene
	    Signalst&auml;rke ist allerdings mit Vorsicht zu
	    genie&szlig;en, da die Umrechnung in dBm oder andere
	    Einheiten von der eingesetzten Firmware-Version
	    abh&auml;ngig ist.</para>
        </sect4>
      </sect3>

      <sect3>
	<title>Clients</title>

	<para>Ein drahtloser Client ist ein System, das direkt auf
	  einen Zugangspunkt oder einen anderen Client
	  zugreift.</para>

	<para>&Uuml;blicherweise haben drahtlose Clients nur ein
	  Netzwerkger&auml;t, die drahtlose Netzkarte.</para>

	<para>Es gibt verschiedene M&ouml;glichkeiten, einen
	  drahtlosen Client zu konfigurieren.  Diese h&auml;ngen von
	  den verschiedenen drahtlosen Betriebsmodi ab.  Man
	  unterscheidet vor allem zwischen BSS (Infrastrukturmodus,
	  erfordert einen Zugangspunkt) und IBSS (ad-hoc,
	  Peer-to-Peer-Modus, zwischen zwei Clients, ohne
	  Zugangspunkt).  In unserem Beispiel verwenden wir den weiter
	  verbreiteten BSS-Modus, um einen Zugangspunkt anzusprechen.
	</para>

	<sect4>
	  <title>Voraussetzungen</title>

	  <para>Es gibt nur eine Voraussetzung, um FreeBSD als
	    drahtlosen Client betreiben zu k&ouml;nnen: Sie brauchen
	    eine von FreeBSD unterst&uuml;tzte drahtlose Karte.</para>
	</sect4>

	<sect4>
	  <title>Einen drahtlosen FreeBSD-Client einrichten</title>

	  <para>Sie m&uuml;ssen ein paar Dinge &uuml;ber das drahtlose
	    Netzwerk wissen, mit dem Sie sich verbinden wollen, bevor
	    Sie starten k&ouml;nnen.  In unserem Beispiel verbinden
	    wir uns mit einem Netzwerk, das den Namen
	    <replaceable>my_net</replaceable> hat, und bei dem die
	    Verschl&uuml;sselung deaktiviert ist.</para>

	  <note><para>In unserem Beispiel verwenden wir keine
	    Verschl&uuml;sselung.  Dies ist eine gef&auml;hrliche
	    Situation.  Im n&auml;chsten Abschnitt werden Sie daher
	    lernen, wie man die Verschl&uuml;sselung aktiviert, warum
	    es wichtig ist, dies zu tun, und warum einige
	    Verschl&uuml;sselungstechniken Sie trotzdem nicht
	    vollst&auml;ndig sch&uuml;tzen.</para></note>

	  <para>Stellen Sie sicher, dass Ihre Karte von FreeBSD
	    erkannt wird:</para>

	  <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
        status: no carrier
        ssid ""
        stationname "FreeBSD Wireless node"
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</screen>

	  <para>Nun k&ouml;nnen wir die Einstellungen der Karte unserem
	    Netzwerk anpassen:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 inet <replaceable>192.168.0.20</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>my_net</replaceable></userinput></screen>

	  <para>Ersetzen Sie <hostid
	    role="ipaddr">192.168.0.20</hostid> und <hostid
	    role="netmask">255.255.255.0</hostid> durch eine
	    g&uuml;ltige IP-Adresse und Netzmaske ihres
	    Kabel-Netzwerks.  Bedenken Sie au&szlig;erdem, dass unser
	    Zugangspunkt als Bridge zwischen dem drahtlosen und
	    dem Kabel-Netzwerk fungiert.  F&uuml;r die anderen
	    Rechner Ihres Netzwerks befinden Sie sich, genauso wie
	    diese, im gleichen Kabel-Netzwerk, obwohl Sie zum
	    drahtlosen Netzwerk geh&ouml;ren.</para>

	  <para>Nachdem Sie dies erledigt haben, sollten Sie andere
	    Rechner (Hosts) im Kabel-Netzwerk an&man.ping.8;en
	    k&ouml;nnen, genauso, wie wenn Sie &uuml;ber eine
	    Standardkabelverbindung mit ihnen verbunden
	    w&auml;ren.</para>

	  <para>Wenn Probleme mit Ihrer drahtlosen Verbindung
	    auftreten, stellen Sie sicher, dass Sie mit dem
	    Zugangspunkt verbunden sind:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0</userinput></screen>

	  <para>sollte einige Informationen ausgeben und Sie sollten
	    Folgendes sehen:</para>

	  <screen>status: associated</screen>

	  <para>Wird <literal>associated</literal> nicht angezeigt, sind
	    Sie entweder au&szlig;erhalb der Reichweite des
	    Zugangspunktes, haben die Verschl&uuml;sselung deaktiviert,
	    oder Sie haben ein anderes Konfigurationsproblem.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Verschl&uuml;sselung</title>

	<indexterm>
	  <primary>drahtlose Netzwerke</primary>
	  <secondary>Verschl&uuml;sselung</secondary>
	</indexterm>

	<para>Verschl&uuml;sselung ist in einem drahtlosen Netzwerk
	  wichtig, da Sie das Netzwerk nicht l&auml;nger in einem
	  gesch&uuml;tzten Bereich betreiben k&ouml;nnen.  Ihre Daten
	  verbreiten sich in der ganzen Nachbarschaft, das hei&szlig;t
	  jeder, der es will, kann Ihre Daten lesen.  Deshalb gibt es
	  die Verschl&uuml;sselung.  Durch die Verschl&uuml;sselung der
	  durch die Luft versendeten Daten machen Sie es einem Dritten
	  sehr viel schwerer, Ihre Daten abzufangen oder auf diese
	  zuzugreifen.</para>

	<para>Die gebr&auml;uchlichsten Methoden, um Daten zwischen
	  Ihrem Client und dem Zugangspunkt zu verschl&uuml;sseln,
	  sind WEP und &man.ipsec.4;.</para>

	<sect4>
	  <title>WEP</title>

	  <indexterm>
	    <primary>WEP</primary>
	  </indexterm>

	  <para>WEP ist die Abk&uuml;rzung f&uuml;r
	    <foreignphrase>Wired Equivalency
	    Protocol</foreignphrase> ("Verkabelung entsprechendes
	    Protokoll").  WEP war ein Versuch, drahtlose Netzwerke
	    ebenso sicher und gesch&uuml;tzt zu machen wie verkabelte
	    Netzwerke.  Ungl&uuml;cklicherweise wurde es bereits
	    geknackt, und ist relativ einfach auszuhebeln.  Sie sollten
	    sich also nicht darauf verlassen, wenn Sie sensible Daten
	    verschl&uuml;sseln wollen.</para>

	  <para>Allerdings ist eine schlechte Verschl&uuml;sselung
	    noch immer besser als gar keine Verschl&uuml;sselung.
	    Aktivieren Sie daher WEP f&uuml;r Ihren neuen
	    FreeBSD-Zugangspunkt:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 inet up ssid <replaceable>my_net</replaceable> wepmode on wepkey <replaceable>0x1234567890</replaceable> media DS/11Mbps mediaopt hostap</userinput></screen>

	  <para>Auf dem Client k&ouml;nnen Sie WEP wie folgt
	    aktivieren:</para>

	  <screen>&prompt.root; <userinput>ifconfig wi0 inet <replaceable>192.168.0.20</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>my_net</replaceable> wepmode on wepkey <replaceable>0x1234567890</replaceable></userinput></screen>

	  <para>Beachten Sie bitte, dass Sie
	    <replaceable>0x1234567890</replaceable> durch einen besseren
	    Schl&uuml;ssel ersetzen sollten.</para>
	</sect4>

	<sect4>
	  <title>IPsec</title>

	  <para>&man.ipsec.4; ist ein viel besseres und robusteres
	    Werkzeug, um Daten in einem Netzwerk zu
	    verschl&uuml;sseln und ist auch der bevorzugte Weg,
	    Daten in einem drahtlosen Netzwerk zu verschl&uuml;sseln.
	    Weitere Informationen zu &man.ipsec.4; sowie zu dessen
	    Implementierung enth&auml;lt der Abschnitt
	    <link linkend="ipsec">IPsec</link> des Handbuches.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Werkzeuge</title>

	<para>Es gibt einige Werkzeuge, die dazu dienen, Ihr
	  drahtloses Netzwerk zu installieren, und auftretende
	  Probleme zu beheben.  Im folgenden Abschnitt werden die
	  wichtigsten von ihnen beschrieben.</para>

	<sect4>
	  <title><application>bsd-airtools</application></title>

	  <para>Das Paket <application>bsd-airtools</application>
	    enth&auml;lt einen kompletten Werkzeugsatz zum
	    Herausfinden von WEP-Schl&uuml;sseln, zum Auffinden von
	    Zugangspunkten, usw.</para>

	  <para>Die <application>bsd-airtools</application>
	    k&ouml;nnen Sie &uuml;ber den Port
	    <filename role="package">net/bsd-airtools</filename>
	    installieren.  Wie ein Port installiert wird,
	    beschreibt <xref linkend="ports"> des Handbuchs.</para>

	  <para>Das Programm <command>dstumbler</command> ist ein
	    Werkzeug, das Sie beim Auffinden von Zugangspunkten
	    unterst&uuml;tzt, und das Signal-Rausch-Verh&auml;ltnis
	    graphisch darstellen kann.  Wenn Sie Probleme beim
	    Einrichten und Betreiben Ihres Zugangspunktes haben,
	    k&ouml;nnte <command>dstumbler</command> genau das
	    Richtige f&uuml;r Sie sein.</para>

	  <para>Um die Sicherheit Ihres drahtlosen Netzwerks zu
	    &uuml;berpr&uuml;fen, k&ouml;nnten Sie das Paket
	    <quote>dweputils</quote> (<command>dwepcrack</command>,
	    <command>dwepdump</command> und
	    <command>dwepkeygen</command>) verwenden.  Durch diese Tools
	    k&ouml;nnen Sie feststellen, ob WEP Ihren
	    Sicherheitsanforderungen gen&uuml;gt.</para>
	</sect4>

	<sect4>
	  <title><command>wicontrol</command>,
	    <command>ancontrol</command> und
	    <command>raycontrol</command></title>

	  <para>Dies sind Werkzeuge, um das Verhalten Ihrer drahtlosen
	    Karte im drahtlosen Netzwerk zu kontrollieren.  In den
	    obigen Beispielen haben wir &man.wicontrol.8; verwendet,
	    da es sich bei unser drahtlosen Karte um ein Ger&auml;t
	    der <devicename>wi0</devicename>-Schnittstelle handelt.
	    H&auml;tten Sie eine drahtlose Karte von Cisco,
	    w&uuml;rden Sie diese &uuml;ber
	    <devicename>an0</devicename> ansprechen, und daher
	    &man.ancontrol.8; verwenden.</para>
	</sect4>

	<sect4>
	  <title>Das Kommando <command>ifconfig</command></title>

	  <indexterm>
	    <primary>ifconfig</primary>
	  </indexterm>

	  <para>&man.ifconfig.8; kennt zwar viele Optionen von
	    &man.wicontrol.8;, einige fehlen jedoch.  Unter
	    &man.ifconfig.8; finden Sie Informationen zu
	    Parametern und Optionen.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Unterst&uuml;tzte Karten</title>

	<sect4>
	  <title>Zugangspunkt</title>

	  <para>Die einzigen Karten, die im BSS-Modus (das hei&szlig;t
	    als Zugangspunkt) derzeit unterst&uuml;tzt werden, sind
	    solche mit Prism&nbsp;2-, 2.5- oder 3-Chipsatz.  F&uuml;r
	    eine komplette &Uuml;bersicht lesen Sie bitte &man.wi.4;.
	  </para>
	</sect4>

	<sect4>
	  <title>Clients</title>

	  <para>Beinahe alle nach 802.11b arbeitenden drahtlosen
	    Karten werden von FreeBSD unterst&uuml;tzt.  Die meisten
	    dieser Karten von Prism, Spectrum24, Hermes, Aironet und
	    Raylink arbeiten als drahtlose Netzkarten im IBSS-Modus
	    (ad-hoc, Peer-to-Peer und BSS).</para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-bluetooth">
    <title>Bluetooth</title>

    <indexterm><primary>Bluetooth</primary></indexterm>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/network-bluetooth.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>

  <sect1 id="network-bridging">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Steve</firstname>
	  <surname>Peterson</surname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>LAN-Kopplung mit einer Bridge</title>

    <sect2>
      <title>Einf&uuml;hrung</title>

      <indexterm><primary>Subnetz</primary></indexterm>
      <indexterm><primary>Bridge</primary></indexterm>

      <para>Manchmal ist es n&uuml;tzlich, ein physikalisches Netzwerk
	(wie ein Ethernetsegment) in zwei separate Netzwerke
	aufzuteilen, ohne gleich IP-Subnetze zu erzeugen, die &uuml;ber
	einen Router miteinander verbunden sind.  Ein Ger&auml;t, das
	zwei Netze auf diese Weise verbindet, wird als
	<emphasis>Bridge</emphasis> bezeichnet.  Jedes FreeBSD-System
	mit zwei Netzkarten kann als Bridge fungieren.</para>

      <para>Die Bridge arbeitet, indem sie die MAC Layeradressen
	(Ethernet Adressen) der Ger&auml;te in ihren Netzsegmenten
	lernt.  Der Verkehr wird nur dann zwischen zwei Netzsegmenten
	weitergeleitet, wenn sich Sender und Empf&auml;nger in
	verschiedenen Netzsegmenten befinden.</para>

      <para>In vielerlei Hinsicht entspricht eine Bridge daher einem
        Ethernet-Switch mit sehr wenigen Ports.</para>
    </sect2>

    <sect2>
      <title>Situationen, in denen <emphasis>Bridging</emphasis>
	angebracht ist</title>

      <para>Eine Bridge wird vor allem in folgenden zwei Situationen
	verwendet:</para>

      <sect3>
	<title>Hohes Datenaufkommen in einem Segment</title>

	<para>In der ersten Situation wird Ihr physisches Netz
	  mit Datenverkehr &uuml;berschwemmt.  Aus irgendwelchen
	  Gr&uuml;nden wollen Sie allerdings keine Subnetze verwenden,
	  die &uuml;ber einen Router miteinander verbunden sind.</para>

	<para>Stellen Sie sich einen Zeitungsverlag vor, in dem sich die
	  Redaktions- und Produktionsabteilungen in verschiedenen
	  Subnetzen befinden.  Die Redaktionsrechner verwenden den
	  Server <hostid>A</hostid> f&uuml;r Dateioperationen, und die
	  Produktionsrechner verwenden den Server <hostid>B</hostid>.
	  Alle Benutzer sind &uuml;ber ein gemeinsames Ethernet-LAN
	  miteinander verbunden.  Durch das hohe Datenaufkommen sinkt
	  die Geschwindigkeit des gesamten Netzwerks.</para>

	<para>W&uuml;rde man die Redaktionsrechner und die
	  Produktionsrechner in separate Netzsegmente auslagern,
	  k&ouml;nnte man diese beiden Segmente &uuml;ber eine Bridge
	  verbinden.  Nur der f&uuml;r Rechner im jeweils
	  <emphasis>anderen</emphasis> Segment bestimmte Verkehr wird
	  dann &uuml;ber die Brigde in das andere Netzsegment geleitet.
	  Dadurch verringert sich das Gesamtdatenaufkommen in beiden
	  Segmenten.</para>
      </sect3>

      <sect3>
	<title>Filtering/Traffic Shaping Firewall</title>

	<indexterm><primary>Firewall</primary></indexterm>
	<indexterm><primary>Network Adress Translation</primary></indexterm>

	<para>Die zweite h&auml;ufig anzutreffende Situation tritt auf,
	  wenn Firewallfunktionen ben&ouml;tigt werden, ohne dass
	  <foreignphrase>Network Adress Translation</foreignphrase>
	  (NAT) verwendet wird.</para>

	<para>Ein Beispiel daf&uuml;r w&auml;re ein kleines Unternehmen,
	  das &uuml;ber DSL oder ISDN an seinen ISP angebunden ist.  Es
	  verf&uuml;gt &uuml;ber 13 weltweit erreichbare IP-Adressen,
	  sein Netzwerk besteht aus 10 Rechnern.  In dieser Situation
	  ist die Verwendung von Subnetzen sowie einer routerbasierten
	  Firewall schwierig.</para>

	<indexterm><primary>Router</primary></indexterm>
	<indexterm><primary>DSL</primary></indexterm>
	<indexterm><primary>ISDN</primary></indexterm>

	<para>Eine brigdebasierte Firewall kann konfiguriert und in den
	  ISDN/DSL-Downstreampfad ihres Routers eingebunden werden, ohne
	  sich um IP-Adressen k&uuml;mmern zu m&uuml;ssen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Die LAN-Kopplung konfigurieren</title>

      <sect3>
	<title>Auswahl der Netzkarten</title>

	<para>Eine Bridge ben&ouml;tigt mindestens zwei Netzkarten.
	  Leider sind unter FreeBSD&nbsp;4.X nicht alle verf&uuml;gbaren
	  Netzkarten daf&uuml;r geeignet.  Lesen Sie &man.bridge.4;
	  f&uuml;r Informationen zu unterst&uuml;tzten Karten.</para>

	<para>Installieren und testen Sie beide Netzkarten, bevor Sie
	  fortfahren.</para>
      </sect3>

      <sect3>
	<title>Anpassen der Kernelkonfiguration</title>

	<indexterm><primary>Kernelkonfiguration</primary></indexterm>
	<indexterm>
	  <primary>Kernelkonfiguration</primary>
	  <secondary>options BRIDGE</secondary>
	</indexterm>

	<para>Um die Kernelunterst&uuml;tzung f&uuml;r die LAN-Kopplung
	  zu aktivieren, f&uuml;gen Sie</para>

	<programlisting>options BRIDGE</programlisting>

	<para>in Ihre Kernelkonfigurationsdatei ein, und erzeugen einen
	  neuen Kernel.</para>
      </sect3>

      <sect3>
	<title>Firewallunterst&uuml;tzung</title>

	<indexterm><primary>Firewall</primary></indexterm>

	<para>Wenn Sie die Bridge als Firewall verwenden wollen,
	  m&uuml;ssen Sie zus&auml;tzlich die Option
	  <literal>IPFIREWALL</literal> einf&uuml;gen.  Die
	  Konfiguration einer Firewall wird in
	  <xref linkend="firewalls"> des Handbuchs beschrieben.</para>

	<para>Wenn Sie Nicht-IP-Pakete (wie ARP-Pakete) durch Ihre
	  Bridge leiten wollen, m&uuml;ssen Sie eine zus&auml;tzliche
	  Option verwenden.  Es handelt sich um
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal>.
	  Beachten Sie aber, dass Ihre Firewall durch diese Option per
	  Voreinstellung alle Pakete akzeptiert.  Sie sollten sich also
	  &uuml;ber die Auswirkungen dieser Option im Klaren sein,
	  bevor Sie sie verwenden.</para>
      </sect3>

      <sect3>
	<title>Unterst&uuml;tzung f&uuml;r Traffic Shaping</title>

	<para>Wenn Sie die Bridge als Traffic-Shaper verwenden wollen,
	  m&uuml;ssen Sie die Option <literal>DUMMYNET</literal> in
	  Ihre Kernelkonfigurationsdatei einf&uuml;gen.  Lesen Sie
	  &man.dummynet.4;, um weitere Informationen zu erhalten.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Die LAN-Kopplung aktivieren</title>

      <para>F&uuml;gen Sie die Zeile</para>

      <programlisting>net.link.ether.bridge=1</programlisting>

      <para>in <filename>/etc/sysctl.conf</filename> ein, um die Bridge
        zur Laufzeit zu aktivieren, sowie die Zeile</para>

      <programlisting>net.link.ether.bridge_cfg=<replaceable>if1</replaceable>,<replaceable>if2</replaceable></programlisting>

      <para>um die LAN-Kopplung f&uuml;r die festgelegten Ger&auml;te
	zu erm&ouml;glichen (ersetzen Sie dazu
	<replaceable>if1</replaceable> und
	<replaceable>if2</replaceable> durch die Namen Ihrer
	Netzkarten).  Wenn Sie die Datenpakete via &man.ipfw.8; filtern
	wollen, sollten Sie zus&auml;tzlich folgende Zeile
	einf&uuml;gen:</para>

      <programlisting>net.link.ether.bridge_ipfw=1</programlisting>

      <para>Ab &os;&nbsp;5.2-RELEASE verwenden Sie die
	folgenden Zeilen:</para>

      <programlisting>net.link.ether.bridge.enable=1
net.link.ether.bridge.config=<replaceable>if1</replaceable>,<replaceable>if2</replaceable>
net.link.ether.bridge.ipfw=1</programlisting>
    </sect2>

    <sect2>
      <title>Sonstige Informationen</title>

      <para>Wenn Sie via &man.telnet.1; auf die Bridge zugreifen wollen,
	k&ouml;nnen Sie einer der Netzkarten eine IP-Adresse zuzuweisen.
	Es besteht Einigkeit dar&uuml;ber, dass es eine schlechte Idee
	ist, beiden Karten eine IP-Adresse zuzuweisen.
      </para>

      <para>Wenn Sie verschiedene Bridges in Ihrem Netzwerk haben, kann
	es dennoch nicht mehr als einen Weg zwischen zwei
	Arbeitspl&auml;tzen geben.  Das hei&szlig;t,
	<foreignphrase>Spanning tree link Management</foreignphrase>
	wird nicht unterst&uuml;tzt.</para>

      <para>Eine Bridge kann, besonders f&uuml;r Verkehr &uuml;ber
	Segmente, die Laufzeiten von Paketen erh&ouml;hen.</para>
    </sect2>
  </sect1>

  <sect1 id="network-nfs">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
	  <contrib>Reorganisiert und erweitert von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
	  <firstname>Bill</firstname>
	  <surname>Swingle</surname>
	  <contrib>Geschrieben von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>NFS &ndash; Network File System</title>

    <indexterm><primary>NFS</primary></indexterm>

    <para>Eines der vielen von FreeBSD unterst&uuml;tzten Dateisysteme
      ist das Netzwerkdateisystem, das auch als <acronym>NFS</acronym>
      bekannt ist.  <acronym>NFS</acronym> erm&ouml;glicht es einem
      System, Dateien und Verzeichnisse &uuml;ber ein Netzwerk mit
      anderen zu teilen.  &Uuml;ber <acronym>NFS</acronym> k&ouml;nnen
      Benutzer und Programme auf Daten entfernter Systeme zugreifen, und
      zwar genauso, wie wenn es sich um lokale Daten handeln w&uuml;rde.
    </para>

    <para>Einige der wichtigsten Vorteile von <acronym>NFS</acronym>
      sind:</para>

    <itemizedlist>
      <listitem>
	<para>Lokale Arbeitsstationen ben&ouml;tigen weniger
	  Plattenplatz, da gemeinsam benutzte Daten nur auf einem
	  einzigen Rechner vorhanden sind.  Alle anderen Stationen
	  greifen &uuml;ber das Netzwerk auf diese Daten zu.</para>
      </listitem>

      <listitem>
	<para>Benutzer ben&ouml;tigen nur noch ein zentrales
	  Heimatverzeichnis auf einem <acronym>NFS</acronym>-Server.
	  Diese Verzeichnisse sind &uuml;ber das Netzwerk auf allen
	  Stationen verf&uuml;gbar.</para>
      </listitem>

      <listitem>
	<para>Speicherger&auml;te wie Disketten-, CD-ROM-
	  oder ZIP-Laufwerke k&ouml;nnen &uuml;ber das Netzwerk von
	  anderen Arbeitstationen genutzt werden.  Dadurch sind f&uuml;r
	  das gesamte Netzwerk deutlich weniger Speicherger&auml;te
	  n&ouml;tig.</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Wie funktioniert <acronym>NFS</acronym>?</title>

      <para><acronym>NFS</acronym> besteht aus zwei Hauptteilen: Einem
        Server und einem oder mehreren Clients.  Der Client greift
	&uuml;ber das Netzwerk auf die Daten zu, die auf dem Server
	gespeichert sind.  Damit dies korrekt funktioniert, m&uuml;ssen
	einige Prozesse konfiguriert und gestartet werden:</para>

      <note>
	<para>In &os;&nbsp;5.X wurde <application>portmap</application>
	  durch <command>rpcbind</command> ersetzt.  Benutzer von
	  &os;&nbsp;5.X m&uuml;ssen daher in den folgenden Beispielen
	  <application>portmap</application> durch
	  <command>rpcbind</command> ersetzen.</para>
      </note>

      <para>Der Server ben&ouml;tigt folgende Daemonen:</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>Server</secondary>
      </indexterm>

      <indexterm>
        <primary><application>portmap</application></primary>
      </indexterm>

      <indexterm>
        <primary><application>mountd</application></primary>
      </indexterm>

      <indexterm>
        <primary><application>nfsd</application></primary>
      </indexterm>

      <informaltable frame="none">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Daemon</entry>

	      <entry>Beschreibung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>nfsd</entry>

	      <entry>Der <acronym>NFS</acronym>-Daemon.  Er bearbeitet
	        Anfragen der <acronym>NFS</acronym>-Clients.</entry>
	    </row>

	    <row>
	      <entry>mountd</entry>

	      <entry>Der <acronym>NFS</acronym>-Mount-Daemon.  Er
	        bearbeitet die Anfragen, die &man.nfsd.8; an ihn
		weitergibt.</entry>
	    </row>

	    <row>
	      <entry>portmap</entry>

	      <entry> Der Portmapper-Daemon.  Durch ihn erkennen die
	        <acronym>NFS</acronym>-Clients, welchen Port der
		<acronym>NFS</acronym>-Server verwendet.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Der Client kann ebenfalls einen Daemon aufrufen, und zwar
	den <application>nfsiod</application>-Daemon.  Der
	<application>nfsiod</application>-Daemon bearbeitet Anfragen vom
	<acronym>NFS</acronym>-Server.  Er ist optional und verbessert
	die Leistung des Netzwerks.  F&uuml;r eine normale und korrekte
	Arbeit ist er allerdings nicht erforderlich.  Mehr erfahren
	Sie in der Hilfeseite &man.nfsiod.8;.</para>
    </sect2>

    <sect2 id="network-configuring-nfs">
      <title><acronym>NFS</acronym> einrichten</title>

      <indexterm>
        <primary>NFS</primary>
	<secondary>einrichten</secondary>
      </indexterm>

      <para><acronym>NFS</acronym> l&auml;sst sich leicht
        einrichten.  Die n&ouml;tigen Prozesse werden durch einige
	&Auml;nderungen in <filename>/etc/rc.conf</filename> bei
	jedem Systemstart gestartet.</para>

      <para>Stellen Sie sicher, dass auf dem
	<acronym>NFS</acronym>-Server folgende Optionen in der Datei
	<filename>/etc/rc.conf</filename> gesetzt sind:</para>

      <programlisting>portmap_enable="YES"
nfs_server_enable="YES"
mountd_flags="-r"</programlisting>

      <para><command>mountd</command> l&auml;uft automatisch, wenn der
        <acronym>NFS</acronym>-Server aktiviert ist.</para>

      <para>Auf dem Client muss in <filename>/etc/rc.conf</filename>
        folgende Option gesetzt sein:</para>

      <programlisting>nfs_client_enable="YES"</programlisting>

      <para><filename>/etc/exports</filename> legt fest, welche
	Dateisysteme <acronym>NFS</acronym> exportieren (manchmal auch
	als <quote>teilen</quote> bezeichnet) soll.  Jede Zeile in
	<filename>/etc/exports</filename> legt ein Dateisystem sowie
	die Arbeitsstationen, die darauf Zugriff haben, fest.
	Au&szlig;erdem ist es m&ouml;glich, Zugriffsoptionen
	festzulegen.  Es gibt viele verschiedene Optionen, allerdings
	werden hier nur einige von ihnen erw&auml;hnt.  Wenn Sie
	Informationen zu weiteren Optionen ben&ouml;tigen, lesen Sie
	&man.exports.5;.</para>

      <para>Nun folgen einige Beispieleintr&auml;ge f&uuml;r
        <filename>/etc/exports</filename>:</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>Export von Dateisystemen</secondary>
      </indexterm>

      <para>Die folgenden Beispiele geben Ihnen Anhaltspunkte zum
        Exportieren von Dateisystemen, obwohl diese Einstellungen
	nat&uuml;rlich von Ihrer Arbeitsumgebung und Ihrer
	Netzwerkkonfiguration abh&auml;ngen.  Das n&auml;chste
	Beispiel exportiert das Verzeichnis <filename>/cdrom</filename>
	f&uuml;r drei Rechner, die sich in derselben Dom&auml;ne wie
	der Server befinden oder f&uuml;r die entsprechende
	Eintr&auml;ge in <filename>/etc/hosts</filename> existieren.
	Die Option <option>-ro</option> kennzeichnet das
	exportierte Dateisystem als schreibgesch&uuml;tzt.  Durch dieses
	Flag ist das entfernte System nicht in der Lage, das exportierte
	Dateisystem zu ver&auml;ndern.</para>

      <programlisting>/cdrom -ro host1 host2 host3</programlisting>

      <para>Die n&auml;chste Zeile exportiert <filename>/home</filename>
        auf drei durch IP-Adressen bestimmte Rechner.  Diese Einstellung
	ist n&uuml;tzlich, wenn Sie &uuml;ber ein privates Netzwerk ohne
	<acronym>DNS</acronym>-Server verf&uuml;gen.  Optional
	k&ouml;nnten interne Rechnernamen auch in
	<filename>/etc/hosts</filename>	konfiguriert werden.
	Ben&ouml;tigen Sie hierzu weitere Informationen, lesen Sie bitte
	&man.hosts.5;.  Durch das Flag <option>-alldirs</option> wird es
	m&ouml;glich, auch Unterverzeichnisse als Mountpunkte
	festzulegen.  Dies bedeutet aber nicht, dass alle
	Unterverzeichnisse eingeh&auml;ngt werden, vielmehr wird es dem
	Client erm&ouml;glicht, nur diejenigen	Verzeichnisse
	einzuh&auml;ngen, die auch ben&ouml;tigt werden.</para>

      <programlisting>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

      <para>Die n&auml;chste Zeile exportiert <filename>/a</filename>,
        damit Clients von verschiedenen Dom&auml;nen auf das Dateisystem
	zugreifen k&ouml;nnen.  Das <option>-maproot=root</option>-Flag
	erlaubt es dem Benutzer <username>root</username> des entfernten
	Systems, als <username>root</username> auf das exportierte
	Dateisystem zu schreiben.  Wenn dieses Flag nicht gesetzt ist,
	kann selbst <username>root</username> nicht auf das exportierte
	Dateisystem schreiben.</para>

      <programlisting>/a  -maproot=root  host.example.com box.example.org</programlisting>

      <para>Damit ein Client auf ein exportiertes Dateisystem zugreifen
        kann, muss ihm dies explizit gestattet werden.  Stellen Sie also
	sicher, dass der Client in <filename>/etc/exports</filename>
	aufgef&uuml;hrt wird.</para>

      <para>Jede Zeile in <filename>/etc/exports</filename> entspricht
	der Exportinformation f&uuml;r ein Dateisystem auf einen
	Rechner.  Ein entfernter Rechner kann f&uuml;r jedes Dateisystem
	nur einmal festgelegt werden, und kann auch nur einen
	Standardeintrag	haben.  Nehmen wir an, dass
	<filename>/usr</filename> ein einziges Dateisystem ist.  Dann
	w&auml;ren folgende Zeilen ung&uuml;ltig:</para>

      <programlisting>/usr/src   client
/usr/ports client</programlisting>

      <para>Das Dateisystem <filename>/usr</filename> wird hier zweimal
	auf den selben Rechner (<hostid>client</hostid>)
	exportiert.  Dies ist aber nicht zul&auml;ssig.  Der korrekte
	Eintrag sieht daher so aus:</para>

      <programlisting>/usr/src /usr/ports  client</programlisting>

      <para>Die Eigenschaften eines auf einen anderen Rechner
	exportierten Dateisystems m&uuml;ssen alle in einer Zeile
	stehen.  Zeilen, in denen kein Rechner festgelegt wird, werden
	als einzelner Rechner behandelt.  Dies schr&auml;nkt die
	M&ouml;glichkeiten zum Export von Dateisystemen ein, f&uuml;r
	die meisten Anwender ist dies aber kein Problem.</para>

      <para>Eine g&uuml;ltige Exportliste, in der
        <filename>/usr</filename> und <filename>/exports</filename>
	lokale Dateisysteme sind, sieht so aus:</para>

      <programlisting># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports                  client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</programlisting>

      <para>Sie m&uuml;ssen <command>mountd</command> nach jeder
        &Auml;nderung von <filename>/etc/exports</filename> neu
	starten, damit die &Auml;nderungen wirksam werden.  Dies
	kann durch das Senden des HUP-Signals an den
	<command>mountd</command>-Prozess erfolgen:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>

      <para>Alternativ k&ouml;nnen Sie auch das System neu starten.
        Dies ist allerdings nicht n&ouml;tig.  Wenn Sie die folgenden
	Befehle als <username>root</username> ausf&uuml;hren, sollte
	alles korrekt gestartet werden.</para>

      <para>Auf dem <acronym>NFS</acronym>-Server:</para>

      <screen>&prompt.root; <userinput>portmap</userinput>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput></screen>

      <para>Auf dem <acronym>NFS</acronym>-Client:</para>

      <screen>&prompt.root; <userinput>nfsiod -n 4</userinput></screen>

      <para>Nun sollte alles bereit sein, um ein entferntes Dateisystem
        einh&auml;ngen zu k&ouml;nnen.  In unseren Beispielen nennen wir
	den Server <literal>server</literal>, den Client
	<literal>client</literal>.  Wenn Sie ein entferntes Dateisystem
	nur zeitweise einh&auml;ngen wollen, oder nur Ihre Konfiguration
	testen m&ouml;chten, f&uuml;hren Sie auf dem Client als
	<username>root</username> einen Befehl &auml;hnlich dem
	folgenden aus:</para>

      <indexterm>
        <primary>NFS</primary>
	<secondary>Dateisysteme einh&auml;ngen</secondary>
      </indexterm>

      <screen>&prompt.root; <userinput>mount server:/home /mnt</userinput></screen>

      <para>Dadurch wird das Verzeichnis <filename>/home</filename> des
	Servers auf dem Client unter <filename>/mnt</filename>
	eingeh&auml;ngt.  Wenn alles korrekt konfiguriert wurde, sehen
	Sie auf dem Client im Verzeichnis <filename>/mnt</filename> alle
	Dateien des Servers.</para>

      <para>Wenn Sie ein entferntes Dateisystem nach jedem Systemstart
	automatisch einh&auml;ngen wollen, f&uuml;gen Sie das
	Dateisystem in <filename>/etc/fstab</filename> ein.  Dazu ein
	Beispiel:</para>

      <programlisting>server:/home	/mnt	nfs	rw	0	0</programlisting>

      <para>Eine Beschreibung aller Optionen enth&auml;lt
	die Hilfeseite &man.fstab.5;.</para>
    </sect2>

    <sect2>
      <title>Praktische Anwendungen</title>

      <para><acronym>NFS</acronym> ist in vielen Situationen
        n&uuml;tzlich.  Einige Anwendungsbereiche finden Sie in der
	folgenden Liste:</para>

      <indexterm>
        <primary>NFS</primary>
	<secondary>Anwendungsbeispiele</secondary>
      </indexterm>

      <itemizedlist>
        <listitem>
	  <para>Mehrere Maschinen k&ouml;nnen sich ein CD-ROM-Laufwerk
	    oder andere Medien teilen.  Dies ist billiger und
	    au&szlig;erdem praktischer, um Programme auf mehreren
	    Rechnern zu installieren.</para>
	</listitem>

	<listitem>
	  <para>In gr&ouml;&szlig;eren Netzwerken ist es praktisch,
	    einen zentralen <acronym>NFS</acronym>-Server einzurichten,
	    auf dem die Heimatverzeichnisse der Benutzer gespeichert
	    werden.  Diese Heimatverzeichnisse werden &uuml;ber das
	    Netzwerk exportiert.  Dadurch haben die Benutzer immer das
	    gleiche Heimatverzeichnis zur Verf&uuml;gung,
	    unabh&auml;ngig davon, an welchem Arbeitsplatz sie sich
	    anmelden.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Rechner k&ouml;nnen auf ein gemeinsames
	    Verzeichnis <filename>/usr/ports/distfiles</filename>
	    zugreifen.  Wenn Sie nun einen Port auf mehreren Rechnern
	    installieren wollen, greifen Sie einfach auf dieses
	    Verzeichnis zu, ohne die Quelldateien auf jede Maschine
	    zu kopieren.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="network-amd">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Wylie</firstname>
	    <surname>Stilwell</surname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>

	<authorgroup>
	  <author>
	    <firstname>Chern</firstname>
	    <surname>Lee</surname>
	    <contrib>&Uuml;berarbeitet von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title><application>AMD</application></title>

      <indexterm><primary>amd</primary></indexterm>
      <indexterm><primary>Automatic Mounter Daemon</primary></indexterm>

      <para>&man.amd.8; (Automatic Mounter Daemon) h&auml;ngt ein
	entferntes Dateisystem automatisch ein,
	wenn auf eine Datei oder ein Verzeichnis in diesem Dateisystem
	zugegriffen wird.  Dateisysteme, die &uuml;ber einen gewissen
	Zeitraum inaktiv sind, werden von <application>amd</application>
	automatisch abgeh&auml;ngt.
	<application>amd</application> ist eine einfache
	Alternative zum dauerhaften Einh&auml;ngen von Dateisystemen
	in <filename>/etc/fstab</filename>.</para>

      <para>In der Voreinstellung stellt <application>amd</application>
	die Verzeichnisse <filename>/host</filename> und
	<filename>/net</filename> als NFS-Server bereit.  Wenn auf eine
	Datei in diesen Verzeichnissen zugegriffen wird, sucht
	<application>amd</application> den entsprechenden Mountpunkt
	und h&auml;ngt das Dateisystem automatisch ein.
	<filename>/net</filename> wird zum Einh&auml;ngen von
	exportierten Dateisystemen von einer IP-Adresse verwendet,
	w&auml;hrend <filename>/host</filename> zum Einh&auml;ngen
	von exportierten Dateisystemen eines durch seinen Namen
	festgelegten Rechners dient.</para>

      <para>Ein Zugriff auf eine Datei in
        <filename>/host/foobar/usr</filename> w&uuml;rde
	<application>amd</application> veranlassen,
	das von <hostid>foobar</hostid> exportierte Dateisystem
	<filename>/usr</filename> einzuh&auml;ngen.</para>

      <example>
	<title>Ein exportiertes Dateisystem mit
	  <application>amd</application> in den Verzeichnisbaum
	    einh&auml;ngen</title>

	<para>Sie k&ouml;nnen sich die verf&uuml;gbaren Mountpunkte
	  eines entfernten Rechners mit <command>showmount</command>
	  ansehen.  Wollen Sie sich die Mountpunkte des Rechners
	  <hostid>foobar</hostid> ansehen, so verwenden Sie:</para>

	<screen>&prompt.user; <userinput>showmount -e foobar</userinput>
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
&prompt.user; <userinput>cd /host/foobar/usr</userinput></screen>
      </example>

      <para>Wie Sie an diesem Beispiel erkennen k&ouml;nnen, zeigt
        <command>showmount</command> <filename>/usr</filename>
	als exportiertes Dateisystem an.  Wenn man in das Verzeichnis
	<filename>/host/foobar/usr</filename> wechselt, versucht
	<application>amd</application> den Rechnernamen
	<hostid>foobar</hostid>	aufzul&ouml;sen	und den gew&uuml;nschten
	Export in den Verzeichnisbaum einzuh&auml;ngen.</para>

      <para><application>amd</application> kann durch das Einf&uuml;gen
        der folgenden Zeile in <filename>/etc/rc.conf</filename>
	automatisch gestartet werden:</para>

      <programlisting>amd_enable="YES"</programlisting>

      <para>Mit der Option <varname>amd_flags</varname> kann
        <application>amd</application> angepasst werden.
	Die Voreinstellung f&uuml;r <varname>amd_flags</varname> sieht
	so aus:</para>

      <programlisting>amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"</programlisting>

      <para><filename>/etc/amd.map</filename> legt die Standardoptionen
        fest, mit denen exportierte Dateisysteme in den Verzeichnisbaum
	eingeh&auml;ngt werden.  <filename>/etc/amd.conf</filename>
	hingegen legt einige der erweiterten Optionen von
	<application>amd</application> fest.</para>

      <para>Weitere Informationen finden Sie in den Hilfeseiten
	&man.amd.8; und &man.amd.conf.5;.</para>
    </sect2>

    <sect2 id="network-nfs-integration">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>John</firstname>
            <surname>Lind</surname>
            <contrib>Beigetragen von </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Integrationsprobleme mit anderen Systemen</title>

      <para>Bestimmte ISA-Ethernetadapter haben Beschr&auml;nkungen, die
        zu ernsthaften Netzwerkproblemen, insbesondere mit NFS
	f&uuml;hren k&ouml;nnen.  Es handelt sich dabei nicht um ein
	FreeBSD-spezifisches Problem, aber FreeBSD-Systeme sind davon
	ebenfalls betroffen.</para>

      <para>Das Problem tritt fast ausschlie&szlig;lich dann auf, wenn
        (FreeBSD)-PC-Systeme mit Hochleistungsrechnern verbunden werden,
	wie Systemen von Silicon&nbsp;Graphics, Inc. oder
	Sun&nbsp;Microsystems, Inc.  Das Einh&auml;ngen via NFS
	funktioniert problemlos, auch einige Dateioperationen
	k&ouml;nnen erfolgreich sein.  Pl&ouml;tzlich aber wird der
	Server nicht mehr auf den Client reagieren, obwohl Anfragen von
	anderen Rechnern weiterhin bearbeitet werden.  Dieses
	Problem betrifft stets den Client, egal ob es sich beim Client
	um das FreeBSD-System oder den Hochleistungsrechner handelt.
	Auf vielen Systemen gibt es keine M&ouml;glichkeit mehr, den
	Client ordnungsgem&auml;&szlig; zu beenden.  Die einzige
	L&ouml;sung ist es oft, den Rechner neu zu starten, da dieses
	NFS-Problem nicht mehr behoben werden kann.</para>

      <para>Die <quote>korrekte</quote> L&ouml;sung f&uuml;r dieses
        Problem ist es, sich eine schnellere Ethernetkarte f&uuml;r
	FreeBSD zu kaufen.  Allerdings gibt es auch eine einfache und
	meist zufriedenstellende L&ouml;sung, um dieses Problem zu
	umgehen.  Wenn es sich beim FreeBSD-System um den
	<emphasis>Server</emphasis> handelt, verwenden Sie beim
	Einh&auml;ngen in den Verzeichnisbaum auf der Clientseite
	zus&auml;tzlich die Option <option>-w=1024</option> .  Wenn es
	sich beim FreeBSD-System um den <emphasis>Client</emphasis>
	handelt, dann h&auml;ngen Sie das NFS-Dateisystem mit der
	zus&auml;tzlichen Option <option>-r=1024</option> ein.
	Diese Optionen k&ouml;nnen auf der Clientseite auch durch
	das vierte Feld der Eintr&auml;ge in
	<filename>/etc/fstab</filename>	festgelegt werden, damit die
	Dateisysteme automatisch eingeh&auml;ngt werden.  Um die
	Dateisysteme manuell einzuh&auml;ngen, verwendet man bei
	<command>mount</command> zus&auml;tzlich die Option
	<option>-o</option>.</para>

      <para>Es gibt ein anderes Problem, das oft mit diesem verwechselt
        wird.  Dieses andere Problem tritt auf, wenn sich &uuml;ber NFS
	verbundene Server und Clients in verschiedenen Netzwerken
	befinden.  Wenn dies der Fall ist, stellen Sie
	<emphasis>sicher</emphasis>, dass Ihre Router die
	n&ouml;tigen UDP-Informationen weiterleiten, oder Sie werden
	nirgends hingelangen, egal was Sie machen.</para>

      <para>In den folgenden Beispielen ist <hostid>fastws</hostid> der
        Name des Hochleistungsrechners (bzw. dessen Schnittstelle),
	<hostid>freebox</hostid> hingegen ist der Name des
	FreeBSD-Systems, das &uuml;ber eine Netzkarte mit geringer
	Leistung verf&uuml;gt.  <filename>/sharedfs</filename> ist das
	exportierte NFS&nbsp;-Dateisystem (lesen Sie dazu auch
	&man.exports.5;).  Bei <filename>/project</filename> handelt es
	sich um den Mountpunkt, an dem das exportierte Dateisystem auf
	der Clientseite	eingeh&auml;ngt wird.  In allen F&auml;llen
	k&ouml;nnen zus&auml;tzliche Optionen, wie z.B.
	<option>hard</option>, <option>soft</option> oder
	<option>bg</option> w&uuml;nschenswert sein.</para>

      <para>FreeBSD als Client (eingetragen in
	<filename>/etc/fstab</filename> auf <hostid>freebox</hostid>):
      </para>

      <programlisting>fastws:/sharedfs /project nfs rw,-r=1024 0 0</programlisting>

      <para>Manuelles Einh&auml;ngen auf
	<hostid>freebox</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sharedfs /project</userinput></screen>

      <para>&os; als Server (eingetragen in
	<filename>/etc/fstab</filename> auf <hostid>fastws</hostid>):
      </para>

      <programlisting>freebox:/sharedfs /project nfs rw,-w=1024 0 0</programlisting>

      <para>Manuelles Einh&auml;ngen auf <hostid>fastws</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sharedfs /project</userinput></screen>

      <para>Nahezu alle 16-bit Ethernetadapter erlauben Operationen
        ohne obengenannte Einschr&auml;nkungen auf die Lese- oder
	Schreibgr&ouml;&szlig;e.</para>

      <para>F&uuml;r alle technisch Interessierten wird nun beschrieben,
        was passiert, wenn dieser Fehler auftritt, und warum er
	irreversibel ist.  NFS arbeitet &uuml;blicherweise mit einer
	<quote>Blockgr&ouml;&szlig;e</quote> von 8&nbsp;kByte (obwohl
	es kleinere Fragmente zulassen w&uuml;rde).  Da die maximale
	Rahmengr&ouml;&szlig;e von Ethernet 1500&nbsp;Bytes
	betr&auml;gt, wird der NFS-<quote>Block</quote> in einzelne
	Ethernetrahmen aufgeteilt, obwohl es sich nach wie vor um eine
	Einheit handelt, die auch als Einheit empfangen, verarbeitet
	und <emphasis>best&auml;tigt</emphasis> werden muss.  Der
	Hochleistungsrechner verschickt die Pakete, aus denen der
	NFS-Block besteht, so eng hintereinander, wie es der Standard
	erlaubt.  Auf der anderen Seite (auf der sich die langsamere
	Netzkarte befindet), &uuml;berschreiben die sp&auml;teren
	Pakete ihre Vorg&auml;nger, bevor diese vom System verarbeitet
	werden (&Uuml;berlauf!).  Dies hat zur Folge, dass der NFS-Block
	nicht mehr rekonstruiert und best&auml;tigt werden kann.  Als
	Folge davon glaubt der Hochleistungsrechner, dass der andere
	Rechner nicht erreichbar ist (Timeout!) und versucht die
	Sendung zu wiederholen.  Allerdings wird wiederum der komplette
	NFS-Block verschickt, so dass sich der ganze Vorgang wiederholt,
	und zwar immer wieder (oder bis zum Systemneustart).</para>

      <para>Indem wir die Einheitengr&ouml;&szlig;e unter der maximalen
        Gr&ouml;&szlig;e der Ethernetpakete halten, k&ouml;nnen wir
	sicherstellen, dass jedes vollst&auml;ndig erhaltene
	Ethernetpaket individuell angesprochen werden kann und vermeiden
	die Blockierung des Systems.</para>

      <para>&Uuml;berl&auml;ufe k&ouml;nnen zwar nach wie vor auftreten,
        wenn ein Hochleistungsrechner Daten auf ein PC-System
	transferiert.  Durch die besseren (und schnelleren) Netzkarten
	treten solche &Uuml;berl&auml;ufe allerdings nicht mehr
	<emphasis>zwingend</emphasis> auf, wenn
	NFS-<quote>Einheiten</quote> &uuml;bertragen werden.  Tritt nun
	ein &Uuml;berlauf auf, wird die betroffene Einheit erneut
	verschickt, und es besteht eine gute Chance, dass sie nun
	erhalten, verarbeitet und best&auml;tigt werden kann.</para>
    </sect2>
  </sect1>

  <sect1 id="network-diskless">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Jean-Fran&ccedil;ois</firstname>
          <surname>Dock&egrave;s</surname>
          <contrib>Aktualisiert von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
	<author>
	  <firstname>Alex</firstname>
	  <surname>Dupre</surname>
	  <contrib>Reorganisiert und erweitert von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Start und Betrieb von FreeBSD &uuml;ber ein Netzwerk</title>

    <indexterm>
      <primary>plattenloser Arbeitsplatz</primary>
    </indexterm>
    <indexterm>
      <primary>plattenloser Betrieb</primary>
    </indexterm>

    <para>FreeBSD kann &uuml;ber ein Netzwerk starten und arbeiten, ohne
      eine lokale Festplatte zu verwenden, indem es Dateisysteme eines
      <acronym>NFS</acronym>-Servers in den eigenen Verzeichnisbaum
      einh&auml;ngt.  Dazu sind, von den Standardkonfigurationsdateien
      abgesehen, keine System&auml;nderungen n&ouml;tig.  Ein solches
      System kann leicht installiert werden, da alle notwendigen
      Elemente bereits vorhanden sind:</para>

    <itemizedlist>
      <listitem>
        <para>Es gibt mindestens zwei M&ouml;glichkeiten, den Kernel
          &uuml;ber das Netzwerk zu laden:</para>

        <itemizedlist>
          <listitem>
	    <para><acronym>PXE</acronym>: Das
              <quote>Preboot Execution Environment System</quote> von
	      &intel; ist eine Art intelligentes Boot-ROM, das in
	      einigen Netzkarten oder Hauptplatinen verwendet wird.
	      Weitere Informationen finden Sie in &man.pxeboot.8;.
	    </para>
          </listitem>

          <listitem>
            <para>Der Port
	      <application>etherboot</application>
	      (<filename role="package">net/etherboot</filename>)
	      erzeugt ROM-f&auml;higen Code, um einen Kernel &uuml;ber
	      das Netzwerk zu laden.  Dieser Code kann entweder auf ein
              Boot-PROM einer Netzkarte gebrannt werden, was von vielen
              Netzkarten unterst&uuml;tzt wird.  Oder er kann von einer
              lokalen Diskette, Festplatte oder von einem laufenden
              &ms-dos;-System geladen werden.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Das Beispielskript
	  <filename>/usr/share/examples/diskless/clone_root</filename>
	  erleichtert die Erzeugung und die Wartung des
	  root-Dateisystems auf dem Server.  Das Skript muss
	  wahrscheinlich angepasst werden, dennoch werden Sie schnell zu
	  einem Ergebnis kommen.</para>
      </listitem>

      <listitem>
        <para>Die Startdateien, die einen plattenlosen Systemstart
          erkennen und unterst&uuml;tzen, sind nach der Installation
          in <filename>/etc</filename> vorhanden.</para>
      </listitem>

      <listitem>
	<para>Dateiauslagerungen k&ouml;nnen sowohl via
	  <acronym>NFS</acronym> als auch auf die lokale Platte
	  erfolgen.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt verschiedene Wege, einen plattenlosen Rechner
      einzurichten.  Viele Elemente sind daran beteiligt, die fast
      immer an den pers&ouml;nlichen Geschmack angepasst werden
      k&ouml;nnen.  Im folgenden Abschnitt wird die Installation
      eines kompletten Systems beschrieben, wobei der
      Schwerpunkt auf Einfachheit und Kompatibilit&auml;t zu den
      Standardstartskripten von FreeBSD liegt.  Das beschriebene
      System hat folgende Eigenschaften:</para>

    <itemizedlist>
      <listitem>
        <para>Die plattenlosen Rechner haben ein gemeinsames
          <filename>root</filename>- sowie ein gemeinsames
          <filename>/usr</filename>-Dateisystem, die jeweils
          schreibgesch&uuml;tzt sind.</para>

        <para>Das <filename>root</filename>-Dateisystem ist eine Kopie
          eines Standardwurzelverzeichnisses von FreeBSD
          (&uuml;blicherweise das des Servers), bei dem einige
          Konfigurationsdateien durch f&uuml;r den plattenlosen
          Betrieb geeignete Versionen ersetzt wurden.</para>

        <para>F&uuml;r die Bereiche von <filename>root</filename>, die
          beschreibbar sein m&uuml;ssen, werden mit &man.mfs.8;
	  (&os;&nbsp;4.X) oder &man.md.4; (&os;&nbsp;5.X)
          virtuelle Dateisysteme erzeugt.  Dies bedeutet aber auch, dass
          alle Ver&auml;nderungen verloren gehen, wenn das System neu
          gestartet wird.</para>
      </listitem>

      <listitem>
	<para>Der Kernel wird, in Abh&auml;ngigkeit von der jeweiligen
	  Situation, entweder von <application>etherboot</application>
	  oder von <acronym>PXE</acronym> transferiert und geladen.
	</para>
      </listitem>
    </itemizedlist>

    <caution><para>Das hier beschriebene System ist nicht sicher.  Es
      sollte nur in einem gesicherten Bereich eines Netzwerks verwendet
      werden und f&uuml;r andere Rechner nicht erreichbar sein.</para>
    </caution>

    <para>Alle Informationen in diesem Abschnitt wurden unter
      &os;&nbsp;4.9-RELEASE sowie 5.2.1-RELEASE getestet.  Die
      Beschreibungen beziehen sich aber vor allem auf die Version 4.X.
      Falls n&ouml;tig, wurden daher Hinweise auf eventuelle
      &Auml;nderungen unter 5.X eingef&uuml;gt.</para>

    <sect2>
      <title>Hintergrundinformationen</title>

      <para>Die Einrichtung von plattenlosen Rechnern ist einfach, aber
	auch fehleranf&auml;llig.  Der Grund daf&uuml;r sind auftretende
	Fehler, die sich oft nur schwer zuordnen lassen.  Unter anderem
	sind daf&uuml;r folgende Umst&auml;nde verantwortlich:</para>

      <itemizedlist>
	<listitem>
	  <para>Kompilierte Optionen haben zur Laufzeit unterschiedliche
	    Auswirkungen.</para>
	</listitem>

	<listitem>
	  <para>Fehlermeldungen sind oft kryptisch oder fehlen
	    vollst&auml;ndig.</para>
	</listitem>
      </itemizedlist>

      <para>Daher ist es n&uuml;tzlich, &uuml;ber die im Hintergrund
	ablaufenden Mechanismen Bescheid zu wissen.  Dadurch wird es
	einfacher, eventuell auftretende Fehler zu beheben.</para>

      <para>Verschiedene Operationen m&uuml;ssen ausgef&uuml;hrt werden,
	um ein System erfolgreich zu starten:</para>

      <itemizedlist>
	<listitem>
	  <para>Der Rechner ben&ouml;tigt einige Startparameter, wie
	    seine IP-Adresse, die Namen ausf&uuml;hrbarer Dateien, den
	    Servernamen sowie den root-Pfad.  F&uuml;r die
	    &Uuml;bermittlung dieser Informationen wird entweder das
	    <acronym>DHCP</acronym>- oder das BOOTP-Protokoll verwendet.
	    Bei <acronym>DHCP</acronym> handelt es sich um eine
	    abw&auml;rtskompatible Erweiterung von BOOTP, die die
	    gleichen Portnummern und das gleiche Paketformat verwendet.
	  </para>

	  <para>Es ist m&ouml;glich, das System so zu konfigurieren,
	    dass es nur BOOTP verwendet.  Das Serverprogramm
	    &man.bootpd.8; ist bereits im &os;-Basissystem enthalten.
	  </para>

	  <para><acronym>DHCP</acronym> hat im Vergleich zu BOOTP
	    allerdings mehrere Vorteile (bessere Konfigurationsdateien,
	    die M&ouml;glichkeit zur Verwendung von
	    <acronym>PXE</acronym>, sowie viele andere, die nicht in
	    direktem Zusammenhang mit dem plattenlosen Betrieb stehen).
	    Dieser Abschnitt beschreibt die Konfiguration mittels
	    <acronym>DHCP</acronym>.  Wenn m&ouml;glich, werden aber
	    entsprechende Beispiele f&uuml;r &man.bootpd.8;
	    angef&uuml;hrt.  Die Beispielkonfiguration nutzt das
	    Softwarepaket <application>ISC DHCP</application>.</para>
	</listitem>

	<listitem>
	  <para>Der Rechner muss ein oder mehrere Programme in den
	    lokalen Speicher laden.  Dazu wird entweder
	    <acronym>TFTP</acronym> oder <acronym>NFS</acronym>
	    verwendet.  Die Auswahl zwischen <acronym>TFTP</acronym> und
	    <acronym>NFS</acronym> erfolgt &uuml;ber das Setzen von
	    verschiedenen Kompilieroptionen.  Ein h&auml;ufig gemachter
	    Fehler ist es, Dateinamen f&uuml;r das falsche Protokoll
	    anzugeben:  <acronym>TFTP</acronym> transferiert
	    normalerweise alle Dateien aus einem einzigen Verzeichnis
	    des Servers, und erwartet einen Pfad relativ zu diesem
	    Verzeichnis.  <acronym>NFS</acronym> verlangt hingegen
	    absolute Dateipfade.</para>
	</listitem>

	<listitem>
	  <para>Die m&ouml;glichen Bootstrap-Programme und der Kernel
	    m&uuml;ssen initialisiert und ausgef&uuml;hrt werden.  Dabei
	    gibt es zwei M&ouml;glichkeiten:</para>

	  <itemizedlist>
	    <listitem>
	      <para><acronym>PXE</acronym> l&auml;dt &man.pxeboot.8;.
	        Dabei handelt es sich um eine modifizierte Version des
	        &os;-Laders der Boot-Phase drei.  Der &man.loader.8;
	        beschafft alle f&uuml;r den Systemstart notwendigen
	        Parameter, und hinterlegt diese in der Kernelumgebung,
	        bevor er die Kontrolle &uuml;bergibt.  Es ist hier
	        m&ouml;glich, den <filename>GENERIC</filename>-Kernel
	        zu verwenden.</para>
	    </listitem>

	    <listitem>
	      <para><application>etherboot</application> l&auml;dt den
	        Kernel hingegen direkt.  Daf&uuml;r m&uuml;ssen Sie
	        allerdings einen Kernel mit spezifischen Optionen
	        erzeugen.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Auf 4.X-Systemen sind <acronym>PXE</acronym> und
	    <application>etherboot</application> gleichwertig.
	    5.X-Kernel &uuml;bergeben hingegen viele Aufgaben an den
	    &man.loader.8;, daher ist die Verwendung von
	    <acronym>PXE</acronym> auf 5.X-Systemen
	    empfehlenswert.</para>

	  <para>Wenn Ihr <acronym>BIOS</acronym> und Ihre Netzkarten
	    <acronym>PXE</acronym> unterst&uuml;tzen, sollten Sie es
	    auch verwenden.  Es ist allerdings nach wie vor
	    m&ouml;glich, ein 5.X-System &uuml;ber
	    <application>etherboot</application> zu starten.</para>
	</listitem>

	<listitem>
	   <para>Zuletzt muss der Rechner auf seine Dateisysteme
	     zugreifen k&ouml;nnen.  Daf&uuml;r wird stets
	     <acronym>NFS</acronym> verwendet.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Informationen finden Sie in &man.diskless.8;.</para>
    </sect2>

    <sect2>
      <title>Installationsanweisungen</title>

      <sect3>
	<title>Konfiguration unter Verwendung von
	  <application>ISC DHCP</application></title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

	<para>Der <application>ISC DHCP</application>-Server kann
	  Anfragen sowohl von BOOTP als auch von DHCP beantworten.
	</para>

	<para><application>isc-dhcp 3.0</application> ist nicht Teil
	  des Basissystems.  Sie m&uuml;ssen es daher zuerst
	  installieren.  Verwenden Sie dazu den Port
	  <filename role="package">net/isc-dhcp3-server</filename>
	  oder das entsprechende Paket.  Allgemeine Informationen zu
	  Ports und Paketen finden Sie im <xref linkend="ports">
	  des Handbuchs.</para>

	<para>Nachdem <application>ISC DHCP</application> installiert
	  ist, muss das Programm konfiguriert werden (normalerweise in
	  <filename>/usr/local/etc/dhcpd.conf</filename>).  Im
	  folgenden Beispiel verwendet Rechner <hostid>margaux</hostid>
	  <application>etherboot</application>, w&auml;hrend Rechner
	  <hostid>corbieres</hostid> <acronym>PXE</acronym> verwendet:
	</para>

	<programlisting>          default-lease-time 600;
          max-lease-time 7200;
          authoritative;

          option domain-name "example.com";
          option domain-name-servers 192.168.4.1;
          option routers 192.168.4.1;

          subnet 192.168.4.0 netmask 255.255.255.0 {
            use-host-decl-names on; <co id="co-dhcp-host-name">
            option subnet-mask 255.255.255.0;
            option broadcast-address 192.168.4.255;

            host margaux {
              hardware ethernet 01:23:45:67:89:ab;
              fixed-address margaux.example.com;
              next-server 192.168.4.4;<co id="co-dhcp-next-server">
              filename "/tftpboot/kernel.diskless";<co id="co-dhcp-filename">
              option root-path "192.168.4.4:/data/misc/diskless";<co id="co-dhcp-root-path">
            }
           host corbieres {
             hardware ethernet 00:02:b3:27:62:df;
              fixed-address corbieres.example.com;
              next-server 192.168.4.4;
              filename "pxeboot";
              option root-path "192.168.4.4:/data/misc/diskless";
            }
          }
        </programlisting>

	<calloutlist>
	  <callout arearefs="co-dhcp-host-name"><para>Diese Option
	    weist <application>dhcpd</application> an, den Wert der
	    <literal>host</literal>-Deklaration als Rechnernamen des
	    plattenlosen Rechners zu senden.  Alternativ kann man der
	    Hostdeklaration Folgendes hinzuf&uuml;gen:
	    <literal>option host-name
	    <replaceable>margaux</replaceable></literal></para>
	  </callout>

	  <callout arearefs="co-dhcp-next-server"><para>Die Anweisung
	    <literal>next-server</literal> bestimmt den
	    <acronym>TFTP</acronym>- oder
	    <acronym>NFS</acronym>-Server, von dem der Loader oder
	    der Kernel geladen werden (in der Voreinstellung ist das
	    der <acronym>DHCP</acronym>-Server selbst).</para>
	  </callout>

	  <callout arearefs="co-dhcp-filename"><para>Die Anweisung
	    <literal>filename</literal> bestimmt die Datei, die
	    <application>etherboot</application> als n&auml;chstes
	    l&auml;dt.  Das genaue Format h&auml;ngt von der
	    gew&auml;hlten Transfermethode ab.
	    <application>etherboot</application> kann sowohl mit
	    <acronym>NFS</acronym> als auch mit
	    <acronym>TFTP</acronym> kompiliert werden.  In der
	    Voreinstellung wird der &os;-Port mit
	    <acronym>NFS</acronym>-Unterst&uuml;tzung kompiliert.
	    <acronym>PXE</acronym> verwendet <acronym>TFTP</acronym>,
	    daher wird im Beispiel ein relativer Dateipfad verwendet.
	    Dies kann aber, je nach Konfiguration des
	    <acronym>TFTP</acronym>-Servers, auch anders sein.
	    Beachten Sie, dass <acronym>PXE</acronym>
	    <filename>pxeboot</filename> l&auml;dt, und nicht den
	    Kernel.  Es ist auch m&ouml;glich, das Verzeichnis
	    <filename role="directory">/boot</filename> einer
	    &os;-CD-ROM von <filename>pxeboot</filename> laden zu
	    lassen.  &man.pxeboot.8; kann einen
	    <filename>GENERIC</filename>-Kernel laden, dadurch ist es
	    m&ouml;glich, <acronym>PXE</acronym> von einer entfernten
	    CD-ROM zu starten.</para>

	  <callout arearefs="co-dhcp-root-path"><para>Die Option
	    <literal>root-path</literal> bestimmt den Pfad des
	    root-Dateisystems in normaler NFS-Schreibweise.  Wird
	    <acronym>PXE</acronym> verwendet, ist es m&ouml;glich,
	    die IP-Adresse des Rechners wegzulassen, solange nicht
	    die Kerneloption BOOTP aktiviert wird.  Der
	    <acronym>NFS</acronym>-Server entspricht in diesem Fall
	    dem <acronym>TFTP</acronym>-Server.</para>
	  </callout>
	</calloutlist>
      </sect3>

      <sect3>
	<title>Konfiguration bei Verwendung von BOOTP</title>

	<indexterm>
	  <primary>BOOTP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

	<para>Es folgt nun eine der Konfiguration von DHCP
	  entsprechende Konfiguration (f&uuml;r einen Client) f&uuml;r
	  <application>bootpd</application>.  Zu finden ist die
	  Konfigurationsdatei unter <filename>/etc/bootptab</filename>.
	</para>

	<para>Beachten Sie bitte, dass
	  <application>etherboot</application> mit der Option
	  <literal>NO_DHCP_SUPPORT</literal> kompiliert werden muss,
	  damit BOOTP verwendet werden kann.  <acronym>PXE</acronym>
	  hingegen <emphasis>ben&ouml;tigt</emphasis>
	  <acronym>DHCP</acronym>.  Der einzige offensichtliche
	  Vorteil von <application>bootpd</application> ist, dass es
	  bereits im Basissystem vorhanden ist.</para>

	<programlisting>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100</programlisting>
      </sect3>

      <sect3>
        <title>Ein Startprogramm unter Verwendung von
          <application>Etherboot</application> erstellen</title>

        <indexterm>
          <primary>Etherboot</primary>
        </indexterm>

	<para>Die <ulink url="http://etherboot.sourceforge.net">
	  Internetseite von Etherboot</ulink> enth&auml;lt
	  <ulink url="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
          ausf&uuml;hrliche Informationen</ulink>, die zwar vor allem
          f&uuml;r Linux gedacht sind, aber dennoch n&uuml;tzliche
          Informationen enthalten.  Im Folgenden wird daher nur grob
          beschrieben, wie Sie <application>etherboot</application> auf
          einem FreeBSD-System einsetzen k&ouml;nnen.</para>

        <para>Als Erstes m&uuml;ssen Sie
          <filename role="package">net/etherboot</filename> als Paket
          oder als Port installieren.  Der Port
          <application>etherboot</application> befindet sich unter
          <filename>/usr/ports/net/etherboot</filename>.  Wenn Sie
          die Portssammlung installiert haben, reicht es aus, in dieses
          Verzeichnis zu wechseln, und <command>make install</command>
	  aufzurufen.  Alles Weitere sollte automatisch ablaufen.  Ist
	  dies nicht der Fall, lesen Sie bitte <xref linkend="ports">,
	  das Informationen zu Ports und Paketen enth&auml;lt.</para>

	<para>Sie k&ouml;nnen <application>etherboot</application> so
	  konfigurieren, dass <acronym>TFTP</acronym> anstelle von
	  <acronym>NFS</acronym> verwendet wird, indem Sie die Datei
	  <filename>Config</filename> im Quellverzeichnis von
	  <application>etherboot</application> bearbeiten.</para>

        <para>F&uuml;r unsere Installation verwenden wir eine
          Startdiskette.  F&uuml;r Informationen zu anderen Methoden
	  (PROM oder &ms-dos;-Programme) lesen Sie bitte die
	  Dokumentation zu <application>etherboot</application>.</para>

        <para>Um eine Startdiskette zu erzeugen, legen Sie eine Diskette
          in das Laufwerk des Rechners ein, auf dem Sie
          <application>etherboot</application> installiert haben.  Danach
          wechseln Sie in das Verzeichnis <filename>src</filename> des
          <application>etherboot</application>-Verzeichnisbaums und geben
          Folgendes ein:</para>

	<screen>&prompt.root; <userinput>gmake bin32/<replaceable>devicetype</replaceable>.fd0</userinput></screen>

        <para><replaceable>devicetype</replaceable> h&auml;ngt vom Typ
          der Ethernetkarte ab, &uuml;ber die der plattenlose Rechner
          verf&uuml;gt.  Lesen Sie dazu <filename>NIC</filename> im
          gleichen Verzeichnis, um den richtigen Wert f&uuml;r
        <replaceable>devicetype</replaceable> zu bestimmen.</para>
      </sect3>

      <sect3>
	<title>Das System mit <acronym>PXE</acronym> starten</title>

	<para>In der Voreinstellung l&auml;dt der
	  &man.pxeboot.8;-Loader den Kernel &uuml;ber
	  <acronym>NFS</acronym>.  Soll stattdessen
	  <acronym>TFTP</acronym> verwendet werden, muss beim
	  Kompilieren die Option
	  <literal>LOADER_TFTP_SUPPORT</literal> in der Datei
	  <filename>/etc/make.conf</filename> eingetragen sein. Sehen
	  Sie sich die Dateien
	  <filename>/etc/defaults/make.conf</filename> (oder
	  <filename>/usr/share/examples/etc/make.conf</filename>
	  f&uuml;r 5.X-Systeme) f&uuml;r weitere Anweisungen an.</para>

	<para>Es gibt zwei nicht dokumentierte Optionen f&uuml;r
	  <filename>make.conf</filename>, die n&uuml;tzlich sein
	  k&ouml;nnen, wenn Sie eine plattenlose serielle Konsole
	  einrichten wollen:
	  <literal>BOOT_PXELDR_PROBE_KEYBOARD</literal>, und
	  <literal>BOOT_PXELDR_ALWAYS_SERIAL</literal> (die zweite
	  Option existiert nur unter &os;&nbsp;5.X).</para>

	<para>Um <acronym>PXE</acronym> beim Systemstart zu verwenden,
	  m&uuml;ssen Sie im <acronym>BIOS</acronym> des Rechner die
	  Option <literal>&Uuml;ber das Netzwerk starten</literal>
	  aktivieren.  Alternativ k&ouml;nnen Sie w&auml;hrend der
	  PC-Initialisierung auch eine Funktionstaste dr&uuml;cken.
	</para>
      </sect3>

      <sect3>
	<title>Serverkonfiguration - <acronym>TFTP</acronym> und
	  <acronym>NFS</acronym></title>

        <indexterm>
          <primary>TFTP</primary>
          <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <indexterm>
          <primary>NFS</primary>
          <secondary>plattenloser Betrieb</secondary>
        </indexterm>

	<para>Wenn Sie <acronym>PXE</acronym> oder
	  <application>etherboot</application> so konfiguriert haben,
	  dass diese <acronym>TFTP</acronym> verwenden, m&uuml;ssen
	  Sie auf dem Dateiserver <application>tftpd</application>
	  aktivieren:</para>

        <procedure>
          <step>
            <para>Erzeugen Sie ein Verzeichnis, in dem
	      <application>tftpd</application> seine Dateien ablegt,
              beispielsweise <filename>/tftpboot</filename>.</para>
          </step>

          <step>
            <para>F&uuml;gen Sie folgende Zeile in
              <filename>/etc/inetd.conf</filename> ein:</para>

            <programlisting>tftp    dgram   udp     wait    root  /usr/libexec/tftpd    tftpd -s /tftpboot</programlisting>

            <note><para>Anscheinend ben&ouml;tigen zumindest einige
	      <acronym>PXE</acronym>-Versionen die
	      <acronym>TCP</acronym>-Version von
	      <acronym>TFTP</acronym>.  Sollte dies bei Ihnen der
              Fall sein, f&uuml;gen Sie eine zweite Zeile ein, in der
              Sie <literal>dgram udp</literal> durch
              <literal>stream tcp</literal> ersetzen.</para>
            </note>
          </step>

          <step>
	    <para>Weisen Sie <application>inetd</application> an, seine
              Konfiguration erneut einzulesen:</para>

            <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
          </step>
        </procedure>

        <para>Sie k&ouml;nnen das Verzeichnis
          <filename>/tftpboot</filename> an einem beliebigen Ort auf dem
          Server ablegen.  Stellen Sie aber sicher, dass Sie diesen Ort
          sowohl in <filename>inetd.conf</filename> als auch in
	  <filename>dhcpd.conf</filename> eingetragen haben.</para>

        <para>Au&szlig;erdem m&uuml;ssen Sie NFS aktivieren und die
          entsprechenden Verzeichnisse exportieren.</para>

        <procedure>
          <step>
            <para>F&uuml;gen Sie folgende Zeile in
              <filename>/etc/rc.conf</filename> ein:</para>

            <programlisting>nfs_server_enable="YES"</programlisting>
          </step>

          <step>
            <para>Exportieren Sie das Verzeichnis, in dem sich das
              Wurzelverzeichnis f&uuml;r den plattenlosen Betrieb
              befindet, indem Sie folgende Zeile in
              <filename>/etc/exports</filename> einf&uuml;gen (passen
	      Sie dabei den <foreignphrase>mountpoint</foreignphrase>
	      an und ersetzen Sie
	      <replaceable>margaux corbieres</replaceable> durch den
	      Namen Ihres plattenlosen Rechners):</para>

            <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux</replaceable></programlisting>
          </step>

          <step>
	    <para>Weisen sie nun <application>mountd</application> an,
	      seine Konfigurationsdatei erneut einzulesen.  Wenn Sie
	      <acronym>NFS</acronym> erst in der Datei
	      <filename>/etc/rc.conf</filename> aktivieren mussten,
              sollten Sie stattdessen den Rechner neu starten.  Dadurch
              wird die Konfigurationsdatei ebenfalls neu eingelesen.
            </para>

            <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>
          </step>
        </procedure>
      </sect3>

      <sect3>
        <title>Einen plattenlosen Kernel erzeugen</title>

        <indexterm>
          <primary>plattenloser Betrieb</primary>
          <secondary>Kernelkonfiguration</secondary>
        </indexterm>

	<para>Wenn Sie <application>etherboot</application> verwenden,
	  m&uuml;ssen Sie in die Kernelkonfigurationsdatei Ihres
	  plattenlosen Clients zus&auml;tzlich folgende Optionen
	  einf&uuml;gen:</para>

        <programlisting>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info</programlisting>

        <para>Au&szlig;erdem k&ouml;nnen Sie die Optionen
	  <literal>BOOTP_NFSV3</literal>,
	  <literal>BOOT_COMPAT</literal> sowie
          <literal>BOOTP_WIRED_TO</literal> verwenden (sehen Sie sich
	  dazu auch <filename>LINT</filename> unter 4.X oder
	  <filename>NOTES</filename> unter 5.X an).</para>

	 <para>Die Namen dieser Optionen sind historisch bedingt.
	   Sie erm&ouml;glichen eine unterschiedliche Verwendung von
	   <acronym>DHCP</acronym> und BOOTP innerhalb des Kernels.
	   Es ist auch m&ouml;glich, eine strikte Verwendung von BOOTP
	   oder <acronym>DHCP</acronym> zu erzwingen.</para>

        <para>Erzeugen Sie den neuen Kernel (lesen Sie dazu auch
	  <xref linkend="kernelconfig">) und kopieren Sie ihn an den
	  in <filename>dhcpd.conf</filename> festgelegten Ort.</para>

	<note><para>Wenn Sie <acronym>PXE</acronym> verwenden, ist die
	    Erzeugung eines Kernels zwar nicht unbedingt n&ouml;tig, sie
	    wird allerdings dennoch empfohlen.  Die Aktivierung dieser
	    Optionen bewirkt, dass die Anzahl der m&ouml;glichen
	    <acronym>DHCP</acronym>-Anforderungen w&auml;hrend des
	    Kernelstarts erh&ouml;ht wird.  Ein kleiner Nachteil sind
	    eventuell auftretende Inkonsistenzen zwischen den neuen
	    Werten und den von &man.pxeboot.8; erhaltenen Werten.  Der
	    gro&szlig;e Vorteil dieser Variante ist es, dass dabei der
	    Rechnername gesetzt wird, den Sie ansonsten durch eine
	    andere Methode, beispielsweise in einer clientspezifischen
	    <filename>rc.conf</filename>-Datei festlegen m&uuml;ssten.
	  <para>
	</note>

	<note><para>Damit ein 5.X-Kernel von
	    <application>etherboot</application> geladen werden kann,
	    m&uuml;ssen <foreignphrase>device hints</foreignphrase> im
	    Kernel einkompiliert sein.  Dazu setzen Sie normalerweise
	    folgende Option in die Kernelkonfigurationsdatei (sehen Sie
	    sich dazu auch die kommentierte Datei
	    <filename>NOTES</filename> an):</para>

	  <programlisting>hints         "GENERIC.hints"</programlisting>
	</note>
      </sect3>

      <sect3>
        <title>Das root-Dateisystem erzeugen</title>

        <indexterm>
          <primary>Root-Dateisystem</primary>
	  <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <para>Sie m&uuml;ssen f&uuml;r den plattenlosen Rechner ein
          root-Dateisystem erzeugen, und zwar an dem in
          <filename>dhcpd.conf</filename> als
	  <literal>root-path</literal> festgelegten Ort.  Der
	  folgende Abschnitt beschreibt zwei M&ouml;glichkeiten, dies
	  zu tun.</para>

	<sect4>
	  <title>Das Skript <filename>clone_root</filename>
	    verwenden</title>

	  <para>Die Verwendung dieses Skripts ist der schnellste Weg,
	    der allerdings nur unter &os;&nbsp;4.X funktioniert.  Das
	    Shellskript findet sich unter
	    <filename>/usr/share/examples/diskless/clone_root</filename>
	    und muss von Ihnen angepasst werden.  Unbedingt n&ouml;tig
	    ist der Ort, an dem das Dateisystem erzeugt werden soll.
	    Dazu setzen Sie die Variable <literal>DEST</literal>
	    entsprechend.</para>

	  <para>Die Kommentare am Anfang des Skripts enthalten
	    weitere Informationen.  Dort wird erkl&auml;rt, wie das
	    Basisdateisystem erzeugt wird und wie einzelne Dateien durch
	    angepasste Versionen f&uuml;r den plattenlosen Betrieb,
	    f&uuml;r ein Subnetzwerk oder f&uuml;r einen speziellen
	    Rechner ersetzt werden.  Ebenfalls enthalten sind Beispiele
	    f&uuml;r <filename>/etc/fstab</filename> und
	    <filename>/etc/rc.conf</filename>, die f&uuml;r den
	    plattenlosen Betrieb angepasst sind.</para>

	  <para>Die <filename>README</filename>-Dateien unter
	    <filename>/usr/share/examples/diskless</filename> enthalten
	    sehr viele interessante Hintergrundinformationen.  Gemeinsam
	    mit den Beispielen im Verzeichnis
	    <filename>diskless</filename> beschreiben sie allerdings
	    eine Konfigurationsmethode, die von
	    der in <filename>clone_root</filename> und den
	    Systemstartskripten unter
	    <filename role="directory">/etc</filename> abweicht.  Dies
	    kann etwas verwirrend sein.  Verwenden Sie diese Dateien
	    also nur zu Informationszwecken.  Es sei denn, Sie wollen
	    die dort beschriebene Methode verwenden.  In diesem Fall
	    m&uuml;ssen Sie allerdings die
	    <filename>rc</filename>-Skripte anpassen.</para>
	</sect4>

	<sect4>
	  <title>Die Standardprozedur <command>make world</command>
	    verwenden</title>

	  <para>Diese Methode funktioniert sowohl unter &os;&nbsp;4.X
	    als auch unter 5.X und installiert ein komplettes
	    <quote>jungfr&auml;uliches</quote> System (und nicht nur ein
	    root-Dateisystem) nach <envar>DESTDIR</envar>.  Dazu
	    m&uuml;ssen Sie lediglich das folgende Skript
	    ausf&uuml;hren:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make world && make kernel
cd /usr/src/etc; make distribution</programlisting>

	  <para>Danach m&uuml;ssen Sie noch die dadurch in
	    <envar>DESTDIR</envar> erzeugten Dateien
	    <filename>/etc/rc.conf</filename> sowie
	    <filename>/etc/fstab</filename> Ihren W&uuml;nschen
	    anpassen.</para>
	</sect4>
      </sect3>

      <sect3>
        <title>Den Auslagerungsbereich konfigurieren</title>

	<para>Falls n&ouml;tig, kann eine auf dem
	  <acronym>NFS</acronym>-Server liegende Datei als
	  Auslagerungsdatei eingerichtet werden.  Dazu
	  m&uuml;ssen Sie auf 4.X und 5.X-Systemen
	  unterschiedlich vorgehen.</para>

	<sect4>
	  <title>Eine <acronym>NFS</acronym>-Auslagerungsdatei unter
	    &os;&nbsp;4.X einrichten</title>

	  <para>Gr&ouml;&szlig;e und Ort der Auslagerungsdatei werden
	    durch die &os;-spezifischen
	    BOOTP/<acronym>DHCP</acronym>-Optionen 128 und 129
	    festgelegt.  Es folgen nun einige Beispielkonfigurationen
	    f&uuml;r <application>ISC DHCP 3.0</application> sowie
	    <application>bootpd</application>:</para>

	  <procedure>
	    <step><para>F&uuml;gen Sie folgende Zeilen in
	      <filename>dhcpd.conf</filename> ein:</para>

	      <programlisting># Global section
option swap-path code 128 = string;
option swap-size code 129 = integer 32;

host margaux {
  ... # Standard lines, see above
  option swap-path <replaceable>"192.168.4.4:/netswapvolume/netswap"</replaceable>;
  option swap-size <replaceable>64000</replaceable>;
}</programlisting>

	      <para><literal>swap-path</literal> legt den Pfad zum
	        Verzeichnis der Auslagerungsdatei fest.  Jede Datei hat
	        den Namen
	        <filename>swap.<replaceable>client-ip</replaceable></filename>.
	      </para>

	      <para>&Auml;ltere
	        <application>dhcpd</application>-Versionen benutzen die
	        Syntax <literal>option option-128 "...</literal>, die
	        aber nicht mehr unterst&uuml;tzt wird.</para>

	      <para><filename>/etc/bootptab</filename> w&uuml;rde
	        stattdessen folgende Syntax verwenden:</para>

	      <programlisting>T128="192.168.4.4:/netswapvolume/netswap":T129=0000fa00</programlisting>

	      <note><para>Die Gr&ouml;&szlig;e der Auslagerungsdatei
	        wird in <filename>/etc/bootptab</filename> als
	        Hexadezimalzahl festgelegt.</para></note>
	    </step>

	    <step>
	      <para>Erzeugen Sie die Auslagerungsdatei(en) auf dem
	        <acronym>NFS</acronym>-Dateiserver:</para>

	      <screen>&prompt.root; <userinput>mkdir <replaceable>/netswapvolume/netswap</replaceable></userinput>
&prompt.root; <userinput>cd <replaceable>/netswapvolume/netswap</replaceable></userinput>
&prompt.root; <userinput>dd if=/dev/zero bs=1024 count=<replaceable>64000</replaceable> of=swap.<replaceable>192.168.4.6</replaceable></userinput>
&prompt.root; <userinput>chmod 0600 swap.<replaceable>192.168.4.6</replaceable></userinput></screen>

	      <para>Bei <replaceable>192.168.4.6</replaceable> handelt
	        es sich um die IP-Adresse des plattenlosen Clients.
	      </para>
	    </step>

	    <step>
	      <para>F&uuml;gen Sie auf dem
	        <acronym>NFS</acronym>-Dateiserver folgende Zeile in
	        <filename>/etc/exports</filename> ein:</para>

	        <programlisting><replaceable>/netswapvolume</replaceable>  -maproot=0:10 -alldirs <replaceable>margaux corbieres</replaceable></programlisting>

	      <para>Zuletzt weisen Sie <application>mountd</application>
	        erneut an, die Exportdateien neu einzulesen.</para>
	    </step>
	  </procedure>
	</sect4>

	<sect4>
	  <title>Eine <acronym>NFS</acronym>-Auslagerungsdatei unter
	     &os;&nbsp;5.X einrichten</title>

	  <para>Der Kernel unterst&uuml;tzt beim Systemstart keine
	    <acronym>NFS</acronym>-Auslagerungsdatei.  Diese muss daher
	    in den Startskripten aktiviert werden, indem ein
	    beschreibbares Dateisystem eingeh&auml;ngt wird, um dort
	    die Auslagerungsdatei zu erzeugen und zu aktivieren.  Um
	    eine Auslagerungsdatei zu erzeugen, gehen Sie wie folgt
	    vor:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/path/to/swapfile</replaceable> bs=1k count=1 oseek=<replaceable>100000</replaceable></userinput></screen>

	  <para>Um die Auslagerungsdatei zu aktivieren, f&uuml;gen Sie
	    folgende Zeile in <filename>rc.conf</filename> ein:</para>

	  <programlisting>swapfile=<replaceable>/path/to/swapfile</replaceable></programlisting>
	</sect4>
      </sect3>

      <sect3>
        <title>Verschiedenes</title>

        <sect4>
          <title>Schreibgesch&uuml;tztes Dateisystem
	    <filename>/usr</filename></title>

          <indexterm>
            <primary>plattenloser Betrieb</primary>
            <secondary>/usr schreibgesch&uuml;tzt</secondary>
          </indexterm>

          <para>Wenn am plattenlosen Rechner X l&auml;uft, m&uuml;ssen
            Sie die Konfigurationsdatei von <filename>xdm</filename>
	    anpassen, da Fehlermeldungen in der Voreinstellung auf
            <filename>/usr</filename> geschrieben werden.</para>
        </sect4>

        <sect4>
          <title>Der Server l&auml;uft nicht unter FreeBSD</title>

	  <para>Wenn das root-Dateisystem nicht auf einem
	    FreeBSD-Rechner liegt, muss das Dateisystem zuerst unter
	    FreeBSD erzeugt werden.  Anschlie&szlig;end wird es
	    beispielsweise mit <command>tar</command> oder
	    <command>cpio</command> an den gew&uuml;nschten Ort
	    kopiert.</para>

	  <para>Dabei kann es Probleme mit den Ger&auml;tedateien
	    in <filename>/dev</filename> geben, die durch eine
	    unterschiedliche Darstellung der  Major- und Minor-Number
	    von Ger&auml;ten auf beiden Systemen hervorgerufen werden.
	    Eine Probleml&ouml;sung besteht darin, das root-Verzeichnis
	    auf einem FreeBSD-Rechner einzuh&auml;ngen und die
	    Ger&auml;tedateien dort mit <command>MAKEDEV</command>
	    zu erzeugen (seit FreeBSD&nbsp;5.0 werden Ger&auml;tedateien
	    allerdings mit &man.devfs.5; erzeugt, ein Ausf&uuml;hren von
	    <command>MAKEDEV</command> ist unter diesen Versionen
	    daher sinnlos).</para>
        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-isdn">
    <title>ISDN &ndash; diensteintegrierendes digitales Netzwerk</title>

    <indexterm>
      <primary>ISDN</primary>
    </indexterm>

    <para>Eine gute Quelle f&uuml;r Informationen zu ISDN ist die
      <ulink url="http://www.alumni.caltech.edu/~dank/isdn/">
      ISDN-Seite</ulink> von Dan Kegel.</para>

    <para>Welche Informationen finden Sie in diesem Abschnitt?</para>

    <itemizedlist>
      <listitem>
        <para>Wenn Sie in Europa leben, k&ouml;nnte der Abschnitt
          &uuml;ber ISDN-Karten f&uuml;r Sie interessant sein.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie ISDN haupts&auml;chlich dazu verwenden wollen, um
          sich &uuml;ber einen Anbieter ins Internet einzuw&auml;hlen,
          sollten Sie den Abschnitt &uuml;ber Terminaladapter lesen.
          Dies ist die flexibelste Methode, die auch die wenigsten
          Probleme verursacht.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie zwei Netzwerke miteinander verbinden, oder sich
          &uuml;ber eine ISDN-Standleitung mit dem Internet verbinden
          wollen, finden Sie entsprechende Informationen im Abschnitt
          &uuml;ber Router und Bridges.</para>
      </listitem>
    </itemizedlist>

    <para>Bei der Wahl der gew&uuml;nschten L&ouml;sung sind die
      entstehenden Kosten ein entscheidender Faktor.  Die folgenden
      Beschreibungen reichen von der billigsten bis zur teuersten
      Variante.</para>

    <sect2 id="network-isdn-cards">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Hellmuth</firstname>
            <surname>Michaelis</surname>
            <contrib>Beigetragen von </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>ISDN-Karten</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Karten</secondary>
      </indexterm>

      <para>Das ISDN-Subsystem von FreeBSD unterst&uuml;tzt den
        DSS1/Q.931- (oder Euro-ISDN)-Standard nur f&uuml;r passive
	Karten.  Seit FreeBSD&nbsp;4.4 werden auch einige
        aktive Karten unterst&uuml;tzt, bei denen die Firmware auch
        andere Signalprotokolle unterst&uuml;tzt;  dies schlie&szlig;t
        auch die erste ISDN-Karte mit
        Prim&auml;rmultiplex-Unterst&uuml;tzung mit ein.</para>

      <para><application>isdn4bsd</application> erm&ouml;glicht es
	Ihnen, sich unter Nutzung von
	<emphasis>IP over raw HDLC</emphasis> oder
        <emphasis>synchronem PPP</emphasis> mit anderen ISDN-Routern zu
        verbinden.  Dazu verwenden Sie entweder Kernel-&man.ppp.8;
	(via <literal>isppp</literal>, einem modifizierten
	sppp-Treiber), oder Sie benutzen User-&man.ppp.8;.  Wenn Sie
	User-&man.ppp.8; verwenden, k&ouml;nnen Sie zwei oder mehrere
	ISDN-B-Kan&auml;le b&uuml;ndeln.  Im Paket enthalten ist auch
	ein Programm mit Anrufbeantworterfunktion sowie verschiedene
	Werkzeuge, wie ein Softwaremodem, das 300&nbsp;Baud
	unterst&uuml;tzt.</para>

      <para>FreeBSD unterst&uuml;tzt eine st&auml;ndig wachsende Anzahl
        von PC-ISDN-Karten, die weltweit erfolgreich eingesetzt werden.
      </para>

      <para>Von FreeBSD unterst&uuml;tzte passive ISDN-Karten enthalten
        fast immer den ISAC/HSCX/IPAC ISDN-Chipsatz von Infineon
        (ehemals Siemens).  Unterst&uuml;tzt werden aber auch Karten mit
        Cologne Chip (diese allerdings nur f&uuml;r den ISA-Bus),
        PCI-Karten mit Winbond W6692 Chipsatz, einige Karten mit dem
        Tiger 300/320/ISAC Chipsatz sowie einige Karten mit einem
        herstellerspezifischen Chipsatz, wie beispielsweise die
        Fritz!Card PCI V.1.0 und die Fritz!Card PnP von AVM.</para>

      <para>An aktiven ISDN-Karten werden derzeit die AVM B1 BRI-Karten
        (ISA und PCI-Version) sowie die AVM T1 PRI-Karten (PCI-Version)
        unterst&uuml;tzt.</para>

      <para>Informationen zu <application>isdn4bsd</application> finden
	Sie im Verzeichnis
	<filename>/usr/share/examples/isdn/</filename> Ihres
	FreeBSD-Systems, oder auf der
        <ulink url="http://www.freebsd-support.de/i4b/">Internetseite</ulink>
        von <application>isdn4bsd</application>.  Dort finden Sie auch
        Verweise zu Tipps, Korrekturen, sowie weiteren Informationen,
        wie dem
        <ulink url="http://people.FreeBSD.org/~hm/">isdn4bsd-Handbuch</ulink>.
      </para>

      <para>Falls Sie an der Unterst&uuml;tzung eines zus&auml;tzlichen
        ISDN-Protokolls, einer weiteren ISDN-Karte oder an einer anderen
        Erweiterung von <application>isdn4bsd</application> interessiert
        sind, wenden Sie sich bitte an &a.hm;.</para>

      <para>F&uuml;r Fragen zur Installation, Konfiguration und zu
        sonstigen Problemen von <application>isdn4bsd</application> gibt
        es die Mailingliste &a.isdn.name;.</para>
    </sect2>

    <sect2>
      <title>ISDN-Terminaladapter</title>

      <indexterm>
        <primary>Terminaladapter</primary>
      </indexterm>

      <para>Terminaladapter (TA) sind f&uuml;r ISDN, was Modems f&uuml;r
        analoge Telefonleitungen sind.</para>

      <indexterm>
        <primary>Modem</primary>
      </indexterm>

      <para>Die meisten Terminaladapter verwenden den
	Standardbefehlssatz f&uuml;r Modems von Hayes (AT-Kommandos) und
	k&ouml;nnen daher als Modemersatz verwendet werden.</para>

      <para>Ein Terminaladapter funktioniert prinzipiell wie ein Modem,
	allerdings erfolgt der Verbindungsaufbau um einiges schneller.
	Die Konfiguration von <link linkend="ppp">PPP</link> entspricht
	dabei exakt der eines Modems.  Stellen Sie dabei allerdings
	die serielle Geschwindigkeit so hoch wie m&ouml;glich ein.
      </para>

      <indexterm>
        <primary>PPP</primary>
      </indexterm>

      <para>Der Hauptvorteil bei der Verwendung eines Terminaladapters
	zur Verbindung mit einem Internetanbieter ist die
	M&ouml;glichkeit zur Nutzung von dynamischem PPP.  Da
	IP-Adressen immer knapper werden, vergeben die meisten Provider
	keine statischen IP-Adressen mehr.  Die meisten Router
	unterst&uuml;tzen allerdings keine dynamische Zuweisung von
	IP-Adressen.</para>

      <para>Der PPP-Daemon bestimmt die Stabilit&auml;t und
	Eigenschaften der Verbindung, wenn Sie einen Terminaladapter
	verwenden.  Daher k&ouml;nnen Sie unter FreeBSD einfach von
	einer Modemverbindung auf eine ISDN-Verbindung wechseln, wenn
	Sie PPP bereits konfiguriert haben.  Allerdings bedeutet
	dies auch, das bereits bestehende Probleme mit PPP auch unter
	ISDN auftreten werden.</para>

      <para>Wenn Sie an maximaler Stabilit&auml;t interessiert sind,
        verwenden Sie Kernel-<link linkend="ppp">PPP</link>, und
	nicht das <link linkend="userppp">User-PPP</link>.</para>

      <para>Folgende Terminaladapter werden von FreeBSD
	unterst&uuml;tzt:</para>

      <itemizedlist>
        <listitem>
          <para>Motorola BitSurfer und Bitsurfer Pro</para>
        </listitem>

        <listitem>
          <para>Adtran</para>
        </listitem>
      </itemizedlist>

      <para>Die meisten anderen Terminaladapter werden wahrscheinlich
	ebenfalls funktionieren, da die Hersteller von Terminaladaptern
	darauf achten, dass ihre Produkte den Standardbefehlssatz
	m&ouml;glichst gut unterst&uuml;tzen.</para>

      <para>Das wirkliche Problem mit einem externen Terminaladapter ist,
        dass, &auml;hnlich wie bei Modems, eine gute serielle Karte
        eine Grundvoraussetzung ist.</para>

      <para>Sie sollten sich die
        <ulink url="http://www.FreeBSD.org/doc/en_US.ISO8859-1/articles/serial-uart/index.html">
        Anleitung f&uuml;r die Nutzung serieller Ger&auml;te unter
        FreeBSD</ulink> ansehen, wenn Sie detaillierte Informationen
        &uuml;ber serielle Ger&auml;te und die Unterschiede zwischen
	asynchronen und synchronen seriellen Ports ben&ouml;tigen.
      </para>

      <para>Ein Terminaladapter, der an einem (asynchronen)
	seriellen Standardport angeschlossen ist, beschr&auml;nkt
	Sie auf 115,2&nbsp;Kbs.  Dies
        selbst dann, wenn Sie eine Verbindung mit 128&nbsp;Kbs haben.
        Um die volle Leistungsf&auml;higkeit von ISDN (128&nbsp;Kbs)
        nutzen zu k&ouml;nnen, m&uuml;ssen Sie den Terminaladapter
	daher an eine synchrone serielle Karte anschlie&szlig;en.</para>

      <para>Kaufen Sie keinen internen Terminaladapter in der Hoffnung,
        damit das synchron/asynchron-Problem vermeiden zu k&ouml;nnen.
	Interne Terminaladapter haben einen (asynchronen) seriellen
	Standardportchip eingebaut.  Der einzige Vorteil interner
	Terminaladapter ist es, dass Sie ein serielles sowie ein
	Stromkabel weniger ben&ouml;tigen.</para>

      <para>Eine synchrone Karte mit einem Terminaladapter ist
	mindestens so schnell wie ein autonomer ISDN-Router,
	und, in Kombination mit einem einfachen 386-FreeBSD-System,
	wahrscheinlich flexibler.</para>

      <para>Die Entscheidung zwischen synchroner Karte/Terminaladapter
	und einem autonomen ISDN-Router ist beinahe eine religi&ouml;se
        Angelegenheit.  Zu diesem Thema gibt es viele Diskussionen
        in den Mailinglisten.  Suchen Sie in den
        <ulink url="http://www.FreeBSD.org/search/index.html">
        Archiven</ulink> danach, wenn Sie an der kompletten Diskussion
        interessiert sind.</para>
    </sect2>

    <sect2>
      <title>ISDN-Bridges und Router</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Autonome Bridge/Router</secondary>
      </indexterm>

      <para>ISDN-Bridges und Router sind keine Eigenheit von
        FreeBSD oder eines anderen Betriebssystems.  F&uuml;r eine
        vollst&auml;ndigere Beschreibung von Routing und
        Netzwerkkopplungen mit einer Bridge informieren Sie sich
        bitte durch weiterf&uuml;hrende Literatur.</para>

      <para>In diesem Abschnitt werden die Begriffe Router und
        Bridge synonym verwendet.</para>

      <para>ISDN-Router und Bridges werden immer g&uuml;nstiger und
	damit auch immer beliebter.  Ein ISDN-Router ist eine kleine
	Box, die direkt an Ihr lokales Ethernet-Netzwerk angeschlossen
	wird und sich mit einem Router oder einer Bridge verbindet.
	Die eingebaute Software erm&ouml;glicht die Kommunikation
	&uuml;ber PPP oder andere beliebte Protokolle.</para>

      <para>Ein Router erm&ouml;glicht einen deutlich h&ouml;heren
        Datendurchsatz als ein herk&ouml;mmlicher Terminaladapter,
	da er eine vollsynchrone ISDN-Verbindung nutzt.</para>

      <para>Das Hauptproblem mit ISDN-Routern und Bridges ist,
        dass die Zusammenarbeit zwischen Ger&auml;ten verschiedener
        Hersteller nach wie vor ein Problem ist.  Wenn Sie sich auf
        diese Weise mit einem Internetanbieter verbinden wollen,
        kl&auml;ren Sie daher vorher ab, welche Anforderungen Ihre
        Ger&auml;te erf&uuml;llen m&uuml;ssen.</para>

      <para>Eine ISDN-Bridge ist eine einfache und wartungsarme
	L&ouml;sung, zwei Netze, beispielsweise Ihr privates Netz
	und Ihr Firmennetz, miteinander zu verbinden.  Da Sie die
        technische Ausstattung f&uuml;r beide Seiten kaufen m&uuml;ssen,
        ist sichergestellt, dass die Verbindung funktionieren
        wird.</para>

      <para>Um beispielsweise einen privaten Computer oder eine
        Zweigstelle mit dem Hauptnetzwerk zu verbinden, k&ouml;nnte
        folgende Konfiguration verwendet werden:</para>

      <example>
        <title>Kleines Netzwerk (Privatnetz)</title>

        <indexterm>
          <primary>10 base 2</primary>
        </indexterm>

        <para>Das Netzwerk basiert auf der Bustopologie mit 10base2
          Ethernet (<quote>Thinnet</quote>).  Falls n&ouml;tig, stellen
          Sie die Verbindung zwischen Router und Netzwerkkabel mit einem
          AUI/10BT-Transceiver her.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-bus">
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
---Sun Workstation
|
---FreeBSD Rechner
|
---Windows 95
|
Autonomer Router
   |
ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>10Base2 - Ethernet</phrase>
          </textobject>
        </mediaobject>

        <para>Wenn Sie nur einen einzelnen Rechner verbinden wollen,
          k&ouml;nnen Sie auch ein Twisted-Pair-Kabel (Cross-Over)
          verwenden, das direkt an den Router angeschlossen wird.</para>
      </example>

      <example>
        <title>Gro&szlig;es Netzwerk (Firmennetz)</title>

        <indexterm>
          <primary>10 base T</primary>
        </indexterm>

        <para>Dieses Netzwerk basiert auf der Sterntopologie und 10baseT
          Ethernet (<quote>Twisted Pair</quote>).</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-twisted-pair">
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
-------Novell Server
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---Autonomer Router
                |
        ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>ISDN Netzwerkdiagramm</phrase>
          </textobject>
        </mediaobject>
      </example>

      <para>Ein gro&szlig;er Vorteil der meisten Router und Bridges
	ist es, dass man <emphasis>gleichzeitig</emphasis> zwei
	<emphasis>unabh&auml;ngige</emphasis> PPP-Verbindungen
	zu zwei verschiedenen Zielen aufbauen kann.  Diese
        Funktion bieten die meisten Terminaladapter nicht.  Die
        Ausnahme sind spezielle (meist teure) Modelle, die &uuml;ber
        zwei getrennte serielle Ports verf&uuml;gen.  Verwechseln Sie
        dies aber nicht mit Kanalb&uuml;ndelung oder MPP.</para>

      <para>Dies kann sehr n&uuml;tzlich sein, wenn Sie eine
        ISDN-Standleitung in Ihrem B&uuml;ro haben, die sie
        aufteilen wollen, ohne eine zus&auml;tzliche ISDN-Leitung
        zu installieren.  Ein ISDN-Router kann &uuml;ber einen B-Kanal
        (64&nbsp;Kbps) eine dedizierte Verbindung ins Internet aufbauen,
        und gleichzeitig den anderen B-Kanal f&uuml;r eine separate
        Datenverbindung nutzen.  Der zweite B-Kanal kann beispielsweise
        f&uuml;r ein- oder ausgehende Verbindungen verwendet werden.
        Sie k&ouml;nnen ihn aber auch dynamisch mit dem ersten B-Kanal
        b&uuml;ndeln, um Ihre Bandbreite zu erh&ouml;hen.</para>

      <indexterm>
        <primary>IPX/SPX</primary>
      </indexterm>

      <para>Eine Ethernet-Bridge kann Daten nicht nur im IP-Protokoll,
        sondern auch in beliebigen anderen Protokollen versenden.</para>
    </sect2>
  </sect1>

  <sect1 id="network-nis">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Bill</firstname>
          <surname>Swingle</surname>
          <contrib>Beigetragen von </contrib>
         </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Eric</firstname>
          <surname>Ogren</surname>
          <contrib>Erweitert von </contrib>
        </author>

        <author>
          <firstname>Udo</firstname>
          <surname>Erdelhoff</surname>
        </author>
      </authorgroup>
    </sect1info>

    <title>NIS/YP &ndash; Network Information Service</title>

    <sect2>
      <title>Was ist NIS?</title>

      <indexterm><primary>NIS</primary></indexterm>
      <indexterm><primary>Solaris</primary></indexterm>
      <indexterm><primary>HP-UX</primary></indexterm>
      <indexterm><primary>AIX</primary></indexterm>
      <indexterm><primary>Linux</primary></indexterm>
      <indexterm><primary>NetBSD</primary></indexterm>
      <indexterm><primary>OpenBSD</primary></indexterm>

      <para>NIS (Network Information Service) wurde von Sun Microsystems
	entwickelt, um &unix;-Systeme (urspr&uuml;nglich &sunos;)
	zentral verwalten zu k&ouml;nnen.  Mittlerweile hat es sich zu
	einem Industriestandard entwickelt, der von allen wichtigen
	&unix;-Systemen (&solaris;, HP-UX, &aix;, Linux, NetBSD,
	OpenBSD, FreeBSD und anderen) unterst&uuml;tzt wird.</para>

      <indexterm>
        <primary>yellow pages</primary>
          <see>NIS</see>
      </indexterm>

     <para>NIS war urspr&uuml;nglich als
       <emphasis>Yellow Pages</emphasis> bekannt, aus markenrechtlichen
       Gr&uuml;nden wurde der Name aber ge&auml;ndert.  Die alte
       Bezeichnung (sowie die Abk&uuml;rzung YP) wird aber nach wie vor
       h&auml;ufig verwendet.</para>

      <indexterm>
        <primary>NIS</primary>
        <secondary>Dom&auml;nen</secondary>
      </indexterm>

      <para>Bei NIS handelt es sich um ein RPC-basiertes
        Client/Server-System. Eine Gruppe von Rechnern greift dabei
        innerhalb einer NIS-Dom&auml;ne auf gemeinsame
        Konfigurationsdateien zu.  Ein Systemadministrator wird dadurch
        in die Lage versetzt, NIS-Clients mit minimalem Aufwand
        einzurichten, sowie &Auml;nderungen an der Systemkonfiguration
        von einem zentralen Ort aus durchzuf&uuml;hren.</para>

      <indexterm>
        <primary>Windows NT</primary>
      </indexterm>

      <para>Die Funktion entspricht dem Dom&auml;nensystem von
        &windowsnt;; auch wenn sich die interne Umsetzung unterscheidet,
        sind die Basisfunktionen vergleichbar.</para>
    </sect2>

    <sect2>
      <title>Wichtige Prozesse und Begriffe</title>

      <para>Es gibt verschiedene Begriffe und Anwenderprozesse, auf die
        Sie sto&szlig;en werden, wenn Sie NIS unter FreeBSD einrichten,
        egal ob Sie einen Server oder einen Client konfigurieren:</para>

      <indexterm>
        <primary><application>portmap</application></primary>
      </indexterm>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Begriff</entry>

              <entry>Beschreibung</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>NIS-Dom&auml;nenname</entry>

              <entry>Ein NIS-Masterserver sowie alle Clients (inklusive
                der Slaveserver) haben einen NIS-Dom&auml;nennamen.
	        Dieser hat (&auml;hnlich den
	        &windowsnt;-Dom&auml;nennamen) nichts mit DNS zu tun.
	      </entry>
            </row>

            <row>
              <entry>portmap</entry>

              <entry>Muss laufen, damit RPC (Remote Procedure Call, ein
                von NIS verwendetes Netzwerkprotokoll) funktioniert.
                NIS-Server sowie Clients funktionieren ohne
                <command>portmap</command> nicht.</entry>
            </row>

            <row>
              <entry>ypbind</entry>

              <entry><quote>Bindet</quote> einen NIS-Client an seinen
                NIS-Server.  Der Client bezieht den
                NIS-Dom&auml;nennamen vom System und stellt &uuml;ber
                das RPC-Protokoll eine Verbindung zum NIS-Server her.
                <command>ypbind</command> ist der zentrale Bestandteil
                der Client-Server-Kommunikation in einer NIS-Umgebung.
                Wird <command>ypbind</command> auf einem Client beendet,
                ist dieser nicht mehr in der Lage, auf den NIS-Server
                zuzugreifen.</entry>
            </row>

            <row>
              <entry>ypserv</entry>

              <entry>Sollte nur auf dem NIS-Server laufen, da es sich um
                den Serverprozess selbst handelt.  Wenn &man.ypserv.8;
                nicht mehr l&auml;uft, kann der Server nicht mehr auf
                NIS-Anforderungen reagieren (wenn ein Slaveserver
                existiert, kann dieser als Ersatz fungieren).  Einige
	        NIS-Systeme (allerdings nicht das von
                FreeBSD) versuchen allerdings erst gar nicht, sich mit
                einem anderen Server zu verbinden, wenn der bisher
                verwendete Server nicht mehr reagiert.  Die einzige
                L&ouml;sung dieses Problems besteht dann darin, den
                Serverprozess (oder gar den Server selbst) oder den
                <command>ypbind</command>-Prozess auf dem Client neu
                zu starten.</entry>
            </row>

            <row>
             <entry>rpc.yppasswdd</entry>

             <entry>Ein weiterer Prozess, der nur auf dem
               NIS-Masterserver laufen sollte.  Es handelt sich um einen
               Daemonprozess, der es NIS-Clients erm&ouml;glicht, sich
               auf dem NIS-Masterserver anzumelden, um ihr Passwort zu
               &auml;ndern.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <!-- XXX Missing: rpc.ypxfrd (not important, though) May only run
      on the master -->
    </sect2>

    <sect2>
      <title>Wie funktioniert NIS?</title>

      <para>In einer NIS-Umgebung gibt es drei Rechnerarten:
        Masterserver, Slaveserver und Clients.  Server dienen als
        zentraler Speicherort f&uuml;r Rechnerkonfigurationen.
        Masterserver speichern die ma&szlig;gebliche Kopie dieser
        Informationen, w&auml;hrend Slaveserver diese Informationen
        aus Redundanzgr&uuml;nden spiegeln.  Die Clients beziehen
        ihre Informationen immer vom Server.</para>

      <para>Auf diese Art und Weise k&ouml;nnen Informationen aus
        verschiedenen Dateien von mehreren Rechnern gemeinsam
        verwendet werden. <filename>master.passwd</filename>,
        <filename>group</filename>, und <filename>hosts</filename>
        werden oft gemeinsam &uuml;ber NIS verwendet.  Immer, wenn
        ein Prozess auf einem Client auf Informationen zugreifen will,
        die normalerweise in lokalen Dateien vorhanden w&auml;ren,
        wird stattdessen eine Anfrage an den NIS-Server gestellt, an
        den der Client gebunden ist.</para>

      <sect3>
        <title>Arten von NIS-Rechnern</title>

        <itemizedlist>
          <indexterm>
            <primary>NIS</primary>
            <secondary>Masterserver</secondary>
          </indexterm>

          <listitem>
            <para>Ein <emphasis>NIS-Masterserver</emphasis> verwaltet,
              &auml;hnlich einem &windowsnt;-Dom&auml;nencontroller, die
              von allen NIS-Clients gemeinsam verwendeten Dateien.
              <filename>passwd</filename>, <filename>group</filename>,
              sowie verschiedene andere von den Clients verwendete
              Dateien existieren auf dem Masterserver.</para>

            <note><para>Ein Rechner kann auch f&uuml;r mehrere
              NIS-Dom&auml;nen als Masterserver fungieren.  Dieser
              Abschnitt konzentriert sich im Folgenden allerdings auf
              eine relativ kleine NIS-Umgebung.</para></note>
          </listitem>

          <indexterm>
            <primary>NIS</primary>
            <secondary>Slaveserver</secondary>
          </indexterm>

          <listitem>
            <para><emphasis>NIS-Slaveserver</emphasis>. &Auml;hnlich
              einem &windowsnt;-Backupdom&auml;nencontroller, verwalten
              NIS-Slaveserver Kopien der Daten des NIS-Masterservers.
              NIS-Slaveserver bieten die Redundanz, die f&uuml;r
              kritische Umgebungen ben&ouml;tigt wird.  Zus&auml;tzlich
              entlasten Slaveserver den Masterserver:  NIS-Clients
              verbinden sich immer mit dem NIS-Server, der zuerst
	      reagiert.  Dieser Server kann auch ein Slaveserver sein.
	    </para>
          </listitem>

          <indexterm>
            <primary>NIS</primary>
            <secondary>Client</secondary>
          </indexterm>

          <listitem>
            <para><emphasis>NIS-Clients</emphasis>.  NIS-Clients
              identifizieren sich gegen&uuml;ber dem NIS-Server
	      (&auml;hnlich den &windowsnt;-Workstations), um sich am
	      Server anzumelden.</para>
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>

    <sect2>
      <title>NIS/YP konfigurieren</title>

      <para>Dieser Abschnitt beschreibt an Hand eines Beispiels die
        Einrichtung einer NIS-Umgebung.</para>

      <note><para>Es wird dabei davon ausgegangen, dass Sie
        FreeBSD&nbsp;3.3 oder eine aktuellere Version verwenden.
        <emphasis>Wahrscheinlich</emphasis> funktioniert diese Anleitung
        auch f&uuml;r FreeBSD-Versionen ab 3.0, es gibt daf&uuml;r aber
        keine Garantie.</para></note>

      <sect3>
        <title>Planung</title>

        <para>Nehmen wir an, Sie seien der Administrator eines kleinen
          Universit&auml;tsnetzes.  Dieses Netz besteht aus
          f&uuml;nfzehn FreeBSD-Rechnern, f&uuml;r die derzeit keine
          zentrale Verwaltung existiert, jeder Rechner hat also eine
          eigene Version von <filename>/etc/passwd</filename> und
          <filename>/etc/master.passwd</filename>.  Diese Dateien werden
          manuell synchron gehalten; legen Sie einen neuen Benutzer an,
          so muss dies auf allen f&uuml;nfzehn Rechnern manuell
          erledigt werden (unter Verwendung von
          <command>adduser</command>).  Da diese L&ouml;sung sehr
          ineffizient ist, soll das Netzwerk in Zukunft NIS verwenden,
          wobei zwei der Rechner als Server dienen sollen.</para>

        <para>In Zukunft soll das Netz also wie folgt aussehen:</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Rechnername</entry>
                <entry>IP-Adresse</entry>
                <entry>Rechneraufgabe</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><hostid>ellington</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.2</hostid></entry>
                <entry>NIS-Master</entry>
              </row>
              <row>
                <entry><hostid>coltrane</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.3</hostid></entry>
                <entry>NIS-Slave</entry>
              </row>
              <row>
                <entry><hostid>basie</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.4</hostid></entry>
                <entry>Workstation der Fakult&auml;t</entry>
              </row>
              <row>
                <entry><hostid>bird</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.5</hostid></entry>
                <entry>Clientrechner</entry>
              </row>
              <row>
                <entry><hostid>cli[1-11]</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.[6-17]</hostid></entry>
                <entry>Verschiedene andere Clients</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Wenn Sie NIS das erste Mal einrichten, ist es ratsam, sich
          zuerst &uuml;ber die Vorgangsweise Gedanken zu machen.
          Unabh&auml;ngig von der Gr&ouml;&szlig;e Ihres Netzwerks
          m&uuml;ssen Sie stets einige Entscheidungen treffen.</para>

        <sect4>
          <title>Einen NIS-Dom&auml;nennamen w&auml;hlen</title>

          <indexterm>
            <primary>NIS</primary>
            <secondary>Dom&auml;nenname</secondary>
          </indexterm>

          <para>Dies muss nicht der <quote>Domainname</quote> sein.  Es
            handelt sich vielmehr um den <quote>NIS-Domainnamen</quote>.
            Wenn ein Client Informationen anfordert, ist in dieser
            Anforderung der Name der NIS-Dom&auml;ne enthalten.
            Dadurch wei&szlig; jeder Server im Netzwerk, auf welche
            Anforderung er antworten muss.  Stellen Sie sich den
            NIS-Dom&auml;nennamen als den Namen einer Gruppe von
            Rechnern vor, die etwas gemeinsam haben.</para>

          <para>Manchmal wird der Name der Internetdom&auml;ne auch
            f&uuml;r die NIS-Dom&auml;ne verwendet.  Dies ist allerdings
            nicht empfehlenswert, da dies bei der Behebung von Problemen
            verwirrend sein kann.  Der Name der NIS-Dom&auml;ne sollte
            innerhalb Ihres Netzwerks einzigartig sein.  Hilfreich ist
            es, wenn der Name die Gruppe der in ihr zusammengefassten
            Rechner beschreibt.  Die Kunstabteilung von Acme Inc.
            h&auml;tte daher die NIS-Dom&auml;ne
            <quote>acme-art</quote>.  F&uuml;r unser Beispiel verwenden
            wir den NIS-Dom&auml;nennamen
            <emphasis>test-domain</emphasis>.</para>

          <indexterm><primary>SunOS</primary></indexterm>

          <para>Es gibt jedoch auch Betriebssysteme (vor allem &sunos;),
            die als NIS-Dom&auml;nennamen den Name der
            Internetdom&auml;ne verwenden.  Wenn dies f&uuml;r einen
            oder mehrere Rechner Ihres Netzwerks zutrifft,
            <emphasis>m&uuml;ssen</emphasis> Sie den Namen der
            Internetdom&auml;ne als Ihren NIS-Dom&auml;nennamen
            verwenden.</para>
        </sect4>

        <sect4>
          <title>Anforderungen an den Server</title>

          <para>Wenn Sie einen NIS-Server einrichten wollen, m&uuml;ssen
            Sie einige Dinge beachten.  Eine unangenehme Eigenschaft
            von NIS ist die Abh&auml;ngigkeit der Clients vom Server.
            Wenn sich der Client nicht &uuml;ber den Server mit seiner
            NIS-Dom&auml;ne verbinden kann, wird der Rechner oft
            unbenutzbar, da das Fehlen von Benutzer- und
            Gruppeninformationen zum Einfrieren des Clients f&uuml;hrt.
            Daher sollten Sie f&uuml;r den Server einen Rechner
            ausw&auml;hlen, der nicht regelm&auml;&szlig;ig neu
            gestartet werden muss und der nicht f&uuml;r Testversuche
            verwendet wird.  Idealerweise handelt es sich um einen
            alleinstehenden Rechner, dessen einzige Aufgabe es ist, als
            NIS-Server zu dienen.  Wenn Sie ein Netzwerk haben, das
            nicht zu stark ausgelastet ist, ist es auch m&ouml;glich,
            den NIS-Server als weiteren Dienst auf einem anderen Rechner
            laufen zu lassen.  Denken Sie aber daran, dass ein Ausfall
            des NIS-Servers <emphasis>alle</emphasis> NIS-Clients
            betrifft.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>NIS-Server</title>

        <para>Die verbindlichen Kopien aller NIS-Informationen befinden
          sich auf einem einzigen Rechner, dem NIS-Masterserver.  Die
          Datenbanken, in denen die Informationen gespeichert sind,
          bezeichnet man als NIS-Maps.  Unter FreeBSD werden diese
          Maps unter <filename>/var/yp/[domainname]</filename>
          gespeichert, wobei <filename>[domainname]</filename> der
          Name der NIS-Dom&auml;ne ist.  Ein einzelner NIS-Server
          kann gleichzeitig mehrere NIS-Dom&auml;nen verwalten, daher
          k&ouml;nnen auch mehrere Verzeichnisse vorhanden sein.  Jede
          Dom&auml;ne verf&uuml;gt &uuml;ber ein eigenes Verzeichnis
          sowie einen eigenen, von anderen Dom&auml;nen
          unabh&auml;ngigen Satz von NIS-Maps.</para>

        <para>NIS-Master- und Slaveserver verwenden den
          <command>ypserv</command>-Daemon, um NIS-Anfragen zu
          bearbeiten.  <command>ypserv</command> empf&auml;ngt
          eingehende Anfragen der NIS-Clients, ermittelt aus der
          angeforderten Dom&auml;ne und Map einen Pfad zur
          entsprechenden Datenbank, und sendet die angeforderten
          Daten von der Datenbank zum Client.</para>

        <sect4>
          <title>Einen NIS-Masterserver einrichten</title>

          <indexterm>
            <primary>NIS</primary>
            <secondary>Serverkonfiguration</secondary>
          </indexterm>

          <para>Abh&auml;ngig von Ihren Anforderungen ist die
            Einrichtung eines NIS-Masterservers relativ einfach, da
            NIS von FreeBSD bereits in der Standardkonfiguration
            unterst&uuml;tzt wird.  Sie m&uuml;ssen nur folgende
            Zeilen in <filename>/etc/rc.conf</filename> einf&uuml;gen:
          </para>

          <procedure>
            <step>
              <programlisting>nisdomainname="test-domain"</programlisting>

              <para>Diese Zeile setzt den NIS-Dom&auml;nennamen auf
                <emphasis>test-domain</emphasis>, wenn Sie das Netzwerk
                initialisieren (beispielsweise nach einem Systemstart).
              </para>
            </step>

            <step>
              <para><programlisting>nis_server_enable="YES"</programlisting>
                Dadurch werden die NIS-Serverprozesse gestartet.</para>
            </step>

            <step>
              <para><programlisting>nis_yppasswdd_enable="YES"</programlisting>
                Durch diese Zeile wird der
                <command>rpc.yppasswdd</command>-Daemon aktiviert, der,
                wie bereits erw&auml;hnt, die &Auml;nderung von
                NIS-Passw&ouml;rtern von einem Client aus
                erm&ouml;glicht.</para>
            </step>
          </procedure>

          <note>
            <para>In Abh&auml;ngigkeit von Ihrer NIS-Konfiguration
              k&ouml;nnen weitere Eintr&auml;ge erforderlich sein.
	      Weitere Informationen finden Sie im Abschnitt
              <link linkend="nis-server-is-client">NIS-Server, die auch
              als NIS-Clients arbeiten</link>.</para>
          </note>

          <para>Nun m&uuml;ssen Sie nur noch
            <command>/etc/netstart</command> als Superuser
            ausf&uuml;hren, um alles entsprechend Ihren Vorgaben in
            <filename>/etc/rc.conf</filename> einzurichten.</para>
        </sect4>

        <sect4>
          <title>Die NIS-Maps initialisieren</title>

          <indexterm>
            <primary>NIS</primary>
            <secondary>maps</secondary>
          </indexterm>

          <para><emphasis>NIS-Maps</emphasis> sind Datenbanken, die
            sich im Verzeichnis <filename>/var/yp</filename> befinden.
            Sie werden am NIS-Masterserver aus den Konfigurationsdateien
            unter <filename>/etc</filename> erzeugt.  Einzige Ausnahme:
            <filename>/etc/master.passwd</filename>.  Dies ist auch
            sinnvoll, da Sie die Passw&ouml;rter f&uuml;r Ihr
            <username>root</username>- oder andere
            Administratorkonten nicht an alle Server der NIS-Dom&auml;ne
            verteilen wollen.  Bevor Sie also die NIS-Maps des
            Masterservers einrichten, sollten Sie Folgendes tun:</para>

          <screen>&prompt.root; <userinput>cp /etc/master.passwd /var/yp/master.passwd</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>vi master.passwd</userinput></screen>

          <para>Entfernen Sie alle Systemkonten
            (wie <username>bin</username>, <username>tty</username>,
            <username>kmem</username> oder <username>games</username>),
            sowie alle Konten, die Sie nicht an die NIS-Clients
            weitergeben wollen (beispielsweise <username>root</username>
            und alle Konten mit der UID 0 (=Superuser).</para>

          <note><para>Stellen Sie sicher, dass
            <filename>/var/yp/master.passwd</filename> weder von der
            Gruppe noch von der Welt gelesen werden kann (Zugriffsmodus
            600)!  Ist dies nicht der Fall, &auml;ndern Sie dies mit
            <command>chmod</command>.</para></note>

          <indexterm><primary>Tru64 UNIX</primary></indexterm>

          <para>Nun k&ouml;nnen Sie die NIS-Maps initialisieren.
	    FreeBSD verwendet daf&uuml;r das Skript
	    <command>ypinit</command> (lesen Sie dazu auch
	    &man.ypinit.8;).  Dieses Skript ist auf fast allen
	    UNIX-Betriebssystemen verf&uuml;gbar.  Bei
            Digitals Unix/Compaq Tru64 UNIX nennt es sich allerdings
            <command>ypsetup</command>.  Da wir Maps f&uuml;r einen
            NIS-Masterserver erzeugen, verwenden wir
            <command>ypinit</command> mit der Option
            <option>-m</option>.  Nachdem Sie die beschriebenen
            Aktionen durchgef&uuml;hrt haben, erzeugen Sie nun die
            NIS-Maps:</para>

          <screen>ellington&prompt.root; <userinput>ypinit -m test-domain</userinput>
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] <userinput>n</userinput>
Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server   :  ellington
next host to add:  <userinput>coltrane</userinput>
next host to add:  <userinput>^D</userinput>
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] <userinput>y</userinput>

[..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</screen>

          <para>Dadurch erzeugt <command>ypinit</command>
            <filename>/var/yp/Makefile</filename> aus der Datei
            <filename>/var/yp/Makefile.dist</filename>.
            Durch diese Datei wird festgelegt, dass Sie in einer
            NIS-Umgebung mit nur einem Server arbeiten und dass alle
            Clients unter FreeBSD laufen.  Da
            <emphasis>test-domain</emphasis> aber auch &uuml;ber einen
            Slaveserver verf&uuml;gt, m&uuml;ssen Sie
            <filename>/var/yp/Makefile</filename> entsprechend anpassen:
          </para>

          <screen>ellington&prompt.root; <userinput>vi /var/yp/Makefile</userinput></screen>

          <para>Sie sollten die Zeile</para>

          <programlisting>NOPUSH = "True"</programlisting>

          <para>auskommentieren (falls dies nicht bereits der Fall ist).</para>
        </sect4>

        <sect4>
          <title>Einen NIS-Slaveserver einrichten</title>

          <indexterm>
            <primary>NIS</primary>
            <secondary>Slaveserver</secondary>
          </indexterm>

          <para>Ein NIS-Slaveserver ist noch einfacher einzurichten als
            ein Masterserver.  Melden Sie sich am Slaveserver an und
            &auml;ndern Sie <filename>/etc/rc.conf</filename> analog
            zum Masterserver.  Der einzige Unterschied besteht in der
            Verwendung der Option <option>-s</option>, wenn Sie
            <command>ypinit</command> aufrufen.  Die Option
            <option>-s</option> erfordert den Namen des
            NIS-Masterservers, daher sieht unsere Ein- und Ausgabe wie
            folgt aus:</para>

          <screen>coltrane&prompt.root; <userinput>ypinit -s ellington test-domain</userinput>

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  <userinput>n</userinput>

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don't forget to update map ypservers on ellington.</screen>

          <para>Sie sollten nun &uuml;ber das Verzeichnis
            <filename>/var/yp/test-domain</filename> verf&uuml;gen.
            Die Kopien der NIS-Masterserver-Maps sollten sich in diesem
            Verzeichnis befinden.  Allerdings m&uuml;ssen Sie diese
            auch aktuell halten.  Die folgenden Eintr&auml;ge in
            <filename>/etc/crontab</filename> erledigen diese Aufgabe:
          </para>

          <programlisting>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</programlisting>

          <para>Diese zwei Zeilen zwingen den Slaveserver, seine Maps
            mit denen des Masterservers zu synchronisieren.  Diese
            Eintr&auml;ge sind nicht zwingend, da der Masterserver
            versucht, alle &Auml;nderungen seiner NIS-Maps an seine
            Slaveserver weiterzugeben.  Da Passwortinformationen aber
            f&uuml;r vom Server abh&auml;ngige Systeme vital sind, ist
            es eine gute Idee, diese Aktualisierungen zu erzwingen.
            Besonders wichtig ist dies in stark ausgelasteten Netzen,
            in denen Map-Aktualisierungen unvollst&auml;ndig sein
            k&ouml;nnten.</para>

          <para>F&uuml;hren Sie nun <command>/etc/netstart</command>
            auch auf dem Slaveserver aus, um den NIS-Server erneut zu
            starten.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>NIS-Clients</title>

        <para>Ein NIS-Client <literal>bindet</literal> sich unter
          Verwendung des <command>ypbind</command>-Daemons an einen
          NIS-Server.  <command>ypbind</command> pr&uuml;ft die
          Standarddom&auml;ne des Systems (die durch
          <command>domainname</command> gesetzt wird), und beginnt
          RPCs &uuml;ber das lokale Netzwerk zu verteilen (broadcast).
          Diese Anforderungen legen den Namen der Dom&auml;ne fest,
          f&uuml;r die <command>ypbind</command> eine Bindung erzeugen
          will.  Wenn der Server der entsprechenden Dom&auml;ne eine
          solche Anforderung erh&auml;lt, schickt er eine Antwort an
          <command>ypbind</command>.  <command>ybind</command> speichert
          daraufhin die Adresse des Servers.  Wenn mehrere Server
          verf&uuml;gbar sind (beispielsweise ein Master- und mehrere
          Slaveserver), verwendet <command>ypbind</command> die erste
          erhaltene Adresse.  Ab diesem Zeitpunkt richtet der Client alle
          Anfragen an genau diesen Server.  <command>ypbind</command>
          <quote>pingt</quote> den Server gelegentlich an, um
          sicherzustellen, dass der Server funktioniert.  Antwortet der
          Server innerhalb eines bestimmten Zeitraums nicht (Timeout),
          markiert <command>ypbind</command> die Dom&auml;ne als
          ungebunden und beginnt erneut, RPCs &uuml;ber das Netzwerk zu
          verteilen, um einen anderen Server zu finden.</para>

        <sect4>
          <title>Einen NIS-Client konfigurieren</title>

          <indexterm>
            <primary>NIS</primary>
            <secondary>Client konfigurieren</secondary>
          </indexterm>

          <para>Einen FreeBSD-Rechner als NIS-Client einzurichten, ist
            recht einfach.</para>

          <procedure>
            <step>
              <para>F&uuml;gen Sie folgende Zeilen in
                <filename>/etc/rc.conf</filename> ein, um den
                NIS-Dom&auml;nennamen festzulegen, und um
                <command>ypbind</command> bei der Initialisierung des
                Netzwerks zu starten:</para>

              <programlisting>nisdomainname="test-domain"
nis_client_enable="YES"</programlisting>
            </step>

            <step>
              <para>Um alle Passworteintr&auml;ge des NIS-Servers zu
                importieren, l&ouml;schen Sie alle Benutzerkonten in
                <filename>/etc/master.passwd</filename> und f&uuml;gen
                mit <command>vipw</command> folgende Zeile am Ende der
                Datei ein:</para>

              <programlisting>+:::::::::</programlisting>

              <note>
                <para>Diese Zeile legt f&uuml;r alle g&uuml;ltigen
                  Benutzerkonten der NIS-Server-Maps einen Zugang an.
                  Es gibt verschiedene Wege, Ihren NIS-Client durch
                  &Auml;nderung dieser Zeile zu konfigurieren.  Lesen
                  Sie dazu auch den Abschnitt &uuml;ber
                  <link linkend="netgroups">Netzgruppen</link> weiter
                  unten.  Weitere detaillierte Informationen finden Sie
                  im Buch <literal>Managing NFS and NIS</literal> von
                  O'Reilly.</para>
              </note>

              <note>
                <para>Sie sollten zumindest ein lokales Benutzerkonto,
                  das nicht &uuml;ber NIS importiert wird, in Ihrer
                  <filename>/etc/master.passwd</filename> behalten.
                  Dieser Benutzer sollte au&szlig;erdem ein Mitglied der
                  Gruppe <groupname>wheel</groupname> sein.  Wenn es
                  mit NIS Probleme gibt, k&ouml;nnen Sie diesen Zugang
                  verwenden, um sich anzumelden,
                  <username>root</username> zu werden und das Problem
                  zu beheben.</para>
              </note>
            </step>

            <step>
              <para>Um alle m&ouml;glichen Gruppeneintr&auml;ge vom
                NIS-Server zu importieren, f&uuml;gen sie folgende Zeile
                in <filename>/etc/group</filename> ein:</para>

              <programlisting>+:*::</programlisting>
            </step>
          </procedure>

          <para>Nachdem Sie diese Schritte erledigt haben, sollten Sie
            mit <command>ypcat passwd</command> die
            <literal>passwd-Map</literal> des NIS-Server anzeigen
            k&ouml;nnen.
          </para>
        </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Sicherheit unter NIS</title>

      <indexterm>
        <primary>NIS</primary>
        <secondary>Sicherheit</secondary>
      </indexterm>

      <para>Im Allgemeinen kann jeder entfernte Anwender einen RPC an
        &man.ypserv.8; schicken, um den Inhalt Ihrer NIS-Maps abzurufen,
        falls er Ihren NIS-Dom&auml;nennamen kennt.  Um solche
        unautorisierten Transaktionen zu verhindern, unterst&uuml;tzt
        &man.ypserv.8; <literal>securenets</literal>, durch die man den
        Zugriff auf bestimmte Rechner beschr&auml;nken kann.
        &man.ypserv.8; versucht, beim Systemstart die Informationen
        &uuml;ber <literal>securenets</literal> aus der Datei
        <filename>/var/yp/securenets</filename> zu laden.</para>

      <note>
	<para>Die Datei <filename>securenets</filename> kann auch
	  in einem anderen Verzeichnis stehen, das mit der Option
          <option>-p</option> angegeben wird.  Diese Datei
          enth&auml;lt Eintr&auml;ge, die aus einer Netzwerkadresse und
          einer Netzmaske bestehen, die durch Leerzeichen getrennt
          werden.  Kommentarzeilen beginnen mit <quote>#</quote>.
          <filename>/var/yp/securnets</filename> k&ouml;nnte
          beispielsweise so aussehen:</para>
      </note>

      <programlisting># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0</programlisting>

      <para>Wenn &man.ypserv.8; eine Anforderung von einer zu diesen
        Regeln passenden Adresse erh&auml;lt, wird die Anforderung
        bearbeitet.  Gibt es keine passende Regel, wird die
        Anforderung ignoriert und eine Warnmeldung aufgezeichnet.  Wenn
        <filename>/var/yp/securenets</filename> nicht vorhanden ist,
        erlaubt <command>ypserv</command> Verbindungen von jedem Rechner
        aus.</para>

      <para><command>ypserv</command> unterst&uuml;tzt auch das
        <application>tcpwrapper</application>-Paket von Wietse Venema.
        Mit diesem Paket kann der Administrator f&uuml;r
        Zugriffskontrollen die Konfigurationsdateien von
        <application>tcpwrapper</application> anstelle von
        <filename>/var/yp/securenets</filename> verwenden.</para>

      <note>
        <para>W&auml;hrend beide Kontrollmechanismen einige Sicherheit
          gew&auml;hren, beispielsweise durch privilegierte Ports, sind
          sie gegen&uuml;ber <quote>IP spoofing</quote>-Attacken
          verwundbar.  Jeder NIS-Verkehr sollte daher von Ihrer Firewall
          blockiert werden.</para>

        <para>Server, die <filename>/var/yp/securenets</filename>
          verwenden, k&ouml;nnen Schwierigkeiten bei der Anmeldung von
          Clients haben, die ein veraltetes TCP/IP-Subsystem
          besitzen.  Einige dieser TCP/IP-Subsysteme setzen alle
          Rechnerbits auf Null, wenn Sie einen
          <literal>Broadcast</literal> durchf&uuml;hren und/oder
          k&ouml;nnen die Subnetzmaske nicht auslesen, wenn sie die
	  Broadcast-Adresse berechnen.  Einige Probleme k&ouml;nnen
	  durch &Auml;nderungen der Clientkonfiguration behoben werden.
          Andere hingegen lassen sich nur durch das Entfernen des
          betreffenden Rechners aus dem Netzwerk oder den Verzicht auf
          <filename>/var/yp/securenets</filename> umgehen.</para>

        <para>Die Verwendung von <filename>/var/yp/securenets</filename>
          auf einem Server mit einem solch veralteten
          TCP/IP-Subsystem ist eine sehr schlechte Idee, die zu
          einem Verlust der NIS-Funktionalit&auml;t f&uuml;r gro&szlig;e
          Teile Ihres Netzwerks f&uuml;hren kann.</para>

        <indexterm>
          <primary>tcpwrapper</primary>
        </indexterm>

        <para>Die Verwendung von <application>tcpwrapper</application>
          verlangsamt die Reaktion Ihres NIS-Servers.  Diese
          zus&auml;tzliche Reaktionszeit kann in Clientprogrammen zu
          Timeouts f&uuml;hren.  Dies vor allem in Netzwerken, die
          stark ausgelastet sind, oder nur &uuml;ber langsame NIS-Server
          verf&uuml;gen.  Wenn ein oder mehrere Ihrer Clientsysteme
          dieses Problem aufweisen, sollten Sie die betreffenden Clients
          in NIS-Slaveserver umwandeln, und diese an sich selbst binden.
        </para>
      </note>
    </sect2>

    <sect2>
      <title>Bestimmte Benutzer an der Anmeldung hindern</title>

      <indexterm>
        <primary>NIS</primary>
        <secondary>Benutzer blockieren</secondary>
      </indexterm>

      <para>In unserem Labor gibt es den Rechner <hostid>basie</hostid>,
        der nur f&uuml;r Mitarbeiter der Fakult&auml;t bestimmt ist.
        Wir wollen diesen Rechner nicht aus der NIS-Dom&auml;ne
        entfernen, obwohl <filename>passwd</filename> des
        NIS-Masterservers Benutzerkonten sowohl f&uuml;r
        Fakult&auml;tsmitarbeiter als auch f&uuml;r Studenten
        enth&auml;lt.  Was k&ouml;nnen wir also tun?</para>

      <para>Es gibt eine M&ouml;glichkeit, bestimmte Benutzer an der
        Anmeldung an einem bestimmten Rechner zu hindern, selbst wenn
        diese in der NIS-Datenbank vorhanden sind.  Dazu m&uuml;ssen
        Sie lediglich an diesem Rechner den Eintrag
        <emphasis>-<replaceable>Benutzername</replaceable></emphasis> an
        das Ende von <filename>/etc/master.passwd</filename> setzen,
        wobei <replaceable>Benutzername</replaceable> der zu
        blockierende Benutzername ist.  Diese &Auml;nderung sollte
        bevorzugt durch <command>vipw</command> erledigt werden, da
        <command>vipw</command> Ihre &Auml;nderungen an
        <filename>/etc/master.passwd</filename> auf Plausibilit&auml;t
        &uuml;berpr&uuml;ft und nach erfolgter &Auml;nderung die
        Passwortdatenbank automatisch aktualisiert.  Um also den
        Benutzer <emphasis>bill</emphasis> an der Anmeldung am Rechner
        <hostid>basie</hostid> zu hindern, gehen wir wie folgt vor:
      </para>

      <screen>basie&prompt.root; <userinput>vipw</userinput>
<userinput>[add -bill to the end, exit]</userinput>
vipw: rebuilding the database...
vipw: done

basie&prompt.root; <userinput>cat /etc/master.passwd</userinput>

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/share/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
-bill

basie&prompt.root;</screen>
    </sect2>

    <sect2 id="netgroups">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Udo</firstname>
            <surname>Erdelhoff</surname>
            <contrib>Beigetragen von </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Netzgruppen verwenden</title>

      <indexterm><primary>Netzgruppen</primary></indexterm>

      <para>Die im letzten Abschnitt beschriebene Methode eignet sich
        besonders, wenn Sie spezielle Regeln f&uuml;r wenige
        Benutzer oder wenige Rechner ben&ouml;tigen.  In gro&szlig;en
        Netzwerken werden Sie allerdings
        <emphasis>mit Sicherheit</emphasis> vergessen, einige Benutzer
        von der Anmeldung an bestimmten Rechnern auszuschlie&szlig;en.
        Oder Sie werden gezwungen sein, jeden Rechner einzeln zu
        konfigurieren.  Dadurch verlieren Sie aber den Hauptvorteil von
        NIS, die <emphasis>zentrale</emphasis> Verwaltung.</para>

      <para>Die L&ouml;sung f&uuml;r dieses Problem sind
        <emphasis>Netzgruppen</emphasis>.  Ihre Aufgabe und Bedeutung
        ist vergleichbar mit normalen, von UNIX-Dateisystemen
        verwendeten Gruppen.  Die Hauptunterschiede sind das Fehlen
        einer numerischen ID sowie die M&ouml;glichkeit, Netzgruppen
        zu definieren, die sowohl Benutzer als auch andere Netzgruppen
        enthalten.</para>

      <para>Netzgruppen wurden entwickelt, um gro&szlig;e, komplexe
        Netzwerke mit Hunderten Benutzern und Rechnern zu verwalten.
        Sie sind also von Vorteil, wenn Sie von dieser Situation
        betroffen sind.  Andererseits ist es dadurch beinahe
        unm&ouml;glich, Netzgruppen mit einfachen Beispielen zu
        erkl&auml;ren.  Das hier verwendete Beispiel veranschaulicht
        dieses Problem.</para>

      <para>Nehmen wir an, dass Ihre erfolgreiche Einf&uuml;hrung von
        NIS die Aufmerksamkeit Ihrer Vorgesetzten geweckt hat.  Ihre
        n&auml;chste Aufgabe besteht nun darin, Ihre NIS-Dom&auml;ne
        um zus&auml;tzliche Rechner zu erweitern.  Die folgenden
        Tabellen enthalten die neuen Benutzer und Rechner inklusive
        einer kurzen Beschreibung.</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Benutzername(n)</entry>
              <entry>Beschreibung</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>alpha, beta</entry>
              <entry>Besch&auml;ftigte der IT-Abteilung</entry>
            </row>

            <row>
              <entry>charlie, delta</entry>
              <entry>Die neuen Lehrlinge der IT-Abteilung</entry>
            </row>

            <row>
              <entry>echo, foxtrott, golf, ...</entry>
              <entry>Normale Mitarbeiter</entry>
            </row>

            <row>
              <entry>able, baker, ...</entry>
              <entry>Externe Mitarbeiter</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Rechnername(n)</entry>
              <entry>Beschreibung</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <!--  Names taken from "Good Omens" by Neil Gaiman and Terry
                    Pratchett.  Many thanks for a brilliant book.  -->
              <entry>war, death, famine, pollution</entry>
              <entry>Ihre wichtigsten Server.  Nur IT-Fachleute
                d&uuml;rfen sich an diesen Rechnern anmelden.</entry>
            </row>

            <row>
              <!-- gluttony was omitted because it was too fat -->
              <entry>pride, greed, envy, wrath, lust, sloth</entry>
              <entry>Weniger wichtige Server.  Alle Mitarbeiter der
                IT-Abteilung d&uuml;rfen sich auf diesen Rechnern
                anmelden.</entry>
            </row>

            <row>
              <entry>one, two, three, four, ...</entry>
              <entry>Gew&ouml;hnliche Arbeitsrechner.  Nur die
                <emphasis>wirklichen</emphasis> Mitarbeiter d&uuml;rfen
                diese Rechner verwenden.</entry>
            </row>

            <row>
              <entry>trashcan</entry>
              <entry>Ein sehr alter Rechner ohne kritische Daten. Sogar
                externe Mitarbeiter d&uuml;rfen diesen Rechner
                verwenden.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Wollten Sie diese Einschr&auml;nkungen umsetzen, indem Sie
        jeden Benutzer einzeln blockieren, m&uuml;ssten Sie auf jedem
        System f&uuml;r jeden Benutzer eine Zeile in
        <filename>passwd</filename> einf&uuml;gen.  Wenn Sie nur einen
        Eintrag vergessen, haben Sie ein Problem.  Es mag noch angehen,
        dies w&auml;hrend der ersten Installation zu erledigen, im
        t&auml;glichen Betrieb werden Sie allerdings
        <emphasis>mit Sicherheit</emphasis> einmal vergessen, die
        entsprechenden Eintr&auml;ge anzulegen.  Vergessen Sie nicht:
        Murphy war Optimist.</para>

      <para>Die Verwendung von Netzgruppen hat in dieser Situation
        mehrere Vorteile.  Sie m&uuml;ssen nicht jeden Benutzer einzeln
        verwalten;  weisen Sie stattdessen den Benutzer einer Netzgruppe
        zu und erlauben oder verbieten Sie allen Mitglieder dieser
        Gruppe die Anmeldung an einem Server.  Wenn Sie einen neuen
        Rechner hinzuf&uuml;gen, m&uuml;ssen Sie
        Zugangsbeschr&auml;nkungen nur f&uuml;r die Netzgruppen
        festlegen.  Legen Sie einen neuen Benutzer an, m&uuml;ssen Sie
        ihn nur einer oder mehrere Netzgruppen zuweisen.  Diese
        Ver&auml;nderungen sind voneinander unabh&auml;ngig; Anweisungen
        der Form <quote>f&uuml;r diese Kombination aus Benutzer und
        Rechner mache Folgendes ...</quote> sind nicht mehr n&ouml;tig.
        Wenn Sie die Einrichtung von NIS sorgf&auml;ltig geplant haben,
        m&uuml;ssen Sie nur noch eine zentrale Konfigurationsdatei
        bearbeiten, um den Zugriff auf bestimmte Rechner zu erlauben
        oder zu verbieten.</para>

      <para>Der erste Schritt ist die Initialisierung der NIS-Maps
        der Netzgruppe.  &man.ypinit.8; kann dies unter FreeBSD nicht
        automatisch durchf&uuml;hren.  Sind die Maps aber erst einmal
        erzeugt, werden sie jedoch von NIS problemlos unterst&uuml;tzt.
        Um eine leere Map zu erzeugen, geben Sie Folgendes ein:</para>

      <screen>ellington&prompt.root; <userinput>vi /var/yp/netgroup</userinput></screen>

      <para>Danach legen Sie die Eintr&auml;ge an.  F&uuml;r unser
        Beispiel ben&ouml;tigen wir mindestens vier Netzgruppen:
        IT-Besch&auml;ftige, IT-Lehrlinge, normale Besch&auml;ftigte
        sowie Externe.</para>

      <programlisting>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
        (,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</programlisting>

      <para>Bei <literal>IT_EMP</literal>, <literal>IT_APP</literal>
        usw. handelt es sich um Netzgruppennamen.  In den Klammern
        werden diesen Netzgruppen jeweils ein oder mehrere
        Benutzerkonten hinzugef&uuml;gt.  Die drei Felder in der
        Klammer haben folgende Bedeutung:</para>

      <orderedlist>
        <listitem>
          <para>Der Name des Rechners, auf dem die folgenden Werte
            g&uuml;ltig sind.  Legen Sie keinen Rechnernamen fest, ist
            der Eintrag auf allen Rechnern g&uuml;ltig. Dadurch
            gehen Sie vielen Problemen aus dem Weg.</para>
        </listitem>

        <listitem>
          <para>Der Name des Benutzerkontos, der zu dieser Netzgruppe
            geh&ouml;rt.</para>
        </listitem>

        <listitem>
          <para>Die NIS-Dom&auml;ne f&uuml;r das Benutzerkonto.  Sie
            k&ouml;nnen Benutzerkonten von anderen NIS-Dom&auml;nen in
            Ihre Netzgruppe importieren, wenn Sie mehrere
            NIS-Dom&auml;nen verwalten.</para>
        </listitem>
      </orderedlist>

      <para>Jedes Feld kann Wildcards enthalten.  Die Einzelheiten
	entnehmen Sie bitte &man.netgroup.5;.</para>

      <note>
        <indexterm><primary>Netzgruppen</primary></indexterm>

        <para>Netzgruppennamen sollten nicht l&auml;nger als 8 Zeichen
          sein, vor allem dann, wenn Sie Rechner mit verschiedenen
          Betriebssystemen in Ihrer NIS-Dom&auml;ne haben.  Es wird
          zwischen Gro&szlig;- und Kleinschreibung unterschieden.
          Die Verwendung von Gro&szlig;buchstaben f&uuml;r
          Netzgruppennamen erm&ouml;glicht eine leichte Unterscheidung
          zwischen Benutzern, Rechnern und Netzgruppen.</para>

        <para>Einige NIS-Clients (dies gilt nicht f&uuml;r FreeBSD)
          k&ouml;nnen keine Netzgruppen mit einer gro&szlig;en Anzahl
          von Eintr&auml;gen verwalten.  Einige &auml;ltere Versionen
	  von &sunos; haben beispielsweise Probleme, wenn Netzgruppen
	  mehr als f&uuml;nfzehn <emphasis>Eintr&auml;ge</emphasis>
          enthalten.  Sie k&ouml;nnen dieses Problem umgehen, indem Sie
          mehrere Subnetzgruppen mit weniger als f&uuml;nfzehn Benutzern
          anlegen und diese Subnetzgruppen wiederum in einer Netzgruppe
          zusammenfassen:</para>

        <programlisting>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</programlisting>

        <para>Sie k&ouml;nnen diesen Vorgang wiederholen, wenn Sie mehr
          als 255 Benutzer in einer einzigen Netzgruppe ben&ouml;tigen.
        </para>
      </note>

      <para>Das Aktivieren und Verteilen Ihre neuen NIS-Map ist
        einfach:</para>

      <screen>ellington&prompt.root; <userinput>cd /var/yp</userinput>
ellington&prompt.root; <userinput>make</userinput></screen>

      <para>Dadurch werden die NIS-Maps <filename>netgroup</filename>,
        <filename>netgroup.byhost</filename> und
        <filename>netgroup.byuser</filename> erzeugt.  Pr&uuml;fen Sie
        die Verf&uuml;gbarkeit Ihrer neuen NIS-Maps mit &man.ypcat.1;.
      </para>

      <screen>ellington&prompt.user; <userinput>ypcat -k netgroup</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byhost</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byuser</userinput></screen>

      <para>Die Ausgabe des ersten Befehls gibt den Inhalt von
        <filename>/var/yp/netgroup</filename> wieder.  Der zweite Befehl
        erzeugt nur dann eine Ausgabe, wenn Sie rechnerspezifische
        Netzgruppen erzeugt haben.  Der dritte Befehl gibt die
        Netzgruppen nach Benutzern sortiert aus.</para>

      <para>Die Einrichtung der Clients ist einfach.  Sie m&uuml;ssen
        lediglich auf dem Server <replaceable>war</replaceable>
        &man.vipw.8; aufrufen und die Zeile</para>

      <programlisting>+:::::::::</programlisting>

      <para>durch</para>

      <programlisting>+@IT_EMP:::::::::</programlisting>

      <para>ersetzen.</para>

      <para>Ab sofort werden nur noch die Daten der in der Netzgruppe
        <replaceable>IT_EMP</replaceable> vorhandenen Benutzer in die
        Passwortdatenbank von <replaceable>war</replaceable> importiert.
        Nur diese Benutzer d&uuml;rfen sich am Server anmelden.</para>

      <para>Ungl&uuml;cklicherweise gilt diese Einschr&auml;nkung auch
        f&uuml;r die ~-Funktion der Shell und f&uuml;r alle Routinen,
        die auf Benutzernamen und numerische Benutzer-IDs zugreifen.
        Oder anders formuliert,
        <command>cd ~<replaceable>user</replaceable></command> ist nicht
        m&ouml;glich, <command>ls -l</command> zeigt die numerische
        Benutzer-ID statt dem Benutzernamen und
        <command>find . -user joe -print</command> erzeugt die
        Fehlermeldung <errorname>No such user</errorname>.  Um dieses
        Problem zu beheben, m&uuml;ssen Sie alle Benutzereintr&auml;ge
        importieren, <emphasis>ohne ihnen jedoch zu erlauben, sich an
        Ihrem Server anzumelden</emphasis>.</para>

      <para>Dazu f&uuml;gen Sie eine weitere Zeile in
        <filename>/etc/master.passwd</filename> ein.  Diese Zeile sollte
        &auml;hnlich der folgenden aussehen:</para>

      <para><literal>+:::::::::/sbin/nologin</literal>, was in etwa
        <quote>Importiere alle Eintr&auml;ge, aber ersetze die Shell in
        den importierten Eintr&auml;gen durch
        <filename>/sbin/nologin</filename></quote> entspricht.  Sie
        k&ouml;nnen jedes Feld dieses Eintrages ersetzen, indem Sie
        einen Standardwert in <filename>/etc/master.passwd</filename>
        eintragen.</para>

      <warning>
        <para>Stellen Sie sicher, dass die Zeile
        <literal>+:::::::::/sbin/nologin</literal>
        <emphasis>nach</emphasis> der Zeile
        <literal>+@IT_EMP:::::::::</literal> eingetragen ist.  Sonst
        haben alle via NIS importierten Benutzerkonten
        <filename>/sbin/nologin</filename> als Loginshell.</para>
      </warning>

      <para>Danach m&uuml;ssen Sie nur mehr eine einzige NIS-Map
        &auml;ndern, wenn ein neuer Mitarbeiter ber&uuml;cksichtigt
        werden muss.  F&uuml;r weniger wichtige Server gehen Sie analog
        vor, indem Sie den alten Eintrag <literal>+:::::::::</literal>
        in den lokalen Versionen von
        <filename>/etc/master.passwd</filename> durch folgende
        Eintr&auml;ge ersetzen:</para>

      <programlisting>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Die entsprechenden Zeilen f&uuml;r normale Arbeitspl&auml;tze
        lauten:</para>

      <programlisting>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Ab jetzt w&auml;re alles wunderbar, allerdings &auml;ndert
        sich kurz darauf die Firmenpolitik:  Die IT-Abteilung beginnt
        damit, externe Mitarbeiter zu besch&auml;ftigen.  Externe
        d&uuml;rfen sich an normalen Arbeitspl&auml;tzen sowie an den
        weniger wichtigen Servern anmelden.  Die IT-Lehrlinge
        d&uuml;rfen sich nun auch an den Hauptservern anmelden.  Sie
        legen also die neue Netzgruppe IT_INTERN an, weisen Ihr die
        neuen IT-Externen als Benutzer zu und beginnen damit,
        die Konfiguration auf jedem einzelnen Rechner zu &auml;ndern ...
        Halt.  Sie haben gerade die alte Regel <quote>Fehler in der
        zentralisierten Planung f&uuml;hren zu globaler
        Verwirrung.</quote> best&auml;tigt.</para>

      <para>Da NIS in der Lage ist, Netzgruppen aus anderen Netzgruppen
        zu bilden, lassen sich solche Situationen leicht vermeiden.
        Eine M&ouml;glichkeit ist die Erzeugung rollenbasierter
        Netzgruppen.  Sie k&ouml;nnten eine Netzgruppe
        <replaceable>BIGSRV</replaceable> erzeugen, um den Zugang zu
        den wichtigsten Servern zu beschr&auml;nken, eine weitere
        Gruppe <replaceable>SMALLSRV</replaceable> f&uuml;r die weniger
        wichtigen Server und eine dritte Netzgruppe
        <replaceable>USERBOX</replaceable> f&uuml;r die normalen
        Arbeitsplatzrechner.  Jede dieser Netzgruppen enth&auml;lt die
        Netzgruppen, die sich auf diesen Rechnern anmelden d&uuml;rfen.
        Die Eintr&auml;ge der Netzgruppen in der NIS-Map sollten
        &auml;hnlich den folgenden aussehen:</para>

      <programlisting>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</programlisting>

      <para>Diese Methode funktioniert besonders gut, wenn Sie
        Rechner in Gruppen mit identischen Beschr&auml;nkungen einteilen
        k&ouml;nnen.  Ungl&uuml;cklicherweise ist dies die Ausnahme und
        nicht die Regel.  Meistens werden Sie die M&ouml;glichkeit zur
	rechnerspezischen Zugangsbeschr&auml;nkung ben&ouml;tigen.
      </para>

      <para>Rechnerspezifische Netzgruppen sind die zweite
        M&ouml;glichkeit, um mit den oben beschriebenen &Auml;nderungen
        umzugehen.  In diesem Szenario enth&auml;lt
        <filename>/etc/master.passwd</filename> auf jedem Rechner zwei
        mit <quote>+</quote> beginnende Zeilen.  Die erste Zeile
        legt die Netzgruppe mit den Benutzern fest, die sich auf diesem
        Rechner anmelden d&uuml;rfen.  Die zweite Zeile weist allen
        anderen Benutzern <filename>/sbin/nologin</filename> als Shell
        zu.  Verwenden Sie auch hier (analog zu den Netzgruppen)
        Gro&szlig;buchstaben f&uuml;r die Rechnernamen.  Die Zeilen
        sollten also &auml;hnlich den folgenden aussehen:</para>

      <programlisting>+@<replaceable>BOXNAME</replaceable>:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Wenn Sie dies f&uuml;r alle Rechner erledigt haben, werden
        Sie die lokalen Versionen von
        <filename>/etc/master.passwd</filename> nie mehr ver&auml;ndern
        m&uuml;ssen.  Alle weiteren &Auml;nderungen geschehen &uuml;ber
        die NIS-Maps.  Nachfolgend ein Beispiel f&uuml;r eine
        m&ouml;gliche Netzgruppen-Map, die durch einige Besonderheiten
        erweitert wurde:</para>

      <programlisting># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION  BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]
      </programlisting>

      <para>Wenn Sie eine Datenbank verwenden, um Ihre Benutzerkonten zu
        verwalten, sollten Sie den ersten Teil der NIS-Map mit Ihren
        Datenbanktools erstellen k&ouml;nnen.  Auf diese Weise haben
        neue Benutzer automatisch Zugriff auf die Rechner.</para>

      <para>Eine letzte Warnung:  Es ist nicht immer ratsam,
        rechnerbasierte Netzgruppen zu verwenden.  Wenn Sie Dutzende
        oder gar Hunderte identische Rechner einrichten m&uuml;ssen,
        sollten Sie rollenbasierte Netzgruppen verwenden, um die
        Gr&ouml;sse der NIS-Maps in Grenzen zu halten.</para>
    </sect2>

    <sect2>
      <title>Weitere wichtige Punkte</title>

      <para>Nachdem Sie Ihre NIS-Umgebung eingerichtet haben,
        m&uuml;ssen Sie einige Dinge anders als bisher erledigen.</para>

      <itemizedlist>
        <listitem>
          <para>Jedes Mal, wenn Sie einen neuen Benutzer anlegen wollen,
            tun Sie dies <emphasis>ausschlie&szlig;lich</emphasis> am
            NIS-Masterserver.  Au&szlig;erdem
            <emphasis>m&uuml;ssen</emphasis> Sie anschlie&szlig;end die
            NIS-Maps neu erzeugen.  Wenn Sie diesen Punkt vergessen,
            kann sich der neue Benutzer <emphasis>nur</emphasis> am
            NIS-Masterserver anmelden.  Wenn Sie also den neuen Benutzer
	    <quote>jsmith</quote> anlegen, gehen Sie folgerndermassen
	    vor:</para>

          <screen>&prompt.root; <userinput>pw useradd jsmith</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>make test-domain</userinput></screen>

          <para>Statt <command>pw useradd jsmith</command> k&ouml;nnten
            Sie auch <command>adduser jsmith</command> verwenden.</para>
        </listitem>

        <listitem>
          <para><emphasis>Tragen Sie die Administratorkonten nicht
            in die NIS-Maps ein</emphasis>.  Administratorkonten und
            Passw&ouml;rter d&uuml;rfen nicht auf Rechnern verbreitet
            werden, auf denen sich Benutzer anmelden k&ouml;nnen, die
            auf diese Konten keine Zugriff haben sollen.</para>
        </listitem>

        <listitem>
          <para><emphasis>Sichern Sie die NIS-Master- und Slaveserver
            und minimieren Sie die Ausfallzeiten</emphasis>.  Wenn
            diese Rechner gehackt oder einfach nur ausgeschaltet werden,
            haben viele Leute keinen Netzwerkzugriff mehr.</para>

          <para>Dies ist die gr&ouml;&szlig;te Schw&auml;che
            jeder zentralen Verwaltung.  Wenn Sie Ihre NIS-Server nicht
            sch&uuml;tzen, werden Sie viele ver&auml;rgerte Anwender
            haben.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Kompatibilit&auml;t zu NIS v1</title>

      <indexterm>
        <primary>NIS</primary>
        <secondary>Kompatibilit&auml;t zu NIS v1</secondary>
      </indexterm>

      <para><application>ypserv</application> unterst&uuml;tzt NIS v1
        unter FreeBSD nur eingeschr&auml;nkt.  Die NIS-Implementierung
        von FreeBSD verwendet nur NIS v2, andere Implementierungen
        unterst&uuml;tzen aus Gr&uuml;nden der
        Abw&auml;rtskompatibilit&auml;t mit &auml;lteren Systemen auch
        NIS v1.  Die mit diesen Systemen gelieferten
        <application>ypbind</application>-Daemonen versuchen, sich an
        einen NIS-v1-Server zu binden (Dies selbst dann, wenn sie ihn
	nie ben&ouml;tigen.  Au&szlig;erdem versuchen Sie auch dann,
	einen v1-Server zu erreichen, wenn Sie zuvor eine Antwort von
	einem v2-Server erhalten.).  W&auml;hrend normale Clientaufrufe
        unter FreeBSD unterst&uuml;tzt werden, sind Anforderungen zum
        Transfer von v1-Maps nicht m&ouml;glich.  Daher kann FreeBSD
        nicht als Client oder Server verwendet werden, wenn ein
        NIS-Server vorhanden ist, der nur NIS v1 unterst&uuml;tzt.
        Gl&uuml;cklicherweise sollte es heute keine Server mehr geben,
        die nur NIS v1 unterst&uuml;tzen.</para>
    </sect2>

    <sect2 id="nis-server-is-client">
      <title>NIS-Server, die auch als NIS-Clients arbeiten</title>

      <para>Wenn Sie ypserv in einer Multi-Serverdom&auml;ne verwenden,
        in der NIS-Server gleichzeitig als NIS-Clients arbeiten, ist es
        eine gute Idee, diese Server zu zwingen, sich an sich selbst zu
        binden.  Damit wird verhindert, dass Bindeanforderungen gesendet
        werden und sich die Server gegenseitig binden.  Sonst
        k&ouml;nnten seltsame Fehler auftreten, wenn ein Server
        ausf&auml;llt, auf den andere Server angewiesen sind.  Letztlich
        werden alle Clients einen Timeout melden, und versuchen, sich an
        andere Server zu binden.  Die dadurch entstehende
	Verz&ouml;gerung kann betr&auml;chtlich sein.  Au&szlig;erdem
	kann der Fehler erneut auftreten, da sich die Server wiederum
        aneinander binden k&ouml;nnten.</para>

      <para>Sie k&ouml;nnen einen Rechner durch die Verwendung von
        <command>ypbind</command> sowie der Option <option>-S</option>
        zwingen, sich an einen bestimmten Server zu binden.  Um diesen
        Vorgang zu automatisieren, k&ouml;nnen Sie folgende Zeilen in
        <filename>/etc/rc.conf</filename> einf&uuml;gen:</para>

      <programlisting>nis_client_enable="YES"	# run client stuff as well
nis_client_flags="-S <replaceable>NIS domain</replaceable>,<replaceable>server</replaceable>"</programlisting>

      <para>Lesen Sie &man.ypbind.8;, wenn Sie weitere Informationen
        ben&ouml;tigen.</para>
    </sect2>

    <sect2>
      <title>Passwortformate</title>
      <indexterm>
        <primary>NIS</primary>
	<secondary>Passwortformate</secondary>
      </indexterm>
      <para>Unterschiedliche Passwortformate sind das Hauptproblem,
	das beim Einrichten eines NIS-Servers auftreten kann.
	Wenn der NIS-Server mit DES verschl&uuml;sselte Passw&ouml;rter
	verwendet, werden nur Clients unterst&uuml;tzt, die ebenfalls
	DES benutzen.  Wenn sich auf Ihrem Netzwerk beispielsweise
	&solaris; NIS-Clients befinden, m&uuml;ssen die Passw&ouml;rter
	mit DES verschl&uuml;sselt werden.</para>

      <para>Welches Format die Server und Clients verwenden,
	steht in <filename>/etc/login.conf</filename>.  Wenn ein
	System Passw&ouml;rter mit DES verschl&uuml;sselt,
	enth&auml;lt die <literal>default</literal>-Klasse einen
	Eintrag wie den folgenden:</para>

      <programlisting>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[weitere Eintr&auml;ge]</programlisting>

      <para>M&ouml;gliche Werte f&uuml;r
	<literal>passwd_format</literal> sind unter anderem
	<literal>blf</literal> und <literal>md5</literal> (mit
	Blowfish und MD5 verschl&uuml;sselte Passw&ouml;rter).</para>

      <para>Wenn die Datei <filename>/etc/login.conf</filename>
	ge&auml;ndert wird, muss die Login-Capability Datenbank
	neu erstellt werden.  Geben Sie dazu als
	<username>root</username> den folgenden Befehl ein:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>

      <note>
	<para>Das Format der schon in
	  <filename>/etc/master.passwd</filename> befindlichen
	  Passw&ouml;rter wird erst aktualisiert, wenn ein Benutzer
	  sein Passwort &auml;ndert, <emphasis>nachdem</emphasis>
	  die Datenbank neu erstellt wurde.</para>
      </note>

      <para>Damit die Passw&ouml;rter auch im gew&auml;hlten
	Format abgespeichert werden, muss mit
	<literal>crypt_default</literal> in der Datei
	<filename>/etc/auth.conf</filename> die richtige
	Priorit&auml;t der Formate eingestellt werden.  Das
	gew&auml;hlte Format sollte als Erstes in der Liste
	stehen.  Sollen die Passw&ouml;rter mit DES verschl&uuml;sselt
	werden, verwenden Sie den folgenden Eintrag:</para>

      <programlisting>crypt_default	=	des blf md5</programlisting>

      <para>Wenn Sie alle &os; NIS-Server und NIS-Clients entsprechend
	den obigen Schritten eingestellt haben, wird im ganzen
	Netzwerk dasselbe Passwortformat verwendet.  Falls Sie
	Probleme mit der Authentifizierung eines NIS-Clients
	haben, kontrollieren Sie die verwendeten Passwortformate.
	In einer heterogenen Umgebung werden Sie DES benutzen
	m&uuml;ssen, da dies der meist unterst&uuml;tzte Standard
	ist.</para>
    </sect2>
  </sect1>

  <sect1 id="network-dhcp">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Greg</firstname>
          <surname>Sutter</surname>
          <contrib>Geschrieben von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>DHCP &ndash; Dynamic Host Configuration Protocol</title>

    <sect2>
      <title>Was ist DHCP?</title>

      <indexterm>
        <primary>Dynamic Host Configuration Protocol</primary>
        <see>DHCP</see>
      </indexterm>

      <indexterm>
        <primary>Internet Software Consortium (ISC)</primary>
      </indexterm>

      <para>&Uuml;ber DHCP, das Dynamic Host Configuration Protocol,
        kann sich ein System mit einem Netzwerk verbinden und die
        f&uuml;r die Kommunikation mit diesem Netzwerk n&ouml;tigen
        Informationen beziehen.  FreeBSD verwendet die
        DHCP-Implementation von ISC (Internet Software Consortium),
        daher beziehen sich alle implementationsspezifischen
        Informationen in diesem Abschnitt auf die ISC-Distribution.
      </para>
    </sect2>

    <sect2>
      <title>&Uuml;bersicht</title>

      <para>Dieser Abschnitt beschreibt sowohl die Client- als auch die
        Serverseite des DHCP-Systems von ISC.  Das Clientprogramm
        <command>dhclient</command> ist in FreeBSD integriert, das
        Serverprogramm kann &uuml;ber den Port
	<filename role="package">net/isc-dhcp3-server</filename>
	installiert werden.  Weiter Informationen finden Sie in
        &man.dhclient.8;, &man.dhcp-options.5; sowie
        &man.dhclient.conf.5;.</para>
    </sect2>

    <sect2>
      <title>Wie funktioniert DHCP?</title>

      <indexterm><primary>UDP</primary></indexterm>

      <para>Der DHCP-Client <command>dhclient</command> beginnt von
        einem Clientrechner aus &uuml;ber den UDP-Port 68
        Konfigurationsinformationen anzufordern.  Der Server antwortet
	auf dem UDP-Port 67, indem er dem Client eine IP-Adresse
        zuweist und ihm weitere wichtige Informationen &uuml;ber das
        Netzwerk, wie Netzmasken, Router und DNS-Server mitteilt.  Diese
        Informationen werden als
        <firstterm>DHCP-Lease</firstterm> bezeichnet und
        sind nur f&uuml;r eine bestimmte Zeit, die vom Administrator des
        DHCP-Servers vorgegeben wird, g&uuml;ltig.  Dadurch fallen
        verwaiste IP-Adressen, deren Clients nicht mehr mit dem Netzwerk
        verbunden sind, automatisch an den Server zur&uuml;ck.</para>

      <para>DHCP-Clients k&ouml;nnen sehr viele Informationen von einem
        DHCP-Server erhalten.  Eine ausf&uuml;hrliche Liste finden Sie
        in &man.dhcp-options.5;.</para>
    </sect2>

    <sect2>
      <title>Integration in FreeBSD</title>

      <para>Der ISC-DHCP-Client ist seit FreeBSD&nbsp;3.2
	vollst&auml;ndig in FreeBSD integriert.  Sowohl w&auml;hrend
	der Installation als auch im Basissystem steht der
	DHCP-Client zur Verf&uuml;gung.  In Netzen mit
	DHCP-Servern wird dadurch die Konfiguration von
	Systemen erheblich vereinfacht.</para>

      <indexterm>
        <primary><application>sysinstall</application></primary>
      </indexterm>

      <para>DHCP wird von <application>sysinstall</application>
        unterst&uuml;tzt.  Richten Sie eine Netzkarte unter
        <application>sysinstall</application> ein, wird Ihnen zuerst
        folgende Frage gestellt: <quote>Wollen Sie diese Karte &uuml;ber
        DHCP einrichten?</quote>  Wenn Sie diese Frage bejahen, wird
        <command>dhclient</command> aufgerufen, und die Netzkarte wird
        automatisch eingerichtet.</para>

      <para>Um DHCP beim Systemstart zu aktivieren, m&uuml;ssen Sie zwei
        Dinge erledigen:</para>

      <indexterm>
        <primary>DHCP</primary>
        <secondary>Anforderungen</secondary>
      </indexterm>

      <itemizedlist>
        <listitem>
          <para>Stellen Sie sicher, dass <devicename>bpf</devicename> in
            Ihren Kernel kompiliert ist.  Dazu f&uuml;gen Sie die Zeile
            <literal>pseudo-device bpf</literal> in Ihre
            Kernelkonfigurationsdatei ein und erzeugen einen neuen
	    Kernel.  Weitere Informationen zur Kernelkonfiguration
	    finden Sie in <xref linkend="kernelconfig"> des Handbuchs.
	  </para>

          <para>Das Ger&auml;t <devicename>bpf</devicename> ist im
            <filename>GENERIC</filename>-Kernel bereits enthalten.
            F&uuml;r die Nutzung von DHCP muss also kein angepasster
            Kernel erzeugt werden.</para>

            <note>
              <para>Wenn Sie um die Sicherheit Ihres Systems besorgt
                sind, sollten Sie wissen, dass
                <devicename>bpf</devicename> auch zur Ausf&uuml;hrung
                von Paketsniffern erforderlich ist (obwohl diese dennoch
                als <username>root</username> ausgef&uuml;hrt werden
                m&uuml;ssen).  <devicename>bpf</devicename>
                <emphasis>muss</emphasis> vorhanden sein, damit DHCP
                funktioniert.  Sind Sie sehr sicherheitsbewusst, sollten
                Sie <devicename>bpf</devicename> aus Ihrem Kernel
                entfernen, wenn Sie DHCP nicht verwenden.</para>
            </note>
        </listitem>

        <listitem>
          <para>F&uuml;gen Sie folgende Zeile in
            <filename>/etc/rc.conf</filename> ein:</para>

          <programlisting>ifconfig_fxp0="DHCP"</programlisting>

            <note>
              <para>Ersetzen Sie <literal>fxp0</literal> durch den
                Eintrag f&uuml;r die Netzkarte, die Sie dynamisch
                einrichten wollen.  Lesen Sie dazu auch
                <xref linkend="config-network-setup">.</para>
            </note>

          <para>Wenn Sie <command>dhclient</command> an einem anderen
            Ort installiert haben, oder zus&auml;tzliche Flags an
            <command>dhclient</command> &uuml;bergeben wollen,
            f&uuml;gen Sie auch folgende (entsprechend angepasste)
            Zeilen ein:</para>

            <programlisting>dhcp_program="/sbin/dhclient"
dhcp_flags=""</programlisting>
        </listitem>
      </itemizedlist>

      <indexterm>
          <primary>DHCP</primary>
          <secondary>Server</secondary>
      </indexterm>

      <para>Der DHCP-Server <command>dhcpd</command> ist als Teil des
	Ports <filename role="package">net/isc-dhcp3-server</filename>
        verf&uuml;gbar.  Dieser Port enth&auml;lt die komplette
	ISC-DHCP-Distribution, inklusive der Dokumentation.</para>
    </sect2>

    <sect2>
      <title>Dateien</title>

      <indexterm>
        <primary>DHCP</primary>
        <secondary>Konfigurationsdateien</secondary>
      </indexterm>

      <itemizedlist>
        <listitem>
          <para><filename>/etc/dhclient.conf</filename></para>

          <para><command>dhclient</command> ben&ouml;tigt die
            Konfigurationsdatei <filename>/etc/dhclient.conf</filename>.
	    Diese Datei enth&auml;lt normalerweise nur Kommentare, da
	    die Vorgabewerte zumeist ausreichend sind.  Lesen Sie dazu
	    auch &man.dhclient.conf.5;.</para>
        </listitem>

        <listitem>
          <para><filename>/sbin/dhclient</filename></para>

          <para><command>dhclient</command> ist statisch gelinkt und
	    befindet sich in <filename>/sbin</filename>.  Weitere
	    Informationen finden Sie in &man.dhclient.8;.</para>
        </listitem>

        <listitem>
          <para><filename>/sbin/dhclient-script</filename></para>

          <para>Bei <command>dhclient-script</command> handelt es sich
            um das FreeBSD-spezifische Konfigurationsskript des
            DHCP-Clients.  Es wird in &man.dhclient-script.8;
            beschrieben und kann meist unver&auml;ndert &uuml;bernommen
            werden.</para>
        </listitem>

        <listitem>
          <para><filename>/var/db/dhclient.leases</filename></para>

          <para>Der DHCP-Client verf&uuml;gt &uuml;ber eine Datenbank,
            die alle derzeit g&uuml;ltigen Leases enth&auml;lt und als
            Logdatei erzeugt wird.  Weitere Informationen finden Sie in
            &man.dhclient.8;.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Weitere Informationen</title>

      <para>Das DHCP-Protokoll wird vollst&auml;ndig im
        <ulink url="http://www.freesoft.org/CIE/RFC/2131/">RFC 2131</ulink>
        beschrieben.  Eine weitere, lehrreiche Informationsquelle
        existiert unter
        <ulink url="http://www.dhcp.org/">dhcp.org</ulink>.</para>
    </sect2>

    <sect2 id="network-dhcp-server">
      <title>Einen DHCP-Server installieren und einrichten</title>

      <sect3>
        <title>&Uuml;bersicht</title>

        <para>Dieser Abschnitt beschreibt die Einrichtung eines
          FreeBSD-Systems als DHCP-Server.  Dazu wird die
          DHCP-Implementation von ISC (Internet Software Consortium)
          verwendet.</para>

        <para>Der DHCP-Server ist nicht im Basissystem von FreeBSD
          enthalten,  daher m&uuml;ssen Sie als Erstes den Port
	  <filename role="package">net/isc-dhcp3-server</filename>
          installieren.  Lesen Sie <xref linkend="ports">, wenn Sie
          weitere Informationen zur Portssammlung ben&ouml;tigen.
        </para>
      </sect3>

      <sect3>
        <title>Den DHCP-Server installieren</title>

        <indexterm>
          <primary>DHCP</primary>
          <secondary>installieren</secondary>
        </indexterm>

        <para>Stellen Sie sicher, dass <devicename>bpf</devicename> in
          Ihren Kernel kompiliert ist.  Dazu f&uuml;gen Sie die Zeile
          <literal>pseudo-device bpf</literal> in Ihre
          Kernelkonfigurationsdatei ein und erzeugen einen neuen
          Kernel.  Die Kernelkonfiguration wird in
          <xref linkend="kernelconfig"> beschrieben.</para>

        <para>Das Ger&auml;t <devicename>bpf</devicename> ist im
          <filename>GENERIC</filename>-Kernel bereits enthalten.
          F&uuml;r die Nutzung von DHCP muss also kein angepasster
          Kernel erzeugt werden.</para>

          <note>
            <para>Wenn Sie um die Sicherheit Ihres Systems besorgt
              sind, sollten Sie wissen, dass
              <devicename>bpf</devicename> auch zur Ausf&uuml;hrung
              von Paketsniffern erforderlich ist (obwohl diese dennoch
              als <username>root</username> ausgef&uuml;hrt werden
              m&uuml;ssen).  <devicename>bpf</devicename>
              <emphasis>muss</emphasis> vorhanden sein, damit DHCP
              funktioniert.  Sind Sie sehr sicherheitsbewusst, sollten
              Sie <devicename>bpf</devicename> aus Ihrem Kernel
              entfernen, wenn Sie DHCP nicht verwenden.</para>
          </note>

        <para>Danach m&uuml;ssen Sie die vom Port
	  <filename role="package">net/isc-dhcp3-server</filename>
	  erzeugte Vorlage f&uuml;r <filename>dhcpd.conf</filename>
	  anpassen.  Die bei der Installation erzeugte Datei
          <filename>/usr/local/etc/dhcpd.conf.sample</filename>
          sollten Sie nach
          <filename>/usr/local/etc/dhcpd.conf</filename> kopieren,
          bevor Sie Ver&auml;nderungen vornehmen.</para>
      </sect3>

      <sect3>
        <title>Den DHCP-Server einrichten</title>

        <indexterm>
          <primary>DHCP</primary>
          <secondary>dhcpd.conf</secondary>
        </indexterm>

        <para><filename>dhcpd.conf</filename> besteht aus Festlegungen
          zu Subnetzen und Rechnern und l&auml;sst sich am besten an
          einem Beispiel erkl&auml;ren:</para>

          <programlisting>option domain-name "example.com";<co id="domain-name">
option domain-name-servers 192.168.4.100;<co id="domain-name-servers">
option subnet-mask 255.255.255.0;<co id="subnet-mask">

default-lease-time 3600;<co id="default-lease-time">
max-lease-time 86400;<co id="max-lease-time">
ddns-update-style none;<co id="ddns-update-style">

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<co id="range">
  option routers 192.168.4.1;<co id="routers">
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<co id="hardware">
  fixed-address mailhost.example.com;<co id="fixed-address">
}</programlisting>

          <calloutlist>
            <callout arearefs="domain-name">
              <para>Diese Option beschreibt die Dom&auml;ne, die den
                Clients als Standardsuchdom&auml;ne zugewiesen wird.
	        Weitere Informationen finden Sie in man.resolv.conf.5;.
	      </para>
            </callout>

            <callout arearefs="domain-name-servers">
              <para>Diese Option legt eine, durch Kommata getrennte
                Liste von DNS-Servern fest, die von den Clients
                verwendet werden sollen.</para>
            </callout>

            <callout arearefs="subnet-mask">
              <para>Die den Clients zugewiesene Netzmaske.</para>
            </callout>

            <callout arearefs="default-lease-time">
              <para>Ein Client kann eine Lease einer bestimmten Dauer
                anfordern.  Geschieht dies nicht, weist der Server eine
                Lease mit einer vorgegebenen Ablaufdauer (in Sekunden)
                zu.</para>
            </callout>

            <callout arearefs="max-lease-time">
              <para>Die maximale Zeitdauer, f&uuml;r die der Server
                Konfigurationsinformationen vergibt.  Sollte ein Client
                eine l&auml;ngere Zeitspanne anfordern, wird dennoch
                nur der Wert <literal>max-lease-time</literal> in
                Sekunden zugewiesen.</para>
            </callout>

            <callout arearefs="ddns-update-style">
              <para>Diese Option legt fest, ob der DHCP-Server eine
                DNS-Aktualisierung versuchen soll, wenn
                Konfigurationsdateien vergeben oder zur&uuml;ckgezogen
                werden.  In der ISC-Implementation
                <emphasis>muss</emphasis> diese Option gesetzt sein.
              </para>
            </callout>

            <callout arearefs="range">
              <para>Dadurch werden die IP-Adressen festgelegt, die den
                Clients zugewiesen werden k&ouml;nnen.  IP-Adressen
                zwischen diesen Grenzen sowie die einschlie&szlig;enden
                Adressen werden den Clients zugewiesen.</para>
            </callout>

            <callout arearefs="routers">
	      <para>Legt das Standard-Gateway fest, das den Clients
                zugewiesen wird.</para>
            </callout>

            <callout arearefs="hardware">
              <para>Die (Hardware-)MAC-Adresse eines Rechners (durch die
                der DHCP-Server den Client erkennt, der eine Anforderung
                an ihn stellt).</para>
            </callout>

            <callout arearefs="fixed-address">
              <para>Einem Rechner soll immer die gleiche IP-Adresse
                zugewiesen werden.  Beachten Sie, dass hier auch ein
                Rechnername g&uuml;ltig ist, da der DHCP-Server den
                Rechnernamen aufl&ouml;st, bevor er die
                Konfigurationsinformationen zuweist.</para>
            </callout>
          </calloutlist>

        <para>Nachdem Sie <filename>dhcpd.conf</filename> fertig
          konfiguriert haben, k&ouml;nnen Sie den DHCP-Server starten:
        </para>

	  <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/isc-dhcpd.sh start</userinput></screen>

        <para>Sollten Sie die Konfiguration Ihres Servers einmal
          ver&auml;ndern m&uuml;ssen, reicht es nicht aus, ein
          <literal>SIGHUP</literal>-Signal an
          <application>dhcpd</application> zu senden, weil damit die
          Konfiguration <emphasis>nicht</emphasis> erneut geladen wird
          (im Gegensatz zu den meisten Daemonen).  Sie m&uuml;ssen
          den Prozess vielmehr mit dem Signal
          <literal>SIGTERM</literal> stoppen, um ihn
          anschlie&szlig;end neu zu starten.</para>
      </sect3>

      <sect3>
        <title>Dateien</title>

        <indexterm>
          <primary>Server</primary>
          <secondary>Konfigurationsdateien</secondary>
        </indexterm>

        <itemizedlist>
          <listitem>
            <para><filename>/usr/local/sbin/dhcpd</filename></para>

            <para><application>dhcpd</application> ist statisch
              gelinkt und befindet sich in
              <filename>/usr/local/sbin</filename>.  Lesen Sie auch die
	      mit dem Port installierte Hilfeseite &man.dhcpd.8;, wenn
	      Sie weitere Informationen zu
	     <application>dhcpd</application> ben&ouml;tigen.</para>
          </listitem>

          <listitem>
            <para><filename>/usr/local/etc/dhcpd.conf</filename></para>

            <para><application>dhcpd</application> ben&ouml;tigt die
              Konfigurationsdatei
              <filename>/usr/local/etc/dhcpd.conf</filename>, damit
              der Server den Clients seine Dienste anbieten kann.
              Diese Datei muss alle Informationen enthalten, die an
              die Clients weitergegeben werden soll.  Au&szlig;erdem
              sind hier Informationen zur Konfiguration des Servers
              enthalten.  Die mit dem Port installierte Hilfeseite
	      &man.dhcpd.conf.5; enth&auml;lt weitere Informationen.
	    </para>
          </listitem>

          <listitem>
            <para><filename>/var/db/dhcpd.leases</filename></para>

            <para>Der DHCP-Server hat eine Datenbank, die alle
              vergebenen Leases enth&auml;lt.  Diese wird als Logdatei
              erzeugt.  Weitere Informationen finden Sie in der vom
              Port installierten Hilfeseite &man.dhcpd.leases.5;.</para>
          </listitem>

          <listitem>
            <para><filename>/usr/local/sbin/dhcrelay</filename></para>

            <para><application>dhcrelay</application> wird in
              komplexen Umgebungen verwendet, in denen ein DHCP-Server
              eine Anfrage eines Clients an einen DHCP-Server in einem
	      separaten Netzwerk weiterleitet.  Wenn Sie diese
	      Funktion ben&ouml;tigen, m&uuml;ssen Sie den Port
	      <filename role="package">net/isc-dhcp3-server</filename>
	      installieren.  Weitere Informationen zu diesem Thema
	      finden Sie in &man.dhcrelay.8;.</para>
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-dns">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Beigetragen von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>DNS &ndash; Domain Name Service</title>

    <sect2>
      <title>&Uuml;berblick</title>

      <indexterm><primary>BIND</primary></indexterm>

      <para>DNS ist das f&uuml;r die Umwandlung von Rechnernamen in
        IP-Adressen zust&auml;ndige Protokoll.  FreeBSD verwendet dazu
        BIND (Berkeley Internet Name Domain), die am h&auml;ufigsten
        verwendete Implementierung von DNS.  Eine Anfrage nach
        <hostid>www.FreeBSD.org</hostid> gibt die IP-Adresse
        des &os;-Webservers, eine Anfrage nach
        <hostid>ftp.FreeBSD.org</hostid> die IP-Adresse des
        entsprechenden FTP-Servers zur&uuml;ck.  Der umgekehrte Weg
        ist ebenso m&ouml;glich, eine IP-Adresse kann also auch in ihren
        Rechnernamen aufgel&ouml;st werden.  Um eine DNS-Abfrage
        durchzuf&uuml;hren, muss am jeweiligen Rechner kein Nameserver
        installiert sein.</para>

      <indexterm><primary>DNS</primary></indexterm>

      <para>Im Internet wird DNS durch ein komplexes System von
        autoritativen Root-Nameservern sowie anderen kleineren
        Nameservern verwaltet, die individuelle Rechnerinformationen
        speichern und untereinander abgleichen.</para>

      <para>Dieses Dokument beschreibt die unter FreeBSD verwendete
        stabile Version BIND 8.x.  BIND 9.x kann &uuml;ber den
        Port <filename role="package">net/bind9</filename>
        installiert werden.</para>

      <para>Das DNS-Protokoll wird in den RFCs 1034 und 1035
        beschrieben.</para>

      <para>Derzeit wird BIND vom <ulink url="http://www.isc.org/">
        Internet Software Consortium</ulink> verwaltet.</para>
    </sect2>

    <sect2>
      <title>Begriffsbestimmungen</title>

      <para>Um dieses Dokument besser verstehen zu k&ouml;nnen,
        m&uuml;ssen einige DNS-spezifische Begriffe genauer definiert
        werden.</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Begriff</entry>

              <entry>Bedeutung</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Forward-DNS</entry>

              <entry>Rechnernamen in IP-Adressen umwandeln</entry>
            </row>

            <row>
              <entry>Origin (Ursprung)</entry>

              <entry>Die in einer bestimmten Zonendatei beschriebene
                Dom&auml;ne.</entry>
            </row>

            <row>
              <entry><application>named</application>, BIND,
                Nameserver</entry>

              <entry>Gebr&auml;uchliche Namen f&uuml;r das unter FreeBSD
                verwendete BIND-Nameserverpaket</entry>
            </row>

            <indexterm><primary>Resolver</primary></indexterm>

            <row>
              <entry>Resolver</entry>

              <entry>Ein Systemprozess, durch den ein Rechner
                Zoneninformationen von einem Nameserver anfordert.
              </entry>
            </row>

            <indexterm><primary>Reverse-DNS</primary></indexterm>

            <row>
              <entry>Reverse-DNS</entry>

              <entry>Das Gegenteil von Forward-DNS; die Umwandlung von
                IP-Adressen in Rechnernamen</entry>
            </row>

            <indexterm><primary>root zone</primary></indexterm>

            <row>
              <entry>Root-Zone</entry>

              <entry>Der Beginn der Internet-Zonenhierarchie.  Alle
                Zonen befinden sich innerhalb der Root-Zone. Dies ist
                analog zu einem Dateisystem, in dem sich alle Dateien
                und Verzeichnisse innerhalb des Wurzelverzeichnisses
                befinden.</entry>
            </row>

            <row>
              <entry>Zone</entry>

              <entry>Eine individuelle Dom&auml;ne, Unterdom&auml;ne,
                oder ein Teil von DNS, der von der gleichen
                Autorit&auml;t verwaltet wird.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <indexterm>
        <primary>Zonen</primary>
        <secondary>Beispiele</secondary>
      </indexterm>

      <para>Es folgen nun einige Zonenbeispiele:</para>

      <itemizedlist>
        <listitem>
          <para><hostid>.</hostid> ist die Root-Zone.</para>
        </listitem>

        <listitem>
          <para><hostid>org.</hostid> ist eine Zone innerhalb der
            Root-Zone.</para>
        </listitem>

        <listitem>
          <para><hostid>example.org.</hostid> ist eine Zone innerhalb
            der <hostid>org</hostid>-Zone.</para>
        </listitem>

        <listitem>
          <para><hostid>foo.example.org.</hostid> ist eine
            Unterdom&auml;ne, eine Zone innerhalb der Zone
            <hostid>example.org</hostid>.</para>
        </listitem>

        <listitem>
          <para><hostid>1.2.3.in-addr.arpa.</hostid> ist die Zone mit
            allen IP-Adressen des 3.2.1.*-IP-Adressraums.</para>
        </listitem>
      </itemizedlist>

      <para>Wie man an diesen Beispielen erkennen kann, befindet sich
        der spezifischere Teil eines Rechnernamens auf der linken Seite
        der Adresse.  <hostid>example.org.</hostid> beschreibt einen
        Rechner also genauer als <hostid>org.</hostid>, w&auml;hrend
        <hostid>org.</hostid> genauer als die Root-Zone ist.  Jeder Teil
        des Rechnernamens hat &Auml;hnlichkeiten mit einem Dateisystem,
        in dem etwa <filename>/dev</filename> dem Wurzelverzeichnis
        untergeordnet ist.</para>
    </sect2>

    <sect2>
      <title>Gr&uuml;nde f&uuml;r die Verwendung eines
        Nameservers</title>

      <para>Es gibt zwei Arten von Nameservern: Autoritative Nameserver
        sowie zwischenspeichernde (cachende) Nameserver.</para>

      <para>Ein autoritativer Nameserver ist notwendig, wenn</para>

      <itemizedlist>
        <listitem>
	  <para>sie anderen verbindliche DNS-Ausk&uml;nfte erteilen
	    wollen.</para>
        </listitem>

        <listitem>
          <para>eine Domain, beispielsweise <hostid>example.org</hostid>,
            registriert wird, und den zu dieser Domain geh&ouml;renden
            Rechnern IP-Adressen zugewiesen werden m&uuml;ssen.</para>
        </listitem>

        <listitem>
          <para>ein IP-Adressblock reverse-DNS-Eintr&auml;ge
            ben&ouml;tigt, um IP-Adressen in Rechnernamen aufl&ouml;sen
            zu k&ouml;nnen.</para>
        </listitem>

        <listitem>
          <para>ein Backup-Nameserver (auch Slaveserver genannt) auf
            Anfragen antworten muss, weil der Hauptserver nicht
            erreichbar ist.</para>
        </listitem>
      </itemizedlist>

      <para>Ein cachender Nameserver ist notwendig, weil</para>

      <itemizedlist>
        <listitem>
          <para>ein lokaler DNS-Server Daten zwischenspeichern und daher
            schneller auf Anfragen reagieren kann als ein entfernter
            Server.</para>
        </listitem>

        <listitem>
	  <para>die Datenmenge reduziert werden muss
            (DNS-Verkehr macht etwa 5 % des gesamten Datenverkehrs im
            Internet aus).</para>
        </listitem>
      </itemizedlist>

      <para>Wird nach <hostid>www.FreeBSD.org</hostid> gesucht, leitet
        der Resolver diese Anfrage an den Nameserver des
        ISPs weiter und nimmt danach das Ergebnis der
        Abfrage entgegen.  Existiert ein lokaler, zwischenspeichernder
        DNS-Server, muss dieser die Anfrage nur einmal nach au&szlig;en
        weitergeben.  F&uuml;r alle weiteren Anfragen ist dies nicht
        mehr n&ouml;tig, da diese Information nun lokal gespeichert
        ist.</para>
    </sect2>

    <sect2>
      <title>Wie funktioniert DNS?</title>

      <para>Unter FreeBSD wird der BIND-Daemon als
        <application>named</application> bezeichnet.</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Datei</entry>

              <entry>Beschreibung</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><application>named</application></entry>

              <entry>Der BIND-Daemon.</entry>
            </row>

            <row>
              <entry><command>ndc</command></entry>

              <entry>Das Steuerprogramm f&uuml;r
                <application>named</application>.</entry>
            </row>

            <row>
              <entry><filename>/etc/namedb</filename></entry>

              <entry>Das Verzeichnis, in dem sich die Zoneninformationen
                f&uuml;r BIND befinden.</entry>
            </row>

            <row>
              <entry><filename>/etc/namedb/named.conf</filename></entry>

              <entry>Die Konfigurationsdatei f&uuml;r
                <application>named</application>.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Zonendateien befinden sich normalerweise im Verzeichnis
        <filename>/etc/namedb</filename> und enthalten die vom
        Nameserver angebotenen DNS-Zoneninformationen.</para>
    </sect2>

    <sect2>
      <title>BIND starten</title>

      <indexterm>
        <primary>BIND</primary>
        <secondary>Start</secondary>
      </indexterm>

      <para>Da BIND automatisch installiert wird, ist die Konfiguration
        relativ einfach.</para>

      <para>Um den <application>named</application>-Daemon beim
        Systemstart automatisch zu starten, f&uuml;gen Sie folgende
        Zeile in <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>named_enable="YES"</programlisting>

      <para>Um den Daemon (nach der Konfiguration) manuell zu starten,
        geben Sie Folgendes ein:</para>

      <screen>&prompt.root; <userinput>ndc start</userinput></screen>
    </sect2>

    <sect2>
      <title>Konfigurationsdateien</title>

      <indexterm>
        <primary>BIND</primary>
        <secondary>Konfigurationsdateien</secondary>
      </indexterm>

      <sect3>
        <title><command>make-localhost</command> verwenden</title>

        <para>Um die lokale reverse-DNS-Zonendatei
          <filename>/etc/namedb/localhost.rev</filename> korrekt zu
          erzeugen, machen Sie Folgendes:</para>

          <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>sh make-localhost</userinput></screen>
      </sect3>

      <sect3>
        <title><filename>/etc/namedb/named.conf</filename></title>

        <programlisting>// &dollar;FreeBSD$
//
// Refer to the named(8) manual page for details.  If you are ever going
// to setup a primary server, make sure you've understood the hairy
// details of how DNS is working.  Even with simple mistakes, you can
// break connectivity for affected parties, or cause huge amount of
// useless Internet traffic.

options {
        directory "/etc/namedb";

// In addition to the "forwarders" clause, you can force your name
// server to never initiate queries of its own, but always ask its
// forwarders only, by enabling the following line:
//
//      forward only;

// If you've got a DNS server around at your upstream provider, enter
// its IP address here, and enable the line below.  This will make you
// benefit from its cache, thus reduce overall DNS traffic in the
Internet.
/*
        forwarders {
                127.0.0.1;
        };
*/      </programlisting>

        <para>Um vom Cache Ihres Internetproviders zu profitieren,
          k&ouml;nnen hier <literal>forwarders</literal> aktiviert
          werden.  Normalerweise sucht ein Nameserver das Internet
          rekursiv ab, bis er die gesuchte Antwort findet.  Durch
          diese Option wird stets der Nameserver Ihres
          Internetproviders zuerst abgefragt, um von dessen
          Cache zu profitieren.  Wenn es sich um einen schnellen,
          viel benutzten Nameserver handelt, kann dies zu einer
          Geschwindigkeitssteigerung f&uuml;hren.</para>

        <warning>
          <para><hostid role="ipaddr">127.0.0.1</hostid> funktioniert
            hier <emphasis>nicht</emphasis>.  &Auml;ndern Sie diese
            Adresse in einen Nameserver Ihres Einwahlproviders.</para>
        </warning>

        <programlisting>/*
* If there is a firewall between you and name servers you want
* to talk to, you might need to uncomment the query-source
* directive below.  Previous versions of BIND always asked
* questions using port 53, but BIND 8.1 uses an unprivileged
* port by default.
*/
// query-source address * port 53;

/*
* If running in a sandbox, you may have to specify a different
* location for the dumpfile.
*/
// dump-file "s/named_dump.db";
};

// Note: the following will be supported in a future release.
/*
host { any; } {
        topology {
                127.0.0.0/8;
        };
};
*/

// Setting up secondaries is way easier and the rough picture for this
// is explained below.
//
// If you enable a local name server, don't forget to enter 127.0.0.1
// into your /etc/resolv.conf so this server will be queried first.
// Also, make sure to enable it in /etc/rc.conf.

zone "." {
        type hint;
        file "named.root";
};

zone "0.0.127.IN-ADDR.ARPA" {
        type master;
        file "localhost.rev";
};

zone
"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.INT" {
        type master;
        file "localhost.rev";
};

// NB: Do not use the IP addresses below, they are faked, and only
// serve demonstration/documentation purposes!
//
// Example secondary config entries.  It can be convenient to become
// a secondary at least for the zone where your own domain is in.  Ask
// your network administrator for the IP address of the responsible
// primary.
//
// Never forget to include the reverse lookup (IN-ADDR.ARPA) zone!
// (This is the first bytes of the respective IP address, in reverse
// order, with ".IN-ADDR.ARPA" appended.)
//
// Before starting to setup a primary zone, better make sure you fully
// understand how DNS and BIND works, however.  There are sometimes
// unobvious pitfalls.  Setting up a secondary is comparably simpler.
//
// NB: Don't blindly enable the examples below. :-)  Use actual names
// and addresses instead.
//
// NOTE!!! FreeBSD runs bind in a sandbox (see named_flags in rc.conf).
// The directory containing the secondary zones must be write accessible
// to bind.  The following sequence is suggested:
//
//      mkdir /etc/namedb/s
//      chown bind:bind /etc/namedb/s
//      chmod 750 /etc/namedb/s</programlisting>

        <para>Wenn Sie BIND innerhalb einer Sandbox betreiben wollen,
          lesen Sie bitte den
	  <xref linkend="network-named-sandbox">.</para>

        <programlisting>/*
zone "example.com" {
        type slave;
        file "s/example.com.bak";
        masters {
                192.168.1.1;
        };
};

zone "0.168.192.in-addr.arpa" {
        type slave;
        file "s/0.168.192.in-addr.arpa.bak";
        masters {
                192.168.1.1;
        };
};
*/      </programlisting>

        <para>Hierbei handelt es sich um Slave-Eintr&auml;ge f&uuml;r
          eine Reverse- und Forward-DNS-Zone, die in der Datei
          <filename>named.conf</filename> definiert sind.</para>

        <para>F&uuml;r jede neue Zone muss ein zus&auml;tzlicher Eintrag
          in <filename>named.conf</filename> erstellt werden.</para>

        <para>Ein einfacher Eintrag f&uuml;r eine Zone
          <hostid role="domainname">example.org</hostid> k&ouml;nnte
          beispielsweise so aussehen:</para>

        <programlisting>zone "example.org" {
        type master;
        file "example.org";
};      </programlisting>

        <para>Die Option <option>type</option> legt fest, dass es sich
          um eine Master-Zone handelt, deren Zoneninformationen sich in
          der Datei <filename>/etc/namedb/example.org</filename>
          befinden.  Diese Datei wird durch die Option
          <option>file</option> festgelegt.</para>

        <programlisting>zone "example.org" {
        type slave;
        file "example.org";
};      </programlisting>

        <para>Hier handelt es sich um einen Slaveserver, der seine
          Informationen vom Masterserver der betreffenden Zone bezieht
          und diese in der angegebenen Datei speichert.  Wenn der
          Masterserver nicht erreichbar ist, verf&uuml;gt der
          Slaveserver &uuml;ber die transferierten Zoneninformationen
          und kann diese an andere Rechner weitergeben.</para>
      </sect3>

      <sect3>
        <title>Zonendateien</title>

        <para>Die in der Datei
          <filename>/etc/namedb/example.org</filename> definierte
          Zonendatei f&uuml;r <hostid>example.org</hostid> k&ouml;nnte
          etwa so aussehen:</para>

        <programlisting>$TTL 3600

example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        86400 )         ; Minimum TTL

; DNS Servers
@       IN NS           ns1.example.org.
@       IN NS           ns2.example.org.

; Machine Names
localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30

; Aliases
www             IN CNAME        @

; MX Record
@               IN MX   10      mail.example.org.</programlisting>

        <para>Beachten Sie, dass jeder mit einem <quote>.</quote>
          endende Rechnername ein exakter Rechnername ist, w&auml;hrend
          sich alles ohne einen abschlie&szlig;enden <quote>.</quote>
          auf den Ursprung bezieht.  <literal>www</literal> steht daher
          f&uuml;r <literal>www + Ursprung</literal>.  In unserer
          fiktiven Zonendatei ist <hostid>example.org.</hostid> der
          Ursprung, daher steht <literal>www</literal> f&uuml;r
          <hostid>www.example.org.</hostid></para>

        <para>Eine Zonendatei hat folgenden Aufbau:</para>

        <programlisting>recordname      IN recordtype   value</programlisting>

        <indexterm>
          <primary>DNS</primary>
          <secondary>Eintr&auml;ge</secondary>
        </indexterm>

        <para>Die am h&auml;ufigsten verwendeten DNS-Eintr&auml;ge sind:</para>

        <variablelist>
          <varlistentry>
            <term>SOA</term>

            <listitem>
              <para>Start der Zonenautorit&auml;t</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>NS</term>

            <listitem>
              <para>Ein autoritativer Nameserver</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>A</term>

            <listitem><para>Eine Rechneradresse</para></listitem>
          </varlistentry>

          <varlistentry>
            <term>CNAME</term>

            <listitem>
              <para>Der kanonische Name eines Alias</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>MX</term>

            <listitem><para>Mail Exchanger</para></listitem>
          </varlistentry>

          <varlistentry>
            <term>PTR</term>

            <listitem>
              <para>Ein (bei Reverse-DNS verwendeter) Domain Name
                Pointer</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <programlisting>example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        86400 )         ; Minimum TTL of 1 day</programlisting>

        <variablelist>
          <varlistentry>
            <term><hostid>example.org.</hostid></term>

            <listitem><para>Der Name der Dom&auml;ne und damit der
              Ursprung dieser Zonendatei.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><hostid>ns1.example.org.</hostid></term>

            <listitem><para>Der prim&auml;re/autoritative Nameserver
              dieser Zone.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>admin.example.org.</literal></term>

            <listitem><para>Die f&uuml;r diese Zone verantwortliche
             Person. Das Zeichen <literal>@</literal> wird dabei
             ersetzt (<email>admin@example.org</email> wird also zu
             <literal>admin.example.org</literal>).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>5</literal></term>

            <listitem><para>Die Seriennummer der Datei.  Sie muss
              stets inkrementiert werden, wenn die Zonendatei
              ge&auml;ndert wird.  Viele Administratoren bevorzugen
              ein <literal>JJJJMMTTRR</literal>-Format, um die
              Seriennummer festzulegen.  2001041002 steht also f&uuml;r
              den 10.04.2001, die beiden letzten Stellen f&uuml;r die
              zweite Modifikation der Zonendatei an diesem Tag.  Die
              Seriennummer ist von gro&szlig;er Bedeutung, da
              Slaveserver daran eine aktualisierte Zonendatei erkennen
              k&ouml;nnen.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <programlisting>@       IN NS           ns1.example.org.</programlisting>

        <para>Ein <varname>NS</varname>-Eintrag.  Jeder Nameserver, der
          f&uuml;r eine Zone verantwortlich ist, muss &uuml;ber einen
          solchen Eintrag verf&uuml;gen.  Das Zeichen
          <literal>@</literal> steht in unserem Beispiel f&uuml;r
          <hostid role="domainname">example.org.</hostid>,
          <literal>@</literal> verweist also auf den Ursprung.</para>

        <programlisting>localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30</programlisting>

        <para>Der Eintrag <literal>A</literal> bezieht sich auf
          Rechnernamen.  <hostid>ns1.example.org</hostid> w&uuml;rde
          also zu <hostid role="ipaddr">3.2.1.2</hostid> aufgel&ouml;st
          werden.  Da das (Ursprungs-)Symbol <literal>@</literal>
          verwendet wird, wird <hostid>example.org</hostid> zu
          <hostid role="ipaddr">3.2.1.30</hostid> aufgel&ouml;st.</para>

        <programlisting>www             IN CNAME        @</programlisting>

        <para>Der Eintrag f&uuml;r den kanonischen Namen wird dazu
          verwendet, Aliase f&uuml;r einen Rechner zu vergeben.  Im
          Beispiel ist <hostid>www</hostid> ein Alias f&uuml;r den
          Ursprungsrechner (<hostid>example.org</hostid> oder
          <hostid role="ipaddr">3.2.1.30</hostid>).  Durch die Option
          <varname>CNAME</varname> k&ouml;nnen Aliasnamen vergeben
          werden.  Ein Rechnername kann aber auch abwechselnd
          verschiedenen Rechnern zugewiesen werden.</para>

	<indexterm>
	  <primary>MX-Eintrag</primary>
	</indexterm>

        <programlisting>@               IN MX   10      mail.example.org.</programlisting>

        <para>Die Option <varname>MX</varname> legt fest, welcher
          Mailserver f&uuml;r eintreffende Mails der Zone
          verantwortlich ist.
          <hostid role="fqdn">mail.example.org</hostid> ist der
          Rechnername des Mailservers, der eine Priorit&auml;t von 10
          hat.</para>

        <para>Es k&ouml;nnen auch mehrere Mailserver mit verschiedener
          Priorit&auml;t vorhanden sein.  Ein Mailserver, der eine Mail
          an <hostid role="domainname">example.org</hostid> verschicken
          will, verwendet zuerst den MX mit der h&ouml;chsten
          Priorit&auml;t, danach den mit der n&auml;chsth&ouml;heren,
          bis die E-Mail zugestellt werden kann.</para>

        <para>F&uuml;r (bei Reverse-DNS verwendete)
          <literal>in-addr.arpa</literal>-Zonendateien wird das gleiche
          Format verwendet.  Der einzige Unterschied besteht in der
          Verwendung der Option <varname>PTR</varname> an Stelle der
          Optionen <varname>A</varname> und <varname>CNAME</varname>.</para>

        <programlisting>$TTL 3600

1.2.3.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        3600 )          ; Minimum

@       IN NS   ns1.example.org.
@       IN NS   ns2.example.org.

2       IN PTR  ns1.example.org.
3       IN PTR  ns2.example.org.
10      IN PTR  mail.example.org.
30      IN PTR  example.org.</programlisting>

        <para>Durch diese Datei werden den Rechnernamen der fiktiven
          Dom&auml;ne IP-Adressen zugewiesen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Zwischenspeichernde (cachende) Nameserver</title>

      <indexterm>
        <primary>BIND</primary>
        <secondary>Zwischenspeichernde Nameserver</secondary>
      </indexterm>

      <para>Ein cachender Nameserver ist f&uuml;r keine Zonen
        verantwortlich.  Er stellt lediglich eigene Anfragen und
        speichert deren Ergebnisse ab.  Um einen solchen Nameserver
        einzurichten, gehen Sie wie gewohnt vor, allerdings definieren
        Sie keine Zonen.</para>
    </sect2>

    <sect2 id="network-named-sandbox">
      <title><application>named</application> in einer Sandbox
        ausf&uuml;hren</title>

      <indexterm>
        <primary>BIND</primary>
        <secondary>Sandbox</secondary>
      </indexterm>

      <indexterm>
        <primary><command>chroot</command></primary>
      </indexterm>

      <para>Es ist m&ouml;glich, &man.named.8; als nicht privilegierter
        Benutzer in einer mit &man.chroot.8; definierten Sandbox
        auszuf&uuml;hren.  Dadurch hat der
        <application>named</application>-Daemon keinen Zugriff auf
        Verzeichnisse und Dateien au&szlig;erhalb der Sandbox.  Sollte
        <application>named</application> kompromittiert werden,
        l&auml;sst sich dadurch der m&ouml;gliche Schaden begrenzen.
        FreeBSD erzeugt dazu automatisch einen Benutzer und eine
        Gruppe namens <groupname>bind</groupname>.</para>

      <note>
        <para>Manchmal wird auch empfohlen, statt mit
          <command>chroot</command> das Wurzelverzeichnis f&uuml;r
          <application>named</application> zu &auml;ndern,
          <application>named</application> innerhalb eines &man.jail.8;s
          auszuf&uuml;hren.  Diese Situation wird hier jedoch nicht
          beschrieben.</para>
      </note>

      <para>Da <application>named</application> keinen Zugriff auf
        Dateien au&szlig;erhalb der Sandbox (wie Systembibliotheken oder
        Protokolldateien) hat, sind einige Vorbereitungen notwendig,
        damit <application>named</application> korrekt funktioniert.
        Im Folgenden wird angenommen, dass die Sandbox unter
        <filename>/etc/namedb</filename> eingerichtet wird. Au&szlig;erdem
        befinden sich die Dateien in diesem Verzeichnis noch im
        Originalzustand.  Alle Schritte m&uuml;ssen als
        <username>root</username> durchgef&uuml;hrt werden.</para>

      <itemizedlist>
        <listitem>
          <para>Erzeugen Sie alle Verzeichnisse, die
            <application>named</application> ben&ouml;tigt:</para>

            <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>mkdir -p bin dev etc var/tmp var/run master slave</userinput>
&prompt.root; <userinput>chown bind:bind slave var/*</userinput><co id="chown-slave"></screen>

          <calloutlist>
            <callout arearefs="chown-slave">
              <para>Da <application>named</application> nur schreibend
                auf diese Verzeichnisse zugreifen muss, werden auch
                keine weiteren Rechte zugeteilt.</para>
            </callout>
          </calloutlist>
        </listitem>

        <listitem>
          <para>Erzeugen Sie die Basiszonen sowie die n&ouml;tigen
            Konfigurationsdateien:</para>

          <screen>&prompt.root; <userinput>cp /etc/localtime etc</userinput><co id="localtime">
&prompt.root; <userinput>mv named.conf etc && ln -sf etc/named.conf</userinput>
&prompt.root; <userinput>mv named.root master</userinput>
<!-- I don't like this next bit -->
&prompt.root; <userinput>sh make-localhost && mv localhost.rev localhost-v6.rev master</userinput>&prompt.root; <userinput>cat > master/named.localhost
$ORIGIN localhost.
$TTL 6h
@	IN	SOA	localhost. postmaster.localhost. (
			1	; serial
			3600	; refresh
			1800	; retry
			604800	; expiration
			3600 )	; minimum
	IN	NS	localhost.
	IN	A		127.0.0.1
^D</userinput></screen>

          <calloutlist>
            <callout arearefs="localtime">
              <para>Dadurch ist es <application>named</application>
                m&ouml;glich, die korrekte Systemzeit an &man.syslogd.8;
                weiterzugeben.</para>
            </callout>
          </calloutlist>
        </listitem>

        <listitem>
          <para>Wenn Sie FreeBSD in einer Version vor 4.9-RELEASE
            verwenden, erzeugen Sie eine statisch gelinkte Kopie von
            <application>named-xfer</application> und kopieren diese
            in Ihre Sandbox:</para>

          <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make NOSHARED=yes all</userinput>
&prompt.root; <userinput>cp named-xfer /etc/namedb/bin && chmod 555 /etc/namedb/bin/named-xfer</userinput><co id="clean-cruft"></screen>

          <para>Nachdem Sie ihre statische gelinkte Version von
            <command>named-xfer</command> installiert haben,
            m&uuml;ssen Sie etwas aufr&auml;umen, damit keine
            veralteten Kopien von Bibliotheken oder Programmen in Ihrem
            Quellbaum verbleiben:</para>

          <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

          <calloutlist>
            <callout arearefs="clean-cruft">
              <para>Dieser Schritt kann manchmal fehlschlagen.  Wenn
                dies passiert, machen Sie Folgendes:</para>

              <screen>&prompt.root; <userinput>cd /usr/src && make cleandir && make cleandir</userinput></screen>

              <para>Danach l&ouml;schen Sie
                <filename>/usr/obj</filename> inklusive aller
                Unterverzeichnisse:</para>

              <screen>&prompt.root; <userinput>rm -fr /usr/obj && mkdir /usr/obj</userinput></screen>

              <para>Dadurch entfernen Sie den ganzen
                <quote>M&uuml;ll</quote> aus Ihrem Quellbaum und die
                fehlgeschlagenen Schritte sollten nun ebenfalls
                funktionieren.</para>
            </callout>
          </calloutlist>

          <para>Wenn Sie &os; in der Version 4.9-RELEASE oder neuer
            verwenden, wird die in <filename>/usr/libexec</filename>
            vorhandene Kopie von <command>named-xfer</command>
            automatisch statisch gelinkt und Sie k&ouml;nnen die Datei
            einfach mit &man.cp.1; in Ihre Sandbox kopieren.</para>
        </listitem>

        <listitem>
          <para>Erzeugen Sie ein <devicename>dev/null</devicename>, auf
            das <application>named</application> lesend und schreibend
            zugreifen kann:</para>

          <screen>&prompt.root; <userinput>cd /etc/namedb/dev && mknod null c 2 2</userinput>
&prompt.root; <userinput>chmod 666 null</userinput></screen>
        </listitem>

        <listitem>
          <para>Linken Sie <filename>/etc/namedb/var/run/ndc</filename>
            symbolisch nach <filename>/var/run/ndc</filename>:</para>

          <screen>&prompt.root; <userinput>ln -sf /etc/namedb/var/run/ndc /var/run/ndc</userinput></screen>

          <note>
            <para>Dadurch k&ouml;nnen Sie auf die Option
              <option>-c</option> verzichten, wenn Sie &man.ndc.8;
              aufrufen.  Der Inhalt von <filename>/var/run</filename>
              wird beim Systemstart automatisch gel&ouml;scht.  Diese
              Anweisung kann unter Nutzung der Option
              <option>@reboot</option> in die
              <filename>crontab</filename> von <username>root</username>
              eingebaut werden.  Lesen Sie dazu auch die Hilfeseite
              &man.crontab.5;.</para>
          </note>
        </listitem>

        <listitem>
          <para>Weisen Sie &man.syslogd.8; an, einen zus&auml;tzlichen
            <devicename>log</devicename>-Socket zu erzeugen, auf den
            <application>named</application> Schreibzugriff hat.  Dazu
            h&auml;ngen Sie in der Datei
            <filename>/etc/rc.conf</filename> an den Eintrag
            <varname>syslogd_flags</varname> die Option
            <literal>-l /etc/namedb/dev/log</literal> an.</para>
        </listitem>

        <listitem>
          <para>Stellen Sie sicher, dass
            <application>named</application> gestartet wird und sein
            Wurzelverzeichnis mittels <command>chroot</command> in die
            Sandbox setzt, indem Sie folgende Eintr&auml;ge in
            <filename>/etc/rc.conf</filename> einf&uuml;gen:</para>

        <programlisting>named_enable="YES"
named_flags="-u bind -g bind -t /etc/namedb /etc/named.conf"</programlisting>

          <note>
            <para>Beachten Sie, dass die Konfigurationsdatei
              <replaceable>/etc/named.conf</replaceable> durch einen
              absoluten Pfad (aber <emphasis>relativ</emphasis> zur
              Sandbox) festgelegt wird.  Bei der im obigen Beispiel
              angesprochenen Datei handelt es sich also um
              <filename>/etc/namedb/etc/named.conf</filename>.</para>
          </note>
        </listitem>
      </itemizedlist>

      <para>Danach bearbeiten Sie
        <filename>/etc/namedb/etc/named.conf</filename>, damit
        <application>named</application> wei&szlig;, welche Zonen geladen
        werden m&uuml;ssen und wo sich diese befinden.  Es folgt nun
        ein kommentiertes Beispiel (alle nicht dokumentierten
        Eintr&auml;ge gelten auch f&uuml;r einen DNS-Server, der nicht
        in einer Sandbox l&auml;uft):</para>

      <programlisting>options {
        directory "/";<co id="directory">
        named-xfer "/bin/named-xfer";<co id="named-xfer">
        version "";		// Don't reveal BIND version
        query-source address * port 53;
};
// ndc control socket
controls {
        unix "/var/run/ndc" perm 0600 owner 0 group 0;
};
// Zones follow:
zone "localhost" IN {
        type master;
        file "master/named.localhost";<co id="master">
        allow-transfer { localhost; };
        notify no;
};
zone "0.0.127.in-addr.arpa" IN {
        type master;
        file "master/localhost.rev";
        allow-transfer { localhost; };
        notify no;
};
zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.int" {
	type master;
	file "master/localhost-v6.rev";
	allow-transfer { localhost; };
	notify no;
};
zone "." IN {
        type hint;
        file "master/named.root";
};
zone "private.example.net" in {
        type master;
        file "master/private.example.net.db";
	allow-transfer { 192.168.10.0/24; };
};
zone "10.168.192.in-addr.arpa" in {
        type slave;
        masters { 192.168.10.2; };
        file "slave/192.168.10.db";<co id="slave">
};    </programlisting>

      <calloutlist>
        <callout arearefs="directory">
          <para><literal>directory</literal> wird als
            <filename>/</filename> festgelegt, da sich alle von
            <application>named</application> ben&ouml;tigten Dateien in
            diesem Verzeichnis befinden (analog zur
            <filename>/etc/namedb</filename> eines
            <quote>normalen</quote> Benutzers.</para>
        </callout>

        <callout arearefs="named-xfer">
          <para>Legt den vollst&auml;ndigen Pfad zur Bin&auml;rdatei
            <command>named-xfer</command> aus der Sicht von
            <application>named</application> fest.  Das ist n&ouml;tig,
            weil <application>named</application> per Voreinstellung
            im Verzeichnis <filename>/usr/libexec</filename> nach
            <command>named-xfer</command> sucht.</para>
        </callout>

        <callout arearefs="master">
          <para>Legt die Datei (relativ zum
            <literal>directory</literal>-Statement) fest, in der
            <application>named</application> die Zonendatei f&uuml;r
            diese Zone findet.</para>
        </callout>

        <callout arearefs="slave">
          <para>Legt die Datei (relativ zum
            <literal>directory</literal>-Statement) fest, in die
            <application>named</application> eine Kopie der Zonendatei
            dieser Zone schreibt, nachdem diese erfolgreich vom
            Masterserver angefordert wurde.  Aus diesem Grund musste in
            den vorherigen Schritten auch <groupname>bind</groupname>
            der Eigent&uuml;mer des Verzeichnisses
            <filename>slave</filename> sein.</para>
        </callout>
      </calloutlist>

      <para>Nachdem Sie diese Schritte erledigt haben, m&uuml;ssen Sie
        entweder den Rechner oder &man.syslogd.8; neu starten.  Danach
        starten Sie &man.named.8; unter Verwendung der neuen, unter
        <varname>syslogd_flags</varname> und
        <varname>named_flags</varname> festgelegten Optionen.  Sie
        verwenden nun eine Sandboxversion von
        <application>named</application>!</para>
    </sect2>

    <sect2>
      <title>Sicherheit</title>

      <para>Obwohl BIND die am meisten verwendete (und kontrollierte)
        Implementierung von DNS darstellt, werden dennoch manchmal neue
        Sicherheitsprobleme entdeckt.</para>

      <para>Es ist daher eine gute Idee, die Mailinglisten von
        <ulink url="http://www.cert.org/">CERT</ulink> sowie
        <ulink url="../handbook/eresources.html#ERESOURCES-MAIL">
        freebsd-security-notifications</ulink> zu abonnieren, um sich
        &uuml;ber Sicherheitsprobleme im Zusammenhang mit dem Internet
        und FreeBSD zu informieren.</para>

      <tip>
        <para>Tritt ein Problem auf, kann es nie schaden, die
          Quellen zu aktualisieren und <application>named</application>
          neu zu kompilieren.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Weitere Informationsquellen</title>

      <itemizedlist>
        <listitem>
          <para>Hilfeseiten zu BIND/<application>named</application>:
            &man.ndc.8;, &man.named.8;, &man.named.conf.5;</para>
        </listitem>

        <listitem>
          <para><ulink
            url="http://www.isc.org/products/BIND/">Offizielle ISC-Seite
            zu BIND</ulink></para>
        </listitem>

        <listitem>
          <para><ulink
            url="http://www.nominum.com/getOpenSourceResource.php?id=6">
            BIND FAQs</ulink></para>
        </listitem>

        <listitem>
          <para><ulink url="http://www.oreilly.com/catalog/dns4/">O'Reilly
            DNS and BIND 4th Edition</ulink></para>
        </listitem>

        <listitem>
          <para><ulink
            url="ftp://ftp.isi.edu/in-notes/rfc1034.txt">RFC1034
            - Domain Names - Concepts and Facilities</ulink></para>
        </listitem>

        <listitem>
          <para>
            <ulink url="ftp://ftp.isi.edu/in-notes/rfc1035.txt">RFC1035
            - Domain Names - Implementation and Specification</ulink>
          </para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="network-ntp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Hukins</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>NTP &ndash; Network Time Protocol</title>

    <indexterm><primary>NTP</primary></indexterm>

    <sect2>
      <title>&Uuml;berblick</title>

      <para>Da die interne Uhrzeit eines Computers nie ganz exakt ist,
	wurde mit NTP
	(<foreignphrase>Network Time Protocol</foreignphrase>) eine
	M&ouml;glichkeit geschaffen, die exakte Uhrzeit zu ermitteln
	und festzulegen.</para>

      <para>Viele Internetdienste sind von einer exakten Uhrzeit
	abh&auml;ngig.  Ein Webserver k&ouml;nnte beispielsweise die
	Anforderung erhalten, eine Datei zu versenden, wenn sich diese
	in einer bestimmten Zeitspanne ge&auml;ndert hat.  Dienste wie
	&man.cron.8; f&uuml;hren Befehle zu einem bestimmten Zeitpunkt
	aus.  Ist die Uhrzeit nicht korrekt, kann dies zu Problemen
	f&uuml;hren.</para>

      <indexterm>
	<primary>NTP</primary>
	<secondary>ntpd</secondary>
      </indexterm>

      <para>&os; verwendet den &man.ntpd.8;-NTP-Server, um die genaue
	Uhrzeit von anderen NTP-Servern abzufragen, die eigene
	Systemzeit zu setzen, oder um diese anderen Rechnern
	anzubieten.</para>
    </sect2>

    <sect2>
      <title>Einen passenden NTP-Server ausw&auml;hlen</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>Serverwahl</secondary>
      </indexterm>

      <para>Um die Uhrzeit zu synchronisieren, m&uuml;ssen Sie sich mit
	einem NTP-Server verbinden.  Ihr Netzwerkadministrator oder Ihr
	Internetprovider haben vielleicht schon einen NTP-Server
	eingerichtet.  Lesen Sie deren Dokumentation, um dies zu
	&uuml;berpr&uuml;fen.  Es gibt eine
	<ulink url="http://www.eecis.udel.edu/~mills/ntp/servers.html">
	Liste mit frei zug&auml;nglichen NTP-Servern</ulink>, aus der
	Sie sich einen in Ihrer N&auml;he gelegenen Server
	ausw&auml;hlen k&ouml;nnen.  Beachten Sie aber auf jeden Fall
	die Nutzungsbedingungen des entsprechenden Servers, und fragen
	Sie um Erlaubnis, wenn dies n&ouml;tig ist.</para>

      <para>Die Auswahl von mehreren NTP-Servern kann sinnvoll sein,
	wenn ein Server ausf&auml;llt oder falsche Zeiten liefert.
	&man.ntpd.8; verwendet die Antworten anderer Server, um
	zuverl&auml;ssige Server zu bestimmen, die dann bevorzugt
	abgefragt werden.</para>
    </sect2>

    <sect2>
      <title>NTP unter &os; einrichten</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>Konfiguration</secondary>
      </indexterm>

      <sect3>
	<title>NTP aktivieren</title>

	<indexterm><primary>ntpdate</primary></indexterm>

	<para>Wenn Sie Ihre Uhrzeit nur beim Systemstart
	  synchronisieren wollen, k&ouml;nnen Sie &man.ntpdate.8;
	  verwenden.  F&uuml;r Desktoprechner, die regelm&auml;&szlig;ig
	  neu gestartet werden und keine st&auml;ndige Synchronisation
	  ben&ouml;tigen, ist dies akzeptabel.  In allen anderen
	  F&auml;llen sollten Sie jedoch &man.ntpd.8; verwenden.</para>

	<para>Die Ausf&uuml;hrung von &man.ntpdate.8; w&auml;hrend des
	  Systemstarts ist aber auch f&uuml;r Rechner, die &man.ntpd.8;
	  verwenden, sinnvoll.  &man.ntpd.8; passt die Systemzeit nur
	  bei gr&ouml;&szlig;eren Abweichungen an, w&auml;hrend
	  &man.ntpdate.8; die Zeit immer synchronisiert, egal wie
	  gro&szlig; die Differenz zwischen Systemzeit und korrekter
	  Zeit ist.</para>

	<para>Um &man.ntpdate.8; beim Systemstart zu aktivieren,
	  f&uuml;gen Sie den Eintrag
	  <literal>ntpdate_enable="YES"</literal> in
	  <filename>/etc/rc.conf</filename> ein.  Au&szlig;erdem m&uuml;ssen
	  Sie alle Server, mit denen Sie sich synchronisieren wollen,
	  sowie alle an &man.ntpdate.8; zu &uuml;bergebenden Optionen
	  in den <varname>ntpdate_flags</varname> angeben.</para>
      </sect3>

      <sect3>
	<indexterm>
	  <primary>NTP</primary>
	  <secondary>ntp.conf</secondary>
	</indexterm>

	<title>NTP einrichten</title>

	<para>Die Konfiguration von NTP erfolgt &uuml;ber die Datei
	  <filename>/etc/ntp.conf</filename>, und wird in der
	  Hilfeseite &man.ntp.conf.5; beschrieben.  Dazu ein
	  einfaches Beispiel:</para>

	<programlisting>server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift</programlisting>

	<para>Die Option <literal>server</literal> legt die zu
	  verwendenden Server fest, wobei jeder Server in einer eigenen
	  Zeile steht.  Wenn ein Server mit der Option
	  <literal>prefer</literal> versehen ist, wie dies hier bei
	  <hostid role="fqdn">ntplocal.example.com</hostid> der Fall
	  ist, wird dieser Server bevorzugt verwendet.  Eine Antwort von
	  einem bevorzugten Server wird nur dann verworfen, wenn sie
	  signifikant von denen anderer Server abweicht, ansonsten wird
	  sie ohne Abfrage weiterer Server verwendet.  Die Option
	  <literal>prefer</literal> wird gew&ouml;hnlich nur f&uuml;r
	  sehr zuverl&auml;ssige und genaue Server verwendet, die
	  &uuml;ber spezielle Hardware zur Zeit&uuml;berwachung
	  verf&uuml;gen.</para>

	<para>Die Option <literal>driftfile</literal> legt fest, in
	  welcher Datei die Abweichungen der Systemuhr protokolliert
	  werden.  &man.ntpd.8; verwendet diese Datei, um die Systemzeit
	  automatisch anzupassen, selbst wenn kurzzeitig kein NTP-Server
	  zur Synchronisation verf&uuml;gbar ist.</para>

	<para>Weiterhin legt die Option <literal>driftfile</literal> fest,
	  wo Informationen &uuml;ber fr&uuml;here Antworten des von
	  Ihnen verwendeten NTP-Servers gespeichert werden sollen.
	  Diese Datei enth&auml;lt NTP-interne Informationen, sie sollte
	  daher von anderen Prozessen nicht ver&auml;ndert werden.</para>
      </sect3>

      <sect3>
	<title>Den Zugang zu Ihrem NTP-Server beschr&auml;nken</title>

	<para>In der Voreinstellung ist Ihr NTP-Server f&uuml;r alle
	  Rechner im Internet erreichbar.  &Uuml;ber die Option
	  <literal>restrict</literal> in der Datei
	  <filename>/etc/ntp.conf</filename> k&ouml;nnen Sie den
	  Zugang zu Ihrem Server beschr&auml;nken.</para>

	<para>Wenn Sie alle Rechner vom Zugriff auf Ihren NTP-Server
	  ausschlie&szlig;en wollen, f&uuml;gen Sie folgende Zeile in
	  <filename>/etc/ntp.conf</filename> ein:</para>

	<programlisting>restrict default ignore</programlisting>

	<para>Wenn Sie nur Rechnern Ihres eigenen Netzwerks die
	  Synchronisation mit Ihrem NTP-Server erlauben, gleichzeitig
	  aber verhindern wollen, dass diese den NTP-Server
	  konfigurieren oder als Server f&uuml;r andere Rechner dienen
	  k&ouml;nnen, f&uuml;gen Sie folgende Zeile ein:</para>

	<programlisting>restrict 192.168.1.0 mask 255.255.255.0 notrust nomodify notrap</programlisting>

	<para>Bei <hostid role="ipaddr">192.168.1.0</hostid> handelt es
	  sich um einen Rechner Ihres Netzwerks.
	  <hostid role="netmask">255.255.255.0</hostid> ist die
	  Netzmaske Ihres Netzwerks.</para>

	<para><filename>/etc/ntp.conf</filename> kann verschiedene
	  <literal>restrict</literal>-Optionen enthalten.
	  Weiteres erfahren Sie im Abschnitt
	  <literal>Access Control Support</literal> der
	  Hilfeseite &man.ntp.conf.5;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Den NTP-Server starten</title>

      <para>Damit der NTP-Server beim Systemstart automatisch gestartet
	wird, f&uuml;gen Sie den Eintrag
	<literal>xntpd_enable="YES"</literal> in
	<filename>/etc/rc.conf</filename> ein.  Wenn Sie weitere
	Argumente an &man.ntpd.8; &uuml;bergeben wollen, passen Sie
	die Option <varname>xntpd_flags</varname> in der Datei
	<filename>/etc/rc.conf</filename> entsprechend an.</para>

      <para>Um den NTP-Server ohne einen Systemneustart zu starten,
	rufen Sie <command>ntpd</command> mit den unter
	<varname>xntpd_flags</varname> in
	<filename>/etc/rc.conf</filename> festgelegten Parametern auf.
	Hierzu ein Beispiel:</para>

      <screen>&prompt.root; <userinput>ntpd -p /var/run/ntpd.pid</userinput></screen>

      <note><para>Unter &os;&nbsp;5.X wurden verschiedene Optionen in
	<filename>/etc/rc.conf</filename> umbenannt.  Daher
	m&uuml;ssen Sie alle Vorkommen von <literal>xntpd</literal>
	durch <literal>ntpd</literal> ersetzen.</para></note>
    </sect2>

    <sect2>
      <title>ntpd mit einer Einwahlverbindung verwenden</title>

      <para>&man.ntpd.8; ben&ouml;tigt keine st&auml;ndige
	Internetverbindung.  Wenn Sie sich ins Internet einw&auml;hlen,
	ist es sinnvoll, zu verhindern, dass NTP-Verkehr eine Verbindung
	aufbauen oder aufrechterhalten kann.  Wenn Sie user-PPP
	verwenden, k&ouml;nnen Sie dies in den
	<literal>filter</literal>-Direktiven von
	<filename>/etc/ppp/ppp.conf</filename> festlegen.  Sehen Sie
	sich dazu das folgende Beispiel ein:</para>

      <programlisting>set filter dial 0 deny udp src eq 123
# Prevent NTP traffic from initiating dial out
set filter dial 1 permit 0 0
set filter alive 0 deny udp src eq 123
# Prevent incoming NTP traffic from keeping the connection open
set filter alive 1 deny udp dst eq 123
# Prevent outgoing NTP traffic from keeping the connection open
set filter alive 2 permit 0/0 0/0</programlisting>

      <para>Weitere Informationen finden Sie im Abschnitt
	<literal>PACKET FILTERING</literal> von &man.ppp.8; sowie in den
	Beispielen unter <filename>/usr/share/examples/ppp/</filename>.</para>

      <note><para>Einige Internetprovider blockieren Ports mit niedrigen
	Nummern.  In solchen F&auml;llen funktioniert NTP leider
	nicht, da Antworten eines NTP-Servers Ihren Rechner nicht
	erreichen werden.</para></note>
    </sect2>

    <sect2>
      <title>Weitere Informationen</title>

      <para>Weiterf&uuml;hrende Dokumentation (im HTML-Format)
	zum NTP-Server finden Sie unter
	<filename>/usr/share/doc/ntp/</filename>.</para>
    </sect2>
  </sect1>

  <sect1 id="network-natd">
    <title>NATD &ndash; Network Address Translation Daemon</title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/network-natd.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>

  <sect1 id="network-inetd">
    <title>inetd <quote>Super-Server</quote></title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/network-inetd.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>

  <sect1 id="network-plip">
    <title>PLIP &ndash; Parallel Line IP</title>

    <indexterm><primary>PLIP</primary></indexterm>

    <indexterm><primary>Parallel Line IP</primary></indexterm>

    <para>PLIP erm&ouml;glicht TCP/IP-Verbindungen zwischen zwei
      Rechnern, die &uuml;ber ihre parallelen Schnittstellen
      verbunden sind.  Eine solche Verbindung ist n&uuml;tzlich,
      wenn zwei Rechner nicht mit Netzkarten ausgestattet sind,
      oder wenn eine Installation auf einem Laptop erfolgen soll.
      Dieser Abschnitt behandelt folgende Themen:</para>

    <itemizedlist>
      <listitem>
	<para>Die Herstellung eines parallelen (Laplink-) Kabels</para>
      </listitem>

      <listitem>
	<para>Die Verbindung von zwei Computern &uuml;ber PLIP</para>
      </listitem>
    </itemizedlist>

    <sect2 id="network-create-parallel-cable">
      <title>Ein paralleles Kabel herstellen</title>

      <para>Ein paralleles (Laplink-)Kabel k&ouml;nnen Sie in fast jedem
	Computergesch&auml;ft kaufen.  Falls dies nicht m&ouml;glich
	sein sollte, oder Sie einfach wissen wollen, wie ein solches
	Kabel aufgebaut ist, sollten Sie sich die folgende Tabelle
	ansehen.  Sie beschreibt die Herstellung eines parallelen
	Netzwerkkabels aus einem gew&ouml;hnlichen parallelen
	Druckerkabel.</para>

      <table>
	<title>Die Netzwerk-Verdrahtung eines parallelen Kabels</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>A-Name</entry>

	      <entry>A-Ende</entry>

	      <entry>B-Ende</entry>

	      <entry>Beschreibung</entry>

	      <entry>Post/Bit</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literallayout>DATA0
-ERROR</literallayout></entry>

	      <entry><literallayout>2
15</literallayout></entry>

	      <entry><literallayout>15
2</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA1
+SLCT</literallayout></entry>

	      <entry><literallayout>3
13</literallayout></entry>

	      <entry><literallayout>13
3</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA2
+PE</literallayout></entry>

	      <entry><literallayout>4
12</literallayout></entry>

	      <entry><literallayout>12
4</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA3
-ACK</literallayout></entry>

	      <entry><literallayout>5
10</literallayout></entry>

	      <entry><literallayout>10
5</literallayout></entry>

	      <entry>Strobe</entry>

	      <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA4
BUSY</literallayout></entry>

	      <entry><literallayout>6
11</literallayout></entry>

	      <entry><literallayout>11
6</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
	    </row>

	    <row>
	      <entry>GND</entry>

	      <entry>18-25</entry>

	      <entry>18-25</entry>

	      <entry>GND</entry>

	      <entry>-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2 id="network-plip-setup">
      <title>PLIP einrichten</title>

      <para>Als Erstes ben&ouml;tigen Sie ein Laplink-Kabel.  Danach
	m&uuml;ssen Sie sicherstellen, dass beide Computerkernel den
	&man.lpt.4;-Treiber unterst&uuml;tzen:</para>

      <screen>&prompt.root; <userinput>grep lp /var/run/dmesg.boot</userinput>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</screen>

      <para>Der Parallelport muss Interrupt-gesteuert sein, daher
	sollte Ihre Kernelkonfigurationsdatei unter &os;&nbsp;4.X eine
	Zeile &auml;hnlich der folgenden enthalten:</para>

      <programlisting>device ppc0 at isa? irq 7</programlisting>

      <para>Unter &os;&nbsp;5.X sollte die Datei
	<filename>/boot/device.hints</filename> hingegen folgende Zeilen
	enthalten:</para>

      <programlisting>hint.ppc.0.at="isa"
hint.ppc.0.irq="7"</programlisting>

      <para>Danach &uuml;berpr&uuml;fen Sie, ob die
	Kernelkonfigurationsdatei die Zeile
	<literal>device plip</literal> enth&auml;lt, oder ob das
	Kernelmodul <filename>plip.ko</filename> geladen wurde. In
	beiden F&auml;llen sollte die parallele Schnittstelle
	von &man.ifconfig.8; angezeigt werden.  Unter &os;&nbsp;4.X
	sieht die Ausgabe in etwa so aus:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0</userinput>
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <para>Unter &os;&nbsp;5.X erhalten Sie folgende Ausgabe:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <note><para>Die Ger&auml;tenamen der parallelen Schnittstelle
	sind f&uuml;r &os;&nbsp;4.X
	(<devicename>lp<replaceable>X</replaceable></devicename>)
	und &os;&nbsp;5.X
	(<devicename>plip<replaceable>X</replaceable></devicename>)
	unterschiedlich.</para></note>

      <para>Verbinden Sie die parallelen Schnittstellen der beiden
	Computer &uuml;ber das (Laplink-)Kabel.</para>

      <para>Konfigurieren Sie die Netzwerkparameter auf beiden Rechnern
	als <username>root</username>.  Wenn Sie beispielweise den Rechner
	<hostid>host1</hostid>, der unter &os;&nbsp;4.X l&auml;uft, mit
	dem unter &os;&nbsp;5.X laufenden Rechner <hostid>host2</hostid>
	verbinden wollen, gehen Sie folgenderma&szlig;en vor:</para>

      <programlisting>                 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</programlisting>

      <para>Richten Sie die parallele Schnittstelle von
	<hostid>host1</hostid> ein, indem Sie Folgendes eingeben:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0 10.0.0.1 10.0.0.2</userinput></screen>

      <para>Danach richten Sie die parallele Schnittstelle von
	<hostid>host2</hostid> ein:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.2 10.0.0.1</userinput></screen>

      <para>Sie sollten nun &uuml;ber eine funktionierende Verbindung
	verf&uuml;gen.  Bei Problemen lesen Sie bitte die Hilfeseiten
	&man.lp.4; sowie &man.lpt.4;.</para>

      <para>Zus&auml;tzlich sollten beide Rechner in
	<filename>/etc/hosts</filename> eingetragen werden:</para>

      <programlisting>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain</programlisting>

      <para>Um die Verbindung zu &uuml;berpr&uuml;fen, pingen Sie jeden
	Rechner vom anderen Rechner aus an.  Auf <hostid>host1</hostid>
	gehen Sie dazu folgenderma&szlig;en vor:</para>

	<screen>&prompt.root; <userinput>ifconfig lp0</userinput>
lp0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       lp0
&prompt.root; <userinput>ping -c 4 host2</userinput>
PING host2 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- host2 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>
    </sect2>
  </sect1>

  <sect1 id="network-ipv6">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Aaron</firstname>
          <surname>Kaplan</surname>
          <contrib>Beigetragen von </contrib>
         </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
          <contrib>&Uuml;berarbeitet und erweitert von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>IPv6 &ndash; Internet Protocol Version 6</title>

    <para>Bei IPv6 (auch als IPng oder
      <foreignphrase>IP next generation</foreignphrase>
      bekannt) handelt es sich um die neueste Version des bekannten
      IP-Protokolls (das auch als <acronym>IPv4</acronym> bezeichnet
      wird).  FreeBSD enth&auml;lt, genauso wie die anderen frei
      erh&auml;ltlichen BSD-Systeme, die IPv6-Referenzimplementation
      von <acronym>KAME</acronym>.  FreeBSD erf&uuml;llt damit bereits
      alle f&uuml;r die Nutzung von IPv6 n&ouml;tigen Voraussetzungen.
      Dieser Abschnitt konzentriert sich daher auf die Konfiguration
      und den Betrieb von IPv6.</para>

    <para>Anfang der 90er Jahre wurde man auf den stark steigenden
      Verbrauch von IPv4-Adressen aufmerksam.  Im Hinblick auf das
      Wachstums des Internets gab es zwei Hauptsorgen:</para>

    <itemizedlist>
      <listitem>
        <para>Die drohende Knappheit von IPv4-Adressen.  Dieses Problem
          konnte durch die Einf&uuml;hrung von privaten
          Adressr&auml;umen (mit Adressen wie
          <hostid role="ipaddr">10.0.0.0/8</hostid> oder
          <hostid role="ipaddr">192.168.0.0/24</hostid>) sowie der
          Entwicklung von <foreignphrase>Network Address
          Translation</foreignphrase> (<acronym>NAT</acronym>)
          weitestgehend entsch&auml;rft werden.</para>
      </listitem>

      <listitem>
        <para>Die immer gr&ouml;&szlig;er werdenden Eintr&auml;ge in
          Router-Tabellen.  Dieses Problem ist auch heute noch
          aktuell.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 ist in der Lage, diese, aber auch viele andere Probleme
      zu l&ouml;sen:</para>

    <itemizedlist>
      <listitem>
        <para>IPv6 hat einen 128&nbsp;Bit gro&szlig;en Adressraum. Es sind
          also theoretisch
          340.282.366.920.938.463.463.374.607.431.768.211.456 Adressen
          verf&uuml;gbar.  In anderen Worten: F&uuml;r jeden
          Quadratmeter der Erdoberfl&auml;che sind etwa
          6,67&nbsp;*&nbsp;10^27 IPv6-Adressen verf&uuml;gbar.</para>
      </listitem>

      <listitem>
        <para>Router speichern nur noch Netzwerk-Aggregationsadressen in
          Ihren Routingtabellen.  Dadurch reduziert sich die
          durchschnittliche Gr&ouml;&szlig;e  einer Routingtabelle auf
          8192&nbsp;Eintr&auml;ge.</para>
      </listitem>
    </itemizedlist>

    <para>Weitere n&uuml;tzliche Eigenschaften von IPv6 sind:</para>

    <itemizedlist>
      <listitem>
        <para>Die automatische Konfiguration von Adressen, die im
          <ulink url="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</ulink>
          beschrieben wird.</para>
      </listitem>

      <listitem>
        <para>Anycast-Adressen (<quote>eine-von-vielen</quote>)</para>
      </listitem>

      <listitem>
        <para>Verpflichtende Multicast-Adressen</para>
      </listitem>

      <listitem>
        <para>Die Unterst&uuml;tzung von IPsec (IP-Security)</para>
      </listitem>

      <listitem>
        <para>Eine vereinfachte Headerstruktur</para>
      </listitem>

      <listitem>
        <para>Mobile <acronym>IP</acronym>-Adressen</para>
      </listitem>

      <listitem>
        <para>Die Umwandlung von IPv4- in IPv6-Adressen</para>
      </listitem>
    </itemizedlist>

    <para>Weitere Informationsquellen:</para>

    <itemizedlist>
      <listitem>
        <para>Beschreibung von IPv6 auf
          <ulink url="http://playground.sun.com/pub/ipng/html/ipng-main.html">playground.sun.com</ulink>
        </para>
      </listitem>

      <listitem>
        <para><ulink url="http://www.kame.net">KAME.net</ulink></para>
      </listitem>

      <listitem>
        <para><ulink url="http://www.6bone.net">6bone.net</ulink></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Hintergrundinformationen zu IPv6-Adressen</title>

      <para>Es gibt verschiedene Arten von IPv6-Adressen: Unicast-,
        Anycast- und Multicast-Adressen.</para>

      <para>Unicast-Adressen sind die herk&ouml;mlichen Adressen. Ein
        Paket, das an eine Unicast-Adresse gesendet wird, kommt nur an
        der Schnittstelle an, die dieser Adresse zugeordnet ist.</para>

      <para>Anycast-Adressen unterscheiden sich in ihrer Syntax nicht
        von Unicast-Adressen, sie w&auml;hlen allerdings aus
	mehreren Schnittstellen eine Schnittstelle aus.
	Ein f&uuml;r eine Anycast-Adresse
	bestimmtes Paket kommt an der n&auml;chstgelegenen
	(entsprechend der Router-Metrik) Schnittstelle
        an.  Anycast-Adressen werden nur von Routern verwendet.</para>

      <para>Multicast-Adressen bestimmen Gruppen, denen mehrere
        Schnittstellen angeh&ouml;ren.  Ein
        Paket, das an eine Multicast-Adresse geschickt wird, kommt an
        allen Schnittstellen an, die zur Multicast-Gruppe geh&ouml;ren.</para>

        <note><para>Die von IPv4 bekannte Broadcast-Adresse
          (normalerweise
          <hostid role="ipaddr">xxx.xxx.xxx.255</hostid>) wird bei IPv6
          durch Multicast-Adressen verwirklicht.</para></note>

      <table>
        <title>Reservierte IPv6-Adressen:</title>

        <tgroup cols="4">
          <thead>
            <row>
              <entry>IPv6-Adresse</entry>
              <entry>Pr&auml;fixl&auml;nge</entry>
              <entry>Beschreibung</entry>
              <entry>Anmerkungen</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><hostid role="ip6addr">::</hostid></entry>
              <entry>128 Bit</entry>
              <entry>nicht festgelegt</entry>
              <entry>entspricht <hostid role="ipaddr">0.0.0.0</hostid>
                bei IPv4</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">::1</hostid></entry>
              <entry>128 Bit</entry>
              <entry>Loopback-Adresse</entry>
              <entry>entspricht <hostid role="ipaddr">127.0.0.1</hostid>
                bei IPv4</entry>
            </row>

            <row>
              <entry><hostid
                role="ip6addr">::00:xx:xx:xx:xx</hostid></entry>
              <entry>96 Bit</entry>
              <entry>Eingebettete IPv4-Adresse</entry>
              <entry>Die niedrigen 32&nbsp;Bit entsprechen der IPv4-Adresse.
                Wird auch als <quote>IPv4-kompatible IPv6-Adresse
                bezeichnet</quote>.</entry>
	    </row>

            <row>
              <entry><hostid
                role="ip6addr">::ff:xx:xx:xx:xx</hostid></entry>
              <entry>96 Bit</entry>
	      <entry>Eine auf IPv6 abgebildete IPv4-Adresse</entry>
              <entry>Die niedrigen 32&nbsp;Bit entsprechen der IPv4-Adresse.
                Notwendig f&uuml;r Rechner, die IPv6 nicht
                unterst&uuml;tzen.</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">fe80::</hostid> - <hostid
                role="ip6addr">feb::</hostid></entry>
              <entry>10 Bit</entry>
              <entry><foreignphrase>link-local</foreignphrase></entry>
              <entry>Entspricht der Loopback-Adresse bei IPv4</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">fec0::</hostid> - <hostid
                role="ip6addr">fef::</hostid></entry>
              <entry>10 Bit</entry>
              <entry><foreignphrase>site-local</foreignphrase></entry>
              <entry>&nbsp;</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">ff::</hostid></entry>
              <entry>8 Bit</entry>
              <entry>Multicast</entry>
              <entry>&nbsp;</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">001</hostid>
		(im Dualsystem)</entry>
              <entry>3 Bit</entry>
              <entry>Globaler Unicast</entry>
              <entry>Alle globalen Unicastadressen stammen aus diesem
                Pool.  Die ersten 3&nbsp;Bit lauten <quote>001</quote>.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2>
      <title>IPv6-Adressen verstehen</title>

      <para>Die kanonische Form von IPv6-Adressen lautet
        <hostid role="ip6addr">x:x:x:x:x:x:x:x</hostid>, jedes
        <quote>x</quote> steht dabei f&uuml;r einen
        16-Bit-Hexadezimalwert.  Ein Beispiel f&uuml;r eine IPv6-Adresse
        w&auml;re etwa
        <hostid
        role="ip6addr">FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</hostid>.</para>

      <para>Eine IPv6-Adresse enth&auml;lt oft Teilzeichenfolgen aus lauter
        Nullen.  Ein solcher Zeichenfolge kann zu <quote>::</quote>
        verk&uuml;rzt werden.  <hostid role="ip6addr">fe80::1</hostid>
        entspricht also der Adresse
        <hostid role="ip6addr">fe80:0000:0000:0000:0000:0000:0000:0001</hostid>.
      </para>

      <para>Eine weitere M&ouml;glichkeit ist die Darstellung der
        letzten 32&nbsp;Bit in  der bekannten (dezimalen) IPv4-Darstellung,
        bei der Punkte (<quote>.</quote>) zur Trennung verwendet werden.
        <hostid role="ip6addr">2002::10.0.0.1</hostid> ist also nur eine
        andere Schreibweise f&uuml;r die (hexadezimale) kanonische Form
        <hostid role="ip6addr">2002:0000:0000:0000:0000:0000:0a00:0001</hostid>,
        die wiederum der Adresse
        <hostid role="ip6addr">2002::a00:1</hostid> entspricht.</para>

      <para>Sie sollten nun in der Lage sein, die folgende Ausgabe zu
        verstehen:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput>
rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</screen>

      <para>Bei
        <hostid role="ip6addr">fe80::200:21ff:fe03:8e1%rl0</hostid>
        handelt es sich um eine automatisch konfigurierte
        <foreignphrase>link-local</foreignphrase>-Adresse.  Sie
        enth&auml;lt die (kodierte) Ethernet-MAC-Adresse als
        Folge der automatischen Konfiguration.</para>

      <para>Weitere Informationen zum Aufbau von IPv6-Adressen finden
        Sie im <ulink url="http://www.ietf.org/rfc/rfc3513.txt">
        RFC3513</ulink>.</para>
    </sect2>

    <sect2>
      <title>Eine IPv6-Verbindung herstellen</title>

      <para>Es gibt derzeit vier M&ouml;glichkeiten, sich mit anderen
        IPv6-Rechnern oder Netzwerken zu verbinden:</para>

      <itemizedlist>
        <listitem>
          <para>Die Teilnahme am experimentellen 6bone.</para>
        </listitem>

        <listitem>
          <para>Die Teilnahme am IPv6-Netzwerk Ihres Providers.
            Wenn Sie daran interessiert sind, wenden Sie sich an Ihren
            Provider.</para>
        </listitem>

        <listitem>
          <para>Die Verwendung eines 6-nach-4-Tunnels.</para>
        </listitem>

        <listitem>
          <para>Die Verwendung des Ports
            <filename>/usr/ports/net/freenet6</filename> bei der Einwahl
            ins Internet.</para>
        </listitem>
      </itemizedlist>

      <para>In diesem Abschnitt wird die Einrichtung einer Verbindung
        zum 6bone beschrieben, da dies derzeit der beliebteste Weg ist.</para>

      <para>Suchen Sie sich zuerst auf der Internetseite des
	<ulink url="http://www.6bone.net">6bone-Projekts</ulink>
	einen 6bone-Knoten in Ihrer N&auml;he.  Schreiben Sie an
	die verantwortliche Person und mit etwas Gl&uuml;ck erhalten
	Sie entsprechende Anweisungen, um Ihre Verbindung einzurichten.
	Dazu geh&ouml;rt &uuml;blicherweise die Einrichtung
	eines GRE-(gif)-Tunnels.</para>

      <para>Typischerweise wird ein  &man.gif.4;-Tunnels wie folgt
	eingerichtet:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput>
&prompt.root; <userinput>ifconfig gif0</userinput>
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>MY_IPv4_ADDR</replaceable>  <replaceable>HIS_IPv4_ADDR</replaceable></userinput>
&prompt.root; <userinput>ifconfig gif0 inet6 alias <replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable></userinput></screen>

      <para>Ersetzen Sie die in Gro&szlig;buchstaben geschriebenen
        Werte durch die Informationen, die Sie f&uuml;r Ihren
        6bone-Knoten erhalten haben.</para>

      <para>Die gezeigten Befehle bauen den Tunnel auf.
        &Uuml;berpr&uuml;fen Sie die korrekte Funktion, indem Sie
        <hostid role="ip6addr">ff02::1%gif0</hostid> an&man.ping6.8;en.
        Sie sollten zwei Antworten erhalten.</para>

      <note>
	<para>Bei <hostid role="ip6addr">ff02:1%gif0</hostid>
          handelt es sich um eine Multicast-Adresse.
          <literal>%gif0</literal> legt fest, dass die Multicast-Adresse
          der Schnittstelle <devicename>gif0</devicename> verwendet
          werden soll.  Da wir
          eine Multicast-Adresse ange&man.ping6.8;t haben, sollte der
          andere Endpunkt des Tunnels ebenfalls antworten.</para>
      </note>

      <para>Eine Route zu Ihrem 6bone-Knoten k&ouml;nnen Sie
	einfach wie folgt einrichten:</para>

      <screen>&prompt.root; <userinput>route add -inet6 default -interface gif0</userinput>
&prompt.root; <userinput>ping6 -n <replaceable>MY_UPLINK</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>traceroute6 www.jp.FreeBSD.org</userinput>
(3ffe:505:2008:1:2a0:24ff:fe57:e561) from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1  atnet-meta6  14.147 ms  15.499 ms  24.319 ms
     2  6bone-gw2-ATNET-NT.ipv6.tilab.com  103.408 ms  95.072 ms *
     3  3ffe:1831:0:ffff::4  138.645 ms  134.437 ms  144.257 ms
     4  3ffe:1810:0:6:290:27ff:fe79:7677  282.975 ms  278.666 ms  292.811 ms
     5  3ffe:1800:0:ff00::4  400.131 ms  396.324 ms  394.769 ms
     6  3ffe:1800:0:3:290:27ff:fe14:cdee  394.712 ms  397.19 ms  394.102 ms</screen>

      <para>Diese Ausgabe kann auf Ihrem Rechner unterschiedlich sein.
        Sie sollten aber jetzt die IPv6-Seite
        <ulink url="http://www.kame.net">www.kame.net</ulink> erreichen
        und die tanzende Schildkr&ouml;te sehen k&ouml;nnen &ndash;
        vorausgesetzt, Sie haben einen IPv6-f&auml;higen Browser wie
        <filename role="package">www/mozilla</filename> installiert.</para>
    </sect2>

    <sect2>
      <title>DNS in der IPv6-Welt</title>

      <para>Mit IPv6 werden zwei neue DNS-Eintr&auml;ge
        eingef&uuml;hrt:</para>

      <itemizedlist>
        <listitem>
          <para>AAAA-Eintr&auml;ge,</para>
        </listitem>

        <listitem>
          <para>A6-Eintr&auml;ge</para>
        </listitem>
      </itemizedlist>

      <para>Empfohlen wird die Verwendung von AAAA-Eintr&auml;gen.
        Weisen Sie die erhaltene IPv6-Adresse Ihrem Rechnernamen zu,
        indem Sie den Eintrag</para>

      <programlisting>MYHOSTNAME           AAAA    MYIPv6ADDR</programlisting>

      <para>in Ihre prim&auml;re DNS-Zonendatei einf&uuml;gen.  Falls
        Sie nicht f&uuml;r Ihre <acronym>DNS</acronym>-Zone
        verantwortlich sind, bitten Sie den daf&uuml;r
        Zust&auml;ndigen, diese &Auml;nderung durchzuf&uuml;hren.
        Die aktuellen Versionen von <application>bind</application>
        (Version&nbsp;8.3 oder 9) unterst&uuml;tzen AAAA-Eintr&auml;ge.</para>
    </sect2>
  </sect1>

  <sect1 id="network-atm">
    <title>ATM &ndash; Asynchronous Transfer Mode</title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.  Lesen Sie
      bitte <ulink
      url="http://www.FreeBSD.org/doc/en_US.ISO8859-1/books/handbook/network-atm.html">
      das Original in englischer Sprache</ulink>.</para>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
