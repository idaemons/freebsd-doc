<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/firewalls/chapter.xml,v 1.53 2012/04/30 16:15:52 bcr Exp $
     basiert auf: r39270
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="firewalls">
  <info><title>Firewalls</title>
    <authorgroup>
      <author><personname><firstname>Joseph J.</firstname><surname>Barbish</surname></personname><contrib>Beigetragen von </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Brad</firstname><surname>Davis</surname></personname><contrib>Nach SGML konvertiert und aktualisiert von </contrib></author>
    </authorgroup>
    <authorgroup>
      <author><personname><firstname>Michael</firstname><surname>Bunzel</surname></personname><contrib>Übersetzt von </contrib></author>
      <author><personname><firstname>Johann</firstname><surname>Kois</surname></personname></author>
      <author><personname><firstname>Benjamin</firstname><surname>Lukas</surname></personname></author>
    </authorgroup>

  </info>

  

  <indexterm><primary>firewall</primary></indexterm>

  <indexterm>
    <primary>security</primary>

    <secondary>firewalls</secondary>
  </indexterm>

  <sect1 xml:id="firewalls-intro">
    <title>Einführung</title>

    <para>Firewalls ermöglichen es, den ein- und ausgehenden
      Netzwerkverkehr eines Systems zu filtern.  Dazu verwendet eine
      Firewall eine oder mehrere Gruppen von <quote>Regeln</quote>,
      um ankommende Netzwerkpakete zu untersuchen und entweder
      durchzulassen oder zu blockieren.  Die Regeln einer
      Firewall untersuchen charakteristische Eigenschaften von
      Datenpaketen, darunter den Protokolltyp, die Quell- und
      Zieladresse sowie den Quell- und Zielport.</para>

    <para>Firewalls können die Sicherheit eines Rechners oder
      eines Netzwerks erhöhen, indem sie folgende Aufgaben
      übernehmen:</para>

    <itemizedlist>
      <listitem>
        <para>Den Schutz der Anwendungen, Dienste und Rechner eines
          internen Netzwerks vor unerwünschtem Datenverkehr
          aus dem Internet.</para>
      </listitem>

      <listitem>
        <para>Die Beschränkung des Zugriffs von Rechnern des
          internen Netzwerks auf Rechner oder Dienste des öffentlichen
          Internets.</para>
      </listitem>

      <listitem>
        <para>Den Einsatz von Network Address Translation
          (<acronym>NAT</acronym>), welches es durch die Verwendung
          von privaten <acronym>IP</acronym>-Adressen ermöglicht,
          eine einzige gemeinsame Internetverbindung für mehrere
          Rechner zu nutzen.  Dies geschieht entweder über eine
	  einzige <acronym>IP</acronym>-Adresse oder über eine Gruppe
	  von jeweils automatisch zugewiesenen öffentlichen
	  Adressen.</para>
      </listitem>
    </itemizedlist>

    <para>Das Basissystem von &os; enthält drei Firewalls:
      <application>PF</application>, <application>IPFW</application>
      und <application>IPFILTER</application> (auch als
      <application>IPF</application> bekannt).  &os; enthält ebenfalls
      zwei <foreignphrase>Traffic-Shaper</foreignphrase> zur Kontrolle
      der Bandbreite: &man.altq.4; und &man.dummynet.4;.
      <application>ALTQ</application> ist traditionell eng an
      <application>PF</application> gebunden, während
      <application>dummynet</application> zusammen mit
      <application>IPFW</application> verwendet wird.
      Gemeinsam ist allen Firewalls, dass sie Regeln einsetzen, um den
      Transfer von ein- und ausgehenden Datenpaketen des Systems
      zu steuern.  Unterschiedlich ist aber die Art und Weise, wie
      dies realisiert wird.  Auch die für diese Regeln verwendete
      Syntax ist unterschiedlich.</para>

    <para>&os; besitzt mehrere Firewalls, um den unterschiedlichen
      Anforderungen und Vorlieben von Benutzern gerecht zu werden.
      Jeder Benutzer sollte selbst beurteilen, welche Firewall seinen
      Bedürfnissen am besten entspricht.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie
      wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Wie man Paketfilterregeln erstellt.</para>
      </listitem>

      <listitem>
	<para>Was die Unterschiede zwischen den in &os; eingebauten
	  Firewalls sind.</para>
      </listitem>

      <listitem>
        <para>Wie die <application>PF</application>-Firewall
	  konfiguriert und einsetzt wird.</para>
      </listitem>

      <listitem>
        <para>Wie die <application>IPFW</application>-Firewall
	  konfiguriert und einsetzt wird.</para>
      </listitem>

      <listitem>
        <para>Wie die <application>IPFILTER</application>-Firewall
	  konfiguriert und einsetzt wird.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie:</para>

    <itemizedlist>
      <listitem>
        <para>Die grundlegenden Konzepte von &os; und dem Internet
          verstehen.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Da alle Firewalls auf der Inspektion ausgewählter
	Kontrollfelder in Datenpaketen basieren, muss für die
	Erstellung von Firewallregeln ein grundlegendes Verständnis
	von <acronym>TCP/IP</acronym> vorhanden sein.  Eine gute
	Einführung finden Sie in <link
	  xlink:href="http://www.ipprimer.com/overview.cfm">
	  Daryl's TCP/IP Primer</link>.</para>
    </note>
  </sect1>

  <sect1 xml:id="firewalls-concepts">
    <title>Firewallkonzepte</title>

    <indexterm>
      <primary>firewall</primary>
      <secondary>Regelsatz</secondary>
    </indexterm>

    <para>Ein Regelsatz besteht aus einer Gruppe von Regeln, die
      Pakete basierend auf ihren Inhalt entweder blockieren oder
      durchlassen.  Der bidirektionale Austausch von Paketen zwischen
      zwei Rechnern wird als Sitzung
      (<foreignphrase>Session</foreignphrase>) bezeichnet.  Der
      Regelsatz verarbeitet sowohl ankommende Pakete aus dem
      Internet, als auch die vom System erzeugten Antwortpakete.
      Jeder <acronym>TCP/IP</acronym>-Dienst hat ein festgelegtes
      Protokoll und einen vorgegebenen Port.  Pakete für einen
      bestimmten Dienst stammen von einer Quelladresse und einem
      unprivilegierten Port und gehen an einen spezifischen Port
      auf der Zieladresse.  Alle oben genannten Parameter können als
      Selektionskriterien verwendet werden, um einen Regelsatz zu
      erstellen, der den Zugriff auf bestimmte Dienste gewährt oder
      blockiert.</para>

    <para>Unbekannte Portnummern können Sie in
      <filename>/etc/services</filename> nachschlagen.
      Alternativ finden Sie die Portnummern und deren Verwendungszweck
      auf <link
	xlink:href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">
	http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</link>.</para>

    <para>Die Seite <link
	xlink:href="http://www.sans.org/security-resources/idfaq/oddports.php">
	http://www.sans.org/security-resources/idfaq/oddports.php</link>
      enthält eine Liste der Portnummern, die auch von Trojanern
      benutzt werden.</para>

    <para><acronym>FTP</acronym> hat zwei Modi:  Aktiv und Passiv.
      Unterschied liegt in der Bestimmung des Datenkanals.  Der
      Passiv-Modus ist sicherer, da der Datenkanal vom Client
      bestimmt wird.  Eine ausführliche Erklärung von
      <acronym>FTP</acronym> und den verschiedenen Modi finden Sie
      unter <link xlink:href="http://www.slacksite.com/other/ftp.html">
	http://www.slacksite.com/other.ftp.html</link>.</para>

    <para>Ein Firewall-Regelsatz kann entweder
      <quote>einschließend</quote> (<foreignphrase>inclusive
	firewall</foreignphrase>) oder <quote>ausschließend</quote>
      (<foreignphrase>exclusive Firewall</foreignphrase>) sein.  Eine
      ausschließende Firewall lässt jeden Datenverkehr durch, der
      nicht durch eine Regel ausgeschlossen wurde.  Eine
      einschließende Firewall macht das genaue Gegenteil.  Sie lässt
      Datenverkehr nur dann passieren, wenn dieser einer der
      definierten Regeln entspricht.</para>

    <para>Eine einschließende Firewall bietet eine wesentlich bessere
      Kontrolle des ausgehenden Verkehrs, was sie zur besseren Wahl
      für Systeme macht, welche Dienste für das Internet anbieten.
      Sie kontrolliert auch den Verkehr aus dem öffentlichen Internet
      zum privaten Netzwerk.  Jeder Verkehr, der keiner Regel
      entspricht wird geblockt und protokolliert.  Einschließende
      Firewalls sind generell sicherer als ausschließende Firewalls,
      da sie das Risiko, dass unerwünschter Verkehr hindurch geht,
      drastisch reduzieren.</para>

    <note>
      <para>Wenn nicht anders vermerkt, verwenden alle Konfigurationen
	und Regelsätze in diesem Kapitel einschließende
	Firewalls.</para>
    </note>

    <para>Die Sicherheit kann durch den Einsatz einer
      <quote>zustandsorientierten Firewall</quote>
      (<foreignphrase>stateful firewall</foreignphrase>) weiter
      erhöht werden.  Dieser Typ Firewall überwacht alle offenen
      Verbindungen und erlaubt nur Datenverkehr von bereits
      bestehenden Verbindungen oder wenn eine neue Verbindung
      aufgebaut wird.</para>

    <para>Eine zustandsorientierte Firewall behandelt den Verkehr
      als einen bidirektionalen Austausch von Paketen während einer
      Session.  Wenn ein Zustand für eine passende Regel angegeben
      wird, erstellt die Firewall dynamisch interne Regeln für jedes
      Paket, das während dieser Session ausgetauscht wird.  Die
      Firewall hat ausreichend Möglichkeiten, um zu bestimmen, ob ein
      Paket zu einer Session gehört.  Alle Pakete, die nicht zu dieser
      Session passen, werden automatisch abgelehnt.</para>

    <para>Sobald die Session beendet ist, wird sie aus der
      dynamischen Zustandstabelle entfernt.</para>

    <para>Eine zustandsorientierte Filterung erlaubt es, sich auf die
      Sperrung bzw. Freigabe von neuen Sessions zu konzentrieren.
      Wenn eine neue Session genehmigt wird, werden alle nachfolgenden
      Pakete dieser Session automatisch erlaubt und betrügerische
      Pakete werden automatisch abgelehnt.  Wenn eine neue Session
      nicht genehmigt wird, werden alle nachfolgenden Pakete dieser
      Session abgelehnt.  Die zustandsorientierte Filterung bietet
      fortgeschrittene Fähigkeiten zur Abwehr von verschiedensten
      Angriffsmethoden, die von Angreifern eingesetzt werden.</para>

    <para><acronym>NAT</acronym> steht für <emphasis>Network Address
	Translation</emphasis>.  Die <acronym>NAT</acronym>-Funktion
      ermöglicht es einem privaten <acronym>LAN</acronym> hinter einer
      Firewall, sich eine einzelne vom <acronym>ISP</acronym>
      zugewiesene <acronym>IP</acronym>-Adresse zu teilen, auch wenn
      die Adresse dynamisch zugewiesen wird.  <acronym>NAT</acronym>
      ermöglicht den Internetzugriff für jeden Rechner im
      <acronym>LAN</acronym>, ohne dass der <acronym>ISP</acronym> für
      mehrere Internet-Konten bezahlt wird.</para>

    <para><acronym>NAT</acronym> übersetzt automatisch die private
      <acronym>IP</acronym>-Adresse auf die öffentliche
      <acronym>IP</acronym>-Adresse, sobald ein Paket für das
      öffentliche Internet die Firewall passiert.  Zusätzlich führt es
      auch die Übersetzung der Anwortpakete durch.</para>

    <para>Gemäß RFC 1918 sind die folgenden
      <acronym>IP</acronym>-Adressbereiche für private Netzwerke
      reserviert und werden nie ins öffentliche Internet
      weitergeleitet.  Daher sind diese Bereiche für den Einsatz
      mit <acronym>NAT</acronym> geeignet:</para>

    <itemizedlist>
      <listitem>
	<para><literal>10.0.0.0/8</literal></para>
      </listitem>

      <listitem>
	<para><literal>172.16.0.0/12</literal></para>
      </listitem>

      <listitem>
	<para><literal>192.168.0.0/16</literal></para>
      </listitem>
    </itemizedlist>

    <warning>
      <para>Seien Sie <emphasis>äußerst vorsichtig</emphasis> wenn Sie
	mit Firewallregeln arbeiten.  Durch eine falsche Konfiguration
	kann der Administrator den Zugriff auf den Server verlieren.
	Um auf der sicheren Seite zu sein, sollten Sie die anfängliche
	Konfiguration der Firewall von der lokalen Konsole
	durchführen, anstatt dass Sie dies aus der Ferne über
	<application>ssh</application> tun.</para>
    </warning>
  </sect1>

  <sect1 xml:id="firewalls-pf">
    <info>
      <title>PF</title>

      <authorgroup>
        <author>
	  <personname>
	    <firstname>John</firstname>
	    <surname>Ferrell</surname>
	  </personname>
	  <contrib>Überarbeitet und aktualisiert von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>firewall</primary>

      <secondary>PF</secondary>
    </indexterm>

    <para>In &os;&nbsp;5.3 wurde <application>PF</application> von
      OpenBSD in das Basissystem integriert.  Bei
      <application>PF</application> handelt es sich um eine komplette,
      voll ausgestattete Firewall, die optional auch
      <application>ALTQ</application> (Alternatives Queuing)
      unterstützt.  <application>ALTQ</application> stellt
      <foreignphrase>Quality of Service</foreignphrase>
      (<acronym>QoS</acronym>) zur Verfügung.</para>

    <para>Das OpenBSD-Projekt pflegt die maßgebliche Referenz von
      <application>PF</application> in der <link
	xlink:href="http://www.openbsd.org/faq/pf">PF FAQ</link>.
      Peter Hansteen betreut ein sehr ausführliches
      <application>PF</application>-Tutorial unter <link
	xlink:href="http://home.nuug.no/~peter/pf/">
	http://home.nuug.no/~peter/pf/</link>.</para>

    <warning>
      <para>Bedenken Sie beim Studium der <link
	xlink:href="http://www.openbsd.org/faq/pf/">PF FAQ</link>,
	dass &os; die <application>PF</application>-Version aus
	OpenBSD&nbsp;4.5 enthält.</para>
    </warning>

    <para>Die &a.pf; ist ein guter Anlaufpunkt für Fragen zur
      Konfiguration und dem Einsatz der
      <application>PF</application>-Firewall.  Überprüfen Sie
      aber zunächst die Archive der Mailingliste, bevor Sie eine
      Frage stellen.  Vielleicht wurde die Frage dort schon
      beantwortet.</para>

    <para>Weitere Informationen über die Portierung von
      <application>PF</application> nach &os; finden Sie unter <link
	xlink:href="http://pf4freebsd.love2party.net/">
	http://pf4freebsd.love2party.net/</link>.</para>

    <para>Dieser Abschnitt konzentriert sich auf
      <application>PF</application> in &os;.  Es wird beschrieben, wie
      <application>PF</application> und
      <application>ALTQ</application> aktiviert werden.  Anschließend
      wird demonstriert, wie Regelsätze auf einem &os;-System erstellt
      werden.</para>

    <sect2>
      <title><application>PF</application> aktivieren</title>

      <para>Damit <application>PF</application> benutzt werden kann,
	muss zunächst das Kernelmodul geladen werden.  Dieser
	Abschnitt beschreibt die Einträge für
	<filename>/etc/rc.conf</filename>, die verwendet werden können
	um <application>PF</application> zu aktivieren.</para>

      <para>Beginnen Sie mit folgender Zeile in
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>pf_enable="YES"</programlisting>

      <para>&man.pfctl.8; beschreibt zusätzliche Optionen, die beim
	Start an <application>PF</application> übergeben werden
	können.  Fügen Sie diesen Eintrag in
	<filename>/etc/rc.conf</filename> hinzu und schreiben Sie die
	benötigten Optionen zwischen die Anführungszeichen:</para>

      <programlisting>pf_flags=""                     # additional flags for pfctl startup</programlisting>

      <para><application>PF</application> kann nicht gestartet werden,
	wenn es seine Konfigurationsdatei nicht findet.  In der
	Voreinstellung existiert bereits ein Regelsatz namens
	<filename>/etc/pf.conf</filename>.  Wenn bereits ein Regelsatz
	an anderer Stelle gespeichert wurde, fügen Sie in
	<filename>/etc/rc.conf</filename> einen Eintrag mit dem
	vollständigen Pfad zur Datei ein:</para>

      <programlisting>pf_rules="<replaceable>/path/to/pf.conf</replaceable>"</programlisting>

      <para>Protokollierungsfunktionen für
	<application>PF</application> werden von &man.pflog.4; zur
	Verfügung gestellt.  Fügen Sie folgende Zeile in
	<filename>/etc/rc.conf</filename> ein, um diese Funktion zu
	aktivieren:</para>

      <programlisting>pflog_enable="YES"</programlisting>

      <para>Die folgenden Zeilen können ebenfalls hinzugefügt werden,
	um den Speicherort der Protokolldatei zu bestimmen und weitere
	Optionen beim Start an &man.pflog.4; zu übergeben:</para>

      <programlisting>pflog_logfile="/var/log/pflog"  # where pflogd should store the logfile
pflog_flags=""                  # additional flags for pflogd startup</programlisting>

      <para>Falls ein <acronym>LAN</acronym> hinter der Firewall
	existiert und die Pakete an die Rechner im
	<acronym>LAN</acronym> weitergeleitet werden müssen, oder
	wenn <acronym>NAT</acronym> benötigt wird, fügen Sie die
	folgende Option hinzu:</para>

      <programlisting>gateway_enable="YES"            # Enable as LAN gateway</programlisting>

      <para>Nachdem die Änderungen gespeichert wurden, kann
        <application>PF</application> mit Unterstützung für
	Protokollierung gestartet werden:</para>

      <screen>&prompt.root; <userinput>service pf start</userinput>
&prompt.root; <userinput>service pflog start</userinput></screen>

<!--
This is no longer true as of 9.x. It also references the CARP section
which doesn't explain how to use it...At some point it should.
      <indexterm>$
	<primary>kernel options</primary>
	<secondary>device pf</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>
	<secondary>device pflog</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>
	<secondary>device pfsync</secondary>
      </indexterm>

      <note>
	<para>While it is not necessary to compile
	  <application>PF</application> support into the &os; kernel,
	  some advanced features are not included, namely &man.pfsync.4;, which is a
	  pseudo-device that exposes certain changes to the state table
	  used by <application>PF</application>.  It can be paired with
	  &man.carp.4; to create failover firewalls using
	  <application>PF</application>.  More information on
	  <acronym>CARP</acronym> can be found in <xref linkend="carp"/>.</para>

	<para>The following <application>PF</application> kernel options
	  are available:</para>

	<programlisting>device pf
device pflog
device pfsync</programlisting>

	<para>where:</para>

	<para><literal>device pf</literal> enables PF support.</para>

	<para><literal>device pflog</literal> enables the optional
	  &man.pflog.4; pseudo network device which can be used to log
>>>>>>>>  traffic to a &man.bpf.4; descriptor.  The &man.pflogd.8;
>>>>>>>>  daemon can then be used to store the logging information to
>>>>>>>>  disk.</para>

	<para><literal>device pfsync</literal> enables the optional
	  &man.pfsync.4; pseudo-network device that is used to monitor
	  <quote>state changes</quote>.</para>
      </note>
-->

      <para>In der Voreinstellung liest <application>PF</application>
	seine Konfiguration aus <filename>/etc/pf.conf</filename> und
	modifiziert, verwirft oder akzeptiert Pakete anhand der
	Definitionen in dieser Datei.  &os; enthält mehrere
	Beispieldateien unter
	<filename>/usr/share/examples/pf/</filename>.  Auch die
	<link xlink:href="http://www.openbsd.org/faq/pf/">PF
	  FAQ</link> enthält sehr ausführliche Beispiele für
	<application>PF</application>-Regeln.</para>

      <para>Zur Steuerung von <application>PF</application> wird
	<command>pfctl</command> verwendet.  <xref linkend="pfctl"/>
	fasst einige nützliche Optionen für diesen Befehl zusammen.
	Eine Beschreibung aller verfügbaren Optionen finden Sie in
	&man.pfctl.8;.</para>

      <table xml:id="pfctl" frame="none" pgwide="1">
	<title>Nützliche <command>pfctl</command> Optionen</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Kommando</entry>
	      <entry>Aufgabe</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><command>pfctl -e</command></entry>
	      <entry><application>PF</application> aktivieren</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -d</command></entry>
	      <entry><application>PF</application>
		deaktivieren</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -F all -f
		  /etc/pf.conf</command></entry>
	      <entry>Alle Filterregeln zurücksetzen
		(<acronym>NAT</acronym>, Filter, Zustandstabelle) und
		<filename>/etc/pf.conf</filename> erneut
		einlesen.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -s [ rules | nat |
		  states ]</command></entry>
	      <entry>Zusammenfassung der Filterregeln,
		<application>NAT</application>-Regeln, oder der
		Zustandstabelle.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -vnf
		  /etc/pf.conf</command></entry>
	      <entry>Überprüft <filename>/etc/pf.conf</filename> auf
		Fehler, lädt aber die Filterregeln nicht neu.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <tip>
	<para><package>security/sudo</package> ist nützlich um
	  Kommandos mit erhöhten Berechtigungen auszuführen, wie
	  beispielsweise <command>pfctl</command>.  Das Programm kann
	  aus der Ports-Sammlung installiert werden.</para>
      </tip>

      <para>Um den ein- und ausgehenden Verkehr im Auge zu behalten,
	können Sie ein Werkzeug wie <package>sysutils/pftop</package>
	benutzen.  Sobald das Programm installiert ist, können Sie
	<application>pftop</application> ausführen, um einen Snapshot
	des Datenverkehrs zu sehen.  Das Format der Ausgabe ist der
	von &man.top.1; sehr ähnlich.</para>
    </sect2>

    <sect2>
      <title><application>ALTQ</application> aktivieren</title>

      <para>Unter &os; kann <application>ALTQ</application> zusammen
	mit <application>PF</application> benutzt werden, um Quality
	of Service (<acronym>QoS</acronym>) bereitzustellen.  Sobald
	<application>ALTQ</application> aktiviert ist, können
	Warteschlangen definiert werden, mit denen Sie die Priorität
	für ausgehende Pakete festlegen können.</para>

      <para>Bevor Sie <application>ALTQ</application> aktivieren,
	sollten Sie &man.altq.4; lesen und sicherstellen, das der
	Treiber der Netzwerkkarte diese Funktion unterstützt.</para>

      <para><application>ALTQ</application> steht nicht als ladbares
	Kernelmodul zur Verfügung.  Wenn die Netzwerkkarte des Systems
	<application>ALTQ</application> unterstützt, erstellen Sie
	nach den Anweisungen in <xref linkend="kernelconfig"/> einen
	angepassten Kernel.  Als erstes muss
	<application>ALTQ</application> aktiviert werden.  Zudem ist
	mindestens eine weitere Option nötig, um den Algorithmus für
	die Warteschlange zu bestimmen:</para>

      <programlisting>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Schedule (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</programlisting>

      <para>Die folgenden Algorithmen stehen zur Verfügung:</para>

      <variablelist>
	<varlistentry>
	  <term>CBQ</term>
	  <listitem>
	    <para>Class Based Queuing (<acronym>CBQ</acronym>) erlaubt
	    es, die Bandbreite einer Verbindung in verschiedene
	    Klassen oder Warteschlangen zu unterteilen, um die
	    Priorität von Datenpaketen basierend auf Filterregeln zu
	    beeinflussen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RED</term>
	  <listitem>
	    <para>Random Early Detection (<acronym>RED</acronym>) wird
	      eingesetzt, um eine Überlastung des Netzwerks zu
	      vermeiden.  Dazu ermittelt <acronym>RED</acronym> die
	      Größe der Warteschlange und vergleicht diesen Wert mit
	      den minimalen und maximalen Grenzwerten der
	      Warteschlange.  Ist die Warteschlange größer als das
	      erlaubte Maximum, werden alle neuen Pakete nach dem
	      Zufallsprinzip verworfen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RIO</term>
	  <listitem>
	    <para>Random Early Detection In and Out
	      (<acronym>RIO</acronym>).  Dieser Modus verwaltet
	      mehrere Warteschlangen durchschnittlicher Größe mit
	      mehreren Schwellwerten, eine für jedes
	      <acronym>QoS</acronym>-Level.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>HFSC</term>
	  <listitem>
	    <para>Hierachical Fair Service Curve Packet Scheduler
	      (<acronym>HFSC</acronym>) wird in <link
		xlink:href="http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html">
		http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</link>
	      beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>PRIQ</term>
	  <listitem>
	    <para>Priority Queuing (<acronym>PRIQ</acronym>) lässt den
	      Verkehr einer Warteschlange mit höherer Priorität zuerst
	      durch.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Weitere Informationen über diese Algorithmen und Beispiele
	für Regelsätze finden Sie unter <link
	  xlink:href="http://www.openbsd.org/faq/pf/queueing.html">
	  http://www.openbsd.org/faq/pf/queueing.html</link>.</para>
    </sect2>

    <sect2 xml:id="pf-tutorial">
      <info>
	<title><application>PF</application> Regelsätze</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Peter</firstname>
	      <surname>Hansteen</surname>
	      <othername>N. M.</othername>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Dieser Abschnitt beschreibt die Erstellung von angepassten
	Regelsätzen.  Es wird mit dem einfachsten Regelsatz begonnen
	auf dem dann weitere aufgebaut werden, um die
	Konzepte und Funktionen von <application>PF</application> an
	einigen konkreten Beispielen zu verdeutlichen.</para>

      <para>Der einfachste Regelsatz gilt für einen Rechner, der
	keine Dienste anbietet und Zugriff auf das Internet haben
	soll.  Für diesen minimalen Regelsatz wird
	<filename>/etc/pf.conf</filename> wie folgt
	konfiguriert:</para>

      <programlisting>block in all
pass out all keep state</programlisting>

      <para>Die erste Regel blockiert jeglichen eingehenden
	Datenverkehr.  Die zweite Regel erlaubt ausgehende
	Verbindungen von diesem Rechner, während die
	Zustandsinformationen dieser Verbindungen gespeichert werden.
	Diese Zustandsinformationen machen es möglich, den
	Antwortverkehr für diese Verbindungen zu erlauben.  Der
	Regelsatz wird mit dem folgenden Befehl geladen:</para>

      <screen>&prompt.root; <userinput>pfctl -e ; pfctl -f /etc/pf.conf</userinput></screen>

      <para>Neben den Zustandsinformationen verfügt
	<application>PF</application> über
	<firstterm>Listen</firstterm> und
	<firstterm>Makros</firstterm>.  Diese können bei der
	Erstellung der Regeln definiert werden.  Makros können Listen
	enthalten und sie müssen vor ihrer ersten Benutzung definiert
	sein.  Fügen Sie beispielsweise folgende Zeilen an den Anfang
	des Regelsatzes:</para>

      <programlisting>tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"</programlisting>

      <para><application>PF</application> versteht sowohl Portnamen
	als auch Portnummern, solange die Namen in
	<filename>/etc/services</filename> aufgeführt sind.  Dieses
	Beispiel erstellt zwei Makros.  Das erste ist eine Liste mit
	sieben <acronym>TCP</acronym>-Portnamen, die zweite Liste
	enthält einen <acronym>UDP</acronym>-Portnamen.  Sobald ein
	Makro definiert ist, kann es in den Regeln verwendet werden.
	In diesem Beispiel wird der gesamte Datenverkehr geblockt, mit
	Ausnahme der Verbindungen die von diesem Rechner initiiert
	wurden und sich auf einen der angegebenen
	<acronym>TCP</acronym>-Dienste oder den
	<acronym>UDP</acronym>-Dienst beziehen:</para>

      <programlisting>tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</programlisting>

      <para>Obwohl <acronym>UDP</acronym> als zustandsloses Protokoll
	betrachtet wird, ist <application>PF</application> in der Lage
	einige Zustandsinformationen zu verfolgen.  Wenn
	beispielsweise eine <acronym>UDP</acronym>-Abfrage für einen
	Nameserver das System verlässt, wird
	<application>PF</application> nach der Antwort Ausschau halten
	und das Antwortpaket durch lassen.</para>

      <para>Nachdem der Regelsatz verändert wurde, muss er neu geladen
	werden:</para>

      <screen>&prompt.root; <userinput>pfctl -f /etc/pf.conf</userinput></screen>

      <para>Wenn keine Syntaxfehler festgestellt werden, wird
	<command>pfctl</command> keine Ausgabe erzeugen.  Die Syntax
	kann auch getestet werden, bevor der Regelsatz geladen
	wird:</para>

      <screen>&prompt.root; <userinput>pfctl -nf /etc/pf.conf</userinput></screen>

      <para>Die Option <option>-n</option> bewirkt, dass die Regeln
	nur interpretiert, jedoch nicht geladen werden.  Dies bietet
	die Möglichkeit, alle Fehler zu korrigieren.  Es wird immer
	der letzte gültige Regelsatz geladen, bis
	<application>PF</application> entweder deaktiviert, oder ein
	neuer Regelsatz geladen wird.</para>

      <tip>
	<para>Wenn Sie beim Laden oder Prüfen des Regelsatzes noch die
	  Option <option>-v</option> hinzufügen, wird
	  <command>pfctl</command> den komplett interpretierten
	  Regelsatz anzeigen.  Dies ist äußerst nützlich, wenn Sie
	  versuchen Fehler im Regelsatz zu finden.</para>
      </tip>

      <sect3 xml:id="pftut-gateway">
	<title>Einfaches Gateway mit <acronym>NAT</acronym></title>

	<para>Dieser Abschnitt zeigt wie ein &os;-System mit
	  <application>PF</application> als Gateway konfiguriert wird.
	  Das Gateway muss über mindestens zwei Netzwerkkarten
	  verfügen, die jeweils mit einem separaten Netzwerk verbunden
	  sind.  In diesem Beispiel ist <filename>xl1</filename> mit
	  dem Internet verbunden und <filename>xl0</filename> ist mit
	  dem internen Netzwerk verbunden.</para>

	<para>Aktivieren Sie zunächst das Gateway, damit der Rechner
	  den Netzwerkverkehr von einer Schnittstelle zur nächsten
	  weiterleiten kann.  Diese
	  <application>sysctl</application>-Einstellung sorgt dafür,
	  dass <acronym>IPv4</acronym>-Pakete weitergeleitet
	  werden:</para>

	<screen>&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	<para>So leiten Sie <acronym>IPv6</acronym>-Datenverkehr
	  weiter:</para>

	<screen>&prompt.root; <userinput>sysctl net.inet6.ip6.forwarding=1</userinput></screen>

	<para>Um diese Einstellungen beim Systemstart zu aktivieren,
	  fügen Sie folgende Zeilen in
	  <filename>/etc/rc.conf</filename> ein:</para>
	
	<programlisting>gateway_enable="YES"		#für ipv4
ipv6_gateway_enable="YES"	#für ipv6</programlisting>

	<para>Prüfen Sie mit <command>ifconfig</command>, dass beide
	  Schnittstellen vorhanden und aktiv sind.</para>

	<para>Als nächstes erstellen Sie die nötigen
	  <application>PF</application>-Regeln, damit das Gateway den
	  Datenverkehr weiterleiten kann.  Die folgende Regel erlaubt
	  den zustandsorientierten Verkehr aus dem Internet zu den
	  Rechnern im Netzwerk:</para>

	<programlisting>pass in on xl1 from xl1:network to xl0:network port $ports keep state</programlisting>

	<para>Diese Regel erlaubt lediglich den Datenverkehr über das
	  Gateway auf der internen Schnittstelle.  Damit die Pakete
	  noch weiter gehen, wird eine passende Regel benötigt:</para>

	<programlisting>pass out on xl0 from xl1:network to xl0:network port $ports keep state</programlisting>

	<para>Obwohl diese beiden Regeln funktionieren, werden sie
	  in der Praxis so spezifisch selten benötigt.  Ein lesbarer
	  Regelsatz ist oft ein sicherer Regelsatz.  Der Rest dieses
	  Abschnitts zeigt, wie Sie die Regeln so einfach und lesbar
	  wie möglich halten.  Zum Beispiel könnten die beiden Regeln
	  zu einer Regel zusammengefasst werden:</para>

	<programlisting>pass from xl1:network to any port $ports keep state</programlisting>

	<para>Die Notation <literal>interface:network</literal> kann
	  durch ein Makro ersetzt werden, um den Regelsatz besser
	  lesbar zu machen.  Zum Beispiel könnte für das Netzwerk an
	  der internen Schnittstelle (<literal>xl0:network</literal>)
	  ein Makro namens <literal>$localnet</literal> definiert
	  werden.  Alternativ könnte für die Definition von
	  <literal>$localnet</literal> auch eine
	  <emphasis>IP-Adresse/Netzmaske</emphasis> Notation verwendet
	  werden, um ein Netzwerk zu bezeichnen, beispielsweise
	  <literal>192.168.100.1/24</literal> für ein privates
	  Subnetz.</para>

	<para>Bei Bedarf kann für <literal>$localnet</literal> auch
	  eine Liste von Netzwerken definiert werden.  Abhängig von
	  den Bedürfnissen kann <literal>$localnet</literal> auch für
	  eine typische Regel wie folgt verwendet werden:</para>

	<programlisting>pass from $localnet to any port $ports keep state</programlisting>

	<para>Der folgende Regelsatz erlaubt sämtlichen Verkehr, der
	  von den Rechnern im internen Netzwerk initiiert wird.
	  Zunächst werden zwei Makros definiert, die die externen und
	  internen 3COM-Schnittstellen repräsentieren.</para>

	<note>
	  <para>Bei Einwählverbindungen wird <filename>tun0</filename>
	    für die externe Schnittstelle verwendet.  Bei
	    <acronym>ADSL</acronym>-Verbindungen, insbesondere denen
	    die <acronym>PPP</acronym> over Ethernet
	    (<acronym>PPPoE</acronym>) verwenden, ist die richtige
	    externe Schnittstelle <filename>tun0</filename> und nicht
	    die physische Ethernet-Schnittstelle.</para>
	</note>

	<programlisting>ext_if = "xl0"	# macro for external interface - use tun0 for PPPoE
int_if = "xl1"	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</programlisting>

	<para>Dieser Regelsatz führt die <acronym>NAT</acronym>-Regel
	  ein, die verwendet wird, um die Übersetzung der
	  Netzwerkadressen von den nicht-routebaren Adressen im
	  internen Netzwerk auf die <acronym>IP</acronym>-Adresse der
	  externen Schnittstelle zu handhaben.  Die Klammern im
	  letzten Teil der <acronym>NAT</acronym>-Regel
	  <literal>($ext_if)</literal> werden angegeben, wenn die
	  <acronym>IP</acronym>-Adresse der externen Schnittstelle
	  dynamisch zugewiesen wird.  Damit wird sichergestellt, dass
	  der Netzwerkverkehr ohne schwerwiegende Unterbrechungen
	  weiterläuft, auch wenn sich die externe
	  <acronym>IP</acronym>-Adresse ändert.</para>

	<para>Beachten Sie, dass dieser Regelsatz wahrscheinlich mehr
	  Verkehr aus dem Netzwerk zulässt, als eigentlich nötig ist.
	  Bei einem angemessenen Aufbau könnte folgendes Makro
	  erstellt werden:</para>

	<programlisting>client_out = "{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }"</programlisting>

	<para>Dieses Makro wird dann in der Filterregel
	  benutzt:</para>

	<programlisting>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</programlisting>

	<para>Weitere <literal>pass</literal> Regeln werden
	  vielleicht noch benötigt.  Diese Regel aktiviert
	  <acronym>SSH</acronym> auf der externen
	  Schnittstelle:</para>

	<programlisting>pass in inet proto tcp to $ext_if port ssh</programlisting>

	<para>Dieses Makrodefinition und Regel erlaubt
	  <acronym>DNS</acronym> und <acronym>NTP</acronym> für
	  interne Clients:</para>

	<programlisting>udp_services = "{ domain, ntp }"
pass quick inet proto { tcp, udp } to any port $udp_services keep state</programlisting>

	<para>Beachten Sie das Schlüsselwort <literal>quick</literal>
	  in dieser Regel.  Da der Regelsatz aus mehreren Regeln
	  besteht, ist es wichtig, die Beziehungen zwischen den
	  einzelnen Regeln zu verstehen.  Die Regeln werden von oben
	  nach unten ausgewertet, in der Reihenfolge wie sie
	  geschrieben sind.  Für jedes Paket oder jede Verbindung, das
	  <application>PF</application> ausgewertet, wird die letzte
	  übereinstimmende Regel im Regelsatz angewendet.  Wenn jedoch
	  ein Paket auf eine Regel passt, welche das Schlüsselwort
	  <literal>quick</literal> enthält, wird das Paket
	  entsprechend dieser Regel behandelt und die
	  Regelverarbeitung wird gestoppt.  Diese Vorgehensweise ist
	  sehr nützlich, wenn eine Ausnahme von den allgemeinen Regeln
	  erforderlich ist.</para>
      </sect3>

      <sect3 xml:id="pftut-ftp">
	<title>Einen <acronym>FTP</acronym>-Proxy einrichten</title>

	<para>Die Konfiguration einer funktionierenden Regel für
	  <acronym>FTP</acronym> kann aufgrund der Beschaffenheit des
	  <acronym>FTP</acronym>-Protokolls problematisch sein.
	  <acronym>FTP</acronym> ist sehr viel älter als Firewalls
	  und schon vom Design her unsicher.  Die häufigsten Argumente
	  gegen eine Verwendung von <acronym>FTP</acronym>
	  sind:</para>
	
	<itemizedlist>
	  <listitem>
	    <para>Passwörter werden im Klartext übertragen.</para>
	  </listitem>

	  <listitem>
	    <para>Das Protokoll erfordert die Verwendung von
	      mindestens zwei <acronym>TCP</acronym>-Verbindungen
	      (Steuerung und Daten) auf separaten Ports.</para>
	  </listitem>

	  <listitem>
	    <para>Wenn eine Sitzung aufgebaut wird, werden die Daten
	      auf zufällig ausgewählten Ports übermittelt.</para>
	  </listitem>
	</itemizedlist>

	<para>All diese Punkte stellen Herausforderungen dar, noch
	  bevor die Client- oder Server-Software auf potenzielle
	  Sicherheitslücken überprüft wurde.  Es existieren aber auch
	  sichere Alternativen für die Dateiübertragung, wie
	  &man.sftp.1; oder &man.scp.1;, wo die Authentifizierung und
	  die Datenübertragung über eine verschlüsselte Verbindung
	  erfolgt.</para>

	<para>Für Situationen, in denen <acronym>FTP</acronym>
	  erforderlich ist, kann <application>PF</application> den
	  <acronym>FTP</acronym>-Datenverkehr an ein kleines
	  Proxy-Programm namens &man.ftp-proxy.8; weiterleiten.
	  Dieses Programm ist im Basissystem von &os; enthalten.  Die
	  Aufgabe des Proxies ist das dynamische Einfügen und
	  Entfernen von Regeln im Regelsatz.  Dies wird durch den
	  Einsatz von Ankern erreicht, damit der
	  <acronym>FTP</acronym>-Verkehr korrekt verarbeitet werden
	  kann.</para>

	<para>Fügen Sie folgende Zeilen in
	  <filename>/etc/rc.conf</filename> ein, um den Proxy zu
	  aktivieren:</para>

	<programlisting>ftpproxy_enable="YES"</programlisting>

	<para>Danach kann der Proxy mit <command>service ftp-proxy
	    start</command> gestartet werden.</para>

	<para>Für die Grundkonfiguration müssen drei weitere Einträge
	  in <filename>/etc/pf.conf</filename> hinzugefügt werden.
	  Zunächst werden die Anker hinzugefügt, die der Proxy für die
	  <acronym>FTP</acronym>-Sitzungen verwendet:</para>

	<programlisting>nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"</programlisting>

	<para>Dann wird eine <literal>pass</literal>-Regel benötigt,
	  damit der <acronym>FTP</acronym>-Datenverkehr durch den
	  Proxy geleitet werden kann.</para>

	<para>Die Regeln für Umleitung und <acronym>NAT</acronym>
	  müssen vor den eigentlichen Filterregeln definiert werden.
	  Fügen Sie diese <literal>rdr</literal>-Regel unmittelbar
	  nach der <acronym>NAT</acronym>-Regel ein:</para>

	<programlisting>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</programlisting>

	<para>Zum Schluss muss der umgeleitete Verkehr die Firewall
	  passieren dürfen:</para>
	
	<programlisting>pass out proto tcp from $proxy to any port ftp</programlisting>

	<para><literal>$poxy</literal> enthält die Adresse, an dem der
	  Proxy-Daemon gebunden ist.</para>

	<para>Speichern Sie <filename>/etc/pf.conf</filename> und
	  laden Sie die Regeln neu.  Prüfen Sie von einem Client, ob
	  die <acronym>FTP</acronym>-Verbindungen
	  funktionieren:</para>

	<screen>&prompt.root; <userinput>pfctl -f /etc/pf.conf</userinput></screen>

	<para>Dieses Beispiel umfasst eine Grundkonfiguration, in der
	  die Rechner im lokalen Netzwerk Zugriff auf entfernte
	  <acronym>FTP</acronym>-Server benötigen.  Diese
	  Konfiguration sollte mit den meisten
	  <acronym>FTP</acronym>-Clients und -Servern gut
	  funktionieren.  Das Verhalten von &man.ftp-proxy.8; kann
	  durch diverse Optionen in <literal>ftpproxy_flags</literal>
	  beeinflusst werden.  Einige Clients und Server haben
	  bestimmte Marotten, die bei der Konfiguration berücksichtigt
	  werden müssen.  Es kann zum Beispiel notwendig sein, den
	  <acronym>FTP</acronym>-Datenverkehr für den Proxy einer
	  bestimmten Warteschlange zuzuweisen.</para>

	<para>Es besteht auch die Möglichkeit einen
	  <acronym>FTP</acronym>-Server mit
	  <application>PF</application> und &man.ftp-proxy.8; zu
	  schützen.  Konfigurieren Sie einen separaten
	  <command>ftp-proxy</command> mit <option>-R</option> für den
	  Reverse-Modus auf einem separaten Port und einer eigenen
	  Umleitungsregel.</para>
      </sect3>

      <sect3 xml:id="pftut-icmp">
	<title><acronym>ICMP</acronym> verwalten</title>

	<para>Viele Werkzeuge zur Fehlerbehebung in
	  <acronym>TCP/IP</acronym>-Netzwerken verlassen sich auf das
	  <foreignphrase>Internet Control Message
	    Protocol</foreignphrase> (<acronym>ICMP</acronym>), das
	  speziell für diese Zwecke entwickelt wurde.</para>

	<para>Das <acronym>ICMP</acronym>-Protokoll sendet und
	  empfängt Kontrollnachrichten zwischen Rechnern und Gateways,
	  hauptsächlich um ungewöhnliche Bedingungen auf dem Weg zum
	  Zielrechner zu berichten.  Router verwenden
	  <acronym>ICMP</acronym> um Paketgrößen und andere
	  Übertragungsparameter zu ermitteln.  Dieser Prozess ist auch
	  als <emphasis>Path <acronym>MTU</acronym>
	    Discovery</emphasis> bekannt.</para>

	<para>Aus der Sicht einer Firewall sind einige
	  <acronym>ICMP</acronym>-Kontrollnachrichten anfällig für
	  bekannte Angriffsmethoden.  Zwar ist die Fehlerbehebung
	  einfacher, wenn alle <acronym>ICMP</acronym>-Pakete
	  bedingungslos durch gelassen werden, aber dass macht es auch
	  für Angreifer leichter, Informationen über das Netzwerk zu
	  extrahieren.  Aus diesen Gründen ist die folgende Regel nicht
	  optimal:</para>

	<programlisting>pass inet proto icmp from any to any</programlisting>

	<para>Eine Lösung besteht darin, nur den
	  <acronym>ICMP</acronym>-Verkehr aus dem lokalen Netz zu
	  akzeptieren, während <acronym>ICMP</acronym>-Pakete von
	  außerhalb des Netzwerks verworfen werden:</para>

	<programlisting>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</programlisting>

	<para>Es stehen noch weitere Optionen zur Verfügung, die die
	  Flexibilität von <application>PF</application>
	  demonstrieren.  Anstatt beispielsweise alle
	  <acronym>ICMP</acronym>-Nachrichten zu erlauben, kann man
	  die Nachrichten angeben, die von &man.ping.8; und
	  &man.traceroute.8; verwendet werden.  Beginnen Sie damit,
	  ein Makro für diese Art von Nachrichten zu
	  definieren:</para>

	<programlisting>icmp_types = "echoreq"</programlisting>

	<para>Erstellen Sie dann eine Regel, die das eben erstellte
	  Makro benutzt:</para>

	<programlisting>pass inet proto icmp all icmp-type $icmp_types keep state</programlisting>

	<para>Wenn weitere Arten von
	  <acronym>ICMP</acronym>-Nachrichten benötigt werden, kann
	  die Liste <literal>icmp_types</literal> einfach erweitert
	  werden.  Geben Sie <command>more
	    /usr/src/contrib/pf/pfctl/pfctl_parser.c</command> ein, um
	  eine Liste der von <application>PF</application>
	  unterstützten <acronym>ICMP</acronym>-Nachrichten zu sehen.
	  Die Webseite <link
	    xlink:href="http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml">
	    http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</link>
	  enthält eine Erklärung für jeden Nachrichtentyp.</para>

	<para>Da &unix; <command>traceroute</command> in der
	  Voreinstellung <acronym>UDP</acronym> verwendet, wird eine
	  weitere Regel benötigt:</para>

	<programlisting># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</programlisting>

	<para>Da <command>TRACERT.EXE</command> unter
	  &microsoft.windows;-Systemen <acronym>ICMP</acronym> Echo
	  Request Meldungen verwendet, ist nur die erste Regel
	  notwendig um Traces für solche Systeme zu ermöglichen.
	  &unix; <command>traceroute</command> kann aber auch andere
	  Protokolle verwenden, zum Beispiel <acronym>ICMP</acronym>
	  Echo Request, wenn der Schalter <option>-I</option> benutzt
	  wird.  Details finden Sie in &man.traceroute.8;.</para>
	
	<sect4 xml:id="pftut-pathmtudisc">
	  <title>Path <acronym>MTU</acronym> Discovery</title>

	  <para>Internet-Protokolle sind so ausgelegt, dass sie
	    geräteunabhängig sind.  Eine Folge davon ist, dass die
	    optimale Paketgröße nicht immer zuverlässig vorhergesagt
	    werden kann.  Das größte Hindernis ist hier die
	    <emphasis>Maximum Transmission Unit</emphasis>
	    (<literal>MTU</literal>), welche die Obergrenze für die
	    Paketgröße festlegt.  Die <acronym>MTU</acronym> für die
	    Schnittstelle des Systems können Sie sich mit
	    <command>ifconfig</command> anzeigen lassen.</para>

	  <para><acronym>TCP/IP</acronym> benutzt ein Verfahren, das
	    als <foreignphrase>path MTU discovery</foreignphrase>
	    bekannt ist, um die korrekte Paketgröße für eine
	    Verbindung zu bestimmen.  Dieses Verfahren sendet Pakete
	    unterschiedlicher Größe mit dem Flag <quote>do not
	      fragment</quote> und erwartet ein
	    <acronym>ICMP</acronym>-Antwortpaket vom Typ
	    <quote>type 3, code 4</quote>, wenn die Obergrenze
	    erreicht worden ist.  Typ 3 bedeutet <quote>Ziel nicht
	      erreichbar</quote> und Code 4 ist die Abkürzung für
	    <quote>Fragmentierung nötig, aber Do-not-Fragment Flag ist
	      gesetzt</quote>.  Um <foreignphrase>path MTU
	      discovery</foreignphrase> zu erlauben und damit
	    Verbindungen zu anderen <acronym>MTU</acronym>s zu
	    unterstützen, fügen Sie dem Makro
	    <literal>icmp_types</literal> den Typ <literal>destination
	      unreachable</literal> hinzu:</para>

	  <programlisting>icmp_types = "{ echoreq, unreach }"</programlisting>

	  <para>Da die <literal>pass</literal>-Regel bereits das Makro
	    verwendet, braucht es nicht geändert werden um den neuen
	    <acronym>ICMP</acronym>-Typ zu unterstützen:</para>

	  <programlisting>pass inet proto icmp all icmp-type $icmp_types keep state</programlisting>

	  <para><application>PF</application> kann alle Variationen
	    von <acronym>ICMP</acronym>-Typen und Codes filtern.  Eine
	    Liste der verfügbaren Typen und Codes ist in &man.icmp.4;
	    und &man.icmp6.4; dokumentiert.</para>
	</sect4>
      </sect3>

      <sect3 xml:id="pftut-tables">
	<title>Tabellen benutzen</title>

	<para>Manchmal sind bestimmte Daten für die Filterung und
	  Weiterleitung interessant, jedoch wäre eine Definition einer
	  solchen Filterregel für einen Regelsatz viel zu lang.
	  <application>PF</application> unterstützt die Verwendung von
	  Tabellen.  Dies sind definierte Listen, die verändert werden
	  können, ohne den gesamten Regelsatz neu laden zu müssen.
	  Zudem können diese Listen sehr schnell durchsucht werden.
	  Tabellennamen sind immer in <literal>&lt; &gt;</literal>
	  eingeschlossen und sehen wie folgt aus:</para>

	<programlisting>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</programlisting>

	<para>In diesem Beispiel ist das Netzwerk
	  <literal>192.168.2.0/24</literal> Teil der Tabelle.
	  <literal>192.168.2.5</literal> wurde im dem Operator
	  <literal>!</literal> ausgeschlossen und ist somit nicht Teil
	  der Tabelle.  Es ist auch möglich Tabellen aus Dateien zu
	  laden, wo jeder Eintrag in einer separaten Zeile steht.
	  Dieses Beispiel verwendet dazu die Datei
	  <filename>/etc/clients</filename>:</para>

	<programlisting>192.168.2.0/24
!192.168.2.5</programlisting>

	<para>Um sich auf diese Datei zu beziehen, definieren Sie die
	  Tabelle wie folgt:</para>

	<programlisting>table &lt;clients&gt; persist file "/etc/clients"</programlisting>

	<para>Sobald die Tabelle definiert ist, kann eine Filterregel
	  Bezug darauf nehmen:</para>

	<programlisting>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</programlisting>

	<para>Die Inhalte einer Tabelle können mit
	  <command>pfctl</command> direkt verändert werden.  Dieses
	  Beispiel fügt ein weiteres Netzwerk zur Tabelle
	  hinzu:</para>

	<screen>&prompt.root; <userinput>pfctl -t clients -T add 192.168.1.0/16</userinput></screen>

	<para>Beachten Sie, dass auf diese Weise vorgenommene
	  Änderungen direkt übernommen werden, jedoch bei einem
	  Neustart des Systems oder bei einem Stromausfall verloren
	  gehen.  Um die Änderungen dauerhaft zu speichern, müssen sie
	  in der Definition der Tabelle oder in der Datei, auf die
	  sich die Tabelle bezieht, bearbeitet werden.  Mit einem
	  &man.cron.8; Job und einem Befehl wie
	  <command>pfctl -t clients -T show &gt;/etc/clients</command>
	  können Sie auch eine Kopie der Tabelle auf Platte speichern
	  und dann in regelmäßigen Abständen aktualisieren.
	  Alternativ kann <filename>/etc/clients</filename> auch mit
	  den Tabelleneinträgen, die sich aktuell im Speicher
	  befinden, aktualisiert werden.</para>

	<screen>&prompt.root; <userinput>pfctl -t clients -T replace -f /etc/clients</userinput></screen>
      </sect3>

      <sect3 xml:id="pftut-overload">
	<title>Verwendung von Tabellen zum Schutz von
	  <acronym>SSH</acronym></title>

	<para>Benutzer, die <acronym>SSH</acronym> auf einer externen
	  Schnittstelle ausführen, haben wahrscheinlich schon einmal
	  ähnliche Meldungen in den Protokolldateien gesehen:</para>

	<programlisting>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</programlisting>

	<para>Diese Meldungen deuten auf einen Brute-Force-Angriff
	  hin, bei dem ein Angreifer oder ein Programm versucht,
	  den Benutzernamen und das Passwort zu erraten, um Zugriff
	  auf das System zu bekommen.</para>

	<para>Wenn der Zugriff über <acronym>SSH</acronym> für
	  berechtigte Benutzer erforderlich ist, kann eine Änderung
	  des Standard-Ports für <acronym>SSH</acronym> einen gewissen
	  Schutz bieten.  Allerdings bietet
	  <application>PF</application> eine elegantere Lösung für
	  dieses Problem.  <literal>pass</literal>-Regeln können
	  Einschränkungen für Dinge enthalten, die ein verbindender
	  Rechner tun kann.  Bei einem Verstoß gegen diese
	  Einschränkungen kann dann dem betroffenen Rechner der
	  Zugriff teilweise oder ganz entzogen werden.  Es ist sogar
	  möglich, alle bestehenden Verbindungen zu trennen, falls die
	  Grenze überschritten wird.</para>

	<para>Um dies zu konfigurieren, erstellen Sie folgende Tabelle
	  im Regelsatz:</para>

	<programlisting>table &lt;bruteforce&gt; persist</programlisting>

	<para>Fügen Sie dann ziemlich am Anfang der Filterregeln
	  folgende Regeln hinzu, um die Brute-Force-Angriffe zu
	  blocken und gleichzeitig berechtigte Verbindungen zu
	  erlauben:</para>

	<programlisting>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn <replaceable>100</replaceable>, max-src-conn-rate <replaceable>15/5</replaceable>, \
    overload &lt;bruteforce&gt; flush global)</programlisting>

	<para>Der Teil in Klammern definiert die Grenzwerte.  Die
	  Zahlen sollten an die lokalen Anforderungen angepasst
	  werden.  Die Zeilen können wie folgt interpretiert
	  werden:</para>

	<para><literal>max-src-conn</literal> definiert die maximal
	  erlaubte Anzahl gleichzeitiger Verbindungen von einem
	  Rechner.</para>

	<para><literal>max-src-conn-rate</literal> definiert die
	  maximal erlaubte Anzahl neuer Verbindungen eines einzelnen
	  Rechners (<replaceable>15</replaceable>) pro Anzahl von
	  Sekunden (<replaceable>5</replaceable>).</para>

	<para><literal>overload &lt;bruteforce&gt;</literal> bedeutet,
	  dass jeder Rechner, der diesen Grenzwert überschreitet, zur
	  Tabelle <literal>bruteforce</literal> hinzugefügt wird.
	  Diese Filterregel blockiert jeglichen Datenverkehr von
	  Adressen aus der Tabelle
	  <literal>bruteforce</literal>.</para>

	<para><literal>flush global</literal> besagt, dass alle
	  (<literal>global</literal>) Verbindungen dieses Rechners
	  getrennt (<literal>flush</literal>) werden, wenn der
	  Grenzwert erreicht wird.</para>

	<note>
	  <para>Diese Filterregeln helfen nicht bei langsamen
	    Brute-Force-Angriffen, wie sie in <link
	      xlink:href="http://home.nuug.no/~peter/hailmary2013/">
	      http://home.nuug.no/~peter/hailmary2013/</link>
	    beschrieben sind.</para>
	</note>

	<para>Dieser Beispielregelsatz dient lediglich als
	  Illustration.  Wenn Sie allgemein eine große Anzahl an
	  Verbindungen erlauben wollen, aber gleichzeitig
	  bei <acronym>SSH</acronym> etwas restriktiver vorgehen
	  möchten, können Sie die obige Regel ergänzen:</para>

	<programlisting>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</programlisting>

	<note>
	  <!-- XXX Overloaders == agressive Rechner -->
	  <title>Es ist möglicherweise nicht notwendig, alle
	    aggressiven Rechner zu blockieren</title>

	  <para>Es ist zu erwähnen, dass der
	    <literal>overlaod</literal>-Mechanismus eine allgemeine
	    Technik darstellt, die nicht auf <acronym>SSH</acronym>
	    beschränkt ist.  Außerdem ist es nicht immer optimal,
	    Datenverkehr von aggressiven Rechnern zu
	    blockieren.</para>

	  <para>Eine <literal>overload</literal>-Regel kann
	    beispielsweise benutzt werden, um einen Mail- oder
	    Webserver zu schützen.  Die
	    <literal>overload</literal>-Tabelle könnte dann in einer
	    Regel verwendet werden, um aggressive Rechner einer
	    Warteschlange mit geringerer Bandbreite zuzuweisen, oder
	    den Rechner auf eine bestimtme Webseite umzuleiten.</para>
	</note>

	<para>Im Laufe der Zeit werden die Tabellen durch die
	  <literal>overload</literal>-Regeln immer größer und belegen
	  immer mehr Speicher.  Manchmal wird eine geblockte
	  <acronym>IP</acronym>-Adresse einem Rechner dynamisch
	  zugewiesen, der eigentlich berechtigt ist, mit den Rechnern
	  im lokalen Netzwerk zu kommunizieren.</para>

	<para>Für solche Situationen bietet <command>pfctl</command>
	  die Möglichkeit, Tabelleneinträge auslaufen zu lassen.
	  Dieses Kommando würde beispielsweise Einträge aus der
	  Tabelle <literal>&lt;bruteforce&gt;</literal> löschen,
	  die seit <literal>86400</literal> Sekunden nicht mehr
	  referenziert wurden:</para>

	<screen>&prompt.root; <userinput>pfctl -t bruteforce -T expire 86400</userinput></screen>

	<para>Eine ähnliche Funktionalität bietet
	  <package>security/expiretable</package>, welches Einträge
	  entfernt, die für einen bestimmten Zeitraum nicht
	  referenziert wurden.</para>

	<para>Nach der Installation kann
	  <application>expiretable</application> benutzt werden, um
	  Einträge aus der Tabelle
	  <literal>&lt;bruteforce&gt;</literal> nach einer bestimmten
	  Zeit zu entfernen.  Dieses Beispiel entfernt alle Einträge,
	  die älter sind als 24 Stunden:</para>

	<programlisting>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</programlisting>
      </sect3>

      <sect3 xml:id="pftut-spamd">
	<title>Schutzt vor <acronym>SPAM</acronym></title>

	<para>Im Gegensatz zum <application>spamd</application>-Daemon
	  von <application>spamassassin</application>, kann
	  <package>mail/spamd</package> zusammen mit
	  <application>PF</application> den <acronym>SPAM</acronym>
	  direkt an der Firewall abwehren.  Dieser
	  <application>spamd</application> wird in
	  <application>PF</application> über einen Satz von
	  Umleitungen konfiguriert.</para>

	<para>Spammer neigen dazu, eine große Anzahl von Nachrichten
	  zu versenden.  Dabei nutzten Sie
	  <acronym>SPAM</acronym>-freundliche Netzwerke und gekaperte
	  Rechner, welche dann ziemlich schnell bei sogenannten
	  <foreignphrase>Blacklists</foreignphrase> gemeldet
	  werden.</para>

	<para>Wenn eine <acronym>SMTP</acronym>-Verbindung von einer
	  Adresse in der Blacklist empfangen wird, präsentiert
	  <application>spamd</application> einen Banner und schaltet
	  sofort in einen Modus, in dem die Antworten auf den
	  <acronym>SMTP</acronym>-Verkehr jeweils ein Byte groß sind.
	  Diese Technik, die möglichst viel Zeit des Spammers
	  verschwenden soll, wird
	  <foreignphrase>Tarpitting</foreignphrase> genannt. Die
	  spezifische Implementierung, welche ein Byte
	  <acronym>SMTP</acronym>-Antworten verwendet, wird als
	  <foreignphrase>Stuttering</foreignphrase> bezeichnet.</para>

	<para>Dieses Beispiel zeigt das grundlegende Verfahren zur
	  Konfiguration von <application>spamd</application> mit
	  automatisch aktualisierten Blacklists.  Für weitere
	  Informationen lesen die Manualpages, die zusammen mit
	  <package>mail/spamd</package> installiert werden.</para>

	<procedure>
	  <title>Konfiguration von
	    <application>spamd</application></title>

	  <step>
	    <para>Installieren Sie das Paket oder den Port
	      <package>mail/spamd</package>.  Um
	      <application>spamd</application>'s Greylisting-Funktion
	      zu nutzen, muss &man.fdescfs.5; in
	      <filename>/dev/fd</filename> eingehängt werden.  Fügen
	      Sie folgende Zeile in <filename>/etc/fstab</filename>
	      ein:</para>

	    <programlisting>fdescfs /dev/fd fdescfs rw 0 0</programlisting>

	    <para>Danach hängen Sie das Dateisystem ein:</para>

	    <screen>&prompt.root; <userinput>mount fdescfs</userinput></screen>
	  </step>

	  <step>
	    <para>Fügen Sie folgende Zeilen in den
	      <application>PF</application>-Regelsatz ein:</para>

	    <programlisting>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</programlisting>

	    <para>Die beiden Tabellen <literal>&lt;spamd&gt;</literal>
	      und <literal>&lt;spam-white&gt;</literal> sind von
	      großer Bedeutung.  <acronym>SMTP</acronym>-Verkehr von
	      einer Adresse, die in <literal>&lt;spamd&gt;</literal>
	      aber nicht in <literal>&lt;spamd-white&gt;</literal>
	      ist, wird an den <application>spamd</application>-Daemon
	      auf Port 8025 umgeleitet.</para>
	  </step>

	  <step>
	    <para>Im nächsten Schritt wird
	      <application>spamd</application> in
	      <filename>/usr/local/etc/spamd.conf</filename>
	      konfiguriert und einige Parameter werden in
	      <filename>/etc/rc.conf</filename> hinzugefügt.</para>

	    <para>Die Installation von <package>mail/spamd</package>
	      enthält eine Beispielkonfiguration
	      (<filename>/usr/local/etc/spamd.conf.sample</filename>)
	      und eine Manualpage für <filename>spamd.conf</filename>.
	      Beziehen Sie sich für zusätzliche Konfigurationsoptionen
	      auf diese Dokumentation.</para>

	    <para>Die Konfigurationsdatei enthält einen Block, in dem
	      die <literal>all</literal>-Liste definiert ist, die
	      wiederum weitere Listen spezifiziert:</para>

	    <programlisting>all:\
    :traplist:whitelist:</programlisting>

	    <para>Dieser Eintrag fügt die gewünschten Blacklists,
	      getrennt durch einen Doppelpunkt (<literal>:</literal>),
	      hinzu.  Um auch eine Whitelist zu verwenden, fügen Sie
	      den Namen unmittelbar hinter dem Namen der Blacklist
	      ein.  Zum Beispiel:
	      <literal>:Blacklist:Whitelist:</literal>.</para>

	    <para>Danach folgt die Definition der verwendeten
	      Blacklist:</para>

	    <programlisting>traplist:\
    :black:\
    :msg="SPAM. Your address %A has sent spam within the last 24 hours":\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</programlisting>

	    <para>In der ersten Zeile steht der Name der Blacklist und
	      die zweite Zeile gibt den Typ an.  Das Feld
	      <literal>msg</literal> enthält die Nachricht, die dem
	      Absender während des <acronym>SMTP</acronym>-Dialogs
	      angezeigt wird.  Das Feld <literal>mehtod</literal> legt
	      fest, wie <application>spamd-setup</application> die
	      Listen bezieht; unterstützte Methoden sind
	      <literal>http</literal>, <literal>ftp</literal>,
	      <literal>file</literal> und ein externes Programm via
	      <literal>exec</literal>.  Im letzten Feld gibt
	      <literal>file</literal> den Namen der Datei an, die
	      <application>spamd</application> erwartet.</para>

	    <para>Die Definition der Whitelist ist ähnlich.  Das Feld
	      <literal>msg</literal> wird jedoch nicht definiert, da
	      eine Meldung hier nicht erforderlich ist:</para>

	    <programlisting>whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</programlisting>

	    <tip>
	      <title>Wählen Sie die Datenquellen mit Sorgfalt:</title>

	      <para>Bei der Verwendung von sämtlichen Blacklists aus
		der Beispieldatei <filename>spamd.conf</filename>
		würden große Teile des Internets geblockt.  Der
		Administrator muss diese Datei bearbeiten, um eine
		optimale Konfiguration zu erzielen.  Dazu gehört auch
		die Auswahl von geeigneten Blacklists und, wenn nötig,
		die Erstellung von benutzerdefinierten Listen.</para>
	    </tip>

	    <para>Als nächstes fügen Sie folgenden Eintrag in
	      <filename>/etc/rc.conf</filename> hinzu.  Zusätzliche
	      Optionen sind in der Manualpage beschrieben:</para>

	    <programlisting>spamd_flags="-v" # use "" and see spamd-setup(8) for flags</programlisting>

	    <para>Wenn Sie fertig sind, starten Sie
	      <application>spamd</application> durch die Eingabe von
	      <command>service obspamd start</command>.  Führen Sie
	      die weitere Konfiguration mit
	      <command>spamd-setup</command> durch.  Erstellen Sie zum
	      Schluss einen &man.cron.8;-Job, der
	      <command>spamd-setup</command> in regelmäßigen Abständen
	      aufruft, um die Listen zu aktualisieren.</para>
	  </step>
	</procedure>

	<para>Auf einem typischen Gateway vor dem Mailserver, werden
	  Rechner innerhalb von wenigen Minuten geblockt.</para>

	<para><application>PF</application> unterstützt auch
	  <firstterm>Greylisting</firstterm>, das Nachrichten von
	  unbekannten Rechnern vorübergehend mit
	  <replaceable>45n</replaceable>-Codes ablehnt.  Nachrichten
	  von diesen Rechnern werden bei einem erneuten Versuch nach
	  einer angemessenen Zeit durchgelassen.  Nachrichten von
	  Rechnern, die nach RFC 1123 und RFC 2821 konfiguriert sind,
	  werden sofort durchgelassen.</para>

	<para>Weitere Informationen über Greylisting finden Sie unter
	  <link xlink:href="http://www.greylisting.org/">
	  greylisting.org</link>.  Das Erstaunlichste an Greylisting
	  ist, neben der einfachen Benutzung, dass es immer noch
	  funktioniert.  Spammer und Malware-Autoren gelingt es
	  bislang nur schwer, diese Technik zu umgehen.</para>

	<para>Die grundsätzliche Vorgehensweise zur Konfiguration von
	  Greylisting ist wie folgt:</para>

	<procedure>
	  <title>Konfiguration von Greylisting</title>

	  <step>
	    <para>Stellen Sie sicher, dass &man.fdescfs.5; eingehängt
	      ist.  Dies wird in Schritt 1 der vorherigen Prozedur
	      beschrieben.</para>
	  </step>

	  <step>
	    <para>Um <application>spamd</application> im
	      Greylisting-Modus auszuführen, fügen Sie folgende Zeilen
	      in <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>spamd_grey="YES"  # use spamd greylisting if YES</programlisting>

	    <para>Lesen Sie die Manualpage von
	      <application>spamd</application> für Beschreibungen von
	      zusätzlichen Parametern.</para>
	  </step>

	  <step>
	    <para>Starten Sie die Dienste, um die Konfiguration von
	      Greylisting abzuschließen:</para>

	    <screen>&prompt.root; <userinput>service obspamd restart</userinput>
&prompt.root; <userinput>service spamlogd start</userinput></screen>
	  </step>
	</procedure>

	<para>Hinter den Kulissen führen die
	  <application>spamdb</application>-Datenbank und
	  <application>spamlogd</application> wesentliche Aufgaben der
	  Greylisting-Funktion aus.  <application>spamdb</application>
	  ist die Schnittstelle für den Administrator, der über den
	  Inhalt der Datenbank <filename>/var/db/spamdb</filename>
	  Blaklists, Whitelists und Greylists verwaltet.</para>
      </sect3>

      <sect3 xml:id="pftut-hygiene">
	<title>Netzwerk-Hygiene</title>

	<para>Dieser Abschnitt beschreibt die Verwendung von
	  <literal>block-policy</literal>, <literal>scrub</literal>
	  und <literal>antispoof</literal>, mit denen das Verhalten
	  des Regelsatzes weiter optimiert werden kann.</para>

	<para>Die Option <literal>block-policy</literal> kann im
	  Teil <literal>options</literal> des Regelwerks konfiguriert
	  werden, vor den Umleitungen und den eigentlichen
	  Filterregeln.  Diese Option legt fest, welche Rückmeldung
	  <application>PF</application> an einen geblockten Rechner
	  sendet.  Es existieren zwei mögliche Werte:
	  <literal>drop</literal> verwirft das Paket ohne Rückmeldung
	  und <literal>return</literal> gibt eine Statusmeldung, wie
	  etwa <computeroutput>Connection refused</computeroutput>
	  zurück.</para>

	<para>Die Voreinstellung ist <literal>drop</literal>.  Geben
	  Sie den gewünschten Wert ein, um die
	  <literal>block-policy</literal>-Richtlinie zu ändern:</para>

	<programlisting>set block-policy return</programlisting>

	<para><literal>scrub</literal> ist ein Schlüsselwort in
	  <application>PF</application>, das die Paket-Normalisierung
	  aktiviert.  Dieser Prozess fügt fragmentierte Pakete wieder
	  zusammen und blockt <acronym>TCP</acronym>-Pakete mit
	  ungültigen Flag-Kombinationen.  Ein aktiviertes
	  <literal>scrub</literal> bietet einen gewissen Schutz gegen
	  Angriffe, die auf die falsche Handhabung von fragmentierten
	  Paketen aufbauen.  Es stehen viele Optionen zur Verfügung,
	  jedoch sollte die einfachste Form für die meisten
	  Konfigurationen ausreichend sein:</para>
	
	<programlisting>scrub in all</programlisting>

	<para>Einige Dienste, wie beispielsweise
	  <acronym>NFS</acronym>, erfordern eine bestimmte Handhabung
	  von fragmentierten Paketen.  Weitere Informationen finden
	  Sie unter <link
	    xlink:href="http://www.openbsd.org/faq/pf/scrub.html">
	    http://www.openbsd.org/faq/pf/scrub.html</link>.</para>
	
	<para>Dieses Beispiel fügt fragmentierte Pakete wieder
	  zusammen, löscht das <quote>do not fragment</quote>-Bit und
	  setzt die maximale Segmentgröße auf 1440 Bytes:</para>

	<programlisting>scrub in all fragment reassemble no-df max-mss 1440</programlisting>

	<para>Der <literal>antispoof</literal>-Mechanismus bietet
	  einen Schutz gegen gefälschte
	  <acronym>IP</acronym>-Adressen.  Dabei werden hauptsächlich
	  Pakete verworfen, die auf der falschen Schnittstellen
	  ankommen.</para>

	<para>Folgende Regeln verwerfen gefälschte Adressen, wenn sie
	  aus dem Internet oder dem lokalen Netzwerk stammen:</para>

	<programlisting>antispoof for $ext_if
antispoof for $int_if</programlisting>
      </sect3>

      <sect3 xml:id="pftut-unrouteables">
	<title>Handhabung von nicht-routebaren Adressen</title>

	<para>Sogar bei einem richtig konfigurierten
	  <acronym>NAT</acronym>-Gateway müssen Sie vielleicht die
	  Fehlkonfiguration anderer Personen ausgleichen.  Ein
	  typischer Fehler besteht darin, nicht-routebare Adressen ins
	  Internet zu lassen.  Da der Verkehr von nicht-routebaren
	  Adressen Teil eines <acronym>DoS</acronym>-Angriffs sein
	  kann, sollten Sie in Betracht ziehen, diesen Verkehr
	  explizit an der externen Schnittstelle des Netzwerks zu
	  blockieren.</para>

	<para>In diesem Beispiel wird ein Makro erstellt, das die
	  nicht-routebaren Adressen enthält.  Datenverkehr von und zu
	  diesen Adressen wird dann an der externen Schnittstelle des
	  Gateways verworfen.</para>

	<programlisting>martians = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }"

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipf">
    <title>Die IPFILTER-Firewall (IPF)</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>IPFILTER</secondary>
    </indexterm>

    <para>Geschrieben wurde IPFILTER von Darren Reed.  IPFILTER ist vom
      Betriebssystem unabhängig: Es ist eine Open Source Anwendung,
      die auf die Betriebssysteme &os;, NetBSD, OpenBSD, &sunos;, HP/UX
      und &solaris; portiert wurde.  IPFILTER wird aktiv betreut und
      gepflegt.  Es werden regelmäßig neue Versionen
      herausgegeben.</para>

    <para>IPFILTER basiert auf einer kernelseitigen Firewall und einem
      <acronym>NAT</acronym> Mechanismus, der durch Anwenderprogramme
      betreut und gesteuert werden kann.  Die Regeln der Firewall werden
      mit dem Programm &man.ipf.8; gesetzt oder gelöscht.  Für
      die Manipulation der <acronym>NAT</acronym> Regeln verwendet man
      &man.ipnat.8;.  Mit &man.ipfstat.8; werden Laufzeitstatistiken der
      kernelseitigen Anteile von IPFILTER aufgelistet.  Und mit dem
      Programm &man.ipmon.8; kann man die Aktionen von IPFILTER in die
      Protokolldateien des Systems speichern.</para>

    <para>IPF funktionierte ursprünglich mit einer
      Regel-Prozess-Logik &agrave; la <quote>die letzte Regel, die
      passt, entscheidet</quote> und verwendete ausschließlich
      Regeln ohne feste Zustände.  Inzwischen wurde die
      Regel-Prozess-Logik drastisch modernisiert:  Es gibt eine
      <option>quick</option> und eine zustandsorientierte <option>
      keep-state</option> Option.  Die offizielle Dokumentation beinhaltet
      leider nur die veralteten Parameter zur Regelerstellung - die neuen
      Funktionen werden nur als Zusatzoptionen aufgelistet, was ihre
      Vorteile beim Erstellen einer weit überlegenen und viel
      sichereren Firewall völlig untergräbt.</para>

    <para>Die Anweisungen in diesem Kapitel basieren darauf, Regeln mit
      den Optionen <option>quick</option> und <option>keep-state</option>
      zu erstellen.  Mit diesem Grundwissen wird man einen kompletten
      einschließenden Regelsatz erstellen können.</para>

    <para>Für eine ausführliche Erläuterung der alten Methode
      zur Regelverarbeitung schauen Sie bitte auf <uri
	xlink:href="http://www.munk.me.uk/ipf/ipf-howto.html">
	http://www.munk.me.uk/ipf/ipf-howto.html</uri> oder <uri
	xlink:href="http://coombs.anu.edu.au/~avalon/ip-filter.html">
	http://coombs.anu.edu.au/~avalon/ip-filter.html</uri>.</para>

    <para>Antworten auf häufige Fragen finden Sie unter
      <uri xlink:href="http://www.phildev.net/ipf/index.html">http://www.phildev.net/ipf/index.html</uri>.</para>

    <para>Und ein durchsuchbares Archiv der Mailingliste zu IPFILTER
      gibt es unter <uri xlink:href="http://marc.theaimsgroup.com/?l=ipfilter">http://marc.theaimsgroup.com/?l=ipfilter</uri>.</para>

    <sect2>
      <title>Aktivieren von IPF</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>enabling</secondary>
      </indexterm>

      <para>&os; enthält IPF in der Standardversion als ladbares
        Kernelmodul.  Dieses Modul wird vom System automatisch geladen,
        wenn in der <filename>rc.conf</filename> der Eintrag<literal>
        ipfilter_enable="YES"</literal> angelegt wird. In dieser
        ursprünglichen Konfiguration ist die Protokollierung aktiv
        und	die Option <literal>default pass all</literal> ("Pakete passieren
        lassen") als Standard gesetzt.  Um die <literal>block all</literal>
        ("alles Blockieren") Option zu setzen, muss man nicht gleich
        einen neuen Kernel bauen - es reicht, <literal>block all</literal>
        als letzte Position des Regelsatzes aufzulisten.</para>
    </sect2>

    <sect2>
      <title>Kernel-Optionen</title>

	  <indexterm>
	  	<primary>Kerneloptionen</primary>

		<secondary>IPFILTER</secondary>
      </indexterm>

      <indexterm>
		<primary>Kerneloptionen</primary>

		<secondary>IPFILTER_LOG</secondary>
      </indexterm>

      <indexterm>
		<primary>Kerneloptionen</primary>

		<secondary>IPFILTER_DEFAULT_BLOCK</secondary>
      </indexterm>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>Kerneloptionen</secondary>
      </indexterm>

      <para>Es ist nicht unbedingt notwendig, IPF durch die folgenden
        Optionen direkt in der Kernel einzubinden.  Diese Möglichkeit
        der Verwendung von IPF wird hier mehr als Hintergrundwissen angeboten.
        Man sollte nur wissen, dass dadurch nicht mehr das Kernelmodul geladen
        wird - und dementsprechend auch nicht mehr entladen werden kann.</para>

      <para>Die Beschreibung der einzelnen Optionen von IPF für die
        Verwendung in der Kernelkonfiguration finden Sie auch in der Datei
        <filename>/usr/src/sys/conf/NOTES</filename>.</para>

      <programlisting>options IPFILTER
options IPFILTER_LOG
options IPFILTER_DEFAULT_BLOCK</programlisting>

      <para><literal>options IPFILTER</literal> aktiviert die Verwendung
	der <quote>IPFILTER</quote> Firewall.</para>

      <para><literal>options IPFILTER_LOG</literal> aktiviert den
        Logging-Mechanismus.  Das bedeutet, dass jedes Paket geloggt wird,
        auf das eine Regel passt, die das Schlüsselwort
        <literal>log</literal> enthält.  Dazu wird der
        Pseudo&mdash;Device	<filename>ipl</filename> verwendet.</para>

      <para><literal>options IPFILTER_DEFAULT_BLOCK</literal> ändert
        das Verhalten der Firewall dahingehend, dass jedes Paket, dass nicht
        explizit von einer <literal>pass</literal> Regel Zugang erhält,
        abgewiesen, bzw. geblockt, wird.</para>

      <para>Diese Einstellungen werden erst aktiv, wenn der Kernel, in den sie
      	eingebunden wurden, kompiliert, installiert und gebootet wurde.</para>
    </sect2>

    <sect2>
      <title>Optionen in rc.conf</title>

      <para>Um IPF während des Bootvorgangs einzubinden, braucht man
        lediglich die folgenden Zeilen der Datei
        <filename>/etc/rc.conf</filename> anzufügen:</para>

      <programlisting>ipfilter_enable="YES"             # Startet IPF
ipfilter_rules="/etc/ipf.rules"   # liest den Regelsatz aus einer Datei
ipmon_enable="YES"                # Startet das IP-Monitor Log
ipmon_flags="-Ds"                 # D = Als Da:mon starten
                                  # s = Protokollierung via syslog
                                  # v = Protokollierung von tcp window, ack, seq
                                  # n = Namen statt IP &amp; port ausgeben
      </programlisting>

      <para>Falls sich hinter der Firewall ein lokales Netzwerk befindet,
        das den reservierten privaten Adressbereich verwendet, müssen
        die folgenden Zeilen zur Aktivierung von <acronym>NAT</acronym>
        ebenfalls in <filename>/etc/rc.conf</filename> eingetragen
        werden:</para>

      <programlisting>gateway_enable="YES"              # Aktivierung des LAN-Gateways
ipnat_enable="YES"                # Startet die ipnat Funktion
ipnat_rules="/etc/ipnat.rules"    # Liest die ipnat-Regeldefinitionen aus einer Datei
      </programlisting>
    </sect2>

    <sect2>
      <title>Der Befehl ipf</title>

      <indexterm><primary><command>ipf</command></primary></indexterm>

      <para>Mit dem Befehl &man.ipf.8; liest man die Datei, die den Regelsatz
      	enthält ein.  Mit dem folgenden Befehl können Sie Ihre
      	eigenen, für Ihr System maßgeschneiderten Regeln einlesen
      	und so in einem Schritt alle Regeln der laufenden Firewall
      	ersetzen:</para>

      <screen>&prompt.root; <userinput>ipf -Fa -f /etc/ipf.rules</userinput></screen>

      <para><option>-Fa</option> bedeutet, dass alle intern gespeicherten
        Tabellen mit Regeln gelöscht werden.</para>

      <para><option>-f</option> gibt die Datei an, aus der die neuen Regeln
        gelesen werden sollen.</para>

      <para>Mit diesen beiden Optionen erhalten Sie die Möglichkeit,
        Änderungen an der Datei mit Ihrem Regelsatz vorzunehmen und
        gleich die Firewall mit den neuen Regeln zu bestücken, ohne
        den Rechner neu starten zu müssen.  Da dieser Vorgang beliebig
        wiederholt werden kann, ist es ein sehr bequemer Weg, neue Regeln
        einzuarbeiten und zu testen.</para>

      <para>Um mehr über diese und weitere Optionen von &man.ipf.8;
        zu erfahren, konsultieren Sie bitte die Manpage.</para>

      <para>&man.ipf.8; erwartet, dass es sich bei der Datei mit dem Regelsatz
        um eine Standard-Textdatei handelt.  Eine Datei, die ein Skript oder
        Variablen enthält, wird nicht verarbeitet.</para>

      <para>Es gibt allerdings doch einen Weg, IPF Regeln mit Hilfe von
        Skripten und Variablen zu erstellen.  Weitere Informationen dazu
        finden Sie unter <xref linkend="firewalls-ipf-rules-script"/>.</para>
    </sect2>

    <sect2>
      <title>IPFSTAT</title>

      <indexterm><primary><command>ipfstat</command></primary></indexterm>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>statistics</secondary>
     </indexterm>

      <para>Das normale Verhalten von &man.ipfstat.8; ist, die Zusammenfassung
      	der angefallenen Statistiken, die als Resultat der Anwendung von
      	nutzerspezifischen Regeln auf ein- und ausgehende Pakete seit dem
      	letzten Start der Firewall oder seit dem letzten Zurücksetzen
      	der Zähler auf Null durch das Kommando
      	<command>ipf -Z</command> angesammelt wurden, abzurufen und
      	anzuzeigen.</para>

      <para>Für weiterführende Informationen schauen Sie bitte
        auf die Manpage von &man.ipfstat.8;!</para>

      <para>Die Ausgabe von &man.ipfstat.8;, wenn keine Parameter
        übergeben wurden, sieht etwa so aus:</para>

      <screen>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
input packets logged: blocked 99286 passed 0
output packets logged: blocked 0 passed 0
packets logged: input 0 output 0
log failures: input 3898 output 0
fragment state(in): kept 0 lost 0
fragment state(out): kept 0 lost 0
packet state(in): kept 169364 lost 0
packet state(out): kept 431395 lost 0
ICMP replies: 0 <acronym>TCP</acronym> RSTs sent: 0
Result cache hits(in): 1215208 (out): 1098963
IN Pullups succeeded: 2 failed: 0
OUT Pullups succeeded: 0 failed: 0
Fastroute successes: 0 failures: 0
<acronym>TCP</acronym> cksum fails(in): 0 (out): 0
Packet log flags set: (0)</screen>

      <para>Wenn die Option <option>-i</option> für
        <quote>eingehend</quote> oder <option>-o</option> für
        <quote>ausgehend</quote> übergeben wird, liefert das Kommando
        eine entsprechende Liste von Filter-Regeln, die gerade installiert
        sind und vom Kernel verwendet werden.</para>

      <para><command>ipfstat -in</command> zeigt alle aktive Regeln
        für eingehende Verbindungen zusammen mit ihren Nummern.</para>

      <para><command>ipfstat -on</command> erledigt dasselbe für die
      	ausgehenden Verbindungen.</para>

      <para>Die Ausgabe sieht in etwa folgendermaßen aus:</para>

      <screen>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para><command>ipfstat -ih</command> zeigt die Tabelle der aktiven
        Regeln für eingehende Verbindungen zusammen mit der Anzahl,
        wie oft jeder einzelnen Regel entsprochen wurde.</para>

      <para><command>ipfstat -oh</command> zeigt das Gleiche für
      	die ausgehenden Verbindungen.</para>

      <para>Hier wird die Ausgabe so oder so ähnlich aussehen:</para>

      <screen>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>Einer der wichtigsten Funktionen von <command>ipfstat</command>
        wird über die Option <option>-t</option> bereitgestellt.  Mit
        ihr wird eine Statustabelle vergleichbar der Prozess-Tabelle
        von &man.top.1; ausgegeben.  Mit dieser Funktion erhalten Sie im
        Falle eines Angriffs die Möglichkeit, die angreifenden Pakete
        zu identifizieren, abzufangen und auszuwerten.  Weitere Unteroptionen
        eröffnen, die IP-Adresse, den Port oder das Protokoll, geteilt
        nach Herkunft und Ziel, auszuwählen und dann in Echtzeit zu
        beobachten. Lesen Sie dazu bitte auch die Manpage von
        &man.ipfstat.8;.</para>
    </sect2>

    <sect2>
      <title>IPMON</title>

      <indexterm><primary><command>ipmon</command></primary></indexterm>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>logging</secondary>
     </indexterm>

      <para>Damit der Befehl <command>ipmon</command> korrekt arbeiten kann,
        muss die Option <literal>IPFILTER_LOG</literal> in die
        Kernelkonfiguration eingearbeitet werden.  Das Kommando selbst
        arbeitet in zwei verschiedenen Modi.  Für den nativen Modus
        startet man <command>ipmon</command> auf der Kommandozeile ohne die
        Option <option>-D</option>.</para>

      <para>Der Hintergrundmodus (<literal>daemon mode</literal>) dient der
        Erstellung eines stetigen Systemprotokolls, so dass Einträge
        vergangener Ereignisse inspiziert werden können. So sollen &os;
        und IPFILTER entsprechend ihrer Konfiguration zusammen arbeiten.
        &os; kann mit einem eingebauten Mechanismus Systemprotokolle
        turnusmäßig abspeichern.  Aus diesem Grund sollte man
        besser &man.syslogd.8; verwenden anstatt die Protokollinformationen
        in eine Datei zu schreiben, wie es als Standard vorgesehen ist.  In
        der Standard-<filename>rc.conf</filename>-Datei (im Ordner
        <filename>/etc/defaults/</filename>) wird dem Eintrag
        <literal>ipmon_flags</literal> die Option <option>-Ds</option>
        übergeben:</para>

      <programlisting>ipmon_flags="-Ds" # D = Als Da:mon starten
# s = Protokollierung via syslog
# v = Protokollierung von tcp window, ack, seq
# n = Namen statt IP &amp; port ausgeben</programlisting>

      <para>Die Vorteile des Protokollierens liegen auf der Hand:  Sie
        versetzen den Administrator in die Lage, nach einem Vorfall
        Informationen abzurufen, etwa welche Pakete aussortiert wurden,
       	welche Adressen diese Pakete gesendet haben oder wohin sie gesendet
       	werden sollten.  Alles in allem erhält er ein sehr gutes Werkzeug
       	zum Aufspüren von Angreifern.</para>

      <para>Jedoch, auch wenn die Protokollierung aktiviert ist, wird IPF
        keine einzige Regel zum Protokollieren von alleine entwerfen und
        umsetzen.  Der Administrator der Firewall entscheidet, welche Regeln
        in seinem Regelsatz mitgeschrieben werden sollen und er muss
        dementsprechend das Schlüsselword <literal>log</literal> in
        dieser Regel angeben.  Normalerweise werden nur Treffer auf abweisende
        Regeln protokolliert.</para>

      <para>Es ist üblich, als letzte Regel eine alles blockierende
        Regel mit dem Schlüsselwort <literal>log</literal> in den
        Regelsatz einzutragen. Dadurch erkennt man alle Pakete, die keiner
        Regel im Regelsatz entsprachen.</para>
    </sect2>

    <sect2>
      <title>IPMON Logging</title>

      <para><application>Syslogd</application> verwendet seine eigene Methode
        zum Sortieren der gesammtelten Protokolldaten - spezielle Gruppierungen
        namens <quote>facility</quote> und <quote>level</quote>.  IPMON
        verwendet im <literal>daemon</literal>-Modus als
        <quote>facility</quote> den Wert <literal>security</literal>.  Die
        folgenden <quote>level</quote> können für eine genauere
        Trennung der Protokolldaten verwendet werden:</para>

      <screen>LOG_INFO - Alle zu protokollierenden Pakete
LOG_NOTICE - Protokollierte Pakete, die passieren durften
LOG_WARNING - Protokollierte Pakete, die blockiert wurden
LOG_ERR - Protokollierte Pakete, deren Headerdaten nicht komplett vorlagen</screen>

      <para>Damit IPFILTER angewiesen werden kann, alle Protokolldaten in
        die Datei <filename>/var/log/ipfilter.log</filename> zu schreiben,
        muss diese erst erstellt werden.  Folgendes Kommando
        übernimmt diese Aufgabe:</para>

      <screen>&prompt.root; <userinput>touch /var/log/ipfilter.log</userinput></screen>

      <para>Die Funktionen von &man.syslogd.8; werden durch Definition in
        der Datei <filename>/etc/syslog.conf</filename> gesteuert.  In dieser
        Datei kann sehr weitläfig eingestellt werden, wie
        <application>syslog</application> mit den Systemnachrichten umgehen
        soll, die ihm von Anwendungen wie IPF übergeben werden.</para>

      <para>Fügen Sie folgende Definition in die Datei
        <filename>/etc/syslog.conf</filename> ein, um die Protokollierung
        für IPF via <filename>syslog</filename> zu aktivieren:</para>

      <programlisting>security.* /var/log/ipfilter.log</programlisting>

      <para><literal>security.*</literal> bedeutet, dass alle Nachrichten
        der Klasse <literal>security.*</literal> am angegebenen Ort (hier
        eine Datei) geschrieben werden sollen.</para>

      <para>Um Änderungen an der Datei
        <filename>/etc/syslog.conf</filename> zu aktivieren müssen Sie
        den Rechner neu starten, oder den Befehl</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/syslogd reload</userinput></screen>

      <para>ausführen.</para>

      <para>Vergessen Sie nicht, <filename>/etc/newsyslog.conf</filename>
        anzupassen, damit die neuen Protokolldateien, die eben konfiguriert
        wurden, auch in den Rotationsturnus eingefügt werden!</para>
    </sect2>

    <sect2>
      <title>Die Formatierung der Logdatei</title>

      <para>Nachrichten, die durch <command>ipmon</command> erzeugt werden,
        bestehen aus durch Leerstellen getrennten Datenfeldern.  Folgende
        Felder sind in allen Nachrichten enthalten:</para>

      <orderedlist>
		<listitem>
		  <para>Das Datum der Paketerstellung.</para>
		</listitem>

		<listitem>
		  <para>Die Uhrzeit der Paketerstellung in der Form
		    <literal>HH:MM:SS.F</literal>, mit Stunden, Minuten, Sekunden
		    und Sekundenbruchteilen, wobei letztere mehrere Stellen lang
		    sein können.</para>
		</listitem>

		<listitem>
		  <para>Der Name der Schnittstelle, die das Paket verarbeitet hat,
		    bspw. <filename>dc0</filename>.</para>
		</listitem>

		<listitem>
		  <para>Die Gruppe und die Nummer der angewandten Regel, bspw.
		    <literal>@0:17</literal>.</para>
		</listitem>

		<listitem>
		  <para>Die ausgeführte Aktion: p für
		    <literal>passed</literal> (zugelassen), b für blockiert,
		    S für <literal>short packet</literal> (unvollständiger
		    Header), n für <literal>no match</literal> (gar keine Regel
		    wurde berührt) und L für Log-Regel.  Die Reihe, in der
		    die Flags angezeigt werden ist:  S, p, b, n, L.  Ein groß
		    geschriebenes P oder B bedeutet, dass das Paket aufgrund einer
		    globalen Einstellung protokolliert wurde und nicht wegen einer
		    einzelnen Regel.</para>
		</listitem>

		<listitem>
		  <para>Die Adressen.  Diese bestehen aus drei Feldern:  Der
		    Quelladresse mit Port (getrennt durch ein Komma), dem Symbol
		    <quote>-&gt;</quote> und der Zieladresse. Also bspw.
		    <literal>209.53.15.22,80 -&gt; 198.64.221.18,1722</literal>.</para>
		</listitem>

		<listitem>
		  <para><literal>PR</literal> gefolgt vom Namen eines
		    Netzwerk-Protokolls oder dessen Nummer.  Bspw.
		    <literal>PR tcp</literal>.</para>
		</listitem>

		<listitem>
		  <para><literal>len</literal> gefolgt von der Länge des Headers
		    und der Gesamtlänge des Paketes, beispielsweise
		    <literal>len 20 40</literal>.</para>
		</listitem>
      </orderedlist>

      <para>Wenn es sich um ein <acronym>TCP</acronym>-Paket handelt, wird
        ein weiteres Feld, beginnend mit einem Querstrich und gefolgt von
        Buchstaben, die den gesetzten Flags entsprechen, angezeigt.  Lesen
        Sie bitte die Manpage &man.ipmon.8; für eine Liste der Buchstaben
        und deren Bedeutungen.</para>

      <para>Falls das Paket ein ICMP-Paket ist, werden zwei Felder am Ende
        hinzugefügt - das erstere ist immer <quote>ICMP</quote>, das
        zweite enthält die ICMP-Nachricht und den Nachrichtentyp,
        getrennt durch einen Schrägstrich.  <literal>ICMP 3/3</literal>
        steht beispielsweise für <quote>Port nicht
        erreichbar</quote>.</para>
    </sect2>

    <sect2 xml:id="firewalls-ipf-rules-script">
      <title>Die Erstellung eines Regelsatzes mit Variablen</title>

      <para>Erfahrenere IPF Anwender erstellen sich eine Datei, die die
        Regeln enthält und gestalten diese als ein Skript, in dem
        Variablen verwendet werden.  Der wichtigste Vorteil besteht darin,
        dass man lediglich den Wert der Variablen anpassen muss und diese,
        sobald das Skript gestartet wird, durch die entsprechenden Werte
        ersetzt	und die Regeln entsprechend formuliert werden.  In Skripten
        kann man so häufig verwendete Werte einfach als Variable in
        mehreren Regeln zuweisen.  Am folgenden Beispiel soll das
        verdeutlicht werden.</para>

      <para>Die Syntax dieses Skriptes ist kompatibel mit den Shells
        &man.sh.1;, &man.csh.1; und &man.tcsh.1;.</para>

      <para>Variablen beginnen mit einem Dollar-Zeichen:
        <literal>&dollar;Variablenname</literal>.  Im Beispiel unten steht
        <literal>&dollar;oif</literal> für die Variable, in der der Name
        der Schnittstelle abgelegt wird, über die der Verkehr nach
        außen erfolgt.</para>

      <para>In Variablenzuweisungen fehlt das beginnende &dollar;-Zeichen.
        Alleine der Name der Variable wird angegeben, gefolgt von einem
        Gleichheitszeichen, und dem Wert, der der Variablen zugewiesen werden
        soll.  Dieser muss in doppelten Anführungszeichen
        (<literal>""</literal>) stehen.  Also folgt eine Zuweisung dem Schema
        <literal>Variablenname = "Wert"</literal>.</para>

      <programlisting>############# Start of IPF rules script ########################

oif="dc0"            # Name der Internet-Schnittstelle
odns="192.0.2.11"    # IP des DNS-Servers unseres ISPs
myip="192.0.2.7"     # die statische IP, die uns der ISP zugeteilt hat
ks="keep state"
fks="flags S keep state"

# Sie haben die Wahl, aus diesem Skript eine eigene
# /etc/ipf.rules erstellen zu lassen oder es einfach
# direkt als Skript laufen zu lassen.
#
# Entfernen Sie dazu das eine Kommentarzeichen
# und kommentieren Sie die andere Zeile aus!
#
# 1) Diese Zeile verwenden Sie zur Erstellung von /etc/ipf.rules
#cat &gt; /etc/ipf.rules &lt;&lt; EOF
#
# 2) Diese Zeile, wenn Sie direkt mit dem Skript arbeiten wollen
/sbin/ipf -Fa -f - &lt;&lt; EOF

# Erlaubnis ausgehenden Verkehrs an den Nameserver des ISPs
pass out quick on &dollar;oif proto tcp from any to &dollar;odns port = 53 &dollar;fks
pass out quick on &dollar;oif proto udp from any to &dollar;odns port = 53 &dollar;ks

# Erlaubnis ausgehenden unsicheren www-Verkehrs
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 80 &dollar;fks

# Erlaubnis ausgehenden sicheren www-Verkehrs https via TLS SSL
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 443 &dollar;fks
EOF
################## End of IPF rules script ########################</programlisting>

      <para>Das ist schon alles.  Die Regeln selbst sind im Beispiel nicht
        so wichtig - achten Sie auf die Anwendung der Variablenzuweisung
        am Anfang und die Verwendung der Variablen im Skript.  Falls das
        obige Beispiel in einer Datei namens
        <filename>/etc/ipf.rules.script</filename> gespeichert wurde,
        können die	Regeln mit folgenden Kommando neu geladen
        werden:</para>

      <screen>&prompt.root; <userinput>sh /etc/ipf.rules.script</userinput></screen>

      <para>Es gibt ein Problem mit Regelsatz-Dateien, die Variablen
        verwenden: IPF kann mit Variablen nichts anfangen - und kann derartige
        Skripte	nicht direkt einlesen.</para>

      <para>Unser kleines Skript kann daher nur auf eine der beiden folgenden
        Weisen verwendet werden:</para>

      <itemizedlist>
		<listitem>
		  <para>Entfernen Sie das Kommentarzeichen der Zeile, die mit
		    <literal>cat</literal> beginnt.  Kommentieren Sie die Zeile aus,
		    die mit <literal>/sbin/ipf</literal> beginnt.  Schreiben Sie die
		    Zeile <literal>ipfilter_enable="YES"</literal> in die Datei
		    <filename>/etc/rc.conf</filename> und rufen Sie dann das Skript
		    auf, um <filename>/etc/ipf.rules</filename> zu erstellen oder
		    zu erneuern.</para>
		</listitem>

		<listitem>
		  <para>Deaktivieren Sie IPFILTER in den Systemstart-Skripten, indem
		    Sie die Zeile <literal>ipfilter_enable="NO"</literal> in die
		    Datei <filename>/etc/rc.conf</filename> eintragen (was auch der
		    Standard-Einstellung entspricht).</para>

		  <para>Fügen Sie ein Skript ähnlich dem folgenden in Ihr
		    Verzeichnis <filename>/usr/local/etc/rc.d/</filename>.  Es
		    sinnvoll, dem Skript einen offensichtlichen Namen zu geben, wie
		    etwa <filename>ipf.loadrules.sh</filename>.  Die Endung
		    <filename>.sh</filename> ist dabei verbindlich.</para>

	 	 <programlisting>#!/bin/sh
sh /etc/ipf.rules.script</programlisting>

		  <para>Die Zugriffsrechte für die Datei, die das Skript
		    enthält, müssen für den Eigentümer
		    <systemitem class="username">root</systemitem> auf Lesen, Schreiben und Ausführen
		    gesetzt werden.</para>

		  <screen>&prompt.root; <userinput>chmod 700 /usr/local/etc/rc.d/ipf.loadrules.sh</userinput></screen>
		</listitem>
      </itemizedlist>

      <para>Wenn nun Ihr System startet, werden Ihre IPF-Regeln geladen.</para>
    </sect2>

    <sect2>
      <title>IPF Regelsätze</title>

      <para> Ein Regelsatz ist eine Gruppe von IPF-Regeln, die anhand der
        Werte eines Netzwerkpaketes entscheiden, ob dieses Paket durchgelassen
        oder blockiert wird.  Der Austausch von Paketen erfolgt immer
        zweiseitig in Form einer sogenannten Session.  Der Regelsatz der
        Firewall verarbeitet sowohl die eingehenden Pakete aus dem
        öffentlichen Internet als auch die Pakete, die vom System als
        Antwort auf die Ersteren gesendet werden.  Jeder Dienst, der via
        <acronym>TCP/IP</acronym> arbeitet, zum Beispiel
        <literal>telnet</literal>, <literal>www</literal> oder
        <literal>mail</literal>, ist vordefiniert durch sein Protokoll und
        seinen privilegierten Port,	an dem er auf Anfragen wartet und
        reagieren kann.  Pakete, die gezielt einen Dienst ansprechen sollen,
        werden von einem unprivilegierten Port des Senders an einen konkreten
        privilegierten Port des Zielsystems	geschickt.  Alle genannten
        Parameter (Ports, Adressen usw.) können als Auswahlkriterien zum
        erstellen von Regeln eingesetzt werden, die	Dienste erlauben oder
        blockieren.</para>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>rule processing order</secondary>
      </indexterm>

      <para>IPF wurde ursprünglich mit einer Regel-Prozess-Logik
        geschrieben, die ausschließlich statusfreie Regeln zuließ
        und nach dem Prinzip <quote>die letzte Regel, die passt,
        entscheidet</quote> arbeitete.  Mit der Zeit erhielt IPF eine
        <option>quick</option> Option sowie <option>keep-state</option> Option
        für die Anwendung von zustandsorientierten Regeln, was die
        Regel-Prozess-Logik signifikant modernisierte.</para>

      <para>Die Anweisungen in diesem Kapitel basieren auf der Verwendung
        von Regeln, die diese beiden neuen Optionen verarbeiten.  Dies ist
        das Framework zur Entwicklung eines Firewallregelsatzes.</para>

      <warning>
	<para>Wenn Sie mit einer Firewall arbeiten, seien Sie
	<emphasis>sehr vorsichtig</emphasis>.  Durch wenige Einstellungen
	können Sie sich aus Ihrem System
	<emphasis>aussperren</emphasis>.  Wenn Sie auf der sicheren Seite
	sein wollen, führen Sie die Firewall-Konfiguration direkt am
	entsprechenden Gerät aus und nicht über eine
	Netzwerkverbindung wie bspw. <application>ssh</application>.</para>
     </warning>
    </sect2>

    <sect2>
      <title>IPF Regel-Syntax</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>rule syntax</secondary>
      </indexterm>

      <para>Die Syntax zur Erstellung der Regeln, die hier vorgestellt wird,
        ist dahingehend vereinfacht worden, dass sie ausschliesslich auf
        den modernen Regelkontext, mit statusbehafteten Regeln und einer
        <quote>die erste Regel, die passt, gewinnt</quote>-Logik,
        zurückgreift.  Um alles über die veraltete Syntax zu
        erfahren, lesen Sie bitte die Man-Page von &man.ipf.8;.</para>

      <para>Ein <literal>#</literal>-Zeichen markiert den Beginn eines
        Kommentars.  Es darf nach nach einer Regel stehen oder als erstes
        Zeichen einer Zeile.  Leere Zeilen werden von der
        Regel-Prozess-Logik ignoriert.</para>

      <para>Regeln enthalten Schlüsselwörter.  Diese
        Schlüsselwörter müssen in einer bestimmten Reihenfolge
        von links nach rechts in einer Zeile erscheinen.  Als solche
        identifizierte Schlüsselwörter werden fett wiedergegeben.
        Einige Schlüsselwörter haben Unteroptionen, die wiederum
        selbst Schlüsselwörter sein und ebenfalls weiter
        Unteroptionen einschließen können.</para>

      <!-- This section is probably wrong. See the OpenBSD flag -->
      <!-- What is the "OpenBSD flag"?  Reference please -->

      <para><replaceable>ACTION IN-OUT OPTIONS SELECTION STATEFUL PROTO
        SRC_ADDR,DST_ADDR OBJECT PORT_NUM TCP_FLAG
        STATEFUL</replaceable></para>

      <para><replaceable>ACTION</replaceable> = block | pass</para>

      <para><replaceable>IN-OUT</replaceable> = in | out</para>

      <para><replaceable>OPTIONS</replaceable> = log | quick | on
        interface-name</para>

      <para><replaceable>SELECTION</replaceable> = proto value |
        source/destination IP | port = number | flags flag-value</para>

      <para><replaceable>PROTO</replaceable> = tcp/udp | udp | tcp |
        icmp</para>

      <para><replaceable>SRC_ADD,DST_ADDR</replaceable> = all | from
        object to object</para>

      <para><replaceable>OBJECT</replaceable> = IP address | any</para>

      <para><replaceable>PORT_NUM</replaceable> = port number</para>

      <para><replaceable>TCP_FLAG</replaceable> = S</para>

      <para><replaceable>STATEFUL</replaceable> = keep state</para>

      <sect3>
		<title>ACTION</title>

		<para>Die <quote>ACTION</quote> bestimmt, was mit dem Paket passieren
		  soll, wenn der Rest der Regel zutrifft.  Dieser Teil muss
		  für jede Regel angegeben werden.</para>

		<para>Das Schlüsselwort <literal>block</literal> gibt an, dass
		  das Paket verfallen soll, wenn die Auswahlparameter zutreffen.</para>

		<para>Das Schlüsselwort <literal>pass</literal> gibt an, dass
		  das Paket durch die Firewall durchgelassen werden soll, wenn die
		  Auswahlparameter zutreffen.</para>
      </sect3>

      <sect3>
		<title>IN-OUT</title>

		<para>Ebenfalls verbindlich ist die Angabe, welchen Teil der
		  Verbindung, Ein- oder Ausgang, die Regel beeinflussen soll.  Das
		  nächste Schlüsselwort muss daher entweder
		  <literal>in</literal>, für eingehend, oder
		  <literal>out</literal>, für ausgehend, lauten - oder die Regel
		  wird aufgrund eines Syntaxfehlers nicht umgesetzt.</para>

		<para><literal>in</literal> bedeutet, dass diese Regel auf eingehende
		  Pakete angewendet wird, die gerade an der dem öffentlichen
		  Internet zugewandten Schnittstelle empfangen wurden.</para>

		<para><literal>out</literal> bedeutet, das diese Regel auf ausgehende
		  Pakete angewendet wird, also Pakete die gerade gesendet werden und
		  deren Zieladresse im öffentlichen Internet liegt.</para>
      </sect3>

      <sect3>
		<title>OPTIONS</title>

		<note>
		  <para>Die Optionen müssen in der hier aufgeführten
		    Reihenfolge verwendet werden.</para>
		</note>

        <para><literal>log</literal> bestimmt, dass die Kopfdaten des Paketes
          an die Systemschnittstelle &man.ipl.4; geschrieben werden sollen.
          Genaueres dazu weiter unten im Abschnitt LOGGING.</para>

		<para><literal>quick</literal> bestimmt, dass,
		  <emphasis>wenn</emphasis> die Auswahlkriterien der Regel auf das
		  Paket zutreffen, keine weiteren Regeln ausgewertet werden.  So
		  vermeidet man das Abarbeiten des gesamten Regelsatzes.  Diese Option
		  ist eine verbindliche Vorraussetzung der modernen
		  Regel-Prozess-Logik.</para>

		<para><literal>on</literal> bestimmt den Namen der Schnittstelle,
		  der als Auswahlkriterium hinzugefügt werden soll.  Die Namen
		  aller verfügbaren Schnittstellen werden durch den Befehl
		  &man.ifconfig.8; angezeigt.  wenn man diese Option verwendet,
		  passt die Regeln nur auf Pakete, die durch diese Schnittstelle
		  empfangen (<literal>in</literal>) oder gesendet
		  (<literal>out</literal>) wurden.  Für die modernisierte
		  Regel-Prozess-Logik ist die Verwendung dieser Option
		  verbindlich.</para>

		<para>Wenn ein Paket protokolliert wird, werden die Kopfdaten in
		  die Pseudo-Schnittstelle &man.ipl.4; geschrieben.  Folgende Parameter
		  können zusätzlich übergeben werden, müssen dazu
		  aber direkt nach dem Schlüsselwort <literal>log</literal> und in
		  gleicher Reihenfolge stehen:</para>

		<para><literal>body</literal> bestimmt, dass die ersten 128 Bytes des
		  Paketinhaltes zusätzlich zu den Kopfdaten protokolliert
		  werden.</para>

		<para><literal>first</literal> trifft nur zu, wenn das
		  Schlüsselwort <literal>log</literal> zusammen mit
		  <literal>keep-state</literal> verwendet wird.  Es bestimmt, dass nur
		  das auslösende Paket protokolliert wird und nicht jedes weitere
		   Paket, dass von der gespeicherten Status-Regel betroffen ist.</para>
      </sect3>

      <sect3>
		<title>SELECTION</title>

		<para>Die Schlüsselwörter, die in diesem Abschnitt
		  vorgestellt werden, dienen zur Beschreibung von Attributen, anhand
		  derer geprüft und entschieden wird, ob eine Regel zutrifft
		  oder nicht.  Es gibt ein Schlüsselwort, und das hat mehrere
		  Optionen, von denen eine ausgewählt werden muss.  Die
		  folgenden allgemeinen Attribute können beliebig zum Erstellen
		  einer Regel verwendet werden, allerdings nur in der vorgestellten
		  Reihenfolge:</para>
      </sect3>

      <sect3>
		<title>PROTO</title>

		<para><literal>proto</literal> ist das Schlüsselwort für
		  das im Paket angewendete Protokoll.  Als Option ein Protokoll aus
		  Auswahlkriterium übergeben.  Diese Option ist verbindlich, wenn
		  man die moderne Regel-Prozess-Logik verwendet.</para>

		<para><literal>tcp/udp | udp | tcp | icmp</literal> oder irgendein
		  Protokollname, der in der Datei <filename>/etc/protocols</filename>
		  zu finden ist, kann übergeben werden.  Außerdem kann das
		  Schlüsselwort <literal>tcp/udp</literal> verwendet werden, wenn
		  sowohl <acronym>TCP</acronym> als auch <acronym>UDP</acronym> von der
		  Regel betroffen sein sollen.  Dieses Schlüsselwort wurde
		  eingeführt, um Duplikate sonst identischer Regeln zu
		  vermeiden.</para>
      </sect3>

      <sect3>
		<title>SRC_ADDR/DST_ADDR</title>

		<para>Das Schlüsselwort <literal>all</literal> ist ein Synonym
		  für <quote>from any to any</quote> ohne weitere
		  Auswahlkriterien.</para>

		<para><literal>from src to dst</literal>: Die Schlüsselwörter
		  <literal>from</literal> und <literal>to</literal> dienen zur Angabe
		  von Quelle und Ziel in Form von IP-Adressen oder -Bereichen.
		  Innerhalb einer Regel muss immer beides angegeben werden.
		  Statt einer Adresse kann auch das Schlüsselwort
		  <literal>any</literal> übergeben werden, das für jede
		  beliebige IP-Adresse steht.  Zum Beispiel:
		  <literal>from any to any</literal> oder
		  <literal>from 0.0.0.0/0 to any</literal> oder
		  <literal>from any to 0.0.0.0/0</literal> oder
		  <literal>from 0.0.0.0 to any</literal> oder
		  <literal>from any to 0.0.0.0</literal> bedeuten alle das
		  Gleiche.</para>

		<para>IP-Bereiche können nur in der CIDR-Notation angegeben
		  werden.  Der Port <package>net-mgmt/ipcalc</package>
		  hilft Ihnen bei der Berechnung der richtigen Angaben.
		  Weiterführende Informationen zu CIDR finden Sie auf der Webseite
		  von <link xlink:href="http://www.rfc-editor.org/rfc/rfc1519.txt"><literal>ipcalc</literal></link>.</para>
      </sect3>

      <sect3>
		<title>PORT</title>

		<para>Wenn ein Port als Auswahlkriterium übergeben wurde, bei
		  Quelle und/oder Ziel, wird er nur bei <acronym>TCP</acronym> und
		  <acronym>UDP</acronym> Paketen verwendet.  Angegeben werden kann
		  entweder die Portnummer oder der Dienstname aus
		  <filename>/etc/services</filename>.  Die Verwendung der
		  Portoption mit dem <literal>to</literal>-Objekt ist verbindlich
		  für die Verwendung der modernisierten Regel-Prozess-Logik.
		  Ein Beispiel für die Filterung Paketen von allen Quell-IPs mit
		  beliebiger Portnummer auf beliebige Ziel-IPs mit der Portnummer 80
		  (dem <literal>www</literal>-Port):
		  <literal>from any to any port = 80</literal>.</para>

	<!-- XXX: Rewritten, but probably needs more changes -->

		<para>Einfache Portvergleiche können auf verschiedenen Wegen
		  erfolgen.  Mehrere Vergleichsoperatoren stehen dafür zur
		  Verfügung.  Genauso können Bereiche angegeben
		  werden.</para>

		<para>port "=" | "!=" | "&lt;" | "&gt;" | "&lt;=" | "&gt;=" | "eq"
		  | "ne" | "lt" | "gt" | "le" | "ge".</para>

		<para>Um einen Bereich anzugeben: port "&lt;&gt;" | "&gt;&lt;"</para>

		<warning>
          <para>Genau wie die Trefferspezifikation für Quelle und Ziel
            sind auch die beiden folgenden Parameter obligatorisch bei der
            Verwendung der modernen Regel-Prozess-Logik.</para>
		</warning>
      </sect3>

      <sect3>
		<title><acronym>TCP</acronym>_FLAG</title>

		<para>Flags spielen nur beim Filtern von <acronym>TCP</acronym> eine
		  Rolle.  Die Buchstaben entsprechen jeweils einem möglichen
		  Flag, dass in den Kopfdaten der <acronym>TCP</acronym>-Pakete
		  geprueft werden soll.</para>

		<para>Die moderne Regel-Prozess-Logik verwendet den Parameter
		  <literal>flags S</literal> um eine Anfrage zum Start einer
		  <acronym>TCP</acronym>-Session zu identifizieren.</para>
      </sect3>

      <sect3>
		<title>STATEFUL</title>

		<para><literal>keep state</literal> zeigt bei einer Passage-Regel an,
		  dass für alle Pakete, die die Selektion erfolgreich durchlaufen,
		  <literal>Stateful Filtering</literal> eingerichtet werden
		  soll.</para>

		<note>
		  <para>Diese Option ist obligatorisch für die Verwendung der
		    modernen Prozess-Regel-Logik.</para>
		</note>
      </sect3>
    </sect2>
<!-- xxxxxxxxxxx Benjamin bis hier xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  //-->
    <sect2>
      <title>Stateful Filtering</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>stateful filtering</secondary>
      </indexterm>

      <!-- XXX: duplicated -->

      <para>Stateful filtering treats traffic as a bi-directional
	exchange of packets comprising a session conversation.  When
	activated, keep-state dynamically generates internal rules for
	each anticipated packet being exchanged during the
	bi-directional session conversation.  It has sufficient matching
	capabilities to determine if the session conversation between the
	originating sender and the destination are following the valid
	procedure of bi-directional packet exchange.  Any packets that
	do not properly fit the session conversation template are
	automatically rejected as impostors.</para>

      <para>Keep state will also allow <acronym>ICMP</acronym> packets related to a
	<acronym>TCP</acronym> or <acronym>UDP</acronym> session through.  So if you get
	<acronym>ICMP</acronym> type 3 code 4 in response to some web surfing allowed out
	by a keep state rule, they will be automatically allowed in.
	Any packet that IPF can be certain is part of an active
	session, even if it is a different protocol, will be let
	in.</para>

      <para>What happens is:</para>

      <para>Packets destined to go out through the interface connected to the
	public Internet are first checked against the dynamic state
	table.  If the packet matches the next expected packet
	comprising an active session conversation, then it exits the
	firewall and the state of the session conversation flow is
	updated in the dynamic state table.  Packets that do not belong to
	an already active session, are simply checked against the outbound
	ruleset.</para>

      <para>Packets coming in from the interface connected to the public
	Internet are first checked against the dynamic state table.  If
	the packet matches the next expected packet comprising an
	active session conversation, then it exits the firewall and
	the state of the session conversation flow is updated in the
	dynamic state table.  Packets that do not belong to an already active
	session, are simply checked against the inbound ruleset.</para>

      <para>When the conversation completes it is removed from the
	dynamic state table.</para>

      <para>Stateful filtering allows you to focus on blocking/passing
	new sessions.  If the new session is passed, all its subsequent
	packets will be allowed through automatically and any impostors
	automatically rejected.  If a new session is blocked, none of
	its subsequent packets will be allowed through.  Stateful
	filtering has technically advanced matching abilities
	capable of defending against the flood of different attack
	methods currently employed by attackers.</para>
    </sect2>

    <sect2>
      <!-- XXX: This section needs a rewrite -->

      <title>Inclusive Ruleset Example</title>

      <para>The following ruleset is an example of how to code a very
	secure inclusive type of firewall.  An inclusive firewall only
	allows services matching <literal>pass</literal> rules through, and blocks all
	others by default.  Firewalls intended to protect other machines,
	also called <quote>network firewalls</quote>, should have at least
	two interfaces, which are generally configured to trust one side
	(the <acronym>LAN</acronym>) and not the other (the public Internet).  Alternatively,
	a firewall might be configured to protect only the system it is
	running on&mdash;this is called a
	<quote>host based firewall</quote>, and is particularly appropriate
	for servers on an untrusted network.</para>

      <para>All &unix; flavored systems including &os; are designed to
	use interface <filename>lo0</filename> and IP address
	<systemitem class="ipaddress">127.0.0.1</systemitem> for internal
	communication within the operating system.  The firewall rules
	must contain rules to allow free unmolested movement of these
	special internally used packets.</para>

      <para>The interface which faces the public Internet is the one
	to place the rules that authorize and control access of the outbound
	and inbound connections.  This can be your user PPP
	<filename>tun0</filename> interface or your NIC that is
	connected to your DSL or cable modem.</para>

      <para>In cases where one or more NICs are cabled to private network
	segments, those interfaces may require rules to allow packets
	originating from those LAN interfaces transit to each other and/or
	to the outside (Internet).</para>

      <para>The rules should be organized into three major
	sections: first trusted interfaces, then the public
	interface outbound, and last the public untrusted interface inbound.</para>

      <para>The rules in each of the public interface sections should
	have the most frequently matched rules placed before less
	commonly matched rules, with the last rule in the section
	blocking and logging all packets on that interface and
	direction.</para>

      <para>The Outbound section in the following ruleset only
	contains <literal>pass</literal> rules which contain selection values that
	uniquely identify the service that is authorized for public
	Internet access.  All the rules have the <literal>quick</literal>, <literal>on</literal>,
	<literal>proto</literal>, <literal>port</literal>, and <literal>keep state</literal> options set.  The <literal>proto
	tcp</literal> rules have the <literal>flag</literal> option included to identify the
	session start request as the triggering packet to activate the
	stateful facility.</para>

      <para>The Inbound section has all the blocking of undesirable
	packets first, for two different reasons.  The first is that
	malicious packets may be partial matches for legitimate traffic.
	These packets have to be discarded rather than allowed in, based on
	their partial matches against <literal>allow</literal> rules.
	The second reason is that known and uninteresting rejects may be
	blocked silently, rather than being caught and logged by the last
	rules in the section.  The final rule in each section, blocks and
	logs all packets and can be used to create the legal evidence needed
	to prosecute the people who are attacking your system.</para>

      <para>Another thing that should be taken care of, is to ensure there is no
	response returned for any of the undesirable traffic.  Invalid
	packets should just get dropped and vanish.  This way the attacker
	has no knowledge if his packets have reached your system.  The
	less the attackers can learn about your system, the more
	time they must invest before actually doing something bad.
	Rules that include a <literal>log first</literal> option, will only
	log the event the first time they are triggered.  This option is
	included in the sample <literal>nmap OS fingerprint</literal> rule.
	The <package>security/nmap</package> utility is
	commonly used by attackers who attempt to identify the operating
	system of your server.</para>

      <para>Any time there are logged messages on a rule with
	the <literal>log first</literal> option, an <command>ipfstat -hio</command>
	command should be executed to evaluate how many times the rule has
	actually matched.  Large number of matches usually indicate that the
	system is being flooded (i.e.: under attack).</para>

      <para>The <filename>/etc/services</filename> file may be used to
	lookup unknown port numbers.  Alternatively,
	visit <uri xlink:href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</uri>
	and do a port number lookup to find the purpose of a particular
	port number.</para>

      <para>Check out this link for port numbers used by Trojans <uri xlink:href="http://www.sans.org/security-resources/idfaq/oddports.php">http://www.sans.org/security-resources/idfaq/oddports.php</uri>.</para>

      <para>The following ruleset creates a complete and very secure
	<literal>inclusive</literal> type of firewall ruleset that has been
	tested on production systems.  It can be easily modified for your
	own system.  Just comment out any <literal>pass</literal> rules for
	services that should not be authorized.</para>

      <para>To avoid logging unwanted messages,
	just add a <literal>block</literal> rule in the inbound section.</para>

      <para>The <filename>dc0</filename> interface name has to be changed
	in every rule to the real interface name of the NIC
	card that connects your system to the public Internet.  For
	user PPP it would be <filename>tun0</filename>.</para>

      <para>Add the following statements to
	<filename>/etc/ipf.rules</filename>:</para>

      <programlisting>#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN
#################################################################

#pass out quick on xl0 all
#pass in quick on xl0 all

#################################################################
# No restrictions on Loopback Interface
#################################################################
pass in quick on lo0 all
pass out quick on lo0 all

#################################################################
# Interface facing Public Internet (Outbound Section)
# Match session start requests originating from behind the
# firewall on the private network
# or from this gateway server destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# xxx must be the IP address of your ISP's DNS.
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
pass out quick on dc0 proto tcp from any to xxx port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow out access to my ISP's DHCP server for cable or DSL networks.
# This rule is not needed for 'user ppp' type connection to the
# public Internet, so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state


# Allow out non-secure standard www function
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow out secure www function https over TLS SSL
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow out send &amp; get email function
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow out Time
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow out nntp news
pass out quick on dc0 proto tcp from any to any port = 119 flags S keep state

# Allow out gateway &amp; LAN users' non-secure FTP ( both passive &amp; active modes)
# This function uses the IP<acronym>NAT</acronym> built in FTP proxy function coded in
# the nat rules file to make this single rule function correctly.
# If you want to use the pkg_add command to install application packages
# on your gateway system you need this rule.
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow out ssh/sftp/scp (telnet/rlogin/FTP replacements)
# This function is using SSH (secure shell)
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow out insecure Telnet
pass out quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow out FreeBSD CVSup
pass out quick on dc0 proto tcp from any to any port = 5999 flags S keep state

# Allow out ping to public Internet
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Allow out whois from LAN to public Internet
pass out quick on dc0 proto tcp from any to any port = 43 flags S keep state

# Block and log only the first occurrence of everything
# else that's trying to get out.
# This rule implements the default block
block out log first quick on dc0 all

#################################################################
# Interface facing Public Internet (Inbound Section)
# Match packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

##### Block a bunch of different nasty things. ############
# That I do not want to see in the log

# Block frags
block in quick on dc0 all with frags

# Block short tcp packets
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block nmap OS fingerprint attempts
# Log first occurrence of these so I can get their IP address
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings
block in quick on dc0 proto icmp all icmp-type 8

# Block ident
block in quick on dc0 proto tcp from any to any port = 113

# Block all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP's DHCP server as it is the only
# authorized source to send this packet type. Only necessary for
# cable or DSL configurations. This rule is not needed for
# 'user ppp' type connection to the public Internet.
# This is the same IP address you captured and
# used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow in standard www function because I have apache server
pass in quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID/PW passed over public Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
#pass in quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow in secure FTP, Telnet, and SCP from public Internet
# This function is using SSH (secure shell)
pass in quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Block and log only first occurrence of all remaining traffic
# coming into the firewall. The logging of only the first
# occurrence avoids filling up disk with Denial of Service logs.
# This rule implements the default block.
block in log first quick on dc0 all
################### End of rules file #####################################</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym></title>

      <indexterm><primary>NAT</primary></indexterm>

      <indexterm>
	<primary>IP masquerading</primary>

	<see>NAT</see>
      </indexterm>

      <indexterm>
	<primary>network address translation</primary>

	<see>NAT</see>
      </indexterm>

      <para><acronym>NAT</acronym> stands for <emphasis>Network Address
	  Translation</emphasis>.  To those familiar with &linux;, this concept is
	called IP Masquerading; <acronym>NAT</acronym> and IP
	Masquerading are the same thing.  One of the many things the
	IPF <acronym>NAT</acronym> function enables is the ability to
	have a private Local Area Network (LAN) behind the firewall
	sharing a single ISP assigned IP address on the public
	Internet.</para>

      <para>You may ask why would someone want to do this.  ISPs
	normally assign a dynamic IP address to their non-commercial
	users.  Dynamic means that the IP address can be different each
	time you dial in and log on to your ISP, or for cable and DSL
	modem users, when the modem is power cycled.  This dynamic IP
	address is used to identify your system to the public Internet.</para>

      <para>Now lets say you have five PCs at home and each one needs
	Internet access.  You would have to pay your ISP for an
	individual Internet account for each PC and have five phone
	lines.</para>

      <para>With <acronym>NAT</acronym> only a single account is needed
	with your ISP.  The other four PCs may then be cabled to a switch and
	the switch to the NIC in your &os; system which is going to
	service your LAN as a gateway. <acronym>NAT</acronym> will
	automatically translate the private LAN IP address for each
	separate PC on the LAN to the single public IP address as it
	exits the firewall bound for the public Internet.  It also does
	the reverse translation for returning packets.</para>

      <para>There is a special range of IP addresses reserved for
	<acronym>NAT</acronym>ed private LANs.  According to
	RFC 1918, the following IP ranges may be used for private nets
	which will never be routed directly to the public
	Internet:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <colspec colwidth="1*"/>

	  <colspec colwidth="1*"/>

	  <colspec colwidth="1*"/>

	  <tbody>
	    <row>
	      <entry>Start IP <systemitem class="ipaddress">10.0.0.0</systemitem></entry>

	      <entry>-</entry>

	      <entry>Ending IP <systemitem class="ipaddress">10.255.255.255</systemitem></entry>
	    </row>

	    <row>
	      <entry>Start IP <systemitem class="ipaddress">172.16.0.0</systemitem></entry>

	      <entry>-</entry>

	      <entry>Ending IP <systemitem class="ipaddress">172.31.255.255</systemitem></entry>
	    </row>

	    <row>
	      <entry>Start IP <systemitem class="ipaddress">192.168.0.0</systemitem></entry>

	      <entry>-</entry>

	      <entry>Ending IP <systemitem class="ipaddress">192.168.255.255</systemitem></entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>IP<acronym>NAT</acronym></title>

      <indexterm>
	<primary>NAT</primary>

	<secondary>and IPFILTER</secondary>
      </indexterm>

      <indexterm><primary><command>ipnat</command></primary></indexterm>

      <para><acronym>NAT</acronym> rules are loaded by using the
	<command>ipnat</command> command.  Typically the
	<acronym>NAT</acronym> rules are stored in
	<filename>/etc/ipnat.rules</filename>.  See &man.ipnat.8; for
	details.</para>

      <para>When changing the <acronym>NAT</acronym> rules after
	<acronym>NAT</acronym> has been started, make your changes to
	the file containing the NAT rules, then run the <command>ipnat</command> command with
	the <option>-CF</option> flags to delete the internal in use
	<acronym>NAT</acronym> rules and flush the contents of the
	translation table of all active entries.</para>

      <para>To reload the <acronym>NAT</acronym> rules issue a command
	like this:</para>

      <screen>&prompt.root; <userinput>ipnat -CF -f /etc/ipnat.rules</userinput></screen>

      <para>To display some statistics about your
	<acronym>NAT</acronym>, use this command:</para>

      <screen>&prompt.root; <userinput>ipnat -s</userinput></screen>

      <para>To list the <acronym>NAT</acronym> table's current
	mappings, use this command:</para>

      <screen>&prompt.root; <userinput>ipnat -l</userinput></screen>

      <para>To turn verbose mode on, and display information relating
	to rule processing and active rules/table entries:</para>

      <screen>&prompt.root; <userinput>ipnat -v</userinput></screen>
    </sect2>

    <sect2>
      <title>IP<acronym>NAT</acronym> Rules</title>

      <para><acronym>NAT</acronym> rules are very flexible and can
	accomplish many different things to fit the needs of commercial
	and home users.</para>

      <para>The rule syntax presented here has been simplified to what
	is most commonly used in a non-commercial environment.  For a
	complete rule syntax description see the &man.ipnat.5; manual
	page.</para>

      <para>The syntax for a <acronym>NAT</acronym> rule looks
	something like this:</para>

      <programlisting>map <replaceable>IF</replaceable> <replaceable>LAN_IP_RANGE</replaceable> -&gt; <replaceable>PUBLIC_ADDRESS</replaceable></programlisting>

      <para>The keyword <literal>map</literal> starts the rule.</para>

      <para>Replace <replaceable>IF</replaceable> with the external
	interface.</para>

      <para>The <replaceable>LAN_IP_RANGE</replaceable> is what your
	internal clients use for IP Addressing, usually this is
	something like <systemitem class="ipaddress">192.168.1.0/24</systemitem>.</para>

      <para>The <replaceable>PUBLIC_ADDRESS</replaceable> can either
	be the external IP address or the special keyword
	<literal>0/32</literal>, which means to use the IP address
	assigned to <replaceable>IF</replaceable>.</para>
    </sect2>

    <sect2>
      <title>How <acronym>NAT</acronym> works</title>

      <para>A packet arrives at the firewall from the LAN with a public
	destination.  It passes through the outbound filter rules,
	<acronym>NAT</acronym> gets its turn at the packet and applies
	its rules top down, first matching rule wins.
	<acronym>NAT</acronym> tests each of its rules against the
	packet's interface name and source IP address.  When a packet's
	interface name matches a <acronym>NAT</acronym> rule then the
	source IP address (i.e.: private LAN IP address) of the packet
	is checked to see if it falls within the IP address range
	specified to the left of the arrow symbol on the
	<acronym>NAT</acronym> rule.  On a match the packet has its
	source IP address rewritten with the public IP address
	obtained by the <literal>0/32</literal> keyword.
	<acronym>NAT</acronym> posts an entry in its internal
	<acronym>NAT</acronym> table so when the packet returns from
	the public Internet it can be mapped back to its original
	private IP address and then passed to the filter rules for
	processing.</para>
    </sect2>

    <sect2>
      <title>Enabling IP<acronym>NAT</acronym></title>

      <para>To enable IP<acronym>NAT</acronym> add these statements to
	<filename>/etc/rc.conf</filename>.</para>

      <para>To enable your machine to route traffic between
	interfaces:</para>

      <programlisting>gateway_enable="YES"</programlisting>

      <para>To start IP<acronym>NAT</acronym> automatically each
	time:</para>

      <programlisting>ipnat_enable="YES"</programlisting>

      <para>To specify where to load the IP<acronym>NAT</acronym> rules
	from:</para>

      <programlisting>ipnat_rules="/etc/ipnat.rules"</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym> for a very large LAN</title>

      <para>For networks that have large numbers of PC's on the LAN or
	networks with more than a single LAN, the process of funneling
	all those private IP addresses into a single public IP address
	becomes a resource problem that may cause problems with the
	same port numbers being used many times across many
	<acronym>NAT</acronym>ed LAN PC's, causing collisions.  There
	are two ways to relieve this resource problem.</para>

      <sect3>
	<title>Assigning Ports to Use</title>

	<!-- What does it mean ? Is there something missing ?-->
	<!-- XXXBLAH <- Apparently you can't start a sect
	     with a <programlisting> tag ?-->

	<para>A normal NAT rule would look like:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32</programlisting>

	<para>In the above rule the packet's source port is unchanged
	  as the packet passes through IP<acronym>NAT</acronym>.  By
	  adding the <literal>portmap</literal> keyword,
	  IP<acronym>NAT</acronym> can be directed to only use source ports in the specified range.
	  For example the following rule will tell
	  IP<acronym>NAT</acronym> to modify the source port to be
	  within the range shown:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</programlisting>

	<para>Additionally we can make things even easier by using the
	  <literal>auto</literal> keyword to tell
	  IP<acronym>NAT</acronym> to determine by itself which ports
	  are available to use:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</programlisting>
      </sect3>

      <sect3>
	<title>Using a Pool of Public Addresses</title>

	<para>In very large LANs there comes a point where there are just too
	  many LAN addresses to fit into a single public address.  If a block
	  of public IP addresses is available, these addresses can be used as
	  a <quote>pool</quote>, and IP<acronym>NAT</acronym> may pick one of
	  the public IP addresses as packet-addresses are mapped on their way
	  out.</para>

	<para>For example, instead of mapping all packets through a single
	  public IP address, as in:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.1</programlisting>

	<para>A range of public IP addresses can be specified either with a
	  netmask:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0</programlisting>

	<para>or using CIDR notation:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Port Redirection</title>

      <para>A very common practice is to have a web server, email
	server, database server and DNS server each segregated to a
	different PC on the LAN.  In this case the traffic from these
	servers still have to be <acronym>NAT</acronym>ed, but there
	has to be some way to direct the inbound traffic to the
	correct LAN PCs.  IP<acronym>NAT</acronym> has the redirection
	facilities of <acronym>NAT</acronym> to solve this problem.
	For example, assuming a web server operating on LAN address <systemitem class="ipaddress">10.0.10.25</systemitem> and using a single public IP
	address of <systemitem class="ipaddress">20.20.20.5</systemitem> the rule would
	be coded as follows:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>or:</para>

	<programlisting>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>or for a LAN DNS Server on LAN address of <systemitem class="ipaddress">10.0.10.33</systemitem> that needs to receive
	  public DNS requests:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 53 -&gt; 10.0.10.33 port 53 udp</programlisting>
    </sect2>

    <sect2>
      <title>FTP and <acronym>NAT</acronym></title>

      <para>FTP is a dinosaur left over from the time before the
	Internet as it is known today, when research universities were
	leased lined together and FTP was used to share files among
	research Scientists.  This was a time when data security was
	not a consideration.  Over the years the FTP protocol became
	buried into the backbone of the emerging Internet and its
	username and password being sent in clear text was never
	changed to address new security concerns.  FTP has two flavors,
	it can run in active mode or passive mode.  The difference is
	in how the data channel is acquired.  Passive mode is more
	secure as the data channel is acquired by the ordinal ftp
	session requester.  For a real good explanation of FTP and the
	different modes see <uri xlink:href="http://www.slacksite.com/other/ftp.html">http://www.slacksite.com/other/ftp.html</uri>.</para>

      <sect3>
	<title>IP<acronym>NAT</acronym> Rules</title>

	<para>IP<acronym>NAT</acronym> has a special built in FTP proxy
	  option which can be specified on the <acronym>NAT</acronym>
	  map rule.  It can monitor all outbound packet traffic for FTP
	  active or passive start session requests and dynamically
	  create temporary filter rules containing only the port number
	  really in use for the data channel.  This eliminates the
	  security risk FTP normally exposes the firewall to from
	  having large ranges of high order port numbers open.</para>

	<para>This rule will handle all the traffic for the internal
	  LAN:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>This rule handles the FTP traffic from the
	  gateway:</para>

	<programlisting>map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>This rule handles all non-FTP traffic from the internal
	  LAN:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32</programlisting>

	<para>The FTP map rule goes before our regular map rule.  All
	  packets are tested against the first rule from the top.
	  Matches on interface name, then private LAN source IP
	  address, and then is it a FTP packet.  If all that matches
	  then the special FTP proxy creates temp filter rules to let
	  the FTP session packets pass in and out, in addition to also
	  <acronym>NAT</acronym>ing the FTP packets.  All LAN packets
	  that are not FTP do not match the first rule and fall
	  through to the third rule and are tested, matching on
	  interface and source IP, then are
	  <acronym>NAT</acronym>ed.</para>
      </sect3>

      <sect3>
	<title>IP<acronym>NAT</acronym> FTP Filter Rules</title>

	<para>Only one filter rule is needed for FTP if the
	  <acronym>NAT</acronym> FTP proxy is used.</para>

	<para>Without the FTP Proxy, the following three rules will be
	  needed:</para>

	<programlisting># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipfw">
    <title>IPFW</title>

    <indexterm>
      <primary>Firewall</primary>

      <secondary>IPFW</secondary>
    </indexterm>

    <para><application>IPFW</application> ist eine
      <foreignphrase>Stateful-Firewall</foreignphrase>
      für &os;, die sowohl <acronym>IPv4</acronym> als auch
      <acronym>IPv6</acronym> unterstützt.  Die Firewall setzt sich
      aus mehreren Komponenten zusammen: dem Kernel Firewall
      Filter-Prozessor mit integriertem Paket-Accounting,
      Protokollfunktionen, <acronym>NAT</acronym>, dem
      &man.dummynet.4; <foreignphrase>Traffic-Shaper</foreignphrase>,
      sowie Weiterleitungs-, Bridge- und ipstealth-Funktionen.</para>

    <para>&os; enthält mit <filename>/etc/rc.firewall</filename> ein
      Beispielregelwerk, welches mehrere Firewall-Typen für
      gebräuchliche Szenarien definiert und unerfahrene Anwender
      dabei unterstützen soll, ein geeignetes Regelwerk zu erstellen.
      <application>IPFW</application> besitzt eine leistungsstarke
      Syntax, mit der erfahrene Benutzer ihre eigenen Regeln
      anfertigen können, um den Sicherheitsanforderungen der
      jeweiligen Umgebung gerecht zu werden.</para>

    <para>Diser Abschnitt beschreibt, wie
      <application>IPFW</application> aktiviert wird und bietet einen
      Überblick über die Regelsyntax.  Zudem werden mehrere Regelsätze
      für gebräuchliche Konfigurationsszenarien vorgestellt.</para>

    <sect2 xml:id="firewalls-ipfw-enable">
      <title><application>IPFW</application> aktivieren</title>

      <indexterm>
	<primary><application>IPFW</application></primary>
	<secondary>aktivieren</secondary>
      </indexterm>

      <para>Das &os; Basissystem enthält für
	<application>IPFW</application> ein ladbares Kernelmodul, was
	bedeutet, dass kein angepasster Kernel benötigt wird, um
	<application>IPFW</application> zu benutzen.</para>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFIREWALL</secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFIREWALL_VERBOSE</secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFIREWALL_VERBOSE_LIMIT</secondary>
      </indexterm>

      <indexterm>
	<primary><application>IPFW</application></primary>
	<secondary>Kerneloptionen</secondary>
      </indexterm>

      <para>Wenn Sie eine statische Unterstützung für
	<application>IPFW</application> in den Kernel kompilieren
	wollen, lesen Sie <xref linkend="kernelconfig"/>.  Folgende
	Optionen können in der Kernelkonfigurationsdatei verwendet
	werden:</para>

      <programlisting>options    IPFIREWALL				# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT	# sets default policy to pass what is not explicitly denied
options    IPDIVERT			# enables NAT</programlisting>

      <para>Um <application>IPFW</application> beim Systemstart zu
	aktivieren, fügen Sie folgende Zeile in
	<filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>firewall_enable="YES"</programlisting>

      <para>Wenn Sie einen der von &os; zur Verfügung gestellten
	Firewall-Profile benutzen möchten, fügen Sie eine weitere
	Zeile hinzu, in der Sie das Profil bestimmen:</para>

      <programlisting>firewall_type="open"</programlisting>

      <para>Folgende Profile stehen zur Verfügung:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>open</literal>: gestattet jeglichen
	    Datenverkehr.</para>
	</listitem>

	<listitem>
	  <para><literal>client</literal>: schützt lediglich diesen
	    Rechner.</para>
	</listitem>

	<listitem>
	  <para><literal>simple</literal>: schützt das gesamte
	    Netzwerk.</para>
	</listitem>

	<listitem>
	  <para><literal>closed</literal>: blockiert den gesamten
	    <acronym>IP</acronym>-Datenverkehr, mit Ausnahme des
	    Verkehrs über die Loopback-Schnittstelle.</para>
	</listitem>

	<listitem>
	  <para><literal>workstation</literal>: schützt lediglich
	    diesen Rechner und verwendet zustandsorientierte
	    Regeln.</para>
	</listitem>

	<listitem>
	  <para><literal>UNKNOWN</literal>: deaktiviert das Laden von
	    Firewallregeln.</para>
	</listitem>

	<listitem>
	  <para><filename><replaceable>filename</replaceable></filename>:
	    absoluter Pfad zu einer Datei, in der die Firewallregeln
	    definiert sind.</para>
	</listitem>
      </itemizedlist>

      <para>Wenn Sie <literal>firewall_type</literal> auf
	<literal>client</literal> oder <literal>simple</literal>
	setzen, müssen Sie die voreingestellten Regeln in
	<filename>/etc/rc.firewall</filename> anpassen, damit sie
	der Konfiguration des Systems entsprechen.</para>

      <para>Beachten Sie, dass das Profil <literal>filename</literal>
	verwendet wird, um ein benutzerdefiniertes Regelwerk zu
	laden.</para>

      <para>Eine alternative Möglichkeit, um ein benutzerdefiniertes
	Regelwerk zu laden, bietet die Variable
	<literal>firewall_script</literal>.  Setzen Sie die Variable
	auf den absoluten Pfad eines
	<emphasis>ausführbaren Skripts</emphasis>, welches die Befehle
	für <application>IPFW</application> enthält.  Die Beispiele in
	diesem Abschnitt gehen davon aus, dass
	<literal>firewall_script</literal> auf
	<filename>/etc/ipfw.rules</filename> gesetzt ist.</para>

      <programlisting>firewall_script="/etc/ipfw.rules"</programlisting>

      <para>Die Protokollierung wird mit diesem Eintrag
	aktiviert:</para>

      <programlisting>firewall_logging="YES"</programlisting>

      <para>Es existiert keine Variable für
	<filename>/etc/rc.conf</filename>, um die Protokollierung zu
	begrenzen.  Um die Anzahl der Protokoll-Nachrichten pro
	Verbindungsversuch zu begrenzen, legen Sie die Anzahl der
	Einträge in <filename>/etc/sysctl.conf</filename> fest:</para>

      <programlisting>net.inet.ip.fw.verbose_limit=5</programlisting>

      <para>Nachdem Sie die Änderungen gespeichert haben, können Sie
	die Firewall starten.  Um auch die Anzahl der
	Protokoll-Nachrichten zu konfigurieren, setzen Sie mit
	<command>sysctl</command> den gewünschten Wert:</para>

      <screen>&prompt.root; <userinput>service firewall start</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.fw.verbose_limit=<replaceable>5</replaceable></userinput></screen>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-rules">
      <title><application>IPFW</application> Regel-Syntax</title>

      <para>Wenn ein Paket die Firewall <quote>betritt</quote>, also
	von der Firewall geprüft und verarbeitet wird, wird die
	erste Regel des Regelwerkes auf das Paket angewandt.  Auf
	diese Weise wird in aufsteigender Reihenfolge der Regelnummer
	mit allen weiteren Regeln verfahren.  Falls die
	Selektionsparameter einer Regel auf ein Paket zutreffen, wird
	das Aktionsfeld der Regel ausgeführt und die Prüfung
	des Pakets beendet, nachfolgende Regeln werden also nicht
	mehr geprüft.  Diese Suchmethode wird als <quote>erster
	  Treffer gewinnt</quote> bezeichnet.  Falls keine Regel auf
	das betreffende Paket zutrifft, wird die obligatorische
	<application>IPFW</application>-Rückfallregel mit der Nummer
	65535 angewendet und das Paket wird ohne Rückantwort
	verworfen.  Wenn das Paket jedoch einer Regel mit dem
	Schlüsselwort <literal>count</literal>,
	<literal>skipto</literal> oder <literal>tee</literal>
	entspricht, wird die Prüfung des Pakets weiter
	fortgeführt.  Weitere Details darüber, wie diese
	Schlüsselwörter die Regelverarbeitung beeinflussen, finden Sie
	in &man.ipfw.8;.</para>

      <indexterm>
	<primary><application>IPFW</application></primary>
	<secondary>Regel-Syntax</secondary>
      </indexterm>

      <para>Bei der Erstellung der
	<application>IPFW</application>-Regeln müssen die
	Schlüsselwörter in der folgenden Reihenfolge geschrieben
	werden.  Einige Schlüsselwörter müssen zwingend angegeben
	werden, während andere optional sind.  Die Wörter in
	Großbuchstaben repräsentieren Variablen und die Wörter in
	Kleinbuchstaben müssen den Variablen vorangestellt
	werden.  Das Zeichen <literal>#</literal> wird benutzt, um
	einen Kommentar einzuleiten und kann am Ende einer Regel oder
	in einer eigenen Zeile stehen. Leerzeilen werden
	ignoriert.</para>

      <para><replaceable>CMD RULE_NUMBER set SET_NUMBER ACTION log
	  LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT
	  OPTIONS</replaceable></para>

      <para>Dieser Abschnitt bietet einen Überblick über diese
	Schlüsselwörter und deren Optionen.  Es ist keine vollständige
	Liste aller verfügbaren Optionen.  Eine vollständige
	Beschreibung der Regel-Syntax, die Sie verwenden können um
	<application>IPFW</application>-Regeln zu erstellen, finden
	Sie in &man.ipfw.8;.</para>

      <variablelist>
	<varlistentry>
	  <term>CMD</term>
	  <listitem>
	    <para>Jede Regel muss mit <parameter>ipfw add</parameter>
	      beginnen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RULE_NUMBER</term>
	  <listitem>
	    <para>Jede Regel gehört zu einer Nummer zwischen
	      <literal>1</literal> und <literal>65534</literal>.  Die
	      Nummer wird verwendet, um die Reihenfolge der
	      Regelverarbeitung zu kennzeichnen.  Es ist möglich, dass
	      mehrere Regeln dieselbe Nummer haben.  In diesem Fall
	      werden sie entsprechend der Reihenfolge angewendet, in
	      der sie aufgenommen wurden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SET_NUMBER</term>
	  <listitem>
	    <para>Jede Regel ist einer <emphasis>Set</emphasis>-Nummer
	      zwischen <literal>0</literal> und <literal>31</literal>
	      zugeordnet.  Sets können einzeln aktiviert oder
	      deaktiviert werden.  Dies macht es möglich, eine Reihe
	      von Regeln schnell hinzuzufügen oder zu löschen.  Wenn
	      <literal>SET_NUMBER</literal> nicht angegeben ist, wird
	      die Regel zu Set <literal>0</literal>
	      hinzugefügt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>ACTION</term>
	  <listitem>
	    <para>Eine Regel kann mit einer der folgenden Aktionen
	      verknüpft werden.  Die festgelegte Aktion wird
	      ausgeführt, wenn das Paket den Selektionskriterien der
	      Regel entspricht.</para>

	    <para><parameter>allow | accept | pass |
		permit</parameter>: All diese Aktionen sind
	      gleichbedeutend und erlauben Pakete, die mit der Regel
	      übereinstimmen.</para>

	    <para><parameter>check-state</parameter>: Diese Aktion
	      überprüft die Regel in der dynamischen Zustandstabelle.
	      Bei einer Übereinstimmung wird die mit der dynamischen
	      Regel verknüpfte Aktion ausgeführt, andernfalls wird mit
	      der Prüfung gegen die nächste Regel fortgefahren.  Die
	      Regel <literal>check-state</literal> hat selbst kein
	      Selektionskriterium.  Sollte keine
	      <literal>check-state</literal>-Regel im Regelwerk
	      vorhanden sein, wird die dynamische Zustandstabelle beim
	      ersten Vorkommen einer <literal>keep-state</literal>-
	      oder <literal>limit</literal>-Regel überprüft.</para>

	    <para><parameter>count</parameter>: Aktualisiert die
	      Zähler für alle Pakete, die mit dieser Regel
	      übereinstimmen.  Die Prüfung wird mit der nächsten Regel
	      fortgesetzt.</para>

	    <para><parameter>deny | drop</parameter>: Diese Aktionen
	      sind gleichbedeutend und verwerfen Pakete, die mit
	      dieser Regel übereinstimmen.</para>

	    <para>Es stehen noch weitere Aktionen zur Verfügung.
	      Einzelheiten finden Sie in &man.ipfw.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>LOG_AMOUNT</term>
	  <listitem>
	    <para>Erfüllt ein Paket die Selektionskriterien mit dem
	      Schlüsselwort <literal>log</literal>, wird dies von
	      &man.syslogd.8; mit der Annotation
	      <literal>SECURITY</literal> protokolliert.  Dies erfolgt
	      allerdings nur, wenn die Anzahl der protokollierten
	      Pakete der betreffenden Regel die definierte
	      <literal>LOG_AMOUNT</literal>-Grenze nicht übersteigt.
	      Wenn <literal>LOG_AMOUNT</literal> nicht definiert ist,
	      wird die Grenze aus dem Wert von
	      <varname>net.inet.ip.fw.verbose_limit</varname>
	      benutzt.  Ein Wert von <literal>0</literal> bedeutet
	      eine unbegrenzte Protokollierung.  Wird eine definierte
	      Grenze erreicht, wird die Protokollierung für diese
	      Regel deaktiviert.  Um die Protokollierung zu
	      reaktivieren, können Sie den Protokoll- oder Paketzähler
	      mit <command>ipfw resetlog</command>
	      zurücksetzen.</para>

	    <note>
	      <para>Die Protokollierung findet statt, nachdem alle
		Selektionskriterien geprüft und bevor die endgültige
		Aktion auf das Paket angewendet wird.  Der
		Administrator entscheidet, welche Regel protokolliert
		werden soll.</para>
	    </note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>PROTO</term>
	  <listitem>
	    <para>Dieser optionale Wert wird verwendet, um einen
	      beliebigen Protokollnamen oder -nummer aus
	      <filename>/etc/protocols</filename> gegen das Paket zu
	      prüfen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SRC</term>
	  <listitem>
	    <para>Nach dem Schlüsslwort<literal>from</literal> muss
	      die Quelladresse stehen, oder ein Schlüsselwort, das die
	      Quelladresse darstellt.  Eine Adresse wird dargestellt
	      duch <literal>any</literal>, <literal>me</literal> (jede
	      Adresse dieses Systems), <literal>me6</literal> (jede
	      <acronym>IPv6</acronym>-Adresse dieses Systems), oder
	      <literal>table</literal> gefolgt von der Nummer der
	      Tabelle, welche die Adressen enthält.
	      <acronym>IP</acronym>-Adressen können in
	      <acronym>CIDR</acronym>-Notation geschrieben werden.
	      Beispielsweise <literal>1.2.3.4/25</literal> oder
	      <literal>1.2.3.4:255.255.255.128</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SRC_PORT</term>
	  <listitem>
	    <para>Optional kann ein Quellport über eine Nummer oder
	      einen Namen aus <filename>/etc/services</filename>
	      spezifiziert werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DST</term>
	  <listitem>
	    <para>Nach dem Schlüsselwort <literal>to</literal> muss
	      die Zieladresse stehen, oder ein Schlüsselwort, das die
	      Zieladresse darstellt.  Es können die gleichen
	      Schlüsselwörter und Adressen benutzt werden, die bereits
	      im SRC-Abschnitt beschrieben wurden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DST_PORT</term>
	  <listitem>
	    <para>Optional kann ein Zielport über eine Nummer oder
	      einen Namen aus <filename>/etc/services</filename>
	      spezifiziert werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>OPTIONS</term>
	  <listitem>
	    <para>Nach der Quell- und Zieladresse können noch weitere
	      Optionen angegeben werden.  Wie der Name bereits sagt,
	      sind <literal>OPTIONS</literal> optional.  Häufig
	      verwendete Optionen sind <literal>in</literal> oder
	      <literal>out</literal>, mit denen die Richtug des
	      Pakets bestimmt wird, <literal>icmptypes</literal>
	      gefolgt vom Typ der <acronym>ICMP</acronym>-Nachricht,
	      sowie <literal>keep-state</literal>.</para>

	    <para>Wenn ein Paket auf eine
	      <parameter>keep-state</parameter>-Regel zutrifft, wird
	      die Firewall eine dynamische Regel erstellen, die dem
	      bidirektionalen Datenverkehr zwischen den gleichen
	      Quell- und Zieladressen mit dem gleichen Protokoll
	      entspricht.</para>

	    <para>Dynamische Regeln sind für einen sogenannten
	      <foreignphrase>SYN-flood</foreignphrase>-Angriff
	      anfällig, bei dem eine riesige Anzahl an dynamischen
	      Regeln erzeugt wird.  Verwenden Sie die Option
	      <literal>limit</literal>, um einen solchen Angriff
	      entgegenzuwirken.  Diese Option begrenzt die Anzahl
	      der gleichzeitig möglichen Sitzungen.  Es handelt sich
	      dabei um einen Zähler, der die Anzahl von dynamischen
	      Regeln in Kombination mit der Quelladresse verfolgt.
	      Übersteigt der Zähler den durch <literal>limit</literal>
	      definierten Wert, wird das Paket verworfen.</para>

	    <para>Es stehen noch viele weitere Optionen zur Verfügung.
	      &man.ipfw.8; enthält eine Beschreibung der einzelnen
	      Optionen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Beispiel für einen Regelsatz</title>

      <para>Dieser Abschnitt die Erstellung eines Firewall-Skripts
	namens <filename>/etc/ipfw.rules</filename> mit
	zustandsorientierten (<foreignphrase>stateful</foreignphrase>
	Regeln.  Alle Regeln in diesem Beispiel verwenden die Optionen
	<literal>in</literal> und <literal>out</literal>, um die
	Richtung des Pakets zu verdeutlichen.  Zusätzlich wird
	<literal>via</literal>
	<replaceable>interface-name</replaceable> benutzt, um die
	Schnittstelle für das Paket zu prüfen.</para>

      <note>
	<para>Bei den anfänglichen Tests mit dem Firewall-Regelsatz
	  sollten Sie vielleicht folgende Einstellung
	  vornehmen:</para>

	<programlisting>net.inet.ip.fw.default_to_accept="1"</programlisting>

	<para>Dies legt die Standardregel von &man.ipfw.8; etwas
	  großzügiger fest, als das voreingestellte
	  <literal>default deny ip from any to any</literal>.  Dadurch
	  sinkt die Gefahr, sich nach einem Neustart des Systems
	  auszusperren.</para>
      </note>

      <para>Das Firewall-Skript beginnt mit einem Hinweis, dass es
	sich um ein Bourne Shell-Skript handelt.  Danach werden alle
	vorhandenen Filterregeln gelöscht.  Anschließend wird die
	Variable <literal>cmd</literal> erstellt, sodass
	<literal>ipfw add</literal> nicht jedes mal von Hand
	eingegeben werden muss.  Die Variable <literal>pif</literal>
	repräsentiert die mit dem Internet verbundene
	Schnittstelle.</para>

      <programlisting>#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
pif="dc0"     # interface name of NIC attached to Internet</programlisting>

      <para>Jetzt folgen die eigentlichen Filterregeln.  Diese ersten
	beiden Regeln erlauben den Datenverkehr aus dem internen
	Netzwerk und über die Loopback-Schnittstelle:</para>

      <programlisting># Change xl0 to LAN NIC interface name
&dollar;cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
&dollar;cmd 00010 allow all from any to any via lo0</programlisting>

      <para>Die nächste Regel erlaubt Pakete, für die ein Eintrag
	in der dynamischen Zustandstabelle existiert:</para>

      <programlisting>&dollar;cmd 00101 check-state</programlisting>

      <para>Die nächsten Regeln definieren, welche internen Rechner
	Verbindungen zu anderen Rechnern im Internet aufbauen dürfen.
	Hier werden wieder zustandsorientierte Regeln
	verwendet:</para>

      <programlisting># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
&dollar;cmd 00110 allow tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state
&dollar;cmd 00111 allow udp from any to x.x.x.x 53 out via &dollar;pif keep-state

# Allow access to ISP's DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
&dollar;cmd 00120 allow log udp from any to any 67 out via &dollar;pif keep-state
#&dollar;cmd 00120 allow udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Allow outbound HTTP and HTTPS connections
&dollar;cmd 00200 allow tcp from any to any 80 out via &dollar;pif setup keep-state
&dollar;cmd 00220 allow tcp from any to any 443 out via &dollar;pif setup keep-state

# Allow outbound email connections
&dollar;cmd 00230 allow tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 00231 allow tcp from any to any 110 out via &dollar;pif setup keep-state

# Allow outbound ping
&dollar;cmd 00250 allow icmp from any to any out via &dollar;pif keep-state

# Allow outbound NTP
&dollar;cmd 00260 allow tcp from any to any 37 out via &dollar;pif setup keep-state

# Allow outbound SSH
&dollar;cmd 00280 allow tcp from any to any 22 out via &dollar;pif setup keep-state

# deny and log all other outbound connections
&dollar;cmd 00299 deny log all from any to any out via &dollar;pif</programlisting>

      <para>Die folgenden Regeln steuern die Verbindungen von
	Rechern aus dem Internet ins interne Netzwerk.  Zuerst werden
	Pakete verworfen, die typischerweise im Zusammenhang mit
	Angriffen stehen.  Danach werden bestimmte Arten von
	Verbindungen erlaubt.  Alle Dienste aus dem öffentlichen
	Internet beinhalten die Option <literal>limit</literal>, um
	<foreignphrase>Flooding</foreignphrase> zu unterbinden.</para>

      <programlisting># Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 00300 deny all from 192.168.0.0/16 to any in via &dollar;pif     #RFC 1918 private IP
&dollar;cmd 00301 deny all from 172.16.0.0/12 to any in via &dollar;pif      #RFC 1918 private IP
&dollar;cmd 00302 deny all from 10.0.0.0/8 to any in via &dollar;pif         #RFC 1918 private IP
&dollar;cmd 00303 deny all from 127.0.0.0/8 to any in via &dollar;pif        #loopback
&dollar;cmd 00304 deny all from 0.0.0.0/8 to any in via &dollar;pif          #loopback
&dollar;cmd 00305 deny all from 169.254.0.0/16 to any in via &dollar;pif     #DHCP auto-config
&dollar;cmd 00306 deny all from 192.0.2.0/24 to any in via &dollar;pif       #reserved for docs
&dollar;cmd 00307 deny all from 204.152.64.0/23 to any in via &dollar;pif    #Sun cluster interconnect
&dollar;cmd 00308 deny all from 224.0.0.0/3 to any in via &dollar;pif        #Class D &amp; E multicast

# Deny public pings$
&dollar;cmd 00310 deny icmp from any to any in via &dollar;pif$
$
# Deny ident$
&dollar;cmd 00315 deny tcp from any to any 113 in via &dollar;pif$
$
# Deny all Netbios services.$
&dollar;cmd 00320 deny tcp from any to any 137 in via &dollar;pif$
&dollar;cmd 00321 deny tcp from any to any 138 in via &dollar;pif$
&dollar;cmd 00322 deny tcp from any to any 139 in via &dollar;pif$
&dollar;cmd 00323 deny tcp from any to any 81 in via &dollar;pif$

# Deny fragments
&dollar;cmd 00330 deny all from any to any frag in via &dollar;pif

# Deny ACK packets that did not match the dynamic rule table
&dollar;cmd 00332 deny tcp from any to any established in via &dollar;pif

# Allow traffic from ISP's DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#&dollar;cmd 00360 allow udp from any to x.x.x.x 67 in via &dollar;pif keep-state

# Allow HTTP connections to internal web server
&dollar;cmd 00400 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Allow inbound SSH connections
&dollar;cmd 00410 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Reject and log all other incoming connections
&dollar;cmd 00499 deny log all from any to any in via &dollar;pif</programlisting>

      <para>Die letzte Regel protokolliert alle Pakete, die mit
	keiner Regel im Regelsatz übereinstimmen:</para>

      <programlisting># Everything else is denied and logged
&dollar;cmd 00999 deny log all from any to any</programlisting>
    </sect2>

    <sect2 xml:id="network-natd">
      <info>
	<title><acronym>NAT</acronym> Konfiguration</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Chern</firstname>
	      <surname>Lee</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>NAT</primary>
	<secondary>und <application>IPFW</application></secondary>
      </indexterm>

      <para>&os;s integrierter <acronym>NAT</acronym>-Daemon,
	&man.natd.8;, arbeitet in Verbindung mit
	<application>IPFW</application>, um
	<foreignphrase>Network Address Translation</foreignphrase>
	bereitzustellen.  <acronym>NAT</acronym> wird verwendet, um
	mehreren internen Rechnern, über eine einzige
	<acronym>IP</acronym>-Adresse, eine gemeinsame Verbindung zum
	Internet zu ermöglichen.</para>

      <para>Um dies zu tun, muss der mit dem Internet verbundene
	&os;-Rechner als Gateway eingerichtet sein.  Das System muss
	über zwei Netzwerkschnittstellen verfügen, wobei eine
	Schnittstelle mit dem Internet verbunden ist und die andere
	mit dem internen Netzwerk.  Jeder Rechner im internen Netzwerk
	sollte eine <link
	  xlink:href="ftp://ftp.isi.edu./in-notes/rfc1918.txt">RFC
	  1918</link> konforme Adresse zugewiesen bekommen.  Zudem
	muss das Standard-Gateway der Rechner auf die interne
	<acronym>IP</acronym>-Adresse des &man.natd.8;-Systems
	gesetzt werden.</para>

      <para>Es ist noch ein wenig Konfiguration nötig, um die
	<acronym>NAT</acronym>-Funktion von
	<application>IPFW</application> zu aktivieren.  Wenn das
	System einen angepassten Kernel hat, muss die
	Kernelkonfigurationsdatei die Zeile
	<literal>option IPDIVERT</literal> sowie weitere
	<literal>IPFIREWALL</literal>-Optionen, die in <xref
	  linkend="firewalls-ipfw-enable"/> beschrieben sind,
	enthalten.</para>

      <para>Um die <acronym>NAT</acronym>-Unterstützung beim Booten
	zu aktivieren, müssen folgende Einträge in
	<filename>/etc/rc.conf</filename> vorhanden sein:</para>

      <programlisting>gateway_enable="YES"		# enables the gateway
natd_enable="YES"		# enables <acronym>NAT</acronym>
natd_interface="rl0"		# specify interface name of NIC attached to Internet
natd_flags="-dynamic -m"	# -m = preserve port numbers; additional options are listed in &man.natd.8;</programlisting>

      <note>
	<para>Es ist auch möglich eine Konfigurationsdatei zu
	  verwenden, welche die Optionen enthält, die an
	  &man.natd.8; übergeben werden:</para>

	<programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

	<para>Die angegebene Datei muss die Konfigurationsoptionen
	  enthalten, eine Option pro Zeile. Zum Beispiel:</para>

	<programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</programlisting>

	<para>Weitere Informationen zu dieser Konfigurationsdatei
	  finden Sie in &man.natd.8;.</para>
      </note>

      <para>Als nächstes werden die <acronym>NAT</acronym>-Regeln
	hinzugefügt.  Wenn die Regeln zustandsorientiert sind, ist die
	Platzierung der <acronym>NAT</acronym>-Regeln sehr wichtig und
	die <literal>skipto</literal>-Aktion wird verwendet.  Dies
	erfordert, dass jede Regel über eine eindeutige Nummer
	verfügt, um eindeutige Sprungziele zu erhalten.</para>

      <para>Das folgende Beispiel baut auf dem im vorherigen Abschnitt
	gezeigten Firewall-Relgelsatz auf.  Es werden einige neue
	Einträge hinzugefügt und bestehende Regeln modifiziert, um
	<acronym>NAT</acronym> zu konfigurieren.  Zunächst werden
	einige Variablen hinzugefügt, darunter Regelnummern, die
	<literal>keep-state</literal>-Option und eine Liste mit
	<acronym>TCP</acronym>-Ports um die Anzahl der Regeln zu
	reduzieren:</para>

      <programlisting>#!/bin/sh
ipfw -q -f flush
cmd="ipfw -q add"
skip="skipto 500"
pif=dc0
ks="keep-state"
good_tcpo="22,25,37,53,80,443,110"</programlisting>

      <para>Die <acronym>NAT</acronym>-Regel für eingehende Pakete
	wird <emphasis>nach</emphasis> den beiden Regeln, die das
	interne Netzwerk und die Loopback-Schnittstelle erlauben und
	<emphasis>vor</emphasis> der
	<literal>check-state</literal>-Regel eingefügt.  Es ist
	wichtig, dass die Nummer der <acronym>NAT</acronym>-Regel
	(in diesem Beispiel <literal>100</literal>) höher ist, als
	die beiden vorherigen Regeln und niedriger, als die
	<literal>check-state</literal>-Regel:</para>

      <programlisting>&dollar;cmd 005 allow all from any to any via xl0  # exclude LAN traffic
&dollar;cmd 010 allow all from any to any via lo0  # exclude loopback traffic
&dollar;cmd 100 divert natd ip from any to any in via &dollar;pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
&dollar;cmd 101 check-state</programlisting>

      <para>Die Regeln für den ausgehenden Verkehr werden ebenfalls
	modifiziert, um Aktionen mit der
	<literal>&dollar;skipto</literal>-Variable zu erlauben und
	anzuzeigen, dass die Prüfung mit der Regel
	<literal>500</literal> fortgesetzt wird.  Die sieben Regeln
	für <acronym>TCP</acronym> wurden durch die Regel
	<literal>125</literal> ersetzt, da die sieben erlaubten
	ausgehenden Ports in der Variable
	<literal>&dollar;good_tcp0</literal> enthalten sind.</para>

      <programlisting># Authorized outbound packets
&dollar;cmd 120 &dollar;skip udp from any to x.x.x.x 53 out via &dollar;pif &dollar;ks
&dollar;cmd 121 &dollar;skip udp from any to x.x.x.x 67 out via &dollar;pif &dollar;ks
&dollar;cmd 125 &dollar;skip tcp from any to any &dollar;good_tcpo out via &dollar;pif setup &dollar;ks
&dollar;cmd 130 &dollar;skip icmp from any to any out via &dollar;pif &dollar;ks</programlisting>

      <para>Die eingehenden Regeln bleiben unverändert, mit Ausnahme
	der letzten Regel, in der das
	<literal>via &dollar;pif</literal> entfert wird, um ein- und
	ausgehende Pakete prüfen zu können.  Nach der letzten Regel
	für ausgehende Pakete muss die <acronym>NAT</acronym>-Regel
	folgen.  Die Regel muss eine höhere Nummer als die letzte
	Regel haben und die Nummer muss über die
	<literal>skipto</literal>-Aktion referenziert werden.  In
	diesem Regelsatz leitet die Regel mit der Nummer
	<literal>500</literal> alle ausgehenden Pakete zur
	Weiterverarbeitung an &man.natd.8; weiter.  Die darauf
	folgende Regel lässt alle von <acronym>NAT</acronym>
	verarbeiteten Pakete passieren.</para>

      <programlisting>&dollar;cmd 499 deny log all from any to any
&dollar;cmd 500 divert natd ip from any to any out via &dollar;pif # skipto location for outbound stateful rules
&dollar;cmd 510 allow ip from any to any</programlisting>

      <para>In diesem Beispiel steuern die Regeln
	<literal>100</literal>, <literal>101</literal>,
	<literal>125</literal>, <literal>500</literal> und
	<literal>510</literal> die Adressübersetzung der ein- und
	ausgehende Pakete, so dass immer die private
	<acronym>LAN</acronym> <acronym>IP</acronym>-Adresse in der
	dynamische Zustandstabelle registriert werden.</para>

      <para>Nehmen wir beispielsweise einen Web-Browser, der neue
	<acronym>HTTP</acronym>-Sitzungen über Port 80 aufbaut.  Wenn
	nun das erste ausgehende Paket von der Firewall geprüft wird,
	trifft es nicht auf Regel <literal>100</literal> zu, da das
	Paket nach außen geleitet wird und nicht nach innen.  Das
	Paket trifft auch nicht auf Regel <literal>101</literal> zu,
	da es das erste ist und somit noch nicht in der dynamischen
	Zustandstabelle enthalten ist.  Das Paket entspricht
	schließlich Regel <literal>125</literal>, da es ausgehend auf
	einem erlaubten Port gesendet wird und von einer
	<acronym>IP</acronym>-Adresse aus dem internen
	<acronym>LAN</acronym> stammt.  Für Pakete, die auf diese
	Regel zutreffen, werden zwei Aktionen ausgeführt.  Zuerst
	wird durch die Aktion <literal>keep-state</literal> ein
	dynamischer Eintrag in der Statustabelle erstellt und die
	angegebene Aktion <literal>skipto 500</literal> ausgeführt.
	Als nächstes durchläuft das Paket <acronym>NAT</acronym> und
	wird dann an das Internet gesendet.  Nachdem dieses Paket am
	Webserver angekommen ist, wird dort eine Antwort erzeugt und
	zurückgeschickt.  Dieses Paket wird wieder von oben nach unten
	durch das Regelwerk geprüft.  Dieses Mal trifft Regel
	<literal>100</literal> auf das Paket zu und die Zieladresse
	wird auf die zugehörige (lokale)
	<acronym>LAN</acronym>-Adresse abgebildet.  Danach wird das
	Paket von der Regel <literal>check-state</literal>
	verarbeitet.  Die Zustandstabelle erkennt, dass eine
	zugehörige aktive Sitzung vorliegt und das Paket wird
	freigegeben und in das <acronym>LAN</acronym> geleitet.</para>

      <para>Für den eingehenden Datenverkehr muss der Regelsatz
	unerwünschte Pakete blockieren und Pakete für autorisierte
	Dienste durchlassen.  Ein Paket, das mit einer Regel für den
	eingehenden Datenverkehr übereinstimmt, wird in der
	dynamischen Zustandstabelle eingetragen und dann an das
	<acronym>LAN</acronym> freigegeben.  Das Antwortpaket wird
	von der Regel <literal>check-state</literal> als Paket einer
	aktiven Sitzung erkannt.  Das Paket wird dann von Regel
	<literal>500</literal> per <acronym>NAT</acronym>
	verarbeitet, bevor es über die externe Schnittstelle versendet
	wird.</para>

      <sect3>
	<title>Weiterleitung von Ports</title>

	<para>Der Nachteil von &man.natd.8; ist, dass die Rechner im
	  <acronym>LAN</acronym> nicht aus dem Internet zugänglich
	  sind.  Diese Rechner können zwar ausgehende Verbindungen
	  zur Außenwelt aufbauen, jedoch keine eingehenden
	  Verbindungen empfangen.  Dies stellt ein Problem dar, wenn
	  Sie auf einem Rechner im <acronym>LAN</acronym> Dienste
	  anbieten möchten, die aus dem Internet erreichbar sein
	  sollen.  In diesem Fall können Sie die Ports, welche über
	  das Internet erreichbar sein sollen, über die
	  &man.natd.8;-Maschine an den Rechner im
	  <acronym>LAN</acronym> weiterleiten.</para>

	<para>Angenommen es gibt einen <acronym>IRC</acronym>-Server
	  auf Rechner <systemitem>A</systemitem> und einen Webserver
	  auf Rechner <systemitem>B</systemitem>.  Damit dies
	  funktioniert, müssen die Verbindungen auf den Ports 6667
	  (<acronym>IRC</acronym>) und 80 (<acronym>HTTP</acronym>)
	  an die jeweiligen Rechner weitergeleitet werden.</para>

	<para>Die Syntax für <option>-redirect_port</option>
	  lautet:</para>

	<programlisting>-redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

	<para>Für das obige Beispiel sollten die Argumente wie folgt
	  aussehen:</para>

	<programlisting>-redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</programlisting>

	<para>Damit werden die entsprechenden
	  <acronym>TCP</acronym>-Ports an die Rechner im
	  <acronym>LAN</acronym> weitergeleitet.</para>

	<para>Portbereiche können über <option>-redirect_port</option>
	  festgelegt werden.  Zum Beispiel würde
	  <replaceable>tcp 192.168.0.2:2000-3000
	    2000-3000</replaceable> alle Verbindungen auf die Ports
	  2000 bis 3000 an die Ports 2000 bis 3000 an
	  Rechner <systemitem>A</systemitem> weiterleiten.</para>

	<para>Diese Optionen können über
	  <literal>natd_flags=""</literal> in
	  <filename>/etc/rc.conf</filename> direkt beim Start an
	  &man.natd.8; übergeben werden.  Alternativ können die
	  Optionen in eine Konfigurationsdatei eingetragen
	  werden.</para>

	<para>Weitere Konfigurationsmöglichkeiten sind in
	  &man.natd.8; beschrieben.</para>
      </sect3>

      <sect3>
	<title>Weiterleiten von Adressen</title>

	<para>Das Weiterleiten von Adressen ist nützlich, wenn
	  mehr als eine <acronym>IP</acronym>-Adresse zur Verfügung
	  steht.  Jeder Rechner im <acronym>LAN</acronym> kann über
	  &man.natd.8; seine eigene externe
	  <acronym>IP</acronym>-Adresse zugewiesen bekommen.
	  &man.natd.8; wird dann den ausgehenden Datenverkehr der
	  Rechner aus dem <acronym>LAN</acronym> mit der
	  entsprechenden externen <acronym>IP</acronym>-Adresse
	  umschreiben.  Auch der eingehenden Datenverkehr über die
	  externe <acronym>IP</acronym>-Adresse wird an die
	  entsprechenden Rechner im <acronym>LAN</acronym>
	  weitergeleitet.  Diese Methode ist auch als
	  statisches <acronym>NAT</acronym> bekannt.  Wenn Ihnen
	  beispielsweise die <acronym>IP</acronym>-Adressen
	  <systemitem class="ipaddress">128.1.1.1</systemitem>,
	  <systemitem class="ipaddress">128.1.1.2</systemitem> und
	  <systemitem class="ipaddress">128.1.1.3</systemitem> zur
	  Verfügung stehen, kann <systemitem
	    class="ipaddress">128.1.1.1</systemitem> als externe
	  Adresse der &man.natd.8;-Maschine verwendet werden, während
	  <systemitem class="ipaddress">128.1.1.2</systemitem> und
	  <systemitem class="ipaddress">128.1.1.3</systemitem> an
	  Rechner <systemitem>A</systemitem> und
	  Rechner <systemitem>B</systemitem> im <acronym>LAN</acronym>
	  weitergeleitet werden.</para>

	<para>Die Syntax für <option>-redirect_address</option>
	  lautet:</para>

	<programlisting>-redirect_address localIP publicIP</programlisting>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry>localIP</entry>
		<entry>Die interne <acronym>IP</acronym>-Adresse des
		  Rechners im <acronym>LAN</acronym>.</entry>
	      </row>

	      <row>
		<entry>publicIP</entry>
		<entry>Die externe <acronym>IP</acronym>-Adresse für
		  den entsprechenden Rechner im
		  <acronym>LAN</acronym>.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Für das obige Beispiel sollten die Argumente wie
	  folgt aussehen:</para>

	<programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

	<para>Genau wie bei <option>-redirect_port</option>, werden
	  diese Argumente innerhalb der
	  <filename>/etc/rc.conf</filename>-Option
	  <literal>natd_flags=""</literal> angegeben, oder alternativ
	  über eine Konfigurationsdatei.  Allerdings müssen beim
	  Weiterleiten von Adressen keine Ports umgeleitet werden, da
	  der gesamte eingehende Datenverkehr einer bestimmte
	  <acronym>IP</acronym>-Adresse weitergeleitet wird.</para>

	<para>Die externe <acronym>IP</acronym>-Adresse der
	  &man.natd.8;-Maschine muss auf der externen Schnittstelle
	  aktiv und mit einem Alias versehen sein.  Weitere
	  Einzelheiten sind in &man.natd.8; beschrieben.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-cmd">
      <title>Das <application>IPFW</application> Kommando</title>

      <indexterm>
	<primary><command>ipfw</command></primary>
      </indexterm>

      <para><command>ipfw</command> kann benutzt werden, um einzelne
	Regeln im laufenden Betrieb hinzuzufügen oder zu entfernen.
	Problematisch ist jedoch, dass diese Änderungen bei einem
	Neustart des Systems verloren gehen.  Daher ist es
	empfehlenswert, eigene Regeln in einer Datei zu definieren
	und diese zu laden, um die Regeln der Firewall im laufenden
	Betrieb anzupassen.</para>

      <para><command>ipfw</command> ist auch hilfreich, um die
	geladenen Regeln der auf der Konsole auszugeben.
	<application>IPFW</application> erzeugt dynamisch einen
	Zähler, der jedes Paket, auf das eine Regel zutrifft, zählt.
	Dadurch ist es möglich, die Funktion einer Regel zu
	überprüfen.</para>

      <para>Eine Auflistung aller geladenen Regeln erhalten Sie
	mit:</para>

      <screen>&prompt.root; <userinput>ipfw list</userinput></screen>

      <para>Eine Auflistung aller Regeln inklusive des letzten
	Treffers erhalten Sie mit:</para>

      <screen>&prompt.root; <userinput>ipfw -t list</userinput></screen>

      <para>Das nächste Beispiel zeigt Informationen über die Anzahl
	der Pakete, die von einer Regel gefiltert wurden sowie die
	Regel selbst.  Der erste Spalte zeigt die Nummer der
	Regel, gefolgt von der Anzahl der gefilterten Pakete
	und der Anzahl der Pakete in Bytes.  Zum Schluss steht die
	Regel selbst:</para>

      <screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

      <para>Das folgende Kommando zeigt zusätzlich alle dynamischen
	Regeln an:</para>

      <screen>&prompt.root; <userinput>ipfw -d list</userinput></screen>

      <para>Um diese Auflistung um die <quote>abgelaufenen</quote>
	Regeln zu erweitern, geben Sie folgendes Kommando ein:</para>

      <screen>&prompt.root; <userinput>ipfw -d -e list</userinput></screen>

      <para>Hiermit werden alle Zähler auf Null zurückgesetzt:</para>

      <screen>&prompt.root; <userinput>ipfw zero</userinput></screen>

      <para>Es ist auch möglich, einen spezifischen Zähler
	zurückzusetzen:</para>

      <screen>&prompt.root; <userinput>ipfw zero NUM</userinput></screen>

      <sect3>
	<title>Protokollierung von Firewall-Nachrichten</title>

	<para>Auch bei aktivierter Protokollierung wird
	  <application>IPFW</application> von selbst keine Regeln
	  protokollieren.  Der Administrator muss entscheiden, welche
	  Regeln aus dem Regelwerk protokolliert werden sollen.  In
	  diesen Regeln muss dann das Schlüsselwort
	  <literal>log</literal> hinzugefügt werden.  Normalerweise
	  werden nur geblockte Pakete protokolliert.  Es ist üblich,
	  die <quote>ipfw default deny everything</quote>-Regel am 
	  Ende des Regelwerks mit dem Schlüsselwort
	  <literal>log</literal> zu duplizieren.  Dadurch ist es
	  möglich, alle Pakete zu sehen, auf die keine Regel
	  zutraf.</para>

	<para>Protokollierung ist allerdings ein zweischneidiges
	  Schwert.  Bei mangelnder Vorsicht oder einem DoS-Angriff
	  wird die Festplatte mit einer enormen Flut von
	  Protokolldaten belastet.  Protokoll-Nachrichten werden nicht
	  nur an &man.syslogd.8; geschickt, sondern auch auf der
	  Konsole angezeigt, was dann schnell lästig werden
	  kann.</para>

	<para>Die Kerneloption
	  <literal>IPFIREWALL_VERBOSE_LIMIT=5</literal> begrenzt die
	  Anzahl identischer Nachrichten an &man.syslogd.8; für eine
	  gegebene Regel auf fünf Nachrichten.  Ist diese Option im
	  Kernel aktiviert, wird nach Erreichen den festgelegten
	  Anzahl die Protokollierung von aufeinanderfolgenden
	  Nachrichten auf den festgelegten Wert begrenzt, da
	  beispielsweise die Speicherung von 200 gleichen
	  Protokoll-Nachrichten sinnlos ist.  Daher werden durch
	  diese Option nur fünf gleichartige Nachrichten
	  protokolliert.  Alle weiteren Nachrichten werden nur gezählt
	  und deren Gesamtzahl wird schließlich von &man.syslogd.8;
	  wie folgt ausgegeben:</para>

	<programlisting>Last message repeated 45 times</programlisting>

	<para>Alle protokollierten Pakete werden in der Voreinstellung
	  in <filename>/var/log/security</filename> gespeichert.  Dies
	  wird in <filename>/etc/syslog.conf</filename>
	  definiert.</para>
      </sect3>

      <sect3 xml:id="firewalls-ipfw-rules-script">
	<title>Ein Firewall-Regelwerk erstellen</title>

	<para>Die meisten fortgeschrittenen
	  <application>IPFW</application>-Benutzer erzeugen eine
	  Datei, welche die Regeln für die Firewall enthält, um diese
	  als Skript ausführen zu können.  Der Vorteil einer
	  derartigen Konfiguration besteht darin, dass dadurch mehrere
	  Regeln gleichzeitig geändert und aktiviert werden können,
	  ohne dass dazu das System neu gestartet werden muss.  Dies
	  ist zudem beim Testen von Regeländerungen sehr hilfreich.
	  Weil es sich bei der Datei um ein Skript handelt, ist es
	  auch möglich, häufig verwendete Befehle durch Aliase zu
	  ersetzen und diese dann in mehreren Regeln zu nutzen.</para>

	<para>Die Syntax des folgenden Skripts entspricht der Syntax
	  von &man.sh.1;, &man.csh.1; sowie &man.tcsh.1;.  Felder, die
	  symbolisch substituiert werden, haben das Präfix &dollar;
	  (Dollarzeichen).  Symbolische Felder haben das
	  &dollar;-Präfix nicht.  Der Wert, mit dem das symbolische
	  Feld belegt wird, muss in doppelten Anführungszeichen
	  ("") stehen.</para>

	<para>Die Datei mit den Regeln könnte wie folgt aufgebaut
	  sein:</para>

	<programlisting>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif="tun0"             # out interface
odns="192.0.2.11"      # ISP's DNS server IP address
cmd="ipfw -q add "     # build rule prefix
ks="keep-state"        # just too lazy to key this each time
&dollar;cmd 00500 check-state
&dollar;cmd 00502 deny all from any to any frag
&dollar;cmd 00501 deny tcp from any to any established
&dollar;cmd 00600 allow tcp from any to any 80 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00610 allow tcp from any to &dollar;odns 53 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00611 allow udp from any to &dollar;odns 53 out via &dollar;oif &dollar;ks
################### End of example ipfw rules script ############</programlisting>

	<para>Die Regeln in diesem Beispiel sind nicht wichtig.
	  Wichtig ist es, zu zeigen, wie die symbolische Substitution
	  innerhalb der Regeln verwendet wird.</para>

	<para>Wenn dieses Beispiel in
	  <filename>etc/ipfw.rules</filename> gespeichert wurde, so
	  könnten alle Regeln durch die Ausführung des folgenden
	  Kommandos neu geladen werden:</para>

	<screen>&prompt.root; <userinput>sh /etc/ipfw.rules</userinput></screen>

	<para>Anstelle von <filename>/etc/ipfw.rules</filename> kann
	  ein beliebig anderer Name oder Speicherort verwendet
	  werden.</para>

	<para>Alternativ können die einzelnen Befehle dieses Skripts
	  auch von Hand eingegeben werden:</para>

	<screen>&prompt.root; <userinput>ipfw -q -f flush</userinput>
&prompt.root; <userinput>ipfw -q add check-state</userinput>
&prompt.root; <userinput>ipfw -q add deny all from any to any frag</userinput>
&prompt.root; <userinput>ipfw -q add deny tcp from any to any established</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>
