<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/firewalls/chapter.sgml,v 1.33 2011/04/17 08:30:55 jkois Exp $
     basiert auf:  1.95
-->

<chapter id="firewalls">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Joseph J.</firstname>
	<surname>Barbish</surname>
	<contrib>Beigetragen von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Brad</firstname>
	<surname>Davis</surname>
	<contrib>Nach SGML konvertiert und aktualisiert von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	  <firstname>Michael</firstname>
	  <surname>Bunzel</surname>
	  <contrib>&Uuml;bersetzt von </contrib>
      </author>
      <author>
	<firstname>Johann</firstname>
	<surname>Kois</surname>
      </author>
      <author>
	<firstname>Benjamin</firstname>
	<surname>Lukas</surname>
      </author>
    </authorgroup>

  </chapterinfo>

  <title>Firewalls</title>

  <indexterm><primary>firewall</primary></indexterm>

  <indexterm>
    <primary>security</primary>

    <secondary>firewalls</secondary>
  </indexterm>

  <sect1 id="firewalls-intro">
    <title>Einf&uuml;hrung</title>

    <para>Firewalls erm&ouml;glichen es, den ein- und ausgehenden
      Netzwerkverkehr Ihres Systems zu filtern.  Dazu verwendet eine
      Firewall eine oder mehrere Gruppen von <quote>Regeln</quote>,
      um ankommende Netzwerkpakete zu untersuchen und entweder
      durchzulassen oder zu blockieren.  Die Regeln einer
      Firewall untersuchen charakteristische Eigenschaften von
      Datenpaketen, darunter den Protokolltyp, die Quell- und
      Zieladresse sowie den Quell- und Zielport.</para>

    <para>Firewalls k&ouml;nnen die Sicherheit eines Rechners oder
      eines Netzwerks erh&ouml;hen, indem sie folgende Aufgaben
      &uuml;bernehmen:</para>

    <itemizedlist>
      <listitem>
        <para>Den Schutz der Anwendungen, Dienste und Rechner Ihres
          internen Netzwerks vor unerw&uuml;nschtem Datenverkehr
          aus dem Internet.</para>
      </listitem>

      <listitem>
        <para>Die Beschr&auml;nkung des Zugriffs von Rechnern des
          internen Netzwerk auf Rechner oder Dienste des externen
          Internets.</para>
      </listitem>

      <listitem>
        <para>Den Einsatz von Network Address Translation
          (<acronym>NAT</acronym>), die es Ihnen durch die Verwendung
          von privaten <acronym>IP</acronym>-Adressen erm&ouml;glicht,
          eine einzige gemeinsame Internetverbindung f&uuml;r mehrere
          Rechner zu nutzen (entweder &uuml;ber eine einzige Adresse
          oder &uuml;ber eine Gruppe von jeweils automatisch
          zugewiesenen &ouml;ffentlichen
          <acronym>IP</acronym>-Adressen).</para>
      </listitem>
    </itemizedlist>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie:</para>

    <itemizedlist>
      <listitem>
      	<para>Wissen, wie man korrekte Paketfilterregeln erstellt.</para>
      </listitem>

      <listitem>
      	<para>Die Unterschiede zwischen den in &os; eingebauten Firewalls
      	  kennen.</para>
      </listitem>

      <listitem>
        <para>Wissen, wie man die <application>PF</application>-Firewall
          von OpenBSD konfiguriert und einsetzt.</para>
      </listitem>

      <listitem>
        <para><application>IPFILTER</application> konfigurieren und
          einsetzen k&ouml;nnen.</para>
      </listitem>

      <listitem>
        <para>Wissen, wie man <application>IPFW</application> konfiguriert
          und einsetzt.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie:</para>

    <itemizedlist>
      <listitem>
        <para>Die grundlegenden Konzepte von &os; und dem Internet
          verstehen.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="firewalls-concepts">
    <title>Firewallkonzepte</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>rulesets</secondary>
    </indexterm>

    <para>Es gibt zwei grundlegende Arten, Regelgruppen f&uuml;r
      Firewalls zu erstellen: <quote>einschlie&szlig;end</quote>
      (<foreignphrase>inclusive firewall</foreignphrase>) sowie
      <quote>auschlie&szlig;end</quote> (<foreignphrase>exclusive
      Firewall</foreignphrase>).  Eine auschlie&szlig;ende Firewall
      l&auml;sst jeden Datenverkehr durch, der nicht durch eine Regel
      ausgeschlossen wurde.  Eine einschlie&szlig;ende Firewall macht
      das genaue Gegenteil.  Sie l&auml;sst Datenverkehr nur dann
      durch, wenn er einer der definierten Regeln entspricht.</para>

    <para>Eine inclusive Firewall bietet eine wesentlich bessere Kontrolle
      des ausgehenden Verkehrs, macht sie zur besseren Wahl f&uuml;r Systeme,
      die Services f&uuml;r das Internet anbieten.  Sie kontrolliert
      auch den Verkehr vom Internet zu ihrem privaten Netzwerk.  Jeder Verkehr,
      der keiner Regel entspricht wird geblockt und geloggt.  Inclusive
      Firewalls sind generell sicherer als exclusive Firewalls, da sie das
      Risiko, dass unerw&uuml;nschter Verkehr hindurch geht, drastisch
      reduzieren.</para>

    <note>
      <para>Wenn nicht anders vermerkt, verwenden alle Konfigurationen
        und Beispielregelsets dieses Kapitels inclusive Firewalls.</para>
    </note>

    <para>Die Sicherheit einer Firewall kann durch den Einsatz einer
      <quote>zustandsabh&auml;ngigen Firewall</quote>
      (<foreignphrase>stateful firewall</foreignphrase>) weiter
      erh&ouml;ht werden.  Dieser Typ einer Firewall
      &uuml;berwacht alle durch die Firewall gehenden offenen
      Verbindungen und erlaubt nur schon bestehenden Verkehr oder
      Datenverkehr, der eine neue Verbindung &ouml;ffnet.  Der Nachteil
      einer zustandsabh&auml;ngigen Firewall ist allerdings, dass sie
      anf&auml;llig f&uuml;r Denial of Service (<acronym>DoS</acronym>)
      -Attacken ist, wenn sehr schnell sehr viele neue Verbindungen
      erstellt werden.  Bei den meisten Firewalls k&ouml;nnen Sie eine
      Kombination aus zustandsabh&auml;ngigem und nicht
      zustandsabh&auml;ngigem Verhalten verwenden, um eine f&uuml;r Ihre
      Bed&uuml;rfnisse optimale Firewall einzurichten.</para>
  </sect1>

  <sect1 id="firewalls-apps">
    <title>Firewallpakete</title>

    <para>Das Basissystem von &os; enth&auml;lt bereits drei
      Firewallpakete:  <emphasis>IPFILTER</emphasis> (auch als
      <acronym>IPF</acronym> bekannt), <emphasis>IPFIREWALL</emphasis>
      (auch als <acronym>IPFW</acronym> bezeichnet) sowie das von OpenBSD
      &uuml;bernommene <emphasis>PacketFilter</emphasis> (das auch als
      <acronym>PF</acronym> bezeichnet wird).  Zus&auml;tzlich
      verf&uuml;gt &os; &uuml;ber zwei eingebaute Pakete f&uuml;r das
      sogenannte <foreignphrase>traffic shaping</foreignphrase> (dabei
      handelt es sich die Steuerung des Bandbreitenverbrauchs):
      &man.altq.4; sowie &man.dummynet.4;.  Dummynet steht traditionell
      in enger Verbindung mit <acronym>IPFW</acronym>, w&auml;hrend
      <acronym>ALTQ</acronym> gemeinsam mit <acronym>PF</acronym> 
      eingesetzt wird.  Traffic Shaping f&uuml;r IPFILTER ist derzeit
      mit IPFILTER f&uuml;r NAT sowie Filterung und
      mit <acronym>IPFW</acronym> und &man.dummynet.4;
      <emphasis>oder</emphasis> durch die Kombination von
      <acronym>PF</acronym> mit <acronym>ALTQ</acronym> m&ouml;glich.
      Gemeinsam ist allen Firewallpaketen (IPF, IPFW sowie PF), dass sie
      Regeln einsetzen, um den Transfer von Datenpaketen auf und von
      Ihrem System zu regeln.  Unterschiedlich sind aber die Art und
      Weise, wie dies realisiert wird.  Auch die f&uuml;r diese Regeln
      verwendete Syntax ist unterschiedlich.</para>

    <para>&os; &uuml;berl&auml;sst es dem Anwender, das Firewallsystem
      zu w&auml;hlen, dass seinen Anforderungen und Vorlieben am Besten
      entspricht.  Keines der im Basissystem enthaltenen Firewallpakete
      wird dabei als <quote>das beste</quote> angesehen.</para>

    <para>IPFILTER hat etwa den Vorteil, dass dessen
      zustandsabh&auml;ngige Regeln relativ einfach in einer
      <acronym>NAT</acronym>-Umgebung implementiert werden k&ouml;nnen.
      Au&szlig;erdem verf&uuml;gt es &uuml;ber einen eigenen FTP-Proxy,
      der die Erstellung von sicheren Regeln f&uuml;r ausgehende
      FTP-Verbindungen vereinfacht.</para>

    <para>Da alle Firewalls auf der Untersuchung der Werte
      ausgew&auml;hlter Kontrollfelder von Datenpaketen basieren, ist es
      f&uuml;r die Erstellung von Firewallregeln notwendig, die
      Funktionsweise von <acronym>TCP/IP</acronym> zu verstehen.
      Au&szlig;erdem muss man dazu wissen, was die Werte der einzelnen
      Kontrollfelder bedeuten und wie diese w&auml;hrend einer
      Verbindung eingesetzt werden.  Eine gute Erkl&auml;rung dieser
      Thematik finden Sie unter <ulink
      url="http://www.ipprimer.com/overview.cfm"></ulink>.</para>
  </sect1>

  <sect1 id="firewalls-pf">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>John</firstname>
          <surname>Ferrell</surname>
          <contrib>Revised and updated by </contrib>
          <!-- 24 March 2008 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>Paket Filter (PF) von OpenBSD und
      <acronym>ALTQ</acronym></title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>PF</secondary>
    </indexterm>

    <para>Im Juli 2003 wurde <acronym>PF</acronym>, die
      Standard-Firewall von OpenBSD, nach &os; portiert und in die
      &os;-Ports-Sammlung aufgenommen.  2004 war <acronym>PF</acronym> in
      &os;&nbsp;5.3 Teil des Basissystems.  Bei <acronym>PF</acronym>
      handelt es sich um eine komplette, vollausgestattete Firewall,
      die optional auch <acronym>ALTQ</acronym> (Alternatives
      Queuing) unterst&uuml;tzt.  <acronym>ALTQ</acronym> bietet Ihnen
      <foreignphrase>Quality of Service</foreignphrase>
      (<acronym>QoS</acronym>)-Bandbreitenformung.</para>

    <para>Das OpenBSD-Projekt leistet bereits hervorragende
      Dokumentationsarbeit mit der <ulink
      url="http://www.openbsd.org/faq/pf/">PF FAQ</ulink>.  Aus diesem Grund
      konzentriert sich dieser Handbuchabschnitt nur auf diejenigen
      Besonderheiten von <acronym>PF</acronym>, die &os; betreffen, sowie ein
      paar allgemeine Informationen hinsichtlich der Verwendung.  Genauere
      Informationen zum Einsatz erhalten Sie in der <ulink
      url="http://www.openbsd.org/faq/pf/">PF FAQ</ulink>.</para>

    <para>Weitere Informationen zu <acronym>PF</acronym> f&uuml;r &os; finden
      Sie unter <ulink url="http://pf4freebsd.love2party.net/"></ulink>.</para>

    <sect2>
      <title>Verwendung der PF-Kernelmodule</title>

      <para>Um die PF Kernel Module zu laden, f&uuml;gen Sie folgende
        Zeile in ihre <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>pf_enable="YES"</programlisting>

      <para>Danach starten Sie das Startup Script um die Module
        zu laden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/pf start</userinput></screen>

      <para>Das PF Modul wird nicht geladen, falls es die Ruleset
        Konfigurationsdatei nicht findet.  Standardm&auml;ssig befindet
        sich diese Datei in <filename>/etc/pf.conf</filename>.  Falls das
        PF Ruleset sich an einem anderen Platz befindet, k&ouml;nnen Sie das
        durch Hinzuf&uuml;gen einer Zeile &auml;hnlich der folgenden, in
        ihrer <filename>/etc/rc.conf</filename> &auml;ndern:</para>

      <programlisting>pf_rules="<replaceable>/path/to/pf.conf</replaceable>"</programlisting>

      <note>
		<para>Ein Beispiel f&uuml;r die Datei <filename>pf.conf</filename>
		  finden Sie im Verzeichnis <filename
		  class="directory">/usr/share/examples/pf/</filename>.</para>
      </note>

      <para>Das <acronym>PF</acronym>-Modul kann auch manuell &uuml;ber die
        Kommandozeile geladen werden:</para>

      <screen>&prompt.root; <userinput>kldload pf.ko</userinput></screen>

      <para>Protokollierungsfunktionen f&uuml;r PF werden durch das Modul
        <literal>pflog.ko</literal> zur Verf&uuml;gung gestellt und
        k&ouml;nnen durch folgenden Eintrag in der
        <filename>/etc/rc.conf</filename> aktiviert werden:</para>

      <programlisting>pflog_enable="YES"</programlisting>

      <para>Danach starten Sie das Startup Script, um das Modul
        zu laden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/pflog start</userinput></screen>

      <para>Falls Sie noch weitere Features f&uuml;r
        <acronym>PF</acronym> ben&ouml;tigen, m&uuml;ssen Sie diese in den
        Kernel einbauen.</para>
    </sect2>

    <sect2>
      <title>PF Kernel-Optionen</title>

      <indexterm>
		<primary>kernel options</primary>

		<secondary>device pf</secondary>
      </indexterm>

      <indexterm>
		<primary>kernel options</primary>

		<secondary>device pflog</secondary>
      </indexterm>

      <indexterm>
		<primary>kernel options</primary>

		<secondary>device pfsync</secondary>
      </indexterm>

      <para>Es ist nicht zwingend n&ouml;tig, dass Sie
        <acronym>PF</acronym>-Unterst&uuml;tzung in den &os;-Kernel
        kompilieren.  Sie werden dies tun m&uuml;ssen, um eine von PFs
        fortgeschritteneren Eigenschaften nutzen zu k&ouml;nnen, die nicht als
        Kernelmodul verf&uuml;gbar ist.  Genauer handelt es sich dabei um
        &man.pfsync.4;, ein Pseudo-Ger&auml;t, welches bestimmte
        &Auml;nderungen der <acronym>PF</acronym>-Zustandstabelle offenlegt.
        Es kann mit &man.carp.4; kombiniert werden, um ausfallsichere
        Firewalls mit <acronym>PF</acronym> zu realisieren.  Weitere
        Informationen zu <acronym>CARP</acronym> erhalten Sie in
        <xref linkend="carp"> des Handbuchs.</para>

      <para>Die Kernelkonfigurationsoptionen von <acronym>PF</acronym> befinden
        sich in <filename>/usr/src/sys/conf/NOTES</filename> und sind im
        Folgenden wiedergegeben:</para>

      <programlisting>device pf
device pflog
device pfsync</programlisting>

      <para>Die Option <literal>device pf</literal> aktiviert die
        Unterst&uuml;tzung f&uuml;r die <quote>Packet
        Filter</quote>-Firewall (&man.pf.4;).</para>

      <para>Die Option <literal>device pflog</literal> aktiviert das optionale
        &man.pflog.4;-Pseudonetzwerkger&auml;t, das zum Protokollieren
        des Datenverkehrs &uuml;ber einen &man.bpf.4;-Deskriptor
        dient.  &man.pflogd.8; ist in der Lage, diese Protokolldateien
        auf Ihre Platte zu speichern.</para>

      <para>Die Option <literal>device pfsync</literal> aktiviert das optionale
        &man.pfsync.4;-Pseudonetzwerkger&auml;t f&uuml;r die
        &Uuml;berwachung von <quote>Status&auml;nderungen</quote>.</para>
    </sect2>

    <sect2>
      <title>Verf&uuml;gbare rc.conf-Optionen</title>

      <para>Die	folgenden &man.rc.conf.5;-Eintr&auml;ge konfigurieren
        <acronym>PF</acronym> und &man.pflog.4; beim Systemstart:</para>

      <programlisting>pf_enable="YES"                 # PF aktivieren (Modul, wenn n&ouml;tig, aktivieren)
pf_rules="/etc/pf.conf"         # Datei mit Regeldefinitionen f&uuml;r pf
pf_flags=""                     # zus&auml;tzliche Parameter f&uuml;r den Start von pfctl
pflog_enable="YES"              # starte pflogd(8)
pflog_logfile="/var/log/pflog"  # wo soll pflogd die Protokolldatei speichern
pflog_flags=""                  # zus&auml;tzliche Parameter f&uuml;r den Start von pflogd</programlisting>

      <para>Wenn Sie ein lokales Netzwerk hinter dieser Firewall betreiben
        und Pakete f&uuml;r dessen Rechner weiterleiten oder NAT verwenden
        wollen, ben&ouml;tigen Sie zus&auml;tzlich die folgende Option:</para>

      <programlisting>gateway_enable="YES"            # LAN Gateway aktivieren</programlisting>
    </sect2>

    <sect2>
      <title>Filterregeln erstellen</title>

      <para><acronym>PF</acronym> liest seine konfigurierten Regeln aus
        &man.pf.conf.5; (standardm&auml;ssig <filename>/etc/pf.conf</filename>)
        und modifiziert, verwirft oder l&auml;sst Pakete passieren anhand der
        Regeln oder Definitionen, die in dieser Datei gespeichert sind.  &os;
        enth&auml;lt dazu nach der Installation mehrere Beispieldateien, die
        in <filename>/usr/share/examples/pf/</filename> abgelegt sind.
        F&uuml;r eine ausf&uuml;hrliche Behandlung des
        <acronym>PF</acronym>-Regelwerks lesen Sie bitte die <ulink
        url="http://www.openbsd.org/faq/pf/">PF FAQ</ulink>.</para>

      <warning>
        <para>Beim Lesen der <ulink
          url="http://www.openbsd.org/faq/pf/">PF FAQ</ulink> wollten Sie
          darauf achten, dass verschiedene Versionen von &os; auch
          unterschiedliche Versionen von PF enthalten.  Aktuelle
          &os;-Versionen benutzen die selbe Version von
          <acronym>PF</acronym> wie OpenBSD&nbsp;4.1.</para>
      </warning>

      <para>Die &a.pf; ist eine erste Anlaufstelle f&uuml;r
        Fragen zur Konfiguration und dem Einsatz der <acronym>PF</acronym>
        Firewall.  Vergessen Sie nicht, vorher die Mailinglistenarchive zu
        durchsuchen, bevor Sie dort eine Frage stellen!</para>
    </sect2>

    <sect2>
      <title>Arbeiten mit PF</title>

      <para>Benutzen Sie &man.pfctl.8;, um <acronym>PF</acronym> zu steuern.
        Unten finden Sie ein paar n&uuml;tzliche Befehle (lesen Sie auch die
        Manualpage zu &man.pfctl.8;, um alle verf&uuml;gbaren Optionen
        nachzuschlagen):</para>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Befehl</entry>
              <entry>Zweck</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><command>pfctl <option>-e</option></command></entry>
              <entry>PF aktivieren</entry>
            </row>

            <row>
              <entry><command>pfctl <option>-d</option></command></entry>
              <entry>PF deaktivieren</entry>
            </row>

            <row>
              <entry><command>pfctl <option>-F</option> all <option>-f</option> /etc/pf.conf</command></entry>
              <entry>Alle Filterregeln zur&uuml;cksetzen (NAT, Filter, Zustand,
                Tabelle, etc.) und erneut aus der Datei
                <filename>/etc/pf.conf</filename> auslesen</entry>
            </row>

            <row>
              <entry><command>pfctl <option>-s</option> [ Regeln | NAT |
                Zustand ]</command></entry>
              <entry>Bericht &uuml;ber die Filterregeln, NAT-Regeln, oder
                Zustandstabellen</entry>
            </row>

            <row>
              <entry><command>pfctl <option>-vnf</option> /etc/pf.conf</command></entry>
              <entry>&uuml;berpr&uuml;ft <filename>/etc/pf.conf</filename> auf
                Fehler, l&auml;dt aber das Regelwerk nicht neu</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title><acronym>ALTQ</acronym> aktivieren</title>

      <para><acronym>ALTQ</acronym> muss vor der Verwendung in den
        &os;-Kernel kompiliert werden.  Beachten Sie, dass
        <acronym>ALTQ</acronym> nicht von allen verf&uuml;gbaren
        Netzwerkkartentreibern unterst&uuml;tzt wird.  Sehen Sie daher
        zuerst in &man.altq.4; nach, ob Ihre Netzwerkkarte diese
        Funktion unter Ihrer &os;-Version unterst&uuml;tzt.</para>

      <para>Die	folgenden Kerneloptionen aktivieren <acronym>ALTQ</acronym>
        sowie alle Zusatzfunktionen:</para>

      <programlisting>options         ALTQ
options         ALTQ_CBQ        # Class Bases Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)
options         ALTQ_NOPCC      # Wird von SMP ben&ouml;tigt</programlisting>

      <para><literal>options ALTQ</literal> aktiviert das
	<acronym>ALTQ</acronym>-Framework.</para>

      <para><literal>options ALTQ_CBQ</literal> aktiviert das
        <emphasis>Class Based Queuing</emphasis> (<acronym>CBQ</acronym>).
        <acronym>CBQ</acronym> erlaubt es, die Bandbreite einer Verbindung in
        verschiedene Klassen oder Warteschlangen zu unterteilen, um die
        Priorit&auml;t von Datenpaketen basierend auf Filterregeln zu
        &auml;ndern.</para>

      <para><literal>options ALTQ_RED</literal> aktiviert
        <emphasis>Random Early Detection</emphasis>
        (<acronym>RED</acronym>).  <acronym>RED</acronym> wird
        zur Vermeidung einer Netzwerkverstopfung verwendet.  Dazu
        ermittelt <acronym>RED</acronym> die Gr&ouml;&szlig;e der
        Warteschlange und vergleicht diesen Wert mit den minimalen
        und maximalen Grenzwerten der Warteschlange.  Ist die
        Warteschlange gr&ouml;&szlig;er als das erlaubte Maximum,
        werden alle neuen Pakete verworfen.  Getreu seinem Namen
        verwirft <acronym>RED</acronym> Pakete unterschiedlicher
        Verbindungen nach dem Zufallsprinzip.</para>

      <para><literal>options ALTQ_RIO</literal> aktiviert
        <emphasis>Random Early Detection In and	Out</emphasis>.</para>

      <para><literal>options ALTQ_HFSC</literal> aktiviert den
        <emphasis>Hierarchical Fair Service Curve</emphasis>-Paketplaner.
        Weitere Informationen zu <acronym>HFSC</acronym> finden Sie
        unter <ulink
        url="http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html"></ulink>.</para>

      <para><literal>options ALTQ_PRIQ</literal> aktiviert
        <emphasis>Priority Queuing</emphasis> (<acronym>PRIQ</acronym>).
        <acronym>PRIQ</acronym>	l&auml;sst Verkehr einer Warteschlange mit
        h&ouml;herer Priorit&auml;t zuerst durch.</para>

      <para><literal>options ALTQ_NOPCC</literal> aktiviert die
        <acronym>SMP</acronym> Unterst&uuml;tzung von
        <acronym>ALTQ</acronym>.  Diese Option ist nur auf
        <acronym>SMP</acronym>-System erforderlich.</para>
    </sect2>
  </sect1>

  <sect1 id="firewalls-ipf">
    <title>Die IPFILTER-Firewall (IPF)</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>IPFILTER</secondary>
    </indexterm>

    <para>Geschrieben wurde IPFILTER von Darren Reed.  IPFILTER ist vom
      Betriebssystem unabh&auml;ngig: Es ist eine Open Source Anwendung,
      die auf die Betriebssysteme &os;, NetBSD, OpenBSD, &sunos;, HP/UX
      und &solaris; portiert wurde.  IPFILTER wird aktiv betreut und
      gepflegt.  Es werden regelm&auml;&szlig;ig neue Versionen
      herausgegeben.</para>

    <para>IPFILTER basiert auf einer kernelseitigen Firewall und einem
      <acronym>NAT</acronym> Mechanismus, der durch Anwenderprogramme
      betreut und gesteuert werden kann.  Die Regeln der Firewall werden
      mit dem Programm &man.ipf.8; gesetzt oder gel&ouml;scht.  F&uuml;r
      die Manipulation der <acronym>NAT</acronym> Regeln verwendet man
      &man.ipnat.1;.  Mit &man.ipfstat.8; werden Laufzeitstatistiken der
      kernelseitigen Anteile von IPFILTER aufgelistet.  Und mit dem
      Programm &man.ipmon.8; kann man die Aktionen von IPFILTER in die
      Protokolldateien des Systems speichern.</para>

    <para>IPF funktionierte urspr&uuml;nglich mit einer 
      Regel-Proze&szlig;-Logik &agrave; la <quote>die letzte Regel, die
      pa&szlig;t, entscheidet</quote> und verwendete ausschlie&szlig;lich
      Regeln ohne feste Zust&auml;nde.  Inzwischen wurde die
      Regel-Proze&szlig;-Logik drastisch modernisiert:  Es gibt eine
      <option>quick</option> und eine zustandsorientierte <option>
      keep-state</option> Option.  Die offizielle Dokumentation beinhaltet
      leider nur die veralteten Parameter zur Regelerstellung - die neuen
      Funktionen werden nur als Zusatzoptionen aufgelistet, was ihre
      Vorteile beim Erstellen einer weit &uuml;berlegenen und viel
      sichereren Firewall v&ouml;llig untergr&auml;bt.</para>

    <para>Die Anweisungen in diesem Kapitel basieren darauf, Regeln mit
      den Optionen <option>quick</option> und <option>keep-state</option>
      zu erstellen.  Mit diesem Grundwissen wird man einen kompletten
      einschlie&szlig;enden Regelsatz erstellen k&ouml;nnen.</para>

    <para>F&uuml;r eine ausf&uuml;hrliche Erl&auml;uterung der alten Methode
      zur Regelverarbeitung schauen Sie bitte auf <ulink
      url="http://www.obfuscation.org/ipf/ipf-howto.html#TOC_1"></ulink>
      oder <ulink
      url="http://coombs.anu.edu.au/~avalon/ip-filter.html"></ulink>.</para>

    <para>Antworten auf h&auml;ufige Fragen finden Sie unter
      <ulink url="http://www.phildev.net/ipf/index.html"></ulink>.</para>

    <para>Und ein durchsuchbares Archiv der Mailingliste zu IPFILTER
      gibt es unter <ulink
      url="http://marc.theaimsgroup.com/?l=ipfilter"></ulink>.</para>

    <sect2>
      <title>Aktivieren von IPF</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>enabling</secondary>
      </indexterm>

      <para>&os; enth&auml;lt IPF in der Standardversion als ladbares
        Kernelmodul.  Dieses Modul wird vom System automatisch geladen,
        wenn in der <filename>rc.conf</filename> der Eintrag<literal>
        ipfilter_enable="YES"</literal> angelegt wird. In dieser
        urspr&uuml;nglichen Konfiguration ist die Protokollierung aktiv
        und	die Option <literal>default pass all</literal> ("Pakete passieren
        lassen") als Standard gesetzt.  Um die <literal>block all</literal>
        ("alles Blockieren") Option zu setzen, mu&szlig; man nicht gleich
        einen neuen Kernel bauen - es reicht, <literal>block all</literal>
        als letzte Position des Regelsatzes aufzulisten.</para>
    </sect2>

    <sect2>
      <title>Kernel-Optionen</title>

	  <indexterm>
	  	<primary>kernel options</primary>

		<secondary>IPFILTER</secondary>
      </indexterm>

      <indexterm>
		<primary>kernel options</primary>

		<secondary>IPFILTER_LOG</secondary>
      </indexterm>

      <indexterm>
		<primary>kernel options</primary>

		<secondary>IPFILTER_DEFAULT_BLOCK</secondary>
      </indexterm>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>kernel options</secondary>
      </indexterm>

      <para>Es ist nicht unbedingt notwendig, IPF durch die folgenden
        Optionen direkt in der Kernel einzubinden.  Diese M&ouml;glichkeit
        der Verwendung von IPF wird hier mehr als Hintergrundwissen angeboten.
        Man sollte nur wissen, dass dadurch nicht mehr das Kernelmodul geladen
        wird - und dementsprechend auch nicht mehr entladen werden kann.</para>

      <para>Die Beschreibung der einzelnen Optionen von IPF f&uuml;r die
        Verwendung in der Kernelkonfiguration finden Sie auch in der Datei
        <filename>/usr/src/sys/conf/NOTES</filename>.</para>

      <programlisting>options IPFILTER
options IPFILTER_LOG
options IPFILTER_DEFAULT_BLOCK</programlisting>

      <para><literal>options IPFILTER</literal> aktiviert die Verwendung
	der <quote>IPFILTER</quote> Firewall.</para>

      <para><literal>options IPFILTER_LOG</literal> aktiviert den
        Logging-Mechanismus.  Das bedeutet, dass jedes Paket geloggt wird,
        auf das eine Regel pa&szlig;t, die das Schl&uuml;sselwort
        <literal>log</literal> enth&auml;lt.  Dazu wird der
        Pseudo&mdash;Device	<devicename>ipl</devicename> verwendet.</para>

      <para><literal>options IPFILTER_DEFAULT_BLOCK</literal> &auml;ndert
        das Verhalten der Firewall dahingehend, dass jedes Paket, dass nicht
        explizit von einer <literal>pass</literal> Regel Zugang erh&auml;lt,
        abgewiesen, bzw. geblockt, wird.</para>

      <para>Diese Einstellungen werden erst aktiv, wenn der Kernel, in den sie
      	eingebunden wurden, kompiliert, installiert und gebootet wurde.</para>
    </sect2>

    <sect2>
      <title>Optionen in rc.conf</title>

      <para>Um IPF w&auml;hrend des Bootvorgangs einzubinden, braucht man
        lediglich die folgenden Zeilen der Datei
        <filename>/etc/rc.conf</filename> anzuf&uuml;gen:</para>

      <programlisting>ipfilter_enable="YES"             # Startet IPF
ipfilter_rules="/etc/ipf.rules"   # liest den Regelsatz aus einer Datei
ipmon_enable="YES"                # Startet das IP-Monitor Log
ipmon_flags="-Ds"                 # D = Als Da:mon starten
                                  # s = Protokollierung via syslog
                                  # v = Protokollierung von tcp window, ack, seq
                                  # n = Namen statt IP &amp; port ausgeben
      </programlisting>

      <para>Falls sich hinter der Firewall ein lokales Netzwerk befindet,
        das den reservierten privaten Adressbereich verwendet, m&uuml;ssen
        die folgenden Zeilen zur Aktivierung von <acronym>NAT</acronym>
        ebenfalls in <filename>/etc/rc.conf</filename> eingetragen
        werden:</para>

      <programlisting>gateway_enable="YES"              # Aktivierung des LAN-Gateways
ipnat_enable="YES"                # Startet die ipnat Funktion
ipnat_rules="/etc/ipnat.rules"    # Liest die ipnat-Regeldefinitionen aus einer Datei
      </programlisting>
    </sect2>

    <sect2>
      <title>Der Befehl ipf</title>

      <indexterm><primary><command>ipf</command></primary></indexterm>

      <para>Mit dem Befehl &man.ipf.8; liest man die Datei, die den Regelsatz
      	enth&auml;lt ein.  Mit dem folgenden Befehl k&ouml;nnen Sie Ihre
      	eigenen, f&uuml;r Ihr System ma&szlig;geschneiderten Regeln einlesen
      	und so in einem Schritt alle Regeln der laufenden Firewall
      	ersetzen:</para>

      <screen>&prompt.root; <userinput>ipf -Fa -f /etc/ipf.rules</userinput></screen>

      <para><option>-Fa</option> bedeutet, dass alle intern gespeicherten
        Tabellen mit Regeln gel&ouml;scht werden.</para>

      <para><option>-f</option> gibt die Datei an, aus der die neuen Regeln
        gelesen werden sollen.</para>

      <para>Mit diesen beiden Optionen erhalten Sie die M&ouml;glichkeit,
        &Auml;nderungen an der Datei mit Ihrem Regelsatz vorzunehmen und
        gleich die Firewall mit den neuen Regeln zu best&uuml;cken, ohne
        den Rechner neu starten zu m&uuml;ssen.  Da dieser Vorgang beliebig
        wiederholt werden kann, ist es ein sehr bequemer Weg, neue Regeln
        einzuarbeiten und zu testen.</para>

      <para>Um mehr &uuml;ber diese und weitere Optionen von &man.ipf.8;
        zu erfahren, konsultieren Sie bitte die Manpage.</para>

      <para>&man.ipf.8; erwartet, dass es sich bei der Datei mit dem Regelsatz
        um eine Standard-Textdatei handelt.  Eine Datei, die ein Skript oder
        Variablen enth&auml;lt, wird nicht verarbeitet.</para>

      <para>Es gibt allerdings doch einen Weg, IPF Regeln mit Hilfe von
        Skripten und Variablen zu erstellen.  Weitere Informationen dazu
        finden Sie unter <xref linkend="firewalls-ipf-rules-script">.</para>
    </sect2>

    <sect2>
      <title>IPFSTAT</title>

      <indexterm><primary><command>ipfstat</command></primary></indexterm>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>statistics</secondary>
     </indexterm>

      <para>Das normale Verhalten von &man.ipfstat.8; ist, die Zusammenfassung
      	der angefallenen Statistiken, die als Resultat der Anwendung von
      	nutzerspezifischen Regeln auf ein- und ausgehende Pakete seit dem
      	letzten Start der Firewall oder seit dem letzten Zur&uuml;cksetzen
      	der Z&auml;hler auf Null durch das Kommando
      	<command>ipf -Z</command> angesammelt wurden, abzurufen und 
      	anzuzeigen.</para>

      <para>F&uuml;r weiterf&uuml;hrende Informationen schauen Sie bitte
        auf die Manpage von &man.ipfstat.8;!</para>

      <para>Die Ausgabe von &man.ipfstat.8;, wenn keine Parameter
        &uuml;bergeben wurden, sieht etwa so aus:</para>

      <screen>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
input packets logged: blocked 99286 passed 0
output packets logged: blocked 0 passed 0
packets logged: input 0 output 0
log failures: input 3898 output 0
fragment state(in): kept 0 lost 0
fragment state(out): kept 0 lost 0
packet state(in): kept 169364 lost 0
packet state(out): kept 431395 lost 0
ICMP replies: 0 <acronym>TCP</acronym> RSTs sent: 0
Result cache hits(in): 1215208 (out): 1098963
IN Pullups succeeded: 2 failed: 0
OUT Pullups succeeded: 0 failed: 0
Fastroute successes: 0 failures: 0
<acronym>TCP</acronym> cksum fails(in): 0 (out): 0
Packet log flags set: (0)</screen>

      <para>Wenn die Option <option>-i</option> f&uuml;r
        <quote>eingehend</quote> oder <option>-o</option> f&uuml;r
        <quote>ausgehend</quote> &uuml;bergeben wird, liefert das Kommando
        eine entsprechende Liste von Filter-Regeln, die gerade installiert
        sind und vom Kernel verwendet werden.</para>

      <para><command>ipfstat -in</command> zeigt alle aktive Regeln
        f&uuml;r eingehende Verbindungen zusammen mit ihren Nummern.</para>

      <para><command>ipfstat -on</command> erledigt dasselbe f&uuml;r die
      	ausgehenden Verbindungen.</para>

      <para>Die Ausgabe sieht in etwa folgerma&szlig;en aus:</para>

      <screen>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para><command>ipfstat -ih</command> zeigt die Tabelle der aktiven
        Regeln f&uuml;r eingehende Verbindungen zusammen mit der Anzahl,
        wie oft jeder einzelnen Regel entsprochen wurde.</para>

      <para><command>ipfstat -oh</command> zeigt das Gleiche f&uuml;r
      	die ausgehenden Verbindungen.</para>

      <para>Hier wird die Ausgabe so oder so &auml;hnlich aussehen:</para>

      <screen>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>Einer der wichtigsten Funktionen von <command>ipfstat</command>
        wird &uuml;ber die Option <option>-t</option> bereitgestellt.  Mit
        ihr wird eine Statustabelle vergleichbar der Proze&szlig;-Tabelle
        von &man.top.1; ausgegeben.  Mit dieser Funktion erhalten Sie im
        Falle eines Angriffs die M&ouml;glichkeit, die angreifenden Pakete
        zu identifizieren, abzufangen und auszuwerten.  Weitere Unteroptionen
        er&ouml;ffnen, die IP-Adresse, den Port oder das Protokoll, geteilt
        nach Herkunft und Ziel, auszuw&auml;hlen und dann in Echtzeit zu
        beobachten. Lesen Sie dazu bitte auch die Manpage von
        &man.ipfstat.8;.</para>
    </sect2>

    <sect2>
      <title>IPMON</title>

      <indexterm><primary><command>ipmon</command></primary></indexterm>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>logging</secondary>
     </indexterm>

      <para>Damit der Befehl <command>ipmon</command> korrekt arbeiten kann,
        mu&szlig; die Option <literal>IPFILTER_LOG</literal> in die
        Kernelkonfiguration eingearbeitet werden.  Das Kommando selbst
        arbeitet in zwei verschiedenen Modi.  F&uuml;r den nativen Modus
        startet man <command>ipmon</command> auf der Kommandozeile ohne die
        Option <option>-D</option>.</para>

      <para>Der Hintergrundmodus (<literal>daemon mode</literal>) dient der
        Erstellung eines stetigen Systemprotokolls, so dass Eintr&auml;ge
        vergangener Ereignisse inspiziert werden k&ouml;nnen. So sollen &os;
        und IPFILTER entsprechend ihrer Konfiguration zusammen arbeiten.
        &os; kann mit einem eingebauten Mechanismus Systemprotokolle
        turnusm&auml;&szlig;ig abspeichern.  Aus diesem Grund sollte man
        besser &man.syslogd.8; verwenden anstatt die Protokollinformationen
        in eine Datei zu schreiben, wie es als Standard vorgesehen ist.  In
        der Standard-<filename>rc.conf</filename>-Datei (im Ordner
        <filename>/etc/defaults/</filename>) wird dem Eintrag
        <literal>ipmon_flags</literal> die Option <option>-Ds</option>
        &uuml;bergeben:</para>

      <programlisting>ipmon_flags="-Ds" # D = Als Da:mon starten
# s = Protokollierung via syslog
# v = Protokollierung von tcp window, ack, seq
# n = Namen statt IP &amp; port ausgeben</programlisting>

      <para>Die Vorteile des Protokollierens liegen auf der Hand:  Sie
        versetzen den Administrator in die Lage, nach einem Vorfall
        Informationen abzurufen, etwa welche Pakete aussortiert wurden,
       	welche Adressen diese Pakete gesendet haben oder wohin sie gesendet
       	werden sollten.  Alles in allem erh&auml;lt er ein sehr gutes Werkzeug
       	zum Aufsp&uuml;ren von Angreifern.</para>

      <para>Jedoch, auch wenn die Protokollierung aktiviert ist, wird IPF
        keine einzige Regel zum Protokollieren von alleine entwerfen und
        umsetzen.  Der Administrator der Firewall entscheidet, welche Regeln
        in seinem Regelsatz mitgeschrieben werden sollen und er mu&szlig;
        dementsprechend das Schl&uuml;sselword <literal>log</literal> in
        dieser Regel angeben.  Normalerweise werden nur Treffer auf abweisende
        Regeln protokolliert.</para>

      <para>Es ist &uuml;blich, als letzte Regel eine alles blockierende
        Regel mit dem Schl&uuml;sselwort <literal>log</literal> in den
        Regelsatz einzutragen. Dadurch erkennt man alle Pakete, die keiner
        Regel im Regelsatz entsprachen.</para>
    </sect2>

    <sect2>
      <title>IPMON Logging</title>

      <para><application>Syslogd</application> verwendet seine eigene Methode
        zum Sortieren der gesammtelten Protokolldaten - spezielle Gruppierungen
        namens <quote>facility</quote> und <quote>level</quote>.  IPMON
        verwendet im <literal>daemon</literal>-Modus als
        <quote>facility</quote> den Wert <literal>security</literal>.  Die
        folgenden <quote>level</quote> k&ouml;nnen f&uuml;r eine genauere
        Trennung der Protokolldaten verwendet werden:</para>

      <screen>LOG_INFO - Alle zu protokollierenden Pakete
LOG_NOTICE - Protokollierte Pakete, die passieren durften
LOG_WARNING - Protokollierte Pakete, die blockiert wurden
LOG_ERR - Protokollierte Pakete, deren Headerdaten nicht komplett vorlagen</screen>

      <para>Damit IPFILTER angewiesen werden kann, alle Protokolldaten in
        die Datei <filename>/var/log/ipfilter.log</filename> zu schreiben,
        mu&szlig; diese erst erstellt werden.  Folgendes Kommando
        &uuml;bernimmt diese Aufgabe:</para>

      <screen>&prompt.root; <userinput>touch /var/log/ipfilter.log</userinput></screen>

      <para>Die Funktionen von &man.syslogd.8; werden durch Definition in
        der Datei <filename>/etc/syslog.conf</filename> gesteuert.  In dieser
        Datei kann sehr weitl&auml;fig eingestellt werden, wie
        <application>syslog</application> mit den Systemnachrichten umgehen
        soll, die ihm von Anwendungen wie IPF &uuml;bergeben werden.</para>

      <para>F&uuml;gen Sie folgende Definition in die Datei 
        <filename>/etc/syslog.conf</filename> ein, um die Protokollierung
        f&uuml;r IPF via <filename>syslog</filename> zu aktivieren:</para>

      <programlisting>security.* /var/log/ipfilter.log</programlisting>

      <para><literal>security.*</literal> bedeutet, dass alle Nachrichten
        der Klasse <literal>security.*</literal> am angegebenen Ort (hier
        eine Datei) geschrieben werden sollen.</para>

      <para>Um &Auml;nderungen an der Datei
        <filename>/etc/syslog.conf</filename> zu aktivieren m&uuml;ssen Sie
        den Rechner neu starten, oder den Befehl</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/syslogd reload</userinput></screen>

      <para>ausf&uuml;hren.</para>

      <para>Vergessen Sie nicht, <filename>/etc/newsyslog.conf</filename>
        anzupassen, damit die neuen Protokolldateien, die eben konfiguriert
        wurden, auch in den Rotationsturnus eingef&uuml;gt werden!</para>
    </sect2>

    <sect2>
      <title>Die Formatierung der Logdatei</title>

      <para>Nachrichten, die durch <command>ipmon</command> erzeugt werden,
        bestehen aus durch Leerstellen getrennten Datenfeldern.  Folgende
        Felder sind in allen Nachrichten enthalten:</para>

      <orderedlist>
		<listitem>
		  <para>Das Datum der Paketerstellung.</para>
		</listitem>

		<listitem>
		  <para>Die Uhrzeit der Paketerstellung in der Form
		    <literal>HH:MM:SS.F</literal>, mit Stunden, Minuten, Sekunden
		    und Sekundenbruchteilen, wobei letztere mehrere Stellen lang
		    sein k&ouml;nnen.</para>
		</listitem>

		<listitem>
		  <para>Der Name der Schnittstelle, die das Paket verarbeitet hat,
		    bspw. <devicename>dc0</devicename>.</para>
		</listitem>

		<listitem>
		  <para>Die Gruppe und die Nummer der angewandten Regel, bspw.
		    <literal>@0:17</literal>.</para>
		</listitem>

		<listitem>
		  <para>Die ausgef&uuml;hrte Aktion: p f&uuml;r
		    <literal>passed</literal> (zugelassen), b f&uuml;r blockiert,
		    S f&uuml;r <literal>short packet</literal> (unvollst&auml;ndiger
		    Header), n f&uuml;r <literal>no match</literal> (gar keine Regel
		    wurde ber&uuml;hrt) und L f&uuml;r Log-Regel.  Die Reihe, in der
		    die Flags angezeigt werden ist:  S, p, b, n, L.  Ein gro&szlig;
		    geschriebenes P oder B bedeutet, dass das Paket aufgrund einer
		    globalen Einstellung protokolliert wurde und nicht wegen einer
		    einzelnen Regel.</para>
		</listitem>

		<listitem>
		  <para>Die Adressen.  Diese bestehen aus drei Feldern:  Der
		    Quelladresse mit Port (getrennt durch ein Komma), dem Symbol
		    <quote>-&gt;</quote> und der Zieladresse. Also bspw.
		    <literal>209.53.15.22,80 -&gt; 198.64.221.18,1722</literal>.</para>
		</listitem>

		<listitem>
		  <para><literal>PR</literal> gefolgt vom Namen eines
		    Netzwerk-Protokolls oder dessen Nummer.  Bspw.
		    <literal>PR tcp</literal>.</para>
		</listitem>

		<listitem>
		  <para><literal>len</literal> gefolgt von der L&auml;nge des Headers
		    und der Gesamtl&auml;nge des Paketes, beispielsweise
		    <literal>len 20 40</literal>.</para>
		</listitem>
      </orderedlist>

      <para>Wenn es sich um ein <acronym>TCP</acronym>-Paket handelt, wird
        ein weiteres Feld, beginnend mit einem Querstrich und gefolgt von
        Buchstaben, die den gesetzten Flags entsprechen, angezeigt.  Lesen
        Sie bitte die Manpage &man.ipmon.8; f&uuml;r eine Liste der Buchstaben
        und deren Bedeutungen.</para>

      <para>Falls das Paket ein ICMP-Paket ist, werden zwei Felder am Ende
        hinzugef&uuml;gt - das erstere ist immer <quote>ICMP</quote>, das
        zweite enth&auml;lt die ICMP-Nachricht und den Nachrichtentyp,
        getrennt durch einen Schr&auml;gstrich.  <literal>ICMP 3/3</literal>
        steht beispielsweise f&uuml;r <quote>Port nicht
        erreichbar</quote>.</para>
    </sect2>

    <sect2 id="firewalls-ipf-rules-script">
      <title>Die Erstellung eines Regelsatzes mit Variablen</title>

      <para>Erfahrenere IPF Anwender erstellen sich eine Datei, die die
        Regeln enth&auml;lt und gestalten diese als ein Skript, in dem
        Variablen verwendet werden.  Der wichtigste Vorteil besteht darin,
        dass man lediglich den Wert der Variablen anpassen muss und diese,
        sobald das Skript gestartet wird, durch die entsprechenden Werte
        ersetzt	und die Regeln entsprechend formuliert werden.  In Skripten
        kann man so h&auml;ufig verwendete Werte einfach als Variable in
        mehreren Regeln zuweisen.  Am folgenden Beispiel soll das
        verdeutlicht werden.</para>

      <para>Die Syntax dieses Skriptes ist kompatibel mit den Shells
        &man.sh.1;, &man.csh.1; und &man.tcsh.1;.</para>

      <para>Variablen beginnen mit einem Dollar-Zeichen:
        <literal>&dollar;Variablenname</literal>.  Im Beispiel unten steht
        <literal>&dollar;oif</literal> f&uuml;r die Variable, in der der Name
        der	Schnittstelle abgelegt wird, &uuml;ber die der Verkehr nach
        au&szlig;en	erfolgt.</para>

      <para>In Variablenzuweisungen fehlt das beginnende &dollar;-Zeichen.
        Alleine der Name der Variable wird angegeben, gefolgt von einem
        Gleichheitszeichen, und dem Wert, der der Variablen zugewiesen werden
        soll.  Dieser mu&szlig; in doppelten Anf&uuml;hrungszeichen
        (<literal>"</literal>) stehen.  Also folgt eine Zuweisung dem Schema
        <literal>Variablenname = "Wert"</literal>.</para>

      <programlisting>############# Start of IPF rules script ########################

oif="dc0"            # Name der Internet-Schnittstelle
odns="192.0.2.11"    # IP des DNS-Servers unseres ISPs
myip="192.0.2.7"     # die statische IP, die uns der ISP zugeteilt hat
ks="keep state"
fks="flags S keep state"

# Sie haben die Wahl, aus diesem Skript eine eigene
# /etc/ipf.rules erstellen zu lassen oder es einfach
# direkt als Skript laufen zu lassen.
#
# Entfernen Sie dazu das eine Kommentarzeichen
# und kommentieren Sie die andere Zeile aus!
#
# 1) Diese Zeile verwenden Sie zur Erstellung von /etc/ipf.rules
#cat &gt; /etc/ipf.rules &lt;&lt; EOF
#
# 2) Diese Zeile, wenn Sie direkt mit dem Skript arbeiten wollen
/sbin/ipf -Fa -f - &lt;&lt; EOF

# Erlaubnis ausgehenden Verkehrs an den Nameserver des ISPs
pass out quick on &dollar;oif proto tcp from any to &dollar;odns port = 53 &dollar;fks
pass out quick on &dollar;oif proto udp from any to &dollar;odns port = 53 &dollar;ks

# Erlaubnis ausgehenden unsicheren www-Verkehrs
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 80 &dollar;fks

# Erlaubnis ausgehenden sicheren www-Verkehrs https via TLS SSL
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 443 &dollar;fks
EOF
################## End of IPF rules script ########################</programlisting>

      <para>Das ist schon alles.  Die Regeln selbst sind im Beispiel nicht
        so wichtig - achten Sie auf die Anwendung der Variablenzuweisung
        am Anfang und die Verwendung der Variablen im Skript.  Falls das
        obige Beispiel in einer Datei namens
        <filename>/etc/ipf.rules.script</filename> gespeichert wurde,
        k&ouml;nnen die	Regeln mit folgenden Kommando neu geladen
        werden:</para>

      <screen>&prompt.root; <userinput>sh /etc/ipf.rules.script</userinput></screen>

      <para>Es gibt ein Problem mit Regelsatz-Dateien, die Variablen
        verwenden: IPF kann mit Variablen nichts anfangen - und kann derartige
        Skripte	nicht direkt einlesen.</para>

      <para>Unser kleines Skript kann daher nur auf eine der beiden folgenden
        Weisen verwendet werden:</para>

      <itemizedlist>
		<listitem>
		  <para>Entfernen Sie das Kommentarzeichen der Zeile, die mit
		    <literal>cat</literal> beginnt.  Kommentieren Sie die Zeile aus,
		    die mit <literal>/sbin/ipf</literal> beginnt.  Schreiben Sie die
		    Zeile <literal>ipfilter_enable="YES"</literal> in die Datei
		    <filename>/etc/rc.conf</filename> und rufen Sie dann das Skript
		    auf, um <filename>/etc/ipf.rules</filename> zu erstellen oder
		    zu erneuern.</para>
		</listitem>

		<listitem>
		  <para>Deaktivieren Sie IPFILTER in den Systemstart-Skripten, indem
		    Sie die Zeile <literal>ipfilter_enable="NO"</literal> in die
		    Datei <filename>/etc/rc.conf</filename> eintragen (was auch der
		    Standard-Einstellung entspricht).</para>

		  <para>F&uuml;gen Sie ein Skript &auml;hnlich dem folgenden in Ihr
		    Verzeichnis <filename
		    class="directory">/usr/local/etc/rc.d/</filename>.  Es
		    sinnvoll, dem Skript einen offensichtlichen Namen zu geben, wie
		    etwa <filename>ipf.loadrules.sh</filename>.  Die Endung
		    <filename>.sh</filename> ist dabei verbindlich.</para>

	 	 <programlisting>#!/bin/sh
sh /etc/ipf.rules.script</programlisting>

		  <para>Die Zugriffsrechte f&uuml;r die Datei, die das Skript
		    enth&auml;lt, m&uuml;ssen f&uuml;r den Eigent&uuml;mer
		    <username>root</username> auf Lesen, Schreiben und Ausf&uuml;hren
		    gesetzt werden.</para>

		  <screen>&prompt.root; <userinput>chmod 700 /usr/local/etc/rc.d/ipf.loadrules.sh</userinput></screen>
		</listitem>
      </itemizedlist>

      <para>Wenn nun Ihr System startet, werden Ihre IPF-Regeln geladen.</para>
    </sect2>

    <sect2>
      <title>IPF Regels&auml;tze</title>

      <para> Ein Regelsatz ist eine Gruppe von IPF-Regeln, die anhand der
        Werte eines Netzwerkpaketes entscheiden, ob dieses Paket durchgelassen
        oder blockiert wird.  Der Austausch von Paketen erfolgt immer
        zweiseitig in Form einer sogenannten Session.  Der Regelsatz der
        Firewall verarbeitet sowohl die eingehenden Pakete aus dem
        &ouml;ffentlichen Internet als auch die Pakete, die vom System als
        Antwort auf die Ersteren gesendet werden.  Jeder Dienst, der via
        <acronym>TCP/IP</acronym> arbeitet, zum Beispiel
        <literal>telnet</literal>, <literal>www</literal> oder
        <literal>mail</literal>, ist vordefiniert durch sein Protokoll und
        seinen privilegierten Port,	an dem er auf Anfragen wartet und
        reagieren kann.  Pakete, die gezielt einen Dienst ansprechen sollen,
        werden von einem unprivilegierten Port des Senders an einen konkreten
        privilegierten Port des Zielsystems	geschickt.  Alle genannten
        Parameter (Ports, Adressen usw.) k&ouml;nnen als Auswahlkriterien zum
        erstellen von Regeln eingesetzt werden, die	Dienste erlauben oder
        blockieren.</para>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>rule processing order</secondary>
      </indexterm>

      <para>IPF wurde urspr&uuml;nglich mit einer Regel-Proze&szlig;-Logik
        geschrieben, die ausschlie&szlig;lich statusfreie Regeln zulie&szlig;
        und nach dem Prinzip <quote>die letzte Regel, die pa&szlig;t,
        entscheidet</quote> arbeitete.  Mit der Zeit erhielt IPF eine
        <option>quick</option> Option sowie <option>keep-state</option> Option
        f&uuml;r die Anwendung von zustandsorientierten Regeln, was die
        Regel-Proze&szlig;-Logik signifikant modernisierte.</para>

      <para>Die Anweisungen in diesem Kapitel basieren auf der Verwendung
        von Regeln, die diese beiden neuen Optionen verarbeiten.  Dies ist
        das Framework zur Entwicklung eines Firewall-Regelsatzes.</para>

      <warning>
		<para>Wenn Sie mit Firewall arbeiten, seien Sie
		  <emphasis>sehr vorsichtig</emphasis>.  Durch wenige Einstellungen
		  k&ouml;nnen Sie sich aus Ihrem System
		  <emphasis>aussperren</emphasis>.  Wenn Sie auf der sicheren Seite
		  sein wollen, f&uuml;hren Sie die Firewall-Konfiguration direkt am
		  entsprechenden Ger&auml;t aus und nicht &uuml;ber eine
		  Netzwerkverbindung wie bspw. <application>ssh</application>.</para>
     </warning>
    </sect2>

    <sect2>
      <title>IPF Regel-Syntax</title>

      <indexterm>
		<primary>IPFILTER</primary>

		<secondary>rule syntax</secondary>
      </indexterm>

      <para>Die Syntax zur Erstellung der Regeln, die hier vorgestellt wird,
        ist dahingehend vereinfacht worden, dass sie ausschliesslich auf
        den modernen Regelkontext, mit statusbehafteten Regeln und einer
        <quote>die erste Regel, die pa&szlig;t, gewinnt</quote>-Logik,
        zur&uuml;ckgreift.  Um alles &uuml;ber die veraltete Syntax zu
        erfahren, lesen Sie bitte die Man-Page von &man.ipf.8;.</para>

      <para>Ein <literal>#</literal>-Zeichen markiert den Beginn eines
        Kommentars.  Es darf nach nach einer Regel stehen oder als erstes
        Zeichen einer Zeile.  Leere Zeilen werden von der
        Regel-Proze&szlig;-Logik ignoriert.</para>

      <para>Regeln enthalten Schl&uuml;sselw&ouml;rter.  Diese
        Schl&uuml;sselw&ouml;rter m&uuml;ssen in einer bestimmten Reihenfolge
        von links nach rechts in einer Zeile erscheinen.  Als solche
        identifizierte Schl&uuml;sselw&ouml;rter werden fett wiedergegeben.
        Einige Schl&uuml;sselw&ouml;rter haben Unteroptionen, die wiederum
        selbst Schl&uuml;sselw&ouml;rter sein und ebenfalls weiter
        Unteroptionen einschlie&szlig;en k&ouml;nnen.</para>

      <!-- This section is probably wrong. See the OpenBSD flag -->
      <!-- What is the "OpenBSD flag"?  Reference please -->

      <para><replaceable>ACTION IN-OUT OPTIONS SELECTION STATEFUL PROTO
        SRC_ADDR,DST_ADDR OBJECT PORT_NUM TCP_FLAG
        STATEFUL</replaceable></para>

      <para><replaceable>ACTION</replaceable> = block | pass</para>

      <para><replaceable>IN-OUT</replaceable> = in | out</para>

      <para><replaceable>OPTIONS</replaceable> = log | quick | on
        interface-name</para>

      <para><replaceable>SELECTION</replaceable> = proto value | 
        source/destination IP | port = number | flags flag-value</para>

      <para><replaceable>PROTO</replaceable> = tcp/udp | udp | tcp |
        icmp</para>

      <para><replaceable>SRC_ADD,DST_ADDR</replaceable> = all | from
        object to object</para>

      <para><replaceable>OBJECT</replaceable> = IP address | any</para>

      <para><replaceable>PORT_NUM</replaceable> = port number</para>

      <para><replaceable>TCP_FLAG</replaceable> = S</para>

      <para><replaceable>STATEFUL</replaceable> = keep state</para>

      <sect3>
		<title>ACTION</title>

		<para>Die <quote>ACTION</quote> bestimmt, was mit dem Paket passieren
		  soll, wenn der Rest der Regel zutrifft.  Dieser Teil mu&szlig;
		  f&uuml;r jede Regel angegeben werden.</para>

		<para>Das Schl&uuml;sselwort <literal>block</literal> gibt an, dass
		  das Paket verfallen soll, wenn die Auswahlparameter zutreffen.</para>

		<para>Das Schl&uuml;sselwort <literal>pass</literal> gibt an, dass
		  das Paket durch die Firewall durchgelassen werden soll, wenn die
		  Auswahlparameter zutreffen.</para>
      </sect3>

      <sect3>
		<title>IN-OUT</title>

		<para>Ebenfalls verbindlich ist die Angabe, welchen Teil der
		  Verbindung, Ein- oder Ausgang, die Regel beeinflussen soll.  Das
		  n&auml;chste Schl&uuml;sselwort mu&szlig; daher entweder
		  <literal>in</literal>, f&uuml;r eingehend, oder
		  <literal>out</literal>, f&uuml;r ausgehend, lauten - oder die Regel
		  wird aufgrund eines Syntaxfehlers nicht umgesetzt.</para>

		<para><literal>in</literal> bedeutet, dass diese Regel auf eingehende
		  Pakete angewendet wird, die gerade an der dem &ouml;ffentlichen
		  Internet zugewandten Schnittstelle empfangen wurden.</para>

		<para><literal>out</literal> bedeutet, das diese Regel auf ausgehende
		  Pakete angewendet wird, also Pakete die gerade gesendet werden und
		  deren Zieladresse im &ouml;ffentlichen Internet liegt.</para>
      </sect3>

      <sect3>
		<title>OPTIONS</title>

		<note>
		  <para>Die Optionen m&uuml;ssen in der hier aufgef&uuml;hrten
		    Reihenfolge verwendet werden.</para>
		</note>

        <para><literal>log</literal> bestimmt, dass die Kopfdaten des Paketes
          an die Systemschnittstelle &man.ipl.4; geschrieben werden sollen.
          Genaueres dazu weiter unten im Abschnitt LOGGING.</para>

		<para><literal>quick</literal> bestimmt, dass,
		  <emphasis>wenn</emphasis> die Auswahlkriterien der Regel auf das
		  Paket zutreffen, keine weiteren Regeln ausgewertet werden.  So
		  vermeidet man das Abarbeiten des gesamten Regelsatzes.  Diese Option
		  ist eine verbindliche Vorraussetzung der modernen
		  Regel-Proze&szlig;-Logik.</para>

		<para><literal>on</literal> bestimmt den Namen der Schnittstelle,
		  der als Auswahlkriterium hinzugef&uuml;gt werden soll.  Die Namen
		  aller verf&uuml;gbaren Schnittstellen werden durch den Befehl
		  &man.ifconfig.8; angezeigt.  wenn man diese Option verwendet,
		  pa&szlig;t die Regeln nur auf Pakete, die durch diese Schnittstelle
		  empfangen (<literal>in</literal>) oder gesendet
		  (<literal>out</literal>) wurden.  F&uuml;r die modernisierte
		  Regel-Proze&szlig;-Logik ist die Verwendung dieser Option
		  verbindlich.</para>

		<para>Wenn ein Paket protokolliert wird, werden die Kopfdaten in
		  die Pseudo-Schnittstelle &man.ipl.4; geschrieben.  Folgende Parameter
		  k&ouml;nnen zus&auml;tzlich &uuml;bergeben werden, m&uuml;ssen dazu
		  aber direkt nach dem Schl&uuml;sselwort <literal>log</literal> und in
		  gleicher Reihenfolge stehen:</para>

		<para><literal>body</literal> bestimmt, dass die ersten 128 Bytes des
		  Paketinhaltes zus&auml;tzlich zu den Kopfdaten protokolliert
		  werden.</para>

		<para><literal>first</literal> trifft nur zu, wenn das
		  Schl&uuml;sselwort <literal>log</literal> zusammen mit
		  <literal>keep-state</literal> verwendet wird.  Es bestimmt, dass nur
		  das ausl&ouml;sende Paket protokolliert wird und nicht jedes weitere
		   Paket, dass von der gespeicherten Status-Regel betroffen ist.</para>
      </sect3>

      <sect3>
		<title>SELECTION</title>

		<para>Die Schl&uuml;sselw&ouml;rter, die in diesem Abschnitt
		  vorgestellt werden, dienen zur Beschreibung von Attributen, anhand
		  derer gepr&uuml;ft und entschieden wird, ob eine Regel zutrifft
		  oder nicht.  Es gibt ein Schl&uuml;sselwort, und das hat mehrere
		  Optionen, von denen eine ausgew&auml;hlt werden mu&szlig;.  Die
		  folgenden allgemeinen Attribute k&ouml;nnen beliebig zum Erstellen
		  einer Regel verwendet werden, allerdings nur in der vorgestellten
		  Reihenfolge:</para>
      </sect3>

      <sect3>
		<title>PROTO</title>

		<para><literal>proto</literal> ist das Schl&uuml;sselwort f&uuml;r
		  das im Paket angewendete Protokoll.  Als Option ein Protokoll aus
		  Auswahlkriterium &uuml;bergeben.  Diese Option ist verbindlich, wenn
		  man die moderne Regel-Proze&szlig;-Logik verwendet.</para>

		<para><literal>tcp/udp | udp | tcp | icmp</literal> oder irgendein
		  Protokollname, der in der Datei <filename>/etc/protocols</filename>
		  zu finden ist, kann &uuml;bergeben werden.  Au&szlig;erdem kann das
		  Schl&uuml;sselwort <literal>tcp/udp</literal> verwendet werden, wenn
		  sowohl <acronym>TCP</acronym> als auch <acronym>UDP</acronym> von der
		  Regel betroffen sein sollen.  Dieses Schl&uuml;sselwort wurde
		  eingef&uuml;hrt, um Duplikate sonst identischer Regeln zu
		  vermeiden.</para>
      </sect3>

      <sect3>
		<title>SRC_ADDR/DST_ADDR</title>

		<para>Das Schl&uuml;sselwort <literal>all</literal> ist ein Synonym
		  f&uuml;r <quote>from any to any</quote> ohne weitere
		  Auswahlkriterien.</para>

		<para><literal>from src to dst</literal>: Die Schl&uuml;sselw&ouml;rter
		  <literal>from</literal> und <literal>to</literal> dienen zur Angabe
		  von Quelle und Ziel in Form von IP-Adressen oder -Bereichen.
		  Innerhalb einer Regel mu&szlig; immer beides angegeben werden.
		  Statt einer Adresse kann auch das Schl&uuml;sselwort
		  <literal>any</literal> &uuml;bergeben werden, das f&uuml;r jede
		  beliebige IP-Adresse steht.  Zum Beispiel:
		  <literal>from any to any</literal> oder
		  <literal>from 0.0.0.0/0 to any</literal> oder
		  <literal>from any to 0.0.0.0/0</literal> oder
		  <literal>from 0.0.0.0 to any</literal> oder
		  <literal>from any to 0.0.0.0</literal> bedeuten alle das
		  Gleiche.</para>

		<para>IP-Bereiche k&ouml;nnen nur in der CIDR-Notation angegeben
		  werden.  Der Port <filename role="package">net-mgmt/ipcalc</filename>
		  hilft Ihnen bei der Berechnung der richtigen Angaben.
		  Weiterf&uuml;hrende Informationen zu CIDR finden Sie auf der Webseite
		  von <ulink
		  url="http://www.rfc-editor.org/rfc/rfc1519.txt"><literal>ipcalc</literal></ulink>.</para>
      </sect3>

      <sect3>
		<title>PORT</title>

		<para>Wenn ein Port als Auswahlkriterium &uuml;bergeben wurde, bei
		  Quelle und/oder Ziel, wird er nur bei <acronym>TCP</acronym> und
		  <acronym>UDP</acronym> Paketen verwendet.  Angegeben werden kann
		  entweder die Portnummer oder der Dienstname aus
		  <filename>/etc/services</filename>.  Die Verwendung der
		  Portoption mit dem <literal>to</literal>-Objekt ist verbindlich
		  f&uuml;r die Verwendung der modernisierten Regel-Proze&szlig;-Logik.
		  Ein Beispiel f&uuml;r die Filterung Paketen von allen Quell-IPs mit
		  beliebiger Portnummer auf beliebige Ziel-IPs mit der Portnummer 80
		  (dem <literal>www</literal>-Port):
		  <literal>from any to any port = 80</literal>.</para>

	<!-- XXX: Rewritten, but probably needs more changes -->

		<para>Einfache Portvergleiche k&ouml;nnen auf verschiedenen Wegen 
		  erfolgen.  Mehrere Vergleichsoperatoren stehen daf&uuml;r zur
		  Verf&uuml;gung.  Genauso k&ouml;nnen Bereiche angegeben
		  werden.</para>

		<para>port "=" | "!=" | "&lt;" | "&gt;" | "&lt;=" | "&gt;=" | "eq"
		  | "ne" | "lt" | "gt" | "le" | "ge".</para>

		<para>Um einen Bereich anzugeben: port "&lt;&gt;" | "&gt;&lt;"</para>

		<warning>
          <para>Genau wie die Trefferspezifikation f&uuml;r Quelle und Ziel
            sind auch die beiden folgenden Parameter obligatorisch bei der
            Verwendung der modernen Regel-Proze&szlig;-Logik.</para>
		</warning>
      </sect3>

      <sect3>
		<title><acronym>TCP</acronym>_FLAG</title>

		<para>Flags spielen nur beim Filtern von <acronym>TCP</acronym> eine
		  Rolle.  Die Buchstaben entsprechen jeweils einem m&ouml;glichen
		  Flag, dass in den Kopfdaten der <acronym>TCP</acronym>-Pakete
		  geprueft werden soll.</para>

		<para>Die moderne Regel-Proze&szlig;-Logik verwendet den Parameter
		  <literal>flags S</literal> um eine Anfrage zum Start einer
		  <acronym>TCP</acronym>-Session zu identifizieren.</para>
      </sect3>

      <sect3>
		<title>STATEFUL</title>

		<para><literal>keep state</literal> zeigt bei einer Passage-Regel an,
		  dass f&uuml;r alle Pakete, die die Selektion erfolgreich durchlaufen,
		  <literal>Stateful Filtering</literal> eingerichtet werden
		  soll.</para>

		<note>
		  <para>Diese Option ist obligatorisch f&uuml;r die Verwendung der
		    modernen Proze&szlig;-Regel-Logik.</para>
		</note>
      </sect3>
    </sect2>
<!-- xxxxxxxxxxx Benjamin bis hier xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  //-->
    <sect2>
      <title>Stateful Filtering</title>

      <indexterm>
	<primary>IPFILTER</primary>

	<secondary>stateful filtering</secondary>
      </indexterm>

      <!-- XXX: duplicated -->

      <para>Stateful filtering treats traffic as a bi-directional
	exchange of packets comprising a session conversation.  When
	activated, keep-state dynamically generates internal rules for
	each anticipated packet being exchanged during the
	bi-directional session conversation.  It has sufficient matching
	capabilities to determine if the session conversation between the
	originating sender and the destination are following the valid
	procedure of bi-directional packet exchange.  Any packets that
	do not properly fit the session conversation template are
	automatically rejected as impostors.</para>

      <para>Keep state will also allow <acronym>ICMP</acronym> packets related to a
	<acronym>TCP</acronym> or <acronym>UDP</acronym> session through.  So if you get
	<acronym>ICMP</acronym> type 3 code 4 in response to some web surfing allowed out
	by a keep state rule, they will be automatically allowed in.
	Any packet that IPF can be certain is part of an active
	session, even if it is a different protocol, will be let
	in.</para>

      <para>What happens is:</para>

      <para>Packets destined to go out through the interface connected to the
	public Internet are first checked against the dynamic state
	table.  If the packet matches the next expected packet
	comprising an active session conversation, then it exits the
	firewall and the state of the session conversation flow is
	updated in the dynamic state table.  Packets that do not belong to
	an already active session, are simply checked against the outbound
	ruleset.</para>

      <para>Packets coming in from the interface connected to the public
	Internet are first checked against the dynamic state table.  If
	the packet matches the next expected packet comprising an
	active session conversation, then it exits the firewall and
	the state of the session conversation flow is updated in the
	dynamic state table.  Packets that do not belong to an already active
	session, are simply checked against the inbound ruleset.</para>

      <para>When the conversation completes it is removed from the
	dynamic state table.</para>

      <para>Stateful filtering allows you to focus on blocking/passing
	new sessions.  If the new session is passed, all its subsequent
	packets will be allowed through automatically and any impostors
	automatically rejected.  If a new session is blocked, none of
	its subsequent packets will be allowed through.  Stateful
	filtering has technically advanced matching abilities
	capable of defending against the flood of different attack
	methods currently employed by attackers.</para>
    </sect2>

    <sect2>
      <!-- XXX: This section needs a rewrite -->

      <title>Inclusive Ruleset Example</title>

      <para>The following ruleset is an example of how to code a very
	secure inclusive type of firewall.  An inclusive firewall only
	allows services matching <literal>pass</literal> rules through, and blocks all
	others by default.  Firewalls intended to protect other machines,
	also called <quote>network firewalls</quote>, should have at least
	two interfaces, which are generally configured to trust one side
	(the <acronym>LAN</acronym>) and not the other (the public Internet).  Alternatively,
	a firewall might be configured to protect only the system it is
	running on&mdash;this is called a
	<quote>host based firewall</quote>, and is particularly appropriate
	for servers on an untrusted network.</para>

      <para>All &unix; flavored systems including &os; are designed to
	use interface <devicename>lo0</devicename> and IP address
	<hostid role="ipaddr">127.0.0.1</hostid> for internal
	communication within the operating system.  The firewall rules
	must contain rules to allow free unmolested movement of these
	special internally used packets.</para>

      <para>The interface which faces the public Internet is the one
	to place the rules that authorize and control access of the outbound
	and inbound connections.  This can be your user PPP
	<devicename>tun0</devicename> interface or your NIC that is
	connected to your DSL or cable modem.</para>

      <para>In cases where one or more NICs are cabled to private network
	segments, those interfaces may require rules to allow packets
	originating from those LAN interfaces transit to each other and/or
	to the outside (Internet).</para>

      <para>The rules should be organized into three major
	sections: first trusted interfaces, then the public
	interface outbound, and last the public untrusted interface inbound.</para>

      <para>The rules in each of the public interface sections should
	have the most frequently matched rules placed before less
	commonly matched rules, with the last rule in the section
	blocking and logging all packets on that interface and
	direction.</para>

      <para>The Outbound section in the following ruleset only
	contains <literal>pass</literal> rules which contain selection values that
	uniquely identify the service that is authorized for public
	Internet access.  All the rules have the <literal>quick</literal>, <literal>on</literal>,
	<literal>proto</literal>, <literal>port</literal>, and <literal>keep state</literal> options set.  The <literal>proto
	tcp</literal> rules have the <literal>flag</literal> option included to identify the
	session start request as the triggering packet to activate the
	stateful facility.</para>

      <para>The Inbound section has all the blocking of undesirable
	packets first, for two different reasons.  The first is that
	malicious packets may be partial matches for legitimate traffic.
	These packets have to be discarded rather than allowed in, based on
	their partial matches against <literal>allow</literal> rules.
	The second reason is that known and uninteresting rejects may be
	blocked silently, rather than being caught and logged by the last
	rules in the section.  The final rule in each section, blocks and
	logs all packets and can be used to create the legal evidence needed
	to prosecute the people who are attacking your system.</para>

      <para>Another thing that should be taken care of, is to ensure there is no
	response returned for any of the undesirable traffic.  Invalid
	packets should just get dropped and vanish.  This way the attacker
	has no knowledge if his packets have reached your system.  The
	less the attackers can learn about your system, the more
	time they must invest before actually doing something bad.
	Rules that include a <literal>log first</literal> option, will only
	log the event the first time they are triggered.  This option is
	included in the sample <literal>nmap OS fingerprint</literal> rule.
	The <filename role="package">security/nmap</filename> utility is
	commonly used by attackers who attempt to identify the operating
	system of your server.</para>

      <para>Any time there are logged messages on a rule with
	the <literal>log first</literal> option, an <command>ipfstat -hio</command>
	command should be executed to evaluate how many times the rule has
	actually matched.  Large number of matches usually indicate that the
	system is being flooded (i.e.: under attack).</para>

      <para>The <filename>/etc/services</filename> file may be used to
	lookup unknown port numbers.  Alternatively,
	visit <ulink
	  url="http://www.securitystats.com/tools/portsearch.php"></ulink>
	and do a port number lookup to find the purpose of a particular
	port number.</para>

      <para>Check out this link for port numbers used by Trojans <ulink
	  url="http://www.simovits.com/trojans/trojans.html"></ulink>.</para>

      <para>The following ruleset creates a complete and very secure
	<literal>inclusive</literal> type of firewall ruleset that has been
	tested on production systems.  It can be easily modified for your
	own system.  Just comment out any <literal>pass</literal> rules for
	services that should not be authorized.</para>

      <para>To avoid logging unwanted messages,
	just add a <literal>block</literal> rule in the inbound section.</para>

      <para>The <devicename>dc0</devicename> interface name has to be changed
	in every rule to the real interface name of the NIC
	card that connects your system to the public Internet.  For
	user PPP it would be <devicename>tun0</devicename>.</para>

      <para>Add the following statements to
	<filename>/etc/ipf.rules</filename>:</para>

      <programlisting>#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN
#################################################################

#pass out quick on xl0 all
#pass in quick on xl0 all

#################################################################
# No restrictions on Loopback Interface
#################################################################
pass in quick on lo0 all
pass out quick on lo0 all

#################################################################
# Interface facing Public Internet (Outbound Section)
# Match session start requests originating from behind the
# firewall on the private network
# or from this gateway server destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# xxx must be the IP address of your ISP's DNS.
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
pass out quick on dc0 proto tcp from any to xxx port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow out access to my ISP's DHCP server for cable or DSL networks.
# This rule is not needed for 'user ppp' type connection to the
# public Internet, so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state


# Allow out non-secure standard www function
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow out secure www function https over TLS SSL
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow out send &amp; get email function
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow out Time
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow out nntp news
pass out quick on dc0 proto tcp from any to any port = 119 flags S keep state

# Allow out gateway &amp; LAN users' non-secure FTP ( both passive &amp; active modes)
# This function uses the IP<acronym>NAT</acronym> built in FTP proxy function coded in
# the nat rules file to make this single rule function correctly.
# If you want to use the pkg_add command to install application packages
# on your gateway system you need this rule.
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow out ssh/sftp/scp (telnet/rlogin/FTP replacements)
# This function is using SSH (secure shell)
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow out insecure Telnet
pass out quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow out FreeBSD CVSup
pass out quick on dc0 proto tcp from any to any port = 5999 flags S keep state

# Allow out ping to public Internet
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Allow out whois from LAN to public Internet
pass out quick on dc0 proto tcp from any to any port = 43 flags S keep state

# Block and log only the first occurrence of everything
# else that's trying to get out.
# This rule implements the default block
block out log first quick on dc0 all

#################################################################
# Interface facing Public Internet (Inbound Section)
# Match packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

##### Block a bunch of different nasty things. ############
# That I do not want to see in the log

# Block frags
block in quick on dc0 all with frags

# Block short tcp packets
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block nmap OS fingerprint attempts
# Log first occurrence of these so I can get their IP address
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings
block in quick on dc0 proto icmp all icmp-type 8

# Block ident
block in quick on dc0 proto tcp from any to any port = 113

# Block all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP's DHCP server as it's the only
# authorized source to send this packet type. Only necessary for
# cable or DSL configurations. This rule is not needed for
# 'user ppp' type connection to the public Internet.
# This is the same IP address you captured and
# used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow in standard www function because I have apache server
pass in quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID/PW passed over public Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
#pass in quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow in secure FTP, Telnet, and SCP from public Internet
# This function is using SSH (secure shell)
pass in quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Block and log only first occurrence of all remaining traffic
# coming into the firewall. The logging of only the first
# occurrence avoids filling up disk with Denial of Service logs.
# This rule implements the default block.
block in log first quick on dc0 all
################### End of rules file #####################################</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym></title>

      <indexterm><primary>NAT</primary></indexterm>

      <indexterm>
	<primary>IP masquerading</primary>

	<see>NAT</see>
      </indexterm>

      <indexterm>
	<primary>network address translation</primary>

	<see>NAT</see>
      </indexterm>

      <para><acronym>NAT</acronym> stands for <emphasis>Network Address
	  Translation</emphasis>.  To those familiar with &linux;, this concept is
	called IP Masquerading; <acronym>NAT</acronym> and IP
	Masquerading are the same thing.  One of the many things the
	IPF <acronym>NAT</acronym> function enables is the ability to
	have a private Local Area Network (LAN) behind the firewall
	sharing a single ISP assigned IP address on the public
	Internet.</para>

      <para>You may ask why would someone want to do this.  ISPs
	normally assign a dynamic IP address to their non-commercial
	users.  Dynamic means that the IP address can be different each
	time you dial in and log on to your ISP, or for cable and DSL
	modem users, when the modem is power cycled.  This dynamic IP
	address is used to identify your system to the public Internet.</para>

      <para>Now lets say you have five PCs at home and each one needs
	Internet access.  You would have to pay your ISP for an
	individual Internet account for each PC and have five phone
	lines.</para>

      <para>With <acronym>NAT</acronym> only a single account is needed
	with your ISP.  The other four PCs may then be cabled to a switch and
	the switch to the NIC in your &os; system which is going to
	service your LAN as a gateway. <acronym>NAT</acronym> will
	automatically translate the private LAN IP address for each
	separate PC on the LAN to the single public IP address as it
	exits the firewall bound for the public Internet.  It also does
	the reverse translation for returning packets.</para>

      <para>There is a special range of IP addresses reserved for
	<acronym>NAT</acronym>ed private LANs.  According to
	RFC 1918, the following IP ranges may be used for private nets
	which will never be routed directly to the public
	Internet:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">

	  <colspec colwidth="1*">

	  <colspec colwidth="1*">

	  <tbody>
	    <row>
	      <entry>Start IP <hostid role="ipaddr">10.0.0.0</hostid></entry>

	      <entry>-</entry>

	      <entry>Ending IP <hostid role="ipaddr">10.255.255.255</hostid></entry>
	    </row>

	    <row>
	      <entry>Start IP <hostid role="ipaddr">172.16.0.0</hostid></entry>

	      <entry>-</entry>

	      <entry>Ending IP <hostid role="ipaddr">172.31.255.255</hostid></entry>
	    </row>

	    <row>
	      <entry>Start IP <hostid role="ipaddr">192.168.0.0</hostid></entry>

	      <entry>-</entry>

	      <entry>Ending IP <hostid role="ipaddr">192.168.255.255</hostid></entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>IP<acronym>NAT</acronym></title>

      <indexterm>
	<primary>NAT</primary>

	<secondary>and IPFILTER</secondary>
      </indexterm>

      <indexterm><primary><command>ipnat</command></primary></indexterm>

      <para><acronym>NAT</acronym> rules are loaded by using the
	<command>ipnat</command> command.  Typically the
	<acronym>NAT</acronym> rules are stored in
	<filename>/etc/ipnat.rules</filename>.  See &man.ipnat.1; for
	details.</para>

      <para>When changing the <acronym>NAT</acronym> rules after
	<acronym>NAT</acronym> has been started, make your changes to
	the file containing the NAT rules, then run the <command>ipnat</command> command with
	the <option>-CF</option> flags to delete the internal in use
	<acronym>NAT</acronym> rules and flush the contents of the
	translation table of all active entries.</para>

      <para>To reload the <acronym>NAT</acronym> rules issue a command
	like this:</para>

      <screen>&prompt.root; <userinput>ipnat -CF -f /etc/ipnat.rules</userinput></screen>

      <para>To display some statistics about your
	<acronym>NAT</acronym>, use this command:</para>

      <screen>&prompt.root; <userinput>ipnat -s</userinput></screen>

      <para>To list the <acronym>NAT</acronym> table's current
	mappings, use this command:</para>

      <screen>&prompt.root; <userinput>ipnat -l</userinput></screen>

      <para>To turn verbose mode on, and display information relating
	to rule processing and active rules/table entries:</para>

      <screen>&prompt.root; <userinput>ipnat -v</userinput></screen>
    </sect2>

    <sect2>
      <title>IP<acronym>NAT</acronym> Rules</title>

      <para><acronym>NAT</acronym> rules are very flexible and can
	accomplish many different things to fit the needs of commercial
	and home users.</para>

      <para>The rule syntax presented here has been simplified to what
	is most commonly used in a non-commercial environment.  For a
	complete rule syntax description see the &man.ipnat.5; manual
	page.</para>

      <para>The syntax for a <acronym>NAT</acronym> rule looks
	something like this:</para>

      <programlisting>map <replaceable>IF</replaceable> <replaceable>LAN_IP_RANGE</replaceable> -&gt; <replaceable>PUBLIC_ADDRESS</replaceable></programlisting>

      <para>The keyword <literal>map</literal> starts the rule.</para>

      <para>Replace <replaceable>IF</replaceable> with the external
	interface.</para>

      <para>The <replaceable>LAN_IP_RANGE</replaceable> is what your
	internal clients use for IP Addressing, usually this is
	something like <hostid
	  role="ipaddr">192.168.1.0/24</hostid>.</para>

      <para>The <replaceable>PUBLIC_ADDRESS</replaceable> can either
	be the external IP address or the special keyword
	<literal>0/32</literal>, which means to use the IP address
	assigned to <replaceable>IF</replaceable>.</para>
    </sect2>

    <sect2>
      <title>How <acronym>NAT</acronym> works</title>

      <para>A packet arrives at the firewall from the LAN with a public
	destination.  It passes through the outbound filter rules,
	<acronym>NAT</acronym> gets its turn at the packet and applies
	its rules top down, first matching rule wins.
	<acronym>NAT</acronym> tests each of its rules against the
	packet's interface name and source IP address.  When a packet's
	interface name matches a <acronym>NAT</acronym> rule then the
	source IP address (i.e.: private LAN IP address) of the packet
	is checked to see if it falls within the IP address range
	specified to the left of the arrow symbol on the
	<acronym>NAT</acronym> rule.  On a match the packet has its
	source IP address rewritten with the public IP address
	obtained by the <literal>0/32</literal> keyword.
	<acronym>NAT</acronym> posts an entry in its internal
	<acronym>NAT</acronym> table so when the packet returns from
	the public Internet it can be mapped back to its original
	private IP address and then passed to the filter rules for
	processing.</para>
    </sect2>

    <sect2>
      <title>Enabling IP<acronym>NAT</acronym></title>

      <para>To enable IP<acronym>NAT</acronym> add these statements to
	<filename>/etc/rc.conf</filename>.</para>

      <para>To enable your machine to route traffic between
	interfaces:</para>

      <programlisting>gateway_enable="YES"</programlisting>

      <para>To start IP<acronym>NAT</acronym> automatically each
	time:</para>

      <programlisting>ipnat_enable="YES"</programlisting>

      <para>To specify where to load the IP<acronym>NAT</acronym> rules
	from:</para>

      <programlisting>ipnat_rules="/etc/ipnat.rules"</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym> for a very large LAN</title>

      <para>For networks that have large numbers of PC's on the LAN or
	networks with more than a single LAN, the process of funneling
	all those private IP addresses into a single public IP address
	becomes a resource problem that may cause problems with the
	same port numbers being used many times across many
	<acronym>NAT</acronym>ed LAN PC's, causing collisions.  There
	are two ways to relieve this resource problem.</para>

      <sect3>
	<title>Assigning Ports to Use</title>

	<!-- What does it mean ? Is there something missing ?-->
	<!-- XXXBLAH <- Apparently you can't start a sect
	     with a <programlisting> tag ?-->

	<para>A normal NAT rule would look like:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32</programlisting>

	<para>In the above rule the packet's source port is unchanged
	  as the packet passes through IP<acronym>NAT</acronym>.  By
	  adding the <literal>portmap</literal> keyword,
	  IP<acronym>NAT</acronym> can be directed to only use source ports in the specified range.
	  For example the following rule will tell
	  IP<acronym>NAT</acronym> to modify the source port to be
	  within the range shown:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</programlisting>

	<para>Additionally we can make things even easier by using the
	  <literal>auto</literal> keyword to tell
	  IP<acronym>NAT</acronym> to determine by itself which ports
	  are available to use:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</programlisting>
      </sect3>

      <sect3>
	<title>Using a Pool of Public Addresses</title>

	<para>In very large LANs there comes a point where there are just too
	  many LAN addresses to fit into a single public address.  If a block
	  of public IP addresses is available, these addresses can be used as
	  a <quote>pool</quote>, and IP<acronym>NAT</acronym> may pick one of
	  the public IP addresses as packet-addresses are mapped on their way
	  out.</para>

	<para>For example, instead of mapping all packets through a single
	  public IP address, as in:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.1</programlisting>

	<para>A range of public IP addresses can be specified either with a
	  netmask:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0</programlisting>

	<para>or using CIDR notation:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Port Redirection</title>

      <para>A very common practice is to have a web server, email
	server, database server and DNS server each segregated to a
	different PC on the LAN.  In this case the traffic from these
	servers still have to be <acronym>NAT</acronym>ed, but there
	has to be some way to direct the inbound traffic to the
	correct LAN PCs.  IP<acronym>NAT</acronym> has the redirection
	facilities of <acronym>NAT</acronym> to solve this problem.
	For example, assuming a web server operating on LAN address <hostid
	  role="ipaddr">10.0.10.25</hostid> and using a single public IP
	address of <hostid role="ipaddr">20.20.20.5</hostid> the rule would
	be coded as follows:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>or:</para>

	<programlisting>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>or for a LAN DNS Server on LAN address of <hostid
	    role="ipaddr">10.0.10.33</hostid> that needs to receive
	  public DNS requests:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 53 -&gt; 10.0.10.33 port 53 udp</programlisting>
    </sect2>

    <sect2>
      <title>FTP and <acronym>NAT</acronym></title>

      <para>FTP is a dinosaur left over from the time before the
	Internet as it is known today, when research universities were
	leased lined together and FTP was used to share files among
	research Scientists.  This was a time when data security was
	not a consideration.  Over the years the FTP protocol became
	buried into the backbone of the emerging Internet and its
	username and password being sent in clear text was never
	changed to address new security concerns.  FTP has two flavors,
	it can run in active mode or passive mode.  The difference is
	in how the data channel is acquired.  Passive mode is more
	secure as the data channel is acquired by the ordinal ftp
	session requester.  For a real good explanation of FTP and the
	different modes see <ulink
	  url="http://www.slacksite.com/other/ftp.html"></ulink>.</para>

      <sect3>
	<title>IP<acronym>NAT</acronym> Rules</title>

	<para>IP<acronym>NAT</acronym> has a special built in FTP proxy
	  option which can be specified on the <acronym>NAT</acronym>
	  map rule.  It can monitor all outbound packet traffic for FTP
	  active or passive start session requests and dynamically
	  create temporary filter rules containing only the port number
	  really in use for the data channel.  This eliminates the
	  security risk FTP normally exposes the firewall to from
	  having large ranges of high order port numbers open.</para>

	<para>This rule will handle all the traffic for the internal
	  LAN:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>This rule handles the FTP traffic from the
	  gateway:</para>

	<programlisting>map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>This rule handles all non-FTP traffic from the internal
	  LAN:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32</programlisting>

	<para>The FTP map rule goes before our regular map rule.  All
	  packets are tested against the first rule from the top.
	  Matches on interface name, then private LAN source IP
	  address, and then is it a FTP packet.  If all that matches
	  then the special FTP proxy creates temp filter rules to let
	  the FTP session packets pass in and out, in addition to also
	  <acronym>NAT</acronym>ing the FTP packets.  All LAN packets
	  that are not FTP do not match the first rule and fall
	  through to the third rule and are tested, matching on
	  interface and source IP, then are
	  <acronym>NAT</acronym>ed.</para>
      </sect3>

      <sect3>
	<title>IP<acronym>NAT</acronym> FTP Filter Rules</title>

	<para>Only one filter rule is needed for FTP if the
	  <acronym>NAT</acronym> FTP proxy is used.</para>

	<para>Without the FTP Proxy, the following three rules will be
	  needed:</para>

	<programlisting># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="firewalls-ipfw">
    <title>IPFW</title>

    <para>Dieses Kapitel ist noch nicht &uuml;bersetzt.
      Lesen Sie bitte <ulink
      url="&url.books.handbook.en;/firewalls-ipfw.html">
      das Original in englischer Sprache</ulink>.  Wenn Sie helfen
      wollen, dieses Kapitel zu &uuml;bersetzen, senden Sie bitte
      eine E-Mail an die Mailingliste &a.de.translators;.</para>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->


