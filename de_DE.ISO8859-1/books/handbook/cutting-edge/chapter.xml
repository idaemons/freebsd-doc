<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r48637
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="updating-upgrading">

  <info>
    <title>&os; aktualisieren</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Jim</firstname>
	  <surname>Mock</surname>
	</personname>
	<contrib>Umstrukturiert und aktualisiert von </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Jordan</firstname>
	  <surname>Hubbard</surname>
	</personname>
	<contrib>Im Original von </contrib>
      </author>

      <author>
	<personname>
	  <firstname>Poul-Henning</firstname>
	  <surname>Kamp</surname>
	</personname>
      </author>

      <author>
	<personname>
	  <firstname>John</firstname>
	  <surname>Polstra</surname>
	</personname>
      </author>

      <author>
	<personname>
	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	</personname>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Martin</firstname>
	  <surname>Heinen</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </info>

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>Übersicht</title>

    <para>&os; wird zwischen einzelnen Releases ständig weiter
      entwickelt.  Manche Leute bevorzugen die offiziellen
      Release-Versionen, während andere wiederum lieber auf dem
      aktuellen Stand der Entwicklung bleiben möchten.  Wie dem auch
      sei, sogar offizielle Release-Versionen werden oft mit
      Sicherheitsaktualisierungen und anderen kritischen
      Fehlerbereinigungen versorgt.  Unabhängig von der eingesetzten
      Version bringt &os; alle nötigen Werkzeuge mit, um das System
      aktuell zu halten und es innerhalb verschiedener Versionen zu
      aktualisieren.  Dieses Kapitel beschreibt, wie man einem
      Entwicklungssystem folgen kann, sowie die grundlegenden
      Werkzeuge um &os; zu aktualisieren.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>wissen, wie das System mit
	  <application>freebsd-update</application> oder
	  <application>Subversion</application> aktualisiert
	  wird.</para>
      </listitem>

      <listitem>
	<para>wissen, wie man das aktuell installierte System mit
	  einer ursprünglichen Version vergleicht.</para>
      </listitem>

      <listitem>
	<para>wissen, wie die installierte Dokumentation mit
	  <application>Subversion</application> oder
	  Dokumentations-Ports
          <!-- oder <application>Docsnap</application> -->
	  aktualisiert wird.</para>
      </listitem>

      <listitem>
	<para>den Unterschied zwischen den beiden Entwicklungszweigen
	  &os.stable; und &os.current; kennen.</para>
      </listitem>

      <listitem>
	<para>wissen, wie das komplette Basissystem neu gebaut und
	  installiert wird.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>das Netzwerk richtig konfiguriert haben
	  (<xref linkend="advanced-networking"/>).</para>
      </listitem>

      <listitem>
	<para>wissen, wie Software Dritter installiert wird
	  (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>In diesem Kapitel wird <command>svn</command> verwendet,
	um die &os; Quellen zu beziehen und zu aktualisieren.  Um es
	zu verwenden, muss zuerst der Port oder das Paket
	<package>devel/subversion</package> installiert werden.</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info>
      <title>&os;-Update</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Colin</firstname>
	    <surname>Percival</surname>
	  </personname>
	  <contrib>Basierend auf Mitschriften von </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Benedict</firstname>
	    <surname>Reuschling</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>Das zeitnahe Einspielen von Sicherheitsaktualisierungen und
      die Aktualisierung des Betriebssystems sind wichtige Aspekte der
      Systemadministration.  &os; enthält das Werkzeug
      <command>freebsd-update</command>, mit dem Sie diese beiden
      Aufgaben erfüllen können.</para>

    <para>Dieses Werkzeug ermöglicht die Anwendung von
      Sicherheitsaktualisierungen im Binärformat auf das &os;
      Basissystem, ohne dieses neu zu übersetzen und zu installieren.
      Die Aktualisierungen im Binärformat sind für alle Architekturen
      und Versionen verfügbar, welche vom &os; Sicherheitsteam
      unterstützt werden.  Eine Liste der unterstützten Versionen und
      der <foreignphrase>End-of-Life</foreignphrase>-Daten ist unter
      <uri xlink:href="http://www.FreeBSD.org/security/">
	http://www.FreeBSD.org/security/</uri> aufgeführt.</para>

    <para><command>freebsd-update</command> unterstützt auch die
      Aktualisierung des Betriebssystems auf eine neuere Unterversion
      sowie eine Aktualisierung auf einen anderen Release-Zweig.
      Bevor Sie auf eine neue Version aktualisieren, sollten Sie die
      aktuellen Ankündigungen zu dem Release gelesen haben, da diese
      wichtige Informationen zu dem entsprechenden Release enthalten.
      Ankündigungen finden Sie unter <uri
	xlink:href="http://www.FreeBSD.org/releases/">
	http://www.FreeBSD.org/releases/</uri>.</para>

    <note>
      <para>Wenn eine <command>crontab</command> existiert, welche die
	Eigenschaften von &man.freebsd-update.8; verwendet, muss diese
	deaktiviert werden, bevor das Betriebssystem aktualisiert
	wird.</para>
    </note>

    <para>Dieser Abschnitt beschreibt die Verwendung der
      Konfigurationsdatei von <command>freebsd-update</command>.  Es
      wird gezeigt wie Sie Sicherheitsaktualisierungen einspielen,
      oder wie Sie das Betriebssystem auf neuere Haupt- und
      Unterversionen aktualisieren können.</para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>Die Konfigurationsdatei</title>

      <para>In der Regel muss die Konfigurationsdatei von
	<command>freebsd-update</command> nicht bearbeitet werden.
	Manche Benutzer möchten die Standard-Konfigurationsdatei
	<filename>/etc/freebsd-update.conf</filename> trotzdem
	anpassen, um bessere Kontrolle über den gesamten Prozess zu
	besitzen.  Die Kommentare in dieser Datei beschreiben die
	verfügbaren Optionen, jedoch benötigen die folgenden ein paar
	zusätzliche Erklärungen:</para>

      <programlisting># Components of the base system which should be kept updated.
Components world kernel</programlisting>

      <para>Dieser Parameter kontrolliert, welche Teile von &os; auf
	dem aktuellen Stand gehalten werden sollen.  In der
	Voreinstellung wird das gesamte Basissystem sowie der Kernel
	aktualisiert.  Es können auch einzelne Komponenten, wie
	<literal>src/base</literal> oder <literal>src/sys</literal>,
	angegeben werden.  Die beste Einstellung ist, diese Option so
	zu belassen, da eine Änderung es bedingt, dass man als
	Benutzer jede Komponente auflisten muss, die aktualisiert
	werden soll.  Dies könnte katastrophale Folgen nach sich
	ziehen, da der Quellcode und die Binärdateien dadurch nicht
	mehr synchron wären.</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths /boot/kernel/linker.hints</programlisting>

      <para>Fügen Sie Pfade wie <filename>/bin</filename> oder
	<filename>/sbin</filename> hinzu, um diese speziellen
	Verzeichnisse während des Aktualisierungsprozesses unberührt
	zu lassen.  Diese Option kann verwendet werden, um zu
	verhindern, dass <command>freebsd-update</command> lokale
	Änderungen überschreibt.</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Diese Option aktualisiert nur unmodifizierte
	Konfigurationsdateien in den angegebenen Verzeichnissen.  Jede
	Änderung, die der Benutzer daran vorgenommen hat, wird die
	automatische Aktualisierung dieser Dateien verhindern.  Es
	gibt eine weitere Option
	<literal>KeepModifiedMetadata</literal>, die
	<command>freebsd-update</command> instruiert, die Änderungen
	während der Zusammenführung zu speichern.</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints</programlisting>

      <para>Eine Liste von Verzeichnissen mit Konfigurationsdateien,
	in denen <command>freebsd-update</command> Zusammenführungen
	versuchen soll.  Dieser Verschmelzungsprozess von Dateien ist
	eine Serie von &man.diff.1;-Korrekturen, ähnlich wie
	&man.mergemaster.8;, aber mit weniger Optionen.  Die
	Änderungen werden entweder akzeptiert, oder öffnen einen
	Editor, oder <command>freebsd-update</command> bricht ab.  Im
	Zweifelsfall sichern Sie <filename>/etc</filename> und
	akzeptieren einfach die Änderungen.  Lesen Sie <xref
	  linkend="mergemaster"/>, um Informationen über
	<command>mergemaster</command> zu erhalten.</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>In diesem Verzeichnis werden alle Korrekturen und
	temporären Dateien abgelegt.  Im Falle einer
	Versionsaktualisierung sollte diesem Verzeichnis mindestens
	ein Gigabyte Festplattenspeicher zur Verfügung stehen.</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>Wenn diese Option auf <literal>yes</literal> gesetzt ist,
	wird <command>freebsd-update</command> annehmen, dass die
	<literal>Components</literal>-Liste vollständig ist und nicht
	versuchen, Änderungen ausserhalb dieser Liste zu tätigen.
	Tatsächlich wird <command>freebsd-update</command> versuchen,
	jede Datei zu aktualisieren, die zu der
	<literal>Components</literal>-Liste gehört.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>Sicherheitskorrekturen anwenden</title>

      <para>Das Einspielen von &os; Sicherheitskorrekturen wurde
	dahingehend vereinfacht, dass der Administrator nun das
	gesamte System mit <command>freebsd-update</command> auf
	dem aktuellen Stand halten kann.  Weitere Informationen zu
	&os; Sicherheitshinweisen finden Sie in <xref
	  linkend="security-advisories"/>.</para>

      <para>Sicherheitskorrekturen für &os; können wie folgt
	heruntergeladen und installiert werden.  Das erste
	Kommando prüft, ob noch ausstehende Korrekturen verfügbar
	sind, und wenn dass der Fall ist, zeigt es welche Dateien
	davon betroffen wären.  Das zweite Kommando wird die
	Korrekturen auf das System anwenden.</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Wenn während der Aktualisierung Korrekturen am Kernel
	angewendet werden, muss das System neu gestartet werden, damit
	der korrigierte Kernel gebootet wird.  Wenn die Korrekturen
	auf laufende Binärdateien angewendet werden, sollten die
	betroffenen Anwendungen neu gestartet werden, damit die
	korrigierte Version der Binärdatei geladen wird.</para>

      <para>Mit dem folgenden Eintrag in
	<filename>/etc/crontab</filename> wird das System einmal
	täglich nach Aktualisierungen suchen:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>Wenn Korrekturen existieren, werden diese automatisch
	heruntergeladen, aber nicht eingespielt.  Der <systemitem
	  class="username">root</systemitem>-Benutzer bekommt eine
	Nachricht, damit die Korrekturen überprüft und mit
	<command>freebsd-update install</command> manuell installiert
	werden können.</para>

      <para>Wenn etwas schief geht, kann
	<command>freebsd-update</command> den letzten Satz von
	Änderungen mit folgendem Befehl rückgängig machen:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput>
Uninstalling updates... done.</screen>

      <para>Wie bereits erwähnt, sollte das System neu gestartet
	werden, wenn der Kernel oder ein Kernelmodul verändert wurde.
	Betroffene Anwendungen sollten neu gestartet werden, wenn
	Binärdateien verändert wurden.</para>

      <para>Das <command>freebsd-update</command>-Werkzeug kann nur
	den <filename>GENERIC</filename>-Kernel automatisch
	aktualisieren.  Wenn ein angepasster Kernel verwendet wird,
	muss dieser neu erstellt und installiert werden, nachdem
	<command>freebsd-update</command> die Aktualisierungen
	durchgeführt hat.  Allerdings wird
	<command>freebsd-update</command> den
	<filename>GENERIC</filename>-Kernel in
	<filename>/boot/GENERIC</filename> erkennen und aktualisieren,
	selbst wenn dies nicht der aktuell verwendete Kernel des
	Systems ist.</para>

      <note>
	<para>Behalten Sie immer eine Kopie des
	  <filename>GENERIC</filename>-Kernels in
	  <filename>/boot/GENERIC</filename>.  Das wird bei der
	  Diagnose von verschiedenen Problemen sowie bei der
	  Durchführung von Versionsaktualisierungen eine große Hilfe
	  sein.  Im <xref linkend="freebsd-update-custom-kernel-9x"/>
	  wird beschrieben, wie Sie eine Kopie des
	  <filename>GENERIC</filename>-Kernels bekommen.</para>
      </note>

      <para>Solange die Standardkonfiguration in
	<filename>/etc/freebsd-update.conf</filename> nicht geändert
	wurde, wird <command>freebsd-update</command> die
	aktualisierten Quellcodedateien des Kernels zusammen mit dem
	Rest der Neuerungen installieren.  Die erneute Übersetzung und
	Installation eines neuen, angepassten Kernels kann dann auf
	die übliche Art und Weise durchgeführt werden.</para>

      <para>Die Aktualisierungen, die über
	<command>freebsd-update</command> verteilt werden, betreffen
	nicht immer den Kernel.  Es ist nicht notwendig, den
	angepassten Kernel neu zu erstellen, wenn die Kernelquellen
	nicht durch <command>freebsd-update install</command> geändert
	wurden.  Allerdings wird <command>freebsd-update</command>
	immer <filename>/usr/src/sys/conf/newvers.sh</filename>
	aktualisieren.  Der aktuelle Patch-Level, der mit der
	<literal>-p</literal>-Nummer bei <command>uname -r</command>
	ausgegeben wird, wird aus dieser Datei ausgelesen.  Die
	Neuinstallation des angepassten Kernels, selbst wenn sich
	daran nichts geändert hat, erlaubt es
	<command>uname</command>, den aktuellen Patch-Level des
	Systems korrekt wiederzugeben.  Dies ist besonders hilfreich,
	wenn mehrere Systeme gewartet werden, da es eine schnelle
	Einschätzung der installierten Aktualisierungen in jedem
	einzelnen System ermöglicht.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>Aktualisierungen an Haupt- und Unterversionen</title>

      <para>Aktualisierungen einer Unterversion von &os; zur nächsten
	Version ist beispielsweise die Aktualisierung von
	&os;&nbsp;9.0 auf &os;&nbsp;9.1.  Die Aktualisierung einer
	Hauptversion ist beispielsweise von &os;&nbsp;9.X auf
	&os;&nbsp;10.X.  Beide Arten der Aktualisierungen können
	durchgeführt werden, indem man
	<command>freebsd-update</command> eine Release-Version als
	Ziel übergibt.</para>

      <note>
	<para>Wenn auf dem System ein angepasster Kernel eingesetzt
	  wird, stellen Sie sicher, dass eine Kopie des
	  <filename>GENERIC</filename>-Kernels in
	  <filename>/boot/GENERIC</filename> existiert.  Im
	  <xref linkend="freebsd-update-custom-kernel-9x"/> wird
	  beschrieben, wie Sie eine Kopie des
	  <filename>GENERIC</filename>-Kernels bekommen.</para>
      </note>

      <para>Wenn Sie das folgende Kommando auf einem System
	mit &os;&nbsp;9.0 ausführen, wird das System auf
	&os;&nbsp;9.1 aktualisiert:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 9.1-RELEASE upgrade</userinput></screen>

      <para>Nach der Eingabe des Kommandos überprüft
	<command>freebsd-update</command> die Konfigurationsdatei und
	das aktuelle System, um die nötigen Informationen für die
	Systemaktualisierung zu sammeln.  Eine Bildschirmausgabe wird
	anzeigen, welche Komponenten erkannt und welche nicht erkannt
	wurden.  Zum Beispiel:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? <userinput>y</userinput></screen>

      <para>An diesem Punkt wird <command>freebsd-update</command>
	versuchen, alle notwendigen Dateien für die Aktualisierung
	herunter zu laden.  In manchen Fällen wird der Benutzer mit
	Fragen konfrontiert, um festzustellen, was installiert werden
	soll oder auf welche Art und Weise fortgesetzt werden
	soll.</para>

      <para>Wenn ein angepasster Kernel benutzt wird, produziert der
	vorherige Schritt eine Warnung ähnlich zu der
	folgenden:</para>

      <screen>WARNING: This system is running a "
<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>Diese Warnung kann an dieser Stelle problemlos ignoriert
	werden.  Der aktualisierte
	<filename>GENERIC</filename>-Kernel wird als ein
	Zwischenschritt im Aktualisierungsprozess verwendet.</para>

      <para>Nachdem alle Korrekturen auf das lokale System
	heruntergeladen wurden, werden diese eingespielt.  Dieser
	Prozess kann eine gewisse Zeit in Anspruch nehmen, abhängig
	von der Geschwindigkeit und Auslastung der Maschine.
	Konfigurationsdateien werden ebenfalls zusammengefügt.  Dieser
	Teil der Prozedur verlangt einige Benutzereingaben, da eine
	Datei möglicherweise von Hand zusammengefasst werden muss oder
	ein Editor erscheint auf dem Bildschirm zum manuellen
	bearbeiten.  Die Ergebnisse von jeder erfolgreichen
	Zusammenfassung werden dem Benutzer angezeigt, während der
	Prozess weiter läuft.  Eine fehlgeschlagene oder ignorierte
	Zusammenfassung wird den Prozess sofort beenden.  Benutzer
	sollten eine Sicherung von <filename>/etc</filename> anlegen
	und wichtige Dateien später manuell vereinen, beispielsweise
	<filename>master.passwd</filename> oder
	<filename>group</filename>.</para>

      <note>
	<para>Das System ist zu diesem Zeitpunkt noch nicht
	  verändert worden, da alle Korrekturen und Vereinigungen
	  in einem anderen Verzeichnis vorgenommen wurden.  Wenn
	  alle Korrekturen erfolgreich eingespielt, alle
	  Konfigurationsdateien zusammengefügt wurden und es den
	  Anschein hat, dass der Prozess problemlos verlaufen wird,
	  müssen die Änderungen vom Anwender noch angewendet und auf
	  die Platte geschrieben werden:</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>
      </note>

      <para>Der Kernel und die Module werden zuerst aktualisiert.
	Wenn das System einen angepassten Kernel verwendet, benutzen
	Sie &man.nextboot.8;, um den Kernel für den nächsten
	Neustart auf <filename>/boot/GENERIC</filename> zu
	setzen:</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
	<para>Bevor das System mit dem
	  <filename>GENERIC</filename>-Kernel neu gestartet wird,
	  vergewissern Sie sich, dass für den Neustart alle
	  benötigten Treiber enthalten sind.  Falls auf die
	  Maschine aus der Ferne zugegriffen wird, stellen Sie
	  sicher, dass das System ordnungsgemäß an das Netzwerk
	  angeschlossen ist.  Achten Sie besonders darauf, dass wenn
	  der angepasste Kernel Funktionalität beinhaltet, die
	  normalerweise von Kernelmodulen zur Verfügung gestellt
	  werden, dass diese temporär über
	  <filename>/boot/loader.conf</filename> in den
	  <filename>GENERIC</filename>-Kernel übernommen werden.
	  Zudem wird empfohlen, nicht benötigte Dienste, eingehängte
	  Platten und verbundene Netzlaufwerke zu deaktivieren, bis
	  der Aktualisierungsprozess abgeschlossen ist.</para>
      </warning>

      <para>Die Maschine sollte nun mit dem aktualisierten Kernel
	neu gestartet werden:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>Sobald das System wieder hochgefahren ist, muss
	<command>freebsd-update</command> erneut gestartet werden.
	Da der Zustand des Prozesses zuvor gesichert wurde, wird
	<command>freebsd-update</command> nicht von vorne
	beginnen, sondern mit der nächsten Phase fortfahren und
	alle alten Bibliotheken und Objektdateien löschen.</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>Abhängig davon, ob irgendwelche Bibliotheksversionen
	  erhöht wurden, kann es sein, dass nur zwei
	  Installationsphasen anstatt drei durchlaufen werden.</para>
      </note>

      <para>Die Aktualisierung ist nun abgeschlossen.  Wenn es sich
	hierbei um eine Aktualisierung auf eine neue Hauptversion
	handelt, müssen alle Ports und Pakete neu installiert
	werden.  Dieser Vorgang wird in <xref
	  linkend="freebsdupdate-portsrebuild"/> beschrieben.</para>

      <sect3 xml:id="freebsd-update-custom-kernel-9x">
	<title>Angepasste Kernel unter &os;&nbsp;9.X und
	  später</title>

	<para>Stellen Sie vor der ersten Benutzung von
	  <command>freebsd-update</command> sicher, dass eine
	  Kopie des <filename>GENERIC</filename>-Kernels in
	  <filename>/boot/GENERIC</filename> existiert.  Wenn ein
	  angepasster Kernel erstmalig gebaut wurde, ist der Kernel
	  in <filename>/boot/kernel.old</filename> der
	  <filename>GENERIC</filename>-Kernel.  Benennen Sie
	  dieses Verzeichnis einfach in
	  <filename>/boot/kernel</filename> um.</para>

	<para>Wenn bereits mehrfach ein angepasster Kernel gebaut
	  wurde, oder nicht bekannt ist wie oft ein angepasster
	  Kernel gebaut wurde, behalten Sie besser eine Kopie des
	  <filename>GENERIC</filename>-Kernels, welcher mit der
	  aktuellen Version des Betriebssystems übereinstimmt.
	  Wenn ein direkter Zugriff auf die Maschine möglich ist,
	  kann eine Kopie des <filename>GENERIC</filename>-Kernels
	  von den Installationsmedien installiert werden:</para>

	<screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/usr/freebsd-dist</userinput>
&prompt.root; <userinput>tar -C/ -xvf kernel.txz boot/kernel/kernel</userinput></screen>

	<para>Alternativ kann der
	  <filename>GENERIC</filename>-Kernel aus den Quellen neu
	  gebaut und installiert werden:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput></screen>

	<para>Damit dieser Kernel als
	  <filename>GENERIC</filename>-Kernel von
	  <command>freebsd-update</command> erkannt wird, darf
	  die <filename>GENERIC</filename>-Konfigurationsdatei
	  in keiner Weise geändert worden sein.  Es wird ebenfalls
	  empfohlen, dass dieser ohne irgendwelche speziellen
	  Optionen erstellt wird.</para>

	<para>Der Neustart in den
	  <filename>GENERIC</filename>-Kernel ist nicht notwendig,
	  da <command>freebsd-update</command> lediglich
	  <filename>/boot/GENERIC</filename> benötigt.</para>
      </sect3>

      <sect3 xml:id="freebsdupdate-portsrebuild">
	<title>Aktualisierung der Pakete nach einem Upgrade auf eine
	  Hauptversion</title>

	<para>In der Regel funktionieren nach einer Aktualisierung
	  einer Unterversion die installierten Anwendungen weiterhin
	  problemlos.  Neue Hauptversionen verwenden jedoch andere
	  Binärschnittstellen (<acronym>ABI</acronym>s), was dazu
	  führt, dass die meisten Anwendungen von Drittherstellern
	  nicht mehr funktionieren.  Nach der Aktualisierung auf eine
	  Hauptversion, müssen alle installierten Ports und Pakete
	  aktualisiert werden.  Benutzen Sie
	  <command>pkg upgrade</command> um Pakte zu aktualisieren.
	  Installierte Ports können Sie mit einem Werkzeug wie
	  <package>ports-mgmt/portmaster</package> aktualisiert
	  werden.</para>

	<para>Bei einer erzwungenen Aktualisierung aller installierten
	  Pakete, werden diese durch eine neue Version aus dem
	  Repository ersetzt, sogar dann, wenn sich die Versionsnummer
	  nicht erhöht hat.  Dieser Schritt ist erforderlich, da sich
	  die <acronym>ABI</acronym> bei einer Aktualisierung der
	  Hauptversion von &os; verändert hat.  Eine erzwungene
	  Aktualisierung aller installierten Pakete geschieht wie
	  folgt:</para>

	<screen>&prompt.root; <userinput>pkg-static upgrade -f</userinput></screen>

	<para>Ein Neubau der installierten Ports führen Sie mit
	  diesem Kommando durch:</para>

	<screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

	<para>Dieser Befehl wird die Konfigurationen für jede
	  Anwendung anzeigen, und der Benutzer hat die Möglichkeit,
	  die Optionen anzupassen.  Wenn Sie ausschließlich die
	  voreingestellten Optionen verwenden möchten, verwenden Sie
	  mit dem obigen Befehl den Parameter
	  <option>-G</option>.</para>

	<para>Sobald dies abgeschlossen ist, beenden Sie den
	  Aktualisierungsprozess mit einem letzten Aufruf von
	  <command>freebsd-update</command>.  Geben Sie den folgenden
	  Befehl ein, um alle losen Enden des Aktualisierungsprozesses
	  miteinander zu verknüpfen:</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	<para>Wenn der <filename>GENERIC</filename>-Kernel temporär
	  Verwendung fand, ist dies der richtige Zeitpunkt, einen
	  neuen, angepassten Kernel nach den Anweisungen in <xref
	    linkend="kernelconfig"/> zu bauen und zu
	  installieren.</para>

	<para>Booten Sie anschließend die Maschine in die neue
	  &os;-Version.  Der Aktualisierungsprozess ist damit
	  abgeschlossen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>Vergleich des Systemzustands</title>

      <para><command>freebsd-update IDS</command> kann verwendet
	werden, um den Zustand der installierten &os;-Version
	gegenüber einer bekannten und funktionierenden Kopie zu
	vergleichen.  Dieses Kommando vergleicht die aktuelle Version
	von Systemwerkzeugen, Bibliotheken sowie Konfigurationsdateien
	und kann als integriertes Intrusion Detection System
	(<acronym>IDS</acronym>) benutzt werden.</para>

      <warning>
	<para>Dieses Programm ist kein Ersatz für ein echtes
	  <acronym>IDS</acronym>-System wie
	  <package>security/snort</package>.  Da
	  <command>freebsd-update</command> Daten auf der Festplatte
	  speichert, ist die Möglichkeit von Verfälschungen
	  offensichtlich.  Obwohl diese Möglichkeit durch die
	  Verwendung von <varname>kern.securelevel</varname> oder die
	  Speicherung von Daten auf einem Nur-Lese Dateisystem
	  eingedämmt werden kann, besteht eine bessere Lösung darin,
	  das System gegen ein gesichertes Medium, wie eine
	  <acronym>DVD</acronym> oder einen externen, separat
	  aufbewahrten <acronym>USB</acronym>-Plattenspeicher, zu
	  vergleichen.  Eine alternative Methode zur Bereitstellung
	  von <acronym>IDS</acronym>-Funktionaliäten wird in
	  <xref linkend="security-ids"/> beschrieben.</para>
      </warning>

      <para>Beginnen Sie den Vergleich, indem Sie das Programm starten
	und eine Ausgabedatei festlegen:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; <replaceable>outfile.ids</replaceable></userinput></screen>

      <para>Das System wird nun überprüft.  Dabei wird eine lange
	Liste von Dateien zusammen mit den
	<acronym>SHA256</acronym>-Hashwerten der Release-Version und
	den Werten des aktuell installierten Systems, in die
	angegebene Ausgabedatei geschrieben.</para>

      <para>Die Zeilen in der Ausgabe sind extrem lang, aber das
	Ausgabeformat kann einfach verarbeitet werden.  Um
	beispielsweise eine Liste von allen Dateien zu erhalten, die
	sich vom aktuellen Release unterscheiden, geben Sie das
	folgende Kommando ein:</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>Diese Beispielausgabe wurde abgeschnitten, da noch viele
	weitere Dateien vorhanden sind.  Einige Dateien wurden auf
	natürliche Art verändert.  <filename>/etc/passwd</filename>
	wurde beispielsweise geändert, wenn Benutzer zum System
	hinzugefügt wurden.  Kernelmodule können sich unterscheiden,
	wenn <command>freebsd-update</command> diese aktualisiert hat.
	Um bestimmte Dateien oder Verzeichnisse auszuschließen, fügen
	Sie diese an die <literal>IDSIgnorePaths</literal>-Option in
	<filename>/etc/freebsd-update.conf</filename> an.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-documentation">
    <info>
      <title>Aktualisieren der Dokumentationssammlung</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Benedict</firstname>
	    <surname>Reuschling</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>

    <indexterm>
      <primary>Documentation</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Dokumentation ein wichtiger Bestandteil des &os;
      Betriebssystems.  Obwohl eine aktuelle Version der &os;
      Dokumentation jederzeit auf der &os; Webseite (<link
	xlink:href="&url.base;/doc/">
	http://www.freebsd.org/doc/</link>) verfügbar ist, kann es
      nützlich sein, eine lokale Kopie der &os; Webseite, Handbücher,
      <acronym>FAQ</acronym> und Artikel zu haben.</para>

    <para>Dieser Abschnitt beschreibt, wie Sie die &os; Dokumentation
      über die Quellen oder die &os; Ports-Sammlung aktuell
      halten.</para>

    <para>Informationen zum Bearbeiten und Einreichen von Korrekturen
      finden Sie in der <link
	xlink:href="&url.doc.langbase;/books/fdp-primer">Fibel für
	neue Mitarbeiter des
	&os;-Dokumentationsprojekts</link>.</para>

    <sect2 xml:id="updating-installed-documentation">
      <title>Die &os;-Dokumentation aus den Quellen
	installieren</title>

      <para>Der Bau der &os; Dokumentation aus den Quellen erfordert
	einige Werkzeuge, die nicht Teil des Basissystems sind.  Die
	erforderlichen Werkzeuge, darunter auch
	<application>svn</application>, können über den Port oder das
	Paket <package>textproc/docproj</package> installiert
	werden.</para>

      <para>Benutzen Sie nach der Installation
	<application>svn</application>, um eine saubere Kopie der
	Dokumentationsquellen zu holen:</para>

      <screen>&prompt.root; <userinput>svn checkout https://svn.FreeBSD.org/doc/head /usr/doc</userinput></screen>

      <para>Es dauert eine Weile, bis die Quellen das allererste Mal
	heruntergeladen werden.  Lassen Sie den Vorgang laufen, bis es
	fertig ist.</para>

      <para>Zukünftige Aktualisierungen der Dokumentationsquellen
	können wie folgt durchgeführt werden:</para>

      <screen>&prompt.root; <userinput>svn update /usr/doc</userinput></screen>

      <para>Sobald ein aktueller Schnappschuss der
	Dokumentationsquellen nach <filename>/usr/doc</filename>
	heruntergeladen wurde, ist alles bereit für eine
	Aktualisierung der bestehenden Dokumentation.</para>

      <para>Eine komplette Aktualisierung aller Sprachen kann durch
	folgende Eingabe erreicht werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Wenn nur eine Aktualisierung einer bestimmten Sprache
	gewünscht wird, kann <command>make</command> in einem
	sprachspezifischen Unterverzeichnis von
	<filename>/usr/doc</filename> aufgerufen werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Alternativ kann der folgende Befehl in
	<filename>/usr/doc</filename> oder einem sprachspezifischen
	Unterverzeichnis abgesetzt werden, um die Dokumentation zu
	aktualisieren:</para>

      <screen>&prompt.root; <userinput>make update</userinput></screen>

      <para>Die zu installierenden Ausgabeformate können durch das
	Setzen von <varname>FORMATS</varname> angegeben werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>

      <para>Es existieren ein paar Optionen, welche den Prozess der
	Aktualisierung von Teilen der Dokumentation oder einer
	bestimmten Übersetzung erleichtern.  Diese Optionen können
	entweder systemweit in <filename>/etc/make.conf</filename>
	gesetzt, oder als Kommandozeilenoptionen an
	<command>make</command> übergeben werden.</para>

      <para>Zu den Optionen gehören:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>DOC_LANG</varname></term>

	  <listitem>
	    <para>Eine Liste von Sprachen und Kodierungen, die gebaut
	      und installiert werden sollen, z.B.
	      <literal>en_US.ISO8859-1</literal>, um nur die englische
	      Dokumentation zu erhalten.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>FORMATS</varname></term>

	  <listitem>
	    <para>Ein einzelnes Format oder eine Liste von
	      Ausgabeformaten, das gebaut werden soll.  Momentan
	      werden <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal> und <literal>pdf</literal>
	      unterstützt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCDIR</varname></term>

	  <listitem>
	    <para>Wohin die Dokumentation installiert werden soll.
	      Der Standardpfad ist
	      <filename>/usr/share/doc</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Für weitere <command>make</command>-Variablen, die als
	systemweite Optionen in &os; unterstützt werden, lesen Sie
	&man.make.conf.5;.</para>
    </sect2>

    <sect2 xml:id="doc-ports-install-package">
      <info>
	<title>Die Dokumentation aus den Ports aktualisieren</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Marc</firstname>
	      <surname>Fonvieille</surname>
	    </personname>
	    <contrib>Basierend auf der Arbeit von </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>Im vorherigen Abschnitt wurde eine Methode gezeigt, wie
	die &os;-Dokumentation aus den Quellen gebaut werden kann.
	Dieser Abschnitt beschreibt eine alternative Methode, in der
	die Ports-Sammlung verwendet wird und die es
	ermöglicht:</para>

      <itemizedlist>
	<listitem>
	  <para>vorgefertigte Schnappschüsse der Dokumentation zu
	    installieren, ohne vorher die Werkzeugsammlung der
	    Dokumentation installieren zu müssen.</para>
	</listitem>

	<listitem>
	  <para>die Dokumentationsquellen durch das Ports-System
	    erstellen zu lassen, was die Schritte zum Auschecken und
	    Erstellen etwas erleichtert.</para>
	</listitem>
      </itemizedlist>

      <para>Diese Methoden der Aktualisierung der
	&os;-Dokumentation werden durch eine Menge von
	Dokumentations-Ports und Paketen unterstützt, die von
	&a.doceng; monatlich aktualisiert wird.  Diese sind in der
	&os; Ports-Sammlung unter der Kategorie <quote>docs</quote>
	gelistet (<link
	  xlink:href="http://www.freshports.org/docs/">
	  http://www.freshports.org/docs/</link>).</para>

      <para>Die Dokumentations-Ports sind wie folgt
	organisiert:</para>

      <itemizedlist>
	<listitem>
	  <para>Das Paket oder der Port
	    <package>misc/freebsd-doc-en</package> installiert die
	    englische Dokumentation.</para>
	</listitem>

	<listitem>
	  <para>Das Paket oder der Port
	    <package>misc/freebsd-doc-all</package> installiert die
	    komplette Dokumentation in allen verfügbaren
	    Sprachen.</para>
	</listitem>

	<listitem>
	  <para>Es gibt noch ein Paket oder einen Port für jede
	    Übersetzung, beispielsweise
	    <package>misc/freebsd-doc-hu</package> für die
	    ungarische Dokumentation.</para>
	</listitem>
      </itemizedlist>

      <para>Wenn Sie Pakete benutzen, wird die &os;-Dokumentation in
	allen verfügbaren Formaten der jeweiligen Sprache
	installiert.  Das folgende Beispiel wird das aktuelle Paket
	der ungarischen Dokumentation installieren:</para>

      <screen>&prompt.root; <userinput>pkg install hu-freebsd-doc</userinput></screen>

      <note>
	<para>Pakete verwenden ein Format, welches sich von dem
	  Namen des dazugehörigen Ports unterscheidet:
	  <literal><replaceable>lang</replaceable>-freebsd-doc</literal>.
	  <replaceable>lang</replaceable> entspricht hier der
	  Kurzform des Sprachcodes, z.B. <literal>hu</literal> für
	  Ungarisch, oder <literal>zh_cn</literal> für vereinfachtes
	  Chinesisch.</para>
      </note>

      <para>Um das Format der Dokumentation zu bestimmen, muss
	anstelle des Pakets der Port gebaut werden.  Das folgende
	Beispiel baut und installiert die englische
	Dokumentation:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Der Port enthält ein Konfigurationsmenü, in dem das
	Format ausgewählt werden kann.  In der Voreinstellung sind
	<literal>html-split</literal> und <literal>pdf</literal>
	ausgewählt.</para>

      <para>Alternativ können bei der Erstellung eines
	Dokumentations-Ports verschiedene
	<command>make</command>-Optionen angegeben werden.
	Dazu gehören:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>WITH_HTML</varname></term>

	  <listitem>
	    <para>Erstellt das <acronym>HTML</acronym>-Format mit
	      einer einzigen <acronym>HTML</acronym>-Datei pro
	      Dokument.  Die formatierte Dokumentation wird als
	      Datei mit dem Namen <filename>article.html</filename>
	      oder <filename>book.html</filename> gespeichert.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>WITH_PDF</varname></term>

	  <listitem>
	    <para>Die formatierte Dokumentation wird als Datei
	      mit dem Namen <filename>article.pdf</filename> oder
	      <filename>book.pdf</filename> gespeichert.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCBASE</varname></term>

	  <listitem>
	    <para>Legt den Pfad fest, wohin die Dokumentation
	      installiert werden soll.  Die Voreinstellung ist
	      <filename>/usr/local/share/doc/freebsd</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Dieses Beispiel verwendet Variablen, um die ungarische
	Dokumentation als <acronym>PDF</acronym> in ein bestimmtes
	Verzeichnis zu installieren:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-hu</userinput>
&prompt.root; <userinput>make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</userinput></screen>

      <para>Dokumentations-Ports oder -Pakete können nach den
	Anweisungen in <xref linkend="ports"/> aktualisiert werden.
	Beispielsweise aktualisiert das folgende Kommando die
	installierte ungarische Dokumentation mittels
	<package>ports-mgmt/portmaster</package> unter Verwendung
	von Paketen:</para>

      <screen>&prompt.root; <userinput>portmaster -PP hu-freebsd-doc</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="current-stable">
    <title>Einem Entwicklungszweig folgen</title>

    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>&os; besitzt zwei Entwicklungszweige: &os.current; und
      &os.stable;.</para>

    <para>Dieser Abschnitt beschreibt beide Zweige sowie deren
      Interessengruppen und erläutert, wie ein System auf dem
      aktuellen Stand eines jeweiligen Zweiges gehalten wird.</para>

    <sect2 xml:id="current">
      <title>&os.current;</title>

      <para>&os.current; ist die allerneueste Entwicklung von &os;.
	Benutzer von &os.current; sollten über sehr gute technische
	Fähigkeiten verfügen.  Benutzer mit weniger technischen
	Fähigkeiten sollten stattdessen &os.stable; benutzen, wenn
	sie einem Entwicklungszweig folgen möchten.</para>

      <para>&os.current; besteht aus den neuesten Quellen des
	&os;-Systems und enthält Sachen, an denen gerade
	gearbeitet wird, experimentelle Änderungen und
	Übergangsmechanismen, die im nächsten offiziellen
	Release enthalten sein können oder nicht.  Obwohl &os.current;
	täglich von vielen Entwicklern gebaut wird, gibt es Zeiträume,
	in denen sich das System vielleicht nicht bauen lässt.  Diese
	Probleme werden so schnell wie möglich behoben, aber ob Sie
	mit &os.current; eine Katastrophe erleben oder neue Funktionen
	erhalten, kann von dem Zeitpunkt abhängen, an dem der
	Quelltext synchronisiert wurde.</para>

      <para>&os.current; wird hauptsächlich für drei
	Interessengruppen zur Verfügung gestellt:</para>

      <orderedlist>
	<listitem>
	  <para>Mitglieder der &os; Gemeinschaft, die aktiv an einem
	    Teil des Quellbaums arbeiten.</para>
	</listitem>

	<listitem>
	  <para>Mitglieder der &os; Gemeinschaft, die aktive Tester
	    sind.  Diese Personen sind bereit, Zeit in das Lösen von
	    Problemen zu investieren, Vorschläge zu Änderungen oder
	    der generellen Entwicklung von &os; zu machen und
	    Fehlerkorrekturen einzureichen.</para>
	</listitem>

	<listitem>
	  <para>Benutzer, die die Entwicklung im Auge behalten, oder
	    die Quellen zu Referenzzwecken benutzen wollen.  Diese
	    Gruppe macht auch Vorschläge oder steuert Quellcode
	    bei.</para>
	</listitem>
      </orderedlist>

      <para>&os.current; ist <emphasis>nicht</emphasis> der
	schnellste Weg, neue Funktionen vor dem offiziellen Release
	auszuprobieren.  Bedenken Sie, dass neue Funktionen noch
	nicht im vollen Umfang getestet wurden und daher
	höchstwahrscheinlich Fehler enthalten.  Es ist auch nicht
	der schnellste Weg, um an Fehlerbehebungen (engl.
	<foreignphrase>bug fixes</foreignphrase>) zu kommen.  Jede
	Fehlerbehebung führt mit gleicher Wahrscheinlichkeit neue
	Fehler ein, mit der sie alte behebt.  &os.current; wird in
	keiner Weise <quote>offiziell unterstützt</quote>.</para>

      <indexterm>
	<primary>-CURRENT</primary>
	<secondary>benutzen</secondary>
      </indexterm>

      <para>Um &os.current; zu folgen:</para>

      <orderedlist>
	<listitem>
	  <para>Lesen Sie die Mailinglisten &a.current.name; und
	    &a.svn-src-head.name;.  Dies ist
	    <emphasis>notwendig</emphasis>, um die Kommentare
	    über den akutellen Status des Systems und wichtige
	    Mitteilungen zum aktuellen Zustand von &os.current; zu
	    erfahren.</para>

	  <para>Die &a.svn-src-head.name; Mailingliste erfasst die
	    Commit-Logs für jede Änderung und enthält alle
	    relevanten Informationen zu möglichen
	    Seiteneffekten.</para>

	  <para>Um diese Listen zu abonnieren, besuchen Sie
	    &a.mailman.lists.link;, klicken Sie auf die gewünschte
	    Liste und folgen Sie den Anweisungen.  Wenn Sie die
	    Änderungen am gesamten Quellbaum verfolgen möchten,
	    abonnieren Sie die &a.svn-src-all.name; Liste.</para>
	</listitem>

	<listitem>
	  <para>Synchronisieren Sie die Quellen für &os.current;.
	    In der Regel wird <link linkend="svn">svn</link>
	    benutzt, um die Quellen für -CURRENT aus dem Zweig
	    <literal>head</literal> zu laden.  Verwenden Sie dazu
	    einen Subversion Spiegel aus <xref
	      linkend="svn-mirrors"/>.</para>
	</listitem>

	<listitem>
	  <para>Aufgrund der Größe des Repositories ist es
	    empfehlenswert, nur die gewünschten Teilbäume
	    auszuchecken.  Wenn Sie die Quellen einsetzen und
	    nicht nur darin lesen wollen, laden Sie sich die
	    <emphasis>kompletten</emphasis> Quellen von &os.current;
	    und nicht nur ausgesuchte Teile.</para>

	  <para>Lesen Sie <filename>/usr/src/Makefile</filename>
	    sehr aufmerksam und folgen Sie den Anweisungen in <xref
	      linkend="makeworld"/>.  Lesen Sie die
	    Mailingliste &a.current; und
	    <filename>/usr/src/UPDATING</filename>, um über
	    Änderungen im Installationsverfahren, die manchmal vor
	    der Einführung eines neuen Releases notwendig sind,
	    informiert zu sein.</para>
	</listitem>

	<listitem>
	  <para>Seien Sie aktiv!  Benutzer von &os.current; werden
	    aufgefordert ihre Verbesserungsvorschläge oder
	    Fehlerbehebungen einzureichen.  Verbesserungsvorschläge,
	    die Code enthalten, sind jederzeit herzlich
	    willkommen.</para>
	</listitem>
      </orderedlist>
    </sect2>

    <sect2 xml:id="stable">
      <title>&os.stable;</title>

      <para>&os.stable; ist der Entwicklungszweig, auf dem Releases
	erstellt werden.  Dieser Zweig ändert sich langsamer als
	&os.current; und alle Änderungen hier sollten zuvor in
	&os.current; ausgetestet sein.  Beachten Sie, dass dies
	<emphasis>immer noch</emphasis> ein Entwicklungszweig ist
	und daher zu jedem Zeitpunkt die Quellen von &os.stable;
	verwendbar sein können oder nicht.  &os.stable; ist Teil des
	Entwicklungsprozesses und nicht für Endanwender gedacht.
	Benutzer, die nicht über die notwendigen Ressourcen zum
	Testen verfügen, sollten stattdessen eine aktuelle Version
	von &os; benutzen.</para>

      <para>Wer daran interessiert ist den &os;-Entwicklungsprozess
	zu verfolgen oder dazu beizutragen, insbesondere im Hinblick
	auf das nächste Hauptversion, der sollte es in Erwägung
	ziehen, &os.stable; zu benutzen.</para>

      <para>Obwohl wir versuchen sicherzustellen, dass der
	&os.stable; Zweig sich jederzeit übersetzen lässt und
	lauffähig ist, können wir dafür keine Garantie übernehmen.
	Auch wenn Neuentwicklungen in &os.current; stattfinden, ist
	es jedoch so, dass mehr Leute &os.stable; anstelle von
	&os.current; benutzen und es daher unvermeidlich ist, dass
	Fehler und Grenzfälle erst in &os.stable; auffallen.  Aus
	diesen Gründen empfehlen wir Ihnen
	<emphasis>nicht</emphasis> blindlings &os.stable; zu
	benutzen.  Es ist besonders wichtig, dass &os.stable; zuerst
	sorgfältig in einer Testumgebung getestet wird, bevor die
	Produktion auf &os.stable; migriert.</para>

      <para>Um &os.stable; zu folgen:</para>

      <indexterm>
	<primary>-STABLE</primary>
	<secondary>benutzen</secondary>
      </indexterm>

      <orderedlist>
	<listitem>
	  <para>Lesen Sie Mailingliste &a.stable.name;, damit Sie über
	    Abhängigkeiten beim Bau von &os.stable; und Sachen, die
	    besondere Aufmerksamkeit erfordern, informiert sind.
	    Umstrittene Fehlerbehebungen oder Änderungen werden von
	    den Entwicklern auf dieser Liste bekannt gegeben.  Dies
	    erlaubt es den Benutzern, Einwände gegen die
	    vorgeschlagenen Änderungen vorzubringen.</para>

	  <para>Abonnieren Sie die passende
	    <application>svn</application>-Liste für den jeweiligen
	    Branch, den Sie verfolgen.  Wenn Sie beispielsweise den
	    Zweig 9-STABLE verfolgen, lesen Sie die
	    &a.svn-src-stable-9.name;.  Diese Liste enthält zu jeder
	    Änderung das Commit-Log, das Informationen zu möglichen
	    Seiteneffekten enthält.</para>

	  <para>Um diese Listen zu abonnieren, besuchen Sie die
	    Seite &a.mailman.lists.link;.  Klicken Sie auf die
	    gewünschte Liste und folgenden Sie den Anweisungen.
	    Wenn Sie daran interessiert sind, Änderungen am gesamten
	    Quellbaum zu verfolgen, abonnieren Sie
	    &a.svn-src-all.name;.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie ein neues System installieren und dazu
	    einen der monatlich aus &os.stable; erzeugten Snapshots
	    verwenden wollen, sollten Sie zuerst <link
	      xlink:href="&url.base;/snapshots">
	      www.freebsd.org/snapshots</link> auf aktuelle
	    Informationen überprüfen.  Alternativ können Sie auch
	    das neueste &os.stable;-Release von den <link
	      linkend="mirrors">&os; Spiegeln</link> beziehen.</para>

	  <para>Um ein bestehendes &os;-System auf &os.stable; zu
	    aktualisieren, benutzen Sie <link
	      linkend="svn">svn</link>, um den gewünschten
	    Entwicklungs- oder Release-Zweig auszuchecken.  Die
	    Zweige, wie beispielsweise <literal>stable/9</literal>,
	    sind unter <link xlink:href="&url.base;/releng/">
	      www.freebsd.org/releng</link> aufgeführt.</para>
	</listitem>

	<listitem>
	  <para>Lesen Sie <filename>/usr/src/Makefile</filename>
	    sehr aufmerksam bevor Sie &os.stable; aktualisieren und
	    folgen Sie den Anweisungen in <xref
	      linkend="makeworld"/>.  Lesen Sie die
	    Mailingliste &a.stable; und
	    <filename>/usr/src/UPDATING</filename>, um über
	    Änderungen im Installationsverfahren, die manchmal vor
	    der Einführung eines neuen Releases notwendig sind,
	    informiert zu sein.</para>
	</listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="synching">
    <title>Synchronisation der Quellen</title>

    <para>Es gibt verschiedene Methoden um die Quellen von &os;
      aktuell zu halten.  Dieser Abschnitt beschreibt
      <application>Subversion</application>, den primären Dienst für
      diese Aufgabe.</para>

    <warning>
      <para>Obwohl es möglich ist, nur Teile des Quellbaums zu
	aktualisieren, ist die einzige unterstütze Prozedur,
	den kompletten Quellbaum zu aktualisieren und alles neu zu
	übersetzen.  Dazu zählen alle Userland-Programme in
	<filename>/bin</filename> und <filename>/sbin</filename>,
	sowie die Kernelquellen.  Wird hingegen nur ein Teil der
	Quellen, zum Beispiel nur der Kernel oder nur die Programme
	aus dem Userland aktualisiert, treten Probleme auf, die von
	Übersetzungsfehlern über Kernel-Panics bis hin zu
	Beschädigung von Daten reichen können.</para>
    </warning>

    <indexterm>
      <primary>Subversion</primary>
    </indexterm>

    <para><application>Subversion</application> benutzt die
      <foreignphrase>Pull</foreignphrase>-Methode, um die Quellen zu
      aktualisieren.  Der Benutzer, oder ein
      <command>cron</command>-Skript, ruft das Programm
      <command>svn</command> auf, das die Quellen aktualisiert.
      <application>Subversion</application> ist die empfohlene
      Methode, um die lokalen Quellen zu aktualisieren, da
      aktuelle Updates zu einem vom Benutzer bestimmten Zeitpunkt
      herunterlädt.  Zudem ist es einfach, die Prozedur auf bestimmte
      Dateien oder Verzeichnisse zu beschränken.  Die angeforderten
      Updates werden zur Laufzeit auf dem Server generiert.  Die
      Aktualisierung der Quellen wird in <xref linkend="svn"/>
      beschrieben.</para>

    <para>Wenn ein Benutzer unabsichtlich Teile des Archivs löscht,
      wird das von <application>Subversion</application> erkannt und
      bei der nächsten Aktualisierung repariert.</para>
  </sect1>

  <sect1 xml:id="makeworld">
    <title>Das Basissystem neu bauen</title>

    <indexterm>
      <primary>Bau des Basissystems</primary>
    </indexterm>

    <para>Sobald der lokalen Quellbaum mit einer bestimmten &os;
      Version, z.B. &os.stable; oder &os.current; synchronisiert
      wurde, kann dieser dazu benutzt werden das System neu zu
      bauen.  Dieser Prozess wird auch als
      <quote>die Welt neu bauen</quote> bezeichnet.</para>

    <para><emphasis>Bevor</emphasis> das System neu gebaut wird,
      müssen die folgende Aufgaben erledigt werden:</para>

    <procedure>
      <title>Führen Sie diese Aufgaben aus, <emphasis>bevor</emphasis>
	das System neu gebaut wird</title>

      <step>
	<para>Sichern Sie alle wichtigen Daten auf ein anderes System
	  oder auf Wechselmedien und überprüfen Sie die Integrität der
	  Sicherungskopie.  Zudem sollten Sie bootfähige
	  Installationsmedien zur Hand haben.  Es kann nicht oft genug
	  betont werden, wie wichtig es ist, vor dem Neubau des
	  Systems eine Sicherung zu machen.  Während der Neubau des
	  Systems eine einfache Aufgabe ist, wird es zwangsläufig
	  einmal vorkommen, dass Fehler im Quellcode dazu führen, dass
	  das System nicht mehr bootet.  Wahrscheinlich wird die
	  Sicherungskopie nicht benötigt, aber gehen Sie auf Nummer
	  sicher!</para>
      </step>

      <step>
	<indexterm><primary>Mailingliste</primary></indexterm>
	<para>Lesen Sie die neuesten Einträge in &a.stable; oder
	  &a.current;, je nachdem welchen Zweig Sie folgen.
	  Informieren Sie sich über bekannte Probleme und welche
	  Systeme davon betroffen sind.  Wenn ein Problem für den
	  von Ihnen synchronisierten Code besteht, warten Sie auf
	  eine <quote>all clear</quote>-Nachricht, die besagt, dass
	  das Problem behoben wurde.  Synchronisieren Sie dann die
	  Quellen neu um sicherzustellen, dass die lokale Version
	  die benötigten Korrekturen hat.</para>
      </step>

      <step>
	<para>Lesen Sie <filename>/usr/src/UPDATING</filename> für
	  zusätzliche Aufgaben, die für diese Version des Quellcodes
	  notwendig sind.  Diese Datei enthält wichtige Informationen
	  über potentielle Probleme.  Gegebenenfalls müssen einige
	  Kommandos in einer bestimmten Reihenfolge ausgeführt werden.
	  Manche Aktualisierungen erfordern bestimmte zusätzliche
	  Schritte, die ausgeführt werden müssen, bevor das System neu
	  gebaut wird, wie beispielsweise das umbenennen oder löschen
	  von bestimmten Dateien.  Diese Aufgaben sind am Ende der
	  Datei aufgeführt.  Die Anweisungen in
	  <filename>UPDATING</filename> sind aktueller als die in
	  diesem Handbuch.  Im Zweifelsfall folgen Sie bitte den
	  Anweisungen aus <filename>UPDATING</filename>.</para>
      </step>
    </procedure>

    <warning>
      <title>Verwenden Sie nicht <command>make world</command></title>

      <para>Einige ältere Dokumentationen empfehlen
	<command>make world</command> für den Neubau.
	Das Kommando überspringt jedoch wichtige Schritte und sollte
	nur von Experten verwendet werden.  In fast allen Fällen ist
	<command>make world</command> falsch.  Benutzen Sie
	stattdessen die nachstehende Anleitung.</para>
    </warning>

    <sect2 xml:id="canonical-build">
      <title>Übersicht</title>

      <para>Dieser Prozess geht davon aus, dass ein System von einer
	älteren Version von &os; auf eine neuere Version aktualisiert
	wird.  Der Quellcode für die neue Version wurde nach den
	Anweisungen in <xref linkend="synching"/>
	synchronisiert.</para>

      <para>Das Basissystem enthält den &os;-Kernel, die
	zentralen Binärdateien, Bibliotheken und Entwicklerdateien
	sowie einen integrierten Compiler.  Die Reihenfolge, in der
	diese Komponenten gebaut werden, ist wichtig.</para>

      <para>Beispielsweise könnte der alte Compiler aufgrund von
	Fehlern nicht in der Lage sein, den neuen Kernel zu
	übersetzen.  Da der neue Kernel mit dem neuen Compiler
	übersetzt wird, muss der neue Compiler gebaut, aber nicht
	notwendigerweise <emphasis>installiert</emphasis> werden,
	bevor der neue Kernel gebaut wird.</para>

      <para>Das neue Basissystem ist eventuell auf neue Funktionen des
	Kernels angewiesen.  Aus diesem Grund muss der neue Kernel
	installiert sein, bevor das neue Basissystem installiert
	wird.</para>

      <para>Das alte Basissystem wird möglicherweise nicht korrekt mit
	dem neuen Kernel funktionieren, weshalb das neue Basissystem
	sofort nach der Installation des neuen Kernels installiert
	werden muss.</para>

      <para>Manche Änderungen an der Konfiguration müssen erledigt
	worden sein, bevor das neue Basissystem installiert wird,
	jedoch können andere die Funktionalität des alten Basissystems
	beeinträchtigen.  Aus diesem Grund sind zwei verschiedene
	Schritte notwendig, um eine Aktualisierung der Konfiguration
	durchzuführen.  Der Aktualisierungsprozess ersetzt zum
	Großteil Dateien oder fügt neue hinzu, bestehende Dateien
	werden nicht gelöscht.  Da dieser Prozess Probleme verursachen
	kann, werden in <filename>/usr/src/UPDATING</filename>
	gegebenenfalls Dateien aufgelistet, die manuell entfernt
	werden müssen.</para>

      <para>Diese Bedenken haben zu einer empfohlenen
	Reihenfolge bei der Aktualisierung geführt, die im folgenden
	Prozess beschrieben wird.</para>

      <note>
	<para>Es ist ratsam, die Ausgaben von <command>make</command>
	  in einer Datei zu sichern.  Wenn etwas schief geht, kann
	  eine Kopie der Fehlermeldung zu einer der &os;-Mailinglisten
	  gesendet werden.</para>

	<para>Dazu können Sie einfach <command>script</command>
	  benutzen, dem Sie beim Aufruf als Parameter den Dateinamen
	  für die Ausgaben mitgeben.  Sichern Sie die Ausgaben nicht
	  nach <filename>/tmp</filename>, da dessen Inhalt beim
	  nächsten Neustart vielleicht verloren geht.  Ein besserer
	  Platz ist <filename>/var/tmp</filename>.  Setzen Sie dieses
	  Kommando unmittelbar vor dem Neubau ab und geben Sie
	  <userinput>exit</userinput> ein, wenn der Bau abgeschlossen
	  ist:</para>

	<screen>&prompt.root; <userinput>script <replaceable>/var/tmp/mw.out</replaceable></userinput>
Script started, output file is /var/tmp/mw.out</screen>
      </note>

      <procedure>
	<title>Zusammenfassung des Aktualisierungsprozesses</title>

	<para>Die verwendeten Kommandos sollten in der hier
	  angegebenen Reihenfolge ausgeführt werden.  Die Funktionen
	  der einzelnen Kommandos werden in diesem Abschnitt
	  beschrieben.</para>

	<step>
	  <para>Wenn der Bauprozess bereits einmal auf diesem
	    System durchgeführt wurde, existiert vielleicht noch eine
	    Kopie davon in <filename>/usr/obj</filename>.  Um den
	    neuen Bauprozess zu beschleunigen und Ärger aufgrund von
	    Abhängigkeiten zu vermeiden, kann dieses Verzeichnis
	    entfernt werden:</para>

	  <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/*</userinput>
&prompt.root; <userinput>rm -rf /usr/obj</userinput></screen>
	</step>

	<step>
	  <para>Übersetzen Sie zuerst den neuen Compiler und
	    ein paar damit zusammenhängende Werkzeuge.  Verwenden Sie
	    dann den neuen Compiler, um den Rest des Basissystems zu
	    erstellen.  Das Ergebnis wird in
	    <filename>/usr/obj</filename> abgelegt.</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput></screen>
	</step>

	<step>
	  <para>Benutzen Sie den neuen Compiler aus
	    <filename>/usr/obj</filename>, um sich vor falschen
	    Compiler-Kernel-Kombinationen abzusichern.  Dies ist
	    notwendig, da sich einige Datenstrukturen geändert haben
	    könnten und Programme wie &man.ps.1; und &man.top.1; nur
	    mit einem Kernel zusammen arbeiten, der auch zu dem
	    entsprechenden Quellcode passt.</para>

	  <screen>&prompt.root; <userinput>make buildkernel</userinput></screen>
	</step>

	<step>
	  <para>Installieren Sie den neuen Kernel und die
	    Kernelmodule, damit Sie den frisch aktualisierten Kernel
	    starten können.  Wenn <varname>kern.securelevel</varname>
	    einen Wert größer als <literal>1</literal> besitzt
	    <emphasis>und</emphasis> der Kernel mit
	    <literal>noschg</literal> oder ähnlichen Optionen
	    geschützt ist, müssen Sie zuerst in den Single-User-Modus
	    wechseln.  Andernfalls läuft dieses Kommando problemlos im
	    Mehrbenutzermodus.  Weitere Informationen über
	    <varname>kern.securelevel</varname> finden Sie in
	    &man.init.8;.  Optionen, die auf Dateien gesetzt werden
	    können, werden in &man.chflags.1; detailliert
	    erläutert.</para>

	  <screen>&prompt.root; <userinput>make installkernel</userinput></screen>
	</step>

	<step>
	  <para>Starten Sie das System in den Single-User-Modus, damit
	    Probleme mit der Aktualisierung von Programmen, die
	    bereits gestartet sind, minimiert werden.  Ebenso
	    minimiert dieser Modus Probleme, die mit der Verwendung
	    des alten Basissystems und des neuen Kernels zu tun
	    haben.</para>

	  <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

	  <para>Führen Sie folgende Befehle im Single-User-Modus aus,
	    wenn das System mit einem
	    <acronym>UFS</acronym>-Dateisystem formatiert ist:</para>

	  <screen>&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

	  <para>Wenn das System mit <acronym>ZFS</acronym> formatiert
	    ist, führen Sie stattdessen folgende Befehle aus.  In
	    diesem Beispiel ist der Name des Pools
	    <literal>zroot</literal>:</para>

	  <screen>&prompt.root; <userinput>zfs set readonly=off zroot</userinput>
&prompt.root; <userinput>zfs mount -a</userinput></screen>
	</step>

	<step>
	  <para>Optional: Wenn eine andere Tastaturbelegung als
	    US-Englisch gewünscht wird, kann diese mit &man.kbdmap.1;
	    angepasst werden:</para>

	  <screen>&prompt.root; <userinput>kbdmap</userinput></screen>
	</step>

	<step>
	  <para>Führen Sie folgenden Befehl aus, wenn die
	    <acronym>CMOS</acronym>-Uhr auf die lokale Zeit
	    eingestellt ist (dies ist der Fall, wenn die Ausgabe von
	    &man.date.1; nicht die richtige Zeit anzeigt):</para>

	  <screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>
	</step>

	<step>
	  <para>Bei der Aktualisierung des Basissystems werden
	    bestimmte Verzeichnisse, wie <filename>/etc</filename>,
	    <filename>/var</filename> und <filename>/usr</filename>
	    ausgelassen.  Im nächsten Schritt werden ein paar
	    Konfigurationsdateien zur Vorbereitung für das neue
	    Basissystem aktualisiert.  Der folgende Befehl
	    aktualisiert lediglich Dateien, die für das Gelingen von
	    <buildtarget>installworld</buildtarget> unerlässlich sind.
	    Beispielsweise können neue Gruppen, Systembenutzerkonten,
	    oder neue Startskripten erstellt werden, die seit der
	    letzten Aktualisierung hinzugefügt wurden.  Dieser Schritt
	    ist notwendig, damit
	    <buildtarget>installworld</buildtarget> in der Lage ist,
	    die neuen Konten, Gruppen und Skripten zu verwenden.
	    Weitere Informationen zu diesem Befehl finden Sie in
	    <xref linkend="mergemaster"/>:</para>

	  <screen>&prompt.root; <userinput>mergemaster -p</userinput></screen>
	</step>

	<step>
	  <para>Installieren Sie das neue Basissystem und die
	    Systemdateien aus <filename>/usr/obj</filename>:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>
	</step>

	<step>
	  <para>Aktualisieren Sie die verbleibenden
	    Konfigurationsdateien:</para>

	  <screen>&prompt.root; <userinput>mergemaster -iF</userinput></screen>
	</step>

	<step>
	  <para>Löschen Sie veraltete Dateien.  Dieser Schritt
	    ist wichtig, da alte Dateien manchmal Probleme bereiten,
	    falls sie nicht entfernt werden:</para>

	  <screen>&prompt.root; <userinput>make delete-old</userinput></screen>
	</step>

	<step>
	  <para>Nun wird ein Neustart benötigt, um den neuen Kernel
	    und das neue Basissystem zu laden:</para>

	  <screen>&prompt.root; <userinput>reboot</userinput></screen>
	</step>

	<step>
	  <para>Stellen Sie sicher, dass alle Ports neu gebaut wurden,
	    bevor die alten Bibliotheken entfernt werden.  Folgen
	    Sie dazu den Anweisungen aus <xref
	      linkend="ports-upgrading"/>.  Entfernen Sie anschließend
	    alle veralteten Bibliotheken um Konflikte mit den neuen
	    Bibliotheken zu vermeiden.  Weitere Informationen zu
	    diesem Schritt finden Sie
	    in <xref linkend="make-delete-old"/>.</para>

	  <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>
	</step>
      </procedure>

      <indexterm><primary>Single-User Modus</primary></indexterm>

      <para>Wenn Sie eine Ausfallzeit des Systems in Kauf nehmen
	können, sollten sie das System im Single-User Modus
	bauen.  Die Neuinstallation des Systems verändert viele
	wichtige Systemdateien, Systemwerkzeuge, Bibliotheken und
	Include-Dateien.  Ändern Sie diese Dateien auf einem laufenden
	System, insbesondere mit aktiven Nutzern, kann dies große
	Probleme verursachen.</para>
    </sect2>

    <sect2 xml:id="src-updating">
      <title>Konfigurationsdateien</title>

      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Der Bauprozess verwendet verschiedene
	Konfigurationsdateien.</para>

      <para>Das <filename>Makefile</filename> in
	<filename>/usr/src</filename> legt fest, wie die Programme,
	aus denen &os; besteht, zu bauen sind und in welcher
	Reihenfolge diese zu bauen sind.</para>

      <para>Die verfügbaren Optionen für <command>make</command>
	werden in &man.make.conf.5; und
	<filename>/usr/share/examples/etc/make.conf</filename>
	beschrieben.  Jede Option in
	<filename>/etc/make.conf</filename> beeinflusst das Verhalten
	von <command>make</command> beim Bau von Programmen.  Die in
	<filename>/etc/make.conf</filename> gesetzten Optionen wirken
	sich bei jedem Aufruf von <command>make</command> aus,
	einschließlich beim Bau von Programmen aus der Ports-Sammlung,
	vom Benutzer geschriebene C-Programme oder beim Bau des
	&os;-Betriebssystems.  Änderungen an einigen Einstellungen
	können weitreichende und unerwartete Auswirkungen nach sich
	ziehen.  Lesen Sie die Kommentare in diesen beiden Ressourcen
	und beachten Sie, dass die Standardwerte aus einer Kombination
	von Leistung und Sicherheit gewählt wurden.</para>

      <indexterm>
	<primary><filename>/etc/src.conf</filename></primary>
      </indexterm>

      <para>Der Bau des Betriebssystems aus dem Quellcode wird von
	<filename>/etc/src.conf</filename> kontrolliert.  Im Gegensatz
	zu <filename>/etc/make.conf</filename> greifen die Optionen in
	<filename>/etc/src.conf</filename> nur dann, wenn das
	&os; Betriebssystem selbst gebaut wird.  Die vielen Optionen
	für diese Datei werden in &man.src.conf.5; beschrieben.
	Seien Sie vorsichtig mit dem Entfernen von scheinbar nicht
	mehr benötigten Kernelmodulen und Optionen.  Manchmal gibt es
	unerwartete oder subtile Wechselwirkungen.</para>
    </sect2>

    <sect2 xml:id="make-buildworld">
      <title>Variablen und Ziele</title>

      <para>Ein typischer Aufruf von <command>make</command> sieht
	wie folgt aus:</para>

      <screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

      <para>In diesem Beispiel ist
	<option>-<replaceable>x</replaceable></option> eine Option,
	die an <command>make</command> übergeben wird.  Eine Liste
	gültiger Optionen finden Sie in &man.make.1;.</para>

      <para>Mit
	<option>-D<replaceable>VARIABLE</replaceable></option>
	setzen Sie eine Variable.  Das Verhalten der
	<filename>Makefile</filename> wird von Variablen bestimmt.
	Diese sind etweder in <filename>/etc/make.conf</filename>
	eingetragen, oder können an <command>make</command> übergeben
	werden.  Das folgende Beispiel setzt eine Variable, die
	verhindert, dass die <quote>profiled</quote> Bibliotheken
	gebaut werden:</para>

      <screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>target</replaceable></userinput></screen>

      <para>Dieser Aufruf entspricht dem folgenden Eintrag in
	<filename>/etc/make.conf</filename>:</para>

      <programlisting>NO_PROFILE=    true     #    Avoid compiling profiled libraries</programlisting>

      <para>Das <quote>Ziel</quote> sagt <command>make</command>
	was zu tun ist und das <filename>Makefile</filename>
	definiert die verfügbaren Ziele.  Einige Ziele werden
	verwendet, um den Bauprozess in eine Reihe von
	Einzelschritten zu unterteilen.</para>

      <para>Über separate Optionen zu verfügen, ist aus mehreren
	Gründen nützlich.  Erstens erlaubt dies einen Bauprozess,
	der die Komponenten des laufenden Systems nicht
	beeinträchtigt.  Deswegen können Sie
	<command>buildworld</command> gefahrlos im Mehrbenutzermodus
	laufen lassen.  Die Installation mit
	<buildtarget>installworld</buildtarget> sollte aber immer
	noch im Single-User-Modus erfolgen.</para>

      <para>Zweitens kann, wie in <xref linkend="small-lan"/>
	beschrieeben, <acronym>NFS</acronym> benutzt werden, um
	mehrere Maschinen in einem Netzwerk zu aktualisieren.</para>

      <para>Mit <option>-j</option> können Sie
	<command>make</command> anweisen, mehrere Prozesse zu
	starten.  Da der Übersetzungsprozess
	hauptsächlich von <acronym>I/O</acronym> statt der
	<acronym>CPU</acronym> bestimmt wird, ist diese Option für
	Einprozessor- und Mehrprozessor-Systeme nützlich.</para>

      <para>Auf einem typischen Einprozessor-System können Sie den
	folgenden Befehl eingeben, um bis zu vier Prozesse
	gleichzeitig laufen zu lassen.  Erfahrungsberichte aus den
	Mailinglisten zeigen, dass dieser Aufruf typischerweise den
	besten Geschwindigkeitsgewinn bringt:</para>

      <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

      <para>Wenn Sie ein Mehrprozessor-System besitzen, probieren
	Sie Werte zwischen <literal>6</literal> und
	<literal>10</literal> aus.</para>

      <indexterm>
	<primary>Bau des Basissystems</primary>
	<secondary>Laufzeiten</secondary>
      </indexterm>

      <note>
	<para>Wenn mit <command>make buildworld</command> Variablen
	  verwendet werden, müssen dieselben Variablen auch bei
	  <command>make installworld</command> angegeben werden.
	  Allerdings darf <option>-j</option> zusammen mit
	  <buildtarget>installworld</buildtarget>
	  <emphasis>nicht</emphasis> benutzt werden.</para>

	<para>Haben Sie zum Bauen die folgende Kommandozeile
	  verwendet:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>dann installieren Sie das Ergebnis mit:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>Andernfalls würde das System bei der Installation
	  versuchen, die <quote>profiled</quote> Bibliotheken, die
	  aber gar nicht gebaut wurden, zu installieren.</para>
      </note>
    </sect2>

    <sect2 xml:id="mergemaster">
      <info>
	<title>Abgleich der Konfigurationsdateien</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>&os; enthält das &man.mergemaster.8; Bourne-Shell
	Skript, welches dabei behilflich ist die Unterschiede zwischen
	den Konfigurationsdateien in <filename>/etc</filename> und
	denen unter <filename>/usr/src/etc</filename> zu finden.
	Dies ist der empfohlene Weg, die Systemkonfiguration mit dem
	Quellbaum abzugleichen.</para>

      <para>Es ist ratsam, zuerst das bestehende
	<filename>/etc</filename> an einen sicheren Ort zu
	kopieren.  Mit <option>-R</option> wird rekursiv kopiert und
	<option>-p</option> erhält die Zugriffszeiten und Eigentümer
	der Dateien:</para>

      <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

      <para>Beim Aufruf wird <command>mergemaster</command>
	ausgehend von <filename>/</filename> einen virtuellen
	Root-Baum aufbauen und darin die neuen Konfigurationsdateien
	ablegen.
	Diese Dateien werden dann mit den auf dem System
	installierten Dateien verglichen.  Unterschiede zwischen den
	Dateien werden im &man.diff.1;-Format dargestellt.  Neue
	oder geänderte Zeilen werden mit <option>+</option>
	gekennzeichnet.  Zeilen die gelöscht oder ersetzt werden,
	sind mit <option>-</option> gekennzeichnet.  Das
	Anzeigeformat wird in &man.diff.1; genauer erklärt.</para>

      <para>Als nächstes zeigt <command>mergemaster</command> jede
	geänderte Datei an und Sie haben die Wahl, die neue Datei
	(auch temporäre Datei genannt) zu löschen, sie unverändert
	zu installieren, den Inhalt der neuen Datei mit dem Inhalt
	der alten Datei abzugleichen, oder die Ausgabe noch einmal
	zu sehen.</para>

      <para>Wenn Sie die temporäre Datei löschen, geht
	<command>mergemaster</command> davon aus, dass Sie die
	aktuelle Datei unverändert behalten möchten.  Die Auswahl
	dieser Option wird nicht empfohlen.  Durch die Eingabe von
	<keycap>?</keycap> können Sie jederzeit die Hilfe am Prompt
	von <command>mergemaster</command> aufrufen.  Wenn Sie eine
	Datei überspringen, wird <command>mergemaster</command>
	diese am Ende erneut präsentieren.</para>

      <para>Wenn Sie die temporäre Datei installieren, wird die
	aktuelle Datei mit der neuen Datei überschrieben.  Sie
	sollten alle unveränderten Konfigurationsdateien auf diese
	Weise aktualisieren.</para>

      <para>Wenn Sie sich entschließen den Inhalt beider Dateien
	abzugleichen, wird ein Texteditor aufgerufen, in dem Sie
	beide Dateien nebeneinander betrachten können.  Mit der
	Taste <keycap>l</keycap> übernehmen Sie die aktuelle Zeile
	der links dargestellten Datei, mit der Taste
	<keycap>r</keycap> übernehmen Sie die Zeile der rechts
	dargestellten Datei.  Das Ergebnis ist eine Datei, die aus
	Teilen der beiden ursprünglichen Dateien besteht und
	installiert werden kann.  Dieses Verfahren wird gewöhnlich
	bei veränderten Dateien genutzt.</para>

      <para>Haben Sie sich entschieden die Differenzen noch einmal
	anzuzeigen, werden nochmals die Unterschiede in beiden
	Dateien angezeigt.</para>

      <para>Wenn <command>mergemaster</command> alle Systemdateien
	abgearbeitet hat, werden weitere Optionen abgefragt.  Sie
	werden unter Umständen gefragt, ob die Passwort-Datei neu
	gebaut werden soll.  Am Ende haben Sie die Möglichkeit, die
	restlichen temporären Dateien zu löschen.</para>

	<!--
	<para>Wenn Sie den Abgleich lieber selbst ausführen wollen,
	  beachten Sie bitte, dass Sie nicht einfach die Dateien aus
	  <filename>/usr/src/etc</filename> nach <filename>/etc</filename>
	  kopieren können.  Einige dieser Dateien müssen zuerst
	  <emphasis>installiert</emphasis> werden, bevor sie benutzt werden
	  können.  Das liegt daran, dass
	  <filename>/usr/src/etc</filename> keine exakte Kopie von
	  <filename>/etc</filename> ist.  Zudem gibt es Dateien, die sich
	  in <filename>/etc</filename> befinden aber nicht in
	  <filename>/usr/src/etc</filename>.</para>

	<para>Am einfachsten ist es, wenn Sie die neuen Dateien in ein
	  temporäres Verzeichnis installieren und sie nacheinander auf
	  Differenzen zu den bestehenden Dateien durchsehen.</para>

	<warning>
	  <title>Sichern Sie die Inhalte von <filename>/etc</filename></title>

	  <para>Es wird empfohlen, zuerst das bestehende
	    <filename>/etc</filename> an einen sicheren Ort zu
	    kopieren:</para>

	    <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	    <para>Mit <option>-R</option> wird rekursiv kopiert und
	      <option>-p</option> erhält die Attribute der kopierten
	      Dateien, wie Zugriffszeiten und Eigentümer.</para>
	</warning>

	<para>Erstellen Sie ein temporäres Verzeichnis für
	  die Installation der neuen Dateien in
	  <filename>/etc</filename>.</para>

        <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

	<para>Die obigen Kommandos bauen die nötige
	  Verzeichnisstruktur auf und installieren die neuen Dateien in
	  diese Struktur.  Unterhalb von <filename>/var/tmp/root</filename>
	  wurden einige leere Verzeichnisse angelegt, die Sie am besten wie
	  folgt entfernen:</para>

        <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

	<para>Dadurch werden alle leeren Verzeichnisse entfernt.  Um
	  die Warnungen über nicht leere Verzeichnisse zu
	  unterdrücken, wurde die Standardfehlerausgabe nach
	  <filename>/dev/null</filename> umgeleitet.</para>

	<para><filename>/var/tmp/root</filename> enthält nun alle
	  Dateien, die unterhalb von <filename>/</filename>
	  installiert werden sollten.  Sie müssen nun jede dieser
	  Dateien mit den schon existierenden Dateien des Systems
	  vergleichen.</para>

	<para>Einige der installierten Dateien unter
	  <filename>/var/tmp/root</filename> beginnen mit einem
	  <quote>.</quote>.  Verwenden Sie <command>ls -a</command> um
	  sicherzustellen, dass Sie alle derartigen Dateien
	  finden.</para>

	<para>Benutzen Sie &man.diff.1;, um zwei Dateien zu
	  vergleichen:</para>

        <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

	<para>Dieses Kommando zeigt die Unterschiede zwischen der
	  installierten Version von <filename>/etc/shells</filename>
	  und der neuen Version in
	  <filename>/var/tmp/root/etc/shells</filename>.  Entscheiden
	  Sie anhand der Unterschiede, ob Sie beide Dateien
	  abgleichen, oder die alte Version durch die neue Version
	  ersetzen wollen.</para>

	<tip>
	  <title>Versehen Sie das temporäre Verzeichnis
	    <filename>/var/tmp/root</filename> mit einem
	    Zeitstempel</title>

	  <para>Wenn das System oft neu gebaut wird, muss auch
	    <filename>/etc</filename> genauso oft aktualisiert werden.
	    Dies kann mit der Zeit ein bisschen mühsam werden.</para>

	  <para>Um diesen Prozess zu beschleunigen, behalten Sie
	    eine Kopie der Dateien, die zuletzt nach
	    <filename>/etc</filename> installiert wurden.</para>

	  <procedure>
	    <step>
	      <para>Folgen Sie der normalen Prozedur um das System zu
	        bauen.  Wenn Sie <filename>/etc</filename> und die anderen
		Verzeichnisse aktualisieren wollen, geben Sie dem
		temporären Verzeichnis einen Namen, der das aktuelle
		Datum enthält.</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-20130214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-20130214 \
    distrib-dirs distribution</userinput></screen>
	    </step>

	    <step>
	      <para>Gleichen Sie die Änderungen entsprechend der
		Anleitung von oben ab.  Wenn Sie fertig sind,
		entfernen Sie das Verzeichnis
		<filename>/var/tmp/root-20130214</filename>
		<emphasis>nicht</emphasis>.</para>
	    </step>

	    <step>
	      <para>Nachdem die neuen Quellen heruntergeladen und
		gebaut haben, folgen Sie Schritt 1.  Erstellen Sie
		ein neues Verzeichnis mit einem aktuellen Datum.
		Dieses Beispiel verwendet
		<filename>/var/tmp/root-20130221</filename>.</para>
	    </step>

	    <step>
	      <para>Vergleichen Sie die Unterschiede, die sich in
		einer Woche ergeben haben, indem Sie &man.diff.1;
		rekursiv anwenden:</para>

	      <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-20130214 root-20130221</userinput></screen>

	      <para>Üblicherweise sind diese Differenzen kleiner, als
		die Differenzen zwischen
		<filename>/var/tmp/root-20130221/etc</filename> und
		<filename>/etc</filename>.  Da die angezeigten Differenzen
		kleiner sind, ist es jetzt einfacher den Abgleich der
		Dateien in <filename>/etc</filename>
		durchzuführen.</para>
	    </step>

	    <step>
	      <para>Wenn Sie fertig sind, können Sie das ältere der
		beiden  <filename>/var/tmp/root-*</filename>
		Verzeichnisse entfernen:</para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-20130214</userinput></screen>
	    </step>

	    <step>
	      <para>Wiederholen Sie diesen Prozess jedes Mal wenn Sie
		Dateien in <filename>/etc</filename> abgleichen
		müssen.</para>
	    </step>
	  </procedure>

	  <para>Benutzen Sie &man.date.1;, um die Verzeichnisnamen
	    automatisch zu erzeugen:</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
	-->
    </sect2>

    <sect2 xml:id="make-delete-old">
      <info>
	<title>Veraltete Dateien und Bibliotheken löschen</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Anton</firstname>
	      <surname>Shterenlikht</surname>
	    </personname>
	    <contrib>Basiert auf Notizen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>Veraltete Dateien und Verzeichnisse löschen</primary>
      </indexterm>

      <para>Aufgrund der ständigen Weiterentwicklung von &os; kann es
	dazu kommen, dass Dateien und deren Inhalte obsolet werden,
	weil deren Funktionalität entweder in anderen Dateien
	implementiert wurde, sich die Versionsnummer der Bibliothek
	geändert hat oder die Funktion aus dem System entfernt wurde.
	Dies kann sowohl Dateien und Verzeichnisse, aber auch
	Bibliotheken betreffen.  Diese veralteten Dateien,
	Verzeichnisse und Bibliotheken sollten
	daher entfernt werden, wenn das System aktualisiert wird.  Die
	stellt sicher, dass das System von nicht mehr
	benötigten Dateien befreit wird.  Falls die obsolete
	Bibliothek Sicherheits- oder Stabilitätsprobleme aufweist,
	sollte das System ebenfalls aktualisiert werden, um das System
	sicher zu halten und/oder durch die fehlerhafte Bibliothek
	verursachte Systemabstürze zu vermeiden.  Veraltete Dateien,
	Verzeichnisse und Bibliotheken sind in
	<filename>/usr/src/ObsoleteFiles.inc</filename> aufgelistet.
	Verwenden Sie die folgenden Anweisungen, um diese Dateien
	während der Systemaktualisierung zu entfernen.</para>

      <para>Nachdem Sie <command>make installworld</command> sowie
	<command>mergemaster</command> erfolgreich ausgeführt haben,
	überprüfen Sie das System auf veraltete Dateien und
	Bibliotheken:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make check-old</userinput></screen>

      <para>Werden dabei veraltete Dateien gefunden, können diese
	mit dem folgenden Kommando entfernt werden:</para>

      <screen>&prompt.root; <userinput>make delete-old</userinput></screen>

      <para>Bei jeder Datei wird nachgefragt, ob diese wirklich
	gelöscht werden soll.  Es ist aber auch möglich, alle
	Dateien automatisch löschen zu lassen.  Dies erreichen Sie,
	indem Sie die Umgebungsvariable
	<varname>BATCH_DELETE_OLD_FILES</varname> setzen:</para>

      <screen>&prompt.root; <userinput>make -DBATCH_DELETE_OLD_FILES delete-old</userinput></screen>

      <para>Alternativ können Sie auch <command>yes</command>
	einsetzen und somit die Antwort <literal>yes</literal>
	an die einzelnen Abfragen weiterreichen:</para>

      <screen>&prompt.root; <userinput>yes | make delete-old</userinput></screen>

      <warning>
	<title>Warnung</title>

	<para>Das Löschen veralteter Dateien kann dazu führen, dass
	  Programme, die auf diese Dateien angewiesen sind, nicht mehr
	  funktionieren.  Dies gilt insbesondere für veraltete
	  Bibliotheken.  In den meisten Fällen ist es dann notwendig,
	  Programme, Ports und Bibliotheken, welche die veraltete
	  Bibliothek verwenden, neu zu bauen, bevor Sie den Befehl
	  <command>make delete-old-libs</command> ausführen.</para>
      </warning>

      <para>Die Bibliothek-Abhängigkeiten können mit
	<package>sysutils/libchk</package> und
	<package>sysutils/bsdadminscripts</package> geprüft
	werden.</para>

      <para>Veraltete Bibliotheken können zu Konflikten mit neueren
	Bibliotheken führen und beispielsweise folgende
	Meldungen verursachen:</para>

      <screen>/usr/bin/ld: warning: libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so, may conflict with librpcsvc.so.5</screen>

      <para>Um diese Probleme zu lösen, müssen Sie zuerst
	herausfinden, welcher Port die Bibliothek installiert
	hat:</para>

      <screen>&prompt.root; <userinput>pkg which /usr/local/lib/libtiff.so</userinput>
/usr/local/lib/libtiff.so was installed by package tiff-3.9.4
&prompt.root; <userinput>pkg which /usr/local/lib/libXext.so</userinput>
/usr/local/lib/libXext.so was installed by package libXext-1.1.1,1</screen>

      <para>Danach deinstallieren Sie den Port und bauen ihn neu, um
	ihn danach erneut zu installieren.  Dieser Vorgang kann durch
	den Einsatz von <package>ports-mgmt/portmaster</package>
	automatisiert werden.  Nachdem alle Ports neu gebaut wurden
	und keine alten Bibliotheken mehr verwenden werden,
	können Sie die alten Bibliotheken endgültig entfernen:</para>

      <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>

      <para>Falls etwas schief geht, ist es leicht einen Teil des
	Systems wiederherzustellen.  Wenn beispielsweise während des
	Updates oder Abgleichs <filename>/etc/magic</filename> aus
	Versehen gelöscht wurde, wird <command>file</command> nicht
	mehr funktionieren.  In diesem Fall kann das Problem mit dem
	folgenden Kommando behoben werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-questions">
      <title>Häufige Fragen</title>

      <variablelist>
	<varlistentry>
	  <term>Muss ich wirklich immer alles neu bauen, wenn sich
	    etwas geändert hat?</term>

	  <listitem>
	    <para>Das hängt von den Änderungen ab.  Es lohnt
	      wahrscheinlich nicht, alles neu zu bauen, wenn sich bei
	      einem <application>svn</application>-Lauf nur die
	      folgenden Dateien geändert haben:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>In diesem Fall können Sie in die entsprechenden
	      Unterverzeichnisse wechseln und dort
	      <command>make all install</command> ausführen.  Wenn
	      sich allerdings etwas Wichtiges, wie
	      <filename>src/lib/libc/stdlib</filename>, geändert hat,
	      sollten Sie die Welt neu bauen.</para>

	    <para>Einige Benutzer sind vielleicht damit zufrieden, das
	      System alle zwei Wochen neu zu bauen und in der
	      Zwischenzeit die anfallenden Änderungen zu sammeln.
	      Wenn Sie sich zutrauen, alle Abhängigkeiten zu erkennen,
	      bauen Sie vielleicht auch nur die geänderten Sachen neu.
	      Das hängt auch noch davon ab, wie oft Sie ein Update
	      durchführen wollen und ob Sie &os.stable; oder
	      &os.current; benutzen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Warum bricht der Bau mit vielen Signal
	      11<indexterm><primary>signal 11</primary></indexterm>
	      Fehlern (oder anderen Signalnummern) ab?</term>

	  <listitem>
	    <para>Für gewöhnlich zeigen diese Meldungen Hardwarefehler
	      an.  Ein Neubau der Welt ist ein guter Belastungstest
	      für die Hardware und zeigt oft Probleme mit dem Speicher
	      auf.  Es liegt garantiert ein Hardwarefehler vor, wenn
	      <command>make</command> neu gestartet wird und an einer
	      anderen Stelle abbricht.</para>

	    <para>In diesem Fall können nur einzelne Komponenten des
	      Systems, angefangen mit dem <acronym>RAM</acronym>,
	      getauscht werden, um zu bestimmen, welche Komponente den
	      Fehler verursacht.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Kann <filename>/usr/obj</filename> entfernt werden,
	    wenn ich fertig bin?</term>

	  <listitem>
	    <para>In diesem Verzeichnis werden alle Dateien
	      abgelegt, die während der Übersetzungsphase erstellt
	      wurden.  Dieses Verzeichnis wird in einem der ersten
	      Schritte von <command>make buildworld</command>
	      entfernt.  Es macht daher wenig Sinn, dieses Verzeichnis
	      zu behalten.  Zudem wird ungefähr 2&nbsp;GB
	      Plattenspeicher freigegeben, wenn dieses Verzeichnis
	      gelöscht wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Kann ein abgebrochener Bau weitergeführt
	    werden?</term>

	  <listitem>
	    <para>Das hängt davon ab, wieweit der Bauprozess
	      fortgeschritten ist.  Üblicherweise werden durch
	      <command>make buildworld</command> essentielle
	      Werkzeuge und die Systembibliotheken neu erstellt.  Die
	      neu erstellten Werkzeuge und Bibliotheken werden dann
	      benutzt, um sich selbst noch einmal zu bauen, und wieder
	      installiert.  Anschließend wird das Gesamtsystem mit den
	      neu erstellten Systemdateien gebaut.</para>

	    <para>Während der letzten Phase können Sie relativ
	      gefahrlos folgende Kommandos ausführen, ohne dabei
	      die von <command>make buildworld</command> erzeugten
	      Dateien zu löschen:</para>

	    <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Wenn diese Meldung in der Ausgabe von
	      <command>make buildworld</command> erscheint:</para>

	    <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>dann können Sie den Befehl bedenkenlos
	      ausführen.</para>

	    <para>Wenn diese Meldung nicht angezeigt wird, dann ist es
	      besser, noch einmal ganz von Vorne anzufangen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Ist es möglich, den Bauprozess zu
	    beschleunigen?</term>

	  <listitem>
	    <para>Es gibt mehrere Maßnahmen um den Bauprozess zu
	      beschleunigen.  Zum Beispiel kann der gesamte Prozess im
	      Single-User-Modus ausgeführt werden.  Dies verhindert
	      jedoch, dass Benutzer Zugriff auf das System haben, bis
	      der Prozess abgeschlossen ist.</para>

	    <para>Die sorgfältige Planung von Dateisystemen oder die
	      Verwendung von <acronym>ZFS</acronym> können auch einen
	      Unterschied machen.  Sie können erwägen,
	      <filename>/usr/src</filename> und
	      <filename>/usr/obj</filename> auf separate Dateisysteme
	      zu legen.  Wenn möglich, platzieren Sie die Dateisysteme
	      auf separaten Festplatten mit getrennten
	      Platten-Controllern.  Verwenden Sie beim einhängen von
	      <filename>/usr/src</filename> die Option
	      <option>noatime</option>, um die Aktualisierung der
	      Dateizugriffe zu deaktivieren.  Falls
	      <filename>/usr/src</filename> nicht auf einem eigenen
	      Dateisystem liegt, können Sie <filename>/usr</filename>
	      abhängen und mit <option>noatime</option> neu
	      einhängen.</para>

	    <para>Das Dateisystem, in dem sich
	      <filename>/usr/obj</filename> befindet, kann mit
	      <option>async</option> eingehangen werden, so dass
	      Schreibzugriffe auf die Platte asynchron stattfinden.
	      Das heißt ein Schreibzugriff ist sofort beendet, die
	      Daten werden allerdings erst einige Sekunden später
	      geschrieben.  Dadurch können Schreibzugriffe
	      zusammengefasst werden, was einen erheblichen
	      Geschwindigkeitszuwachs mit sich bringen kann.</para>

	    <warning>
	      <para>Beachten Sie, dass dies das Dateisystem anfälliger
		für Fehler macht.  Im Fall eines Stromausfalls besteht
		eine erhöhte Wahrscheinlichkeit, dass das Dateisystem
		beim Start der Maschine zerstört ist.</para>

	      <para>Wenn <filename>/usr/obj</filename> das einzige
		Verzeichnis auf diesem Dateisystem ist, stellt das
		kein Problem dar.  Wenn sich allerdings auf diesem
		Dateisystem noch andere wertvolle Daten befinden,
		stellen Sie sicher, dass Sie über aktuelle Sicherungen
		verfügen.</para>
	    </warning>

	    <para>Deaktivieren Sie den Bau der
	      <quote>profiled</quote>-Bibliotheken, indem Sie
	      <quote>NO_PROFILE=true</quote> in
	      <filename>/etc/make.conf</filename> eintragen.</para>

	    <para>Benutzen Sie <command>make</command> zusammen mit
	      <option>-j<replaceable>n</replaceable></option>, um
	      mehrere Prozesse parallel laufen zu lassen.
	      Für gewöhnlich beschleunigt dies den Bauprozess auf
	      Einprozessor- und Mehrprozessorsystemen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Was mache ich, wenn etwas nicht funktioniert?</term>

	  <listitem>
	    <para>Stellen Sie zuerst sicher, dass sich in der Umgebung
	      keine Reste eines vorherigen Baus befinden:</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Ja, <command>make cleandir</command> muss wirklich
	      zweimal aufgerufen werden.</para>

	    <para>Danach starten Sie den Bauprozess wieder mit
	      <command>make buildworld</command>.</para>

	    <para>Wenn Sie immer noch Probleme haben, schicken Sie die
	      Fehlermeldungen und die Ausgabe von
	      <command>uname -a</command> an die Mailingliste
	      &a.de.questions;.  Bereiten Sie sich darauf vor, weitere
	      Fragen zu der Umgebung zu beantworten.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 xml:id="small-lan">
    <info>
      <title>Installation mehrerer Maschinen</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mike</firstname>
	    <surname>Meyer</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <para>Wenn Sie mehrere Maschinen auf dem gleichen Stand
      halten wollen, ist es eine Verschwendung von
      Ressourcen, die Quellen auf jeder Maschine vorzuhalten und zu
      übersetzen.  Die Lösung dazu ist, eine Maschine den
      Großteil der Arbeit durchführen zu lassen und den anderen
      Maschinen das Ergebnis mit <acronym>NFS</acronym> zur Verfügung
      zu stellen.  Dieser Abschnitt zeigt eine Methode dies zu tun.
      Weitere Informationen zu <acronym>NFS</acronym> finden Sie in
      <xref linkend="network-nfs"/>.</para>

    <para>Stellen Sie zuerst eine Liste der Maschinen zusammen, die
      auf demselben Stand sein sollen.  Wir nennen diese Maschinen die
      <firstterm>Baugruppe</firstterm>.  Jede dieser Maschinen kann
      mit einem eigenen Kernel laufen, doch sind die Programme des
      Userlands auf allen Maschinen gleich.  Wählen Sie aus der
      Baugruppe eine Maschine aus, auf der der Bau durchgeführt wird,
      den <firstterm>Bau-Master</firstterm>.  Dies sollte eine
      Maschine sein, die über die nötigen
      <acronym>CPU</acronym>-Ressourcen für
      <command>make buildworld</command> und
      <command>make installworld</command> verfügt.</para>

    <para>Sie brauchen auch eine <firstterm>Testmaschine</firstterm>,
      auf der Sie die Updates testen, bevor Sie sie in Produktion
      installieren.  Dies <emphasis>muss</emphasis> eine Maschine
      sein, die über einen längeren Zeitraum nicht zur Verfügung
      stehen kann.</para>

    <para>Alle Maschinen der Baugruppe müssen
      <filename>/usr/obj</filename> und
      <filename>/usr/src</filename> über <acronym>NFS</acronym> vom
      Bau-Master an gleichem Ort einhängen.  Wenn Sie mehrere
      Baugruppen haben, sollte sich <filename>/usr/src</filename>
      auf einem Bau-Master befinden und über <acronym>NFS</acronym>
      für den Rest der Maschinen zur Verfügung gestellt
      werden.</para>

    <para>Stellen Sie sicher, dass
      <filename>/etc/make.conf</filename> und
      <filename>/etc/src.conf</filename> auf allen Maschinen einer
      Baugruppe mit der Datei des Bau-Masters übereinstimmt.  Der
      Bau-Master muss jeden Teil des Systems bauen, den irgendeine
      Maschine der Baugruppe benötigt.  Auf dem Bau-Master müssen in
      <filename>/etc/make.conf</filename> alle zu bauenden Kernel mit
      der Variablen <varname>KERNCONF</varname> bekannt gegeben
      werden.  Geben Sie dabei den Kernel des Bau-Masters zuerst an.
      Für jeden zu bauenden Kernel muss auf dem Bau-Master die
      entsprechende Konfigurationsdatei unter
      <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
      abgelegt werden.</para>

    <para>Bauen Sie auf dem Bau-Master, wie in <xref
	linkend="makeworld"/> beschrieben, den Kernel und die
      Welt, installieren Sie aber nichts.  Wechseln Sie auf die
      Testmaschine und installieren Sie den gerade gebauten Kernel.
      Hängen Sie auf der Testmaschine <filename>/usr/src</filename>
      und <filename>/usr/obj</filename> über <acronym>NFS</acronym>
      ein.  Geben Sie dann <command>shutdown now</command> ein, um
      in den Single-User-Modus zu gelangen, von wo aus Sie den neuen
      Kernel und das System installieren.  Lassen Sie anschließend
      <command>mergemaster</command> laufen.  Wenn Sie fertig sind,
      booten Sie die Maschine wieder in den
      Mehrbenutzermodus.</para>

    <para>Nachdem Sie sichergestellt haben, dass die Testmaschine
      einwandfrei funktioniert, wiederholen Sie diese Prozedur für
      jede Maschine in der Baugruppe.</para>

    <para>Dasselbe Verfahren können Sie auch für die
      Ports-Sammlung anwenden.  Zuerst müssen alle Maschinen einer
      Baugruppe <filename>/usr/ports</filename> über
      <acronym>NFS</acronym> zur Verfügung gestellt bekommen.
      Setzen Sie ein Verzeichnis für die Quellen auf, das sich alle
      Maschinen teilen.  Dieses Verzeichnis können Sie in
      <filename>/etc/make.conf</filename> mit der Variablen
      <varname>DISTDIR</varname> angeben.  Das Verzeichnis sollte
      für den Benutzer beschreibbar sein, auf den der Benutzer
      <systemitem class="username">root</systemitem> vom
      <acronym>NFS</acronym> Subsystem abgebildet wird.  Jede
      Maschine sollte noch <varname>WRKDIRPREFIX</varname> auf ein
      lokales Bauverzeichnis setzen.  Wenn Sie vorhaben, Pakete zu
      bauen und zu verteilen, sollten Sie
      <varname>PACKAGES</varname> auf ein Verzeichnis mit den
      gleichen Eigenschaften wie <varname>DISTDIR</varname>
      setzen.</para>
  </sect1>
</chapter>
