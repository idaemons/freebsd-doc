<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/cutting-edge/chapter.sgml,v 1.84 2009/09/29 17:26:09 bcr Exp $
     basiert auf: 1.227
-->

<chapter id="updating-upgrading">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Umstrukturiert und aktualisiert von </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Im Original von </contrib>
      </author>
      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>
    <!-- with feedback from various others -->
    <authorgroup>
      <author>
	<firstname>Martin</firstname>
	<surname>Heinen</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>&os; aktualisieren</title>

  <sect1 id="updating-upgrading-synopsis">
    <title>&Uuml;bersicht</title>

    <para>&os; wird zwischen einzelnen Releases konstant weiter entwickelt.
      Es gibt mehrere einfache M&ouml;glichkeiten, ein System auf dem
      aktuellen Stand der Entwicklung zu halten.  Seien Sie jedoch gewarnt:
      Die neueste Version ist nicht f&uuml;r jeden geeignet!  Dieses
      Kapitel hilft Ihnen bei der Entscheidung, ob Sie mit dem
      Entwicklungssystem Schritt halten oder ein Release verwenden
      wollen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>den Unterschied der beiden Entwicklerversionen
          &os.stable; und &os.current; kennen,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Ihr System mit
          <application>CVSup</application>, <application>CVS</application>
	  oder <application>CTM</application> aktualisieren.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie das komplette Basissystem
	  mit <command>make buildworld</command> neu bauen und
	  installieren.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Ihr Netzwerk richtig konfiguriert haben
	  (<xref linkend="advanced-networking">) und</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Software Dritter installieren
	  (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="updating-upgrading-freebsdupdate">
    <title>FreeBSD Update (noch nicht &uuml;bersetzt)</title>

    <para>Dieser Abschnitt ist noch nicht &uuml;bersetzt.
      Lesen Sie bitte <ulink
      url="&url.books.handbook.en;/updating-upgrading-freebsdupdate.html">
      das Original in englischer Sprache</ulink>.  Wenn Sie helfen
      wollen, dieses Kapitel zu &uuml;bersetzen, senden Sie bitte
      eine E-Mail an die Mailingliste &a.de.translators;.</para>
  </sect1>

  <sect1 id="updating-upgrading-portsnap">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Colin</firstname>
	  <surname>Percival</surname>
	  <contrib>Basierend auf bereitgestellten Mitschriften von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Benedict</firstname>
	  <surname>Reuschling</surname>
	  <contrib>&Uuml;bersetzt von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Portsnap: Ein Werkzeug zur Aktualisierung der Ports-Sammlung</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Das Basissystem von &os; enth&auml;lt auch ein Programm zum
      Aktualisieren der Ports-Sammlung: das &man.portsnap.8; Werkzeug.  Wenn
      es ausgef&uuml;hrt wird, verbindet es sich mit einem entfernten Rechner, 
      &uuml;berpr&uuml;ft den Sicherungsschl&uuml;ssel und l&auml;dt eine neue
      Kopie der Ports-Sammlung herunter.  Der Schl&uuml;ssel wird dazu
      verwendet, um die Integrit&auml;t aller heruntergeladenen Dateien zu
      pr&uuml;fen und um sicherzustellen, dass diese unterwegs nicht
      ver&auml;ndert wurden.  Um die aktuellsten Dateien der Ports-Sammlung
      herunter zu laden, geben Sie das folgende Kommando ein:</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 3 mirrors found.
Fetching snapshot tag from portsnap1.FreeBSD.org... done.
Fetching snapshot metadata... done.
Updating from Wed Aug  6 18:00:22 EDT 2008 to Sat Aug 30 20:24:11 EDT 2008.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>Dieses Beispiel zeigt, dass &man.portsnap.8; mehrere Korrekturen
      f&uuml;r die aktuellen Ports-Daten gefunden und verifiziert hat.  Es
      zeigt auch, dass das Programm zuvor schon einmal gestartet wurde.
      W&auml;re es das erste Mal, w&uuml;rde nur die Ports-Sammlung
      heruntergeladen werden.</para>

    <para>Wenn &man.portsnap.8; erfolgreich die
      <command>fetch</command>-Operation abgeschlossen hat, befinden sich die
      Ports-Sammlung und die dazugeh&ouml;rigen Korrekturen auf dem lokalen
      System, welches die &Uuml;berpr&uuml;fung bestanden hat.  Die 
      aktualisierten Dateien k&ouml;nnen nun installiert werden durch die
      Eingabe von:</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>Der Prozess ist jetzt abgeschlossen und Anwendungen k&ouml;nnen
      mittels der aktuellen Ports-Sammlung installiert oder aktualisiert
      werden.</para>

    <para>Um beide Prozesse nacheinander auszuf&uuml;hren, geben Sie das
      folgende Kommando ein:</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>
  </sect1>

  <sect1 id="updating-upgrading-documentation">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Benedict</firstname>
	  <surname>Reuschling</surname>
	  <contrib>&Uuml;bersetzt von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Aktualisieren der Dokumentationssammlung</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>

    <indexterm>
      <primary>Documentation</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Neben dem Basissystem und der Ports-Sammlung ist die Dokumentation
      ein wichtiger Bestandteil des &os; Betriebssystems.  Obwohl eine aktuelle
      Version der &os; Dokumentation jederzeit auf der <ulink
      url="http://www.freebsd.org/doc/">&os; Webseite</ulink> verf&uuml;gbar
      ist, verf&uuml;gen manche Benutzer nur &uuml;ber eine langsame oder
      &uuml;berhaupt keine Netzwerkverbindung. Gl&uuml;cklicherweise gibt es
      mehrere M&ouml;glichkeiten, die Dokumentation, welche mit jeder Version
      ausgeliefert wird, zu aktualisieren, indem eine lokale Kopie der
      aktuellen &os;-Dokumentationssammlung verwendet wird.</para>

    <sect2 id="csup-doc">
      <title>Verwenden von CVSup um die Dokumentation zu aktualisieren</title>

      <para>Die Quellen und die installierte Kopie der &os; Dokumentation
        kann mittels <application>CVSup</application> aktualisiert werden,
        indem ein &auml;hnlicher Mechanismus angewendet wird, wie derjenige
        f&uuml;r die Betriebssystemquellen (vergleichen Sie mit <xref
        linkend="makeworld">).  Dieser Abschnitt beschreibt:</para>

      <itemizedlist>
	<listitem>
	  <para>Wie die Dokumentations-Werkzeugsammlung installiert wird,
	    welche die Werkzeuge enth&auml;lt, die n&ouml;tig sind, um die
	    &os; Dokumentation aus den Quellen neu zu erstellen.</para>
	</listitem>

	<listitem>
	  <para>Wie man eine Kopie der Dokumentationsquellen nach <filename
	    class="directory">/usr/doc</filename> herunterl&auml;dt, unter
	    Verwendung von <application>CVSup</application>.</para>
	</listitem>

	<listitem>
	  <para>Wie man die &os; Dokumentation aus den Quellen baut und unter
	    <filename class="directory">/usr/share/doc</filename>
	    installiert.</para>
	</listitem>

	<listitem>
	  <para>Manche der Optionen zum Erstellen, die vom System zum Bauen der 
	    Dokumentation unterst&uuml;tzt werden, z.B. die Optionen welche nur
	    ein paar der unterschiedlichen Sprach&uuml;bersetzungen der
	    Dokumentation erstellen oder die Optionen, die ein bestimmtes
	    Ausgabeformat ausw&auml;hlen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="installing-documentation-toolchain">
      <title>CVSup und die Werkzeugsammlung der Dokumentation 
        installieren</title>

      <para>Die &os; Dokumentation aus dem Quellen zu erstellen ben&ouml;tigt
        eine ziemlich grosse Anzahl an Werkzeugen.  Diese Werkzeuge sind nicht 
        Teil des &os; Basissystems, da sie eine grosse Menge an Plattenplatz
        verbrauchen und nicht von allen &os;-Anwendern ben&ouml;tigt werden. 
        Sie sind nur f&uuml;r diejenigen Benutzer notwendig, die aktiv an neuer
        Dokumentation f&uuml; &os; schreiben oder h&auml;ufig ihre
        Dokumentation aus den Quellen bauen lassen.</para>

      <para>Alle ben&ouml;tigten Werkzeuge sind als Teil der Ports-Sammlung
        verf&uuml;gbar.  Der Port <filename
        role="package">textproc/docproj</filename> dient als Masterport, der
        vom &os; Documentation Project entwickelt wurde, um die initiale
        Installation und zuk&uuml;nftige Aktualisierungen dieser Werkzeuge zu
        vereinfachen.</para>

      <note>
	<para>Wenn Sie die Dokumentation nicht als &postscript; oder PDF
	  ben&ouml;tigen, k&ouml;nnen Sie alternativ die Installation des
	  <filename role="package">textproc/docproj-nojadetex</filename>-Ports
	  in Erw&auml;gung ziehen.  Diese Version der
	  Dokumentations-Werkzeugsammlung enth&auml;lt alles ausser das
	  <application>teTeX</application>-Textsatzsystem.
	  <application>teTeX</application> ist eine sehr grosse Sammlung an
	  Werkzeugen, deshalb ist es vern&uuml;nftig, deren Installation
	  auszulassen, wenn die Ausgabe von PDF nicht unbedingt gebraucht
	  wird.</para>
      </note>

      <para>F&uuml;r weitere Informationen &uuml;ber das Installieren und
        Verwenden von <application>CVSup</application>, lesen Sie <link
	  linkend="cvsup">CVSup verwenden</link>.</para>
    </sect2>

    <sect2 id="updating-documentation-sources">
      <title>Die Dokumentationsquellen aktualisieren</title>

      <para>Das Programm <application>CVSup</application> kann eine saubere
        Kopie der Dokumentationsquellen holen, indem es die Datei
        <filename>/usr/share/examples/cvsup/doc-supfile</filename> als
        Konfigurationsvorlage verwendet.  Der Standard-Host zum Aktualisieren
        ist auf einen Platzhalterwert im <filename>doc-supfile</filename>
        gesetzt, aber &man.cvsup.1; akzeptiert auch einen Hostnamen &uuml;ber
        die Kommandozeile. Somit k&ouml;nnen die Dokumentationsquellen von
        einem der <application>CVSup</application>-Server geholt werden, indem
        man eingibt:</para>

      <screen>&prompt.root; <userinput>cvsup -h <replaceable>cvsup.FreeBSD.org</replaceable> -g -L 2 <filename>/usr/share/examples/cvsup/doc-supfile</filename></userinput></screen>

      <para>&Auml;ndern Sie <replaceable>cvsup.FreeBSD.org</replaceable> auf
        den Ihnen am n&auml;chsten gelegenen
        <application>CVSup</application>-Server.  Eine vollst&auml;ndige Liste
        von Spiegelservern finden Sie unter <xref
        linkend="cvsup-mirrors">.</para>

      <para>Es dauert eine Weile, wenn die Dokumentationsquellen das allererste
        Mal heruntergeladen werden. Lassen Sie es laufen, bis es fertig
        ist.</para>

      <para>Zuk&uuml;nftige Aktualisierungen der Dokumentationsquellen
        k&ouml;nnen Sie &uuml;ber den gleichen Befehl bekommen.  Das Programm
        <application>CVSup</application> l&auml;dt und kopiert nur diejenigen
        Aktualisierungen herunter, die seit seinem letzten Aufruf hinzugekommen
        sind.  Deshalb sollte jeder weitere Aufruf von
        <application>CVSup</application> nach dem Ersten wesentlich schneller
        abgeschlossen sein.</para>

      <para>Nachdem die Quellen einmal ausgecheckt wurden, besteht ein anderer
        Weg, die Dokumentation zu aktualisieren, darin, das
        <filename>Makefile</filename> im Verzeichnis <filename
        class="directory">/usr/doc</filename> anzupassen.  Durch setzen von
        <makevar>SUP_UPDATE</makevar>, <makevar>SUPHOST</makevar> und
        <makevar>DOCSUPFILE</makevar> in der Datei
        <filename>/etc/make.conf</filename> ist es jetzt m&ouml;glich,
        folgendes zu tun:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update</userinput></screen>

      <para>Ein typischer Satz dieser &man.make.1;-Optionen f&uuml;r
        <filename>/etc/make.conf</filename> ist:</para>

      <programlisting>SUP_UPDATE= yes
SUPHOST?= cvsup.freebsd.org
DOCSUPFILE?= /usr/share/examples/cvsup/doc-supfile</programlisting>

      <note>
	<para>Das Setzen des Werts von <makevar>SUPHOST</makevar> und
	  <makevar>DOCSUPFILE</makevar> auf <literal>?=</literal> erlaubt es,
	  diese in der Kommandozeile von make zu &uuml;berschreiben.  Diese
	  Methode wird empfohlen, um Optionen zu <filename>make.conf</filename>
	  hinzuzuf&uuml;gen, um zu verhinden, dass man die Datei jedes Mal
	  bearbeiten muss, um einen anderen Wert f&uuml;r die Option
	  auszuprobieren.</para>
      </note>
    </sect2>

    <sect2 id="updating-documentation-options">
      <title>Einstellbare Optionen der Dokumentationsquellen</title>

      <para>Das System zum aktualisieren und erstellen der &os;-Dokumentation
        unterst&uuml;tzt ein paar Optionen, welche den Prozess der
        Aktualisierung von Teilen der Dokumentation oder einer bestimmten
        &Uuml;bersetzung erleichtert.  Diese Optionen lassen sich entweder
        systemweit in der Datei <filename>/etc/make.conf</filename> setzen,
        oder als Kommandozeilenoptionen, die dem &man.make.1;-Werkzeug
        &uuml;bergeben werden.</para>

      <para>Die folgenden Optionen sind ein paar davon:</para>

      <variablelist>
	<varlistentry>
	  <term><makevar>DOC_LANG</makevar></term>

	  <listitem>
	    <para>Eine Liste von Sprachen und Kodierungen, die gebaut und
	      installiert werden sollen, z.B.
	      <literal>en_US.ISO8859-1</literal>, um nur die englische
	      Dokumentation zu erhalten.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><makevar>FORMATS</makevar></term>

	  <listitem>
	    <para>Ein einzelnes Format oder eine Liste von Ausgabeformaten, das
	      gebaut werden soll. Momentan werden <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal>, <literal>pdf</literal>,
	      und <literal>rtf</literal> unterst&uuml;tzt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><makevar>SUPHOST</makevar></term>

	  <listitem>
	    <para>Der Hostname des <application>CVSup</application>-Servers,
	      der verwendet werden soll, um Aktualisierungen zu holen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><makevar>DOCDIR</makevar></term>

	  <listitem>
	    <para>Wohin die Dokumentation installiert werden soll.  Der
	      Standardpfad ist <filename
	      class="directory">/usr/share/doc</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>F&uuml;r weitere make-Variablen, die als systemweite Optionen
        in &os; unterst&uuml;tzt werden, lesen Sie &man.make.conf.5;.</para>

      <para>F&uuml;r weitere make-Variablen, die vom System zum Erstellen der
        &os;-Dokumentation unterst&uuml;tzt werden, lesen Sie die <ulink
        url="&url.doc.langbase;/books/fdp-primer">Fibel f&uuml;r neue
        Mitarbeiter des &os;-Dokumentationsprojekts</ulink>.</para>
    </sect2>

    <sect2 id="updating-installed-documentation">
      <title>Die &os;-Dokumentation aus den Quellen installieren</title>

      <para>Wenn ein aktueller Schnappschuss der Dokumentationsquellen nach
        <filename class="directory">/usr/doc</filename> heruntergeladen wurde,
        ist alles bereit f&uuml;r eine Aktualisierung der bestehenden
        Dokumentation.</para>

      <para>Eine komplette Aktualisierung aller Sprachoptionen, definiert durch
        die <makevar>DOC_LANG</makevar> Makefile-Option, kann durch folgende
        Eingabe erreicht werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Wenn <filename>make.conf</filename> mit den richtigen Optionen
        <makevar>DOCSUPFILE</makevar>, <makevar>SUPHOST</makevar> und
        <makevar>SUP_UPDATE</makevar> eingerichtet wurde, kann der
        Installationsschritt mit einer Aktualisierung der Dokumentationsquellen
        kombiniert werden, indem man eingibt:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>Wenn nur eine Aktualisierung einer bestimmten Sprache
        gew&uuml;nscht wird, kann &man.make.1; in einem sprachspezifischen
        Unterverzeichnis von <filename class="directory">/usr/doc</filename>
        aufgerufen werden, z.B.:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>Die zu installierenden Ausgabeformate k&ouml;nnen durch das Setzen
        der make-Variablen <makevar>FORMATS</makevar> angegeben werden,
        z.B.:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>
    </sect2>

    <sect2 id="doc-ports">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	    <contrib>Basierend auf der Arbeit von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Verwendung von Dokumentations-Ports</title>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>Im vorherigen Abschnitt wurde eine Methode gezeigt, wie die
        &os;-Dokumentation aus den Quellen gebaut werden kann.  Allerdings sind
        quellbasierte Aktualisierungen m&ouml;glicherweise nicht f&uuml;r alle
        &os;-Systeme geeignet oder praktikabel. Das Erstellen der
        Dokumentationsquellen ben&ouml;tigt eine grosse Anzahl an Werkzeugen,
        Programmen und Hilfsmitteln, die <emphasis>documentation
        toolchain</emphasis>, ein gewisser Grad an Vertrautheit mit
        <application>CVS</application> und ausgecheckte Quellen von einem
        Repository, sowie ein paar manuelle Schritte, um diese ausgecheckten
        Quellen zu bauen.  In diesem Abschnitt wird eine alternative Art und
        Weise vorgestellt, wie man die installierte Kopie der
        &os;-Dokumentation aktualisieren kann.  Diese Methode verwendet die
        Ports-Sammlung und erlaubt es:</para>

      <itemizedlist>
	<listitem>
	  <para>vorgefertige Schnappsch&uuml;sse der Dokumentation herunter zu
	    laden und zu installieren, ohne vorher irgendetwas lokal zu
	    erstellen (dadurch ist es nicht mehr notwenig, den kompletten
	    Werkzeugkasten der Dokumentation zu installieren).</para>
	</listitem>

	<listitem>
	  <para>die Dokumentationsquellen herunterzuladen und durch das
	    Ports-System erstellen zu lassen (was die Schritte zum Auschecken
	    und Erstellen etwas erleichtert).</para>
	</listitem>
      </itemizedlist>

      <para>Diese beiden Methoden der Aktualisierung der &os;-Dokumentation
        werden durch eine Menge von <emphasis>Dokumentations-Ports</emphasis>
        unterst&uuml;tzt, die von &a.doceng; monatlich aktualisiert wird.  
        Diese sind in der Ports-Sammlung unter der virtuellen Kategorie, <ulink
        url="http://www.freshports.org/docs/">docs</ulink> genannt,
        gelistet.</para>

      <sect3 id="doc-ports-install-make">
	<title>Erstellen und Installieren von Dokumentations-Ports</title>

	<para>Die Dokumentations-Ports nutzen das Ports-System, um das
	  Erstellen von Dokumentation wesentlich einfacher zu machen.  Es
	  automatisiert den Prozess des Auscheckens der Dokumentationsquellen,
	  aufrufen von &man.make.1; mit den passenden Umgebungsvariablen und
	  Kommandozeilenoptionen und macht die Installation und Deinstallation
	  von Dokumentation so einfach wie die Installation von jedem anderen
	  Port oder Paket.</para>

	<note>
	  <para>Als zus&auml;tzliche Eigenschaft zeichnen sie eine
	    Abh&auml;ngigkeit zum
	    <emphasis>Dokumentations-Werkzeugsatz</emphasis> auf, wenn die
	    Dokumentations-Ports lokal erstellt werden, weshalb dieser auch
	    automatisch mitinstalliert wird.</para>
	</note>

	<para>Die Dokumentations-Ports sind wie folgt organisiert:</para>

	<itemizedlist>
	  <listitem>
	    <para>Es existiert ein <quote>Master-Port</quote>, <filename
	      role="package">misc/freebsd-doc-en</filename>, in dem alle
	      Dateien zu den Dokumentations-Ports abgelegt sind.  Es dient als
	      Basis f&uuml;r alle Dokumentations-Ports.  Als Voreinstellung
	      wird nur die englische Dokumentation gebaut.</para>
	  </listitem>

	  <listitem>
	    <para>Es gibt einen <quote>Alles-in-Einem-Port</quote>, <filename
	      role="package">misc/freebsd-doc-all</filename>, welcher die
	      komplette Dokumentation in allen verf&uuml;gbaren Sprachen
	      erstellt und installiert.</para>
	  </listitem>

	  <listitem>
	    <para>Schliesslich gibt es noch einen sogenannten <quote>slave
	      port</quote> f&&uml;r jede &Uuml;bersetzung, z.B.: <filename
	      role="package">misc/freebsd-doc-hu</filename> f&uuml;r
	      Dokumentation in ungarischer Sprache.  All diese ben&ouml;tigen
	      den Master-Port und installieren die &uuml;bersetzte
	      Dokumentation in der entsprechenden Sprache.</para>
	  </listitem>
	</itemizedlist>

	<para>Um einen Dokumentations-Port aus den Quellen zu installieren,
	  geben Sie das folgende Kommando (als <username>root</username>)
	  ein:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para>Auf diese Weise wird die englische Dokumentation gebaut und als
	  getrenntes <acronym>HTML</acronym>-Format im Verzeichnis <filename
	  class="directory">/usr/local/share/doc/freebsd</filename> installiert
	  (genau wie unter <ulink url="http://www.FreeBSD.org"></ulink> zu
	  finden).</para>

	<sect4 id="doc-ports-options">
	  <title>Gebr&auml;uchliche Schalter und Optionen</title>

	  <para>Es gibt viele Optionen, um das Standarderhalten der
	    Dokumentations-Ports zu ver&auml;ndern.  Im Folgenden sind nur ein
	    paar davon aufgef&uuml;hrt:</para>

	  <variablelist>
	    <varlistentry>
	      <term><makevar>WITH_HTML</makevar></term>

	      <listitem>
		<para>Erlaubt das Erstellen im HTML-Format: eine einzige
		  HTML-Datei pro Dokument.  Die formatierte Dokumentation wird
		  als Datei mit dem Namen <filename>article.html</filename>
		  gespeichert, oder, je nachdem, als
		  <filename>book.html</filename>, zuzu&uuml;glich der
		  Bilder.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><makevar>WITH_PDF</makevar></term>

	      <listitem>
		<para>Erlaubt das Erstellen von &adobe; Portable Document
		  Format, f&uuml;r die Verwendung mit &adobe; &acrobat.reader;,
		  <application>Ghostscript</application> oder anderen
		  PDF-Betrachtern.  Die formatierte Dokumentation wird als Datei
		  mit dem Namen <filename>article.pdf</filename> oder, soweit
		  angemessen, als <filename>book.pdf</filename>
		  gespeichert.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><makevar>DOCBASE</makevar></term>

	      <listitem>
		<para>Wohin die Dokumentation installiert werden soll.  Der
		  Standardpfad ist <filename
		  class="directory">/usr/local/share/doc/freebsd</filename>.</para>

		<note>
		  <para>Beachten Sie, dass sich der Standardpfad von dem
		    Verzeichnis unterscheidet, das von der
		    <application>CVSup</application>-Methode verwendet wird.
		    Das liegt daran, dass ein Port installiert wird und diese
		    &uuml;berlicherweise im Verzeichnis <filename
		    class="directory">/usr/local</filename> abgelegt werden.
		    Durch setzen der <makevar>PREFIX</makevar>-Variablen kann
		    dieses Verhalten ge&auml;ndert werden.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Es folgt ein kurzes Beispiel, wie die Variablen verwendet
	    werden, um die oben erw&auml;hnte ungarische Dokumentation als
	    Portable Document Format zu installieren:</para>

	  <screen>&prompt.root; cd /usr/ports/misc/freebsd-doc-hu
&prompt.root; make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</screen>
	</sect4>
      </sect3>

      <sect3 id="doc-ports-install-package">
	<title>Verwendung von Dokumentations-Paketen</title>

	<para>Das Erstellen der Dokumentations-Ports aus den Quellen, wie im
	  vorherigen Abschnitt beschrieben, ben&ouml;tigt die lokale
	  Installation der Dokumentations-Werkzeugsammlung und ein wenig
	  Festplattenspeicher f&uuml;r das Bauen der Ports.  Sollten die
	  Ressourcen zum Bauen der Dokumentations-Werkzeugsammlung nicht zur
	  Verf&uuml;gung stehen, oder weil das erstellen zuviel Plattenplatz
	  ben&ouml;tigen w&uuml;rde, ist es trotzdem m&ouml;glich, bereits
	  zuvor gebaute Schnappsch&uuml;sse der Dokumentations-Ports zu
	  installieren.</para>

	<para>&a.doceng; erstellt monatliche Schnappsch&uuml;sse der
	  Dokumentations-Pakete von &os;.  Diese Bin&auml;rpakete k&ouml;nnen
	  mit jedem der mitgelieferten Paketwerkzeuge installiert werden,
	  beispielsweise &man.pkg.add.1;, &man.pkg.delete.1; und so
	  weiter.</para>

	<note>
	  <para>Wenn Bin&auml;rpakete zu Einsatz kommen, wird die
            &os;-Dokumentation in <emphasis>allen</emphasis> verf&uuml;gbaren
            Formaten in der gegebenen Sprache installiert.</para>
	</note>

	<para>Zum Beispiel installiert das folgende Kommando das aktuelle,
	  vorgefertigte Paket der ungarischen Dokumentation:</para>

	<screen>&prompt.root; <userinput>pkg_add -r hu-freebsd-doc</userinput></screen>

	<note>
	  <para>Pakete haben das folgende Namensformat, welches sich von dem
	    Namen des dazugeh&ouml;rigen Ports unterscheidet:
	    <literal><replaceable>lang</replaceable>-freebsd-doc</literal>.
	    <replaceable>lang</replaceable> entspricht hier der Kurzform des
	    Sprachcodes, z.B. <literal>hu</literal> f&uuml;r Ungarisch, oder
	    <literal>zh_cn</literal> f&uuml;r vereinfachtes Chinesisch.</para>
	</note>
      </sect3>

      <sect3 id="doc-ports-update">
	<title>Dokumentations-Ports aktualisieren</title>

	<para>Um einen zuvor installierten Dokumentations-Port zu aktualisieren, 
	  kann jedes Werkzeug, das auch zum Aktualisieren von Ports verwendet
	  wird, eingesetzt werden.  Beispielsweise aktualisiert das folgende
	  Kommando die installierte ungarische Dokumentation mittels des
	  Programms <filename
	  role="package">ports-mgmt/portupgrade</filename> indem nur Pakete
	  verwendet werden sollen:</para>

	<screen>&prompt.root; <userinput>portupgrade -PP hu-freebsd-doc</userinput></screen>
      </sect3>
    </sect2>

<!-- FIXME: Waiting for a working docsnap server... -->
<![ IGNORE [
    <sect2 id="docsnap">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Pav</firstname>
	    <surname>Lucistnik</surname>
	    <contrib>Based on information provided by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Using Docsnap</title>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>Docsnap</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para><application>Docsnap</application> is an &man.rsync.1;
	repository for updating installed &os; Documentation in a
	relatively easy and fast way.  A
	<quote><application>Docsnap</application> server</quote> tracks
	the documentation sources, and builds them in HTML format every
	hour.  The <filename role="package">textproc/docproj</filename>
	is unneeded with <application>Docsnap</application> as only
	patches to the built documentation exist.</para>

      <para>The only requirement for using this technique is
	the <filename role="package">net/rsync</filename> port or
	package.  To add it, use the following command:</para>

      <screen>&prompt.root; <userinput>pkg_add -r rsync</userinput></screen>

      <note>
	<para><application>Docsnap</application> has been originally
	  developed for updating documentation installed
	  to <filename class="directory">/usr/share/doc</filename>, but
	  the following examples could be adapted for other directories
	  as well.  For user directories, it does not require
	  <username>root</username> privileges.</para>
      </note>

      <para>To update the documentation set, issue the following
	command:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap <replaceable>/usr/share/doc</replaceable></userinput></screen>

      <note>
	<para>There is only one <application>Docsnap</application>
	  server at the moment;
	  the <hostid>docsnap.sk.FreeBSD.org</hostid> shown
	  above.</para>
      </note>

      <para>Do not use the <option>--delete</option> flag here as there
	are some items installed
	into <filename class="directory">/usr/share/doc</filename>
	during <command>make installworld</command>, which would
	accidentally be removed.  To clean up, use this command
	instead:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz --delete <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap/??_??\.\* <replaceable>/usr/share/doc</replaceable></userinput></screen>

      <para>If a subset of documentation needs to be updated, for
	example, the English documentation only, the following command
	should be used:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap/en_US.ISO8859-1 <replaceable>/usr/share/doc</replaceable></userinput></screen>
    </sect2>
]]>
  </sect1>

  <sect1 id="current-stable">
    <title>Einem Entwicklungszweig folgen</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>FreeBSD besitzt zwei Entwicklungszweige: &os.current; und
      &os.stable;.  Dieser Abschnitt beschreibt beide Zweige und
      erl&auml;utert, wie Sie Ihr System auf dem aktuellen Stand
      eines Zweiges halten.  Zuerst wird &os.current; vorgestellt, dann
      &os.stable;.</para>

    <sect2 id="current">
      <title>&os.current;</title>

      <para>Beachten Sie im Folgenden, dass &os.current; die Spitze
        der Entwicklung von &os; ist.  Benutzer von &os.current; sollten
	&uuml;ber sehr gute technische F&auml;higkeiten verf&uuml;gen und
	in der Lage sein, schwierige Probleme alleine zu l&ouml;sen.  Wenn
	&os; neu f&uuml;r Sie ist, &uuml;berlegen Sie sich genau, ob Sie
	&os.current; benutzen wollen.</para>

      <sect3>
	<title>Was ist &os.current;?</title>
	<indexterm><primary>Snapshot</primary></indexterm>

	<para>&os.current; besteht aus den neuesten Quellen des
	  FreeBSD-Systems.  Es enth&auml;lt Sachen, an denen gerade
	  gearbeitet wird, experimentelle &Auml;nderungen und
	  &Uuml;bergangsmechanismen, die im n&auml;chsten offiziellen
	  Release der Software enthalten sein k&ouml;nnen oder nicht.
	  Obwohl &os.current; t&auml;glich von vielen Entwicklern gebaut
	  wird, gibt es Zeitr&auml;ume, in denen sich das System nicht
	  bauen l&auml;sst.  Diese Probleme werden so schnell wie
	  m&ouml;glich gel&ouml;st, aber ob Sie mit &os.current;
	  Schiffbruch erleiden oder die gew&uuml;nschten Verbesserungen
	  erhalten, kann von dem Zeitpunkt abh&auml;ngen, an dem Sie sich
	  den Quelltext besorgt haben!</para>
      </sect3>

      <sect3>
	<title>Wer braucht &os.current;?</title>

	<para>&os.current; wird haupts&auml;chlich f&uuml;r 3
	  Interessengruppen zur Verf&uuml;gung gestellt:</para>

	<orderedlist>
	  <listitem>
	    <para>Entwickler, die an einem Teil des Quellbaums arbeiten und
	      daher &uuml;ber die aktuellen Quellen verf&uuml;gen
	      m&uuml;ssen.</para>
	  </listitem>

	  <listitem>
	    <para>Tester, die bereit sind, Zeit in das L&ouml;sen von
	      Problemen zu investieren und sicherstellen, dass
	      &os.current; so stabil wie m&ouml;glich bleibt.  Weiterhin
	      Leute, die Vorschl&auml;ge zu &Auml;nderungen oder der
	      generellen Entwicklung von &os; machen und Patches
	      bereitstellen, um diese Vorschl&auml;ge zu realisieren.</para>
	  </listitem>

	  <listitem>
	    <para>F&uuml;r Leute, die die Entwicklung im Auge behalten
	      wollen, oder die Quellen zu Referenzzwecken (zum Beispiel
	      darin lesen, aber nicht verwenden) benutzen wollen.  Auch diese
	      Gruppe macht Vorschl&auml;ge oder steuert Quellcode
	      bei.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Was &os.current; <emphasis>nicht</emphasis> ist!</title>

	<orderedlist>
	  <listitem>
	    <para>Der schnellste Weg, neue Sachen vor dem offiziellen
	      Release auszuprobieren.  Bedenken Sie, dass der erste,
	      der die neuen Sachen ausprobiert, auch der erste ist, der die
	      neuen Fehler findet.</para>
	  </listitem>

	  <listitem>
	    <para>Ein schneller Weg, um an Fehlerbehebungen (engl.
	      <foreignphrase>bug fixes</foreignphrase>) zu kommen.  Jede
	      Version von &os.current; f&uuml;hrt mit gleicher
	      Wahrscheinlichkeit neue Fehler ein, mit der sie alte
	      behebt.</para>
	  </listitem>

	  <listitem>
	    <para>In irgendeiner Form <quote>offiziell
	        unterst&uuml;tzt</quote>.  Wir tun unser Bestes, um Leuten
	      aus den drei <quote>legitimen</quote> Benutzergruppen von
	      &os.current; zu helfen, aber wir <emphasis>haben einfach nicht
	      die Zeit</emphasis>, technische Unterst&uuml;tzung zu
	      erbringen.  Das kommt nicht daher, dass wir kleinliche,
	      gemeine Leute sind, die anderen nicht helfen wollen (wenn
	      wir das w&auml;ren, w&uuml;rden wir &os; nicht machen), wir
	      k&ouml;nnen einfach nicht jeden Tag Hunderte Nachrichten
	      beantworten <emphasis>und</emphasis> an &os; arbeiten!  Vor
	      die Wahl gestellt, &os; zu verbessern oder jede Menge Fragen
	      zu experimentellem Code zu beantworten, haben sich die
	      Entwickler f&uuml;r ersteres entschieden.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Benutzen von &os.current;</title>

	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>benutzen</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Es ist <emphasis>essentiell</emphasis>, die Mailinglisten
	      &a.current.name; und &a.cvsall.name; zu lesen.  Wenn Sie
	      &a.current.name; nicht lesen, verpassen Sie die Kommentare
	      anderer &uuml;ber den momentanen Zustand des Systems und rennen
	      demzufolge in viele bekannte Probleme, die schon gel&ouml;st
	      sind.  Noch kritischer ist, dass Sie wichtige
	      Bekanntmachungen verpassen, die erhebliche Auswirkungen
	      auf die Stabilit&auml;t Ihres Systems haben k&ouml;nnen.</para>

	    <para>In der &a.cvsall.name; Mailingliste sehen Sie zu jeder
	      &Auml;nderung das Commit-Log, das Informationen zu
	      m&ouml;glichen Seiteneffekten enth&auml;lt.</para>

	    <para>Um diese Listen zu abonnieren (oder zu lesen)
	      besuchen Sie bitte die Seite &a.mailman.lists.link;.
	      Weitere Informationen erhalten Sie, wenn Sie dort
	      auf die gew&uuml;nschte Liste klicken.</para>
	  </listitem>

	  <listitem>
	    <para>Beschaffen Sie sich die Quellen von einem
	      <link linkend="mirrors">&os;-Spiegel</link>.  Sie haben
	      dazu zwei M&ouml;glichkeiten:</para>

	    <orderedlist>
              <indexterm>
                <primary><command>cvsup</command></primary>
              </indexterm>
              <indexterm>
                <primary><command>cron</command></primary>
              </indexterm>
              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>mit <application>CVSup</application>
		  synchronisieren</secondary>
	      </indexterm>

	      <listitem>
		<para>Benutzen Sie das Programm
		  <link linkend="cvsup">cvsup</link>
		  mit der Datei <filename>standard-supfile</filename>
		  aus dem Verzeichnis
		  <filename>/usr/share/examples/cvsup</filename>.
		  Dies ist die empfohlene Methode, da Sie die ganzen
		  Quellen nur einmal herunterladen und danach nur noch
		  &Auml;nderungen beziehen.  Viele lassen
		  <command>cvsup</command> aus <command>cron</command>
		  heraus laufen, um ihre Quellen automatisch auf Stand
		  zu bringen.  Sie m&uuml;ssen die obige Sup-Datei
		  anpassen und <link linkend="cvsup">cvsup</link>
		  in Ihrer Umgebung konfigurieren.</para>
	      </listitem>

              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>mit CTM synchronisieren</secondary>
	      </indexterm>
	      <listitem>
		<para><application><link linkend="ctm">CTM</link></application>
		  kommt in Frage, wenn Sie
		  &uuml;ber eine schlechte Internet-Anbindung (hoher Preis
		  oder nur E-Mail Zugriff) verf&uuml;gen.  Der Umgang mit
		  <application>CTM</application> ist allerdings recht
		  m&uuml;hsam und Sie k&ouml;nnen besch&auml;digte Dateien
		  erhalten.  Daher wird es selten benutzt, was wiederum
		  dazu f&uuml;hrt, dass es &uuml;ber l&auml;ngere Zeit
		  nicht funktioniert.  Wir empfehlen jedem mit einem
		  9600&nbsp;bps oder schnellerem Modem,
		  <application><link linkend="cvsup">CVSup</link></application>
		  zu benutzen.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Wenn Sie die Quellen einsetzen und nicht nur darin
	      lesen wollen, besorgen Sie sich bitte die
	      <emphasis>kompletten</emphasis> Quellen von &os.current; und
	      nicht nur ausgesuchte Teile.  Der Grund hierf&uuml;r ist,
	      dass die verschiedenen Teile der Quellen voneinander
	      abh&auml;ngen.  Es ist ziemlich sicher, dass Sie in
	      Schwierigkeiten geraten, wenn Sie versuchen, nur einen Teil
	      der Quellen zu &uuml;bersetzen.</para>

	    <indexterm>
	      <primary>-CURRENT</primary>
	      <secondary>&uuml;bersetzen</secondary>
	    </indexterm>

	    <para>Sehen Sie sich das <filename>Makefile</filename> in
	      <filename>/usr/src</filename> genau an, bevor Sie
	      &os.current; &uuml;bersetzen.  Wenn Sie
	      &os; das erste Mal aktualisieren, sollten Sie sowohl
	      <link linkend="makeworld">einen Kernel als auch das
		System neu installieren</link>.
	      Lesen Sie bitte die Mailingliste &a.current;
	      und <filename>/usr/src/UPDATING</filename>, um &uuml;ber
	      &Auml;nderungen im Installationsverfahren, die manchmal
	      vor der Einf&uuml;hrung eines neuen Releases notwendig sind,
	      informiert zu sein.</para>
	  </listitem>

	  <listitem>
	    <para>Seien Sie aktiv!  Wenn Sie &os.current; laufen lassen,
	      wollen wir wissen, was Sie dar&uuml;ber denken, besonders
	      wenn Sie Verbesserungsvorschl&auml;ge oder Fehlerbehebungen
	      haben.  Verbesserungsvorschl&auml;ge, die Code enthalten,
	      werden &uuml;brigens begeistert entgegengenommen.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>&os.stable;</title>

      <sect3>
	<title>Was ist &os.stable;?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; ist der Entwicklungszweig, auf dem Releases
	  erstellt werden.  Dieser Zweig &auml;ndert sich langsamer als
	  &os.current; und alle &Auml;nderungen hier sollten zuvor in
	  &os.current; ausgetestet sein.  Beachten Sie, dass dies
	  <emphasis>immer noch</emphasis> ein Entwicklungszweig ist und
	  daher zu jedem Zeitpunkt die Quellen von &os.stable; verwendbar
	  sein k&ouml;nnen oder nicht.  &os.stable; ist Teil des
	  Entwicklungsprozesses und nicht f&uuml;r Endanwender
	  gedacht.</para>
      </sect3>

      <sect3>
	<title>Wer braucht &os.stable;?</title>

	<para>Wenn Sie den FreeBSD-Entwicklungsprozess, besonders im
	  Hinblick auf das n&auml;chste Release, verfolgen oder
	  dazu beitragen wollen, sollten Sie erw&auml;gen, &os.stable; zu
	  benutzen.</para>

	<para>Auch wenn sicherheitsrelevante Fehlerbehebungen in den
	  &os.stable; Zweig einflie&szlig;en, m&uuml;ssen Sie deswegen
	  noch lange nicht &os.stable; verfolgen.  Jeder der FreeBSD
	  Sicherheitshinweise beschreibt f&uuml;r jedes betroffene Release,
	  <footnote><para>Das stimmt nicht ganz.  Obwohl wir alte FreeBSD
	    Releases f&uuml;r einige Jahre unterst&uuml;tzen, k&ouml;nnen
	    wir sie nicht ewig unterst&uuml;tzen.  Eine vollst&auml;ndige
	    Beschreibung der Sicherheitspolitik f&uuml;r alte FreeBSD
	    Releases entnehmen Sie bitte <ulink
	    url="&url.base;/security/">http://www.FreeBSD.org/security/</ulink>.</para>
	  </footnote>
	  wie sie einen sicherheitsrelevanten Fehler beheben.
	  Wenn Sie den Entwicklungszweig aus Sicherheitsgr&uuml;nden
	  verfolgen wollen, bedenken Sie, dass Sie neben
	  Fehlerbehebungen auch eine Vielzahl unerw&uuml;nschter
	  &Auml;nderungen erhalten werden.</para>

	<para>Obwohl wir versuchen sicherzustellen, dass der
	  &os.stable; Zweig sich jederzeit &uuml;bersetzen l&auml;sst
	  und l&auml;uft, k&ouml;nnen wir daf&uuml;r keine Garantie
	  &uuml;bernehmen.  Auch wenn Neuentwicklungen in &os.current;
	  stattfinden, ist es jedoch so, dass mehr Leute
	  &os.stable; benutzen als &os.current; und es daher unvermeidlich
	  ist, dass Fehler und Grenzf&auml;lle erst in &os.stable;
	  auffallen.</para>

	<para>Aus diesen Gr&uuml;nden empfehlen wir Ihnen
	  <emphasis>nicht</emphasis>, blindlings &os.stable; zu benutzen.
	  Es ist wichtig, dass Sie &os.stable; zuerst sorgf&auml;ltig
	  in einer Testumgebung austesten, bevor Sie Ihre Produktion
	  auf &os.stable; migrieren.</para>

	<para>Wenn Sie dies nicht leisten k&ouml;nnen, empfehlen wir Ihnen,
	  das aktuelle FreeBSD-Release zu verwenden.  Benutzen Sie dann den
	  bin&auml;ren Update-Mechanismus, um auf neue Releases
	  zu migrieren.</para>
      </sect3>

      <sect3>
	<title>Benutzen von &os.stable;</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>benutzen</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Lesen Sie Mailingliste &a.stable.name;, damit Sie &uuml;ber
	      Abh&auml;ngigkeiten beim Bau von &os.stable; und Sachen, die
	      besondere Aufmerksamkeit erfordern, informiert sind.
	      Umstrittene Fehlerbehebungen oder &Auml;nderungen werden von
	      den Entwicklern auf dieser Liste bekannt gegeben.  Dies
	      erlaubt es den Benutzern, Einw&auml;nde gegen die
	      vorgeschlagenen &Auml;nderungen vorzubringen.</para>

	    <para>In der &a.cvsall.name; Mailingliste sehen Sie zu jeder
	      &Auml;nderung das Commit-Log, das Informationen zu
	      m&ouml;glichen Seiteneffekten enth&auml;lt.</para>

	    <para>Um diese Listen oder andere Listen zu abonnieren
	      besuchen Sie bitte die Seite &a.mailman.lists.link;.
	      Weitere Informationen erhalten Sie, wenn Sie dort
	      auf die gew&uuml;nschte Liste klicken.</para>
	  </listitem>

	  <listitem>
	    <para>Wenn Sie ein neues System installieren und dazu einen
	      der monatlich aus &os.stable; erzeugten Snapshots verwenden
	      wollen, sollten Sie zuerst die <ulink
	      url="&url.base;/../snapshots/">Snapshot Website</ulink> auf
	      aktuelle Informationen &uuml;berpr&uuml;fen.  Alternativ
	      k&ouml;nnen Sie auch das neueste &os.stable;-Release von
	      den <link linkend="mirrors">Spiegeln</link> beziehen
	      und Ihr System nach den folgenden Anweisungen
	      aktualisieren.</para>

	    <para>Wenn Sie schon ein &auml;lteres Release von &os;
	      und das System mit dem Quellcode aktualisieren wollen,
	      benutzen Sie einen der <link
	        linkend="mirrors">&os;-Spiegel</link>.  Sie haben
	      dazu zwei M&ouml;glichkeiten:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary>mit <application>CVSup</application>
		  synchronisieren</secondary>
	      </indexterm>
	      <listitem>
		<para>Benutzen Sie das Programm
		  <link linkend="cvsup">cvsup</link>
		  mit der Datei <filename>stable-supfile</filename>
		  aus dem Verzeichnis
		  <filename>/usr/share/examples/cvsup</filename>.
		  Dies ist die empfohlene Methode, da Sie die ganzen
		  Quellen nur einmal herunterladen und danach nur noch
		  &Auml;nderungen beziehen.  Viele lassen
		  <command>cvsup</command> aus <command>cron</command>
		  heraus laufen, um ihre Quellen automatisch auf Stand
		  zu bringen.  Sie m&uuml;ssen das oben erw&auml;hnte
		  <filename>supfile</filename> anpassen und <link
		    linkend="cvsup">cvsup</link> konfigurieren.</para>
	      </listitem>

	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary>mit CTM synchronisieren</secondary>
	      </indexterm>
	      <listitem>
		<para>Benutzen Sie <application><link linkend="ctm">
		    CTM</link></application>.  Wenn Sie &uuml;ber
		  keine schnelle und billige Internet-Anbindung
		  verf&uuml;gen, sollten Sie diese Methode in Betracht
		  ziehen.</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Benutzen Sie <command>cvsup</command> oder
	      <command>ftp</command>, wenn Sie schnellen Zugriff auf die
	      Quellen brauchen und die Bandbreite keine Rolle spielt,
	      andernfalls benutzen Sie
	      <application>CTM</application>.</para>
	  </listitem>

	  <indexterm>
	    <primary>-STABLE</primary>
	    <secondary>&uuml;bersetzen</secondary>
	  </indexterm>
	  <listitem>
	    <para>Bevor Sie &os.stable; &uuml;bersetzen, sollten Sie sich
	      das <filename>Makefile</filename> in
	      <filename>/usr/src</filename> genau anschauen.  Wenn Sie
	      &os; das erste Mal aktualisieren, sollten Sie sowohl
	      <link linkend="makeworld">einen Kernel als auch das
		System neu installieren</link>.
	      Lesen Sie bitte die Mailingliste &a.stable;
	      und <filename>/usr/src/UPDATING</filename>, um &uuml;ber
	      &Auml;nderungen im Installationsverfahren, die manchmal
	      vor der Einf&uuml;hrung eines neuen Releases notwendig sind,
	      informiert zu sein.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Synchronisation der Quellen</title>

    <para>Sie k&ouml;nnen eine Internet-Verbindung (oder E-Mail) dazu
      nutzen, Teile von &os;, wie die Quellen zu einzelnen Projekten, oder
      das Gesamtsystem, aktuell zu halten.  Dazu bieten wir die Dienste
      <link linkend="anoncvs">AnonymousCVS</link>,
      <link linkend="cvsup">CVSup</link> und
      <link linkend="ctm">CTM</link> an.</para>

    <warning>
      <para>Obwohl es m&ouml;glich ist, nur Teile des Quellbaums zu
        aktualisieren, ist die einzige unterst&uuml;tze Migrationsprozedur,
	den kompletten Quellbaum zu aktualisieren und alles, das
	hei&szlig;t das Userland (z.B. alle Programme in
	<filename>/bin</filename> und <filename>/sbin</filename>) und die
	Kernelquellen, neu zu &uuml;bersetzen.  Wenn Sie nur einen Teil der
	Quellen, zum Beispiel nur den Kernel oder nur die Programme aus dem
	Userland, aktualisieren, werden Sie oft Probleme haben, die von
	&Uuml;bersetzungsfehlern &uuml;ber Kernel-Panics bis hin zu
	Besch&auml;digungen Ihrer Daten reichen k&ouml;nnen.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonymous</secondary>
    </indexterm>

    <para><application>Anonymous CVS</application> und
      <application>CVSup</application> benutzen die
      <foreignphrase>Pull</foreignphrase>-Methode
      <footnote>
	<para>Von engl. <foreignphrase>to pull</foreignphrase> =
	  <emphasis>ziehen</emphasis>.  Der Client holt sich bei dieser
	  Methode die Dateien ab.</para>
      </footnote>, um die Quellen zu aktualisieren.  Im Fall von
      <application>CVSup</application> ruft der Benutzer oder ein
      <command>cron</command>-Skript <command>cvsup</command> auf, das
      wiederum mit einem <command>cvsupd</command> Server interagiert, um
      Ihre Quellen zu aktualisieren.  Mit beiden Methoden erhalten Sie
      aktuelle Updates zu einem genau von Ihnen bestimmten Zeitpunkt.  Sie
      k&ouml;nnen die Prozedur auf bestimmte Dateien oder Verzeichnisse
      einschr&auml;nken, so dass Sie nur die Updates bekommen, die
      f&uuml;r Sie von Interesse sind.  Die Updates werden zur Laufzeit,
      abh&auml;ngig von den Sachen, die Sie schon haben und den Sachen, die
      Sie haben wollen, auf dem Server generiert.  <application>Anonymous
        CVS</application> ist eine Erweiterung von
      <application>CVS</application>, die es Ihnen erlaubt, &Auml;nderungen
      direkt aus einem entfernten CVS-Repository zu ziehen.
      <application>Anonymous CVS</application> ist leichter zu handhaben
      als <application>CVSup</application>, doch ist letzteres sehr viel
      effizienter.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para>Im Gegensatz dazu vergleicht <application>CTM</application> Ihre
      Quellen nicht mit denen auf einem Server.  Stattdessen l&auml;uft auf
      dem Server ein Skript, das &Auml;nderungen an Dateien gegen&uuml;ber
      seinem vorigen Lauf bemerkt, die &Auml;nderungen komprimiert, mit
      einer Sequenznummer versieht und f&uuml;r das Verschicken per E-Mail
      kodiert (es werden nur druckbare ASCII-Zeichen verwendet).  Wenn Sie
      diese <quote>CTM-Deltas</quote> erhalten haben, k&ouml;nnen Sie sie
      mit &man.ctm.rmail.1; benutzen, welches die Deltas dekodiert,
      verifiziert und dann die &Auml;nderungen an Ihren Quellen vornimmt.
      Dieses Verfahren ist viel effizienter als
      <application>CVSup</application> und erzeugt auch weniger Last auf
      unseren Servern, da es die
      <foreignphrase>Push</foreignphrase>-Methode
      <footnote>
	<para>Von engl. <foreignphrase>to push</foreignphrase> =
	  <emphasis>schieben</emphasis>.  Der Server schickt dem Client die
	  Dateien.</para>
      </footnote> verwendet.</para>

    <para>Es gibt nat&uuml;rlich noch weitere Unterschiede, die Sie
      beachten sollten.  Wenn Sie unabsichtlich Teile Ihres Archivs
      l&ouml;schen, wird das von <application>CVSup</application>
      wie <application>Anonymous CVS</application> erkannt
      und repariert.  Wenn sich fehlerhafte Dateien in Ihrem Quellbaum
      befinden, l&ouml;schen Sie diese einfach und synchronisieren erneut.
      <application>CTM</application> leistet das nicht,
      wenn Sie Teile des Quellbaums gel&ouml;scht haben und keine Sicherung
      besitzen, m&uuml;ssen Sie von neuem, das hei&szlig;t vom letzten
      <quote>Basis-Delta</quote>, starten und die &Auml;nderungen wieder
      mit <application>CTM</application> nachziehen.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>Das komplette Basissystem neu bauen</title>

    <indexterm>
      <primary>Bau des Basissystems</primary>
    </indexterm>

    <para>Wenn Sie Ihren lokalen Quellbaum mit einer bestimmten FreeBSD
      Version (&os.stable;, &os.current;, usw.) synchronisiert haben,
      k&ouml;nnen Sie diesen benutzen, um das System neu zu
      bauen.</para>

    <warning>
      <title>Erstellen Sie eine Sicherungskopie!</title>

      <para>Es kann nicht oft genug betont werden, wie wichtig es ist, Ihr
        System zu sichern, <emphasis>bevor</emphasis> Sie die nachfolgenden
	Schritte ausf&uuml;hren.  Obwohl der Neubau des Systems eine
	einfache Aufgabe ist, wenn Sie sich an die folgende Anleitung
	halten, kann es dennoch vorkommen, dass Sie einen Fehler machen,
	oder dass Ihr System nicht mehr bootet, weil andere Entwickler
	Fehler in den Quellbaum eingef&uuml;hrt haben.</para>

      <para>Stellen Sie sicher, dass Sie eine Sicherung erstellt haben
        und &uuml;ber eine Fixit-Floppy oder eine startf&auml;hige CD
	verf&uuml;gen.  Wahrscheinlich werden Sie die Startmedien
	nicht ben&ouml;tigen, aber gehen Sie auf Nummer Sicher!</para>
    </warning>

    <warning>
      <title>Abonnieren Sie die richtige Mailingliste</title>

      <indexterm><primary>Mailingliste</primary></indexterm>
      <para>Die &os.stable; und &os.current; Zweige befinden sich in
        <emphasis>st&auml;ndiger Entwicklung</emphasis>.  Die Leute, die zu
	&os; beitragen, sind Menschen und ab und zu machen sie
	Fehler.</para>

      <para>Manchmal sind diese Fehler harmlos und lassen Ihr System eine
        Warnung ausgeben.  Die Fehler k&ouml;nnen allerdings auch
	katastrophal sein und dazu f&uuml;hren, dass Sie Ihr System
	nicht mehr booten k&ouml;nnen, Dateisysteme besch&auml;digt
	werden oder Schlimmeres passiert.</para>

      <para>Wenn solche Probleme auftauchen, wird ein
	<quote>heads up</quote> an die passende Mailingliste geschickt, welches
	das Problem erkl&auml;rt und die betroffenen Systeme benennt.  Eine
	<quote>all clear</quote> Meldung wird versendet, wenn das
	Problem gel&ouml;st ist.</para>

      <para>Wenn Sie &os.stable; oder &os.current; benutzen und nicht die
        Mailinglisten &a.stable; beziehungsweise &a.current; lesen, bringen
	Sie sich nur unn&ouml;tig in Schwierigkeiten.</para>
    </warning>

    <warning>
      <title>Finger weg von <command>make world</command></title>

      <para>&Auml;ltere Dokumentationen empfehlen, das Kommando
	<command>make world</command> f&uuml;r den Neubau.
	Das Kommando &uuml;berspringt wichtige Schritte.  Setzen
	Sie es nur ein, wenn Sie wissen was Sie tun.  In fast
	allen F&auml;llen ist <command>make world</command>
	falsch, benutzen Sie stattdessen die nachstehende
	Anleitung.</para>
    </warning>

    <sect2>
      <title>Richtig aktualisieren</title>

      <para>Um Ihr System zu aktualisieren, sollten Sie zuerst
	<filename>/usr/src/UPDATING</filename> lesen, und
	eventuelle, f&uuml;r Ihre Quellcodeversion n&ouml;tigen
	Aufgaben erledigen, bevor Sie das System bauen.  Danach
	aktualisieren Sie Ihr System mit den folgenden
	Schritten:</para>

      <screen>&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <note>
	<para>Es gibt einige, sehr seltene Situationen, in denen Sie
	  <command>mergemaster -p</command> zus&auml;tzlich
	  ausf&uuml;hren m&uuml;ssen, bevor Sie das System mit
	  <maketarget>buildworld</maketarget> bauen.  Diese Situationen
	  werden in <filename>UPDATING</filename> beschrieben.  Solche
	  Situationen treten aber in der Regel nur dann auf, wenn Sie
	  Ihr &os;-System um eine oder mehrere Hauptversionen
	  aktualisieren.</para>
      </note>

      <para>Nachdem <maketarget>installkernel</maketarget> erfolgreich
	abgeschlossen wurde, starten Sie das System im Single-User-Modus
	(etwa durch die Eingabe von <command>boot -s</command> am
	Loaderprompt).  Danach f&uuml;hren Sie die folgenden Anweisungen
	aus:</para>

      <screen>&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Lesen Sie bitte weiter</title>

	<para>Die obige Vorschrift ist nur eine
	  Ged&auml;chtnisst&uuml;tze.  Um die einzelnen
	  Schritte zu verstehen, lesen Sie bitte die
	  folgenden Abschnitte, insbesondere wenn Sie
	  einen angepassten Kernel erstellen.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Lesen Sie <filename>/usr/src/UPDATING</filename></title>

      <para>Bevor Sie etwas anderes tun, lesen Sie bitte
        <filename>/usr/src/UPDATING</filename> (oder die entsprechende
	Datei, wenn Sie den Quellcode woanders installiert haben).  Die
	Datei enth&auml;lt wichtige Informationen zu Problemen, auf die Sie
	sto&szlig;en k&ouml;nnten oder gibt die Reihenfolge vor, in der Sie
	bestimmte Kommandos laufen lassen m&uuml;ssen.  Die Anweisungen in
	<filename>UPDATING</filename> sind aktueller als die in diesem
	Handbuch.  Im Zweifelsfall folgen Sie bitte den Anweisungen aus
	<filename>UPDATING</filename>.</para>

      <important>
	<para>Das Lesen von <filename>UPDATING</filename> ersetzt nicht das
	  Abonnieren der richtigen Mailingliste.  Die beiden Voraussetzungen
	  erg&auml;nzen sich, es reicht nicht aus, nur eine zu
	  erf&uuml;llen.</para>
      </important>
    </sect2>

    <sect2>
      <title>&Uuml;berpr&uuml;fen Sie
	<filename>/etc/make.conf</filename></title>
      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>&Uuml;berpr&uuml;fen Sie die Dateien
	<filename>/usr/share/examples/etc/make.conf</filename>
	und <filename>/etc/make.conf</filename>.  Die erste enth&auml;lt
	Vorgabewerte, von denen die meisten auskommentiert sind.  Um diese
	w&auml;hrend des Neubaus des Systems zu nutzen, tragen Sie die
	Werte in <filename>/etc/make.conf</filename> ein.  Beachten Sie,
	dass alles, was Sie in <filename>/etc/make.conf</filename>
	eintragen, bei jedem Aufruf von <command>make</command> angezogen
	wird.  Es ist also klug, hier etwas Sinnvolles einzutragen.</para>

      <para>Typischerweise wollen Sie die Zeilen, die
        <makevar>CFLAGS</makevar> und <makevar>NO_PROFILE</makevar>
	enthalten, aus
	<filename>/usr/share/examples/etc/make.conf</filename>
	nach <filename>/etc/make.conf</filename> &uuml;bertragen und dort
	aktivieren.</para>

      <para>Sehen Sie sich auch die anderen Definitionen, wie
        <makevar>COPTFLAGS</makevar> oder <makevar>NOPORTDOCS</makevar> an
	und entscheiden Sie, ob Sie diese aktivieren wollen.</para>
    </sect2>

    <sect2>
      <title>Aktualisieren Sie die Dateien in <filename>/etc</filename></title>

      <para>Das Verzeichnis <filename>/etc</filename> enth&auml;lt den
        Gro&szlig;teil der Konfigurationsdateien des Systems und Skripten,
	die beim Start des Systems ausgef&uuml;hrt werden.  Einige dieser
	Skripten &auml;ndern sich bei einer Migration auf eine neue
	FreeBSD-Version.</para>

      <para>Einige der Konfigurationsdateien, besonders
        <filename>/etc/group</filename>, werden f&uuml;r den Normalbetrieb
	des Systems gebraucht.</para>

      <para>Es gab F&auml;lle, in denen das Kommando
        <command>make installworld</command> auf bestimmte
	Accounts oder Gruppen angewiesen war, die aber w&auml;hrend
	der Aktualisierung fehlten.  Demzufolge kam es zu Problemen
	bei der Aktualisierung.  In einigen F&auml;llen pr&uuml;ft
	<command>make buildworld</command> ob die Accounts oder
	Gruppen vorhanden sind.</para>

      <para>Ein Beispiel daf&uuml;r trat beim Anlegen des Benutzers
	<username>smmsp</username> auf.  Die Installationsprozedur
	schlug an der Stelle fehl, an der &man.mtree.8;
	versuchte, <filename>/var/spool/clientmqueue</filename>
	anzulegen.</para>

      <para>Um dieses Problem zu umgehen,rufen Sie &man.mergemaster.8;
	pr&auml;-buildworld-Modus auf, der mit <option>-p</option> aktiviert
	wird.  In diesem Modus werden nur Dateien verglichen, die f&uuml;r
	den Erfolg von <maketarget>buildworld</maketarget> oder
	<maketarget>installworld</maketarget> essentiell sind.  Wenn Ihre
	alte Version von <command>mergemaster</command> die Option
	<option>-p</option> noch nicht unterst&uuml;tzt, nehmen Sie beim
	ersten Lauf die neue Version aus dem Quellbaum:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Wenn Sie besonders paranoid sind, sollten Sie Ihr System nach
	  Dateien absuchen, die der Gruppe, die Sie umbenennen oder
	  l&ouml;schen, geh&ouml;ren:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>Das obige Kommando zeigt alle Dateien an, die der Gruppe
	  <replaceable>GID</replaceable> (dies kann entweder ein
	  Gruppenname oder eine numerische ID sein) geh&ouml;ren.</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Wechseln Sie in den Single-User-Modus</title>
      <indexterm><primary>Single-User-Modus</primary></indexterm>

      <para>Sie k&ouml;nnen das System im Single-User-Modus
        &uuml;bersetzen.  Abgesehen davon, dass dies etwas schneller
	ist, werden bei der Installation des Systems viele wichtige Dateien,
	wie die Standard-Systemprogramme, die Bibliotheken und
	Include-Dateien, ver&auml;ndert.  Sie bringen sich in
	Schwierigkeiten, wenn Sie diese Dateien auf einem laufenden System
	ver&auml;ndern, besonders dann, wenn zu dieser Zeit Benutzer auf
	dem System aktiv sind.</para>

      <indexterm><primary>Mehrbenutzermodus</primary></indexterm>
      <para>Eine andere Methode &uuml;bersetzt das System im
        Mehrbenutzermodus und wechselt f&uuml;r die Installation in den
	Single-User-Modus.  Wenn Sie diese Methode benutzen wollen, warten
	Sie mit den folgenden Schritten, bis der Bau des Systems fertig
	ist und Sie mit <maketarget>installkernel</maketarget> oder
	<maketarget>installworld</maketarget> installieren wollen.</para>

      <para>Als Superuser k&ouml;nnen Sie mit dem folgenden Kommando ein
        laufendes System in den Single-User-Modus bringen:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>Alternativ k&ouml;nnen Sie das System mit der Option
        <quote>single user</quote> in den Single-User-Modus booten.
	Danach geben Sie die folgenden Befehle ein:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Die Kommandos &uuml;berpr&uuml;fen die Dateisysteme,
        h&auml;ngen <filename>/</filename> wieder beschreibbar ein,
	h&auml;ngen dann alle anderen UFS Dateisysteme aus
	<filename>/etc/fstab</filename> ein und aktivieren den
	Swap-Bereich.</para>

        <note>
	  <para>Zeigt Ihre CMOS-Uhr die lokale Zeit und nicht GMT an, dies
	    erkennen Sie daran, dass &man.date.1; die
	    falsche Zeit und eine flasche Zeitzone anzeigt, setzen Sie das
	    folgende Kommando ab:</para>
<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	  <para>Dies stellt sicher, dass Ihre Zeitzone richtig
	    eingestellt ist.  Ohne dieses Kommando werden Sie
	    vielleicht sp&auml;ter Probleme bekommen.</para>
        </note>

    </sect2>

    <sect2>
      <title>Entfernen Sie <filename>/usr/obj</filename></title>

      <para>Die neugebauten Teile des Systems werden in der Voreinstellung
        unter <filename>/usr/obj</filename> gespeichert.  Die Verzeichnisse
	dort spiegeln die Struktur unter
	<filename>/usr/src</filename>.</para>

      <para>Sie k&ouml;nnen den <command>make buildworld</command> Prozess
        beschleunigen, indem Sie dieses Verzeichnis entfernen.  Dies
	erspart Ihnen zudem einigen &Auml;rger aufgrund von
	Abh&auml;ngigkeiten.</para>

      <para>Einige Dateien unter <filename>/usr/obj</filename> sind
        vielleicht durch die <option>immutable</option>-Option
	(siehe &man.chflags.1;) schreibgesch&uuml;tzt, die vor dem
	L&ouml;schen entfernt werden muss.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 id="updating-upgrading-compilebase">
      <title>&Uuml;bersetzen der Quellen des Basissystems</title>

      <sect3>
	<title>Sichern der Ausgaben</title>

	<para>F&uuml;r den Fall, dass etwas schief geht, sollten Sie
	  die Ausgaben von &man.make.1; in einer Datei sichern, damit Sie
	  eine Kopie der Fehlermeldung besitzen.  Das mag Ihnen nicht
	  helfen, den Fehler zu finden, kann aber anderen helfen, wenn Sie
	  Ihr Problem in einer der &os;-Mailinglisten schildern.</para>

	<para>Dazu k&ouml;nnen Sie einfach das Kommando &man.script.1;
	  benutzen, dem Sie beim Aufruf als Parameter den Dateinamen
	  f&uuml;r die Ausgaben mitgeben.  Setzen Sie das Kommando
	  unmittelbar vor dem Neubau ab und geben Sie
	  <userinput>exit</userinput> ein, wenn der Bau abgeschlossen
	  ist:</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make <replaceable>TARGET</replaceable></userinput>
<emphasis>&hellip; Ausgaben des Kommandos &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Sichern Sie die Ausgaben nicht in <filename>/tmp</filename>,
	  da dieses Verzeichnis beim n&auml;chsten Boot aufger&auml;umt
	  werden kann.  Ein geeigneteres Verzeichnis ist
	  <filename>/var/tmp</filename>, wie im vorigen Beispiel gezeigt,
	  oder das Heimatverzeichnis von <username>root</username>.</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>&Uuml;bersetzen des Basissystems</title>

	<para>Wechseln Sie in das Verzeichnis, in dem die Quellen liegen
	  (in der Voreinstellung ist das
	  <filename>/usr/src</filename>):</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Zum Neubau der Welt benutzen Sie &man.make.1;.  Dieses
	  Kommando liest ein <filename>Makefile</filename>, das Anweisungen
	  enth&auml;lt, wie die Programme, aus denen &os; besteht, zu bauen
	  sind und in welcher Reihenfolge diese zu bauen sind.</para>

	<para>Ein typischer Aufruf von <command>make</command> sieht wie
	  folgt aus:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

	<para>In diesem Beispiel ist
	  <option>-<replaceable>x</replaceable></option> eine Option, die
	  Sie an &man.make.1; weitergeben wollen.  Eine Liste g&uuml;ltiger
	  Optionen finden Sie in der &man.make.1; Manualpage.</para>

	<para>Das Verhalten eines <filename>Makefile</filename>s wird von
	  Variablen bestimmt.  Mit
	  <option>-D<replaceable>VARIABLE</replaceable></option> setzen Sie
	  eine Variable.  Diese Variablen sind dieselben, die auch in
	  <filename>/etc/make.conf</filename> gesetzt werden, dies ist nur
	  ein alternativer Weg, Variablen zu setzen.</para>

	<para>Um zu verhindern, dass die <quote>profiled</quote>
	  Bibliotheken gebaut werden, rufen Sie <command>make</command> wie
	  folgt auf:</para>
	<screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>target</replaceable></userinput></screen>

	<para>Dieser Aufruf entspricht dem folgenden Eintrag in
	  <filename>/etc/make.conf</filename>:</para>

	<programlisting>NO_PROFILE=    true     #    Avoid compiling profiled libraries</programlisting>

	<para>Jedes <filename>Makefile</filename> definiert einige
	  <quote>Ziele</quote>, die festlegen, was genau zu tun ist.  Mit
	  <replaceable>target</replaceable> w&auml;hlen Sie eins dieser
	  Ziele aus.</para>

	<para>Einige Ziele im <filename>Makefile</filename> sind nicht
	  f&uuml;r den Endanwender gedacht, sondern unterteilen den
	  Bauprozess in eine Reihe von Einzelschritten.</para>

	<para>Im Regelfall m&uuml;ssen Sie &man.make.1; keine Parameter
	  mitgeben, so dass Ihre Kommandozeile wie folgt aussehen
	  wird:</para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>

	<para><replaceable>target</replaceable> steht dabei f&uuml;r
	  die verschiedenen Ziele.  Das erste Ziel sollte immer
	  <makevar>buildworld</makevar> sein.</para>

	<para>Mit <maketarget>buildworld</maketarget> wird ein kompletter
	  Baum unterhalb von <filename>/usr/obj</filename> gebaut, der mit
	  <maketarget>installworld</maketarget>, einem weiteren Ziel, auf
	  dem System installiert werden kann.</para>

	<para>&Uuml;ber seperate Optionen zu verf&uuml;gen, ist aus
	  mehreren Gr&uuml;nden n&uuml;tzlich.  Erstens
	  k&ouml;nnen Sie das System auf einem laufenden System bauen, da die
	  Bauprozedur abgekapselt vom Rest des Systems ist.  Das System
	  l&auml;sst sich im Mehrbenutzermodus ohne negative
	  Seiteneffekte bauen.  Die Installation mit
	  <maketarget>installworld</maketarget> sollte aber immer noch im
	  Single-User-Modus erfolgen.</para>

	<para>Zweitens k&ouml;nnen Sie NFS benutzen, um mehrere Maschinen
	  in Ihrem Netzwerk zu aktualisieren.  Wenn Sie die Maschinen
	  <hostid>A</hostid>, <hostid>B</hostid> und <hostid>C</hostid>
	  aktualisieren wollen, lassen sie <command>make
	    buildworld</command> und <command>make installworld</command> auf
	  <hostid>A</hostid> laufen.  Auf den Maschinen <hostid>B</hostid>
	  und <hostid>C</hostid> k&ouml;nnen Sie die
	  Verzeichnisse <filename>/usr/src</filename> und
	  <filename>/usr/obj</filename> von <hostid>A</hostid> einh&auml;ngen
	  und brauchen dort nur noch <command>make installworld</command>
	  auszuf&uuml;hren, um die Bauresultate zu installieren.</para>

	<para>Obwohl das Ziel <maketarget>world</maketarget> noch
	  existiert, sollten Sie es wirklich nicht mehr benutzen.</para>

	<para>Um das System zu bauen, setzen Sie das folgende Kommando
	  ab:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Mit <option>-j</option> k&ouml;nnen Sie
	  <command>make</command> anweisen, mehrere Prozesse zu starten.
	  Besonders effektiv ist das auf Mehrprozessor-Systemen.  Da aber
	  der &Uuml;bersetzungsprozess haupts&auml;chlich von IO statt
	  der CPU bestimmt wird, ist diese Option auch auf
	  Einprozessor-Systemen n&uuml;tzlich.</para>

	<para>Auf einem typischen Einprozessor-System k&ouml;nnen Sie den
	  folgenden Befehl absetzen:</para>

	<screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; wird dann bis zu vier Prozesse gleichzeitig
	  laufen lassen.  Erfahrungsberichte aus den Mailinglisten zeigen,
	  dass dieser Aufruf typischerweise den besten
	  Geschwindigkeitsgewinn bringt.</para>

	<para>Wenn Sie ein Mehrprozessor-System besitzen und SMP in Ihrem
	  Kernel konfiguriert ist, probieren Sie Werte zwischen 6 und 10
	  aus.</para>
      </sect3>

      <sect3>
	<title>Laufzeiten</title>
	<indexterm>
	  <primary>Bau des Basissystems</primary>
	  <secondary>Laufzeiten</secondary>
	</indexterm>

	<para>Die Laufzeit eines Baus wird von vielen Faktoren
	  beeinflusst, ein aktuelles System ben&ouml;tigt aber etwa
	  zwei Stunden um &os.stable; zu bauen.  Der Bau von
	  &os.current; dauert etwas l&auml;nger.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>&Uuml;bersetzen und Installation des Kernels</title>
      <indexterm>
        <primary>Kernel</primary>
	<secondary>&Uuml;bersetzen</secondary>
      </indexterm>

      <para>Um das Beste aus Ihrem System zu holen, sollten Sie einen neuen
	Kernel kompilieren.  Praktisch gesehen ist das sogar notwendig, da
	sich einige Datenstrukturen ge&auml;ndert haben und Programme wie
	&man.ps.1; oder &man.top.1; nur mit einem Kernel zusammen arbeiten,
	der auch zu dem entsprechenden Quellcode passt.</para>

      <para>Am einfachsten und sichersten bauen Sie dazu den
        <filename>GENERIC</filename> Kernel.  Obwohl der
	<filename>GENERIC</filename> Kernel vielleicht nicht alle
	Ihre Ger&auml;te unterst&uuml;tzt, sollte er alles enthalten,
	um das System in den Single-User-Modus zu booten.  Dies ist auch
	ein guter Test, um zu sehen, dass das System
	ordnungsgem&auml;&szlig; funktioniert.  Nachdem Sie mit
	<filename>GENERIC</filename> gebootet und sichergestellt haben,
	dass Ihr System funktioniert, k&ouml;nnen Sie einen neuen
	Kernel mit Ihrer Konfigurationsdatei bauen.</para>

      <para>In aktuellen &os;-Versionen m&uuml;ssen Sie das
	<link linkend="make-buildworld">Basissystem neu bauen</link>,
	bevor Sie einen neuen Kernel erstellen.</para>

      <note>
	<para>Wenn Sie einen angepassten Kernel erstellen wollen und
	  bereits &uuml;ber eine Konfigurationsdatei verf&uuml;gen,
	  geben Sie diese, wie im folgenden Beispiel gezeigt, auf der
	  Kommandozeile an:</para>

        <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>

      </note>

      <para>Wenn <varname>kern.securelevel</varname> einen Wert
	gr&ouml;&szlig;er als <literal>1</literal> besitzt
	<emphasis>und</emphasis> der Kernel mit <literal>noschg</literal>
	oder &auml;hnlichen Optionen gesch&uuml;tzt ist, m&uuml;ssen Sie
	<maketarget>installkernel</maketarget> im Einbenutzermodus
	ausf&uuml;hren.  Wenn das nicht der Fall ist, sollten die beiden
	Kommandos problemlos im Mehrbenutzermodus laufen.  Weitere
	Informationen &uuml;ber <varname>kern.securelevel</varname> finden
	Sie in &man.init.8; und &man.chflags.1; erl&auml;utert Optionen, die
	Sie auf Dateien setzen k&ouml;nnen.</para>
    </sect2>

    <sect2>
      <title>Booten Sie in den Single-User-Modus</title>
      <indexterm><primary>Single-User-Modus</primary></indexterm>

      <para>Um zu pr&uuml;fen, ob der neue Kernel funktioniert, sollten Sie
        in den Single-User-Modus booten.  Folgen Sie dazu der Anleitung aus
	<xref linkend="makeworld-singleuser">.</para>
    </sect2>

    <sect2 id="make-installworld">
      <title>Installation des Systems</title>

      <para>Wenn Sie <command>make buildworld</command> benutzt haben, um
        das System zu bauen, sollten Sie jetzt
	<maketarget>installworld</maketarget> benutzen, um es zu
	installieren.  Rufen Sie dazu das folgende Kommando auf:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Wenn Sie mit dem <command>make buildworld</command> Kommando
	  Variablen verwenden haben, m&uuml;ssen Sie dieselben Variablen
	  auch bei dem <command>make installworld</command> Kommando
	  angeben.  Auf die anderen Optionen trifft das nur bedingt zu:
	  <option>-j</option> darf mit <maketarget>installworld</maketarget>
	  nicht benutzt werden.</para>

	<para>Sie haben zum Bauen die folgende Kommandozeile
	  verwendet:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>Bei der Installation setzen Sie dann das folgende Kommando
	  ab:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>W&uuml;rden Sie die Variable bei der Installation weglassen,
	  so w&uuml;rde das System versuchen, die <quote>profiled</quote>
	  Bibliotheken, die aber gar nicht gebaut wurden, zu
	  installieren.</para>
      </note>
    </sect2>

    <sect2>
      <title>Aktualisieren der von <command>make installworld</command>
        ausgelassenen Dateien</title>

      <para>Neue oder ge&auml;nderte Konfigurationsdateien aus einigen
        Verzeichnissen, besonders <filename>/etc</filename>,
	<filename>/var</filename> und <filename>/usr</filename> werden bei
	der Installationsprozedur nicht ber&uuml;cksichtigt.</para>

      <para>Sie k&ouml;nnen diese Dateien mit &man.mergemaster.8;
        aktualisieren.  Alternativ k&ouml;nnen Sie das auch manuell
	durchf&uuml;hren, obwohl wir diesen Weg nicht empfehlen.  Egal
	welchen Weg Sie beschreiten, sichern Sie vorher den Inhalt von
	<filename>/etc</filename> f&uuml;r den Fall, dass etwas schief
	geht.</para>

      <sect3 id="mergemaster">
        <sect3info>
	  <authorgroup>
	    <author>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	      <contrib>Beigetragen von </contrib>
	    </author>
	  </authorgroup>
        </sect3info>
	<title><command>mergemaster</command></title>
        <indexterm><primary><command>mergemaster</command></primary></indexterm>

	<para>Das Bourne-Shell Skript &man.mergemaster.8; hilft Ihnen dabei,
	  die Unterschiede zwischen den Konfigurationsdateien in
	  <filename>/etc</filename> und denen im Quellbaum unter
	  <filename>/usr/src/etc</filename> zu finden.
	  <command>mergemaster</command> ist der empfohlene Weg, Ihre
	  Systemkonfiguration mit dem Quellbaum abzugleichen.</para>

	<para>Rufen Sie <command>mergemaster</command> einfach auf und
	  schauen Sie zu.  Ausgehend von <filename>/</filename> wird
	  <command>mergemaster</command> einen virtuellen Root-Baum
	  aufbauen und darin die neuen Konfigurationsdateien ablegen.
	  Diese Dateien werden dann mit den auf Ihrem System installierten
	  verglichen.  Unterschiede zwischen den Dateien werden im
	  &man.diff.1;-Format dargestellt.  Neue oder ge&auml;nderte Zeilen
	  werden mit <option>+</option> gekennzeichnet.  Zeilen die
	  gel&ouml;scht oder ersetzt werden, sind mit einem
	  <option>-</option> gekennzeichnet.  Das Anzeigeformat wird in
	  &man.diff.1; genauer erkl&auml;rt.</para>

	<para>&man.mergemaster.8; zeigt Ihnen jede ge&auml;nderte Datei an
	  und Sie haben die Wahl, die neue Datei (in
	  <command>mergemaster</command> wird sie tempor&auml;re Datei
	  genannt) zu l&ouml;schen, sie unver&auml;ndert zu installieren,
	  den Inhalt der neuen Datei mit dem Inhalt der alten Datei
	  abzugleichen, oder die &man.diff.1; Ausgabe noch einmal zu
	  sehen.  Sie k&ouml;nnen die aktuelle Datei auch
	  &uuml;berspringen, sie wird dann noch einmal angezeigt, nachdem
	  alle anderen Dateien abgearbeitet wurden.  Sie erhalten Hilfe,
	  wenn Sie bei der Eingabeaufforderung von
	  <command>mergemaster</command> ein <keycap>?</keycap>
	  eingeben.</para>

	<para>Wenn Sie die tempor&auml;re Datei l&ouml;schen, geht
	  <command>mergemaster</command> davon aus, dass Sie Ihre
	  aktuelle Datei behalten m&ouml;chten.  W&auml;hlen Sie die Option
	  bitte nur dann, wenn Sie keinen Grund sehen, die aktuelle Datei
	  zu &auml;ndern.</para>

	<para>Wenn Sie die tempor&auml;re Datei installieren, wird Ihre
	  aktuelle Datei mit der neuen Datei &uuml;berschrieben.  Sie
	  sollten alle unver&auml;nderten Konfigurationsdateien auf diese
	  Weise aktualisieren.</para>

	<para>Wenn Sie sich entschlie&szlig;en den Inhalt beider Dateien
	  abzugleichen, wird ein Texteditor aufgerufen, indem Sie beide
	  Dateien nebeneinander betrachten k&ouml;nnen.  Mit der Taste
	  <keycap>l</keycap> &uuml;bernehmen Sie die aktuelle Zeile der
	  links dargestellten Datei, mit der Taste <keycap>r</keycap>
	  &uuml;bernehmen Sie die Zeile der rechts dargestellten Datei.
	  Das Ergebnis ist eine Datei, die aus Teilen der beiden
	  urspr&uuml;nglichen Dateien besteht und installiert werden kann.
	  Dieses Verfahren wird gew&ouml;hnlich bei ver&auml;nderten
	  Dateien genutzt.</para>

	<para>Haben Sie sich entschieden die Differenzen noch einmal
	  anzuzeigen, zeigt Ihnen &man.mergemaster.8; dieselbe Ausgabe, die
	  Sie gesehen haben, bevor die Eingabeaufforderung ausgegeben
	  wurde.</para>

	<para>Wenn &man.mergemaster.8; alle Systemdateien abgearbeitet hat,
	  werden weitere Optionen abgefragt.  Sie werden unter
	  Umst&auml;nden gefragt, ob Sie die Passwort-Datei neu bauen
	  lassen wollen.  Am Ende haben Sie die M&ouml;glichkeit, den Rest
	  der tempor&auml;ren Dateien zu l&ouml;schen.</para>
      </sect3>

      <sect3>
	<title>Manueller Abgleich der Konfigurationsdateien</title>

	<para>Wenn Sie den Abgleich lieber selbst ausf&uuml;hren wollen,
	  beachten Sie bitte, dass Sie nicht einfach die Dateien aus
	  <filename>/usr/src/etc</filename> nach <filename>/etc</filename>
	  kopieren k&ouml;nnen.  Einige dieser Dateien m&uuml;ssen zuerst
	  <emphasis>installiert</emphasis> werden, bevor sie benutzt werden
	  k&ouml;nnen.  Das liegt daran, dass
	  <filename>/usr/src/etc</filename> keine exakte Kopie von
	  <filename>/etc</filename> ist.  Zudem gibt es Dateien, die sich
	  in <filename>/etc</filename> befinden aber nicht in
	  <filename>/usr/src/etc</filename>.</para>

	<para>Wenn Sie, wie empfohlen, <command>mergemaster</command>
	  benutzen, k&ouml;nnen Sie direkt in den n&auml;chsten
	  <link linkend="updating-upgrading-rebooting">Abschnitt</link>
	  wechseln.</para>

	<para>Am einfachsten ist es, wenn Sie die neuen Dateien in ein
	  tempor&auml;res Verzeichnis installieren und sie nacheinander auf
	  Differenzen zu den bestehenden Dateien durchsehen.</para>

	<warning>
	  <title>Sichern Sie die Inhalte von <filename>/etc</filename></title>

	  <para>Obwohl bei dieser Prozedur keine Dateien in
	    <filename>/etc</filename> automatisch ver&auml;ndert werden,
	    sollten Sie dessen Inhalt an einen sicheren Ort
	    kopieren:</para>

	    <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	    <para>Mit <option>-R</option> wird rekursiv kopiert und
	      <option>-p</option> erh&auml;lt die Attribute der kopierten
	      Dateien, wie Zugriffszeiten und Eigent&uuml;mer.</para>
	</warning>

	<para>Sie m&uuml;ssen die neuen Dateien in einem tempor&auml;ren
	  Verzeichnis installieren.  <filename>/var/tmp/root</filename> ist
	  eine gute Wahl f&uuml;r das tempor&auml;re Verzeichnis, in dem
	  auch noch einige Unterverzeichnisse angelegt werden
	  m&uuml;ssen.</para>

        <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

	<para>Die obigen Kommandos bauen die n&ouml;tige
	  Verzeichnisstruktur auf und installieren die neuen Dateien in
	  diese Struktur.  Unterhalb von <filename>/var/tmp/root</filename>
	  wurden einige leere Verzeichnisse angelegt, die Sie am besten wie
	  folgt entfernen:</para>

        <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

	<para>Im obigen Beispiel wurde die Fehlerausgabe nach
	  <filename>/dev/null</filename> umgeleitet, um die Warnungen
	  &uuml;ber nicht leere Verzeichnisse zu unterdr&uuml;cken.</para>

	<para><filename>/var/tmp/root</filename> enth&auml;lt nun alle
	  Dateien, die unterhalb von <filename>/</filename> installiert
	  werden m&uuml;ssen.  Sie m&uuml;ssen nun jede dieser Dateien mit
	  den schon existierenden Dateien vergleichen.</para>

	<para>Einige der installierten Dateien unter
	  <filename>/var/tmp/root</filename> beginnen mit einem
	  <quote>.</quote>.
	  Als dieses Kapitel verfasst wurde, waren das nur die
	  Startdateien f&uuml;r die Shells in
	  <filename>/var/tmp/root/</filename> und
	  <filename>/var/tmp/root/root/</filename>.  Abh&auml;ngig davon,
	  wann Sie dieses Handbuch lesen, k&ouml;nnen mehr Dateien dieser
	  Art existieren.  Verwenden Sie <command>ls -a</command> um
	  sicherzustellen, dass Sie alle derartigen Dateien
	  finden.</para>

	<para>Benutzen Sie &man.diff.1; um Unterschiede zwischen zwei
	  Dateien festzustellen:</para>

        <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

	<para>Das obige Kommando zeigt Ihnen die Unterschiede zwischen der
	  installierten Version von <filename>/etc/shells</filename> und
	  der neuen Version in <filename>/var/tmp/root/etc/shells</filename>.
	  Entscheiden Sie anhand der Unterschiede, ob
	  Sie beide Dateien abgleichen oder die neue Version &uuml;ber die
	  alte kopieren wollen.</para>

	<tip>
	  <title>Versehen Sie das tempor&auml;re Verzeichnis mit einem
	    Zeitstempel</title>

	  <para>Wenn Sie das System oft neu bauen, m&uuml;ssen Sie
	    <filename>/etc</filename> genauso oft aktualisieren.  Dies kann
	    mit der Zeit sehr l&auml;stig werden.</para>

	  <para>Sie k&ouml;nnen das Verfahren beschleunigen, wenn Sie sich
	    eine Kopie der Dateien behalten, die Sie zuletzt nach
	    <filename>/etc</filename> installiert haben.  Das folgende
	    Verfahren zeigt Ihnen, wie das geht.</para>

	  <procedure>
	    <step>
	      <para>Folgen Sie der normalen Prozedur um das System zu
	        bauen.  Wenn Sie <filename>/etc</filename> und die anderen
		Verzeichnisse aktualisieren wollen, geben Sie dem
		tempor&auml;ren Verzeichnis einen Namen, der das aktuelle
		Datum enth&auml;lt.  Wenn Sie dies zum Beispiel am
		14.&nbsp;Februar 1998 durchf&uuml;hrten, h&auml;tten Sie die
		folgenden Kommandos abgesetzt:</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	    </step>

	    <step>
	      <para>Gleichen Sie die &Auml;nderungen entsprechend der
		Anleitung von oben ab.</para>

	      <para>Wenn Sie fertig sind, entfernen Sie das Verzeichnis
		<filename>/var/tmp/root-19980214</filename>
		<emphasis>nicht</emphasis>.</para>
	    </step>

	    <step>
	      <para>Wenn Sie nun neue Quellen heruntergeladen und gebaut
	        haben, folgen Sie bitte Schritt 1.  Wenn Sie zwischen den
		Updates eine Woche gewartet haben, haben Sie nun ein
		Verzeichnis mit dem Namen
		<filename>/var/tmp/root-19980221</filename>.</para>
	    </step>

	    <step>
	      <para>Sie k&ouml;nnen nun die Unterschiede, die sich in einer
		Woche ergeben haben, sehen, indem Sie &man.diff.1; rekursiv
		anwenden:</para>

	      <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	      <para>&Uuml;blicherweise sind die Differenzen, die Sie jetzt
	        sehen, kleiner als die Differenzen zwischen
		<filename>/var/tmp/root-19980221/etc</filename> und
		<filename>/etc</filename>.  Da die angezeigten Differenzen
		kleiner sind, ist es jetzt einfacher den Abgleich der
		Dateien durchzuf&uuml;hren.</para>
	    </step>

	    <step>
	      <para>Sie k&ouml;nnen nun das &auml;lteste der beiden
	        <filename>/var/tmp/root-*</filename> Verzeichnisse
	        entfernen:</para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	    </step>

	    <step>
	      <para>Wiederholen Sie diesen Prozess jedes Mal wenn Sie
		Dateien in <filename>/etc</filename> abgleichen
		m&uuml;ssen.</para>
	    </step>
	  </procedure>

	  <para>Mit &man.date.1; k&ouml;nnen Sie den Verzeichnisnamen
	    automatisch erzeugen:</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
      </sect3>
    </sect2>

    <sect2 id="updating-upgrading-rebooting">
      <title>Das System neu starten</title>

      <para>Sie sind nun am Ende der Prozedur angelangt.  Nachdem Sie sich
        davon &uuml;berzeugt haben, dass Ihr System funktioniert,
        starten Sie Ihr System mit &man.shutdown.8; neu:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Ende</title>

      <para>Herzlichen Gl&uuml;ckwunsch!  Sie haben gerade erfolgreich Ihr
        &os; System aktualisiert.</para>

      <para>Es ist &uuml;brigens leicht einen Teil des Systems
        wiederherzustellen, f&uuml;r den Fall, dass Ihnen ein kleiner
	Fehler unterlaufen ist.  Wenn Sie beispielsweise w&auml;hrend des
	Updates oder Abgleichs <filename>/etc/magic</filename> aus Versehen
	gel&ouml;scht haben, wird &man.file.1; nicht mehr funktionieren.
	In diesem Fall k&ouml;nnen Sie das Problem mit dem folgenden
	Kommando beheben:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Fragen</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Muss ich wirklich immer alles neu bauen, wenn sich
	      etwas ge&auml;ndert hat?</para>
	  </question>

	  <answer>
	    <para>Darauf gibt es keine einfache Antwort.  Was zu tun ist,
	      h&auml;ngt von den &Auml;nderungen ab.  Es lohnt
	      wahrscheinlich nicht, alles neu zu bauen, wenn sich bei einem
	      <application>CVSup</application>-Lauf nur die folgenden
	      Dateien ge&auml;ndert haben:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>In diesem Fall k&ouml;nnen Sie in die entsprechenden
	      Unterverzeichnisse wechseln und dort <command>make all
	      install</command> ausf&uuml;hren.  Wenn sich allerdings etwas
	      Wichtiges, wie <filename>src/lib/libc/stdlib</filename>,
	      ge&auml;ndert hat, sollten Sie die Welt oder
	      mindestens die statisch gelinkten Teile des Systems (sowie
	      Ihre statisch gelinkten Erg&auml;nzungen) neu bauen.</para>

	    <para>Letztendlich ist das Ihre Entscheidung.  Sie sind
	      vielleicht damit zufrieden, das System alle zwei Wochen neu
	      zu bauen und in der Zwischenzeit die anfallenden
	      &Auml;nderungen zu sammeln.  Wenn Sie sich zutrauen, alle
	      Abh&auml;ngigkeiten zu erkennen, bauen Sie vielleicht auch
	      nur die ge&auml;nderten Sachen neu.</para>

	    <para>Das h&auml;ngt nat&uuml;rlich auch noch davon ab, wie oft
	      Sie ein Update durchf&uuml;hren wollen und ob Sie &os.stable;
	      oder &os.current; benutzen.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Der Bau bricht mit vielen
	      <errorname>Signal 11</errorname>-Fehlern (oder anderen
	      Signalnummern) ab.  Was ist da passiert?</para>
	  </question>
	  <indexterm><primary>Signal 11</primary></indexterm>

	  <answer>
	    <para>Normalerweise zeigen diese Meldungen Hardwarefehler an.
	      Ein Neubau der Welt ist ein guter Belastungstest f&uuml;r
	      Ihre Hardware und zeigt oft Probleme mit dem Speicher auf.
	      Dies &auml;u&szlig;ert sich darin, dass der Kompiler
	      mit dem Erhalt von seltsamen Signalen abbricht.</para>

	    <para>Es liegt garantiert ein Hardwarefehler vor, wenn ein
	      neuer &Uuml;bersetzungslauf an einer anderen Stelle
	      abbricht.</para>

	    <para>In diesem Fall k&ouml;nnen Sie nur einzelne Komponenten
	      Ihres Systems tauschen, um zu bestimmen, welche Komponente den
	      Fehler verursacht.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kann ich <filename>/usr/obj</filename> l&ouml;schen, wenn
	      ich fertig bin?</para>
	  </question>

	  <answer>
	    <para>Kurze Antwort: Ja.</para>

	    <para>In <filename>/usr/obj</filename> werden alle Dateien
	      abgelegt, die w&auml;hrend der &Uuml;bersetzungsphase erstellt
	      wurden.  Dieses Verzeichnis wird in einem der ersten Schritte
	      der Bauprozedur entfernt.  Es macht daher
	      wenig Sinn, dieses Verzeichnis zu behalten und Sie setzen
	      eine Menge Plattenplatz, momentan ungef&auml;hr 340&nbsp;MB,
	      frei, wenn Sie es l&ouml;schen.</para>

	    <para>Wenn Sie allerdings genau wissen, was Sie tun, k&ouml;nnen
	      Sie diesen Schritt bei <command>make buildworld</command>
	      auslassen.  Nachfolgende Bauprozeduren werden dadurch erheblich
	      schneller, da die meisten Quelldateien nicht mehr neu
	      &uuml;bersetzt werden.  Daf&uuml;r k&ouml;nnen aber subtile
	      Abh&auml;ngigkeitsprobleme entstehen, die dazu f&uuml;hren,
	      dass der Bau auf merkw&uuml;rdige Weise abbrechen kann.
	      Dies f&uuml;hrt h&auml;ufig zu unn&ouml;tigen Diskussionen auf
	      den &os; Mailinglisten, wenn sich jemand &uuml;ber einen
	      kaputten Bau beschwert, aber nicht sieht, dass er
	      Probleme hat, weil er eine Abk&uuml;rzung genommen hat.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kann ein abgebrochener Bau weitergef&uuml;hrt
	      werden?</para>
	  </question>

	  <answer>
	    <para>Das h&auml;ngt davon ab, wieweit der Bauprozess
	      fortgeschritten ist.</para>

	    <para><emphasis>&Uuml;blicherweise</emphasis> werden
	      essentielle Werkzeuge, wie &man.gcc.1; und &man.make.1;,
	      und die Systembibliotheken w&auml;hrend des Bauprozesses
	      neu erstellt (dies ist aber keine allgemein g&uuml;ltige
	      Regel).  Die neu erstellen Werkzeuge und Bibliotheken werden
	      dann benutzt, um sich selbst noch einmal zu bauen, und wieder
	      installiert.  Anschlie&szlig;end wird das Gesamtsystem mit
	      den neu erstellten Systemdateien gebaut.</para>

	    <para>Wenn Sie sich im letzten Schritt befinden und Sie wissen,
	      dass Sie dort sind, weil Sie durch die Ausgaben, die Sie
	      ja sichern, der Bauprozedur gesehen haben, k&ouml;nnen Sie
	      mit ziemlicher Sicherheit den Bau weiterf&uuml;hren:</para>

	    <screen><emphasis>&hellip; Fehler beheben &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Diese Variablen verhindern,
	      dass <command>make buildworld</command> die vorher erstellten
	      Dateien l&ouml;scht.</para>

	    <para>Das Sie sich im letzten Schritt der Bauprozedur
	      befinden, erkennen Sie daran, dass Sie in der Ausgabe die
	      folgenden Zeilen finden:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>Wenn Sie diese Meldung nicht finden, oder sich nicht sicher
	      sind, dann ist es besser, noch einmal ganz von Vorne
	      anzufangen.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Wie kann ich den Bauprozesss beschleunigen?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Bauen Sie im Single-User-Modus.</para>
	      </listitem>

	      <listitem>
		<para>Legen Sie <filename>/usr/src</filename> und
		  <filename>/usr/obj</filename> in getrennte Dateisysteme auf
		  unterschiedliche Festplatten.  Benutzen Sie nach
		  M&ouml;glichkeit auch getrennte Platten-Controller.</para>
	      </listitem>

	      <listitem>
		<para>Noch besser ist es, diese Dateisysteme auf mehrere
		  Festplatten mit &man.ccd.4; zu verteilen.</para>
	      </listitem>

	      <listitem>
		<para>Bauen Sie die <quote>profiled</quote>-Bibliotheken,
		  die Sie wahrscheinlich sowieso nicht brauchen, nicht.
		  <filename>/etc/make.conf</filename> sollte dazu
		  <literal>NO_PROFILE=true</literal> enthalten.</para>
	      </listitem>

	      <listitem>
		<para>Setzen Sie die <makevar>CFLAGS</makevar> in
		  <filename>/etc/make.conf</filename> auf <option>-O
		    -pipe</option>.  Die Optimierungsstufe
		  <option>-O2</option> ist deutlich langsamer und die
		  Performance-Unterschiede zwischen <option>-O</option> und
		  <option>-O2</option> sind vernachl&auml;ssigbar klein.
		  <option>-pipe</option> veranlasst den Kompiler Pipes
		  anstelle von Dateien f&uuml;r die Kommunikation zu
		  benutzen.  Dies spart einige Plattenzugriffe, geht aber
		  auf Kosten des Speichers.</para>
	      </listitem>

	      <listitem>
		<para>Benutzen Sie
		  <option>-j<replaceable>n</replaceable></option>, um
		  mehrere Prozesse parallel laufen zu lassen.
		  Normalerweise beschleunigt dies den Bauprozess
		  unabh&auml;ngig davon, ob Sie ein Einprozessor oder
		  Mehrprozessor System einsetzen.</para>
	      </listitem>

	      <listitem>
		<para>Sie k&ouml;nnen das Dateisystem
		  <filename>/usr/src</filename> mit der Option
		  <option>noatime</option> einh&auml;ngen.  Dies
		  verhindert, dass die Zugriffszeiten der Dateien
		  aktualisiert werden (eine Information, die Sie vielleicht
		  gar nicht brauchen).</para>

		<screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		<warning>
		  <para>Das Beispiel geht davon aus, dass sich
		    <filename>/usr/src</filename> auf einem separaten
		    Dateisystem befindet.  Wenn das nicht der Fall ist,
		    weil das Verzeichnis beispielsweise Teil des
		    <filename>/usr</filename> Dateisystems ist,
		    m&uuml;ssen Sie anstelle von
		    <filename>/usr/src</filename> den Mountpoint des
		    Dateisystems angeben.</para>
		</warning>
	      </listitem>

	      <listitem>
		<para>Das Dateisystem, in dem sich
		  <filename>/usr/obj</filename> befindet, kann mit der
		  Option <option>async</option> eingehangen werden.  Dies
		  bewirkt, dass Schreibzugriffe auf die Platte
		  asynchron stattfinden, das hei&szlig;t ein Schreibzugriff
		  ist sofort beendet, die Daten werden allerdings erst einige
		  Sekunden sp&auml;ter geschrieben.  Dadurch k&ouml;nnen
		  Schreibzugriffe zusammengefasst werden, was einen
		  erheblichen Geschwindigkeitszuwachs mit sich bringen
		  kann.</para>

		<warning>
		  <para>Beachten Sie, dass dies Ihr Dateisystem
		    anf&auml;lliger f&uuml;r Fehler macht.  Im Fall eines
		    Stromausfalls besteht eine erh&ouml;hte
		    Wahrscheinlichkeit, dass das Dateisystem beim
		    Start der Maschine zerst&ouml;rt ist.</para>

		  <para>Wenn sich <filename>/usr/obj</filename> auf einem
		    extra Dateisystem befindet, ist das kein Problem.  Wenn
		    sich allerdings auf diesem Dateisystem noch andere
		    wertvolle Daten befinden, stellen Sie sicher, dass
		    Sie aktuelle Sicherungen besitzen.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Ersetzen Sie <filename>/usr/obj</filename> durch
		    den Mountpoint des entsprechenden Dateisystems, wenn es
		    sich nicht auf einem eigenen Dateisystem
		    befindet.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

        <qandaentry>
          <question>
	    <para>Was mache ich, wenn etwas nicht funktioniert?</para>
          </question>

          <answer>
	    <para>Stellen Sie sicher, dass sich in Ihrer Umgebung
	      keine Reste eines vorherigen Baus befinden.  Das geht ganz
	      einfach:</para>

            <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Ja, <command>make cleandir</command> muss wirklich
	      zweimal aufgerufen werden.</para>

	    <para>Nachdem Sie aufger&auml;umt haben, starten Sie den
	      Bauprozess wieder mit <command>make
	        buildworld</command>.</para>

	    <para>Wenn Sie immer noch Probleme haben, schicken Sie die
	      Fehlermeldungen und die Ausgabe von <command>uname
	        -a</command> an die Mailingliste &a.de.questions;.  Bereiten
	      Sie sich darauf vor, weitere Fragen zu Ihrer Umgebung zu
	      beantworten.</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Installation mehrerer Maschinen</title>

    <para>Wenn Sie mehrere Maschinen besitzen, die Sie alle auf dem
      gleichen Stand halten wollen, ist es eine Verschwendung von
      Ressourcen, die Quellen auf jeder Maschine vorzuhalten und zu
      &uuml;bersetzen.  Die L&ouml;sung dazu ist, eine Maschine den
      Gro&szlig;teil der Arbeit durchf&uuml;hren zu lassen und den anderen
      Maschinen das Ergebnis mit NFS zur Verf&uuml;gung zu stellen.  Dieser
      Abschnitt zeigt Ihnen wie das geht.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Voraussetzungen</title>

      <para>Stellen Sie zuerst eine Liste der Maschinen zusammen, die auf
        demselben Stand sein sollen.  Wir nennen diese Maschinen die
	<emphasis>Baugruppe</emphasis>.  Jede dieser Maschinen kann mit
	einem eigenen Kernel laufen, doch sind die Programme des Userlands
	auf allen Maschinen gleich.  W&auml;hlen Sie aus der Baugruppe eine
	Maschine aus, auf der der Bau durchgef&uuml;hrt wird, den
	<emphasis>Bau-Master</emphasis>.  Dies sollte eine Maschine sein,
	die &uuml;ber die n&ouml;tigen Ressourcen f&uuml;r
	<command>make buildworld</command> und
	<command>make installworld</command> verf&uuml;gt.
	Sie brauchen auch eine
	<emphasis>Testmaschine</emphasis>, auf der Sie die Updates testen,
	bevor Sie sie in Produktion installieren.  Dies sollte eine
	Maschine, eventuell der Bau-Master, sein, die &uuml;ber einen
	l&auml;ngeren Zeitraum nicht zur Verf&uuml;gung stehen kann.</para>

      <para>Alle Maschinen der Baugruppe m&uuml;ssen
        <filename>/usr/obj</filename> und <filename>/usr/src</filename> von
	derselben Maschine an gleichem Ort einh&auml;ngen.  Idealerweise
	befinden sich die beiden Verzeichnisse auf dem Bau-Master auf
	verschiedenen Festplatten, sie k&ouml;nnen allerdings auch auf dem
	Bau-Master &uuml;ber NFS zur Verf&uuml;gung gestellt werden.  Wenn
	Sie mehrere Baugruppen haben, sollte sich
	<filename>/usr/src</filename> auf einem Bau-Master befinden und
	&uuml;ber NFS f&uuml;r den Rest der Maschinen zur Verf&uuml;gung
	gestellt werden.</para>

      <para>Stellen Sie sicher, dass
        <filename>/etc/make.conf</filename> auf allen Maschinen einer
	Baugruppe mit der Datei des Bau-Masters &uuml;bereinstimmt.  Der
	Bau-Master muss jeden Teil des Systems bauen, den irgendeine
	Maschine der Baugruppe ben&ouml;tigt.  Auf dem Bau-Master
	m&uuml;ssen in <filename>/etc/make.conf</filename> alle zu bauenden
	Kernel mit der Variablen <makevar>KERNCONF</makevar> bekannt gegeben
	werden.  Geben Sie dabei den Kernel des Bau-Masters zuerst an.
	F&uuml;r jeden zu bauenden Kernel muss auf dem Bau-Master die
	entsprechende Konfigurationsdatei unter
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
	abgelegt werden.</para>
    </sect2>

    <sect2>
      <title>Installation des Basissystems</title>

      <para>Nach diesen Vorbereitungen k&ouml;nnen Sie mit dem Bau
        beginnen.  Bauen Sie auf dem Bau-Master, wie in <xref
	linkend="make-buildworld"> beschrieben, den Kernel und die Welt,
	installieren Sie aber nichts.  Wechseln Sie auf die Testmaschine
	und installieren Sie den gerade gebauten Kernel.  Wenn diese
	Maschine <filename>/usr/src</filename> und
	<filename>/usr/obj</filename> &uuml;ber NFS bekommt, m&uuml;ssen
	Sie das Netzwerk im Single-User-Modus aktivieren und die beiden
	Dateisysteme einh&auml;ngen.  Am einfachsten ist dies, wenn Sie
	auf der Testmaschine ausgehend vom Mehrbenutzermodus mit
	<command>shutdown now</command> in den Single-User-Modus wechseln.
	Sie k&ouml;nnen dann mit der normalen Prozedur den neuen Kernel
	und das System installieren und anschlie&szlig;end
	<command>mergemaster</command> laufen lassen.  Wenn Sie damit
	fertig sind, k&ouml;nnen Sie die Maschine wieder in den
	Mehrbenutzermodus booten.</para>

      <para>Nachdem Sie sichergestellt haben, dass die Testmaschine
        einwandfrei funktioniert, wiederholen Sie diese Prozedur f&uuml;r
	jede Maschine in der Baugruppe.</para>
    </sect2>

    <sect2>
      <title>Die Ports-Sammlung</title>

      <para>Dasselbe Verfahren k&ouml;nnen Sie auch f&uuml;r die
        Ports-Sammlung anwenden.  Zuerst m&uuml;ssen alle Maschinen einer
	Baugruppe <filename>/usr/ports</filename> von derselben Maschine
	&uuml;ber NFS zur Verf&uuml;gung gestellt bekommen.  Setzen Sie
	dann ein Verzeichnis f&uuml;r die Quellen auf, das sich alle
	Maschinen teilen.  Dieses Verzeichnis k&ouml;nnen Sie in
	<filename>/etc/make.conf</filename> mit der Variablen
	<makevar>DISTDIR</makevar> angeben.  Das Verzeichnis sollte
	f&uuml;r den Benutzer beschreibbar sein, auf den der Benutzer
	<username>root</username> vom NFS Subsystem abgebildet wird.  Jede
	Maschine sollte noch <makevar>WRKDIRPREFIX</makevar> auf ein
	lokales Bauverzeichnis setzen.  Wenn Sie vorhaben, Pakete zu bauen
	und zu verteilen, sollten Sie <makevar>PACKAGES</makevar> auf ein
	Verzeichnis mit den gleichen Eigenschaften wie
	<makevar>DISTDIR</makevar> setzen.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

