<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     Original version 1.59
     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/basics/chapter.sgml,v 1.18 2002/03/28 08:24:18 mheinen Exp $
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
	 <firstname>Chris</firstname>
	 <surname>Shumway</surname>
	 <contrib>Umgeschrieben von </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
    <authorgroup>
      <author>
	 <firstname>Uwe</firstname>
	 <surname>Pierau</surname>
	 <contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Unix Grundlagen</title>
  
  <sect1>
    <title>&Uuml;bersicht</title>
    <indexterm><primary>Grundlagen</primary></indexterm>

   <para>Das folgende Kapitel umfa&szlig;t die grundlegenden Kommandos
     und Funktionsweisen des Betriebssystems FreeBSD.  Viel von dem folgenden
     Material gilt auch f&uuml;r jedes andere Unix-&auml;hnliche System.
     Falls Sie mit dem Material schon vertraut sind, k&ouml;nnen Sie dieses
     Kapitel &uuml;berlesen.  Wenn FreeBSD neu f&uuml;r Sie ist, dann sollten
     Sie dieses Kapitel auf jeden Fall sehr genau lesen.</para>

   <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie folgendes
     wissen:</para>

   <itemizedlist>
     <listitem>
       <para>wie Unix Zugriffsrechte funktionieren,</para>
     </listitem>
     <listitem>
       <para>was Prozesse, D&auml;monen und Signale sind,</para>
     </listitem>
     <listitem>
       <para>was eine Shell ist und wie Sie die Login Umgebung
	 &auml;ndern,</para>
     </listitem>
     <listitem>
       <para>wie Sie mit Texteditoren umgehen, und</para>
     </listitem>
     <listitem>
       <para>wie Sie in den Manual-Pages nach weiteren Informationen
	 suchen k&ouml;nnen.</para>
     </listitem>
   </itemizedlist>

  </sect1>

  <sect1 id="permissions">
    <title>Zugriffsrechte</title>
    <indexterm><primary>Unix</primary></indexterm>

    <para>Die Grundlagen von FreeBSD, das ein direkter Abk&ouml;mmling
      von BSD UNIX ist, st&uuml;tzen sich auf verschiedene UNIX
      Grundkonzepte.  Das erste und ausgepr&auml;gteste: FreeBSD ist
      ein Multi-User Betriebssystem.  Das System erm&ouml;glicht,
      da&szlig; mehrere User gleichzeitig an v&ouml;llig verschiedenen
      und unabh&auml;ngigen Aufgaben arbeiten k&ouml;nnen. Es ist
      verantwortlich f&uuml;r eine gerechte Auf- und Zuteilung von
      Nachfragen nach Hardware- und Peripherieger&auml;ten, Speicher
      und CPU Zeit unter den Usern.</para>

    <para>Da das System mehrere Benutzer unterst&uuml;tzt, hat alles,
      was das System verwaltet, einen Satz von Rechten, die bestimmen, 
      wer die jeweilige Ressource lesen, schreiben oder ausf&uuml;hren 
      darf.  Diese Zugriffsrechte stehen in zwei Achtergruppen, die in
      drei Teile unterteilt sind: einen f&uuml;r den Besitzer der
      Datei, einen f&uuml;r die Gruppe, zu der die Datei geh&ouml;rt
      und einen f&uuml;r alle anderen.  Die numerische Darstellung
      sieht wie folgt aus:</para>

    <indexterm><primary>Zugriffsrechte</primary></indexterm>
    <indexterm>
      <primary>Dateizugriffsrechte</primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Wert</entry>
	    <entry>Zugriffsrechte</entry>
	    <entry>Auflistung im Verzeichnis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Kein Lesen, Kein Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Kein Lesen, Kein Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Kein Lesen, Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Kein Lesen, Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lesen, Kein Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lesen, Kein Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lesen, Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lesen, Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>Verzeichnisse</primary></indexterm>

    <para>Sie k&ouml;nnen <option>-l</option> auf der Kommandozeile
      von &man.ls.1; angeben, um eine ausf&uuml;hrliche Verzeichnisauflistung
      zu sehen, die in einer Spalte die Zugriffsrechte f&uuml;r den
      Besitzer, die Gruppe und alle anderen enth&auml;lt.  Die erste
      Spalte von <command>ls -l</command> k&ouml;nnte wie folgt aussehen:</para>

    <screen>-rw-r--r--</screen>

    <para>Das erste Zeichen von links ist ein Symbol, welches angibt, 
      ob es sich um eine normale Datei, ein Verzeichnis, ein special-
      oder block-Device, ein Socket oder irgendeine andere
      Pseudo-Datei handelt.  Die n&auml;chsten drei Zeichen,
      dargestellt als <literal>rw-</literal>, ergeben die Rechte
      f&uuml;r den Datei-Besitzer.  Die drei Zeichen danach
      <literal>r--</literal> die Rechte der Gruppe, zu der die Datei
      geh&ouml;rt.  Die letzten drei Zeichen, <literal>r--</literal>,
      geben die Rechte f&uuml;r den Rest der Welt an.  Ein Minus
      bedeutet, da&szlig; das Recht nicht gegeben ist.  In diesem Fall
      sind die Zugriffsrechte also: der Eigent&uuml;mer kann die Datei
      lesen und schreiben, die Gruppe kann lesen und alle anderen
      k&ouml;nnen auch nur lesen.  Entsprechend obiger Tabelle
      w&auml;ren die Zugriffsrechte f&uuml;r diese Datei
      <literal>644</literal>, worin jede Ziffer die drei Teile der
      Zugriffsrechte dieser Datei verk&ouml;rpert.</para>

    <para>Das ist alles sch&ouml;n und gut, aber wie kontrolliert das 
      System die Rechte von Hardware Ger&auml;ten?  FreeBSD behandelt
      die meisten Hardware Ger&auml;te als Dateien, welche Programme
      &ouml;ffnen, lesen und mit Daten beschreiben k&ouml;nnen wie
      alle anderen Dateien auch.  Diese Spezial-Dateien sind im
      Verzeichnis <filename>/dev</filename> gespeichert.</para>

    <para>Verzeichnisse werden ebenfalls wie Dateien behandelt.  Sie 
      haben Lese-, Schreib- und Ausf&uuml;hr-Rechte.  Das
      Ausf&uuml;hrungs-Bit hat eine etwas andere Bedeutung f&uuml;r
      ein Verzeichnis als f&uuml;r eine Datei.  Die Ausf&uuml;hrbarkeit 
      eines Verzeichnisses bedeutet, da&szlig; in das Verzeichnis
      zum Beispiel mit <command>cd</command> gewechselt werden kann.
      Das bedeutet auch, da&szlig; in dem Verzeichnis auf Dateien, deren
      Namen bekannt sind, zugegriffen kann, vorausgesetzt die
      Zugriffsrechte der Dateien lassen dies zu.</para>

    <para>Das Leserecht auf einem Verzeichnis erlaubt es, sich den Inhalt
      des Verzeichnisses anzeigen zu lassen.  Um eine Datei mit bekanntem
      Namen in einem Verzeichnis zu l&ouml;schen, m&uuml;ssen auf dem
      Verzeichnis Schreib- <emphasis>und</emphasis> Ausf&uuml;hr-Rechte
      gesetzt sein.</para>

    <para>Es gibt noch mehr Rechte, aber die werden vor allem in
      speziellen Umst&auml;nden benutzt, wie zum Beispiel bei
      SetUID-Binaries und Verzeichnissen mit gesetztem Sticky-Bit.
      Mehr &uuml;ber Zugriffsrechte von Dateien und wie sie gesetzt werden,
      finden Sie in &man.chmod.1;.</para>
  </sect1>

  <sect1 id="dirstructure">
    <title>Verzeichnis-Strukturen</title>
    <indexterm><primary>Verzeichnis Hierarchien</primary></indexterm>

    <para>Die FreeBSD Verzeichnis Hierarchie ist die Grundlange, um
      ein umfassendes Verst&auml;ndnis des Systems zu erlangen.
      Das wichtigste Konzept, das Sie verstehen sollten, ist das
      Root-Verzeichnis <quote>/</quote>.  Dieses Verzeichnis ist das
      erste, das w&auml;hrend des Bootens eingehangen wird.  Es
      enth&auml;lt das notwendige Basissystem um das System in den
      Mehrbenutzerbetrieb zu bringen.  Das Root-Verzeichnis enth&auml;lt
      auch die Mountpunkte anderer Dateisysteme, die sp&auml;ter
      eingehangen werden.</para>
      
    <para>Ein Mountpunkt ist ein Verzeichnis, in das zus&auml;tzliche
      Dateisysteme ins / Verzeichnis eingepflanzt werden k&ouml;nnen.  
      Standard Mountpunkte beinhalten <filename>/usr</filename>, 
      <filename>/var</filename>, <filename>/mnt</filename> und 
      <filename>/cdrom</filename>.  Auf diese Verzeichnisse verweisen
      &uuml;blicherweise Eintr&auml;ge in der Datei
      <filename>/etc/fstab</filename>.  <filename>/etc/fstab</filename> ist
      eine Tabelle mit verschiedenen Dateisystemen und Mountpunkten
      als Referenz des Systems.  Die meisten der Dateisysteme in 
      <filename>/etc/fstab</filename> werden beim Booten automatisch 
      durch das Skript &man.rc.8; gemountet, wenn die zugeh&ouml;rigen
      Eintr&auml;ge nicht mit der Option <option>noauto</option>
      versehen sind.  Konsultieren Sie die &man.fstab.5; Man-Page
      f&uuml;r mehr Informationen &uuml;ber das Format der Datei
      <filename>/etc/fstab</filename> und den Optionen darin.</para>

    <para>Eine vollst&auml;ndige Beschreibung der Dateisystem-Hierarchie
      finden Sie in &man.hier.7;.  Als Beispiel sein eine kurze
      &Uuml;bersicht &uuml;ber die gebr&auml;uchlisten Verzeichnisse
      gegeben:</para>

    <para>
      <informaltable frame="none">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Verzeichnis</entry>
	      <entry>Beschreibung</entry>
	    </row>
	  </thead>
	  <tbody>
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Root-Verzeichnis des Dateisystems.</entry>
            </row>
	    
	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Grundlegende Werkzeuge f&uuml;r den Single-User-Modus
		sowie den Mehrbenutzerbetrieb.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Programme und Konfigurationsdateien, die w&auml;hrend
		des Bootens benutzt werden.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Vorgaben f&uuml;r die Boot-Konfiguration, siehe
		&man.loader.conf.5;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Ger&auml;tedateien, siehe &man.intro.4;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>System Konfigurationsdateien und Skripte.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Vorgaben f&uuml;r die System Konfigurationsdateien,
		siehe &man.rc.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>Konfigurationsdateien von MTAs wie
		&man.sendmail.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry>Konfigurationsdateien von <command>named</command>,
		siehe &man.named.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>T&auml;glich, w&ouml;chentlich oder monatlich
		ablaufende Skripte, die von &man.cron.8; gestartet werden.
		Siehe &man.periodic.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry>Konfigurationsdateien von <command>ppp</command>,
		siehe &man.ppp.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>Ein leeres Verzeichnis, das von Systemadministratoren
		h&auml;ufig als tempor&auml;rer Mountpunkt genutzt wird.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Proze&szlig; Dateisystem, siehe &man.procfs.5;
		und &man.mount.procfs.8;.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry>Home Verzeichnis von <username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>Systemprogramme und administrative Werkzeuge, die
		grundlegend f&uuml;r des Single-User-Modus und den
		Mehrbenutzerbetrieb sind.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
	      <entry>Programme, die ohne andere Programme oder Bibliotheken
		laufen.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Tempor&auml;re Dateien, die f&uuml;r gew&ouml;hnlich
		nicht nach einem Reboot erhalten werden.  Dies kann
		ein speicherbasiertes Dateisystem, siehe &man.mfs.8;,
		sein.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>Der Gro&szlig;teil der Benutzerprogramme und
		Applikationen.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Gebr&auml;uchliche Werkzeuge, Programmierhilfen und
		Applikationen.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Standard C include-Dateien.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Bibliotheken.</entry>
	    </row>
	    
	    
	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Daten verschiedener Werkzeuge.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>System-D&auml;monen und System-Werkzeuge, die von
		anderen Programmen ausgef&uuml;hrt werden.</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>Lokale Programme, Bibliotheken usw.  Die Port Kollektion
		benutzt dieses Verzeichnis als Zielverzeichnis f&uuml;r zu
		installierende Applikationen.  Innerhalb von
		<filename>/usr/local</filename> sollte das von
		&man.hier.7; beschriebene Layout f&uuml;r 
		<filename>/usr</filename> benutzt werden.  Das
		<filename>man</filename> Verzeichnis wird direkt unter
		<filename>/usr/local</filename> anstelle unter 
		<filename>/usr/local/share</filename> angelegt.  Die
		Dokumentation der Ports findet sich in
		<filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Von der Architektur abh&auml;ngiger Verzeichnisbaum,
		der durch das Bauen von <filename>/usr/src</filename>
		entsteht.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
	      <entry>Die FreeBSD Ports-Kollektion (optional).</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>System-D&auml;monen und System-Werkzeuge, die von
		Benutzern ausgef&uuml;hrt werden.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Von der Architektur unabh&auml;ngige Dateien.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>Quelldateien zu BSD und/oder lokalen 
		Erg&auml;nzungen.</entry>
	    </row>
	    
	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>Optionale X11R6 Programme und Bibliotheken.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Wird f&uuml;r mehrere Zwecke genutzt und enth&auml;lt
		Logdateien, tempor&auml;re und Spooldateien.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Verschiedene Logdateien des Systems.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Postf&auml;cher der Benutzer.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Verschiedene Spool-Verzeichnisse der Drucker- und
		Mailsysteme.</entry>
	    </row>
	    
	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Tempor&auml;re Dateien, die &uuml;ber Reboots erhalten
		bleiben.</entry>
	    </row>
	    
	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>NIS maps.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>
  </sect1>

  <sect1 id="basics-processes">
    <title>Prozesse</title>

    <para>Da FreeBSD ein Multitasking Betriebssystem ist, sieht es so aus,
      als ob mehrere Prozesse zur gleichen Zeit laufen.  Jedes Programm,
      das zu irgendeiner Zeit l&auml;uft, wird
      <firstterm>Proze&szlig;</firstterm> genannt.  Jedes Kommando
      startet mindestens einen Proze&szlig;.  Einige Systemprozesse
      laufen die ganze Zeit und stellen die Funktion des Systems sicher.</para>

    <para>Jeder Proze&szlig; wird durch eine eindeutige Nummer identifiziert,
      die <firstterm>Proze&szlig;-ID</firstterm> oder
      <firstterm>PID</firstterm> genannt wird.  Prozesse haben ebenso
      wie Dateien einen Besitzer und eine Gruppe, die festlegen, welche
      Dateien und Ger&auml;te der Proze&szlig; benutzen kann.  Dabei
      finden die vorher beschriebenen Zugriffsrechte Anwendungen.  Die meisten
      Prozesse haben auch einen Elternproze&szlig;, der sie gestartet hat.
      Wenn Sie in der Shell Kommandos eingeben, dann ist die Shell ein
      Proze&szlig; und jedes Kommando, das Sie starten ist auch ein
      Proze&szlig;.  Jeder Proze&szlig;, den Sie auf diese Weise starten,
      besitzt den Shell-Proze&szlig; als Elternproze&szlig;.  Die Ausnahme
      hiervon ist ein spezieller Proze&szlig;, der <command>init</command>
      hei&szlig;t.  <command>init</command> ist immer der erste Proze&szlig;
      und hat somit die PID 1.  <command>init</command> wird vom Kernel
      beim Booten von FreeBSD gestartet.</para>

    <para>Die Kommandos &man.ps.1; und &man.top.1; sind besonders
      n&uuml;tzlich, um sich die Prozesse auf einem System anzusehen.
      &man.ps.1; zeigt eine statische Liste der laufenden Prozesse
      und kann deren PID, Speicherverbrauch und die Kommandozeile, mit der
      sie gestartet wurden, usw. anzeigen.  &man.top.1; zeigt alle
      laufenden Prozesse an und aktualisiert die Anzeige, so da&szlig;
      Sie Ihrem Computer bei der Arbeit zuschauen k&ouml;nnen.</para>

    <para>Normal zeigt Ihnen &man.ps.1; nur die laufenden Prozesse,
      die Ihnen geh&ouml;ren. Zum Beispiel:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Wie Sie sehen, gibt &man.ps.1; mehrere Spalten aus.  In der
      <literal>PID</literal> Spalte findet sich die vorher besprochene
      Proze&szlig;-ID.  PIDs werden von 1 beginnend bis 99999 zugewiesen
      und fangen wieder von vorne an, wenn die Grenze &uuml;berschritten
      wird.  <literal>TT</literal> zeigt den Terminal, auf dem das
      Programm l&auml;uft.  <literal>STAT</literal> zeigt des Status
      des Programms und kann f&uuml;r die Zwecke dieser Diskussion ebenso
      wie <literal>TT</literal> ignoriert werden.  <literal>TIME</literal>
      gibt die Zeit an, die das Programm auf der CPU gelaufen ist&mdash;
      dies ist nicht unbedingt die Zeit, die seit dem Start des Programms
      vergangen ist, da einige Programme viel Zeit mit dem Warten auf
      bestimmte Dinge verbringen, bevor sie wirklich CPU-Zeit verbrauchen.
      Unter der Spalte <literal>COMMAND</literal> finden Sie schlie&szlig;lich
      die Kommandozeile, mit der das Programm gestartet wurde.</para>

    <para>&man.ps.1; besitzt viele Optionen, um die angezeigten Informationen
      zu beeinflussen.  Eine n&uuml;tzliche Kombination ist
      <literal>auxww</literal>.  Mit <option>a</option> werden Information
      &uuml;ber alle laufenden Prozesse und nicht nur Ihrer eigenen
      angezeigt.  Der Name des Besitzers des Prozesses, sowie Informationen
      &uuml;ber den Speicherverbrauch werden mit <option>u</option>
      angezeigt.  <option>x</option> zeigt auch D&auml;monen-Prozesse an,
      und <option>ww</option> vernla&szlig;t &man.ps.1; die komplette
      Kommandozeile anzuzeigen, anstatt sie abzuschneiden, wenn sie
      zu lang f&uuml;r die Bildschirmausgabe wird.</para>

    <para>Die Ausgabe von &man.top.1; sieht &auml;hnlich aus:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Die Ausgabe ist in zwei Abschnitte geteilt.  Im Kopf in den ersten
      f&uuml;nf Zeilen finden sich die zuletzt zugeteilte PID, die
      Systemauslastung (<quote>load average</quote>), die Systemlaufzeit
      (die Zeit seit dem letzten Reboot) und die momentane Zeit.  Die weiteren
      Zahlen im Kopf beschreiben wieviele Prozesse momentan laufen (im
      Beispiel 47), wieviel Speicher und Swap verbraucht wurde und
      wieviel Zeit das System in den verschiedenen CPU-Modi verbringt.</para>

    <para>Darunter befinden sich einige Spalten mit &auml;hnlichen
      Informationen wie in der Ausgabe von &man.ps.1;.  Wie im vorigen
      Beispiel k&ouml;nnen Sie die PID, den Besitzer, die verbrauchte
      CPU-Zeit und das Kommando erkennen.  &man.top.1; zeigt auch den
      Speicherverbrauch des Prozesses an, der in zwei Spalten aufgeteilt
      ist.  Die erste Spalte gibt den gesamten Speicherverbrauch des
      Prozesses an, in der zweiten Spalte wird der aktuelle Verbrauch
      angegeben.  <application>Netscape</application> hat im gezeigten
      Beispiel insgesamt 30 MB Speicher verbraucht.  Momentan benutzt
      es allerdings nur 9 MB.</para>

    <para>Die Anzeige wird von &man.top.1; automatisch alle zwei Sekunden
      aktualisiert.  Der Zeitraum kann mit <option>-s</option> eingestellt
      werden.</para>
  </sect1>

  <sect1>
    <title>D&auml;monen, Signale und Stoppen von Prozessen</title>

    <para>Wenn Sie einen Editor starten, k&ouml;nnen Sie ihn leicht bedienen
      und Dateien laden.  Sie k&ouml;nnen das, weil der Editor daf&uuml;r
      Vorsorge getroffen hat und auf einem <firstterm>Terminal</firstterm>
      l&auml;uft.  Manche Programme erwarten keine Eingaben von einem
      Benutzer und l&ouml;sen sich bei erster Gelegenheit von ihrem
      Terminal.  Ein Web-Server zum Beispiel verbringt den ganzen Tag
      damit, auf Anfragen zu antworten und erwartet keine Eingaben von Ihnen.
      Programme, die email von einem Ort zu einem anderen Ort transportieren
      sind ein weiteres Beispiel f&uuml;r diesen Typ von Applikationen.</para>

    <para>Wir nennen diese Programme <firstterm>D&auml;monen</firstterm>.
      D&auml;monen stammen aus der griechischen Mythologie und waren
      weder gut noch b&ouml;se.  Sie waren kleine dienstbare Geister,
      die meistens n&uuml;tzliche Sachen f&uuml;r die Menschheit vollbrachten.
      &Auml;hnlich wie heutzutage Web-Server und Mail-Server n&uuml;tzliche
      Dienste verrichten.  Seit langer Zeit ist daher das BSD Maskottchen
      dieser fr&ouml;hlich aussehende D&auml;mon mit Turnschuhen
      und Dreizack.</para>

    <para>Programme, die als D&auml;mon laufen, werden entsprechend einer
      Konvention mit einem <quote>d</quote> am Ende benannt.
      <application>BIND</application> ist der Berkeley Internet Name Daemon
      und das tats&auml;chlich laufende Programm hei&szlig;t
      <command>named</command>.  Der Apache Webserver wird
      <command>httpd</command> genannt, der Druckerspool-D&auml;mon hei&szlig;t
      <command>lpd</command> usw.  Dies ist allerdings eine Konvention
      und keine unumst&ouml;&szlig;liche Regel: Der D&auml;mon der
      Applikation <application>sendmail</application> hei&szlig;t
      <command>sendmail</command> und nicht <command>maild</command>, wie
      Sie vielleicht gedacht hatten.</para>

    <para>Manchmal m&uuml;ssen Sie mit einem D&auml;mon kommunizieren und
      dazu benutzen Sie <firstterm>Signale</firstterm>.  Sie k&ouml;nnen
      mit einem D&auml;monen oder jedem anderen laufenden Proze&szlig;
      kommunizieren, indem Sie diesem ein Signal schicken.  Sie k&ouml;nnen
      verschiedene Signale verschicken&mdash;manche haben eine festgelegte
      Bedeutung, andere werden von der Applikation interpretiert.  Die
      Dokumentation zur fraglichen Applikation wird erkl&auml;ren, wie
      die Applikation Signale interpretiert.  Sie k&ouml;nnen nur Signale
      zu Prozessen senden,  die Ihnen geh&ouml;ren.  Wenn Sie versuchen
      einem Proze&szlig;, der nicht Ihnen geh&ouml;rt, ein Signal zu
      senden, so wird das Signal ignoriert.  Der Benutzer
      <username>root</username> darf jedem Proze&szlig; Signale schicken.</para>

    <para>In manchen F&auml;llen wird FreeBSD Signale senden.  Wenn eine
      Applikation schlecht geschrieben ist und auf Speicher zugreift, auf
      den sie nicht zugreifen soll, so sendet FreeBSD dem Proze&szlig;
      das <firstterm>Segmentation Violation</firstterm> Signal 
      (<literal>SIGSEGV</literal>).  Wenn eine Applikation den &man.alarm.3;
      Systemaufruf benutzt hat, um nach einiger Zeit benachrichtigt zu
      werden, bekommt sie das Alarm Signal (<literal>SIGALRM</literal>)
      gesendet.</para>

    <para>Zwei Signale k&ouml;nnen benutzt werden, um Prozesse zu stoppen:
      <literal>SIGTERM</literal> und <literal>SIGKILL</literal>.  Mit
      <literal>SIGTERM</literal> fordern Sie den Proze&szlig; h&ouml;flich zum
      Beenden auf.  Der Proze&szlig; kann das Signal abfangen und merken,
      da&szlig; er sich beenden soll.  Er hat dann Gelegenheit Logdateien
      zu schlie&szlig;en und die Aktion, die er vor der Aufforderung
      sich zu beenden durchf&uuml;hrte, abzuschlie&szlig;en.  Er kann
      sogar <literal>SIGTERM</literal> ignorieren, wenn er eine Aktion
      durchf&uuml;hrt, die nicht unterbrochen werden darf.</para>

    <para><literal>SIGKILL</literal> kann von keinem Proze&szlig; ignoriert
      werden.  Das Signal l&auml;&szlig;t sich mit <quote>Mich interessiert
      nicht, was du gerade machst, h&ouml;r sofort auf damit!</quote>
      umschreiben.  Wenn Sie einem Proze&szlig; <literal>SIGKILL</literal>
      schicken, dann wird FreeBSD diesen sofort beenden<footnote><para>
	Das stimmt nicht ganz: Es gibt F&auml;lle, in denen ein Proze&szlig;
	nicht unterbrochen werden kann.  Wenn der Prozes&szlig; zum Beispiel
	eine Datei von einem anderen Rechner auf dem Netzwerk liest und dieser
	Rechner aus irgendwelchen Gr&uuml;nden nicht erreichbar ist
	(ausgeschaltet, oder ein Netzwerkfehler), dann ist der Proze&szlig;
	nicht zu unterbrechen.  Wenn der Proze&szlig; den Lesezugriff
	nach einem Timeout von typischerweise zwei Minuten aufgibt,
	dann wir er beendet.</para>
      </footnote>.</para>

    <para>Andere Signale, die Sie vielleicht verschicken wollen, sind
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> und
      <literal>SIGUSR2</literal>.  Diese Signale sind f&uuml;r allgemeine
      Zwecke vorgesehen und verschiedene Applikation werden unterschiedlich
      auf diese Signale reagieren.</para>

    <para>Nehmen wir an, Sie haben die Konfiguration Ihres Webservers
      ver&auml;ndert und m&ouml;chten dies dem Server mitteilen.  Sie
      k&ouml;nnten den Server nat&uuml;rlich stoppen und
      <command>httpd</command> wieder starten.  Die Folge w&auml;re eine
      kurze Zeit, in der der Server nicht erreichbar ist.  Die meisten
      D&auml;monen lesen Ihre Konfigurationsdatei beim Empfang eines
      <literal>SIGHUP</literal> neu ein.  Da es keinen Standard gibt, der
      vorschreibt, wie auf diese Signale zu reagieren ist, lesen
      Sie bitte die Dokumentation zu dem in Frage kommenden D&auml;mon.</para>
    
    <para>Mit &man.kill.1; k&ouml;nnen Sie, wie unten gezeigt, Signale
      verschicken.</para>

    <procedure>
      <title>Verschicken von Signalen</title>

      <para>Das folgende Beispiel zeigt, wie Sie &man.inetd.8; ein Signal
	schicken.  Die Konfigurationsdatei von &man.inetd.8; ist
	<filename>/etc/inetd.conf</filename> und &man.inetd.8; liest die
	Konfigurationsdatei erneut ein, wenn er ein <literal>SIGHUP</literal>
	empf&auml;ngt.</para>

      <step>
	<para>Suchen Sie Proze&szlig;-ID des Prozesses, dem Sie ein Signal
	  schicken wollen.  Benutzen Sie dazu &man.ps.1; und &man.grep.1;.
	  Mit &man.grep.1; k&ouml;nnen Sie in einer Ausgabe nach einem
	  String suchen.  Da &man.inetd.8; unter dem Benutzer
	  <username>root</username> l&auml;uft und Sie das Kommando als
	  normaler Benutzer absetzen, m&uuml;ssen Sie &man.ps.1; mit
	  <option>ax</option> aufrufen:</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Die Proze&szlig;-ID von &man.inetd.8; ist 198.  In einigen
	  F&auml;llen werden Sie auch das <literal>grep inetd</literal>
	  Kommando in der Ausgabe sehen.  Dies hat damit zu tun, wie
	  &man.ps.1; die Liste der laufenden Prozesse untersucht.</para>
      </step>

      <step>
	<para>Senden Sie das Signal mit &man.kill.1;.  Da &man.inetd.8;
	  unter dem Benutzer <username>root</username> l&auml;uft, m&uuml;ssen
	  Sie zuerst mit &man.su.1; <username>root</username> werden:</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>&man.kill.1; wird, wie andere Unix Kommandos auch, keine Ausgabe
	  erzeugen, wenn das Kommando erfolgreich war.  Wenn Sie versuchen,
	  einem Proze&szlig;, der nicht Ihnen geh&ouml;rt, ein Signal zu
	  senden, dann werden Sie die Meldung
	  <errorname>kill: <replaceable>PID</replaceable>: Operation not
	  permitted</errorname> sehen.  Wenn Sie sich bei der Eingabe der
	  PID vertippen, werden Sie das Signal dem falschen Proze&szlig;
	  schicken, was schlecht sein kann.  Wenn Sie Gl&uuml;ck haben,
	  existiert der Proze&szlig; nicht und Sie werden mit der Ausgabe
	  <errorname>kill: <replaceable>PID</replaceable>: No such
	  process</errorname> belohnt.</para>

	<note>
	  <title>Warum soll ich <command>/bin/kill</command> benutzen?</title>

	  <para>Viele Shells stellen <command>kill</command> als internes
	    Kommando zur Verf&uuml;gung, das hei&szlig;t die Shell sendet
	    das Signal direkt, anstatt <filename>/bin/kill</filename>
	    zu starten.  Das kann n&uuml;tzlich sein, aber die
	    unterschiedlichen Shells benutzen eine verschiedene Syntax,
	    um die Namen der Signale anzugeben.  Anstatt jede Syntax zu
	    lernen, kann es einfacher sein, <command>/bin/kill
	    <replaceable>...</replaceable></command> direkt aufzurufen.</para>
	</note>
      </step>
    </procedure>

    <para>Andere Signale senden Sie auf die gleiche Weise, ersetzen
      Sie nur <literal>TERM</literal> oder <literal>KILL</literal>
      entsprechend.</para>

    <important>
      <para>Es kann gravierende Auswirkungen haben, wenn Sie zuf&auml;llig
	Prozesse beenden.  Insbesondere &man.init.8; mit der Proze&szlig;-ID
	ist ein Spezialfall.  Mit <command>/bin/kill -s KILL 1</command>
	k&ouml;nnen Sie Ihr System schnell herunterfahren.
	&Uuml;berpr&uuml;fen Sie die Argumente von &man.kill.1;
	<emphasis>immer</emphasis> zweimal <emphasis>bevor</emphasis>
	Sie <keycap>Return</keycap> dr&uuml;cken.</para>
    </important>
  </sect1>

  <sect1 id="disks-mounting">
    <title>Anh&auml;ngen und Abh&auml;ngen von Dateisystemen</title>

    <para>Ein Dateisystem wird am besten als ein Baum mit der
      Wurzel <filename>/</filename> veranschaulicht.
      <filename>/dev</filename>, <filename>/usr</filename>, und
      die anderen Verzeichnisse im Rootverzeichnis sind Zweige,
      die wiederum eigene Zweige wie <filename>/usr/local</filename>
      haben k&ouml;nnen.</para>

    <indexterm><primary>Root-Dateisystem</primary></indexterm>
    <para>Es gibt verschiedene Gr&uuml;nde, bestimmte dieser Verzeichnisse
      auf eigenen Dateisystemen anzulegen.  <filename>/var</filename>
      enth&auml;lt <filename>log/</filename>, <filename>spool/</filename>
      sowie verschiedene andere tempor&auml;re
      Dateien und kann sich daher schnell f&uuml;llen.  Es empfiehlt sich,
      <filename>/var</filename> von <filename>/</filename> zu trennen,
      da es schlecht ist, wenn das Root-Dateisystem voll
      l&auml;uft.</para>

    <para>Ein weiterer Grund bestimmte Verzeichnisb&auml;ume auf
      andere Dateisysteme zu legen, ist gegeben, wenn sich die
      Verzeichnisb&auml;ume auf gesonderten physikalischen oder
      virtuellen Platten, wie 
      Network File System
      <!--
      <link linkend="nfs">Network File System</link>
      -->
      oder CDROM Laufwerken, befinden.</para>

    <sect2 id="disks-fstab">
      <title>Die <filename>fstab</filename> Datei</title>

      <indexterm>
	 <primary>Dateisysteme</primary>
	 <secondary>fstab</secondary>
      </indexterm>
      <para>W&auml;hrend des Boot Prozesses
	<!--
	<link linkend="boot">Boot Prozesses</link>
	-->
	werden in <filename>/etc/fstab</filename> aufgef&uuml;hrte
	Verzeichnisse, sofern sie nicht mit der Option <option>noauto</option>
	versehen sind, automatisch angehangen.</para>

      <para>Die Zeilen in <filename>/etc/fstab</filename> haben das
	folgende Format:</para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>

	  <listitem>
            <para>Ein existierender Ger&auml;tename
	      wie oben in 
	      <!--
	      <link linkend="disks-naming">Benennung von Laufwerken</link>
	      -->
	      Benennung von Laufwerken
	      beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem>
            <para>Ein existierendes Verzeichnis,
	      an das das Dateisystem angehangen wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
            <para>Der Typ des Dateisystems,
	      der an &man.mount.8; weitergegeben wird.  Das default
	      FreeBSD Dateisystem ist <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>Entweder <option>rw</option>
	      f&uuml;r beschreibbare Dateisysteme oder <option>ro</option>
	      f&uuml;r schreibgesch&uuml;tzte Dateisysteme, gefolgt von
	      weiteren ben&ouml;tigten Optionen.  Eine h&auml;ufig verwendete
	      Option ist <option>noauto</option> f&uuml;r Dateisysteme,
	      die w&auml;hrend der normalen Bootsequenz nicht angehangen
	      werden sollen.  Weitere Optionen finden sich 
	      in &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem><para>Gibt die anzahl der Tage an, nachdem das
	      Dateisystem gesichert werden soll.  Fehlt der Wert, wird
	      <literal>0</literal> angenommen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem><para>Bestimmt die Reihenfolge, in der die Dateisysteme
	      &uuml;berpr&uuml;ft werden sollen.  F&uuml;r Dateisysteme,
	      die &uuml;bersprungen werden sollen, ist
	      <literal>passno</literal> auf null zu setzen.  F&uuml;r das
	      Root-Dateisystem, das vor allen anderen &uuml;berpr&uuml;ft
	      werden mu&szlig;, sollte der Wert von
	      <literal>passno</literal> eins betragen.  Allen anderen
	      Dateisystemen sollten Werte gr&ouml;&szlig;er eins zugewiesen
	      werden.  Wenn mehrere Dateisysteme den gleichen Wert
	      besitzen, wird &man.fsck.8; versuchen, diese parallel zu
	      &uuml;berpr&uuml;fen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title>Das mount Kommando</title>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>anh&auml;ngen</secondary>
      </indexterm>

      <para>&man.mount.8; h&auml;ngt schlie&szlig;lich Dateisysteme 
	an.</para>

      <para>In der grundlegenden Form wird es wie folgt benutzt:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Viele Optionen werden in &man.mount.8; beschrieben,
	die am h&auml;ufigsten verwendeten sind:</para>

      <variablelist>
	<title>Mount Optionen</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
            <para>H&auml;ngt alle Dateisysteme aus <filename>/etc/fstab</filename>
	      an.  Davon ausgenommen sind Dateisysteme, die mit 
	      <quote>noauto</quote> markiert sind, die mit der Option
	      <option>-t</option> ausgeschlossen wurden und Dateisysteme,
	      die schon angehangen sind.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
            <para>F&uuml;hrt den entsprechenden Systemcall nicht aus.
	      N&uuml;tzlich ist diese Option in Verbindung
	      mit <option>-v</option>.  Damit wird angezeigt, was
	      <command>mount</command> tats&auml;chlich versuchen
	      w&uuml;rde, um das Dateisystem anzuh&auml;ngen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Erzwingt das Anh&auml;ngen eines unsauberen Dateisystems
	      oder erzwingt die R&uuml;cknahme des Schreibzugriffs, wenn
	      der Status des Dateisystems von beschreibbar auf 
	      schreibgesch&uuml;tzt ge&auml;ndert wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>H&auml;ngt das Dateisystem schreibgesch&uuml;tzt an.  Das
	      kann auch durch Angabe von <option>rdonly</option> zu der
	      <option>-o</option> Option erreicht werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
            <para>H&auml;ngt das Dateisystem mit dem angebenen Typ an,
	      oder h&auml;ngt nur Dateisysteme mit dem angegebenen Typ
	      an, wenn auch <option>-a</option> angegeben
	      wurde.</para>

            <para>Die Voreinstellung f&uuml;r den Typ des Dateisystems
	      ist <quote>ufs</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Aktualisiert die Mountoptionen des Dateisystems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Geschw&auml;tzig sein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>H&auml;ngt das Dateisystem beschreibbar an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para><option>-o</option> erwartet eine durch Kommata separierte Liste
	von Optionen, unter anderem die folgenden:</para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	  <listitem>
            <para>Beachtet keine Ger&auml;tedateien auf dem Dateisystem.
	      Dies ist ein n&uuml;tzliches Sicherheitsfeature.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	    <para>Verbietet das Ausf&uuml;hren von bin&auml;ren
	      Dateien auf dem Dateisystem.  Dies ist ein
	      n&uuml;tzliches Sicherheitsfeature.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>SetUID und SetGID Bits werden auf dem Dateisystem
	      nicht beachtet.  Dies ist ein n&uuml;tzliches
	      Sicherheitsfeature.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>Das <command>umount</command> Kommando</title>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>abh&auml;ngen</secondary>
      </indexterm>

      <para>&man.umount.8; akzeptiert als Parameter entweder
	einen Mountpoint, einen Ger&auml;tenamen, oder die
	Optionen <option>-a</option> oder <option>-A</option>.</para>

      <para>Jede Form akzeptiert <option>-f</option>, um das
	Abh&auml;ngen zu erzwingen, und <option>-v</option>, um
	etwas geschw&auml;tziger zu sein.  Seien Sie bitte vorsichtig mit
	<option>-f</option>: Ihr Computer kann abst&uuml;rzen oder es
	k&ouml;nnen Daten auf dem Dateisystem besch&auml;digt werden, wenn
	Sie das Abh&auml;ngen erzwingen.</para>

      <para><option>-a</option> und <option>-A</option> werden benutzt
	um alle Dateisysteme, deren Typ durch <option>-t</option>
	modifiziert werden kann, abzuh&auml;ngen.  <option>-A</option>
	h&auml;ngt das Rootdateisystem nicht ab.</para>
    </sect2>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>Shells</primary></indexterm>
    <indexterm><primary>Kommandozeile</primary></indexterm>

    <para>Von der tagt&auml;glichen Arbeit mit FreeBSD wird eine Menge
      mit der Kommandozeilen Schnittstelle der Shell erledigt.  Die
      Hauptaufgabe einer Shell besteht darin, Kommandos der Eingabe
      anzunehmen und diese auszuf&uuml;hren.  Viele Shells haben
      au&szlig;erdem eingebaute Funktionen, um die t&auml;gliche
      Arbeit zu erleichtern, wie Dateiverwaltung, Editieren von 
      Kommandozeilen, Makros und Umgebungsvariablen.  FreeBSD 
      enth&auml;lt die Shells <command>sh</command> (die Bourne Shell) und
      <command>tcsh</command> (die verbesserte C-Shell) im Basissystem.
      Viele andere Shells, wie <command>zsh</command> oder
      <command>bash</command>, befinden sich in der Ports-Sammlung.</para>

    <para>Welche Shell soll ich benutzen?  Das ist wirklich eine
      Geschmacksfrage.  Sind Sie ein C Programmierer, finden Sie
      vielleicht eine C-artige Shell wie die <command>tcsh</command>
      angenehmer.  Kommen Sie von Linux oder Ihnen ist eine Unix Kommandozeile
      neu, so k&ouml;nnten Sie die <command>bash</command> probieren.
      Der Punkt ist, da&szlig;
      jede Shell ihre speziellen Eigenschaften hat, die mit Ihrer
      bevorzugten Arbeitsumgebung harmonieren k&ouml;nnen oder nicht.
      Sie m&uuml;ssen sich eine Shell aussuchen.</para>

    <para>Ein verbreitetes Merkmal in Shells ist die
      Dateinamen-Vervollst&auml;ndigung.  Sie m&uuml;ssen nur einige
      Buchstaben eines Kommandos oder eines Dateinamen eingeben und
      die Shell vervollst&auml;ndigt den Rest automatisch durch
      dr&uuml;cken der <keycap>Tab</keycap>-Taste.  Hier ist ein Beispiel.
      Angenommen, Sie
      haben zwei Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename>.  Die Datei
      <filename>foo.bar</filename> m&ouml;chten Sie l&ouml;schen.  Nun
      w&uuml;rden Sie an der Tastatur eingeben: 
      <command>rm fo[<keycap>Tab</keycap>].
      [<keycap>Tab</keycap>]</command>.</para>

    <para>Die Shell w&uuml;rde dann<command>rm
      foo[BEEP].bar</command> ausgeben.</para>

    <para>[BEEP] meint den Rechner-Piepser.  Diesen gibt die Shell
      aus, um anzuzeigen, da&szlig; es den Dateinamen nicht
      vervollst&auml;ndigen konnte, da es mehrere M&ouml;glichkeiten
      gibt.  Beide Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename> beginnen mit <literal>fo</literal>,
      so konnte nur bis <literal>foo</literal> erg&auml;nzt werden.
      Nachdem Sie <literal>.</literal> eingaben und dann die
      <keycap>Tab</keycap>-Taste
      dr&uuml;ckten, konnte die Shell den Rest f&uuml;r Sie 
      ausf&uuml;llen.</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>

    <para>Eine andere Funktion der Shell sind die Umgebungsvariablen.
      Das sind ver&auml;nderbare Schl&uuml;sselpaare im Umgebungsraum
      der Shell.  Diesen Umgebungsraum kann jedes von der Shell
      aufgerufene Programm lesen.  So kommt es, da&szlig; viel
      Programmkonfiguration darin enthalten ist.  Hier eine Liste
      verbreiteter Umgebungsvariablen und was sie bedeuten:</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>
    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Name des zur Zeit angemeldeten Benutzers.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt) 
              zum Suchen nach Programmen.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Wenn gesetzt der Netzwerkname des X11 Bildschirms
              f&uuml;r die Anzeige.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Die aktuelle Shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Name des Terminals des Benutzers.  Benutzt, um die
              F&auml;higkeiten des Terminals bestimmen.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Datenbankeintrag der Terminal Escape Codes,
              ben&ouml;tigt um verschieden Terminalfunktionen
              auszuf&uuml;hren.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Typ des Betriebsystems.  Z.B., FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Die CPU Architektur auf dem das System 
              l&auml;uft.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Betrachter.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt) 
              zum Suchen nach Man-Pages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Das Anzeigen oder Setzen von Umgebungsvariablen funktioniert
      von Shell zu Shell unterschiedlich.  Zum Beispiel benutzt man
      in C-artigen Shells wie der <command>tcsh</command> dazu
      <command>setenv</command>.  Unter Bourne-Shells wie <command>sh</command>
      oder <command>bash</command> w&uuml;rde man
      <command>set</command> und <command>export</command> benutzen
      zum ansehen oder setzen von aktuellen Umgebungsvariablen.  Um
      beispielsweise die Variable <envar>EDITOR</envar> mit 
      <command>csh</command> oder <command>tcsh</command> zu setzen,
      w&uuml;rde folgendes Kommando die Variable
      <envar>EDITOR</envar> auf 
      <filename>/usr/local/bin/emacs</filename> setzen:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Unter Bourne-Shells:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Sie k&ouml;nnen die meisten Shells Umgebungsvariablen
      expandieren lassen, in dem Sie in der Kommandozeile ein 
      <literal>$</literal> davor eingeben.  Zum Beispiel gibt 
      <command>echo $TERM</command> aus, worauf <envar>$TERM</envar> 
      gesetzt ist, weil die Shell <envar>$TERM</envar> expandiert
      und das Ergebnis an <command>echo</command> gibt.</para>

    <para>Shells behandeln eine Menge an Spezialzeichen, sogenannte
      Metazeichen, als besondere Darstellungen f&uuml;r Daten.
      Das allgemeinste ist das Zeichen <literal>*</literal>, das eine
      beliebige Anzahl Zeichen in einem Dateinamen repr&auml;sentiert.
      Das Kommando <command>echo *</command> liefert nahezu das gleiche 
      wie die Eingabe von <command>ls</command>, da die Shell alle
      Dateinamen die mit <command>*</command> &uuml;bereinstimmen an
      echo weitergibt.</para>

    <para>Um zu verhindern, da&szlig; die Shell diese Sonderzeichen
      interpretiert, kann man sie sch&uuml;tzen, indem man ihnen einen
      Backslash (<literal>\</literal>) voranstellt.  <command>echo
      $TERM</command> gibt aus, auf was auch immer Ihr Terminal
      gesetzt ist.  <command>echo \$TERM</command> gibt 
      <envar>$TERM</envar> genauso aus, wie es hier steht.</para>

    <sect2 id="changing-shells">
      <title>&Auml;ndern der Shell</title>

      <para>Der einfachste Weg Ihre Shell zu &auml;ndern, ist das
        Kommando <command>chsh</command> zu benutzen.  
        <command>chsh</command> platziert Sie im Editor, welcher durch
        Ihre Umgebungsvariable <envar>EDITOR</envar> gesetzt ist,
        im <command>vi</command> wenn die Variable nicht gesetzt ist.
        &Auml;ndern Sie die Zeile mit <quote>Shell:</quote>
        entsprechend Ihren W&uuml;nschen.</para>

      <para>Sie k&ouml;nnen auch <command>chsh</command> mit der Option
	<option>-s</option> aufrufen, dann wird Ihre Shell gesetzt,
        ohne das&szlig; Sie in einen Editor gelangen.  Um Ihre Shell
        zum Beispiel auf die bash zu &auml;ndern, geben Sie das
        folgende Kommando ein:</para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Einfach <command>chsh</command> ohne Optionen und mit
        Editieren der entsprechenden Zeile w&uuml;rde auch
        funktionieren.</para>

      <note>
	<para>Die von Ihnen gew&uuml;nschte Shell 
          <emphasis>mu&szlig;</emphasis> in <filename>/etc/shells</filename> 
          aufgef&uuml;hrt sein.  Haben Sie eine Shell aus der
	  <!--<link linkend="ports">-->Ports Sammlung<!--</link>--> installiert,
          sollte das schon automatisch erledigt werden.  Installierten
          Sie die Shell von Hand, so m&uuml;ssen Sie sie dort
          eintragen.</para>
     
      <para>Haben Sie beispielsweise die <command>bash</command> nach
	<filename>/usr/local/bin</filename> installiert, wollen Sie
        dies tun:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Danach k&ouml;nnen Sie <command>chsh</command> aufrufen.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Text Editoren</title>
    <indexterm><primary>Text Editoren</primary></indexterm>
    <indexterm><primary>Editoren</primary></indexterm>

    <para>Eine Menge der Konfiguration bei FreeBSD wird durch
      das Editieren von Textdateien erledigt.  Deshalb ist es eine
      gute Idee, mit einem Texteditor vertraut zu werden.  FreeBSD hat
      ein paar davon im Basissystem und sehr viel mehr in der Ports
      Sammlung.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <para>Der am leichtesten und einfachsten zu erlernende Editor nennt
      sich <application>ee</application>, was f&uuml;r easy editor steht.
      Um <application>ee</application> zu starten, gibt man in der
      Kommandozeile <command>ee filename</command> ein, worin
      <literal>filename</literal> der Name der zu editierenden Datei
      ist.  Um zum Beispiel <filename>/etc/rc.conf</filename> zu
      editieren, tippen Sie <command>ee /etc/rc.conf</command>.
      Einmal im Editor, finden Sie alle Editor-Funktionen oben im
      Display aufgelistet.  Das Einschaltungszeichen 
      <literal>^</literal> meint die Control (oft Steuerung) Taste,
      also ^e hei&szlig;t, da&szlig; die Controltaste und dann der
      Buchstabe <literal>e</literal> gedr&uuml;ckt werden.  Um
      <application>ee</application> zu verlassen, einfach die
      Escapetaste dr&uuml;cken und leave editor w&auml;hlen.  Der
      Editor fragt Sie nach, ob Sie speichern m&ouml;chten, wenn die
      Datei ver&auml;ndert wurde.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD verf&uuml;gt &uuml;ber leistungsf&auml;higere
      Editoren wie <command>vi</command> als Teil des
      Basissystems und <command>emacs</command> oder 
      <command>vim</command> als Teil der Ports Sammlung.
      Diese Editoren bieten h&ouml;here Funktionalit&auml;t und
      Leistungsf&auml;higkeit jedoch auf Kosten einer etwas
      schwierigeren Erlernbarkeit.  Dennoch, wenn Sie viel 
      Textdateien editieren werden, sparen Sie auf lange Sicht mehr
      Zeit ein durch das Erlernen solcher Editoren wie
      <application>vim</application> oder
      <application>emacs</application>.</para>
  </sect1>

  <sect1>
    <title>Ger&auml;te und Ger&auml;tedateien</title>

    <para>Der Begriff Ger&auml;t wird meist in Verbindung mit Hardware
      wie Laufwerken, Druckern, Grafikkarten oder Tastaturen gebraucht.
      Der Gro&szlig;teil der Meldungen, die beim Booten von FreeBSD angezeigt
      werden, beziehen sich auf gefundene Ger&auml;te.  Sie k&ouml;nnen sich
      die Bootmeldungen sp&auml;ter in <filename>/var/run/dmesg.boot</filename>
      ansehen.</para>

    <para>Ger&auml;tenamen, die Sie wahrscheinlich in den Bootmeldungen sehen
      werden, sind zum Beispiel <devicename>acd0</devicename>, das erste
      IDE CDROM oder <devicename>kbd0</devicename>, die Tastatur.</para>

    <para>Auf die meisten Ger&auml;te wird unter Unix &uuml;ber spezielle
      Ger&auml;tedateien im <filename>/dev</filename> Verzeichnis
      zugegriffen.</para>

    <sect2>
      <title>Anlegen von Ger&auml;tedateien</title>
      <para>Wenn sie ein neues Ger&auml;t zu Ihrem System hinzuf&uuml;gen,
	oder die Unterst&uuml;tzung f&uuml;r zus&auml;tzliche Ger&auml;te
	kompilieren, mu&szlig; oft ein Ger&auml;tetreiber erstellt
	werden.</para>

      <sect3>
	<title>MAKEDEV Skript</title>
	<para>Auf Systemen ohne DEVFS m&uuml;ssen Ger&auml;tedateien mit
	  &man.MAKEDEV.8; wie unten gezeigt angelegt werden:</para>

	<screen>&prompt.root; cd /dev
&prompt.root; sh MAKEDEV ad1
	</screen>

	<para>Im Beispiel werden alle Ger&auml;tedateien f&uuml;r das
	  zweite IDE Laufwerk angelegt.</para>
      </sect3>

      <sect3>
	<title>devfs (Ger&auml;tedateisystem)</title>

	<para>Das Ger&auml;tedateisystem devfs erm&ouml;glicht durch den
	  Namensraum des Dateisystems Zugriff auf den Namensraum der
	  Ger&auml;te im Kernel.  Damit m&uuml;ssen Ger&auml;tedateien
	  nicht mehr extra angelegt werden, sondern werden von devfs
	  verwaltet.</para>

	<para>Weitere Informationen finden Sie in &man.devfs.5;.</para>

	<para>In der Grundeinstellung benutzt FreeBSD 5.0 devfs.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Weitere Informationen...</title>

    <sect2 id="basics-man">
      <title>Manual-Pages</title>
      <indexterm><primary>Manual-Pages</primary></indexterm>

      <para>Die umfassendste Dokumentation rund um FreeBSD gibt es in
        Form von Manual-Pages.  Ann&auml;hernd jedes Programm im System
        bringt eine kurze Referenzdokumentation mit, die die
        grunds&auml;tzliche Funktion und verschiedene Parameter 
        erkl&auml;rt.  Diese Dokumentationen kann man mit dem 
        <command>man</command> Kommando benutzen.  Die Benutzung des 
        <command>man</command> Kommandos ist einfach:</para>

      <screen>&prompt.user; <userinput>man <replaceable>Kommando</replaceable></userinput></screen>

      <para><literal>Kommando</literal> ist der Name des Kommandos,
        &uuml;ber das Sie etwas erfahren wollen. Um beispielsweise
        mehr &uuml;ber das Kommando <command>ls</command> zu lernen,
        geben Sie ein:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Die Online-Dokumentation ist in nummerierte Sektionen
        unterteilt:</para>

      <orderedlist>
	<listitem>
	  <para>Benutzerkommandos.</para>
	</listitem>

	<listitem>
	  <para>Systemaufrufe und Fehlernummern.</para>
	</listitem>

	<listitem>
	  <para>Funktionen der C Bibliothek.</para>
	</listitem>

	<listitem>
	  <para>Ger&auml;tetreiber.</para>
	</listitem>

	<listitem>
	  <para>Dateiformate.</para>
	</listitem>

	<listitem>
	  <para>Spiele und andere Unterhaltung.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Informationen.</para>
	</listitem>

	<listitem>
	  <para>Systemverwaltung und -Kommandos.</para>
	</listitem>

	<listitem>
	  <para>Kernel Entwickler.</para>
	</listitem>
      </orderedlist>

      <para>In einigen F&auml;llen kann dasselbe Thema in mehreren
        Sektionen auftauchen.  Es gibt zum Beispiel ein <command>chmod</command>
        Benutzerkommando und einen <function>chmod()</function>
        Systemaufruf.  In diesem Fall k&ouml;nnen Sie dem
	<command>man</command> Kommando
        sagen, aus welcher Sektion Sie die Information erhalten
        m&ouml;chten, indem Sie die Sektion mit angeben:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Dies wird Ihnen die Man-Page f&uuml;r das Benutzerkommando
        <command>chmod</command> zeigen.  Verweise auf eine Sektion
        der Man-Pages werden traditionsgem&auml;&szlig; in Klammern
        gesetzt.  So bezieht sich &man.chmod.1; auf das
        Benutzerkommando <command>chmod</command> und mit
        &man.chmod.2; ist der Systemaufruf gemeint.</para>

      <para>Das ist nett, wenn Sie den Namen eines Kommandos wissen,
        und lediglich wissen wollen, wie es zu benutzen ist. Aber was
        tun Sie, wenn Sie Sich nicht an den Namen des Kommandos
        erinnern k&ouml;nnen?  Sie k&ouml;nnen <command>man</command>
	benutzen, um nach Schl&uuml;sselbegriffen in den
	Kommandobeschreibungen zu suchen, indem Sie den Parameter
	<option>-k</option> benutzen:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para> Mit diesem Kommando bekommen Sie eine Liste der
        Kommandos, deren Beschreibung das Schl&uuml;sselwort
        <quote>mail</quote> enth&auml;lt.  Diese Funktionalit&auml;t
        erhalten Sie auch, wenn Sie das Kommando <command>apropos</command>
        benutzen.</para>

      <para>Nun, Sie schauen Sich alle die geheimnisvollen Kommandos
        in <filename>/usr/bin</filename> an, haben aber nicht den
        blassesten Schimmer, wozu die meisten davon gut sind?  Dann
        geben Sie doch einfach </para>
        <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

        <para>oder</para>

        <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

        <para>ein, beides tut dasselbe</para>
    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info Dateien</title>

      <para>FreeBSD enth&auml;lt viele Applikationen und Utilities
        der Free Software Foundation (FSF).  Zus&auml;tzlich zu den
        Manual-Pages bringen diese Programme ausf&uuml;hrlichere
        Hypertext-Dokumente (<literal>info</literal> genannt) mit, 
        welche man sich mit dem Kommando <command>info</command>
        ansehen kann.  Wenn Sie <application>emacs</application>
        installiert haben, k&ouml;nnen Sie auch dessen info-Modus
        benutzen.</para>

      <para>Um das Kommando &man.info.1; zu benutzen, geben Sie
        einfach ein:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Eine kurze Einf&uuml;hrung gibt es mit
        <literal>h</literal>; eine Befehlsreferenz erhalten Sie durch
        Eingabe von: <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

