<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/basics/chapter.sgml,v 1.65 2003/05/27 00:33:27 mheinen Exp $
     basiert auf: 1.97
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
	 <firstname>Chris</firstname>
	 <surname>Shumway</surname>
	 <contrib>Umgeschrieben von </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
    <authorgroup>
      <author>
	 <firstname>Uwe</firstname>
	 <surname>Pierau</surname>
	 <contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Grundlagen des &unix; Betriebssystems</title>

  <sect1 id="basics-synopsis">
    <title>&Uuml;bersicht</title>
    <indexterm><primary>Grundlagen</primary></indexterm>

   <para>Das folgende Kapitel umfasst die grundlegenden Kommandos
     und Funktionsweisen des Betriebssystems FreeBSD.  Viel von dem folgenden
     Material gilt auch f&uuml;r jedes andere &unix; System.
     Falls Sie mit dem Material schon vertraut sind, k&ouml;nnen Sie dieses
     Kapitel &uuml;berlesen.  Wenn FreeBSD neu f&uuml;r Sie ist, dann sollten
     Sie dieses Kapitel auf jeden Fall aufmerksam lesen.</para>

   <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes
     wissen:</para>

   <itemizedlist>
     <listitem>
       <para>wie Zugriffsrechte unter &unix; Systemen funktionieren,</para>
     </listitem>
     <listitem>
       <para>wie Sie Zugriffskontrolllisten f&uuml;r Dateisysteme
         konfigurieren,</para>
     </listitem>
     <listitem>
       <para>was Prozesse, D&auml;monen und Signale sind,</para>
     </listitem>
     <listitem>
       <para>was eine Shell ist und wie Sie die Login Umgebung
	 &auml;ndern,</para>
     </listitem>
     <listitem>
       <para>wie Sie mit Texteditoren umgehen, und</para>
     </listitem>
     <listitem>
       <para>wie Sie in den Manualpages nach weiteren Informationen
	 suchen k&ouml;nnen,</para>
     </listitem>
     <listitem>
       <para>wie Sie mit virtuellen Konsolen umgehen.</para>
     </listitem>
   </itemizedlist>

  </sect1>

  <sect1 id="permissions">
    <title>Zugriffsrechte</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD, das ein direkter Abk&ouml;mmling von BSD &unix; ist,
      st&uuml;tzt sich auf mehrere Grundkonzepte von &unix; Systemen.
      Das erste und ausgepr&auml;gteste: FreeBSD ist
      ein Mehrbenutzer Betriebssystem.  Das System erm&ouml;glicht,
      dass mehrere Benutzer gleichzeitig an v&ouml;llig verschiedenen
      und unabh&auml;ngigen Aufgaben arbeiten k&ouml;nnen.  Es ist
      verantwortlich f&uuml;r eine gerechte Auf- und Zuteilung von
      Nachfragen nach Hardware- und Peripherieger&auml;ten, Speicher
      und CPU Zeit unter den Benutzern.</para>

    <para>Da das System mehrere Benutzer unterst&uuml;tzt, hat alles,
      was das System verwaltet, einen Satz von Rechten, die bestimmen,
      wer die jeweilige Ressource lesen, schreiben oder ausf&uuml;hren
      darf.  Diese Zugriffsrechte stehen in zwei Achtergruppen, die in
      drei Teile unterteilt sind: einen f&uuml;r den Besitzer der
      Datei, einen f&uuml;r die Gruppe, zu der die Datei geh&ouml;rt
      und einen f&uuml;r alle anderen.  Die numerische Darstellung
      sieht wie folgt aus:</para>

    <indexterm><primary>Zugriffsrechte</primary></indexterm>
    <indexterm>
      <primary>Dateizugriffsrechte</primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Wert</entry>
	    <entry>Zugriffsrechte</entry>
	    <entry>Auflistung im Verzeichnis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Kein Lesen, Kein Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Kein Lesen, Kein Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Kein Lesen, Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Kein Lesen, Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lesen, Kein Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lesen, Kein Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lesen, Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lesen, Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>Verzeichnisse</primary></indexterm>

    <para>Sie k&ouml;nnen <option>-l</option> auf der Kommandozeile
      von &man.ls.1; angeben, um eine ausf&uuml;hrliche Verzeichnisauflistung
      zu sehen, die in einer Spalte die Zugriffsrechte f&uuml;r den
      Besitzer, die Gruppe und alle anderen enth&auml;lt.  Die erste
      Spalte von <command>ls -l</command> k&ouml;nnte wie folgt
      aussehen:</para>

    <screen>-rw-r--r--</screen>

    <para>Das erste Zeichen von links ist ein Symbol, welches angibt,
      ob es sich um eine normale Datei, ein Verzeichnis, ein
      Character-Device, ein Socket oder irgendeine andere
      Pseudo-Datei handelt.  In diesem Beispiel zeigt <literal>-</literal> eine
      normale Datei an.  Die n&auml;chsten drei Zeichen,
      dargestellt als <literal>rw-</literal>, ergeben die Rechte
      f&uuml;r den Datei-Besitzer.  Die drei Zeichen danach
      <literal>r--</literal> die Rechte der Gruppe, zu der die Datei
      geh&ouml;rt.  Die letzten drei Zeichen, <literal>r--</literal>,
      geben die Rechte f&uuml;r den Rest der Welt an.  Ein Minus
      bedeutet, dass das Recht nicht gegeben ist.  In diesem Fall
      sind die Zugriffsrechte also: der Eigent&uuml;mer kann die Datei
      lesen und schreiben, die Gruppe kann lesen und alle anderen
      k&ouml;nnen auch nur lesen.  Entsprechend obiger Tabelle
      w&auml;ren die Zugriffsrechte f&uuml;r diese Datei
      <literal>644</literal>, worin jede Ziffer die drei Teile der
      Zugriffsrechte dieser Datei verk&ouml;rpert.</para>

    <para>Das ist alles sch&ouml;n und gut, aber wie kontrolliert das
      System die Rechte von Hardware Ger&auml;ten?  FreeBSD behandelt
      die meisten Hardware Ger&auml;te als Dateien, welche Programme
      &ouml;ffnen, lesen und mit Daten beschreiben k&ouml;nnen wie
      alle anderen Dateien auch.  Diese Spezial-Dateien sind im
      Verzeichnis <filename>/dev</filename> gespeichert.</para>

    <para>Verzeichnisse werden ebenfalls wie Dateien behandelt.  Sie
      haben Lese-, Schreib- und Ausf&uuml;hr-Rechte.  Das
      Ausf&uuml;hrungs-Bit hat eine etwas andere Bedeutung f&uuml;r
      ein Verzeichnis als f&uuml;r eine Datei.  Die Ausf&uuml;hrbarkeit
      eines Verzeichnisses bedeutet, dass in das Verzeichnis
      zum Beispiel mit <command>cd</command> gewechselt werden kann.
      Das bedeutet auch, dass in dem Verzeichnis auf Dateien, deren
      Namen bekannt sind, zugegriffen werden kann, vorausgesetzt die
      Zugriffsrechte der Dateien lassen dies zu.</para>

    <para>Das Leserecht auf einem Verzeichnis erlaubt es, sich den Inhalt
      des Verzeichnisses anzeigen zu lassen.  Um eine Datei mit bekanntem
      Namen in einem Verzeichnis zu l&ouml;schen, m&uuml;ssen auf dem
      Verzeichnis Schreib- <emphasis>und</emphasis> Ausf&uuml;hr-Rechte
      gesetzt sein.</para>

    <para>Es gibt noch mehr Rechte, aber die werden vor allem in
      speziellen Umst&auml;nden benutzt, wie zum Beispiel bei
      SetUID-Binaries und Verzeichnissen mit gesetztem Sticky-Bit.
      Mehr &uuml;ber Zugriffsrechte von Dateien und wie sie gesetzt werden,
      finden Sie in &man.chmod.1;.</para>
  </sect1>

  <sect1 id="fs-acl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>ACL</primary>
    </indexterm>
    <title>Zugriffskontrolllisten f&uuml;r Dateisysteme</title>

    <para>Zusammen mit anderen Verbesserungen des Dateisystems wie
      Schnappsch&uuml;sse gibt es ab FreeBSD&nbsp;5.0
      <firstterm>Zugriffskontrolllisten</firstterm> (<foreignphrase>access
        control list</foreignphrase>, <acronym>ACL</acronym>).</para>

    <para>Zugriffskontrolllisten erweitern die normalen Zugriffsrechte
      von &unix; Systemen in einer POSIX.1e-kompatiblen Art und Weise
      und bieten feiner granulierte Sicherheitsmechanismen.</para>

    <para>Zugriffskontrolllisten f&uuml;r Dateisysteme werden mit der
      nachstehenden Zeile in der Kernelkonfiguration aktiviert:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>Diese Option ist in der <filename>GENERIC</filename>-Konfiguration
      aktiviert.  Das System gibt eine Warnung aus, wenn ein Dateisystem mit
      <acronym>ACL</acronym>s eingehangen werden soll und die
      Unterst&uuml;tzung f&uuml;r <acronym>ACL</acronym>s nicht im Kernel
      aktiviert ist.  Das Dateisystem muss weiterhin erweiterte Attribute
      zur Verf&uuml;gung stellen, damit <acronym>ACL</acronym>s verwendet
      werden k&ouml;nnen.  Das neue <acronym>UNIX</acronym>-Dateisystem
      <acronym>UFS2</acronym> stellt diese Attribute
      standardm&auml;&szlig;ig zur Verf&uuml;gung.</para>

    <note><para>Die Konfiguration erweiterter Attribute auf
      <acronym>UFS1</acronym> ist mit einem h&ouml;heren Aufwand als die
      Konfiguration erweiterter Attribute auf <acronym>UFS2</acronym>
      verbunden.  Zudem ist <acronym>UFS2</acronym> mit erweiterten
      Attributen leistungsf&auml;higer als <acronym>UFS1</acronym>.
      Zugriffskontrolllisten sollten daher mit <acronym>UFS2</acronym>
      verwendet werden.</para></note>

    <para>Die Angabe der Option <option>acl</option> in
      <filename>/etc/fstab</filename> aktiviert Zugriffskontrolllisten
      f&uuml;r ein Dateisystem.  Die bevorzugte M&ouml;glichkeit ist
      die Verwendung von Zugriffskontrolllisten mit &man.tunefs.8; (Option
      <option>-a</option>), im Superblock des Dateisystems festzuschreiben.
      Diese M&ouml;glichkeit hat mehrere Vorteile:</para>

    <itemizedlist>
      <listitem>
	<para>Nochmaliges Einh&auml;ngen eines Dateisystems (Option
	  <option>-u</option> von &man.mount.8;) ver&auml;ndert den Status
	  der Zugriffskontrolllisten nicht.  Die Verwendung von
	  Zugriffskontrolllisten kann nur durch Abh&auml;ngen und erneutes
	  Einh&auml;ngen eines Dateisystems ver&auml;ndert werden.  Das
	  hei&szlig;t auch, dass Zugriffskontrolllisten nicht
	  nachtr&auml;glich auf dem Root-Dateisystem aktiviert werden
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Die Zugriffskontrolllisten auf den Dateisystemen sind,
	  unabh&auml;ngig von den Option in <filename>/etc/fstab</filename>
	  oder Namens&auml;nderungen der Ger&auml;te, immer aktiv.  Dies
	  verhindert auch, dass Zugriffskontrolllisten aus Versehen
	  auf Dateisystem ohne Zugriffskontrolllisten aktiviert werden und
	  durch falsche Zugriffsrechte Sicherheitsprobleme entstehen.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Es kann sein, dass sich der Status von Zugriffskontrolllisten
        sp&auml;ter durch nochmaliges Einh&auml;ngen des Dateisystems
	(Option <option>-u</option> von &man.mount.8;) &auml;ndern
	l&auml;sst.  Die momentane Variante ist aber sicherer, da der
	Status der Zugriffskontrolllisten nicht versehentlich ge&auml;ndert
	werden kann.  Allgemein sollten Zugriffskontrolllisten auf einem
	Dateisystem, auf dem sie einmal verwendet wurden, nicht deaktiviert
	werden, da danach die Zugriffsrechte falsch sein k&ouml;nnen.
	Werden Zugriffskontrolllisten auf einem solchen Dateisystem wieder
	aktiviert, werden die Zugriffsrechte von Dateien, die sich
	zwischenzeitlich ge&auml;ndert haben, &uuml;berschrieben, was zu
	erneuten Problemen f&uuml;hrt.</para>
    </note>

    <para>Die Zugriffsrechte einer Datei werden durch ein
      <literal>+</literal> (Plus) gekennzeichnet, wenn die Datei durch
      Zugriffskontrolllisten gesch&uuml;tzt ist:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>Die Verzeichnisse <filename>directory1</filename>,
      <filename>directory2</filename> und <filename>directory3</filename>
      sind durch Zugriffskontrolllisten gesch&uuml;tzt, das Verzeichnis
      <filename>public_html</filename> nicht.</para>
  </sect1>

  <sect1 id="dirstructure">
    <title>Verzeichnis-Strukturen</title>
    <indexterm><primary>Verzeichnis Hierarchien</primary></indexterm>

    <para>Die FreeBSD Verzeichnis Hierarchie ist die Grundlange, um
      ein umfassendes Verst&auml;ndnis des Systems zu erlangen.
      Das wichtigste Konzept, das Sie verstehen sollten, ist das
      Root-Verzeichnis <quote>/</quote>.  Dieses Verzeichnis ist das
      erste, das w&auml;hrend des Bootens eingehangen wird.  Es
      enth&auml;lt das notwendige Basissystem, um das System in den
      Mehrbenutzerbetrieb zu bringen.  Das Root-Verzeichnis enth&auml;lt
      auch die Mountpunkte anderer Dateisysteme, die sp&auml;ter
      eingehangen werden.</para>

    <para>Ein Mountpunkt ist ein Verzeichnis, in das zus&auml;tzliche
      Dateisysteme in das <filename>/</filename> Verzeichnis eingepflanzt
      werden k&ouml;nnen.
      Standard Mountpunkte beinhalten <filename>/usr</filename>,
      <filename>/var</filename>, <filename>/mnt</filename> und
      <filename>/cdrom</filename>.  Auf diese Verzeichnisse verweisen
      &uuml;blicherweise Eintr&auml;ge in der Datei
      <filename>/etc/fstab</filename>.  <filename>/etc/fstab</filename> ist
      eine Tabelle mit verschiedenen Dateisystemen und Mountpunkten
      als Referenz des Systems.  Die meisten der Dateisysteme in
      <filename>/etc/fstab</filename> werden beim Booten automatisch
      durch das Skript &man.rc.8; gemountet, wenn die zugeh&ouml;rigen
      Eintr&auml;ge nicht mit der Option <option>noauto</option>
      versehen sind.  Konsultieren Sie die &man.fstab.5; Manualpage
      f&uuml;r mehr Informationen &uuml;ber das Format der Datei
      <filename>/etc/fstab</filename> und den Optionen darin.</para>

    <para>Eine vollst&auml;ndige Beschreibung der Dateisystem-Hierarchie
      finden Sie in &man.hier.7;.  Als Beispiel sei eine kurze
      &Uuml;bersicht &uuml;ber die gebr&auml;uchlisten Verzeichnisse
      gegeben:</para>

    <para>
      <informaltable frame="none">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Verzeichnis</entry>
	      <entry>Beschreibung</entry>
	    </row>
	  </thead>
	  <tbody>
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Root-Verzeichnis des Dateisystems.</entry>
            </row>

	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Grundlegende Werkzeuge f&uuml;r den Single-User-Modus
		sowie den Mehrbenutzerbetrieb.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Programme und Konfigurationsdateien, die w&auml;hrend
		des Bootens benutzt werden.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Vorgaben f&uuml;r die Boot-Konfiguration, siehe
		&man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Ger&auml;tedateien, siehe &man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Konfigurationsdateien und Skripten des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Vorgaben f&uuml;r die System Konfigurationsdateien,
		siehe &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>Konfigurationsdateien von MTAs wie
		&man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry>Konfigurationsdateien von <command>named</command>,
		siehe &man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>T&auml;glich, w&ouml;chentlich oder monatlich
		ablaufende Skripte, die von &man.cron.8; gestartet werden.
		Siehe &man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry>Konfigurationsdateien von <command>ppp</command>,
		siehe &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>Ein leeres Verzeichnis, das von Systemadministratoren
		h&auml;ufig als tempor&auml;rer Mountpunkt genutzt wird.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Prozess Dateisystem, siehe &man.procfs.5;
		und &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry>Home Verzeichnis von <username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>Systemprogramme und administrative Werkzeuge, die
		grundlegend f&uuml;r den Single-User-Modus und den
		Mehrbenutzerbetrieb sind.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
	      <entry>Programme, die ohne andere Programme oder Bibliotheken
		laufen.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Tempor&auml;re Dateien, die f&uuml;r gew&ouml;hnlich
		nicht nach einem Reboot erhalten werden.  Dies kann
		ein speicherbasiertes Dateisystem, siehe &man.mfs.8;,
		sein.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>Der Gro&szlig;teil der Benutzerprogramme und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Gebr&auml;uchliche Werkzeuge, Programmierhilfen und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Standard C include-Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Bibliotheken.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Daten verschiedener Werkzeuge.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>System-D&auml;monen und System-Werkzeuge, die von
		anderen Programmen ausgef&uuml;hrt werden.</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>Lokale Programme, Bibliotheken usw.  Die Ports-Sammlung
		benutzt dieses Verzeichnis als Zielverzeichnis f&uuml;r zu
		installierende Anwendungen.  Innerhalb von
		<filename>/usr/local</filename> sollte das von
		&man.hier.7; beschriebene Layout f&uuml;r
		<filename>/usr</filename> benutzt werden.  Das
		<filename>man</filename> Verzeichnis wird direkt unter
		<filename>/usr/local</filename> anstelle unter
		<filename>/usr/local/share</filename> angelegt.  Die
		Dokumentation der Ports findet sich in
		<filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Von der Architektur abh&auml;ngiger Verzeichnisbaum,
		der durch das Bauen von <filename>/usr/src</filename>
		entsteht.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
	      <entry>Die FreeBSD Ports-Sammlung (optional).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>System-D&auml;monen und System-Werkzeuge, die von
		Benutzern ausgef&uuml;hrt werden.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Von der Architektur unabh&auml;ngige Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>Quelldateien von BSD und/oder lokalen
		Erg&auml;nzungen.</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>Optionale X11R6 Programme und Bibliotheken.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Wird f&uuml;r mehrere Zwecke genutzt und enth&auml;lt
		Logdateien, tempor&auml;re Daten und Spooldateien.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Verschiedene Logdateien des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Postf&auml;cher der Benutzer.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Verschiedene Spool-Verzeichnisse der Drucker- und
		Mailsysteme.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Tempor&auml;re Dateien, die &uuml;ber Reboots erhalten
		bleiben.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>NIS maps.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>
  </sect1>

  <sect1 id="basics-processes">
    <title>Prozesse</title>

    <para>Da FreeBSD ein Multitasking Betriebssystem ist, sieht es so aus,
      als ob mehrere Prozesse zur gleichen Zeit laufen.  Jedes Programm,
      das zu irgendeiner Zeit l&auml;uft, wird
      <firstterm>Prozess</firstterm> genannt.  Jedes Kommando
      startet mindestens einen Prozess.  Einige Systemprozesse
      laufen st&auml;ndig und stellen die Funktion des Systems sicher.</para>

    <para>Jeder Prozess wird durch eine eindeutige Nummer identifiziert,
      die <firstterm>Prozess-ID</firstterm> oder
      <firstterm>PID</firstterm> genannt wird.  Prozesse haben ebenso
      wie Dateien einen Besitzer und eine Gruppe, die festlegen, welche
      Dateien und Ger&auml;te der Prozess benutzen kann.  Dabei
      finden die vorher beschriebenen Zugriffsrechte Anwendung.  Die meisten
      Prozesse haben auch einen Elternprozess, der sie gestartet hat.
      Wenn Sie in der Shell Kommandos eingeben, dann ist die Shell ein
      Prozess und jedes Kommando, das Sie starten, ist auch ein
      Prozess.  Jeder Prozess, den Sie auf diese Weise starten,
      besitzt den Shell-Prozess als Elternprozess.  Die Ausnahme
      hiervon ist ein spezieller Prozess, der <command>init</command>
      hei&szlig;t.  <command>init</command> ist immer der erste Prozess
      und hat somit die PID 1.  <command>init</command> wird vom Kernel
      beim Booten von FreeBSD gestartet.</para>

    <para>Die Kommandos &man.ps.1; und &man.top.1; sind besonders
      n&uuml;tzlich, um sich die Prozesse auf einem System anzusehen.
      &man.ps.1; zeigt eine statische Liste der laufenden Prozesse
      und kann deren PID, Speicherverbrauch und die Kommandozeile, mit der
      sie gestartet wurden und vieles mehr anzeigen.  &man.top.1; zeigt alle
      laufenden Prozesse an und aktualisiert die Anzeige, so dass
      Sie Ihrem Computer bei der Arbeit zuschauen k&ouml;nnen.</para>

    <para>Normal zeigt Ihnen &man.ps.1; nur die laufenden Prozesse,
      die Ihnen geh&ouml;ren.  Zum Beispiel:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Wie Sie sehen, gibt &man.ps.1; mehrere Spalten aus.  In der
      <literal>PID</literal> Spalte findet sich die vorher besprochene
      Prozess-ID.  PIDs werden von 1 beginnend bis 99999 zugewiesen
      und fangen wieder von vorne an, wenn die Grenze &uuml;berschritten
      wird.  <literal>TT</literal> zeigt den Terminal, auf dem das
      Programm l&auml;uft.  <literal>STAT</literal> zeigt den Status
      des Programms an und kann f&uuml;r die Zwecke dieser Diskussion ebenso
      wie <literal>TT</literal> ignoriert werden.  <literal>TIME</literal>
      gibt die Zeit an, die das Programm auf der CPU gelaufen ist &ndash;
      dies ist nicht unbedingt die Zeit, die seit dem Start des Programms
      vergangen ist, da einige Programme viel Zeit mit dem Warten auf
      bestimmte Dinge verbringen, bevor sie wirklich CPU-Zeit verbrauchen.
      Unter der Spalte <literal>COMMAND</literal> finden Sie schlie&szlig;lich
      die Kommandozeile, mit der das Programm gestartet wurde.</para>

    <para>&man.ps.1; besitzt viele Optionen, um die angezeigten Informationen
      zu beeinflussen.  Eine n&uuml;tzliche Kombination ist
      <literal>auxww</literal>.  Mit <option>a</option> werden Information
      &uuml;ber alle laufenden Prozesse und nicht nur Ihrer eigenen
      angezeigt.  Der Name des Besitzers des Prozesses, sowie Informationen
      &uuml;ber den Speicherverbrauch werden mit <option>u</option>
      angezeigt.  <option>x</option> zeigt auch D&auml;monen-Prozesse an,
      und <option>ww</option> veranlasst &man.ps.1; die komplette
      Kommandozeile anzuzeigen, anstatt sie abzuschneiden, wenn sie
      zu lang f&uuml;r die Bildschirmausgabe wird.</para>

    <para>Die Ausgabe von &man.top.1; sieht &auml;hnlich aus:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Die Ausgabe ist in zwei Abschnitte geteilt.  In den ersten
      f&uuml;nf Kopfzeilen finden sich die zuletzt zugeteilte PID, die
      Systemauslastung (engl. <foreignphrase>load average</foreignphrase>),
      die Systemlaufzeit (die Zeit seit dem letzten Reboot) und die
      momentane Zeit.  Die weiteren Zahlen im Kopf beschreiben wie viele
      Prozesse momentan laufen (im Beispiel 47), wie viel Speicher
      und Swap verbraucht wurde und wie viel Zeit das System in den
      verschiedenen CPU-Modi verbringt.</para>

    <para>Darunter befinden sich einige Spalten mit &auml;hnlichen
      Informationen wie in der Ausgabe von &man.ps.1;.  Wie im vorigen
      Beispiel k&ouml;nnen Sie die PID, den Besitzer, die verbrauchte
      CPU-Zeit und das Kommando erkennen.  &man.top.1; zeigt auch den
      Speicherverbrauch des Prozesses an, der in zwei Spalten aufgeteilt
      ist.  Die erste Spalte gibt den gesamten Speicherverbrauch des
      Prozesses an, in der zweiten Spalte wird der aktuelle Verbrauch
      angegeben.  <application>Netscape</application> hat im gezeigten
      Beispiel insgesamt 30&nbsp;MB Speicher verbraucht.  Momentan benutzt
      es allerdings nur 9&nbsp;MB.</para>

    <para>Die Anzeige wird von &man.top.1; automatisch alle zwei Sekunden
      aktualisiert.  Der Zeitraum kann mit <option>-s</option> eingestellt
      werden.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>D&auml;monen, Signale und Stoppen von Prozessen</title>

    <para>Wenn Sie einen Editor starten, k&ouml;nnen Sie ihn leicht bedienen
      und Dateien laden.  Sie k&ouml;nnen das, weil der Editor daf&uuml;r
      Vorsorge getroffen hat und auf einem <firstterm>Terminal</firstterm>
      l&auml;uft.  Manche Programme erwarten keine Eingaben von einem
      Benutzer und l&ouml;sen sich bei erster Gelegenheit von ihrem
      Terminal.  Ein Web-Server zum Beispiel verbringt den ganzen Tag
      damit, auf Anfragen zu antworten und erwartet keine Eingaben von Ihnen.
      Programme, die E-Mail von einem Ort zu einem anderen Ort transportieren
      sind ein weiteres Beispiel f&uuml;r diesen Typ von Anwendungen.</para>

    <para>Wir nennen diese Programme <firstterm>D&auml;monen</firstterm>.
      D&auml;monen stammen aus der griechischen Mythologie und waren
      weder gut noch b&ouml;se.  Sie waren kleine dienstbare Geister,
      die meistens n&uuml;tzliche Sachen f&uuml;r die Menschheit vollbrachten.
      &Auml;hnlich wie heutzutage Web-Server und Mail-Server n&uuml;tzliche
      Dienste verrichten.  Seit langer Zeit ist daher das BSD Maskottchen
      dieser fr&ouml;hlich aussehende D&auml;mon mit Turnschuhen
      und Dreizack.</para>

    <para>Programme, die als D&auml;mon laufen, werden entsprechend einer
      Konvention mit einem <quote>d</quote> am Ende benannt.
      <application>BIND</application> ist der Berkeley Internet Name Daemon
      und das tats&auml;chlich laufende Programm hei&szlig;t
      <command>named</command>.  Der Apache Webserver wird
      <command>httpd</command> genannt, der Druckerspool-D&auml;mon hei&szlig;t
      <command>lpd</command> usw.  Dies ist allerdings eine Konvention
      und keine unumst&ouml;&szlig;liche Regel: Der D&auml;mon der
      Anwendung <application>sendmail</application> hei&szlig;t
      <command>sendmail</command> und nicht <command>maild</command>, wie
      Sie vielleicht gedacht hatten.</para>

    <para>Manchmal m&uuml;ssen Sie mit einem D&auml;mon kommunizieren und
      dazu benutzen Sie <firstterm>Signale</firstterm>.  Sie k&ouml;nnen
      mit einem D&auml;monen oder jedem anderen laufenden Prozess
      kommunizieren, indem Sie diesem ein Signal schicken.  Sie k&ouml;nnen
      verschiedene Signale verschicken &ndash; manche haben eine festgelegte
      Bedeutung, andere werden von der Anwendung interpretiert.  Die
      Dokumentation zur fraglichen Anwendung wird erkl&auml;ren, wie
      die Anwendung Signale interpretiert.  Sie k&ouml;nnen nur Signale
      zu Prozessen senden,  die Ihnen geh&ouml;ren.  Normale Benutzer haben
      nicht die Berechtigung, Prozessen anderer Benutzer mit &man.kill.1;
      oder &man.kill.2; Signale zu schicken.  Der Benutzer
      <username>root</username> darf jedem Prozess Signale schicken.</para>

    <para>In manchen F&auml;llen wird FreeBSD Signale senden.  Wenn eine
      Anwendung schlecht geschrieben ist und auf Speicher zugreift, auf
      den sie nicht zugreifen soll, so sendet FreeBSD dem Prozess
      das <firstterm>Segmentation Violation</firstterm> Signal
      (<literal>SIGSEGV</literal>).  Wenn eine Anwendung den &man.alarm.3;
      Systemaufruf benutzt hat, um nach einiger Zeit benachrichtigt zu
      werden, bekommt sie das Alarm Signal (<literal>SIGALRM</literal>)
      gesendet.</para>

    <para>Zwei Signale k&ouml;nnen benutzt werden, um Prozesse zu stoppen:
      <literal>SIGTERM</literal> und <literal>SIGKILL</literal>.  Mit
      <literal>SIGTERM</literal> fordern Sie den Prozess h&ouml;flich zum
      Beenden auf.  Der Prozess kann das Signal abfangen und merken,
      dass er sich beenden soll.  Er hat dann Gelegenheit Logdateien
      zu schlie&szlig;en und die Aktion, die er vor der Aufforderung
      sich zu beenden durchf&uuml;hrte, abzuschlie&szlig;en.  Er kann
      sogar <literal>SIGTERM</literal> ignorieren, wenn er eine Aktion
      durchf&uuml;hrt, die nicht unterbrochen werden darf.</para>

    <para><literal>SIGKILL</literal> kann von keinem Prozess ignoriert
      werden.  Das Signal l&auml;sst sich mit <quote>Mich interessiert
      nicht, was du gerade machst, h&ouml;r sofort auf damit!</quote>
      umschreiben.  Wenn Sie einem Prozess <literal>SIGKILL</literal>
      schicken, dann wird FreeBSD diesen sofort beenden<footnote><para>
	Das stimmt nicht ganz: Es gibt F&auml;lle, in denen ein Prozess
	nicht unterbrochen werden kann.  Wenn der Prozesss zum Beispiel
	eine Datei von einem anderen Rechner auf dem Netzwerk liest und dieser
	Rechner aus irgendwelchen Gr&uuml;nden nicht erreichbar ist
	(ausgeschaltet, oder ein Netzwerkfehler), dann ist der Prozess
	nicht zu unterbrechen.  Wenn der Prozess den Lesezugriff
	nach einem Timeout von typischerweise zwei Minuten aufgibt,
	dann wir er beendet.</para>
      </footnote>.</para>

    <para>Andere Signale, die Sie vielleicht verschicken wollen, sind
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> und
      <literal>SIGUSR2</literal>.  Diese Signale sind f&uuml;r allgemeine
      Zwecke vorgesehen und verschiedene Anwendungen werden unterschiedlich
      auf diese Signale reagieren.</para>

    <para>Nehmen wir an, Sie haben die Konfiguration Ihres Webservers
      ver&auml;ndert und m&ouml;chten dies dem Server mitteilen.  Sie
      k&ouml;nnten den Server nat&uuml;rlich stoppen und
      <command>httpd</command> wieder starten.  Die Folge w&auml;re eine
      kurze Zeit, in der der Server nicht erreichbar ist.  Die meisten
      D&auml;monen lesen Ihre Konfigurationsdatei beim Empfang eines
      <literal>SIGHUP</literal> neu ein.  Da es keinen Standard gibt, der
      vorschreibt, wie auf diese Signale zu reagieren ist, lesen
      Sie bitte die Dokumentation zu dem in Frage kommenden D&auml;mon.</para>

    <para>Mit &man.kill.1; k&ouml;nnen Sie, wie unten gezeigt, Signale
      verschicken.</para>

    <procedure>
      <title>Verschicken von Signalen</title>

      <para>Das folgende Beispiel zeigt, wie Sie &man.inetd.8; ein Signal
	schicken.  Die Konfigurationsdatei von &man.inetd.8; ist
	<filename>/etc/inetd.conf</filename> und &man.inetd.8; liest die
	Konfigurationsdatei erneut ein, wenn er ein <literal>SIGHUP</literal>
	empf&auml;ngt.</para>

      <step>
	<para>Suchen Sie die Prozess-ID des Prozesses, dem Sie ein Signal
	  schicken wollen.  Benutzen Sie dazu &man.ps.1; und &man.grep.1;.
	  Mit &man.grep.1; k&ouml;nnen Sie in einer Ausgabe nach einem
	  String suchen.  Da &man.inetd.8; unter dem Benutzer
	  <username>root</username> l&auml;uft und Sie das Kommando als
	  normaler Benutzer absetzen, m&uuml;ssen Sie &man.ps.1; mit
	  <option>ax</option> aufrufen:</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Die Prozess-ID von &man.inetd.8; ist 198.  In einigen
	  F&auml;llen werden Sie auch das <literal>grep inetd</literal>
	  Kommando in der Ausgabe sehen.  Dies hat damit zu tun, wie
	  &man.ps.1; die Liste der laufenden Prozesse untersucht.</para>
      </step>

      <step>
	<para>Senden Sie das Signal mit &man.kill.1;.  Da &man.inetd.8;
	  unter dem Benutzer <username>root</username> l&auml;uft, m&uuml;ssen
	  Sie zuerst mit &man.su.1; <username>root</username> werden:</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>&man.kill.1; wird, wie andere Kommandos von &unix; Systemen auch, keine Ausgabe
	  erzeugen, wenn das Kommando erfolgreich war.  Wenn Sie versuchen,
	  einem Prozess, der nicht Ihnen geh&ouml;rt, ein Signal zu
	  senden, dann werden Sie die Meldung
	  <errorname>kill: <replaceable>PID</replaceable>: Operation not
	  permitted</errorname> sehen.  Wenn Sie sich bei der Eingabe der
	  PID vertippen, werden Sie das Signal dem falschen Prozess
	  schicken, was schlecht sein kann.  Wenn Sie Gl&uuml;ck haben,
	  existiert der Prozess nicht und Sie werden mit der Ausgabe
	  <errorname>kill: <replaceable>PID</replaceable>: No such
	  process</errorname> belohnt.</para>

	<note>
	  <title>Warum soll ich <command>/bin/kill</command> benutzen?</title>

	  <para>Viele Shells stellen <command>kill</command> als internes
	    Kommando zur Verf&uuml;gung, das hei&szlig;t die Shell sendet
	    das Signal direkt, anstatt <filename>/bin/kill</filename>
	    zu starten.  Das kann n&uuml;tzlich sein, aber die
	    unterschiedlichen Shells benutzen eine verschiedene Syntax,
	    um die Namen der Signale anzugeben.  Anstatt jede Syntax zu
	    lernen, kann es einfacher sein, <command>/bin/kill
	    <replaceable>...</replaceable></command> direkt aufzurufen.</para>
	</note>
      </step>
    </procedure>

    <para>Andere Signale senden Sie auf die gleiche Weise, ersetzen
      Sie nur <literal>TERM</literal> oder <literal>KILL</literal>
      entsprechend.</para>

    <important>
      <para>Es kann gravierende Auswirkungen haben, wenn Sie zuf&auml;llig
	Prozesse beenden.  Insbesondere &man.init.8; mit der Prozess-ID
	ist ein Spezialfall.  Mit <command>/bin/kill -s KILL 1</command>
	k&ouml;nnen Sie Ihr System schnell herunterfahren.
	&Uuml;berpr&uuml;fen Sie die Argumente von &man.kill.1;
	<emphasis>immer</emphasis> zweimal <emphasis>bevor</emphasis>
	Sie <keycap>Return</keycap> dr&uuml;cken.</para>
    </important>
  </sect1>

  <sect1 id="disks-mounting">
    <title>Anh&auml;ngen und Abh&auml;ngen von Dateisystemen</title>

    <para>Ein Dateisystem wird am besten als ein Baum mit der
      Wurzel <filename>/</filename> veranschaulicht.
      <filename>/dev</filename>, <filename>/usr</filename>, und
      die anderen Verzeichnisse im Rootverzeichnis sind Zweige,
      die wiederum eigene Zweige wie <filename>/usr/local</filename>
      haben k&ouml;nnen.</para>

    <indexterm><primary>Root-Dateisystem</primary></indexterm>
    <para>Es gibt verschiedene Gr&uuml;nde, bestimmte dieser Verzeichnisse
      auf eigenen Dateisystemen anzulegen.  <filename>/var</filename>
      enth&auml;lt <filename>log/</filename>, <filename>spool/</filename>
      sowie verschiedene andere tempor&auml;re
      Dateien und kann sich daher schnell f&uuml;llen.  Es empfiehlt sich,
      <filename>/var</filename> von <filename>/</filename> zu trennen,
      da es schlecht ist, wenn das Root-Dateisystem voll
      l&auml;uft.</para>

    <para>Ein weiterer Grund bestimmte Verzeichnisb&auml;ume auf
      andere Dateisysteme zu legen, ist gegeben, wenn sich die
      Verzeichnisb&auml;ume auf gesonderten physikalischen oder
      virtuellen Platten, wie
      <link linkend="network-nfs">Network File System</link>
      oder CD-ROM Laufwerken, befinden.</para>

    <sect2 id="disks-fstab">
      <title>Die <filename>fstab</filename> Datei</title>

      <indexterm>
	 <primary>Dateisysteme</primary>
	 <secondary>fstab</secondary>
      </indexterm>
      <para>W&auml;hrend des <link linkend="boot">Boot Prozesses</link>
	werden in <filename>/etc/fstab</filename> aufgef&uuml;hrte
	Verzeichnisse, sofern sie nicht mit der Option <option>noauto</option>
	versehen sind, automatisch angehangen.</para>

      <para>Die Zeilen in <filename>/etc/fstab</filename> haben das
	folgende Format:</para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>

	  <listitem>
            <para>Ein existierender Ger&auml;tename
	      wie in <xref linkend="disks-naming"> beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem>
            <para>Ein existierendes Verzeichnis,
	      an das das Dateisystem angehangen wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
            <para>Der Typ des Dateisystems,
	      der an &man.mount.8; weitergegeben wird.  Das default
	      FreeBSD Dateisystem ist <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>Entweder <option>rw</option>
	      f&uuml;r beschreibbare Dateisysteme oder <option>ro</option>
	      f&uuml;r schreibgesch&uuml;tzte Dateisysteme, gefolgt von
	      weiteren ben&ouml;tigten Optionen.  Eine h&auml;ufig verwendete
	      Option ist <option>noauto</option> f&uuml;r Dateisysteme,
	      die w&auml;hrend der normalen Bootsequenz nicht angehangen
	      werden sollen.  Weitere Optionen finden sich
	      in &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem><para>Gibt die Anzahl der Tage an, nachdem das
	      Dateisystem gesichert werden soll.  Fehlt der Wert, wird
	      <literal>0</literal> angenommen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem><para>Bestimmt die Reihenfolge, in der die Dateisysteme
	      &uuml;berpr&uuml;ft werden sollen.  F&uuml;r Dateisysteme,
	      die &uuml;bersprungen werden sollen, ist
	      <literal>passno</literal> auf null zu setzen.  F&uuml;r das
	      Root-Dateisystem, das vor allen anderen &uuml;berpr&uuml;ft
	      werden muss, sollte der Wert von
	      <literal>passno</literal> eins betragen.  Allen anderen
	      Dateisystemen sollten Werte gr&ouml;&szlig;er eins zugewiesen
	      werden.  Wenn mehrere Dateisysteme den gleichen Wert
	      besitzen, wird &man.fsck.8; versuchen, diese parallel zu
	      &uuml;berpr&uuml;fen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title>Das <command>mount</command> Kommando</title>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>anh&auml;ngen</secondary>
      </indexterm>

      <para>&man.mount.8; h&auml;ngt schlie&szlig;lich Dateisysteme
	an.</para>

      <para>In der grundlegenden Form wird es wie folgt benutzt:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Viele Optionen werden in &man.mount.8; beschrieben,
	die am h&auml;ufigsten verwendeten sind:</para>

      <variablelist>
	<title>Mount Optionen</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
            <para>H&auml;ngt alle Dateisysteme aus
	      <filename>/etc/fstab</filename> an.  Davon ausgenommen
	      sind Dateisysteme, die mit <quote>noauto</quote> markiert
	      sind, die mit der Option <option>-t</option> ausgeschlossen
	      wurden und Dateisysteme, die schon angehangen sind.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
            <para>F&uuml;hrt den entsprechenden Systemcall nicht aus.
	      N&uuml;tzlich ist diese Option in Verbindung
	      mit <option>-v</option>.  Damit wird angezeigt, was
	      &man.mount.8; tats&auml;chlich versuchen
	      w&uuml;rde, um das Dateisystem anzuh&auml;ngen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Erzwingt das Anh&auml;ngen eines unsauberen Dateisystems
	      oder erzwingt die R&uuml;cknahme des Schreibzugriffs, wenn
	      der Status des Dateisystems von beschreibbar auf
	      schreibgesch&uuml;tzt ge&auml;ndert wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>H&auml;ngt das Dateisystem schreibgesch&uuml;tzt an.  Das
	      kann auch durch Angabe von <option>rdonly</option> zu der
	      <option>-o</option> Option erreicht werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
            <para>H&auml;ngt das Dateisystem mit dem angegebenen Typ an,
	      oder h&auml;ngt nur Dateisysteme mit dem angegebenen Typ
	      an, wenn auch <option>-a</option> angegeben
	      wurde.</para>

            <para>Die Voreinstellung f&uuml;r den Typ des Dateisystems
	      ist <quote>ufs</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Aktualisiert die Mountoptionen des Dateisystems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Geschw&auml;tzig sein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>H&auml;ngt das Dateisystem beschreibbar an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para><option>-o</option> erwartet eine durch Kommata separierte Liste
	von Optionen, unter anderem die folgenden:</para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	  <listitem>
            <para>Beachtet keine Ger&auml;tedateien auf dem Dateisystem.
	      Dies ist eine n&uuml;tzliche Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	    <para>Verbietet das Ausf&uuml;hren von bin&auml;ren
	      Dateien auf dem Dateisystem.  Dies ist eine
	      n&uuml;tzliche Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>SetUID und SetGID Bits werden auf dem Dateisystem
	      nicht beachtet.  Dies ist eine n&uuml;tzliche
	      Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>Das <command>umount</command> Kommando</title>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>abh&auml;ngen</secondary>
      </indexterm>

      <para>&man.umount.8; akzeptiert als Parameter entweder
	einen Mountpoint, einen Ger&auml;tenamen, oder die
	Optionen <option>-a</option> oder <option>-A</option>.</para>

      <para>Jede Form akzeptiert <option>-f</option>, um das
	Abh&auml;ngen zu erzwingen, und <option>-v</option>, um
	etwas geschw&auml;tziger zu sein.  Seien Sie bitte vorsichtig mit
	<option>-f</option>: Ihr Computer kann abst&uuml;rzen oder es
	k&ouml;nnen Daten auf dem Dateisystem besch&auml;digt werden, wenn
	Sie das Abh&auml;ngen erzwingen.</para>

      <para><option>-a</option> und <option>-A</option> werden benutzt
	um alle Dateisysteme, deren Typ durch <option>-t</option>
	modifiziert werden kann, abzuh&auml;ngen.  <option>-A</option>
	h&auml;ngt das Rootdateisystem nicht ab.</para>
    </sect2>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>Shells</primary></indexterm>
    <indexterm><primary>Kommandozeile</primary></indexterm>

    <para>Von der tagt&auml;glichen Arbeit mit FreeBSD wird eine Menge
      mit der Kommandozeilen Schnittstelle der Shell erledigt.  Die
      Hauptaufgabe einer Shell besteht darin, Kommandos der Eingabe
      anzunehmen und diese auszuf&uuml;hren.  Viele Shells haben
      au&szlig;erdem eingebaute Funktionen, die die t&auml;gliche
      Arbeit erleichtern, beispielsweise eine Dateiverwaltung,
      die Vervollst&auml;ndigung  von Dateinamen (Globbing), einen
      Kommandozeileneditor, sowie Makros und Umgebungsvariablen.  FreeBSD
      enth&auml;lt die Shells <command>sh</command> (die Bourne Shell) und
      <command>tcsh</command> (die verbesserte C-Shell) im Basissystem.
      Viele andere Shells, wie <command>zsh</command> oder
      <command>bash</command>, befinden sich in der Ports-Sammlung.</para>

    <para>Welche Shell soll ich benutzen?  Das ist wirklich eine
      Geschmacksfrage.  Sind Sie ein C Programmierer, finden Sie
      vielleicht eine C-artige Shell wie die <command>tcsh</command>
      angenehmer.  Kommen Sie von Linux oder ist Ihnen der Umgang mit &unix; Systemen
      neu, so k&ouml;nnten Sie die <command>bash</command> probieren.
      Der Punkt ist, dass
      jede Shell ihre speziellen Eigenschaften hat, die mit Ihrer
      bevorzugten Arbeitsumgebung harmonieren k&ouml;nnen oder nicht.
      Sie m&uuml;ssen sich eine Shell aussuchen.</para>

    <para>Ein verbreitetes Merkmal in Shells ist die
      Dateinamen-Vervollst&auml;ndigung.  Sie m&uuml;ssen nur einige
      Buchstaben eines Kommandos oder eines Dateinamen eingeben und
      die Shell vervollst&auml;ndigt den Rest automatisch durch
      dr&uuml;cken der <keycap>Tab</keycap>-Taste.  Hier ist ein Beispiel.
      Angenommen, Sie
      haben zwei Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename>.  Die Datei
      <filename>foo.bar</filename> m&ouml;chten Sie l&ouml;schen.  Nun
      w&uuml;rden Sie an der Tastatur eingeben:
      <command>rm fo[<keycap>Tab</keycap>].
      [<keycap>Tab</keycap>]</command>.</para>

    <para>Die Shell w&uuml;rde dann <command>rm
      foo[BEEP].bar</command> ausgeben.</para>

    <para>[BEEP] meint den Rechner-Piepser.  Diesen gibt die Shell
      aus, um anzuzeigen, dass es den Dateinamen nicht
      vervollst&auml;ndigen konnte, da es mehrere M&ouml;glichkeiten
      gibt.  Beide Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename> beginnen mit <literal>fo</literal>,
      so konnte nur bis <literal>foo</literal> erg&auml;nzt werden.
      Nachdem Sie <literal>.</literal> eingaben und dann die
      <keycap>Tab</keycap>-Taste
      dr&uuml;ckten, konnte die Shell den Rest f&uuml;r Sie
      ausf&uuml;llen.</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>

    <para>Ein weiteres Merkmal der Shell ist der Gebrauch von
      Umgebungsvariablen.  Dies sind ver&auml;nderbare Schl&uuml;sselpaare
      im Umgebungsraum der Shell, die jedes von der Shell aufgerufene
      Programm lesen kann.  Daher enth&auml;lt der Umgebungsraum viele
      Konfigurationsdaten f&uuml;r Programme.  Die folgende Liste zeigt
      verbreitete Umgebungsvariablen und was sie bedeuten:</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>
    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Name des angemeldeten Benutzers.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Programmen.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Wenn gesetzt der Netzwerkname des X11 Bildschirms
              f&uuml;r die Anzeige.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Die aktuelle Shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Name des Terminals des Benutzers.  Benutzt, um die
              F&auml;higkeiten des Terminals bestimmen.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Datenbankeintrag der Terminal Escape Codes,
              ben&ouml;tigt um verschieden Terminalfunktionen
              auszuf&uuml;hren.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Typ des Betriebsystems.  Z.B., FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Die CPU Architektur auf dem das System
              l&auml;uft.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Betrachter.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Manualpages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Das Setzen von Umgebungsvariablen funktioniert
      von Shell zu Shell unterschiedlich.  Zum Beispiel benutzt man
      in C-artigen Shells wie der <command>tcsh</command> dazu
      <command>setenv</command>.  Unter Bourne-Shells wie <command>sh</command>
      oder <command>bash</command> benutzen Sie zum Setzen von
      Umgebungsvariablen <command>export</command>.  Um
      beispielsweise die Variable <envar>EDITOR</envar> mit
      <command>csh</command> oder <command>tcsh</command> auf
      <filename>/usr/local/bin/emacs</filename> zu setzen, setzen Sie das
      folgende Kommando ab:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Unter Bourne-Shells:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Sie k&ouml;nnen die meisten Shells Umgebungsvariablen
      expandieren lassen, in dem Sie in der Kommandozeile ein
      <literal>$</literal> davor eingeben.  Zum Beispiel gibt
      <command>echo $TERM</command> aus, worauf <envar>$TERM</envar>
      gesetzt ist, weil die Shell <envar>$TERM</envar> expandiert
      und das Ergebnis an <command>echo</command> gibt.</para>

    <para>Shells behandeln viele Spezialzeichen, so genannte
      Metazeichen, als besondere Darstellungen f&uuml;r Daten.
      Das allgemeinste ist das Zeichen <literal>*</literal>, das eine
      beliebige Anzahl Zeichen in einem Dateinamen repr&auml;sentiert.
      Diese Metazeichen k&ouml;nnen zum Vervollst&auml;ndigen von
      Dateinamen (Globbing) benutzt werden.  Beispielsweise liefert
      das Kommando <command>echo *</command> nahezu das gleiche
      wie die Eingabe von <command>ls</command>, da die Shell alle
      Dateinamen die mit <literal>*</literal> &uuml;bereinstimmen, an
      <command>echo</command> weitergibt.</para>

    <para>Um zu verhindern, dass die Shell diese Sonderzeichen
      interpretiert, kann man sie sch&uuml;tzen, indem man ihnen einen
      Backslash (<literal>\</literal>) voranstellt.  <command>echo
      $TERM</command> gibt aus, auf was auch immer Ihr Terminal
      gesetzt ist.  <command>echo \$TERM</command> gibt
      <envar>$TERM</envar> genauso aus, wie es hier steht.</para>

    <sect2 id="changing-shells">
      <title>&Auml;ndern der Shell</title>

      <para>Der einfachste Weg Ihre Shell zu &auml;ndern, ist das
        Kommando <command>chsh</command> zu benutzen.
        <command>chsh</command> platziert Sie im Editor, welcher durch
        Ihre Umgebungsvariable <envar>EDITOR</envar> gesetzt ist,
        im <command>vi</command> wenn die Variable nicht gesetzt ist.
        &Auml;ndern Sie die Zeile mit <quote>Shell:</quote>
        entsprechend Ihren W&uuml;nschen.</para>

      <para>Sie k&ouml;nnen auch <command>chsh</command> mit der Option
	<option>-s</option> aufrufen, dann wird Ihre Shell gesetzt,
        ohne dass Sie in einen Editor gelangen.  Um Ihre Shell
        zum Beispiel auf die <command>bash</command> zu &auml;ndern,
	geben Sie das folgende Kommando ein:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Dasselbe Ergebnis h&auml;tten Sie erzielt, wenn Sie einfach
        <command>chsh</command> ohne Optionen aufgerufen und die
	entsprechende Zeile editiert h&auml;tten.</para>

      <note>
	<para>Die von Ihnen gew&uuml;nschte Shell
          <emphasis>muss</emphasis> in <filename>/etc/shells</filename>
          aufgef&uuml;hrt sein.  Haben Sie eine Shell aus der
	  <link linkend="ports">Ports Sammlung</link> installiert,
          sollte das schon automatisch erledigt werden.  Installierten
          Sie die Shell von Hand, so m&uuml;ssen Sie sie dort
          eintragen.</para>

      <para>Haben Sie beispielsweise die <command>bash</command> nach
	<filename>/usr/local/bin</filename> installiert, wollen Sie
        dies tun:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Danach k&ouml;nnen Sie <command>chsh</command> aufrufen.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Text Editoren</title>
    <indexterm><primary>Text Editoren</primary></indexterm>
    <indexterm><primary>Editoren</primary></indexterm>

    <para>Eine Menge der Konfiguration bei FreeBSD wird durch
      das Editieren von Textdateien erledigt.  Deshalb ist es eine
      gute Idee, mit einem Texteditor vertraut zu werden.  FreeBSD hat
      ein paar davon im Basissystem und sehr viel mehr in der Ports
      Sammlung.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <para>Der am leichtesten und einfachsten zu erlernende Editor nennt
      sich <application>ee</application>, was f&uuml;r
      <foreignphrase>easy editor</foreignphrase> steht.
      Um <application>ee</application> zu starten, gibt man in der
      Kommandozeile <command>ee filename</command> ein, worin
      <literal>filename</literal> der Name der zu editierenden Datei
      ist.  Um zum Beispiel <filename>/etc/rc.conf</filename> zu
      editieren, tippen Sie <command>ee /etc/rc.conf</command>.
      Einmal im Editor, finden Sie alle Editor-Funktionen oben im
      Display aufgelistet.  Das Einschaltungszeichen
      <literal>^</literal> steht f&uuml;r die <keycap>Ctrl</keycap> (oder
      <keycap>Strg</keycap>) Taste, mit <literal>^e</literal> ist also die
      Tastenkombination <keycombo
        action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      gemeint.  Um <application>ee</application> zu verlassen, dr&uuml;cken
      Sie <keycap>Esc</keycap> und w&auml;hlen dann <option>leave
        editor</option> aus.  Der Editor fragt nach, ob Sie speichern
      m&ouml;chten, wenn die Datei ver&auml;ndert wurde.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD verf&uuml;gt &uuml;ber leistungsf&auml;higere
      Editoren wie <command>vi</command> als Teil des
      Basissystems, andere Editoren wie <command>emacs</command> oder
      <command>vim</command> sind Teil der Ports Sammlung.
      Diese Editoren bieten h&ouml;here Funktionalit&auml;t und
      Leistungsf&auml;higkeit jedoch auf Kosten einer etwas
      schwierigeren Erlernbarkeit.  Wenn Sie viel
      Textdateien editieren werden, sparen Sie auf lange Sicht mehr
      Zeit durch das Erlernen von Editoren wie
      <application>vim</application> oder
      <application>emacs</application> ein.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Ger&auml;te und Ger&auml;tedateien</title>

    <para>Der Begriff Ger&auml;t wird meist in Verbindung mit Hardware
      wie Laufwerken, Druckern, Grafikkarten oder Tastaturen gebraucht.
      Der Gro&szlig;teil der Meldungen, die beim Booten von FreeBSD angezeigt
      werden, beziehen sich auf gefundene Ger&auml;te.  Sie k&ouml;nnen sich
      die Bootmeldungen sp&auml;ter in <filename>/var/run/dmesg.boot</filename>
      ansehen.</para>

    <para>Ger&auml;tenamen, die Sie wahrscheinlich in den Bootmeldungen sehen
      werden, sind zum Beispiel <devicename>acd0</devicename>, das erste
      IDE CD-ROM oder <devicename>kbd0</devicename>, die Tastatur.</para>

    <para>Auf die meisten Ger&auml;te wird unter &unix; Systemen &uuml;ber spezielle
      Ger&auml;tedateien im <filename>/dev</filename> Verzeichnis
      zugegriffen.</para>

    <sect2>
      <title>Anlegen von Ger&auml;tedateien</title>
      <para>Wenn sie ein neues Ger&auml;t zu Ihrem System hinzuf&uuml;gen,
	oder die Unterst&uuml;tzung f&uuml;r zus&auml;tzliche Ger&auml;te
	kompilieren, m&uuml;ssen oft ein oder mehrere Ger&auml;tedateien
	erstellt werden.</para>

      <sect3>
	<title>MAKEDEV Skript</title>
	<para>Auf Systemen ohne <literal>DEVFS</literal> (das sind alle
	  Systeme vor FreeBSD&nbsp;5.0) m&uuml;ssen Ger&auml;tedateien mit
	  &man.MAKEDEV.8; wie unten gezeigt angelegt werden:</para>

	<screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV ad1</userinput>
	</screen>

	<para>Im Beispiel werden alle Ger&auml;tedateien f&uuml;r das
	  zweite IDE Laufwerk angelegt.</para>
      </sect3>

      <sect3>
	<title><literal>DEVFS</literal> (Ger&auml;tedateisystem)</title>

	<para>Das Ger&auml;tedateisystem <literal>DEVFS</literal>
	  erm&ouml;glicht durch den
	  Namensraum des Dateisystems Zugriff auf den Namensraum der
	  Ger&auml;te im Kernel.  Damit m&uuml;ssen Ger&auml;tedateien
	  nicht mehr extra angelegt werden, sondern werden von
	  <literal>DEVFS</literal> verwaltet.</para>

	<para>Weitere Informationen finden Sie in &man.devfs.5;.</para>

	<para>In der Grundeinstellung benutzt FreeBSD&nbsp;5.0
	  <literal>DEVFS</literal>.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="consoles">
    <title>Virtuelle Konsolen und Terminals</title>
    <indexterm><primary>virtuelle Konsole</primary></indexterm>
    <indexterm><primary>Terminals</primary></indexterm>

    <para>Sie k&ouml;nnen FreeBSD mit einem Terminal benutzen, der nur Text
      darstellen kann.  Wenn Sie FreeBSD auf diese Weise benutzen, stehen
      Ihnen alle M&ouml;glichkeiten eines &unix; Betriebssystems zur
      Verf&uuml;gung.  Dieser Abschnitt beschreibt was Terminals und
      Konsolen sind und wie sie unter FreeBSD eingesetzt werden.</para>

    <sect2 id="consoles-intro">
      <title>Die Konsole</title>
      <indexterm><primary>Konsole</primary></indexterm>

      <para>Wenn Ihr FreeBSD System ohne eine graphische
        Benutzeroberfl&auml;che startet, wird am Ende des Systemstarts,
	nachdem die Startskripten gelaufen sind, ein Anmeldeprompt
	ausgegeben.  Die letzten Startmeldungen sollten &auml;hnlich wie
	die Folgenden aussehen:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Beachten Sie die letzten beiden Zeilen der Ausgabe, die
        vorletzte lautet:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Diese Zeile enth&auml;lt einige Informationen &uuml;ber das
        gerade gestartete System.  Die Ausgabe stammt von der
	FreeBSD-Konsole einer Maschine mit einem Intel oder
	Intel-kompatiblen Prozessor der x86-Architektur<footnote>
	  <para>Genau das ist mit <literal>i386</literal> gemeint.  Auch
	    wenn Ihr System keine Intel 386&nbsp;CPU besitzt, wird
	    <literal>i386</literal> ausgegeben.  Es wird immer die
	    Architektur und nicht der Typ des Prozessors ausgegeben.</para>
	</footnote>.  Der Name des Systems (jedes &unix; System besitzt
	einen Namen) ist <hostid>pc3.example.org</hostid> und die Ausgabe
	stammt von der Systemkonsole, dem Terminal
	<devicename>ttyv0</devicename>.</para>

      <para>Das Ende der Ausgabe ist immer die Aufforderung zur Eingabe
        eines Benutzernamens:</para>

      <programlisting>login:</programlisting>

      <para>Der Anmeldevorgang wird im n&auml;chsten Abschnitt
        erl&auml;utert.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Der Anmeldevorgang</title>

      <para>FreeBSD ist ein Mehrbenutzersystem, das Multitasking
        unterst&uuml;tzt.  Das hei&szlig;t mehrere Benutzer k&ouml;nnen
	gleichzeitig viele Programme auf einem System laufen lassen.</para>

      <para>Jedes Mehrbenutzersystem muss die Benutzer voneinander
        unterscheiden k&ouml;nnen.  In FreeBSD und allen anderen &unix;
	Betriebssystemen wird dies dadurch erreicht, dass sich die
	Benutzer anmelden m&uuml;ssen, bevor sie Programme laufen lassen
	k&ouml;nnen.  Jeder Benutzer besitzt einen eindeutigen Namen (den
	Account) und ein dazugeh&ouml;rendes Passwort, die beide bei
	der Anmeldung abgefragt werden.</para>

      <indexterm><primary>Startskripten</primary></indexterm>
      <para>Nachdem FreeBSD gestartet ist und die Startskripten<footnote>
	  <para>Startskripten sind Programme, die FreeBSD automatisch bei
	    jedem Startvorgang ausf&uuml;hrt.  Der Zweck der Skripten
	    besteht darin, das System zu konfigurieren und n&uuml;tzliche
	    Dienste im Hintergrund zu starten.</para>
	</footnote>, gelaufen sind, erscheint eine Aufforderung zur Eingabe
	des Benutzernamens:</para>

      <screen>login:</screen>

      <para>Wenn Ihr Benutzername beispielsweise <username>john</username>
        ist, geben Sie jetzt <literal>john</literal> gefolgt von
	<keycap>Enter</keycap> ein.  Sie sollten dann eine Aufforderung zur
	Eingabe des Passworts erhalten:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Geben Sie jetzt das Passwort von <username>john</username>
	gefolgt von <keycap>Enter</keycap> ein.  Das Passwort wird aus
	Sicherheitsgr&uuml;nden nicht auf dem Bildschirm angezeigt.</para>

      <para>Wenn Sie das richtige Passwort eingegeben haben, sind Sie
        am System angemeldet und k&ouml;nnen nun alle verf&uuml;gbaren
	Kommandos absetzen.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Virtuelle Konsolen</title>

      <para>Da FreeBSD mehrere Programme gleichzeitig laufen lassen kann,
        ist eine einzige Konsole, an der Kommandos abgesetzt werden
	k&ouml;nnen, zu wenig.  Abhilfe schaffen virtuelle Konsolen, die
	mehrere Konsolen zur Verf&uuml;gung stellen.</para>

      <para>Die Anzahl der virtuellen Konsolen unter FreeBSD k&ouml;nnen Sie
        einstellen.  Zwischen den einzelnen Konsolen k&ouml;nnen Sie mit
	speziellen Tastenkombinationen wechseln.  Jede Konsole verf&uuml;gt
	&uuml;ber einen eigenen Ausgabekanal und FreeBSD ordnet die
	Tastatureingaben und Monitorausgaben der richtigen Konsole zu, wenn
	Sie zwischen den Konsolen wechseln.</para>

      <para>Zum Umschalten der Konsolen stellt FreeBSD spezielle
        Tastenkombinationen bereit<footnote>
	  <para>Eine recht technische und genaue Beschreibung der FreeBSD
	    Konsole und der Tastatur-Treiber finden Sie in den Hilfeseiten
	    &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1; und
	    &man.kbdcontrol.1;.  Lesen Sie diese Seiten, wenn Sie an den
	    Einzelheiten interessiert sind.</para>
	</footnote>.  Benutzen Sie
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> bis
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>,
	um zwischen den verschiedenen Konsolen umzuschalten.</para>

      <para>Wenn Sie zu einer anderen Konsole wechseln, sichert FreeBSD den
        Bildschirminhalt und gibt den Bildschirminhalt der neuen Konsole
	aus.  Dies erzeugt die Illusion mehrerer Bildschirme und
	Tastaturen, an denen Sie Kommandos absetzen k&ouml;nnen.  Wenn eine
	Konsole nicht sichtbar ist, weil Sie auf eine andere Konsole
	gewechselt haben, laufen die dort abgesetzten Kommandos
	weiter.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title><filename>/etc/ttys</filename></title>

      <para>In der Voreinstellung stehen unter FreeBSD acht virtuelle
	Konsolen zur Verf&uuml;gung, deren Anzahl Sie leicht erh&ouml;hen
	oder erniedrigen k&ouml;nnen.  Die Anzahl und Art der Konsolen wird
	in <filename>/etc/ttys</filename> eingestellt.</para>

      <para>Jede Zeile in <filename>/etc/ttys</filename>, die nicht mit
        <literal>#</literal> anf&auml;ngt, konfiguriert einen Terminal oder
	eine virtuelle Konsole.  In der Voreinstellung werden in dieser
	Datei neun virtuelle Konsolen definiert, von denen acht aktiviert
	sind.  Die Konsolen sind in den Zeilen, die mit
	<literal>ttyv</literal> beginnen, definiert:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Die Hilfeseite &man.ttys.5; enth&auml;lt eine ausf&uuml;hrliche
	Beschreibung der Spalten dieser Datei und der Optionen, die Sie zum
	Konfigurieren der virtuellen Konsolen benutzen k&ouml;nnen.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Die Konsole im Single-User-Modus</title>

      <para>Eine eingehende Beschreibung des Single-User-Modus finden Sie
        in <xref linkend="boot-singleuser">.  Im Single-User-Modus steht
	Ihnen nur <emphasis>eine</emphasis> Konsole zur Verf&uuml;gung.
	Die Definition dieser Konsole befindet sich ebenfalls in
	<filename>/etc/ttys</filename>.  Suchen Sie nach einer Zeile, die
	mit <literal>console</literal> beginnt:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
	<para>In der Zeile, die mit <literal>console</literal> beginnt,
	  k&ouml;nnen Sie <literal>secure</literal> durch
	  <literal>insecure</literal> ersetzen.  Wenn Sie danach in den
	  Single-User-Modus booten, verlangt das System ebenfalls die
	  Eingabe des <username>root</username>-Passworts.</para>

	<para><emphasis>Setzen Sie <literal>insecure</literal> nicht
	  leichtfertig ein.</emphasis>  Wenn Sie das Passwort von
	  <username>root</username> vergessen, wird es schwierig, in den
	  Single-User-Modus zu gelangen, wenn Sie den FreeBSD
	  Boot-Prozess nicht genau verstehen.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Weitere Informationen</title>

    <sect2 id="basics-man">
      <title>Manualpages</title>
      <indexterm><primary>Manualpages</primary></indexterm>

      <para>Die umfassendste Dokumentation rund um FreeBSD gibt es in
        Form von Manualpages.  Ann&auml;hernd jedes Programm im System
        bringt eine kurze Referenzdokumentation mit, die die
        grunds&auml;tzliche Funktion und verschiedene Parameter
        erkl&auml;rt.  Diese Dokumentationen kann man mit dem
        <command>man</command> Kommando benutzen.  Die Benutzung des
        <command>man</command> Kommandos ist einfach:</para>

      <screen>&prompt.user; <userinput>man <replaceable>Kommando</replaceable></userinput></screen>

      <para><literal>Kommando</literal> ist der Name des Kommandos,
        &uuml;ber das Sie etwas erfahren wollen.  Um beispielsweise
        mehr &uuml;ber das Kommando <command>ls</command> zu lernen,
        geben Sie ein:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Die Online-Dokumentation ist in nummerierte Sektionen
        unterteilt:</para>

      <orderedlist>
	<listitem>
	  <para>Benutzerkommandos.</para>
	</listitem>

	<listitem>
	  <para>Systemaufrufe und Fehlernummern.</para>
	</listitem>

	<listitem>
	  <para>Funktionen der C Bibliothek.</para>
	</listitem>

	<listitem>
	  <para>Ger&auml;tetreiber.</para>
	</listitem>

	<listitem>
	  <para>Dateiformate.</para>
	</listitem>

	<listitem>
	  <para>Spiele und andere Unterhaltung.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Informationen.</para>
	</listitem>

	<listitem>
	  <para>Systemverwaltung und -Kommandos.</para>
	</listitem>

	<listitem>
	  <para>Kernel Entwickler.</para>
	</listitem>
      </orderedlist>

      <para>In einigen F&auml;llen kann dasselbe Thema in mehreren
        Sektionen auftauchen.  Es gibt zum Beispiel ein <command>chmod</command>
        Benutzerkommando und einen <function>chmod()</function>
        Systemaufruf.  In diesem Fall k&ouml;nnen Sie dem
	<command>man</command> Kommando
        sagen, aus welcher Sektion Sie die Information erhalten
        m&ouml;chten, indem Sie die Sektion mit angeben:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Dies wird Ihnen die Manualpage f&uuml;r das Benutzerkommando
        <command>chmod</command> zeigen.  Verweise auf eine Sektion
        der Manualpages werden traditionell in Klammern
        gesetzt.  So bezieht sich &man.chmod.1; auf das
        Benutzerkommando <command>chmod</command> und mit
        &man.chmod.2; ist der Systemaufruf gemeint.</para>

      <para>Das ist nett, wenn Sie den Namen eines Kommandos wissen,
        und lediglich wissen wollen, wie es zu benutzen ist.  Aber was
        tun Sie, wenn Sie Sich nicht an den Namen des Kommandos
        erinnern k&ouml;nnen?  Sie k&ouml;nnen mit <command>man</command>
	nach Schl&uuml;sselbegriffen in den
	Kommandobeschreibungen zu suchen, indem Sie den Parameter
	<option>-k</option> benutzen:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para> Mit diesem Kommando bekommen Sie eine Liste der
        Kommandos, deren Beschreibung das Schl&uuml;sselwort
        <quote>mail</quote> enth&auml;lt.  Diese Funktionalit&auml;t
        erhalten Sie auch, wenn Sie das Kommando <command>apropos</command>
        benutzen.</para>

      <para>Nun, Sie schauen Sich alle die geheimnisvollen Kommandos
        in <filename>/usr/bin</filename> an, haben aber nicht den
        blassesten Schimmer, wozu die meisten davon gut sind?  Dann
        rufen Sie doch einfach das folgende Kommando auf:</para>
        <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>Dasselbe erreichen Sie durch Eingabe von:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info Dateien</title>

      <para>FreeBSD enth&auml;lt viele Anwendungen und Utilities
        der Free Software Foundation (FSF).  Zus&auml;tzlich zu den
        Manualpages bringen diese Programme ausf&uuml;hrlichere
        Hypertext-Dokumente (<literal>info</literal> genannt) mit,
        welche man sich mit dem Kommando <command>info</command>
        ansehen kann.  Wenn Sie <application>emacs</application>
        installiert haben, k&ouml;nnen Sie auch dessen info-Modus
        benutzen.</para>

      <para>Um das Kommando &man.info.1; zu benutzen, geben Sie
        einfach ein:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Eine kurze Einf&uuml;hrung gibt es mit
        <literal>h</literal>; eine Befehlsreferenz erhalten Sie durch
        Eingabe von: <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

