<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.71
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chern</firstname>

        <surname>Lee</surname>

        <contrib>Scritto da </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
        <firstname>Mike</firstname>

        <surname>Smith</surname>

        <contrib>Basato su un tutorial scritto da </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
        <firstname>Matt</firstname>

        <surname>Dillon</surname>

        <contrib>Basato anche su tuning(7) scritto da </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Configurazione e Messa a Punto</title>

  <sect1>
    <title>Sinossi</title>

    <indexterm>
      <primary>configurazione/ottimizzazione del sistema</primary>
    </indexterm>

    <para>Uno degli aspetti importanti di FreeBSD &egrave; la configurazione del
      sistema. Una corretta configurazione del sistema aiuter&agrave; a
      prevenire mal di testa durante futuri aggiornamenti.  Questo capitolo
      spiegher&agrave; molti dei processi di configurazione di FreeBSD, inclusi
      alcuni parametri che possono essere impostati per ottimizzare un sistema
      FreeBSD.</para>

    <para>Inoltre questo capitolo descriver&agrave; alcuni dei parametri che
      possono essere impostati per mettere a punto un sistema FreeBSD ed
      ottenere prestazioni ottimali.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
        <para>Come lavorare in maniera efficiente con i file system e le
          partizioni di swap.</para>
      </listitem>

      <listitem>
        <para>Le basi dei sistemi di configurazione <filename>rc.conf</filename>
          e di avvio <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>

      <listitem>
        <para>Come configurare host virtuali sui dispositivi di rete.</para>
      </listitem>

      <listitem>
        <para>Come usare i vari file di configurazione in
          <filename>/etc</filename>.</para>
      </listitem>

      <listitem>
        <para>Come mettere a punto FreeBSD usando le variabili
          <command>sysctl</command>.</para>
      </listitem>

      <listitem>
        <para>Come ottimizzare la prestazioni del disco e modificare le
          limitazioni del kernel.</para>
      </listitem>
    </itemizedlist>

    <para>Prima di leggere questo capitolo, dovresti:</para>

    <itemizedlist>
      <listitem>
        <para>Comprendere le basi di Unix e FreeBSD (<xref
            linkend="basics">).</para>
      </listitem>

      <listitem>
        <para>Avere dimestichezza nel mantenere i sorgenti di FreeBSD aggiornati
          (<xref linkend="cutting-edge">), e nella configurazione/compilazione
          del kernel (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Configurazione Iniziale</title>

    <sect2>
      <title>Disposizione delle Partizioni</title>

      <indexterm><primary>disposizione delle partizioni</primary></indexterm>
      <indexterm><primary><filename>/etc</filename></primary></indexterm>
      <indexterm><primary><filename>/var</filename></primary></indexterm>
      <indexterm><primary><filename>/usr</filename></primary></indexterm>

      <sect3>
        <title>Partizioni di Base</title>

        <para>Nel disegnare il tuo file system con &man.disklabel.8; o
          &man.sysinstall.8;, ricorda che i dischi rigidi
          possono trasferire dati ad un ritmo maggiore dalle tracce esterne
          rispetto a quelle interne.  Quindi i
          file system pi&ugrave; piccoli e con un gran numero di accessi
          dovrebbero essere pi&ugrave; vicini alla parte esterna del disco,
          mentre le partizioni pi&ugrave; ampie, come
          <filename>/usr</filename>, dovrebbero essere posizionate verso
          l'interno.
          &Egrave; una buona idea creare le partizioni in un ordine simile:
          root, swap, <filename>/var</filename>,
          <filename>/usr</filename>.</para>

        <para>Le dimensioni della partizione <filename>/var</filename>
          riflettono l'uso che intendi fare della macchina.
          <filename>/var</filename> viene usata per mantenere le
          caselle di posta, i file di log, e gli spool della stampante.  Le
          caselle di posta e file di log potrebbero crescere in
          maniera imprevedibile in relazione al numero di utenti presenti sul
          tuo sistema e da quanto a lungo manterrai i file di log.  La
          maggior parte degli utenti non avr&agrave; mai bisogno di un gigabyte,
          ma ricorda che <filename>/var/tmp</filename>
          deve essere abbastanza ampia da contenere tutti i pacchetti.</para>

        <para>La partizione <filename>/usr</filename> contiene molti
          dei file richiesti per far funzionare il sistema, la collezioni dei
          &man.ports.7; (raccomandata) e il codice sorgente (opzionale).
          Entrambi sono opzionali al momento dell'installazione.
          Almeno 2 gigabyte sono raccomandati per questa partizione.</para>

        <para>Quando decidi le dimensioni delle partizioni, tieni a mente le
          richieste di spazio.  Esaurire lo spazio in una partizione mentre ne
          usi poco in un'altra pu&ograve; essere molto fastidioso.</para>

        <note>
          <para>Alcuni utenti hanno scoperto che il dimensionamento
            <literal>auto-predefinito</literal> di &man.sysinstall.8; a volte
            crea partizioni <filename>/var</filename> o <filename>/</filename>
            pi&ugrave; piccole del necessario.  Partiziona saggiamente e
            generosamente.</para>
        </note>
      </sect3>

      <sect3 id="swap-design">
        <title>Partizione di Swap</title>

        <indexterm><primary>dimensionamento dello swap</primary></indexterm>
        <indexterm><primary>partizione di swap</primary></indexterm>

        <para>Come regola generale, la partizione di swap dovrebbe essere
          tipicamente il doppio della quantit&agrave; di memoria principale
          (RAM).
          Ad esempio, se la macchina avesse 128&nbsp;megabyte di memoria, il
          file di swap dovrebbe essere di 256&nbsp;megabyte.
          Sistemi con meno memoria potrebbero funzionare meglio con uno swap
          maggiore.  Meno di 256&nbsp;megabyte di swap non &egrave; raccomandato
          e dovresti pensare ad una espansione della memoria.
          Gli algoritmi di paginazione sono ottimizzati per funzionare
          al meglio quando la partizione di swap &egrave; almeno due volte la
          dimensione della memoria principale.
          Configurare uno swap troppo piccolo potrebbe portare ad una
          inefficienza nel codice di scansione della VM e potrebbero creare
          problemi in seguito, nel caso di aggiunta di memoria alla
          macchina.</para>

        <para>Su sistemi pi&ugrave; grandi con dischi SCSI multipli
          (o dischi IDE multipli collegati a diversi controller) &egrave;
          consigliabile che ci sia uno swap per ogni disco (fino a
          quattro dischi).  Le partizioni di swap dovrebbero avere
          approssimativamente le stesse dimensioni.
          Il kernel pu&ograve; gestire dimensioni arbitrarie ma internamente le
          strutture dati scalano meglio fino a quattro volte la dimensione della
          partizione di swap pi&ugrave; ampia.  Avere partizioni di swap con
          dimensioni simili permetter&agrave; al kernel di distribuire al meglio
          lo spazio di swap tra i dischi.  Partizioni di swap grandi vanno bene,
          anche se non vengono usate molto.  Potrebbe essere pi&ugrave; semplice
          recuperare il sistema da un programma impazzito prima di essere
          costretti a riavviare.</para>
      </sect3>

      <sect3>
        <title>Perch&eacute; Partizionare?</title>

        <para>Molti utenti pensano che un'unica grande partizione vada bene, ma
          ci sono molte ragioni per cui questa &egrave; una cattiva idea.
          Primo, ogni partizione ha differenti caratteristiche
          operative e separarle permette ai file system di ottimizzare se stessi
          di conseguenza.  Ad esempio, le partizioni root e
          <filename>/usr</filename> sono per lo pi&ugrave; usate in lettura,
          senza molte operazioni di scrittura, mentre un sacco di
          letture e scritture potrebbero esserci in <filename>/var</filename> e
          <filename>/var/tmp</filename>.</para>

        <para>Partizionando in maniera appropriata il sistema, la
          frammentazione introdotta nelle partizioni pi&ugrave; piccole,
          con pi&ugrave; carico in scrittura, non incider&agrave; sulle
          partizioni per lo pi&ugrave; di lettura.
          Mantenere le partizioni con maggiore carico in scrittura
          vicine al bordo del disco
          aumenter&agrave; le prestazioni di I/O nelle partizioni dove ne hai
          pi&ugrave; bisogno.  Ora, sebbene potresti avere bisogno di
          prestazioni di I/O anche nelle partizioni pi&ugrave; ampie,
          spostarle verso il bordo del disco non
          porterebbe nessun miglioramento significativo delle prestazioni, al
          contrario dello spostamento di <filename>/var</filename> all'esterno.
          Infine, ci sono problemi riguardanti la sicurezza.
          Una piccola, simpatica partizione di root che &egrave; essenzialmente
          di sola lettura ha ottime possibilit&agrave; di sopravvivere intatta a
          un brutto crash.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Configurazione Centrale</title>

    <indexterm>
      <primary>i file rc</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>Il posto principale per le informazioni di configurazione del sistema
      &egrave; in <filename>/etc/rc.conf</filename>.  Questo file contiene una
      ampia gamma di informazioni di configurazione, usate principalmente
      all'avvio della macchina per la configurazione del sistema.
      Il suo nome implica direttamente questo; si tratta di informazioni
      di configurazione per i file <filename>rc*</filename>.</para>

    <para>Un amministratore dovrebbe aggiungere dei campi nel file
      <filename>rc.conf</filename> per cambiare le impostazioni
      predefinite di <filename>/etc/defaults/rc.conf</filename>.
      Il file predefinito non drovebbe essere semplicemente copiato in
      <filename>/etc</filename> - esso contiene valori di default, non esempi.
      Tutti i cambiamenti specifici del sistema dovrebbero essere effettuati
      nel file <filename>rc.conf</filename> stesso.</para>

    <para>Nelle applicazioni clustered possono essere adottate differenti
      strategie per separare le configurazioni generali da quelle specifiche del
      sistema in maniera da mantenere basso l'impegno di amministrazione.
      L'approccio raccomandato &egrave; di porre le configurazioni generali in
      un altro file, ad esempio <filename>/etc/rc.conf.site</filename>, e poi
      includerlo in <filename>/etc/rc.conf</filename>, che conterr&agrave; solo
      le informazioni specifiche del sistema.</para>

    <para>Visto che <filename>rc.conf</filename> viene letto da &man.sh.1;
      &egrave; semplice farlo.  Ad esempio:</para>

    <itemizedlist>
      <listitem>
        <para>rc.conf:</para>

        <programlisting>        . rc.conf.site
        hostname="nodo15.example.com"
        network_interfaces="fxp0 lo0"
        ifconfig_fxp0="inet 10.1.1.1"</programlisting>
      </listitem>

      <listitem>
        <para>rc.conf.site:</para>

        <programlisting>        defaultrouter="10.1.1.254"
        saver="daemon"
        blanktime="100"</programlisting>
      </listitem>
    </itemizedlist>

    <para>Il file <filename>rc.conf.site</filename> potr&agrave; poi essere
      distribuito su ogni sistema usando <command>rsync</command> o un programma
      simile, mentre il file <filename>rc.conf</filename> rimarr&agrave;
      unico.</para>

    <para>L'aggiornamento del sistema tramite &man.sysinstall.8;
      o <command>make world</command> non sovrascriver&agrave; il file
      <filename>rc.conf</filename>, quindi le configurazioni del sistema non
      andranno perse.</para>
  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Configurazione delle Applicazioni</title>

    <para>Tipicamente, le applicazioni installate hanno i propri file di
      configurazione, con la loro sintassi, ecc.  E' importante che questi file
      siano tenuti separati dal sistema di base, in maniera da essere
      facilmente individuati e gestiti dagli strumenti di gestione dei
      pacchetti.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>In genere, questi file vengono installati in
      <filename>/usr/local/etc</filename>.  Nel caso in cui una applicazione
      abbia un grande numero di file di configurazione, verr&agrave; creata una
      sottodirectory per contenerli.</para>

    <para>Normalmente, quando viene installato un pacchetto, vengono installati
      anche file di configurazione d'esempio.  In genere questi vengono
      identificati da un suffisso <filename>.default</filename>.  Se non ci sono
      file di configurazione esistenti per l'applicazione, verranno creati
      copiando i file <filename>.default</filename>.</para>

    <para>Ad esempio, considera il contenuto della directory
      <filename>/usr/local/etc/apache</filename>:</para>

    <literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Le differenze nelle dimensioni dei file mostrano che solo
      <filename>srm.conf</filename> &egrave; stato modificato.
      Una successiva installazione di <application>Apache</application> dai port
      non sovrascriver&agrave; questo file modificato.</para>
  </sect1>

  <sect1 id="configtuning-starting-services">
    <title>Avvio dei Servizi</title>

    <indexterm><primary>servizi</primary></indexterm>

    <para>&Egrave; comune per un sistema sostenere un certo numero di servizi.
      Questi possono essere avviati in molti modi differenti, ognuno dei quali
      ha vantaggi differenti.</para>

    <indexterm><primary>/usr/local/etc/rc.d</primary></indexterm>

    <para>I programmi installati tramite port o dalla collezione dei pacchetti
      metteranno spesso uno script in <filename>/usr/local/etc/rc.d</filename>
      che verr&agrave; invocato all'avvio del sistema con l'argomento
      <option>start</option>, ed allo spegnimento con l'argomento
      <option>stop</option>.  Questo &egrave; il modo consigliato per avviare i
      servizi di sistema che devono funzionare come <username>root</username>, o
      che hanno bisogno di essere lanciati da <username>root</username>.
      Questi script sono registrati come parte dell'installazione del pacchetto,
      e saranno rimossi quando verr&agrave; rimosso il pacchetto.</para>

    <para>Uno script di avvio generico in
      <filename>/usr/local/etc/rc.d</filename> appare cos&igrave;:</para>

    <programlisting>#!/bin/sh
echo -n ' FooBar'

case "$1" in
start)
        /usr/local/bin/foobar
        ;;
stop)
        kill -9 `cat /var/run/foobar.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0</programlisting>

    <para>Gli script di avvio di FreeBSD cercheranno in
      <filename>/usr/local/etc/rc.d</filename> degli script che abbiano una
      estensione <literal>.sh</literal> e siano eseguibili da
      <username>root</username>.  Gli script trovati verranno richiamati con
      l'opzione <option>start</option> all'avvio, e <option>stop</option>
      allo spegnimento per permettergli di svolgere il loro compito.
      Quindi se volessi che il suddetto script di esempio venisse trovato ed
      eseguito al momento giusto, durante l'avvio del sistema, dovresti
      salvarlo in un file di nome <filename>FooBar.sh</filename> in
      <filename>/usr/local/etc/rc.d</filename> e dovresti assicurarti che sia
      eseguibile.  Puoi rendere uno script eseguibile tramite &man.chmod.1; come
      mostrato di seguito:</para>

    <screen>&prompt.root; <userinput>chmod 755 <replaceable>FooBar.sh</replaceable></userinput></screen>

    <para>Alcuni servizi aspettano di essere invocati da &man.inetd.8; quando
      viene ricevuta una connessione su una porta valida.  Ci&ograve; &egrave;
      comune per tutti i server di lettura della posta (POP e IMAP, ecc.).
      Questi servizi vengono abilitati modificando il file
      <filename>/etc/inetd.conf</filename>.
      Guarda &man.inetd.8; per i dettagli sulla modifica di questo file.</para>

    <para>Alcuni servizi aggiuntivi potrebbero non essere coperti dalle opzioni
      in <filename>/etc/rc.conf</filename>.
      Tradizionalmente questi vengono avviati mettendo i comandi necessari per
      invocarli in <filename>/etc/rc.local</filename>.
      Da FreeBSD&nbsp;3.1 non c'&egrave; pi&ugrave; nessun
      <filename>/etc/rc.local</filename> predefinito;.  Se venisse creato
      dall'amministratore, esso verrebbe comunque gestito normalmente.
      Nota che <filename>rc.local</filename> viene generalmente visto come
      ultima possibilit&agrave;; se c'&egrave; un posto migliore per avviare il
      servizio, fallo da l&igrave;.</para>

    <note>
      <para><emphasis>NON</emphasis> mettere nessun comando in
        <filename>/etc/rc.conf</filename>.  Per avviare i demoni, o per eseguire
        un qualsiasi comando all'avvio, metti invece uno script in
        <filename>/usr/local/etc/rc.d</filename>.</para>
    </note>

    <para>&egrave; anche possibile usare il demone &man.cron.8; per avviare i
      servizi di sistema.  Questo approccio ha molti vantaggi, non ultimo il
      fatto che poich&eacute; &man.cron.8; esegue questi processi come il
      proprietario di <command>crontab</command>, i servizi possono essere
      avviati e mantenuti da utenti non-<username>root</username>.</para>

    <para>Per fare ci&ograve; si approfitta di una caratteristica di
      &man.cron.8;: le specifiche temporali possono essere sostituite da
      <literal>@reboot</literal>, che far&agrave; s&igrave; che il compito
      venga eseguito quando &man.cron.8; viene avviato, poco dopo l'avvio del
      sistema.</para>
  </sect1>

  <sect1>
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Marc</firstname>

          <surname>Fonvieille</surname>

          <contrib>Contributo di </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Configurazione delle Interfacce di Rete</title>

    <indexterm><primary>configurazione della scheda di rete</primary></indexterm>

    <para>Al giorno d'oggi non riusciamo a pensare ad un computer senza pensare
      ad una connessione di rete.  Aggiungere e configurare una scheda di rete
      &egrave; un compito comune per ogni amministratore FreeBSD.</para>

    <sect2>
      <title>Individuazione del Driver Corretto</title>

      <indexterm>
        <primary>configurazione della scheda di rete</primary>
        <secondary>individuazione del driver</secondary>
      </indexterm>

      <para>Prima di cominciare, dovresti conoscere il modello della scheda di
        rete che possiedi, il chip che usa, e se si tratta di una scheda PCI o
        ISA.  FreeBSD supporta un'ampia variet&agrave; sia di schede PCI che
        ISA.  Verifica la l'Hardware Compatibility List della tua release per
        vedere se la scheda &egrave; supportata.</para>

      <para>Una volta sicuro che la tua scheda sia supportata, hai bisogno di
        determinare il driver appropriato per la scheda.  Il file
        <filename>/usr/src/sys/i386/conf/LINT</filename> ti fornir&agrave; un
        elenco di driver per le interfacce di rete con alcune informazioni
        su chipset/schede supportate.  Se hai dubbi su quale sia il driver
        corretto, leggi la pagina man del driver.
        La pagina man fornir&agrave; ulteriori informazioni sull'hardware
        supportato ed anche sui possibili problemi che potrebbero
        capitare.</para>

      <para>Se sei in possesso di una scheda comune, la maggior parte delle
        volte non dovrai cercare molto per trovare un driver.  I driver per le
        schede di reti comuni sono presenti nel kernel
        <filename>GENERIC</filename>, quindi la tua scheda dovrebbe mostrarsi
        durante l'avvio, in questo modo:</para>

      <screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</screen>

      <para>In questo esempio, vediamo che nel sistema  sono presenti due schede
        che usano il driver &man.dc.4;.</para>

      <para>Per usare la tua scheda di rete, avrai bisogno di caricare il driver
        appropriato.  Ci&ograve; pu&ograve; essere fatto in due modi.
        Il modo pi&ugrave; semplice consiste nel caricare semplicemente un
        modulo nel kernel relativo alla scheda di rete con &man.kldload.8;.
        Non &egrave; disponibile un modulo per ogni scheda di rete
        (le schede ISA e le schede che usano il driver &man.ed.4;, ad esempio).
        Alternativamente, si pu&ograve; compilare staticamente
        il supporto per la propria scheda di rete nel proprio kernel.  Controlla
        <filename>/usr/src/sys/i386/conf/LINT</filename> e la pagina man
        del driver per sapere cosa aggiungere al tuo file di configurazione del
        kernel.  Per maggiori informazioni sulla ricompilzione del kernel,
        guarda il <xref linkend="kernelconfig">.  Se la tua scheda &egrave;
        stata riconosciuta all'avvio dal kernel (<filename>GENERIC</filename>)
        non dovrai compilarne uno nuovo.</para>
    </sect2>

    <sect2>
      <title>Configurazione della Scheda di Rete</title>

      <indexterm>
        <primary>configurazione della scheda di rete</primary>
        <secondary>configurazione</secondary>
      </indexterm>

      <para>Una volta che il driver giusto per la scheda di rete &egrave; stato
        caricato, la scheda ha bisogno di essere configurata.  Come molte altre
        cose, la scheda di rete potrebbe essere gi&agrave; stata configurata al
        momento dell'installazione tramite
        <application>sysinstall</application>.</para>

      <para>Per mostrare la configurazione delle interfaccie di rete sul tuo
        sistema, immetti il seguente comando:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</screen>

      <note>
        <para>Vecchie versioni di FreeBSD potrebbero richiedere l'opzione
          <option>-a</option> dopo &man.ifconfig.8;. Per maggiori dettagli sulla
          sintassi corretta di &man.ifconfig.8;, fai riferimento alla pagina
          man.  Nota anche che le voci relative all'IPv6
          (<literal>inet6</literal> ecc.) sono state omesse in questo
          esempio.</para>
      </note>

      <para>In questo esempio, vengono mostrati i seguenti dispositivi:</para>

      <itemizedlist>
        <listitem>
          <para><devicename>dc0</devicename>: La prima interfaccia
            Ethernet</para>
        </listitem>

        <listitem>
          <para><devicename>dc1</devicename>: La seconda interfaccia
            Ethernet</para>
        </listitem>

        <listitem>
          <para><devicename>lp0</devicename>: L'interfaccia della porta
            parallela</para>
        </listitem>

        <listitem>
          <para><devicename>lo0</devicename>: Il dispositivo di loopback</para>
        </listitem>

        <listitem>
          <para><devicename>tun0</devicename>: Il dispositivo tunnel usato da
            <application>ppp</application></para>
        </listitem>
      </itemizedlist>

      <para>FreeBSD usa il nome del driver seguito dall'ordine nel quale
        la scheda &egrave; stat rilevata all'avvio del kernel per dare un nome
        alla scheda di rete.  Ad esempio <devicename>sis2</devicename> sarebbe
        la terza scheda di rete nel sistema che usa il driver
        &man.sis.4;.</para>

      <para>In questo esempio, il dispositivo <devicename>dc0</devicename>
        &egrave; attivo.  Gli indicatori chiave sono:</para>

      <orderedlist>
        <listitem>
          <para><literal>UP</literal> significa che la scheda &egrave; pronta e
            configurata.</para>
        </listitem>

        <listitem>
          <para>La scheda ha un indirizzo Internet (<literal>inet</literal>)
            (in questo caso <hostid role="ipaddr">192.168.1.3</hostid>).</para>
        </listitem>

        <listitem>
          <para>Essa ha una maschera di sottorete valida
            (<literal>netmask</literal>; <hostid
              role="netmask">0xffffff00</hostid> &egrave; lo stesso che <hostid
              role="netmask">255.255.255.0</hostid>).</para>
        </listitem>

        <listitem>
          <para>Essa ha un indirizzo di broadcast valido (in questo caso,
            <hostid role="ipaddr">192.168.1.255</hostid>).</para>
        </listitem>

        <listitem>
          <para>L'indirizzo MAC della scheda  <literal>ether</literal>)
            &egrave; <hostid role="mac">00:a0:cc:da:da:da</hostid>.</para>
        </listitem>

        <listitem>
          <para>La selezione del mezzo fisico &egrave; in modalit&agrave;
            autoselezione (<literal>media: Ethernet autoselect (100baseTX
            &lt;full-duplex&gt;)</literal>).  Vediamo che
            <devicename>dc1</devicename> &egrave; stata configurata con un mezzo
            fisico <literal>10baseT/UTP</literal>.  Per ulteriori informazioni
            sui tipi di mezzi disponibili per un driver, fai riferimento alla
            sua pagina man.</para>
        </listitem>

        <listitem>
          <para>Lo stato del collegamento (<literal>status</literal>)
            &egrave; <literal>active</literal>, ovvero &egrave; stata rilevata
            la portante.  Per <devicename>dc1</devicename>, vediamo
            <literal>status: no carrier</literal>.  Questo &egrave; normale
            quando un cavo ethernet non &egrave; stato inserito nella
            scheda.</para>
        </listitem>
      </orderedlist>

      <para>Se l'output di &man.ifconfig.8; avesse mostrato qualcosa di simile
        a:</para>

      <screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
                ether 00:a0:cc:da:da:da</screen>

      <para>ci&ograve; avrebbe indicato che la scheda non era stata ben
        configurata.</para>

      <para>Per configurare la tua scheda, avrai bisogno dei privilegi
        di <username>root</username>.  La configurazione della scheda di rete
        pu&ograve; essere effettuata da riga di comando con &man.ifconfig.8;, ma
        avresti bisogno di farlo ad ogni riavvio del sistema.  Il file
        <filename>/etc/rc.conf</filename> &egrave; il posto dove scrivere la
        configurazione della scheda di rete.</para>

      <para>Apri <filename>/etc/rc.conf</filename> con il tuo editor preferito.
        Avrai bisogno di aggiungere una riga per ogni scheda di rete presente
        nel sistema, ad esempio nel nostro caso, abbiamo aggiunto queste
        linee:</para>

      <programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>Dovrai sostituire <devicename>dc0</devicename>,
        <devicename>dc1</devicename>, e cos&igrave; via, con i dispositivi
        corretti per la tua scheda, e gli indirizzi con quelli appropriati.
        Dovresti leggere le pagine man del driver e di &man.ifconfig.8; per
        maggiori dettagli sulle opzioni permesse ed anche la pagina man di
        &man.rc.conf.5; per maggiori informazioni sulla sintassi di
        <filename>/etc/rc.conf</filename>.</para>

      <para>Se hai configurato la rete durante l'installazione, alcune
        linee relative alle schede di rete potrebbero essere gi&agrave;
        presenti.  Controlla due volte <filename>/etc/rc.conf</filename> prima
        di aggiungere ogni linea.</para>

      <para>Avrai anche bisogno di modificare il file
        <filename>/etc/hosts</filename> per aggiungere i nomi e gli IP
        delle varie macchine della LAN, se non sono gi&agrave; l&igrave;.
        Per maggiori informazioni, fai riferimento a &man.hosts.5;
        ed a <filename>/usr/share/examples/etc/hosts</filename>.</para>
    </sect2>

    <sect2>
      <title>Verifica e Risoluzione dei Problemi</title>

      <para>Una volta che hai effettuato i cambiamenti necessari a
        <filename>/etc/rc.conf</filename>, dovresti riavviare la macchina.
        Ci&ograve; far&agrave; s&igrave; che i cambiamenti alle interfacce
        vengano applicati, e verificher&agrave; che il sistema si riavvii senza
        nessun errore di configurazione.</para>

      <para>Una volta che il sistema &egrave; stato riavviato, dovresti testare
        le interfaccie di rete.</para>

      <sect3>
        <title>Test della Scheda Ethernet</title>

        <indexterm>
          <primary>configurazione della scheda di rete</primary>
          <secondary>test della scheda</secondary>
        </indexterm>

        <para>Per verificare che una scheda Ethernet sia configurata
          correttamente, si devono provare due cose.  Prima, effettuare un ping
          verso l'interfaccia stessa, e poi un ping verso un'altra macchina
          sulla LAN.</para>

        <para>Prima proviamo l'interfaccia:</para>

        <screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

        <para>Ora dobbiamo effettuare un ping verso un'altra macchina della
          LAN:</para>

        <screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

        <para>Puoi usare il nome della macchina invece di
          <hostid role="ipaddr">192.168.1.2</hostid> se hai sistemato il file
          <filename>/etc/hosts</filename>.</para>
      </sect3>

      <sect3>
        <title>Risoluzione dei Problemi</title>

        <indexterm>
          <primary>configurazione della scheda di rete</primary>
          <secondary>risoluzione dei problemi</secondary>
        </indexterm>

      <qandaset>
          <qandaentry>
            <question>
              <para>Dove posso trovare informazioni su possibili problemi
                che potrei incontrare con la mia scheda di rete?</para>
            </question>

            <answer>
              <para>La pagina man del driver &egrave; la prima
                documentazione da leggere. Anche gli archivi delle mailing list
                possono essere utili.</para>
            </answer>
          </qandaentry>

          <qandaentry>
            <question>
              <para>Quando cerco di effttuare un ping verso una macchina sulla
                mia LAN, ottengo questo messaggio di errore:
                <errorname>ping: sendto: Permission denied</errorname>.</para>
            </question>

            <answer>
              <para>Questo significa che non hai il permesso di inviare
                pacchetti ICMP.  Verifica se c'&egrave; un firewall in
                esecuzione sulla macchina e se ci sono delle regole che
                bloccano il protocollo ICMP.</para>
            </answer>
          </qandaentry>

          <qandaentry>
            <question>
              <para>Vedo un sacco di messaggi <errorname>watchdog
                  timeout</errorname> nei log del sistema, e quando cerco di
                effettuare un ping verso una macchina sulla LAN, ottengo questo
                messaggio: <errorname>ping: sendto: No route to
                  host</errorname>.</para>
            </question>

            <answer>
              <para>La prima cosa da fare &egrave; verificare il cavo di rete.
                Molte schede di rete richiedono uno slot PCI che supporti il
                Bus Mastering.  Su alcune vecchie schede madri, solo uno slot
                PCI lo permette (la maggior parte delle volte lo slot 0).
                Controlla la scheda di rete e la documentazione della scheda
                madre per capire se quello potrebbe essere il problema.</para>
            </answer>
          </qandaentry>

          <qandaentry>
            <question>
              <para>Vedo un sacco di messaggi <errorname>device
                  timeout</errorname> nei log del sistema, e la mia scheda di
                rete non funziona.</para>
            </question>

            <answer>
              <para>Avere uno o due di questi messaggi &egrave; spesso normale
                con alcune schede.  Ad ogni modo, se questi persistono e la rete
                non &egrave; usabile, assicurati che il cavo di rete sia
                connesso e che non ci siano conflitti IRQ tra scheda di rete
                ed altri dispositivi nel sistema.</para>
            </answer>
          </qandaentry>

          <qandaentry>
            <question>
              <para>Le prestazioni della scheda sono mediocri, cosa posso
                fare?</para>
            </question>

            <answer>
              <para>&Egrave; difficile rispondere a questa domanda.
                Qual &egrave; la tua definizione di <quote>prestazioni
                  mediocri</quote>?  Controlla due volte qualunque cosa nella
                tua configurazione, leggi la pagina man &man.tuning.7;, e cerca
                di evitare schede di rete economiche.  Molti utenti hanno notato
                che impostando la selezione del mezzo fisico su
                <literal>autoselect</literal> porta a prestazioni scadenti su
                certo hardware.</para>
            </answer>
          </qandaentry>

          <qandaentry>
            <question>
              <para>ci sono delle schede di rete raccomandate o alcune
                dalle quali dovrei tenermi lontano?</para>
            </question>

            <answer>
              <para>Dovresti evitare le schede economiche per un uso serio.
                Le schede economiche spesso offrono chipset pieni di bug,
                e la maggior parte delle volte non forniscono buone
                prestazioni.  Molti utenti di FreeBSD apprezzano le schede che
                usano il chipset &man.fxp.4;, tuttavia questo non significa
                che tutti gli altri chipset siano cattivi.</para>
            </answer>
          </qandaentry>
        </qandaset>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Host Virtuali</title>

    <indexterm><primary>host virtuali</primary></indexterm>
    <indexterm><primary>alias ip</primary></indexterm>

    <para>Un uso piuttosto comune di FreeBSD &egrave; come hosting di siti
      virtuali, dove un solo server appare alla rete come molti server distinti.
      Ci&ograve; viene effettuato assegnando indirizzi di rete multipli ad una
      sola interfaccia.</para>

    <para>Una data interfaccia di rete ha un solo indirizzo
      <quote>reale</quote>, e pu&ograve; avere un numero qualsiasi di indirizzi
      <quote>alias</quote>.  Questi alias vengono normalmente aggiunti mettendo
      dei campi alias in <filename>/etc/rc.conf</filename>.</para>

    <para>Un campo alias per l'interfaccia <devicename>fxp0</devicename>
      appare cos&igrave;:</para>

    <programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Nota che il campo alias deve iniziare con alias0 e aumentare in
      ordine, (ad esempio, _alias1, _alias2, e cos&igrave; via).  Il processo di
      configurazione si fermer&agrave; al primo numero mancante.</para>

    <para>Il calcolo delle maschere di sottorete degli alias &egrave;
      importante, ma, fortunatamente, &egrave; anche abbastanza semplice.
      Per una data interfaccia, deve esserci un indirizzo che rappresenta
      correttamente la maschera di sottorete.
      Ogni altro indirizzo che ricada in questa rete deve avere una maschera di
      sottorete con tutti 1.</para>

    <para>Ad esempio, considera il caso in cui l'interfaccia
      <devicename>fxp0</devicename> sia connessa a due reti, la rete <hostid
        role="ipaddr">10.1.1.0</hostid> con maschera di sottorete <hostid
        role="netmask">255.255.255.0</hostid> e la rete <hostid
        role="ipaddr">202.0.75.16</hostid> con maschera di sottorete <hostid
        role="netmask">255.255.255.240</hostid>.  Vogliamo che il sistema sia
      visibile come <hostid role="ipaddr">10.1.1.1</hostid> fino a <hostid
        role="ipaddr">10.1.1.5</hostid> e come <hostid
        role="ipaddr">202.0.75.17</hostid> fino a <hostid
        role="ipaddr">202.0.75.20</hostid>.</para>

    <para>Le seguenti righe configurano il dispositivo correttamente per questo
      scopo:</para>

    <programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>
  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>File di Configurazione</title>

    <sect2>
      <title>Struttura di <filename>/etc</filename></title>

      <para>Ci sono molte directory nelle quali vengono tenute le informazioni
        di configurazione.  Tra queste ci sono:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><filename>/etc</filename></entry>

              <entry>Informazioni generiche sulla configurazione del sistema;
                questi dati  sono specifici del sistema.</entry>
            </row>

            <row>
              <entry><filename>/etc/defaults</filename></entry>

              <entry>Versioni di default dei file di configurazione del
                sistema.</entry>
            </row>

            <row>
              <entry><filename>/etc/mail</filename></entry>

              <entry>Configurazioni extra di &man.sendmail.8;, o file di
                configurazione di altri MTA.</entry>
            </row>

            <row>
              <entry><filename>/etc/ppp</filename></entry>

              <entry>Configurazione ppp sia per i programmi a livello utente che
                a livello kernel.</entry>
            </row>

            <row>
              <entry><filename>/etc/namedb</filename></entry>

              <entry>Posizione predefinita per i dati di &man.named.8;.
                Normalmente qui si trova <filename>named.conf</filename> insieme
                ai file di zona.</entry>
            </row>

            <row>
              <entry><filename>/usr/local/etc</filename></entry>

              <entry>File di configurazione per le applicazioni installate.
                Pu&ograve; contenere sottodirectory.</entry>
            </row>

            <row>
              <entry><filename>/usr/local/etc/rc.d</filename></entry>

              <entry>Script start/stop per i programmi installati.</entry>
            </row>

            <row>
              <entry><filename>/var/db</filename></entry>

              <entry>File di dati specifici del sistema generati
                automaticamente, come il database dei package, il database di
                locate, e cos&igrave; via.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Nomi degli Host</title>

      <indexterm><primary>nomi degli host</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
        <title><filename>/etc/resolv.conf</filename></title>

        <indexterm>
          <primary><filename>resolv.conf</filename></primary>
        </indexterm>

        <para><filename>/etc/resolv.conf</filename> detta il modo in cui il
          sistema di risoluzione dei nomi di FreeBSD accede all'Internet Domain
          Name System (DNS).</para>

        <para>I campi pi&ugrave; comuni in <filename>resolv.conf</filename>
          sono:</para>

        <informaltable frame="none">
          <tgroup cols="2">
            <tbody>
              <row>
                <entry><literal>nameserver</literal></entry>

                <entry>L'indirizzo IP di un name server al quale dovr&agrave;
                  rivolgersi il sistema di risoluzione.  I server vengono
                  interrogati nell'ordine in cui sono elencati, fino a un
                  massimo di tre.</entry>
              </row>

              <row>
                <entry><literal>search</literal></entry>

                <entry>Lista di ricerca per i nomi degli host.  Normalmente
                  questo viene determinato dal dominio dell'host locale.</entry>
              </row>

              <row>
                <entry><literal>domain</literal></entry>

                <entry>Il nome del dominio locale.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Un <filename>resolv.conf</filename> tipico:</para>

        <programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

        <note>
          <para>Si dovrebbe usare solo una tra le due opzioni
            <literal>search</literal> e <literal>domain</literal>.</para>
        </note>

        <para>Se stai usando DHCP, &man.dhclient.8; generalmente
          sovrascriver&agrave; <filename>resolv.conf</filename> con le
          informazioni ricevute dal server DHCP.</para>
      </sect3>

      <sect3>
        <title><filename>/etc/hosts</filename></title>

        <indexterm><primary>hosts</primary></indexterm>

        <para><filename>/etc/hosts</filename> &egrave; un semplice database
          testuale, reminescenza della vecchia rete Internet.
          Esso lavora in congiunzione con DNS e NIS fornendo una mappatura da
          nome a indirizzo IP.  Computer locali connessi ad una LAN possono
          essere messi in questo file per una gestione semplice dei nomi, invece
          di mettere su un server &man.named.8;.
          Inoltre, <filename>/etc/hosts</filename> pu&ograve; essere usato per
          fornire un registro locale dei nomi di internet, riducendo la
          necessit&agrave; di effettuare richieste esternamente per i nomi ad
          accesso frequente.</para>

        <programlisting># &dollar;FreeBSD&dollar;
#
# Host Database
# Questo file dovrebbe contenere gli indirizzi e gli alias
# per gli host locali che condividono questo file.
# In presenza di DNS o NIS, questo file potrebbe non essere consultato affatto;
# guarda /etc/nsswitch.conf per l'ordine di risoluzione.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Rete immaginaria.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# In accordo all'RFC 1918, puoi usare le seguenti classi di IP per reti private
# che non verranno mai connesse ad Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In caso volessi essere in grado di collegarti ad Internet, avrai bisogno
# di veri numeri ufficiali assegnati.  PER FAVORE PER FAVORE PER FAVORE
# non tentare di inventarti i numeri della tua rete ma fattene assegnare
# uno dal tuo provider (se ne hai uno) o dall'Internet Registry (ftp su
# rs.internic.net, directory `/templates').
#</programlisting>

        <para><filename>/etc/hosts</filename> accetta il semplicissimo
          formato:</para>

        <programlisting>[Indirizzo Internet ] [nome host ufficiale] [alias1] [alias2] ...</programlisting>

        <para>Ad esempio:</para>

        <programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

        <para>Consulta &man.hosts.5; per maggiori informazioni.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configurazione dei File di Log</title>

      <indexterm><primary>file di log</primary></indexterm>

      <sect3>
        <title><filename>syslog.conf</filename></title>

        <indexterm><primary>syslog.conf</primary></indexterm>

        <para><filename>syslog.conf</filename> &egrave; il file di
          configurazione per il programma &man.syslogd.8;.  Indica quale tipo di
          messaggi verranno scritti su ogni file di log.</para>

        <programlisting># &dollar;FreeBSD&dollar;
#
#       Gli spazi SONO validi separatori dei campi in questo file. Ad ogni modo,
#       altri sistemi *nix-like insistono ancora nell'usare tab come separatori
#       di campo. Se condividi questo file tra pi&ugrave; sistemi, potresti
#       voler usare solo dei tab come separatori.
#       Consulta la pagina man di syslog.conf(5).
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# togli il commento a questo per loggare tutte le scritture su /dev/console
# in /var/log/console.log
#console.info                                   /var/log/console.log
# togli il commento a questo per abilitare il logging di tutti i messaggi di log
# su /var/log/all.log
#*.*                                            /var/log/all.log
# togli il commento a questo per abilitare il logging su un host remoto di nome
# loghost
#*.*                                            @loghost
# togli i commenti a questi se hai inn in funzione
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

        <para>Consulta la pagina man di &man.syslog.conf.5; per maggiori
          informazioni.</para>
      </sect3>

      <sect3>
        <title><filename>newsyslog.conf</filename></title>

        <indexterm><primary>newsyslog.conf</primary></indexterm>

        <para><filename>newsyslog.conf</filename> &egrave; il file di
          configurazione di &man.newsyslog.8;, un programma che normalmente
          viene eseguito da &man.cron.8;. &man.newsyslog.8; determina quando i
          file di log richiedono un archiviazione o un riordinamento.
          <filename>logfile</filename> viene rinominato in
          <filename>logfile.0</filename>, <filename>logfile.0</filename> in
          <filename> logfile.1</filename> e cos&igrave; via.
          Alternativamente, i file potranno essere archiviati in formato
          &man.gzip.1;, e quindi diventeranno:
          <filename>logfile.0.gz</filename>, <filename>logfile.1.gz</filename>,
          e cos&igrave; via.</para>

        <para><filename>newsyslog.conf</filename> indica quali file di log
          devono essere gestiti, quanti devono essere mantenuti, e quando devono
          essere toccati.  I file di log possono essere riordinati e/o
          archiviati quando raggiungono una certa dimensione, o a una certa
          data/ora periodica.</para>

        <programlisting># file di configurazione per newsyslog
# &dollar;FreeBSD&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

        <para>Consulta la pagina man di &man.newsyslog.8; per maggiori
          informazioni.</para>
      </sect3>
    </sect2>

    <sect2>
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> assomiglia molto a
        <filename>rc.conf</filename>.  I valori vengono impostati nella forma
        <literal>variabile=valore</literal>.  I valori specificati vengono
        impostati dopo che il sistema &egrave; entrato in modalit&agrave;
        multiutente.  Non tutte le variabili sono gestibili in questo
        modo.</para>

      <para>Un <filename>sysctl.conf</filename> d'esempio che disattiva il
        logging delle uscite forzate da segnali non gestibili e che
        lascia capire ai programmi di Linux che essi stanno effettivamente
        funzionando sotto FreeBSD:</para>

      <programlisting>kern.logsigexit=0       # Non registra le uscite forzate (es. sig 11)
compat.linux.osname=FreeBSD
compat.linux.osrelease=4.3-STABLE</programlisting>
    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Messa a Punto con sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm><primary>messa a punto con sysctl</primary></indexterm>

    <para>&man.sysctl.8; &egrave; un'interfaccia che vi permette di effettuare
      cambiamenti ad un sistema FreeBSD gi&agrave; attivo.  Questo include molte
      opzioni avanzate dello stack TCP/IP e del sistema di memoria virtuale che
      possono permettere di migliorare drammaticamente le prestazioni ad un
      sistemista che abbia esperienza.  Pi&ugrave; di cinquecento variabili di
      sistema possono essere lette e modificate usando &man.sysctl.8;.</para>

    <para>In sostanza, &man.sysctl.8; serve a due cose: a leggere e a modificare
      le impostazioni di sistema.</para>

    <para>Per visualizzare tutte le variabili modificabili:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Per leggere una particolare variabile, ad esempio,
      <varname>kern.maxproc</varname>:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Per impostare una particolare variabile, usa l'intuitiva sintassi
      <replaceable>variabile</replaceable>=<replaceable>valore</replaceable>:</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>I valori validi per le variabili di sysctl sono generalmente o
      stringhe, o numeri, o valori booleani (un valore booleano pu&ograve;
      valere <literal>1</literal> per s&igrave; o <literal>0</literal> per
      no).</para>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Messa a Punto dei Dischi</title>

    <sect2>
      <title>Variabili sysctl</title>

      <sect3>
        <title><varname>vfs.vmiodirenable</varname></title>

        <indexterm>
          <primary><varname>vfs.vmiodirenable</varname></primary>
        </indexterm>

        <para>La variabile sysctl <varname>vfs.vmiodirenable</varname>
          pu&ograve; essere impostata a 0 (inattivo) o 1 (attivo); di default
          &egrave; 1.  Questa variabile controlla il modo in cui le directory
          vengono messe nella cache dal sistema.  La maggior parte delle
          directory &egrave; piccola, ed usa solo un singolo frammento
          (tipicamente 1&nbsp;K) nel file system e meno (tipicamente
          512&nbsp;byte) nella cache.
          Ad ogni modo, quando si lavora nella modalit&agrave;
          predefinita il buffer manterr&agrave; soltanto un numero fissato di
          directory anche se hai una quantit&agrave; enorme di memoria.
          Attivando questa sysctl si permette al buffer di usare la VM Page
          Cache per immagazzinare le directory, rendendo disponibile tutta la
          memoria disponibile per il caching delle directory.  In ogni caso, la
          minima quantit&agrave; di memoria usata per memorizzare una directory
          sar&agrave; la dimensione della pagina fisica (in genere 4&nbsp;K)
          invece di 512&nbsp;byte.
          Noi consigliamo di attivare questa opzione se si hanno in
          esecuzione dei servizi che manipolano un grosso numero file.  Servizi
          di questo tipo sono le cache web, i grandi sistemi di posta, e quelli
          di news.  Attivare questa opzione in generale non ridurr&agrave; le
          prestazioni nonostante la memoria sprecata, ma dovresti sperimentare
          tu stesso per verificare.</para>
      </sect3>

      <sect3>
        <title><varname>hw.ata.wc</varname></title>

        <indexterm><primary><varname>hw.ata.wc</varname></primary></indexterm>

        <para>FreeBSD&nbsp;4.3 ha giocato un po' con l'idea di disattivare il
          caching IDE in scrittura.  Questo ha ridotto la larghezza di banda in
          scrittura verso i dischi IDE ma &egrave; stato considerato necessario
          a causa di gravi problemi di consistenza dei dati introdotti dai
          venditori di dischi rigidi.  Il problema &egrave; che il disco IDE
          rimane inattivo dopo che una scrittura &egrave; stata completata.  Con
          il caching in scrittura attivo, i dischi IDE non scrivono soltanto i
          dati sui dischi in maniera disordinata, ma talvolta rimandano la
          scrittura indefinitamente sotto carichi di lavoro del disco pesanti.
          Un crash o un calo di tensione possono condurre a seri problemi di
          corruzione del file system.  L'impostazione predefinita di FreeBSD fu
          cambiata in favore della sicurezza.  Sfortunatamente, il risultato
          &egrave; stato una perdita di prestazioni talmente tremenda che
          abbiamo dovuto reinserire il caching in scrittura di default dopo
          quella release.  Dovresti verificare il valore di default sul tuo
          sistema osservando la variabile sysctl <varname>hw.ata.wc</varname>.
          Se il caching IDE in scrittura &egrave; disattivato, potete attivarlo
          reimpostando la variabile del kernel a 1.  Questo dovrebbe essere
          effettuato dal boot loader all'avvio.  Tentare di effettuare questo
          cambiamento dopo che il kernel &egrave; stato avviato non avr&agrave;
          nessun effetto.</para>

        <para>Per maggiori informazioni, guarda &man.ata.4;.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Il programma &man.tunefs.8; pu&ograve; essere usato per mettere a
        punto con accuratezza un file system.  Questo programma ha molte opzioni
        differenti, ma per ora noi ci preoccuperemo solo di attivare e
        disattivare i Soft Updates, che verr&agrave; effettuato tramite:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Un file system non potr&agrave; essere modificato con &man.tunefs.8;
        mentre &egrave; montato.  Un buon momento per attivare i Soft Updates
        &egrave; prima che le partizioni siano montate, in modalit&agrave;
        singolo utente.</para>

      <note>
        <para>Da FreeBSD&nbsp;4.5, &egrave; possibile attivare i Soft Updates
          al momento della creazione dei file system, grazie all'uso
          dell'opzione <literal>-U</literal> di &man.newfs.8;.</para>
      </note>

      <para>I Soft Updates migliorano drasticamente le prestazioni dei
        meta-dati, principalmente la creazione e la cancellazione di file,
        attraverso l'uso di una memoria cache.  Consigliamo di attivare i Soft
        Updates su tutti i file system.  Ci sono due lati negativi relativi ai
        Soft Updates dei quali dovresti essere a conoscenza: primo, i Soft
        Updates garantiscono la consistenza del file system in caso di crash ma
        &egrave; pi&ugrave; che probabile che passino molti secondi (anche un
        minuto!) prima che venga aggiornato fisicamente il disco.  Se il
        sistema crasha potresti perdere molto pi&ugrave; lavoro in questa modo.
        Secondo, i Soft Updates rallentano la liberazione dei blocchi liberi del
        file system.  Se hai un file system (come il file system root) che
        &egrave; quasi pieno, la realizzazione di un grosso aggiornamento, come
        un <command>make installworld</command>, potrebbe essere causa di un
        superamento dei limiti di spazio del file system e di un fallimento
        dell'aggiornamento.</para>

      <sect3>
        <title>Maggiori dettagli sui Soft Updates</title>

        <indexterm><primary>Soft Updates (Dettagli)</primary></indexterm>

        <para>Ci sono due approcci tradizionalmente nella scrittura dei
          meta-dati del file system su disco.  (Gli aggiornamenti dei meta-dati
          sono aggiornamenti ai dati che non sono contenuto, come gli inode o
          le directory.)</para>

        <para>Storicamente, il comportamento predefinito era di scrivere gli
          aggiornamenti dei meta-dati in maniera sincrona.  Se una directory
          veniva modificata, il sistema attendeva finch&eacute; il cambiamento
          venisse effettivamente scritto su disco.  I buffer con i dati dei file
          (i contenuti dei file) venivano passati attraverso la cache e salvati
          su disco in seguito, in maniera asincrona.  Il vantaggio di questa
          implementazione &egrave; che avviene in maniera sicura.  Se si
          verifica un problema durante un aggiornamento, i meta-dati sono sempre
          in uno stato consistente.  Un file viene creato completamente o non
          viene creato affatto.  Se i blocchi dati di un file non sono riusciti
          ad uscire dalla cache e arrivare al disco prima del crash,
          &man.fsck.8; &egrave; in grado di capirlo e riparare il file system
          impostando a zero la lunghezza del file.  Inoltre, l'implementazione
          &egrave; chiara e semplice.  Lo svantaggio &egrave; che i cambiamenti
          dei meta-dati sono lenti.  Un <command>rm -r</command>, ad esempio,
          tocca tutti i file in una directory consecutivamente, ma ogni
          cambiamento della directory (la cancellazione del file) verr&agrave;
          scritto su disco in maniera sincrona.  Questo include gli
          aggiornamenti alla directory stessa, alla tabella degli inode, e
          magari anche ai blocchi indiretti allocati dal file.  Simili
          considerazioni si applicano nell'elenco di grosse gerarchie
          (<command>tar -x</command>).</para>

        <para>Il secondo caso &egrave; l'aggiornamento asincrono dei meta-dati.
          Questo &egrave; il comportamento predefinito per Linux/ext2fs e
          <command>mount -o async</command> per *BSD/ufs.  Anche tutti gli
          aggiornamenti dei meta-dati vengono semplicemente fatti passare
          attraverso la cache, cio&egrave; vengono mescolati con gli
          aggiornamenti dei dati contenuti nel file.  Il vantaggio di questa
          implementazione &egrave; che non c'&egrave; bisogno di attendere che
          ogni aggiornamento dei meta-dati venga scritto su disco, dunque tutte
          le operazioni che causano enormi quantit&agrave; di aggiornamenti dei
          meta-dati lavorano molto pi&ugrave; velocemente che nel caso sincrono.
          Inoltre, l'implementazione &egrave; ancora semplice e chiara, dunque
          c'&egrave; un basso rischio che si annidino dei bug nel codice.
          Lo svantaggio &egrave; che non c'&egrave; nessuna garanzia di uno
          stato consistente del file system.  Se si verifica un problema durante
          un'operazione che ha aggiornato grandi quantit&agrave; di meta-dati
          (ad esempio un abbassamento di tensione, o qualcuno che preme il tasto
          reset), il file system verr&agrave; lasciato in uno stato
          imprevedibile.  Non c'&egrave; opportunit&agrave; di esaminare lo
          stato del file system quando il sistema viene riavviato; i blocchi
          dati di un file potrebbero essere gi&agrave; stati scritti sul disco
          mentre gli aggiornamenti della tabella degli inode o la directory
          associata non lo sono.
          &Egrave; praticamente impossibile implementare un
          <command>fsck</command> che sia in grado di ripulire il caos
          risultante (perch&eacute; i dati necessari non sono disponibili sul
          disco).  Se il file system &egrave; stato danneggiato pi&ugrave; del
          riparabile, la sola scelta &egrave; di usare &man.newfs.8;
          per ricrearlo e recuperarlo da un backup.</para>

        <para>La soluzione comune di questo problema era implementare
          <emphasis>la registrazione delle regioni sporche</emphasis>, a cui
          spesso si fa riferimento come <emphasis>journaling</emphasis>, anche
          se questo termine non viene usato coerentemente e talvolta viene
          applicato ad altre forme di logging delle transazioni.  Gli
          aggiornamenti dei meta-dati sono ancora scritti in maniera sincrona,
          ma solo in una piccola regione del disco.  In seguito vengono spostati
          nella posizione appropriata.  Poich&eacute; l'area di registrazione
          &egrave; una piccola regione contigua sul disco, non ci sono lunghe
          distanze da percorrere per le testine del disco, anche durante le
          operazioni pesanti, dunque queste operazioni sono pi&ugrave; veloci
          degli aggiornamenti sincroni.  Inoltre la complessit&agrave;
          dell'implementazione &egrave; piuttosto limitata, dunque il rischio
          che si presentino dei bug &egrave; basso.  Uno svantaggio &egrave; che
          tutti i meta-dati vengono scritti due volte (una volta nella regione
          di logging ed un altra nella posizione appropriata) e quindi per un
          lavoro normale si pu&ograve; avere un <quote>peggioramento</quote>
          delle prestazioni.  D'altro canto, in caso di crash, tutti le
          operazioni sui meta-dati in sospeso possono essere velocemente
          annullate o recuperate dall'area di registrazione quando il sistema
          &egrave; di nuovo attivo, e come risultato si ha un avvio veloce del
          file system.</para>

        <para>Kirk McKusick, lo sviluppatore del Berkeley FFS, ha risolto questo
          problema con i Soft Updates: tutti gli aggiornamenti dei meta-dati
          vengono tenuti in memoria e vengono scritti su disco in sequenza
          ordinata (<quote>aggiornamenti ordinati dei meta-dati</quote>).
          Ci&ograve; porta all'effetto che, in caso di operazioni pesanti sui
          meta-dati, gli ultimi aggiornamenti ad un elemento
          <quote>recuperano</quote> i precedenti se questi sono ancora in
          memoria e non sono gi&agrave; stati scritti su disco.  Dunque tutte le
          operazioni, diciamo su una directory, vengono effettuate
          principalmente in memoria prima che l'aggiornamento sia scritto su
          disco (i blocchi dei dati vengono ordinati in relazione alla loro
          posizione, in modo che non vengano scritti su disco prima dei loro
          meta-dati).  Se il sistema va in crash, ci&ograve; causa un implicito
          <quote>riavvolgimento del log</quote>: tutte le operazioni che non
          hanno ancora trovato posto sul disco appariranno come mai effettuate.
          Viene mantenuto uno stato consistente del file system che sar&agrave;
          quello di 30 o 60 secondi prima.  L'algoritmo usato garantisce anche
          che tutte le risorse in uso siano marcate come tali nelle appropriate
          tabelle di bit: blocchi e inode.  Dopo un crash, il solo errore di
          allocazione &egrave; che vengono marcate come <quote>usate</quote>
          anche risorse che sono effettivamente <quote>libere</quote>.
          &man.fsck.8; riconosce questa situazione, e libera le risorse che non
          sono pi&ugrave; in uso.  Non c'&egrave; pericolo nell'ignorare lo
          stato di <emphasis>sporcizia</emphasis> del file system dopo un crash
          montandolo di forza con <command>mount -f</command>.  Per poter
          liberare le risorse che potrebbero essere non usate, &man.fsck.8;
          ha bisogno di essere avviato in seguito.  Questa &egrave; l'idea di un
          <emphasis>fsck in background</emphasis>: all'avvio del sistema, viene
          registrata solo una <emphasis>immagine</emphasis> del file system.
          <command>fsck</command> pu&ograve; essere eseguito in seguito.  Tutti
          i file system possono essere montati <quote>sporchi</quote>, quindi il
          processo di avvio del sistema procede in modalit&agrave; multiutente.
          In seguito, <command>fsck</command> viene avviato su tutti i
          file system dove &egrave; necessario, per liberare le risorse che
          potrebbero essere inutilizzate.  (I file system che non usano i
          Soft Updates hanno ancora bisogno del solito <command>fsck</command>,
          comunque.)</para>

        <para>Il vantaggio &egrave; che le operazioni sui meta-dati sono veloci
          quasi come gli aggiornamenti asincroni (cio&egrave; pi&ugrave; veloci
          che con il <emphasis>logging</emphasis>, che deve scrivere i meta-dati
          due volte).  Gli svantaggi sono nella complessit&agrave; del codice
          (che implica un maggiore rischio di trovare bug in un'area molto
          sensibile, essendo legata alla perdita dei dati degli utenti),
          ed un consumo di memoria maggiore.  Inoltre ci sono alcune
          idiosincrasie alle quali ci si deve abituare.
          Dopo un crash, lo stato del file system appare in qualche modo
          <quote>vecchio</quote>.  In situazioni dove l'approccio
          sincrono avrebbe causato la permanenza di alcuni file di lunghezza
          zero dopo un <command>fsck</command>, questi file non esistono affatto
          con un file system con Soft Updates, perch&eacute; n&eacute; i
          meta-dati n&eacute; i contenuti dei file sono mai stati scritti su
          disco.  Lo spazio su disco non viene rilasciato finch&eacute; gli
          aggiornamenti non sono stati scritti su disco, il che pu&ograve;
          avvenire qualche tempo dopo che &egrave; stato eseguito
          <command>rm</command>.  Questo potrebbe causare problemi durante
          l'installazione di grandi quantit&agrave; di dati su un file system
          che non avesse abbastanza spazio per contenere tutti i file due
          volte.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Messa a Punto dei Limiti del Kernel</title>

    <indexterm>
      <primary>messa a punto dei limiti del kernel</primary>
    </indexterm>

    <sect2 id="file-process-limits">
      <title>Limiti dei File/Processi</title>

      <sect3 id="kern-maxfiles">
        <title><varname>kern.maxfiles</varname></title>

        <indexterm>
          <primary><varname>kern.maxfiles</varname></primary>
        </indexterm>

        <para><varname>kern.maxfiles</varname> pu&ograve; essere aumentato o
          abbassato a seconda dei requisiti del tuo sistema.  Questa variabile
          indica il numero massimo di descrittori di file sul tuo sistema.
          Quando la tabella dei descrittori di file &egrave; piena,
          apparir&agrave; ripetutamente la scritta <errorname>file: table is
          full</errorname> nel buffer dei messaggi di sistema, che pu&ograve;
          essere visualizzato con il comando <command>dmesg</command>.</para>

        <para>Ogni file, socket, o fifo aperta usa un descrittore di file.
          Un server di produzione di larga scala pu&ograve; richiedere
          facilmente molte migliaia di descrittori di file, in relazione al tipo
          e al numero di servizi in esecuzione insieme.</para>

        <para>Il valore predefinito di <varname>kern.maxfile</varname> viene
          dettato dall'opzione <option>MAXUSERS</option> nel file di
          configurazione del kernel.  <varname>kern.maxfiles</varname> cresce
          proporzionalmente al valore di <option>MAXUSERS</option>.  Quando si
          compila un kernel personalizzato, &egrave; una buona idea impostare
          questa opzione di configurazione del kernel in base agli usi del
          proprio sistema.  Da questo numero, dipendono molti dei limiti
          predefiniti del kernel.  Anche se una macchina in produzione potrebbe
          non avere effettivamente 256 utenti connessi contemporaneamente, le
          risorse necessarie potrebbero essere simili a quelle di un server web
          su larga scala.</para>

        <note>
          <para>Da FreeBSD 4.5&nbsp;in poi, l'impostazione di
            <option>MAXUSERS</option> a <literal>0</literal> nel file di
            configurazione del kernel fornir&agrave; un valore di default
            ragionevole basato sulla quantit&agrave; di RAM presente nel
            sistema.</para>
        </note>
      </sect3>
    </sect2>

    <sect2>
      <title>Limiti di Rete</title>

      <para>L'opzione di configurazione del kernel <option>NMBCLUSTERS</option>
        decide la quantit&agrave; di mbuf di rete disponibili al sistema.
        Un server molto trafficato con un numero basso di MBUF
        ostacolerebbe le possibilit&agrave; di FreeBSD.  Ogni cluster
        rappresenta approssimativamente 2&nbsp;K di memoria, dunque un valore di
        1024 rappresenta 2&nbsp;megabyte di memoria del kernel riservata per i
        buffer di rete.
        Pu&ograve; essere effettuato un semplice calcolo per capire
        quanti ne siano necessari.  Se hai un web server che arriva al massimo
        a 1000 connessioni simultanee, ed ogni connessione consuma un buffer di
        16&nbsp;K in ricezione e un'altro di 16&nbsp;K in trasmissione, avrai
        bisogno approssimativamente di 32&nbsp;MB di buffer di rete per coprire
        il web server.
        Una buona regola generale &egrave; di moltiplicare per 2, dunque
        2x32&nbsp;MB&nbsp;/&nbsp;2&nbsp;KB&nbsp;=
        64&nbsp;MB&nbsp;/&nbsp;2&nbsp;KB&nbsp;= 32768.</para>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Aggiunta di Spazio di Swap</title>

    <para>Non importa quanto bene pianifichi tutto, a volte un sistema non
      funziona come ti aspetti.  Se ti trovi ad avere bisogno di maggiore spazio
      di swap, &egrave; abbastanza semplice aggiungerlo.  Ci sono tre modi per
      aumentare lo spazio di swap: aggiungere un nuovo disco rigido, abilitare
      lo swap su NFS, e creare un file di swap su una partizione
      esistente.</para>

    <sect2 id="new-drive-swap">
      <title>Swap su un Nuovo Disco Rigido</title>

      <para>Il modo migliore per aggiungere dello swap, ovviamente, &egrave;
        usare questa come scusa per aggiungere un altro disco rigido.  Puoi
        sempre aggiungere un nuovo disco, dopo tutto.  Se puoi fare cos&igrave;,
        vai a rileggere la discussione sullo <ulink
        url="configtuning-initial.html#SWAP-DESIGN">spazio di swap</ulink> dalla
        sezione sull'<ulink
        url="configtuning-initial.html">Installazione di FreeBSD</ulink> del
        Manuale per alcuni suggerimenti su come organizzare al meglio lo spazio
        di swap.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Swap su NFS</title>

      <para>Lo swap su NFS &egrave; consigliato solo se non hai un disco locale
        su cui realizzare lo swap.  Lo swap via NFS &egrave; lento ed
        inefficiente nelle versioni di FreeBSD precedenti alla 4.X.  Nella
        4.0-RELEASE e successive &egrave; ragionevolmente efficiente e veloce.
        Anche nelle versioni pi&ugrave; nuove di FreeBSD, comunque, lo swap via
        NFS &egrave; limitato dalla larghezza di banda disponibile sulla rete e
        aggiunge ulteriore lavoro per il server NFS.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>File di Swap</title>

      <para>Puoi creare un file delle dimensioni specifiche per usarlo come file
        di swap.  In questo nostro esempio useremo un file di 64MB chiamato
        <filename>/usr/swap0</filename>.  Puoi usare qualsiasi nome vuoi,
        ovviamente.</para>

      <example>
        <title>Creazione di un File di Swap</title>

        <orderedlist>
          <listitem>
            <para>Accertati che la tua configurazione del kernel includa
              il driver per i vnode.  <emphasis>Non</emphasis> c'&egrave;
              nelle versioni recenti del <filename>GENERIC</filename>.</para>

            <programlisting>pseudo-device   vn 1   #driver vnode (trasforma un file in un dispositivo)</programlisting>
          </listitem>

          <listitem>
            <para>crea un dispositivo vn:</para>

            <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
          </listitem>

          <listitem>
            <para>crea un file di swap (<filename>/usr/swap0</filename>):</para>

            <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
          </listitem>

          <listitem>
            <para>imposta i permessi appropriati
              (<filename>/usr/swap0</filename>):</para>

            <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
          </listitem>

          <listitem>
            <para>Abilita il file di swap in
              <filename>/etc/rc.conf</filename>:</para>

            <programlisting>swapfile="/usr/swap0"   # Imposta il nome del file di swap se si desidera un file di swap ausiliario.</programlisting>
          </listitem>

          <listitem>
            <para>Riavvia la macchina, o per abilitare il file di swap
              immediatamente digita:</para>

            <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
          </listitem>
        </orderedlist>
      </example>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
