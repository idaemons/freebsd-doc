<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.58
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chern</firstname>

        <surname>Lee</surname>

        <contrib>Scritto da </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
        <firstname>Mike</firstname>

        <surname>Smith</surname>

        <contrib>Basato su un tutorial scritto da </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
        <firstname>Matt</firstname>

        <surname>Dillon</surname>

        <contrib>Basato anche su tuning(7) scritto da </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Configurazione e Messa a Punto</title>

  <sect1>
    <title>Sinossi</title>

    <indexterm>
      <primary>configurazione/ottimizzazione del sistema</primary>
    </indexterm>

    <para>Configurare un sistema correttamente pu&ograve; ridurre
      sostanzialmente la quantit&agrave; di lavoro legata al futuro mantenimento
      e aggiornamento.  Questo capitolo descrive alcuni aspetti della
      configurazione amministrativa dei sistemi FreeBSD.</para>

    <para>Inoltre questo capitolo descriver&agrave; alcuni dei parametri che
      possono essere impostati per mettere a punto un sistema FreeBSD ed
      ottenere prestazioni ottimali.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
        <para>Come e perch&eacute; dimensionare in maniera efficiente,
          progettare, e disporre filesystem e partizioni di swap sul proprio
          disco.</para>
      </listitem>

      <listitem>
        <para>Le basi dei sistemi di configurazione <filename>rc.conf</filename>
          e di avvio <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>

      <listitem>
        <para>Come configurare host virtuali sui dispositivi di rete.</para>
      </listitem>

      <listitem>
        <para>Come usare i vari file di configurazione in
          <filename>/etc</filename>.</para>
      </listitem>

      <listitem>
        <para>Come mettere a punto FreeBSD usando le variabili
          <command>sysctl</command>.</para>
      </listitem>

      <listitem>
        <para>Come ottimizzare la prestazioni del disco e modificare le
          limitazioni del kernel.</para>
      </listitem>
    </itemizedlist>

    <para>Prima di leggere questo capitolo, dovresti:</para>

    <itemizedlist>
      <listitem>
        <para>Comprendere le basi di Unix e FreeBSD (<xref
            linkend="basics">).</para>
      </listitem>

      <listitem>
        <para>Avere dimestichezza nel mantenere i sorgenti di FreeBSD aggiornati
          (<xref linkend="cutting-edge">), e nella configurazione/compilazione
          del kernel (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Configurazione Iniziale</title>

    <sect2>
      <title>Disposizione delle Partizioni</title>

      <indexterm><primary>disposizione delle partizioni</primary></indexterm>
      <indexterm><primary><filename>/etc</filename></primary></indexterm>
      <indexterm><primary><filename>/var</filename></primary></indexterm>
      <indexterm><primary><filename>/usr</filename></primary></indexterm>

      <sect3>
        <title>Partizioni di Base</title>

        <para>Nel disegnare il tuo filesystem con &man.disklabel.8; o
          &man.sysinstall.8;, &egrave; importante ricordare che i dischi rigidi
          possono trasferire dati ad un ritmo maggiore dalle tracce esterne che
          da quelle interne.  Sapendo questo, dovresti posizionare i tuoi
          filesystem pi&ugrave; piccoli e pi&ugrave; usati in lettura/scrittura,
          come root e swap, vicini all'esterno del disco, mentre dovresti
          posizionare partizioni pi&ugrave; ampie, come
          <filename>/usr</filename>, verso l'interno.  Per fare ci&ograve;,
          &egrave; una buona idea creare le partizioni in un ordine simile:
          root, swap,<filename>/var</filename>,
          <filename>/usr</filename>.</para>

        <para>Le dimensioni della partizione <filename>/var</filename>
          riflettono l'uso che intendi fare della tua macchina.
          <filename>/var</filename> viene usata principalmente per mantenere le
          caselle di posta, i file di log, e gli spool della stampante.  Le
          caselle di posta e file di log, in particolare, potrebbero crescere in
          maniera imprevedibile in relazione al numero di utenti presenti sul
          tuo sistema e da quanto a lungo manterrai i file di log.  Se
          intendi far funzionare un server di posta, una partizione
          <filename>/var</filename> di pi&ugrave; di un gigabyte pu&ograve;
          essere adatta.  Inoltre, <filename>/var/tmp</filename>
          dovrebbe essere abbastanza ampia da contenere tutti i pacchetti che
          potresti voler aggiungere.</para>

        <para>La partizione <filename>/usr</filename> contiene tutto il mucchio
          di file richiesti per far funzionare il sistema, ed una
          sottodirectory chiamata <filename>/usr/local</filename> contiene tutta
          la montagna di file installati dalla gerarchia dei &man.ports.7;.
          Se non vuoi usare molto i port e non hai intenzione di mantenere i
          sorgenti del sistema (<filename>/usr/src</filename>) sulla macchina,
          potresti cavartela con una partizione <filename>/usr</filename> da un
          gigabyte.  Comunque, se vuoi installare un bel po' di port
          (in particolare window manager e binari di Linux), ti consiglio almeno
          due gigabyte di <filename>/usr</filename> e se vuoi tenere i
          sorgenti del sistema sulla macchina ti consiglio una
          <filename>/usr</filename> da tre gigabyte.
          Non sottovalutare la quantit&agrave; di spazio di cui avrai bisogno
          in questa partizione, potrebbe aumentare strisciando e prenderti di
          sorpresa!</para>

        <para>Nel dimensionare le partizioni, tieni a mente le richieste di
          spazio per la crescita del sistema.  Esaurire lo spazio in una
          partizione mentre ce n'&egrave; in abbondanza in un'altra pu&ograve;
          essere causa di molta frustrazione.</para>

        <note>
          <para>Alcuni utenti che hanno usato il dimensionamento
            <literal>auto-predefinito</literal> di &man.sysinstall.8; in seguito
            hanno trovato le partizioni root o <filename>/var</filename>
            troppo piccole.  Partiziona saggiamente e generosamente.</para>
        </note>
      </sect3>

      <sect3 id="swap-design">
        <title>Partizione di Swap</title>

        <indexterm><primary>dimensionamento dello swap</primary></indexterm>
        <indexterm><primary>partizione di swap</primary></indexterm>

        <para>Come regola generale, lo spazio di swap dovrebbe essere
          tipicamente il doppio della quantit&agrave; di memoria principale.
          Ad esempio, se la macchina avesse 128 megabyte di memoria, il file di
          swap dovrebbe essere di 256 megabyte.
          Sistemi con meno memoria potrebbero funzionare meglio con uno swap
          maggiore.  Non &egrave; consigliabile configurare meno di 256 megabyte
          di swap su un sistema e dovresti tenere a mente una futura espansione
          della memoria quando deciderai le dimensioni della partizione di swap.
          Gli algoritmi di paginazione sono ottimizzati per funzionare
          al meglio quando la partizione di swap &egrave; almeno due volte la
          dimensione della memoria principale.
          Configurare uno swap troppo piccolo potrebbe portare ad una
          inefficienza nel codice di scansione della VM e anche creare problemi
          in seguito, nel caso di aggiunta di memoria alla macchina.</para>

        <para>Infine, su sistemi pi&ugrave; grandi con dischi SCSI multipli
          (o dischi IDE multipli collegati a diversi controller) &egrave;
          fortemente raccomandato configurare uno swap su ogni disco (fino a
          quattro dischi).  Le partizioni di swap sui dischi dovrebbero avere
          approssimativamente le stesse dimensioni.
          Il kernel pu&ograve; gestire dimensioni arbitrarie ma internamente le
          strutture dati scalano meglio fino a quattro volte la dimensione della
          partizione di swap pi&ugrave; ampia.  Avere partizioni di swap con
          dimensioni simili permetter&agrave; al kernel di distribuire al meglio
          lo spazio di swap tra i dischi.  Non preoccuparti di esagerare un po',
          lo spazio di swap &egrave; un dono prezioso di Unix.
          Anche se in genere non userai molto swap, esso pu&ograve; fornirti
          pi&ugrave; tempo di recupero da un programma impazzito prima di essere
          costretti a riavviare.</para>
      </sect3>

      <sect3>
        <title>Perch&eacute; Partizionare?</title>

        <para>Ma perch&eacute; partizionare, in generale? Perch&eacute; non
          creare un'unica grossa partizione di root e lavorare con quella?
          Cos&igrave; non dovrei preoccuparmi di sottodimensionare
          qualcosa!</para>

        <para>Ci sono parecchie ragioni per le quali questa non &egrave; una
          buona idea.  Primo, ogni partizione ha differenti caratteristiche
          operative e separarle permette ai filesystem di ottimizzare se stessi
          per quelle caratteristiche.  Ad esempio, le partizioni root e
          <filename>/usr</filename> sono per lo pi&ugrave; usate in lettura, con
          una quantit&agrave; di scrittura molto bassa, mentre un sacco di
          letture e scritture potrebbero esserci in <filename>/var</filename> e
          <filename>/var/tmp</filename>.</para>

        <para>Partizionando in maniera appropriata il sistema, la
          frammentazione introdotta nelle partizioni pi&ugrave; piccole,
          con pi&ugrave; carico in scrittura, non incider&agrave; sulle
          partizioni per lo pi&ugrave; di lettura.
          Inoltre mantenere le partizioni con maggiore carico in scrittura
          vicine al bordo del disco, ad esempio prima della partizione
          pi&ugrave; grossa piuttosto che dopo, nella tabella delle partizioni,
          aumenter&agrave; le prestazioni di I/O nelle partizioni dove ne hai
          pi&ugrave; bisogno.  Ora, &egrave; vero che potresti avere bisogno di
          prestazioni di I/O anche nelle partizioni pi&ugrave; ampie, ma esse
          sono cos&igrave; grandi che spostarle verso il bordo del disco non
          porterebbe nessun miglioramento significativo delle prestazioni,
          mentre spostare <filename>/var</filename> all'esterno potrebbe avere
          un impatto enorme.  Infine, ci sono problemi riguardanti la sicurezza.
          Una piccola, simpatica partizione di root che &egrave; essenzialmente
          di sola lettura ha ottime possibilit&agrave; di sopravvivere intatta a
          un brutto crash.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Configurazione Centrale</title>

    <indexterm>
      <primary>i file rc</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>Il posto principale per le informazioni di configurazione del sistema
      &egrave; in <filename>/etc/rc.conf</filename>.  Questo file contiene una
      ampia gamma di informazioni di configurazione, usate principalmente
      all'avvio della macchina per la configurazione del sistema.
      Il suo nome implica direttamente questo; si tratta di informazioni
      di configurazione per i file <filename>rc*</filename>.</para>

    <para>Un amministratore dovrebbe aggiungere dei campi nel file
      <filename>rc.conf</filename> per cambiare le impostazioni
      predefinite di <filename>/etc/defaults/rc.conf</filename>.
      Il file predefinito non drovebbe essere semplicemente copiato in
      <filename>/etc</filename> - esso contiene valori di default, non esempi.
      Tutti i cambiamenti specifici del sistema dovrebbero essere effettuati
      nel file <filename>rc.conf</filename> stesso.</para>

    <para>Nelle applicazioni clustered possono essere adottate differenti
      strategie per separare le configurazioni generali da quelle specifiche del
      sistema in maniera da mantenere basso l'impegno di amministrazione.
      L'approccio raccomandato &egrave; di porre le configurazioni generali in
      un altro file, ad esempio <filename>/etc/rc.conf.site</filename>, e poi
      includerlo in <filename>/etc/rc.conf</filename>, che conterr&agrave; solo
      le informazioni specifiche del sistema.</para>

    <para>Visto che <filename>rc.conf</filename> viene letto da &man.sh.1;
      &egrave; semplice farlo.  Ad esempio:</para>

    <itemizedlist>
      <listitem>
        <para>rc.conf:</para>

        <programlisting>        . rc.conf.site
        hostname="nodo15.example.com"
        network_interfaces="fxp0 lo0"
        ifconfig_fxp0="inet 10.1.1.1"</programlisting>
      </listitem>

      <listitem>
        <para>rc.conf.site:</para>

        <programlisting>        defaultrouter="10.1.1.254"
        saver="daemon"
        blanktime="100"</programlisting>
      </listitem>
    </itemizedlist>

    <para>Il file <filename>rc.conf.site</filename> potr&agrave; poi essere
      distribuito su ogni sistema usando <command>rsync</command> o un programma
      simile, mentre il file <filename>rc.conf</filename> rimarr&agrave;
      unico.</para>

    <para>L'aggiornamento del sistema tramite &man.sysinstall.8;
      o <command>make world</command> non sovrascriver&agrave; il file
      <filename>rc.conf</filename>, quindi le configurazioni del sistema non
      andranno perse.</para>
  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Configurazione delle Applicazioni</title>

    <para>Tipicamente, le applicazioni installate hanno i propri file di
      configurazione, con la loro sintassi, ecc.  E' importante che questi file
      siano tenuti separati dal sistema di base, in maniera da essere
      facilmente individuati e gestiti dagli strumenti di gestione dei
      pacchetti.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>In genere, questi file vengono installati in
      <filename>/usr/local/etc</filename>.  Nel caso in cui una applicazione
      abbia un grande numero di file di configurazione, verr&agrave; creata una
      sottodirectory per contenerli.</para>

    <para>Normalmente, quando viene installato un pacchetto, vengono installati
      anche file di configurazione d'esempio.  In genere questi vengono
      identificati da un suffisso <filename>.default</filename>.  Se non ci sono
      file di configurazione esistenti per l'applicazione, verranno creati
      copiando i file <filename>.default</filename>.</para>

    <para>Ad esempio, considera il contenuto della directory
      <filename>/usr/local/etc/apache</filename>:</para>

    <literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Le differenze nelle dimensioni dei file mostrano che solo
      <filename>srm.conf</filename> &egrave; stato modificato.
      Una successiva installazione di <application>Apache</application> dai port
      non sovrascriver&agrave; questo file modificato.</para>
  </sect1>

  <sect1 id="configtuning-starting-services">
    <title>Avvio dei Servizi</title>

    <indexterm><primary>servizi</primary></indexterm>

    <para>&Egrave; comune per un sistema sostenere un certo numero di servizi.
      Questi possono essere avviati in molti modi differenti, ognuno dei quali
      ha vantaggi differenti.</para>

    <indexterm><primary>/usr/local/etc/rc.d</primary></indexterm>

    <para>I programmi installati tramite port o dalla collezione dei pacchetti
      metteranno spesso uno script in <filename>/usr/local/etc/rc.d</filename>
      che verr&agrave; invocato all'avvio del sistema con l'argomento
      <option>start</option>, ed allo spegnimento con l'argomento
      <option>stop</option>.  Questo &egrave; il modo consigliato per avviare i
      servizi di sistema che devono funzionare come <username>root</username>, o
      che hanno bisogno di essere lanciati da <username>root</username>.
      Questi script sono registrati come parte dell'installazione del pacchetto,
      e saranno rimossi quando verr&agrave; rimosso il pacchetto.</para>

    <para>Uno script di avvio generico in
      <filename>/usr/local/etc/rc.d</filename> appare cos&igrave;:</para>

    <programlisting>#!/bin/sh
echo -n ' FooBar'

case "$1" in
start)
        /usr/local/bin/foobar
        ;;
stop)
        kill -9 `cat /var/run/foobar.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0</programlisting>

    <para>Gli script di avvio di FreeBSD cercheranno in
      <filename>/usr/local/etc/rc.d</filename> degli script che abbiano una
      estensione <literal>.sh</literal> e siano eseguibili da
      <username>root</username>.  Gli script trovati verranno richiamati con
      l'opzione <option>start</option> all'avvio, e <option>stop</option>
      allo spegnimento per permettergli di svolgere il loro compito.
      Quindi se volessi che il suddetto script di esempio venisse trovato ed
      eseguito al momento giusto, durante l'avvio del sistema, dovresti
      salvarlo in un file di nome <filename>FooBar.sh</filename> in
      <filename>/usr/local/etc/rc.d</filename> e dovresti assicurarti che sia
      eseguibile.  Puoi rendere uno script eseguibile tramite &man.chmod.1; come
      mostrato di seguito:</para>

    <screen>&prompt.root; <userinput>chmod 755 <replaceable>FooBar.sh</replaceable></userinput></screen>

    <para>Alcuni servizi aspettano di essere invocati da &man.inetd.8; quando
      viene ricevuta una connessione su una porta valida.  Ci&ograve; &egrave;
      comune per tutti i server di lettura della posta (POP e IMAP, ecc.).
      Questi servizi vengono abilitati modificando il file
      <filename>/etc/inetd.conf</filename>.
      Guarda &man.inetd.8; per i dettagli sulla modifica di questo file.</para>

    <para>Alcuni servizi aggiuntivi potrebbero non essere coperti dalle opzioni
      in <filename>/etc/rc.conf</filename>.
      Tradizionalmente questi vengono avviati mettendo i comandi necessari per
      invocarli in <filename>/etc/rc.local</filename>.
      Da FreeBSD 3.1 non c'&egrave; pi&ugrave; nessun
      <filename>/etc/rc.local</filename> predefinito;.  Se venisse creato
      dall'amministratore, esso verrebbe comunque gestito normalmente.
      Nota che <filename>rc.local</filename> viene generalmente visto come
      ultima possibilit&agrave;; se c'&egrave; un posto migliore per avviare il
      servizio, fallo da l&igrave;.</para>

    <note>
      <para><emphasis>NON</emphasis> mettere nessun comando in
        <filename>/etc/rc.conf</filename>.  Per avviare i demoni, o per eseguire
        un qualsiasi comando all'avvio, metti invece uno script in
        <filename>/usr/local/etc/rc.d</filename>.</para>
    </note>

    <para>&egrave; anche possibile usare il demone &man.cron.8; per avviare i
      servizi di sistema.  Questo approccio ha molti vantaggi, non ultimo il
      fatto che poich&eacute; &man.cron.8; esegue questi processi come il
      proprietario di <command>crontab</command>, i servizi possono essere
      avviati e mantenuti da utenti non-<username>root</username>.</para>

    <para>Per fare ci&ograve; si approfitta di una caratteristica di
      &man.cron.8;: le specifiche temporali possono essere sostituite da
      <literal>@reboot</literal>, che far&agrave; s&igrave; che il compito
      venga eseguito quando &man.cron.8; viene avviato, poco dopo l'avvio del
      sistema.</para>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Host Virtuali</title>

    <indexterm><primary>host virtuali</primary></indexterm>
    <indexterm><primary>alias ip</primary></indexterm>

    <para>Un uso piuttosto comune di FreeBSD &egrave; come hosting di siti
      virtuali, dove un solo server appare alla rete come molti server distinti.
      Ci&ograve; viene effettuato assegnando indirizzi di rete multipli ad una
      sola interfaccia.</para>

    <para>Una data interfaccia di rete ha un solo indirizzo
      <quote>reale</quote>, e pu&ograve; avere un numero qualsiasi di indirizzi
      <quote>alias</quote>.  Questi alias vengono normalmente aggiunti mettendo
      dei campi alias in <filename>/etc/rc.conf</filename>.</para>

    <para>Un campo alias per l'interfaccia <devicename>fxp0</devicename>
      appare cos&igrave;:</para>

    <programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Nota che il campo alias deve iniziare con alias0 e aumentare in
      ordine, (ad esempio, _alias1, _alias2, e cos&igrave; via).  Il processo di
      configurazione si fermer&agrave; al primo numero mancante.</para>

    <para>Il calcolo delle maschere di sottorete degli alias &egrave;
      importante, ma, fortunatamente, &egrave; anche abbastanza semplice.
      Per una data interfaccia, deve esserci un indirizzo che rappresenta
      correttamente la maschera di sottorete.
      Ogni altro indirizzo che ricada in questa rete deve avere una maschera di
      sottorete con tutti 1.</para>

    <para>Ad esempio, considera il caso in cui l'interfaccia
      <devicename>fxp0</devicename> sia connessa a due reti, la rete 10.1.1.0
      con maschera di sottorete 255.255.255.0 e la rete 202.0.75.16 con maschera
      di sottorete 255.255.255.240.  Vogliamo che il sistema sia visibile come
      10.1.1.1 fino a 10.1.1.5 e come 202.0.75.17 fino a 202.0.75.20.</para>

    <para>Le seguenti righe configurano il dispositivo correttamente per questo
      scopo:</para>

    <programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>
  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>File di Configurazione</title>

    <sect2>
      <title>Struttura di <filename>/etc</filename></title>

      <para>Ci sono molte directory nelle quali vengono tenute le informazioni
        di configurazione.  Tra queste ci sono:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><filename>/etc</filename></entry>

              <entry>Informazioni generiche sulla configurazione del sistema;
                questi dati  sono specifici del sistema.</entry>
            </row>

            <row>
              <entry><filename>/etc/defaults</filename></entry>

              <entry>Versioni di default dei file di configurazione del
                sistema.</entry>
            </row>

            <row>
              <entry><filename>/etc/mail</filename></entry>

              <entry>Configurazioni extra di &man.sendmail.8;, o file di
                configurazione di altri MTA.</entry>
            </row>

            <row>
              <entry><filename>/etc/ppp</filename></entry>

              <entry>Configurazione ppp sia per i programmi a livello utente che
                a livello kernel.</entry>
            </row>

            <row>
              <entry><filename>/etc/namedb</filename></entry>

              <entry>Posizione predefinita per i dati di &man.named.8;.
                Normalmente qui si trova <filename>named.conf</filename> insieme
                ai file di zona.</entry>
            </row>

            <row>
              <entry><filename>/usr/local/etc</filename></entry>

              <entry>File di configurazione per le applicazioni installate.
                Pu&ograve; contenere sottodirectory.</entry>
            </row>

            <row>
              <entry><filename>/usr/local/etc/rc.d</filename></entry>

              <entry>Script start/stop per i programmi installati.</entry>
            </row>

            <row>
              <entry><filename>/var/db</filename></entry>

              <entry>File di dati specifici del sistema generati
                automaticamente, come il database dei package, il database di
                locate, e cos&igrave; via.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Nomi degli Host</title>

      <indexterm><primary>nomi degli host</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
        <title><filename>/etc/resolv.conf</filename></title>

        <indexterm>
          <primary><filename>resolv.conf</filename></primary>
        </indexterm>

        <para><filename>/etc/resolv.conf</filename> detta il modo in cui il
          sistema di risoluzione dei nomi di FreeBSD accede all'Internet Domain
          Name System (DNS).</para>

        <para>I campi pi&ugrave; comuni in <filename>resolv.conf</filename>
          sono:</para>

        <informaltable frame="none">
          <tgroup cols="2">
            <tbody>
              <row>
                <entry><literal>nameserver</literal></entry>

                <entry>L'indirizzo IP di un name server al quale dovr&agrave;
                  rivolgersi il sistema di risoluzione.  I server vengono
                  interrogati nell'ordine in cui sono elencati, fino a un
                  massimo di tre.</entry>
              </row>

              <row>
                <entry><literal>search</literal></entry>

                <entry>Lista di ricerca per i nomi degli host.  Normalmente
                  questo viene determinato dal dominio dell'host locale.</entry>
              </row>

              <row>
                <entry><literal>domain</literal></entry>

                <entry>Il nome del dominio locale.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Un <filename>resolv.conf</filename> tipico:</para>

        <programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

        <note>
          <para>Si dovrebbe usare solo una tra le due opzioni
            <literal>search</literal> e <literal>domain</literal>.</para>
        </note>

        <para>Se stai usando DHCP, &man.dhclient.8; generalmente
          sovrascriver&agrave; <filename>resolv.conf</filename> con le
          informazioni ricevute dal server DHCP.</para>
      </sect3>

      <sect3>
        <title><filename>/etc/hosts</filename></title>

        <indexterm><primary>hosts</primary></indexterm>

        <para><filename>/etc/hosts</filename> &egrave; un semplice database
          testuale, reminescenza della vecchia rete Internet.
          Esso lavora in congiunzione con DNS e NIS fornendo una mappatura da
          nome a indirizzo IP.  Computer locali connessi ad una LAN possono
          essere messi in questo file per una gestione semplice dei nomi, invece
          di mettere su un server &man.named.8;.
          Inoltre, <filename>/etc/hosts</filename> pu&ograve; essere usato per
          fornire un registro locale dei nomi di internet, riducendo la
          necessit&agrave; di effettuare richieste esternamente per i nomi ad
          accesso frequente.</para>

        <programlisting># &dollar;FreeBSD&dollar;
#
# Host Database
# Questo file dovrebbe contenere gli indirizzi e gli alias
# per gli host locali che condividono questo file.
# In presenza di DNS o NIS, questo file potrebbe non essere consultato affatto;
# guarda /etc/nsswitch.conf per l'ordine di risoluzione.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Rete immaginaria.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# In accordo all'RFC 1918, puoi usare le seguenti classi di IP per reti private
# che non verranno mai connesse ad Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In caso volessi essere in grado di collegarti ad Internet, avrai bisogno
# di veri numeri ufficiali assegnati.  PER FAVORE PER FAVORE PER FAVORE
# non tentare di inventarti i numeri della tua rete ma fattene assegnare
# uno dal tuo provider (se ne hai uno) o dall'Internet Registry (ftp su
# rs.internic.net, directory `/templates').
#</programlisting>

        <para><filename>/etc/hosts</filename> accetta il semplicissimo
          formato:</para>

        <programlisting>[Indirizzo Internet ] [nome host ufficiale] [alias1] [alias2] ...</programlisting>

        <para>Ad esempio:</para>

        <programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

        <para>Consulta &man.hosts.5; per maggiori informazioni.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configurazione dei File di Log</title>

      <indexterm><primary>file di log</primary></indexterm>

      <sect3>
        <title><filename>syslog.conf</filename></title>

        <indexterm><primary>syslog.conf</primary></indexterm>

        <para><filename>syslog.conf</filename> &egrave; il file di
          configurazione per il programma &man.syslogd.8;.  Indica quale tipo di
          messaggi verranno scritti su ogni file di log.</para>

        <programlisting># &dollar;FreeBSD&dollar;
#
#       Gli spazi SONO validi separatori dei campi in questo file. Ad ogni modo,
#       altri sistemi *nix-like insistono ancora nell'usare tab come separatori
#       di campo. Se condividi questo file tra pi&ugrave; sistemi, potresti
#       voler usare solo dei tab come separatori.
#       Consulta la pagina man di syslog.conf(5).
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# togli il commento a questo per loggare tutte le scritture su /dev/console
# in /var/log/console.log
#console.info                                   /var/log/console.log
# togli il commento a questo per abilitare il logging di tutti i messaggi di log
# su /var/log/all.log
#*.*                                            /var/log/all.log
# togli il commento a questo per abilitare il logging su un host remoto di nome
# loghost
#*.*                                            @loghost
# togli i commenti a questi se hai inn in funzione
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

        <para>Consulta la pagina man di &man.syslog.conf.5; per maggiori
          informazioni.</para>
      </sect3>

      <sect3>
        <title><filename>newsyslog.conf</filename></title>

        <indexterm><primary>newsyslog.conf</primary></indexterm>

        <para><filename>newsyslog.conf</filename> &egrave; il file di
          configurazione di &man.newsyslog.8;, un programma che normalmente
          viene eseguito da &man.cron.8;. &man.newsyslog.8; determina quando i
          file di log richiedono un archiviazione o un riordinamento.
          <filename>logfile</filename> viene rinominato in
          <filename>logfile.0</filename>, <filename>logfile.0</filename> in
          <filename> logfile.1</filename> e cos&igrave; via.
          Alternativamente, i file potranno essere archiviati in formato
          &man.gzip.1;, e quindi diventeranno:
          <filename>logfile.0.gz</filename>, <filename>logfile.1.gz</filename>,
          e cos&igrave; via.</para>

        <para><filename>newsyslog.conf</filename> indica quali file di log
          devono essere gestiti, quanti devono essere mantenuti, e quando devono
          essere toccati.  I file di log possono essere riordinati e/o
          archiviati quando raggiungono una certa dimensione, o a una certa
          data/ora periodica.</para>

        <programlisting># file di configurazione per newsyslog
# &dollar;FreeBSD&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

        <para>Consulta la pagina man di &man.newsyslog.8; per maggiori
          informazioni.</para>
      </sect3>
    </sect2>

    <sect2>
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> assomiglia molto a
        <filename>rc.conf</filename>.  I valori vengono impostati nella forma
        <literal>variabile=valore</literal>.  I valori specificati vengono
        impostati dopo che il sistema &egrave; entrato in modalit&agrave;
        multiutente.  Non tutte le variabili sono gestibili in questo
        modo.</para>

      <para>Un <filename>sysctl.conf</filename> d'esempio che disattiva il
        logging delle uscite forzate da segnali non gestibili e che
        lascia capire ai programmi di Linux che essi stanno effettivamente
        funzionando sotto FreeBSD:</para>

      <programlisting>kern.logsigexit=0       # Non registra le uscite forzate (es. sig 11)
compat.linux.osname=FreeBSD
compat.linux.osrelease=4.3-STABLE</programlisting>
    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Messa a Punto con sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm><primary>messa a punto con sysctl</primary></indexterm>

    <para>&man.sysctl.8; &egrave; un'interfaccia che vi permette di effettuare
      cambiamenti ad un sistema FreeBSD gi&agrave; attivo.  Questo include molte
      opzioni avanzate dello stack TCP/IP e del sistema di memoria virtuale che
      possono permettere di migliorare drammaticamente le prestazioni ad un
      sistemista che abbia esperienza.  Pi&ugrave; di cinquecento variabili di
      sistema possono essere lette e modificate usando &man.sysctl.8;.</para>

    <para>In sostanza, &man.sysctl.8; serve a due cose: a leggere e a modificare
      le impostazioni di sistema.</para>

    <para>Per visualizzare tutte le variabili modificabili:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Per leggere una particolare variabile, ad esempio,
      <varname>kern.maxproc</varname>:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Per impostare una particolare variabile, usa l'intuitiva sintassi
      <replaceable>variabile</replaceable>=<replaceable>valore</replaceable>:</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>I valori validi per le variabili di sysctl sono generalmente o
      stringhe, o numeri, o valori booleani (un valore booleano pu&ograve;
      valere <literal>1</literal> per s&igrave; o <literal>0</literal> per
      no).</para>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Messa a Punto dei Dischi</title>

    <sect2>
      <title>Variabili sysctl</title>

      <sect3>
        <title><varname>vfs.vmiodirenable</varname></title>

        <indexterm>
          <primary><varname>vfs.vmiodirenable</varname></primary>
        </indexterm>

        <para>La variabile sysctl <varname>vfs.vmiodirenable</varname>
          pu&ograve; essere impostata a 0 (inattivo) o 1 (attivo); di default
          &egrave; 1.  Questa variabile controlla il modo in cui le directory
          vengono messe nella cache dal sistema.  La maggior parte delle
          directory &egrave; piccola, ed usa solo un singolo frammento
          (tipicamente 1K) nel filesystem e meno (tipicamente 512 byte) nella
          cache.  Ad ogni modo, quando si lavora nella modalit&agrave;
          predefinita il buffer manterr&agrave; soltanto un numero fissato di
          directory anche se hai una quantit&agrave; enorme di memoria.
          Attivando questa sysctl si permette al buffer di usare la VM Page
          Cache per immagazzinare le directory, rendendo disponibile tutta la
          memoria disponibile per il caching delle directory.  In ogni caso, la
          minima quantit&agrave; di memoria usata per memorizzare una directory
          sar&agrave; la dimensione della pagina fisica (in genere 4K) invece di
          512 byte.  Noi consigliamo di attivare questa opzione se si hanno in
          esecuzione dei servizi che manipolano un grosso numero file.  Servizi
          di questo tipo sono le cache web, i grandi sistemi di posta, e quelli
          di news.  Attivare questa opzione in generale non ridurr&agrave; le
          prestazioni nonostante la memoria sprecata, ma dovresti sperimentare
          tu stesso per verificare.</para>
      </sect3>

      <sect3>
        <title><varname>hw.ata.wc</varname></title>

        <indexterm><primary><varname>hw.ata.wc</varname></primary></indexterm>

        <para>FreeBSD 4.3 ha giocato un po' con l'idea di disattivare il caching
          IDE in scrittura.  Questo ha ridotto la larghezza di banda in
          scrittura verso i dischi IDE ma &egrave; stato considerato necessario
          a causa di gravi problemi di consistenza dei dati introdotti dai
          venditori di dischi rigidi.  Il problema &egrave; che il disco IDE
          rimane inattivo dopo che una scrittura &egrave; stata completata.  Con
          il caching in scrittura attivo, i dischi IDE non scrivono soltanto i
          dati sui dischi in maniera disordinata, ma talvolta rimandano la
          scrittura indefinitamente sotto carichi di lavoro del disco pesanti.
          Un crash o un calo di tensione possono condurre a seri problemi di
          corruzione del file system.  L'impostazione predefinita di FreeBSD fu
          cambiata in favore della sicurezza.  Sfortunatamente, il risultato
          &egrave; stato una perdita di prestazioni talmente tremenda che
          abbiamo dovuto reinserire il caching in scrittura di default dopo
          quella release.  Dovresti verificare il valore di default sul tuo
          sistema osservando la variabile sysctl <varname>hw.ata.wc</varname>.
          Se il caching IDE in scrittura &egrave; disattivato, potete attivarlo
          reimpostando la variabile del kernel a 1.  Questo dovrebbe essere
          effettuato dal boot loader all'avvio.  Tentare di effettuare questo
          cambiamento dopo che il kernel &egrave; stato avviato non avr&agrave;
          nessun effetto.</para>

        <para>Per maggiori informazioni, guarda &man.ata.4;.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Il programma &man.tunefs.8; pu&ograve; essere usato per mettere a
        punto con accuratezza un filesystem.  Questo programma ha molte opzioni
        differenti, ma per ora noi ci preoccuperemo solo di attivare e
        disattivare i Soft Updates, che verr&agrave; effettuato tramite:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Un filesystem non potr&agrave; essere modificato con &man.tunefs.8;
        mentre &egrave; montato.  Un buon momento per attivare i Soft Updates
        &egrave; prima che le partizioni siano montate, in modalit&agrave;
        singolo utente.</para>

      <note>
        <para>Da FreeBSD 4.5, &egrave; possibile attivare i Soft Updates
          al momento della creazione dei filesystem, grazie all'uso dell'opzione
          <literal>-U</literal> di &man.newfs.8;.</para>
      </note>

      <para>I Soft Updates migliorano drasticamente le prestazioni dei
        meta-dati, principalmente la creazione e la cancellazione di file,
        attraverso l'uso di una memoria cache.  Consigliamo di attivare i Soft
        Updates su tutti i filesystem.  Ci sono due lati negativi relativi ai
        Soft Updates dei quali dovresti essere a conoscenza: primo, i Soft
        Updates garantiscono la consistenza del filesystem in caso di crash ma
        &egrave; pi&ugrave; che probabile che passino molti secondi (anche un
        minuto!) prima che venga aggiornato fisicamente il disco.  Se il
        sistema crasha potresti perdere molto pi&ugrave; lavoro in questa modo.
        Secondo, i Soft Updates rallentano la liberazione dei blocchi liberi del
        filesystem.  Se hai un filesystem (come il filesystem root) che
        &egrave; quasi pieno, la realizzazione di un grosso aggiornamento, come
        un <command>make installworld</command>, potrebbe essere causa di un
        superamento dei limiti di spazio del file system e di un fallimento
        dell'aggiornamento.</para>

      <sect3>
        <title>Maggiori dettagli sui Soft Updates</title>

        <indexterm><primary>Soft Updates (Dettagli)</primary></indexterm>

        <para>Ci sono due approcci tradizionalmente nella scrittura dei
          meta-dati del filesystem su disco.  (Gli aggiornamenti dei meta-dati
          sono aggiornamenti ai dati che non sono contenuto, come gli inode o
          le directory.)</para>

        <para>Storicamente, il comportamento predefinito era di scrivere gli
          aggiornamenti dei meta-dati in maniera sincrona.  Se una directory
          veniva modificata, il sistema attendeva finch&eacute; il cambiamento
          venisse effettivamente scritto su disco.  I buffer con i dati dei file
          (i contenuti dei file) venivano passati attraverso la cache e salvati
          su disco in seguito, in maniera asincrona.  Il vantaggio di questa
          implementazione &egrave; che avviene in maniera sicura.  Se si
          verifica un problema durante un aggiornamento, i meta-dati sono sempre
          in uno stato consistente.  Un file viene creato completamente o non
          viene creato affatto.  Se i blocchi dati di un file non sono riusciti
          ad uscire dalla cache e arrivare al disco prima del crash,
          &man.fsck.8; &egrave; in grado di capirlo e riparare il filesystem
          impostando a zero la lunghezza del file.  Inoltre, l'implementazione
          &egrave; chiara e semplice.  Lo svantaggio &egrave; che i cambiamenti
          dei meta-dati sono lenti.  Un <command>rm -r</command>, ad esempio,
          tocca tutti i file in una directory consecutivamente, ma ogni
          cambiamento della directory (la cancellazione del file) verr&agrave;
          scritto su disco in maniera sincrona.  Questo include gli
          aggiornamenti alla directory stessa, alla tabella degli inode, e
          magari anche ai blocchi indiretti allocati dal file.  Simili
          considerazioni si applicano nell'elenco di grosse gerarchie
          (<command>tar -x</command>).</para>

        <para>Il secondo caso &egrave; l'aggiornamento asincrono dei meta-dati.
          Questo &egrave; il comportamento predefinito per Linux/ext2fs e
          <command>mount -o async</command> per *BSD/ufs.  Anche tutti gli
          aggiornamenti dei meta-dati vengono semplicemente fatti passare
          attraverso la cache, cio&egrave; vengono mescolati con gli
          aggiornamenti dei dati contenuti nel file.  Il vantaggio di questa
          implementazione &egrave; che non c'&egrave; bisogno di attendere che
          ogni aggiornamento dei meta-dati venga scritto su disco, dunque tutte
          le operazioni che causano enormi quantit&agrave; di aggiornamenti dei
          meta-dati lavorano molto pi&ugrave; velocemente che nel caso sincrono.
          Inoltre, l'implementazione &egrave; ancora semplice e chiara, dunque
          c'&egrave; un basso rischio che si annidino dei bug nel codice.
          Lo svantaggio &egrave; che non c'&egrave; nessuna garanzia di uno
          stato consistente del filesystem.  Se si verifica un problema durante
          un'operazione che ha aggiornato grandi quantit&agrave; di meta-dati
          (ad esempio un abbassamento di tensione, o qualcuno che preme il tasto
          reset), il filesystem verr&agrave; lasciato in uno stato
          imprevedibile.  Non c'&egrave; opportunit&agrave; di esaminare lo
          stato del filesystem quando il sistema viene riavviato; i blocchi dati
          di un file potrebbero essere gi&agrave; stati scritti sul disco mentre
          gli aggiornamenti della tabella degli inode o la directory associata
          non lo sono.  &Egrave; praticamente impossibile implementare un
          <command>fsck</command> che sia in grado di ripulire il caos
          risultante (perch&eacute; i dati necessari non sono disponibili sul
          disco).  Se il filesystem &egrave; stato danneggiato pi&ugrave; del
          riparabile, la sola scelta &egrave; di usare <command>newfs</command>
          per ricrearlo e recuperarlo da un backup.</para>

        <para>La soluzione comune di questo problema era implementare
          <emphasis>la registrazione delle regioni sporche</emphasis>, a cui
          spesso si fa riferimento come <emphasis>journaling</emphasis>, anche
          se questo termine non viene usato coerentemente e talvolta viene
          applicato ad altre forme di logging delle transazioni.  Gli
          aggiornamenti dei meta-dati sono ancora scritti in maniera sincrona,
          ma solo in una piccola regione del disco.  In seguito vengono spostati
          nella posizione appropriata.  Poich&eacute; l'area di registrazione
          &egrave; una piccola regione contigua sul disco, non ci sono lunghe
          distanze da percorrere per le testine del disco, anche durante le
          operazioni pesanti, dunque queste operazioni sono pi&ugrave; veloci
          degli aggiornamenti sincroni.  Inoltre la complessit&agrave;
          dell'implementazione &egrave; piuttosto limitata, dunque il rischio
          che si presentino dei bug &egrave; basso.  Uno svantaggio &egrave; che
          tutti i meta-dati vengono scritti due volte (una volta nella regione
          di logging ed un altra nella posizione appropriata) e quindi per un
          lavoro normale si pu&ograve; avere un <quote>peggioramento</quote>
          delle prestazioni.  D'altro canto, in caso di crash, tutti le
          operazioni sui meta-dati in sospeso possono essere velocemente
          annullate o recuperate dall'area di registrazione quando il sistema
          &egrave; di nuovo attivo, e come risultato si ha un avvio veloce del
          filesystem.</para>

        <para>Kirk McKusick, lo sviluppatore del Berkeley FFS, ha risolto questo
          problema con i Soft Updates: tutti gli aggiornamenti dei meta-dati
          vengono tenuti in memoria e vengono scritti su disco in sequenza
          ordinata (<quote>aggiornamenti ordinati dei meta-dati</quote>).
          Ci&ograve; porta all'effetto che, in caso di operazioni pesanti sui
          meta-dati, gli ultimi aggiornamenti ad un elemento
          <quote>recuperano</quote> i precedenti se questi sono ancora in
          memoria e non sono gi&agrave; stati scritti su disco.  Dunque tutte le
          operazioni, diciamo su una directory, vengono effettuate
          principalmente in memoria prima che l'aggiornamento sia scritto su
          disco (i blocchi dei dati vengono ordinati in relazione alla loro
          posizione, in modo che non vengano scritti su disco prima dei loro
          meta-dati).  Se il sistema va in crash, ci&ograve; causa un implicito
          <quote>riavvolgimento del log</quote>: tutte le operazioni che non
          hanno ancora trovato posto sul disco appariranno come mai effettuate.
          Viene mantenuto uno stato consistente del filesystem che sar&agrave;
          quello di 30 o 60 secondi prima.  L'algoritmo usato garantisce anche
          che tutte le risorse in uso siano marcate come tali nelle appropriate
          tabelle di bit: blocchi e inode.  Dopo un crash, il solo errore di
          allocazione &egrave; che vengono marcate come <quote>usate</quote>
          anche risorse che sono effettivamente <quote>libere</quote>.
          &man.fsck.8; riconosce questa situazione, e libera le risorse che non
          sono pi&ugrave; in uso.  Non c'&egrave; pericolo nell'ignorare lo
          stato di <emphasis>sporcizia</emphasis> del filesystem dopo un crash
          montandolo di forza con <command>mount -f</command>.  Per poter
          liberare le risorse che potrebbero essere non usate, &man.fsck.8;
          ha bisogno di essere avviato in seguito.  Questa &egrave; l'idea di un
          <emphasis>fsck in background</emphasis>: all'avvio del sistema, viene
          registrata solo una <emphasis>immagine</emphasis> del filesystem.
          <command>fsck</command> pu&ograve; essere eseguito in seguito.  Tutti
          i filesystem possono essere montati <quote>sporchi</quote>, quindi il
          processo di avvio del sistema procede in modalit&agrave; multiutente.
          In seguito, <command>fsck</command> viene avviato su tutti i
          filesystem dove &egrave; necessario, per liberare le risorse che
          potrebbero essere inutilizzate.  (I filesystem che non usano i
          Soft Updates hanno ancora bisogno del solito <command>fsck</command>,
          comunque.)</para>

        <para>Il vantaggio &egrave; che le operazioni sui meta-dati sono veloci
          quasi come gli aggiornamenti asincroni (cio&egrave; pi&ugrave; veloci
          che con il <emphasis>logging</emphasis>, che deve scrivere i meta-dati
          due volte).  Gli svantaggi sono nella complessit&agrave; del codice
          (che implica un maggiore rischio di trovare bug in un'area molto
          sensibile, essendo legata alla perdita dei dati degli utenti),
          ed un consumo di memoria maggiore.  Inoltre ci sono alcune
          idiosincrasie alle quali ci si deve abituare.
          Dopo un crash, lo stato del filesystem appare in qualche modo
          <quote>vecchio</quote>.  In situazioni dove l'approccio
          sincrono avrebbe causato la permanenza di alcuni file di lunghezza
          zero dopo un <command>fsck</command>, questi file non esistono affatto
          con un filesystem con Soft Updates, perch&eacute; n&eacute; i
          meta-dati n&eacute; i contenuti dei file sono mai stati scritti su
          disco.  Lo spazio su disco non viene rilasciato finch&eacute; gli
          aggiornamenti non sono stati scritti su disco, il che pu&ograve;
          avvenire qualche tempo dopo che &egrave; stato eseguito
          <command>rm</command>.  Questo potrebbe causare problemi durante
          l'installazione di grandi quantit&agrave; di dati su un filesystem
          che non avesse abbastanza spazio per contenere tutti i file due
          volte.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Messa a Punto dei Limiti del Kernel</title>

    <indexterm>
      <primary>messa a punto dei limiti del kernel</primary>
    </indexterm>

    <sect2 id="file-process-limits">
      <title>Limiti dei File/Processi</title>

      <sect3 id="kern-maxfiles">
        <title><varname>kern.maxfiles</varname></title>

        <indexterm>
          <primary><varname>kern.maxfiles</varname></primary>
        </indexterm>

        <para><varname>kern.maxfiles</varname> pu&ograve; essere aumentato o
          abbassato a seconda dei requisiti del tuo sistema.  Questa variabile
          indica il numero massimo di descrittori di file sul tuo sistema.
          Quando la tabella dei descrittori di file &egrave; piena,
          apparir&agrave; ripetutamente la scritta <errorname>file: table is
          full</errorname> nel buffer dei messaggi di sistema, che pu&ograve;
          essere visualizzato con il comando <command>dmesg</command>.</para>

        <para>Ogni file, socket, o fifo aperta usa un descrittore di file.
          Un server di produzione di larga scala pu&ograve; richiedere
          facilmente molte migliaia di descrittori di file, in relazione al tipo
          e al numero di servizi in esecuzione insieme.</para>

        <para>Il valore predefinito di <varname>kern.maxfile</varname> viene
          dettato dall'opzione <option>MAXUSERS</option> nel file di
          configurazione del kernel.  <varname>kern.maxfiles</varname> cresce
          proporzionalmente al valore di <option>MAXUSERS</option>.  Quando si
          compila un kernel personalizzato, &egrave; una buona idea impostare
          questa opzione di configurazione del kernel in base agli usi del
          proprio sistema.  Da questo numero, dipendono molti dei limiti
          predefiniti del kernel.  Anche se una macchina in produzione potrebbe
          non avere effettivamente 256 utenti connessi contemporaneamente, le
          risorse necessarie potrebbero essere simili a quelle di un server web
          su larga scala.</para>

        <note>
          <para>Da FreeBSD 4.5 in poi, l'impostazione di
            <option>MAXUSERS</option> a <literal>0</literal> nel file di
            configurazione del kernel fornir&agrave; un valore di default
            ragionevole basato sulla quantit&agrave; di RAM presente nel
            sistema.</para>
        </note>
      </sect3>
    </sect2>

    <sect2>
      <title>Limiti di Rete</title>

      <para>L'opzione di configurazione del kernel <option>NMBCLUSTERS</option>
        decide la quantit&agrave; di mbuf di rete disponibili al sistema.
        Un server molto trafficato con un numero basso di MBUF
        ostacolerebbe le possibilit&agrave; di FreeBSD.  Ogni cluster
        rappresenta approssimativamente 2K di memoria, dunque un valore di 1024
        rappresenta 2 megabyte di memoria del kernel riservata per i buffer di
        rete.  Pu&ograve; essere effettuato un semplice calcolo per capire
        quanti ne siano necessari.  Se hai un web server che arriva al massimo
        a 1000 connessioni simultanee, ed ogni connessione consuma un buffer di
        16K in ricezione e un'altro di 16K in trasmissione, avrai bisogno
        approssimativamente di 32MB di buffer di rete per coprire il web server.
        Una buona regola generale &egrave; di moltiplicare per 2, dunque
        2x32 MB / 2 KB = 64 MB / 2 KB = 32768.</para>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Aggiunta di Spazio di Swap</title>

    <para>Non importa quanto bene pianifichi tutto, a volte un sistema non
      funziona come ti aspetti.  Se ti trovi ad avere bisogno di maggiore spazio
      di swap, &egrave; abbastanza semplice aggiungerlo.  Ci sono tre modi per
      aumentare lo spazio di swap: aggiungere un nuovo disco rigido, abilitare
      lo swap su NFS, e creare un file di swap su una partizione
      esistente.</para>

    <sect2 id="new-drive-swap">
      <title>Swap su un Nuovo Disco Rigido</title>

      <para>Il modo migliore per aggiungere dello swap, ovviamente, &egrave;
        usare questa come scusa per aggiungere un altro disco rigido.  Puoi
        sempre aggiungere un nuovo disco, dopo tutto.  Se puoi fare cos&igrave;,
        vai a rileggere la discussione sullo <ulink
        url="configtuning-initial.html#SWAP-DESIGN">spazio di swap</ulink> dalla
        sezione sull'<ulink
        url="configtuning-initial.html">Installazione di FreeBSD</ulink> del
        Manuale per alcuni suggerimenti su come organizzare al meglio lo spazio
        di swap.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Swap su NFS</title>

      <para>Lo swap su NFS &egrave; consigliato solo se non hai un disco locale
        su cui realizzare lo swap.  Lo swap via NFS &egrave; lento ed
        inefficiente nelle versioni di FreeBSD precedenti alla 4.X.  Nella
        4.0-RELEASE e successive &egrave; ragionevolmente efficiente e veloce.
        Anche nelle versioni pi&ugrave; nuove di FreeBSD, comunque, lo swap via
        NFS &egrave; limitato dalla larghezza di banda disponibile sulla rete e
        aggiunge ulteriore lavoro per il server NFS.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>File di Swap</title>

      <para>Puoi creare un file delle dimensioni specifiche per usarlo come file
        di swap.  In questo nostro esempio useremo un file di 64MB chiamato
        <filename>/usr/swap0</filename>.  Puoi usare qualsiasi nome vuoi,
        ovviamente.</para>

      <example>
        <title>Creazione di un File di Swap</title>

        <orderedlist>
          <listitem>
            <para>Accertati che la tua configurazione del kernel includa
              il driver per i vnode.  <emphasis>Non</emphasis> c'&egrave;
              nelle versioni recenti del <filename>GENERIC</filename>.</para>

            <programlisting>pseudo-device   vn 1   #driver vnode (trasforma un file in un dispositivo)</programlisting>
          </listitem>

          <listitem>
            <para>crea un dispositivo vn:</para>

            <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
          </listitem>

          <listitem>
            <para>crea un file di swap (<filename>/usr/swap0</filename>):</para>

            <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
          </listitem>

          <listitem>
            <para>imposta i permessi appropriati
              (<filename>/usr/swap0</filename>):</para>

            <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
          </listitem>

          <listitem>
            <para>Abilita il file di swap in
              <filename>/etc/rc.conf</filename>:</para>

            <programlisting>swapfile="/usr/swap0"   # Imposta il nome del file di swap se si desidera un file di swap ausiliario.</programlisting>
          </listitem>

          <listitem>
            <para>Riavvia la macchina, o per abilitare il file di swap
              immediatamente digita:</para>

            <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
          </listitem>
        </orderedlist>
      </example>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
