<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.53
-->

<chapter id="boot">
  <title>La Procedura di Avvio di FreeBSD</title>

  <sect1 id="boot-synopsis">
    <title>Sinossi</title>

    <indexterm><primary>avvio</primary></indexterm>
    <indexterm><primary>avviamento</primary></indexterm>

    <para>Il processo di accensione di un computer e caricamento del sistema
      operativo viene detto <quote>processo di avviamento</quote>, o
      semplicemente <quote>avvio</quote>.  La procedura di avvio di FreeBSD
      fornisce un alto grado di flessibilit&agrave; nel personalizzare quello
      che succede all'avvio del sistema, permettendo di scegliere tra diversi
      sistemi operativi installati sullo stesso computer, o anche tra diverse
      versioni dello stesso sistema operativo o tra diversi
      kernel installati.</para>

    <para>Questo capitolo fornisce i dettagli sulle opzioni di configurazione
      che si possono impostare per personalizzare il processo di avvio di
      FreeBSD.  Ci&ograve; comprende tutto quello che avviene fino a quando il
      kernel viene lanciato, vengono controllate le periferiche, e viene avviato
      &man.init.8;.  Se non sei sicuro di sapere quando tutto questo accada, si
      tratta del momento in cui il colore del testo cambia da bianco brillante a
      grigio.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
        <para>Quali sono i componenti del sistema di avvio di FreeBSD, e come
          interagiscono.</para>
      </listitem>

      <listitem>
        <para>Le opzioni che puoi impostare per i componenti durante
          l'avviamento di FreeBSD per controllare il processo di avvio.</para>
      </listitem>
      
      <listitem>
        <para>Le basi dei &man.device.hints.5;.</para>
      </listitem>
    </itemizedlist>

    <note>
      <title>Solo per x86</title>

      <para>Questo capitolo descrive la procedura di avvio di FreeBSD su sistemi
        Intel x86.</para>
    </note>
  </sect1>

  <sect1 id="boot-introduction">
    <title>Il Problema dell'Avvio</title>

    <para>Accendere un computer e far partire il sistema operativo pone un
      dilemma interessante.  Per definizione, il computer non sa fare
      nulla finch&eacute; non viene avviato il sistema operativo.  Questo
      include l'esecuzione dei programmi dal disco.  Dunque se il computer non
      pu&ograve; eseguire un programma da disco senza il sistema operativo, ed i
      programmi del sistema operativo sono sul disco, come viene avviato il
      sistema operativo?</para>

    <para>Questo &egrave; un problema parallelo a quello che c'&egrave; nel
      libro <citetitle>Le Avventure del Barone di Munchausen</citetitle>.  Un
      personaggio era caduto in una botola, e ne era uscito tirandosi su da
      s&eacute; (in inglese <quote>bootstrap</quote>), riuscendo nell'intento
      solo con i propri sforzi.
      Nei primi giorni dell'informatica al meccanismo usato per caricare
      il sistema operativo fu applicato il termine
      <firstterm>bootstrap</firstterm>, ed in seguito venne abbreviato in
      <quote>booting</quote> (in italiano <quote>avvio</quote>).</para>

    <para>Su sistemi con hardware x86 il Basic Input/Output System (BIOS),
      &egrave; il responsabile del caricamento del sistema operativo. Per fare
      ci&ograve;, il BIOS cerca nel disco rigido il
      Master Boot Record (MBR), che deve essere in una specifica posizione
      sul disco.  Il BIOS ha abbastanza conoscenze per caricare ed eseguire
      l'MBR, ed assume che l'MBR possa portare avanti il resto dei compiti
      relativi al caricamento del sistema operativo.</para>

    <indexterm>
      <primary>BIOS</primary>
      <secondary>Basic Input/Output System</secondary>
    </indexterm>

    <para>Se c'&egrave; solo un sistema operativo installato sui tuoi dischi
      allora l'MBR standard sar&agrave; sufficiente.  Questo MBR cerca la prima
      partizione avviabile sul disco, e poi esegue quel codice per caricare il
      resto del sistema operativo.</para>

    <para>Se sono installati pi&ugrave; sistemi operativi sul disco allora
      si pu&ograve; installare un MBR diverso, che mostri una lista dei diversi
      sistemi operativi, e  permetta di scegliere quale avviare.  FreeBSD viene
      fornito con un MBR di questo tipo, ed altri fornitori di sistemi operativi
      forniscono MBR alternativi.</para>

    <para>Il resto del sistema di avvio di FreeBSD &egrave; diviso in tre stadi.
      Il primo stadio viene eseguito dall'MBR, che sa solo il necessario per
      mettere il computer in un certo stato ed eseguire il secondo.  Il
      secondo stadio pu&ograve; fare poco di pi&ugrave;, prima di eseguire il
      terzo.
      Il terzo stadio esaurisce il compito di caricare il sistema operativo.
      Il lavoro &egrave; diviso in queste tre parti perch&eacute; gli standard
      dei PC pongono dei limiti alla dimensione dei programmi che possono essere
      eseguiti nei primi due stadi.  Concatenare i compiti permette a FreeBSD di
      fornire un loader pi&ugrave; flessibile.</para>

    <indexterm><primary>kernel</primary></indexterm>
    <indexterm><primary><command>init</command></primary></indexterm>

    <para>A questo punto viene avviato il kernel ed esso comincia a verificare i
      dispositivi e ad inizializzarli.  Una volta che la procedura di avvio del
      kernel &egrave; finita,
      il kernel passa il controllo al processo utente &man.init.8;,
      che si assicura che i dischi siano in uno stato usabile.
      Poi &man.init.8; avvia la configurazione delle risorse a livello utente,
      monta i file system, imposta le schede di rete per comunicare via rete,
      ed in generale fa partire tutti i processi che generalmente sono in
      esecuzione su un sistema FreeBSD all'avvio.</para>
  </sect1>

  <sect1 id="boot-blocks">
    <title>L'MBR, e gli Stadi di Avvio Uno, Due, e Tre</title>

    <sect2 id="boot-boot0">
      <title>MBR, <filename>/boot/boot0</filename></title>

      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>L'MBR di FreeBSD &egrave; posizionato in
        <filename>/boot/boot0</filename>.
        Questa &egrave; una <emphasis>copia</emphasis> dell'MBR, perch&eacute;
        il vero MBR deve essere posizionato su una parte speciale del disco,
        fuori dell'area di FreeBSD.</para>

      <para><filename>boot0</filename> &egrave; molto semplice, poich&eacute; il
        programma nell'<abbrev>MBR</abbrev> pu&ograve; essere lungo solo 512
        byte.  Se avete installato l'MBR di FreeBSD ed avete vari sistemi
        operativi installati allora vedrete una schermata simile a questa al
        momento dell'accensione:</para>

      <example id="boot-boot0-example">
        <title>Screenshot di <filename>boot0</filename></title>

        <screen>F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</screen>
      </example>

      <para>Altri sistemi operativi, in particolare Windows&nbsp;95, sono noti
        per l'abitudine a sovrascrivere un MBR esistente con il proprio.
        Se accade questo, o si vuole rimpiazzare l'MBR pre-esistente con quello
        di FreeBSD va usato il seguente comando:</para>

      <screen>&prompt.root; <userinput>fdisk -B -b /boot/boot0 <replaceable>dispositivo</replaceable></userinput></screen>

      <para>Dove <replaceable>dispositivo</replaceable> &egrave; il dispositivo
        dal quale si avvia, come <devicename>ad0</devicename> per il primo disco
        IDE, <devicename>ad2</devicename> per il primo disco ide sul secondo
        canale, <devicename>da0</devicename> per il primo disco SCSI,
        e cos&igrave; via.</para>

      <para>Se sei un utente Linux, comunque, e preferisci che sia
        <application>LILO</application> a controllare il processo di boot,
        puoi modificare <filename>/etc/lilo.conf</filename> per avviare FreeBSD,
        o selezionare <option>Leave The Master Boot Record Untouched</option>
        durante il processo di installazione di FreeBSD.  Se hai installato il
        boot manager di FreeBSD, puoi ritornare a Linux e modificare il file di
        configurazione di <application>LILO</application>,
        <filename>/etc/lilo.conf</filename> aggiungendo la seguente
        opzione:</para>

      <programlisting>other=/dev/hdXY
table=/dev/hdb
loader=/boot/chain.b
label=FreeBSD</programlisting>

      <para>il che permetter&agrave; l'avvio di FreeBSD e Linux via
        <application>LILO</application>.  Nel nostro esempio, usiamo
        <replaceable>XY</replaceable> per determinare quale drive e
        quale partizione.  Se si sta usando un drive <acronym>SCSI</acronym>,
        si dovr&agrave; cambiare <replaceable>/dev/hdXY</replaceable> per
        leggere qualcosa di simile a <replaceable>/dev/sdXY</replaceable>, dove
        usiamo ancora la sintassi <replaceable>XY</replaceable>.
        L'opzione <option>loader=/boot/chain.b</option> pu&ograve; essere omessa
        se avete entrambi i sistemi operativi sullo stesso drive.
        Ora potete eseguire <command>/sbin/lilo -v</command>
        per fare effettuare i cambiamenti al sistema;
        ci&ograve; dovrebbe poter essere verificato grazie ad un messaggio su
        schermo.</para>
    </sect2>

    <sect2 id="boot-boot1">
      <title>Stadio Uno, <filename>/boot/boot1</filename>, e Stadio Due,
        <filename>/boot/boot2</filename></title>

      <para>Concettualmente il primo ed il secondo stadio sono parte dello
        stesso programma, sulla stessa area del disco.  Per limitazioni sullo
        spazio sono  stati divisi in due, ma li installerai sempre
        insieme.</para>

      <para>Essi si trovano sul settore di avvio della partizione di avvio,
        che &egrave; dove <link linkend="boot-boot0">boot0</link>, o ogni altro
        programma nell'<abbrev>MBR</abbrev> si aspetta di trovare il codice per
        proseguire la procedura di avvio.  I file nella cartella
        <filename>/boot</filename> sono copie dei file reali,
        che sono immagazzinati fuori dal file system di FreeBSD.</para>

      <para><filename>boot1</filename> &egrave; molto semplice, poich&eacute;
        pu&ograve; essere lungo solo 512 byte, e conosce solo lo stretto
        necessario del <firstterm>disklabel</firstterm> di FreeBSD, il quale
        memorizza le informazioni sulle slice, per trovare ed eseguire
        <filename>boot2</filename>.</para>

      <para><filename>boot2</filename> &egrave; leggermente pi&ugrave;
        sofisticato, e conosce il file system di FreeBSD abbastanza da potervi
        trovare dei file, e pu&ograve; fornire una semplice interfaccia per
        scegliere quale kernel o loader eseguire.</para>

      <para>Poich&eacute; il <link linkend="boot-loader">loader</link> &egrave;
        molto pi&ugrave; complesso, e fornisce una gradevole interfaccia di
        facile utilizzo alla configurazione di avvio, <filename>boot2</filename>
        in genere lo esegue, ma in precedenza era incaricato di lanciare il
        kernel direttamente.</para>

      <example id="boot-boot2-example">
        <title>Screenshot di <filename>boot2</filename></title>
        <screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/kernel
boot:</screen>
      </example>

      <para>Se mai avrai bisogno di rimpiazzare il
        <filename>boot1</filename> ed il <filename>boot2</filename> installati,
        usa &man.disklabel.8;.</para>

      <screen>&prompt.root; <userinput>disklabel -B <replaceable>discoslice</replaceable></userinput></screen>

      <para>Dove <replaceable>discoslice</replaceable> sono il disco e la slice
        dal quale avviare, come ad esempio <devicename>ad0s1</devicename> per la
        prima slice sul primo disco IDE.</para>

      <warning>
        <title>Modalit&agrave; Pericolosamente Dedicata</title>

        <para>Se si usa solo il nome del disco, come
          <devicename>ad0</devicename>, nel comando &man.disklabel.8; si
          creer&agrave; un disco pericolosamente dedicato, senza slice. Quasi
          sicuramente non &egrave; questo quello che si vorr&agrave; fare,
          quindi controlla due volte il comando &man.disklabel.8;
          prima di premere <keycap>Invio</keycap>.</para>
      </warning>
    </sect2>

    <sect2 id="boot-loader">
      <title>Stadio Tre, <filename>/boot/loader</filename></title>

      <indexterm><primary>boot-loader</primary></indexterm>

      <para>Il loader &egrave; l'ultimo stadio della procedura di avvio divisa
        in tre, e si trova sul file system, generalmente come
        <filename>/boot/loader</filename>.</para>

      <para>Il loader viene inteso come un metodo user-friendly per la
        configurazione, tramite l'uso di un insieme di comandi integrati facili
        da usare, che ha dietro un potente interprete con un insieme di
        comandi pi&ugrave; complesso.</para>

      <sect3 id="boot-loader-flow">
        <title>Sequenza di Operazioni del Loader</title>

        <para>Durante l'inizializzazione, il loader controller&agrave;
          la console e i dischi, e cercher&agrave; di capire da quale disco si
          stia avviando.  Imposter&agrave; le variabili di conseguenza, ed
          avvier&agrave; un interprete al quale potranno essere passati i
          comandi dell'utente in maniera interattiva o attraverso uno
          script.</para>

        <indexterm><primary>loader</primary></indexterm>
        <indexterm><primary>configurazione del loader</primary></indexterm>

        <para>Poi il loader legger&agrave;
          <filename>/boot/loader.rc</filename>, che in maniera predefinita legge
          <filename>/boot/defaults/loader.conf</filename> che imposta
          dei valori di default ragionevoli per le variabili e legge
          <filename>/boot/loader.conf</filename> per i cambiamenti locali a
          quelle variabili.  <filename>loader.rc</filename> poi agisce su queste
          variabili, caricando i moduli ed il kernel selezionati.</para>

        <para>Infine, di default, il loader attende 10 secondi la pressione
          di un tasto, ed avvia il kernel se non viene interrotto.
          Se invece viene interrotto, viene presentato all'utente
          un prompt in grado di comprendere un semplice insieme di comandi,
          dal quale l'utente pu&ograve; impostare precisamente le variabili,
          scaricare dalla memoria tutti i moduli, o caricarli, ed infine
          avviare o ri-avviare.</para>
      </sect3>

      <sect3 id="boot-loader-commands">
        <title>Comandi Integrati nel Loader</title>

        <para>Questi sono i comandi usati pi&ugrave; comunemente.  Per una
          discussione completa su tutti i comandi disponibili, guarda
          &man.loader.8;.</para>

        <variablelist>
          <varlistentry>
            <term>autoboot <replaceable>secondi</replaceable></term>

            <listitem>
              <para>Procede nell'avvio del kernel se non viene interrotto
                nell'intervallo di tempo specificato, in secondi.
                Mostra un conto alla rovescia, e l'intervallo predefinito
                &egrave; di 10 secondi.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>boot
              <optional><replaceable>-opzioni</replaceable></optional>
              <optional><replaceable>nomekernel</replaceable></optional></term>

            <listitem>
              <para>Procede immediatamente all'avvio del kernel, con le
                opzioni date, se ce ne sono, e con il kernel con il nome
                fornito, se esiste.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>boot-conf</term>

            <listitem>
              <para>Va avanti con gli stessi moduli della configurazione
                automatica, basati sulle variabili, come accade al boot.
                Questo ha senso solo se prima usate
                <command>unload</command>, e cambiate delle variabili,
                pi&ugrave; comunemente <envar>kernel</envar>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>help
              <optional><replaceable>argomento</replaceable></optional></term>

            <listitem>
              <para>Mostra un messaggio d'aiuto letto da
                <filename>/boot/loader.help</filename>.  Se l'argomento
                dato &egrave; <literal>index</literal>, allora elenca tutti
                gli argomenti disponibili.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>include <replaceable>nomefile</replaceable>
              &hellip;</term>

            <listitem>
              <para>Processa il file con il nome dato.  Il
                file viene letto, e interpretato riga per riga.
                Un errore blocca il comando include immediatamente.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>load <optional><option>-t</option>
              <replaceable>tipo</replaceable></optional>
              <replaceable>nomefile</replaceable></term>

            <listitem>
              <para>Carica il kernel, il modulo del kernel, o il file
                del tipo specificato, con il nome specificato.  Ogni argomento
                dopo nomefile viene passato al file.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>ls <optional><option>-l</option></optional>
              <optional><replaceable>percorso</replaceable></optional></term>

            <listitem>
              <para>Mostra un elenco dei file nel percorso dato, o
                nella directory root, se non ne viene specificato uno.
                Se &egrave; specificato <option>-l</option>, verranno mostrate
                anche le dimensioni dei file.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>lsdev <optional><option>-v</option></optional></term>

            <listitem>
              <para>Elenca tutti i dispositivi dai quali potrebbe essere
                possibile caricare moduli.  Se viene specificata l'opzione
                <option>-v</option>, verranno stampati dettagli maggiori.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>lsmod <optional><option>-v</option></optional></term>

            <listitem>
              <para>Mostra i moduli caricati. Se viene specificato
                <option>-v</option>, verranno stampati dettagli maggiori.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>more <replaceable>nomefile</replaceable></term>

            <listitem>
              <para>Mostra i file specificati, con una pausa ad ogni
                <varname>LINES</varname> visualizzato.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>reboot</term>

            <listitem>
              <para>Riavvia immediatamente il sistema.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>set <replaceable>variabile</replaceable></term>
            <term>set
              <replaceable>variabile</replaceable>=<replaceable>valore</replaceable></term>

            <listitem>
              <para>Imposta le variabili di ambiente del loader.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>unload</term>

            <listitem>
              <para>Rimuove tutti i moduli caricati.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect3>

      <sect3 id="boot-loader-examples">
        <title>Esempi sul Loader</title>

        <para>Qui ci sono alcuni esempi pratici sull'uso del loader:</para>

        <itemizedlist>
          <indexterm>
            <primary>modalit&agrave; singolo utente</primary>
          </indexterm>

          <listitem>
            <para>Per avviare semplicemente il vostro kernel abituale,
            ma in modalit&agrave; singolo utente:</para>

            <screen><userinput>boot -s</userinput></screen>
          </listitem>

          <listitem>
            <para>Per scaricare dalla memoria i moduli e il kernel normali,
              e poi caricare solo il vecchio (o un altro) kernel:</para>

            <indexterm>
              <primary><filename>kernel.old</filename></primary>
            </indexterm>

            <screen><userinput>unload</userinput>
<userinput>load <replaceable>kernel.old</replaceable></userinput></screen>

            <para>Si pu&ograve; usare <filename>kernel.GENERIC</filename> per
              riferirsi al kernel generico che viene fornito nel disco
              d'installazione, o <filename>kernel.old</filename> per riferirsi
              al kernel installato precedentemente (quando hai aggiornato
              o configurato il kernel, ad esempio).</para>

            <note>
              <para>Usa il comando seguente  per caricare i soliti moduli
                con un altro kernel:</para>

              <screen><userinput>unload</userinput>
<userinput>set kernel="<replaceable>kernel.old</replaceable>"</userinput>
<userinput>boot-conf</userinput></screen></note>
          </listitem>

          <listitem>
            <para>Per caricare uno script di configurazione del kernel
              (uno script automatizzato che faccia le cose
              che faresti tu normalmente configurando il kernel
              all'avvio):</para>

            <screen><userinput>load -t script_configurazione_utente <replaceable>/boot/kernel.conf</replaceable></userinput></screen>
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-kernel">
    <title>Interazione con il Kernel Durante l'Avvio</title>

    <indexterm>
      <primary>kernel</primary>
      <secondary>interazione all'avvio</secondary>
    </indexterm>

    <para>Una volta che il kernel &egrave; stato caricato dal <link
        linkend="boot-loader">loader</link> (come &egrave; normale) o da <link
        linkend="boot-boot1">boot2</link> (scavalcando il loader), esso
      esamina i suoi flag di avvio, se ce ne sono, e aggiusta il suo
      comportamento come necessario.</para>

    <sect2 id="boot-kernel-bootflags">
      <indexterm>
        <primary>kernel</primary>
        <secondary>flag di boot</secondary>
      </indexterm>

      <title>I Flag di Boot del Kernel</title>

      <para>Qui ci sono alcune dei pi&ugrave; comuni flag di boot:</para>

      <variablelist id="boot-kernel-bootflags-list">
        <varlistentry>
          <term><option>-a</option></term>

          <listitem>
            <para>durante l'inizializzazione del kernel, chiede il dispositivo
              da montare come file system di root.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-C</option></term>

          <listitem>
            <para>avvia da CDROM.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-c</option></term>

          <listitem>
            <para>esegue UserConfig, il programma di configurazione del kernel
              all'avvio</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-s</option></term>

          <listitem>
            <para>avvia in modalit&agrave; singolo utente</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-v</option></term>

          <listitem>
            <para>aumenta la verbosit&agrave; durante l'avvio del kernel</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>Ci sono altri flag di avvio, leggi &man.boot.8; per maggiori
          informazioni su di essi.</para></note>
    </sect2>
  </sect1>

  <sect1 id="device-hints">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>

          <surname>Rhodes</surname>

          <contrib>Contributo di </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>device.hints</primary>
    </indexterm>

    <title>Device Hints</title>

    <note>
      <para>Questa &egrave; una caratteristica di FreeBSD&nbsp;5.0 e successive
        che non esiste nelle versioni precedenti.</para>
    </note>

    <para>Durante l'avvio iniziale del sistema, il boot &man.loader.8;
      legger&agrave; il file &man.device.hints.5;.  Questo file contiene
      informazioni di avvio per il kernel dette variabili, e talvolta indicate
      come <quote>device hints</quote>, suggerimenti per i dispositivi.
      Questi <quote>device hints</quote> vengono usati dai driver per la
      configurazione delle varie periferiche.</para>

    <para>I device hints possono essere specificati anche nel prompt del terzo
      stadio <link linkend="boot-loader"> del boot loader</link>.
      Le variabili possono essere aggiunte usando il comando
      <command>set</command>, rimosse con <command>unset</command>, e
      visualizzate con <command>show</command>.  Possono essere scavalcate anche
      le variabili impostate nel file <filename>/boot/device.hints</filename>.
      I device hint inseriti in questo modo non sono permanenti e verranno
      dimenticati al riavvio seguente.</para>

    <para>Una volta che il sistema &egrave; stato avviato, pu&ograve; essere
      usato il comando &man.kenv.1; per mostrare tutte le variabili.</para>

    <para>La sintassi per il file <filename>/boot/device.hints</filename>
      &egrave; una variabile per riga,
      usando il solito cancelletto <quote>#</quote> per indicare i commenti.
      Le linee sono costruito come segue:</para>

    <screen><userinput>hint.driver.unit.keyword="<replaceable>valore</replaceable>"</userinput></screen>

    <para>La sintassi per il terzo stadio del boot loader &egrave;:</para>

    <screen><userinput>set hint.driver.unit.keyword=<replaceable>valore</replaceable></userinput></screen>

    <para><literal>driver</literal> &egrave; il nome del driver per il
      dispositivo, <literal>unit</literal> &egrave; il numero di unit&agrave;
      per quel driver, e <literal>keyword</literal> &egrave; la parola chiave
      per quell'hint.
      La parola chiave pu&ograve; consistere in una delle seguenti
      opzioni:</para>

    <itemizedlist>
      <listitem>
        <para><literal>at</literal>: specifica il bus sul quale &egrave;
          collegato il dispositivo.</para>
      </listitem>

      <listitem>
        <para><literal>port</literal>: specifica l'indirizzo iniziale di
          <acronym>I/O</acronym> che deve essere usato.</para>
      </listitem>

      <listitem>
        <para><literal>irq</literal>: specifica il numero di interrupt request
          che deve essere usato.</para>
      </listitem>

      <listitem>
        <para><literal>drq</literal>: specifica il numero del canale DMA.</para>
      </listitem>

      <listitem>
        <para><literal>maddr</literal>: specifica l'indirizzo di memoria fisico
          occupato dal dispositivo.</para>
      </listitem>

      <listitem>
        <para><literal>flags</literal>: imposta vari bit di flag per il
          dispositivo.</para>
      </listitem>

      <listitem>
        <para><literal>disabled</literal>: se impostato a <quote>1</quote> il
          dispositivo &egrave; disabilitato.</para>
      </listitem>
    </itemizedlist>

    <para>I driver possono accettare (o richiedere) pi&ugrave; hints di queli
      elencati qui, si raccomanda di verificare la loro pagina di manuale.
      Per maggiori informazioni, consulta le pagine di manuale
      &man.device.hints.5;, &man.kenv.1;, &man.loader.conf.5;, e
      &man.loader.8;.</para>
  </sect1>

  <sect1 id="boot-init">
    <indexterm><primary><command>init</command></primary></indexterm>

    <title>Init: Inizializzazione del Controllo dei Processi</title>

    <para>Una volta che il kernel ha finito di avviarsi, trasferisce il
      controllo al processo utente <command>init</command>, che si trova in
      <filename>/sbin/init</filename>, o al programma specificato
      nella variabile <envar>init_path</envar> nel
      <command>loader</command>.</para>

    <sect2 id="boot-autoreboot">
      <title>Sequenza di Riavvio Automatica</title>

      <para>La sequenza di riavvio automatica assicura
        che i file system disponibili sul sistema siano consistenti.
        Se qualcuno non lo &egrave;, e &man.fsck.8; non pu&ograve;
        risolvere le inconsistenze, &man.init.8; abbandona il sistema
        in <link linkend="boot-singleuser">modalit&agrave; singolo utente</link>
        per permettere all'amministratore di sistema di occuparsi dei
        problemi direttamente.</para>
    </sect2>

    <sect2 id="boot-singleuser">
      <title>Modalit&agrave; Singolo Utente</title>

      <indexterm><primary>modalit&agrave; singolo utente</primary></indexterm>
      <indexterm><primary>console</primary></indexterm>

      <para>Questa modalit&agrave; pu&ograve; essere raggiunta attraverso la
        <link linkend="boot-autoreboot">sequenza di riavvio automatica</link>,
        o tramite l'avvio da parte dell'utente con l'opzione
        <option>-s</option> o impostando la variabile <envar>boot_single</envar>
        nel <command>loader</command>.</para>

      <para>Si pu&ograve; arrivare ad essa anche richiamando
        &man.shutdown.8; con l'opzione per il riavvio
        (<option>-r</option>) o per l'arresto (<option>-h</option>),
        dalla <link linkend="boot-multiuser">modalit&agrave; multi
          utente</link>.</para>

      <para>Se la <literal>console</literal> del sistema &egrave; segnata come
        <literal>insecure</literal> in <filename>/etc/ttys</filename>,
        allora il sistema richiede la password di <username>root</username>
        prima di entrare in modalit&agrave; singolo utente.</para>

      <example id="boot-insecure-console">
        <title>Una Console Insicura in <filename>/etc/ttys</filename></title>

        <programlisting># name  getty                           type    status          comments
#
# Se la console &egrave; segnata come  "insecure", allora init chieder&agrave;
# la password di root per andare in modalit&agrave; singolo utente .
console none                            unknown off insecure</programlisting>
      </example>

      <note>
        <para>Avere una console <literal>insecure</literal> significa
          ritenere insicura la sicurezza fisica della console,
          ed assicurarsi che solo chi conosce la password di
          <username>root</username> possa usare la modalit&agrave; singolo
          utente, non significa voler eseguire la console in maniera insicura.
          Dunque, se vuoi avere sicurezza, scegli <literal>insecure</literal>,
          non <literal>secure</literal>.</para>
      </note>
    </sect2>

    <sect2 id="boot-multiuser">
      <title>Modalit&agrave; Multi Utente</title>

      <indexterm><primary>modalit&agrave; multi utente</primary></indexterm>

      <para>Se &man.init.8; ritiene che i file system siano in ordine,
        o quando l'utente ha terminato il lavoro in <link
          linkend="boot-singleuser">modalit&agrave; singolo utente</link>, il
        sistema entra in modalit&agrave; multi utente, nella quale inizia la
        configurazione delle risorse del sistema.</para>

      <sect3 id="boot-rc">
        <indexterm><primary>file rc</primary></indexterm>

        <title>Resource Configuration (rc)</title>

        <para>Il sistema di configurazione delle risorse legge i valori
          predefiniti della configurazione da
          <filename>/etc/defaults/rc.conf</filename>, e
          i dettagli specifici del sistema da
          <filename>/etc/rc.conf</filename>, e poi procede al montaggio dei
          file system del sistema elencati in
          <filename>/etc/fstab</filename>, avvia i servizi di rete,
          avvia vari demoni di sistema, ed infine esegue gli script di avvio dei
          pacchetti installati localmente.</para>

        <para>La pagina man di &man.rc.8; &egrave; un buon riferimento per la
          configurazione delle risorse del sistema, poich&eacute; esamina gli
          script stessi.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-shutdown">
    <title>Sequenza di Spegnimento</title>

    <indexterm><primary><command>spegnimento</command></primary></indexterm>

    <para>Al momento di uno spegnimento controllato, tramite
      &man.shutdown.8;, &man.init.8; cercher&agrave; di
      eseguire lo script <filename>/etc/rc.shutdown</filename>, e poi
      proceder&agrave; ad inviare a tutti i processi il segnale
      <literal>TERM</literal>, e successivamente il segnale
      <literal>KILL</literal> a quelli che non sono terminati in tempo.</para>

    <para>Per spegnere una macchina FreeBSD su architetture e sistemi
      che supportano sistemi di power management, usa semplicemente il comando
      <command>shutdown -p now</command> per disattivare immediatamente
      l'alimentazione.
      Per riavviare semplicemente un sistema FreeBSD system, usa solo
      <command>shutdown -r now</command>.  Avrai bisogno di essere
      <username>root</username> o un membro del gruppo
      <groupname>operator</groupname> per eseguire &man.shutdown.8;.
      Possono essere usati anche i comandi &man.halt.8; e &man.reboot.8;,
      fai riferimento alle loro pagine di manuale ed a quella di
      &man.shutdown.8; per maggiori informazioni.</para>

    <note>
      <para>La gestione dell'energia richiede il supporto &man.acpi.4; nel
        kernel o caricato come modulo in FreeBSD&nbsp;5.X e il supporto
        &man.apm.4; in FreeBSD&nbsp;4.X.</para>
    </note>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
