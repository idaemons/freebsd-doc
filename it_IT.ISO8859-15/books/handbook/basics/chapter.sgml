<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.95
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>

        <surname>Shumway</surname>

        <contrib>Riscritto da </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Basi di Unix</title>

  <sect1 id="basics-synopsis">
    <title>Sinossi</title>

    <indexterm><primary>basi</primary></indexterm>

    <para>Il seguente capitolo tratta i comandi e le funzionalit&agrave; di
      base del sistema operativo FreeBSD.  Molto di questo materiale &egrave;
      valido anche per altri sistemi operativi Unix-like.  Sentiti libero di
      leggere velocemente questo capitolo se hai familiarit&agrave; con questo
      materiale.  Se sei un utente alle prime armi di FreeBSD, allora dovrai di
      sicuro leggere questo capitolo attentamente.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
        <para>Come funzionano i permessi dei file Unix.</para>
      </listitem>

      <listitem>
        <para>Cosa sono le <acronym>ACL</acronym> del file system e come
          usarle.</para>
      </listitem>

      <listitem>
        <para>Cosa sono i processi, i demoni e i segnali.</para>
      </listitem>

      <listitem>
        <para>Cos'&egrave; una shell, e come cambiare il proprio ambiente di
          login di default.</para>
      </listitem>

      <listitem>
        <para>I principi di base sull'uso degli editor testuali.</para>
      </listitem>

      <listitem>
        <para>Come leggere le pagine man per ottenere maggiori
          informazioni.</para>
      </listitem>

      <listitem>
        <para>Come usare le <quote>console virtuali</quote> di FreeBSD.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="permissions">
    <title>I Permessi</title>

    <indexterm><primary>Unix</primary></indexterm>

    <para>FreeBSD, essendo un discendente diretto dello Unix BSD, si basa su
      molti concetti chiave di Unix.  Il primo, e il pi&ugrave; affermato,
      &egrave; che FreeBSD &egrave; un sistema operativo multi-utente.
      Il sistema pu&ograve; gestire diversi utenti che lavorano
      contemporaneamente su lavori indipendenti.  Il sistema &egrave;
      responsabile della gestione e della suddivisione appropiata delle
      richieste di utilizzo dei dispositivi hardware, delle periferiche, della
      memoria, e del tempo di CPU in modo equo per ogni utente.</para>

    <para>Poich&egrave; il sistema &egrave; in grado di supportare pi&ugrave;
      utenti, tutto ci&ograve; che il sistema gestisce possiede un'insieme di
      permessi che determinano chi pu&ograve; leggere, scrivere, ed eseguire la
      risorsa.  Questi permessi sono memorizzati mediante due ottetti
      suddivisi in tre parti, una per il proprietario del file, una per il
      gruppo al quale il file appartiene, e una per tutti gli altri.  Questa
      rappresentazione numerica funziona in questo modo:</para>

    <indexterm><primary>permessi</primary></indexterm>
    <indexterm><primary>permessi dei file</primary></indexterm>

    <informaltable frame="none">
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Valore</entry>

            <entry>Permessi</entry>

            <entry>Listato nella Directory</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>0</entry>

            <entry>Lettura no, scrittura no, esecuzione no</entry>

            <entry><literal>---</literal></entry>
          </row>

          <row>
            <entry>1</entry>

            <entry>Lettura no, scrittura no, esecuzione</entry>

            <entry><literal>--x</literal></entry>
          </row>

          <row>
            <entry>2</entry>

            <entry>Lettura no, scrittura, esecuzione no</entry>

            <entry><literal>-w-</literal></entry>
          </row>

          <row>
            <entry>3</entry>

            <entry>Lettura no, scrittura, esecuzione</entry>

            <entry><literal>-wx</literal></entry>
          </row>

          <row>
            <entry>4</entry>

            <entry>Lettura, scrittura no, esecuzione no</entry>

            <entry><literal>r--</literal></entry>
          </row>

          <row>
            <entry>5</entry>

            <entry>Lettura, scrittura no, esecuzione</entry>

            <entry><literal>r-x</literal></entry>
          </row>

          <row>
            <entry>6</entry>

            <entry>Lettura, scrittura, esecuzione no</entry>

            <entry><literal>rw-</literal></entry>
          </row>

          <row>
            <entry>7</entry>

            <entry>Lettura, scrittura, esecuzione</entry>

            <entry><literal>rwx</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary><command>ls</command></primary></indexterm>
    <indexterm><primary>directory</primary></indexterm>

    <para>Puoi usare l'opzione <option>-l</option> del comando &man.ls.1; per
      visualizzare un lungo listato della directory che include una colonna
      contenente le informazioni sui permessi del file per il proprietario, per
      il gruppo, e per gli altri.  Ecco come &egrave; composta la prima colonna
      di <command>ls -l</command>:</para>

    <screen>-rw-r--r--</screen>

    <para>Il primo carattere (partendo da sinistra) indica se il file in
      questione &egrave; un file regolare, una directory, un file speciale per
      dispositivi a caratteri, una socket, o un file speciali per altri
      dispositivi.  Nel nostro caso, il <literal>-</literal> indica un
      file regolare.  I tre caratteri successivi, che in questo esempio sono
      <literal>rw-</literal>, indicano i permessi per il proprietario del file.
      Seguono altri tre caratteri, <literal>r--</literal>, che indicano i
      permessi del gruppo al quale il file appartiene.  Gli ultimi tre
      caratteri, <literal>r--</literal>, indicano i permessi per il resto del
      mondo.  Un trattino significa che il permesso non viene concesso.
      Nel caso di questo file, i permessi sono settati affinch&egrave; il
      proprietario possa leggere e scrivere il file, il gruppo possa leggere
      il file, e il resto del mondo possa solamente leggere il file.  In accordo
      con la precedente tabella, i permessi per questo file sono
      <literal>644</literal>, dove ogni cifra rappresenta una delle tre parti
      che costituiscono i permessi del file.</para>

    <para>D'accordo, ma il sistema come controlla i permessi sui dispositivi?
      FreeBSD tratta molti dispositivi hardware esattamente come un file che i
      programmi possono aprire, leggere, e scrivere dei dati proprio come
      avviene con gli altri file.  Questi file speciali per i dispositivi sono
      memorizzati nella directory <filename>/dev</filename>.</para>

    <para>Anche le directory sono trattate come file.  Queste hanno permessi di
      lettura, scrittura e di esecuzione.  Il bit riferito al permesso di
      esecuzione per una directory ha un significato leggermente differente
      rispetto a quello dei file.  Quando una directory ha il permesso di
      esecuzione abilitato, significa che si ha accesso alla directory, ad
      esempio &egrave; possibile eseguire il comando <quote>cd</quote> per
      entrarci.  Inoltre questo significa che all'interno della directory
      &egrave; possibile accedere ai file dei quali si conosce il nome
      (naturalmente a condizione dei permessi degli stessi file).</para>

    <para>In particolare, per visualizzare il contenuto di una directory, deve
      essere abilitato il permesso di lettura sulla stessa, mentre per
      eliminare un file di cui si conosce il nome, &egrave; necessario che la
      directory contenente il file abbia i permessi di scrittura
      <emphasis>e</emphasis> di esecuzione abilitati.</para>

    <para>Ci sono altri bit per permessi particolari, ma sono in genere usati
      in circostanze speciali come il permesso di setuid per i binari e
      quello di sticky per le directory.  Se vuoi avere pi&ugrave; informazioni
      sui permessi dei file e su come settarli, guarda la pagina man di
      &man.chmod.1;.</para>
  </sect1>

  <sect1 id="fs-acl">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>

          <surname>Rhodes</surname>

          <contrib>Contributo di </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>ACL</primary></indexterm>

    <title>Liste di Controllo di Accesso del File System</title>

    <para>Oltre ai miglioramenti del file system contenuti nelle snapshot,
      FreeBSD 5.0 e successive offrono la sicurezza delle Liste di Controllo di
      Accesso del File System (<acronym>ACL</acronym>).</para>

    <para>Le Liste di Controllo di Accesso estendono il modello dei permessi
      standard di Unix con un alto grado di compatibilit&agrave; (POSIX.1e).
      Questa caratteristica permette ad un amministratore di usufruire di un
      modello si sicurezza pi&ugrave; sofisticato.</para>

    <para>Per abilitare il supporto delle <acronym>ACL</acronym> per il file
      system <acronym>UFS</acronym>, la riga:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>deve essere contenuta nel file del kernel al momento della sua
      compilazione.  Se il kernel non viene compilato con questa opzione,
      verr&agrave; visualizzato un messaggio di avvertimento quando si
      tenta di effettuare il mount di un file system che supporta le
      <acronym>ACL</acronym>.  Questa opzione &egrave; inclusa nel kernel
      <filename>GENERIC</filename>.  Le <acronym>ACL</acronym> si basano su
      attributi estesi che sono abilitati sul file system.  Questi attributi
      estesi saranno supportati in modo nativo dalla prossima generazione del
      file system Unix, chiamata <acronym>UFS2</acronym>.</para>

    <note>
      <para>Per configurare gli attributi estesi su <acronym>UFS1</acronym>
        &egrave; richiesto un grado di amministrazione globale superiore
        rispetto a quello richiesto per <acronym>UFS2</acronym>.  Inoltre le
        prestazioni degli attributi estesi su <acronym>UFS2</acronym> sono
        sostanzialmente superiori.  Come risultato, <acronym>UFS2</acronym>
        &egrave; in genere preferito a <acronym>UFS1</acronym> per l'utilizzo
        con le liste di controllo di accesso.</para>
    </note>

    <para>Le <acronym>ACL</acronym> sono abilitate in fase di mount tramite una
      flag amministrativa, <option>acl</option>, che pu&ograve; essere aggiunta
      in <filename>/etc/fstab</filename>.  Inoltre tale flag pu&ograve; essere
      settata in modo automatico e permanente usando &man.tunefs.8; per
      modificare il superblocco della flag relativa alle <acronym>ACL</acronym>
      nell'intestazione del file system.  Generalmente, &egrave; preferibile
      usare il superblocco della flag per molte ragioni:</para>

    <itemizedlist>
      <listitem>
        <para>La flag delle <acronym>ACL</acronym> attivata in fase di mount non
          pu&ograve; essere modificata da un remount (&man.mount.8;
          <option>-u</option>), ma solamente da un &man.umount.8; e da un nuovo
          &man.mount.8;.  Questo significa che le <acronym>ACL</acronym> non
          possono essere abilitate sul file system root dopo l'avvio del
          sistema.  Inoltre significa che non puoi modificare la disposizione
          di un file system una volta che &egrave; in uso.</para>
      </listitem>

      <listitem>
        <para>Settando il superblocco della flag si permette di montare il file
          system con le <acronym>ACL</acronym> abilitate anche se non c'&egrave;
          la specifica in <filename>fstab</filename> o se c'&egrave; un
          riordino dei dispositivi.  In questo modo si evita di montare
          accidentalmente file system senza le <acronym>ACL</acronym> abilitate,
          il che potrebbe provocare una forzatura impropria delle
          <acronym>ACL</acronym> e perci&ograve; potrebbe provocare dei
          problemi di sicurezza.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Si pu&ograve; modificare il comportamento delle
        <acronym>ACL</acronym> in modo tale che la flag possa essere abilitata
        senza effettuare un nuovo &man.mount.8;, ma si ritiene opportuno
        scoraggiare accidentali mount senza le <acronym>ACL</acronym>
        abilitate, poich&egrave; potresti seriamente sparati sui piedi se
        abiliti le <acronym>ACL</acronym>, quindi le disabiliti, e poi
        le riabiliti senza aver ripulito gli attributi estesi.  Generalmente,
        una volta che hai abilitato le <acronym>ACL</acronym> su un file system,
        queste non dovrebbero essere disabilitate, affinch&egrave; le
        protezioni sui file non siano compatibili con quelle volute dagli utenti
        sul sistema, e riabilitando le <acronym>ACL</acronym>, quelle precedenti
        potrebbero essere di nuovo attribuite a quei file i cui permessi sono
        stati modificati, avendo come risultato un comportamento
        imprevedibile.</para>
    </note>

    <para>I file system con le <acronym>ACL</acronym> abilitate mostreranno il
      segno <literal>+</literal> (pi&ugrave;) quando verranno visualizzati i
      loro permessi.  Per esempio:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>Vediamo che le directory <filename>directory1</filename>,
      <filename>directory2</filename>, e <filename>directory3</filename>
      fanno uso delle <acronym>ACL</acronym>.  La directory
      <filename>public_html</filename> no.</para>
  </sect1>

  <sect1 id="dirstructure">
    <title>Struttura delle Directory</title>

    <indexterm><primary>gerarchia delle directory</primary></indexterm>

    <para>La gerarchia delle directory di FreeBSD &egrave; fondamentale per
      ottenere una comprensione globale del sistema.  Il concetto pi&ugrave;
      importante da cogliere al volo &egrave; quello relativo alla directory
      root, <quote>/</quote>.  Questa directory &egrave; la prima ad essere
      montata all'avvio e contiene la base del sistema necessaria per
      predisporre il sistema operativo al funzionamento multi-utente.
      Inoltre la directory root contiene i punti di mount per gli altri file
      system che potresti voler montare.</para>

    <para>Un punto di mount &egrave; una directory dove dei file system
      aggiuntivi possono essere innestati sul file system root.  Alcuni punti di
      mount standard sono <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/mnt</filename>, e <filename>/cdrom</filename>.  Queste
      directory compaiono in genere negli elementi del file
      <filename>/etc/fstab</filename>.  Il file <filename>/etc/fstab</filename>
      &egrave; una tabella di file system e punti di mount che viene consultata
      dal sistema.  Molti dei file system riferiti nel file
      <filename>/etc/fstab</filename> sono montati in modo automatico all'avvio
      tramite lo script &man.rc.8; a meno che essi sia stati dichiarati con
      l'opzione <option>noauto</option>.  Consulta la pagina man di
      &man.fstab.5; per maggiori informazioni sul formato del file
      <filename>/etc/fstab</filename> e per le opzioni che pu&ograve;
      contenere.</para>

    <para>Una descrizione completa della gerarchia del file system &egrave;
      disponibile nella pagina man &man.hier.7;.  Per ora, &egrave;
      sufficiente una breve panoramica generale delle directory pi&ugrave;
      comuni.</para>

    <para>
      <informaltable frame="none">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Directory</entry>

              <entry>Descrizione</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><filename class="directory">/</filename></entry>

              <entry>Directory root del file system.</entry>
            </row>

            <row>
              <entry><filename class="directory">/bin/</filename></entry>

              <entry>Utilit&agrave; fondamentali per l'utente sia in ambiente
                mono-utente sia in ambiente multi-utente.</entry>
            </row>

            <row>
              <entry><filename class="directory">/boot/</filename></entry>

              <entry>Programmi e file di configurazione utilizzati durante la
                fase di avvio del sistema operativo.</entry>
            </row>

            <row>
              <entry><filename
                  class="directory">/boot/defaults/</filename></entry>

              <entry>File di configurazione di avvio di default; consultare
                &man.loader.conf.5;.</entry>
            </row>

            <row>
              <entry><filename class="directory">/dev/</filename></entry>

              <entry>Nodi di dispositivo; consultare &man.intro.4;.</entry>
            </row>

            <row>
              <entry><filename class="directory">/etc/</filename></entry>

              <entry>Script e file di configurazione del sistema.</entry>
            </row>

            <row>
              <entry><filename
                  class="directory">/etc/defaults/</filename></entry>

              <entry>File di configurazione di default del sistema; consultare
                &man.rc.8;.</entry>
            </row>

            <row>
              <entry><filename class="directory">/etc/mail/</filename></entry>

              <entry>File di configurazione per gli MTA (Mail Transfer Agent,
                agente di trasferimento della posta elettronica) come
                &man.sendmail.8;.</entry>
            </row>

            <row>
              <entry><filename class="directory">/etc/namedb/</filename></entry>

              <entry>File di configurazione di <command>named</command>;
                consultare &man.named.8;.</entry>
            </row>

            <row>
              <entry><filename
                  class="directory">/etc/periodic/</filename></entry>

              <entry>Script che sono eseguiti giornalmente, settimanalmente, e
                mensilmente tramite &man.cron.8;; consultare
                &man.periodic.8;.</entry>
            </row>

            <row>
              <entry><filename class="directory">/etc/ppp/</filename></entry>

              <entry>File di configurazione di <command>ppp</command>;
                consultare &man.ppp.8;.</entry>
            </row>

            <row>
              <entry><filename class="directory">/mnt/</filename></entry>

              <entry>Directory vuota usata comunemente dagli amministratori di
                sistema come punto di mount temporaneo.</entry>
            </row>

            <row>
              <entry><filename class="directory">/proc/</filename></entry>

              <entry>File system dedicato ai processi; consultare
                &man.procfs.5;, &man.mount.procfs.8;.</entry>
            </row>

            <row>
              <entry><filename class="directory">/root/</filename></entry>

              <entry>Directory home per l'account
                <username>root</username>.</entry>
            </row>

            <row>
              <entry><filename class="directory">/sbin/</filename></entry>

              <entry>Programmi di sistema e utilit&agrave; di amministrazione
                fondamentali sia in ambiente mono-utente sia in ambiente
                multi-utente.</entry>
            </row>

            <row>
              <entry><filename class="directory">/stand/</filename></entry>

              <entry>Programmi usati in un ambiente standalone.</entry>
            </row>

            <row>
              <entry><filename class="directory">/tmp/</filename></entry>

              <entry>File temporanei, di solito un file system basato sulla
                memoria come &man.mfs.8; (generalmente il contenuto di <filename
                  class="directory">/tmp</filename> non viene preservato dopo
                un reboot del sistema).</entry>
            </row>

            <row>
              <entry><filename class="directory">/usr/</filename></entry>

              <entry>La maggior parte delle applicazioni e delle utilit&agrave;
                dell'utente.</entry>
            </row>

            <row>
              <entry><filename class="directory">/usr/bin/</filename></entry>

              <entry>Utilit&agrave;, strumenti di programmazione, e
                applicazioni comuni.</entry>
            </row>

            <row>
              <entry><filename
                  class="directory">/usr/include/</filename></entry>

              <entry>File include standard del C.</entry>
            </row>

            <row>
              <entry><filename class="directory">/usr/lib/</filename></entry>

              <entry>Archivio di librerie.</entry>
            </row>

            <row>
              <entry><filename
                class="directory">/usr/libdata/</filename></entry>

              <entry>Archivio di dati per utilit&agrave; varie.</entry>
            </row>

            <row>
              <entry><filename
                  class="directory">/usr/libexec/</filename></entry>

              <entry>Demoni & utilit&agrave; di sistema (eseguiti da altri
                programmi).</entry>
            </row>

            <row>
              <entry><filename class="directory">/usr/local/</filename></entry>

              <entry>Eseguibili locali, librerie locali, ecc.  Usata anche
                come destinazione di default per la struttura dei port di
                FreeBSD.  All'interno di <filename>/usr/local</filename>, viene
                usato lo stesso schema generale descritto in &man.hier.7; per la
                directory <filename>/usr</filename>.  Le eccezioni sono la
                directory man, che &egrave; posta direttamente sotto
                <filename>/usr/local</filename> piuttosto che sotto
                <filename>/usr/local/share</filename>, e la documentazione dei
                port che &egrave; in
                <filename>share/doc/<replaceable>port</replaceable></filename>.
              </entry>
            </row>

            <row>
              <entry><filename class="directory">/usr/obj/</filename></entry>

              <entry>Albero degli elementi dipendenti dal tipo di architettura
                dell'elaboratore prodotto dalla costruzione dell'albero
                <filename>/usr/src</filename>.</entry>
            </row>

            <row>
              <entry><filename class="directory">/usr/ports</filename></entry>

              <entry>Collezione dei port di FreeBSD (opzionale).</entry>
            </row>

            <row>
              <entry><filename class="directory">/usr/sbin/</filename></entry>

              <entry>Demoni & utilit&agrave; di sistema (eseguiti dagli
                utenti).</entry>
            </row>

            <row>
              <entry><filename class="directory">/usr/share/</filename></entry>

              <entry>File indipendenti dal tipo di architettura
                dell'elaboratore.</entry>
            </row>

            <row>
              <entry><filename class="directory">/usr/src/</filename></entry>

              <entry>File sorgenti di BSD e/o sorgenti proprietari.</entry>
            </row>

            <row>
              <entry><filename class="directory">/usr/X11R6/</filename></entry>

              <entry>Eseguibili, librerie, ecc. riguardanti la distribuzione
                X11R6 (opzionale).</entry>
            </row>

            <row>
              <entry><filename class="directory">/var/</filename></entry>

              <entry>File log di vario genere, file temporanei, file transitori,
                e file di spool.</entry>
            </row>

            <row>
              <entry><filename class="directory">/var/log/</filename></entry>

              <entry>File di log del sistema di vario genere.</entry>
            </row>

            <row>
              <entry><filename class="directory">/var/mail/</filename></entry>

              <entry>File delle caselle di posta degli utenti.</entry>
            </row>

            <row>
              <entry><filename class="directory">/var/spool/</filename></entry>

              <entry>Directory di spool per stampanti e per la posta elettronica
                del sistema.</entry>
            </row>

            <row>
              <entry><filename class="directory">/var/tmp/</filename></entry>

              <entry>File temporanei che sono mantenuti tra i reboot del
                sistema.</entry>
            </row>

            <row>
              <entry><filename>/var/yp</filename></entry>

              <entry>Mappe NIS.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </para>
  </sect1>

  <sect1 id="mount-unmount">
    <title>Montaggio e Smontaggio dei File system</title>

    <para>Il file system &egrave; raffigurato in maniera ottimale da un albero,
      radicato, per cos&igrave; dire, in <filename>/</filename>.  Le directory
      <filename>/dev</filename>, <filename>/usr</filename>, e le altre
      directory che stanno all'interno della directory root sono i rami, i quali
      possono essere a loro volta ramificati, come in
      <filename>/usr/local</filename>, e cos&igrave; via.</para>

    <indexterm><primary>file system root</primary></indexterm>

    <para>Esistono varie ragioni per mantenere alcune di queste directory su
      file system separati.  La directory <filename>/var</filename> contiene
      le directory <filename>log/</filename>, <filename>spool/</filename>,
      e vari tipi di file temporanei, e come tale, pu&ograve; riempirsi.
      Riempire il file system root non &egrave; una buona idea, quindi scindere
      la directory <filename>/var</filename> da <filename>/</filename> &egrave;
      spesso vantaggioso.</para>

    <para>Un'altra motivazione per mantenere certi alberi di directory su altri
      file system &egrave; quando questi alberi sono allogiati su dischi fisici
      separati, o sono dischi virtuali separati, come avviene per i mount del
      <link linkend="nfs">Network File System</link>, o dei dispositivi
      CDROM.</para>

    <sect2 id="disks-fstab">
      <title>Il File <filename>fstab</filename></title>

      <indexterm>
        <primary>file system</primary>
        <secondary>montati con fstab</secondary>
      </indexterm>

      <para>Durante la <link linkend="boot">fase di avvio</link>, i file system
        elencati nel file <filename>/etc/fstab</filename> sono montati
        in modo automatico (a meno che siano specificati con l'opzione
        <option>noauto</option>).</para>

      <para>Il file <filename>/etc/fstab</filename> contiene una serie di righe
        il cui formato &egrave; il seguente:</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
        <varlistentry>
          <term><literal>device</literal></term>

          <listitem>
            <para>Il nome del dispositivo (che deve esistere), come spiegato
              nella <xref linkend="disks-naming">.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>mount-point</literal></term>

          <listitem>
            <para>La directory (che deve esistere), sulla quale montare il file
              system.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>fstype</literal></term>

          <listitem>
            <para>Il tipo di file system da passare a &man.mount.8;.  Il file
              system di default di FreeBSD &egrave;
              <literal>ufs</literal>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>options</literal></term>

          <listitem>
            <para><option>rw</option> per file system leggibili-scrivibili,
              oppure <option>ro</option> per file system solamente leggibili,
              seguite da altre opzioni che potrebbero essere necessarie.
              Un'opzione comune &egrave; <option>noauto</option> per i file
              system che normalmente non sono montati durante la sequenza di
              avvio.  Altre opzioni sono elencate nella pagina man di
              &man.mount.8;.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>dumpfreq</literal></term>

          <listitem>
            <para>Viene usato da &man.dump.8; per determinare quali file system
              richiede un dump.  Se non si specifica nulla, viene assunto il
              valore zero.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>passno</literal></term>

          <listitem>
            <para>Determina l'ordine secondo il quale i file system vengono
              controllati.  I file system che devono saltare il controllo devono
              avere i loro <literal>passno</literal> settati a zero.  Il file
              system root (che deve essere controllato prima di qualsiasi altra
              cosa) deve avere il suo <literal>passno</literal> settato a uno,
              e i <literal>passno</literal> degli altri file system devono
              essere settati a valori maggiori di uno.  Se pi&ugrave; di un
              file system ha lo stesso <literal>passno</literal> allora
              &man.fsck.8; tenter&agrave; di controllare i file system in
              parallelo.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title>Il Comando <command>mount</command></title>

      <indexterm>
        <primary>file system</primary>
        <secondary>montaggio</secondary>
      </indexterm>

      <para>Il comando &man.mount.8; &egrave; ci&ograve; che in definitiva viene
        usato per montare i file system.</para>

      <para>La sua forma di utilizzo elementare &egrave;:</para>

      <informalexample>
        <screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Esistono molte opzioni, come spiegato nella pagina man di
        &man.mount.8;, ma le pi&ugrave; comuni sono:</para>

      <variablelist>
        <title>Opzioni di Mount</title>

        <varlistentry>
          <term><option>-a</option></term>

          <listitem>
            <para>Monta tutti i file system elencati nel file
              <filename>/etc/fstab</filename>.  Le eccezioni sono quei file
              system specificati come <quote>noauto</quote>, quelli esclusi
              dalla flag <option>-t</option>, o quei file system che sono
              gi&agrave; montati.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-d</option></term>

          <listitem>
            <para>F&agrave; tutto ad eccezione della system call attuale.
              Questa opzione risulta utile in congiunzione con la flag
              <option>-v</option> per determinare quale &man.mount.8; si stia
              effettivamente tentando di realizzare.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-f</option></term>

          <listitem>
            <para>Forza il mount di un file system impuro (pericoloso), o forza
              la revoca di accesso in scrittura quando si declassa lo stato
              di mount di un file system da lettura-scrittura a lettura
              solamente.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-r</option></term>

          <listitem>
            <para>Monta il file system in sola lettura.  Questo &egrave;
              identico ad usare l'argomento <option>rdonly</option> con
              l'opzione <option>-o</option>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-t</option> <replaceable>fstype</replaceable></term>

          <listitem>
            <para>Monta il dato file system secondo il tipo di file system
              specificato, oppure, se affiancato dall'opzione
              <option>-a</option>, monta solamente i file system di un dato
              tipo.</para>

            <para><quote>ufs</quote> &egrave; il tipo di file system di
              default.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-u</option></term>

          <listitem>
            <para>Aggiorna le opzioni di mount sul file system.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-v</option></term>

          <listitem>
            <para>Modalit&agrave; verbose.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><option>-w</option></term>

          <listitem>
            <para>Monta il file system in lettura-scrittura.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>L'opzione <option>-o</option> accetta una lista di argomenti
        separati da una virgola, inclusi i seguenti:</para>

      <variablelist>
        <varlistentry>
          <term>nodev</term>

          <listitem>
            <para>Non sostiene dispositivi speciali sul file system.  Questa
              &egrave; un'utile opzione di sicurezza.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>noexec</term>

          <listitem>
            <para>Non permette l'esecuzioni di binari su questo file system.
              Questa &egrave; un'altra utile opzione di sicurezza.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>nosuid</term>

          <listitem>
            <para>Non permette l'interpretazione delle flag setuid o setgid sul
              file system. Anche questa &egrave; un'utile opzione di
              sicurezza.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>Il Comando <command>umount</command></title>

      <indexterm>
        <primary>file system</primary>
        <secondary>smontaggio</secondary>
      </indexterm>

      <para>Il comando &man.umount.8; accetta, come unico parametro, un punto di
        mount, un nome di dispositivo, l'opzione <option>-a</option> o l'opzione
        <option>-A</option>.</para>

      <para>Tutte queste modalit&agrave; accettano l'opzione <option>-f</option>
        per forzare la smontatura, e l'opzione <option>-v</option> per la
        modalit&agrave; verbose.  Sei avvisato che l'opzione <option>-f</option>
        non &egrave; in generale un buona idea.  Smontare in modo violento i
        file system pu&ograve; mandare in crash il computer o danneggiare i dati
        sul file system.</para>

      <para>Le opzioni <option>-a</option> e <option>-A</option> sono usate per
        smontare tutti i file system, con la possibilit&agrave; di specificare
        i tipi di file system elencandoli dopo la flag <option>-t</option>.
        Tuttavia, l'opzione <option>-A</option> non tenta di smontare il file
        system root.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>I Processi</title>

    <para>FreeBSD &egrave; un sistema operativo multi-tasking.  Con questa
      capacit&agrave; il sistema &egrave; come se potesse eseguire pi&ugrave; di
      un programma alla volta.  Ogni programma in esecuzione in un dato istante
      &egrave; chiamato <firstterm>processo</firstterm>.  Ogni volta che esegui
      un comando fai partire almeno un nuovo processo, e ci sono molti processi
      di sistema che sono sempre in esecuzione, che permettono il corretto
      funzionamento del sistema.</para>

    <para>Ogni processo &egrave; identificato in modo univoco da un numero
      chiamato <firstterm>process ID</firstterm>, o <firstterm>PID</firstterm>,
      e, come avviene per i file, ogni processo ha un proprietario e un gruppo.
      Le informazioni sul proprietario e sul gruppo sono usate per determinare,
      tramite il meccanismo dei permessi dei file discusso precedentemente,
      quali file e quali dispositivi il processo pu&ograve; aprire.  Inoltre
      molti processi hanno un processo padre.  Tale processo &egrave; il
      processo che li ha generati.  Per esempio, se stai digitando dei comandi
      in shell allora la shell &egrave; un processo, cos&igrave; come lo sono i
      comandi che esegui. Ogni processo che esegui in questo modo avr&agrave;
      come suo processo padre la tua shell.  L'eccezione a questo meccanismo
      &egrave; un processo speciale chiamato <command>init</command>.  Il
      processo <command>init</command> &egrave; sempre il primo processo, quindi
      il suo PID &egrave; sempre 1.  <command>init</command> viene avviato
      in modo automatico dal kernel quando si avvia FreeBSD.</para>

    <para>Due comandi sono particolarmente utili per monitorare i processi sul
      sistema, &man.ps.1; e &man.top.1;.  Il comando &man.ps.1; &egrave; usato
      per mostrare una lista statica dei processi che sono in esecuzione in quel
      momento, e pu&ograve; mostrare i loro PID, quanta memoria stanno usando,
      la linea di comando che li ha avviati, e altro ancora.  Il comando
      &man.top.1; visualizza tutti i processi in esecuzione, e aggiorna queste
      informazioni ogni qualche secondo, in modo che puoi vedere
      interattivamente cosa sta facendo il tuo computer.</para>

    <para>Di default, &man.ps.1; mostra solo i tuoi comandi che sono in quel
      mmomento in esecuzione.  Per esempio:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Come puoi vedere in questo esempio, l'output di &man.ps.1; &egrave;
      organizzato in molte colonne.  La colonna <literal>PID</literal> si
      riferisce al process ID discusso poco f&agrave;.  I PID sono assegnati
      partendo dal numero 1, andando fino al 99999,  e ricominciando dall'inizio
      una volta esauriti (se disponibili).  La colonna <literal>TT</literal>
      mostra su quale tty il programma &egrave; in esecuzione, e pu&ograve;
      essere benissimo ignorata per il momento.  La colonna
      <literal>STAT</literal> mostra lo stato del programma, e di nuovo,
      pu&ograve; essere benissimo ignorata.  La colonna <literal>TIME</literal>
      indica per quanto tempo il programma &egrave; stato in esecuzione sulla
      CPU&mdash;non indica per forza il tempo trascorso da quando hai avviato
      il programma, poich&egrave; i programmi trascorrono molto tempo in attesa
      per faccende che accadono prima che questi possano trascorrere del tempo
      in CPU.  Infine, la colonna <literal>COMMAND</literal> indica la riga di
      comando che &egrave; stata utilizzata per eseguire il programma.</para>

    <para>Il comando &man.ps.1; supporta varie opzioni per cambiare le
      informazioni da visualizzare.  Uno dei gruppi di opzioni pi&ugrave; utili
      &egrave; <literal>auxww</literal>.  L'opzione <option>a</option> mostra le
      informazioni riguardo a tutti i processi in esecuzione, non solo quelli
      che ti appartengono.  L'opzione <option>u</option> mostra il nome utente
      del proprietario del processo, come pure la memoria utilizzata dal
      processo.  L'opzione <option>x</option> mostra le informazioni riguardo ai
      processi demoni, e l'opzione <option>ww</option> indica a &man.ps.1; di
      visualizzare la linea di comando completa che ha avviato il processo,
      piuttosto che troncarla quando &egrave; troppo lunga per essere adattata
      sullo schermo.</para>

    <para>L'output di &man.top.1; &egrave; simile.  Un esempio di esecuzione
      assomiglia a questo:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>L'output &egrave; diviso in due sezioni.  La parte superiore (le prime
      cinque linee) mostra il PID dell'ultimo processo eseguito, il carico medio
      del sistema (che &egrave; un indice di come il sistema sia impegnato), il
      tempo di vita del sistema (il tempo passato dall'ultimo reboot) e l'ora
      corrente.  I restanti numeri nella parte superiore riportano quanti
      processi sono in esecuzione (47 in questo caso), quanta memoria di sistema
      e quanta memoria di swap &egrave; stata utilizzata, e quanto tempo il
      sistema sta trascorrendo nei vari stati di CPU.</para>

    <para>Sotto ci sono una serie di colonne che contengono simili informazioni
      a quelle contenute nell'output di &man.ps.1;.  Come prima puoi vedere il
      PID, il nome utente, quanto tempo di CPU &egrave; stato utilizzato, e il
      comando che era stato eseguito.  Inoltre il comando &man.top.1; di default
      ti mostra quanta memoria &egrave; stata concessa al processo.  Questa
      informazione &egrave; suddivisa in due colonne, una per la dimensione
      totale, e l'altra per la dimensione attuale&mdash;la dimensione totale
      &egrave; la quantit&agrave; di memoria che l'applicazione ha richiesto, e
      la dimensione attuale &egrave; la quantit&agrave; di memoria che sta
      utilizzando in quel momento.  In questo esempio puoi vedere che
      <application>Netscape</application> ha richiesto quasi 30&nbsp;MB di RAM,
      ma al momento ne sta usando solo 9&nbsp;MB.</para>

    <para>Il comando &man.top.1; aggiorna in modo automatico queste informazioni
      ogni due secondi; questo lasso temporale pu&ograve; essere modificato con
      l'opzione <option>s</option>.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>I Demoni, i Segnali, e come Uccidere i Processi</title>

    <para>Quando esegui un'editor risulta semplice averne il controllo, dirgli
      di caricare file, e cos&igrave; via.  Tutto questo pu&ograve; essere fatto
      poich&egrave; l'editor fornisce delle agevolazioni in questo senso, e
      anche perch&egrave; l'editor &egrave; collegato a un
      <firstterm>terminale</firstterm>.  Alcuni programmi non sono stati
      progettati per essere eseguiti con un continuo input dell'utente, e
      perci&ograve; questi programmi si sconnettono dal terminale alla prima
      occasione.  Per esempio, un server web trascorre tutto il giorno
      rispondendo a richieste web, e normalmente non necessita di alcun input
      da parte tua.  I programmi che trasportano la posta elettronica da un sito
      a un'altro sito sono un'altro esempio di questa classe di
      applicazioni.</para>

    <para>Chiamiamo questi programmi <firstterm>demoni</firstterm>.  I demoni
      erano dei personaggi della mitologia greca; n&egrave; buoni n&egrave;
      cattivi, erano piccoli custodi degli spiriti che, nel complesso,
      risultavano essere utili per l'umanit&agrave;.  Molto similmente i server
      web e quelli di posta elettronica di oggi fanno cose utili.  Ecco il
      motivo per cui la mascot di BSD &egrave; stata per molto tempo, e lo
      &egrave; ancora, l'allegro demone con le scarpe da tennis e con il
      forcone.</para>

    <para>Esiste la convenzione di chiamare i programmi che normalmente sono
      eseguiti come demoni con una <quote>d</quote> finale.
      <application>BIND</application> sta per Berkeley Internet Name Daemon
      (e il nome effettivo del programma che viene eseguito &egrave;
      <command>named</command>), il nome del programma
      <application>Apache</application>, un server web, &egrave;
      <command>httpd</command>, il demone dello spool di stampa &egrave;
      <command>lpd</command> e cos&igrave; via.  Questa &egrave; una
      convenzione, non &egrave; una regola ferrea; per esempio, il principale
      demone di posta elettronica per l'applicazione
      <application>Sendmail</application> &egrave; chiamato
      <command>sendmail</command>, e non <command>maild</command>, come potresti
      aspettarti.</para>

    <para>A volte puoi aver bisogno di comunicare con un processo demone.
      Queste comunicazioni sono chiamate <firstterm>segnali</firstterm>, e puoi
      comunicare con i demoni (o con altri processi in esecuzione) mandandogli
      un segnale.  Esistono svariati segnali che puoi inviare&mdash;alcuni di
      questi hanno un significato specifico, altri sono interpretabili
      dall'applicazione, e la documentazione dell'applicazione ti dir&agrave;
      come l'applicazione stessa interpreta i segnali.  Puoi mandare un segnale
      solo ai processi che ti appartengono.  Se mandi un segnale a un processo
      che non ti appartiene con il comando &man.kill.1; o &man.kill.2; il
      permesso ti sar&agrave; negato.  L'eccezione a questa regola riguarda
      l'utente <username>root</username>, che pu&ograve; mandare segnali a
      processi di chiunque.</para>

    <para>Inoltre in alcune circostanze FreeBSD invia segnali alle
      applicazioni.  Se un'applicazione &egrave; stata scritta malamente, e
      tenta di accedere alla memoria che non gli compete, FreeBSD manda al
      processo il segnale di <firstterm>Violazione della
        Segmentazione</firstterm> (<literal>SIGSEGV</literal>).  Se
      un'applicazione ha utilizzato la system call &man.alarm.3; in modo tale
      da essere avvisata dopo un certo periodo di tempo trascorso allora
      FreeBSD invier&agrave; a questa applicazione il segnale di Allarme
      (<literal>SIGALRM</literal>), e cos&igrave; via.</para>

    <para>Per fermare un processo possono essere utilizzati due segnali,
      <literal>SIGTERM</literal> e <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> &egrave; la modalit&agrave; cortese di
      terminare un processo; il processo pu&ograve;
      <emphasis>catturare</emphasis> il segnale, capire che vuoi abbatterlo,
      chiudere i file di log che potrebbe avere aperto, e in genere terminare
      qualunque cosa che stava facendo prima dell'interruzione.  Nei casi in cui
      un processo sia coinvolto in qualche compito che non pu&ograve; essere
      interrotto allora questo processo pu&ograve; persino ignorare
      <literal>SIGTERM</literal>.</para>

    <para>Il segnale <literal>SIGKILL</literal> non pu&ograve; essere ignorato
      da un processo.  Questo &egrave; il segnale che dice <quote>Non mi
      interessa cosa stai facendo, fermati subito</quote>.  Se mandi il segnale
      <literal>SIGKILL</literal> a un processo allora FreeBSD fermer&agrave;
      subito il processo<footnote>
        <para>Non &egrave; del tutto vero&mdash;ci sono alcune cose che non
          possono essere interrotte.  Per esempio, se il processo sta tentando
          di leggere un file situato su un'altro computer in rete, e questo
          computer non &egrave; disponibile per qualche ragione (&egrave; stato
          spento, o la rete ha qualche problema), allora il processo &egrave;
          detto <quote>non interrompibile</quote>.  Il processo finir&agrave;
          in time out, generalmente dopo due minuti.  Non appena avviene il
          time out il processo potr&agrave; essere terminato.</para>
      </footnote>.
    </para>

    <para>Altri segnali che potresti aver bisogno di usare sono
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, e
      <literal>SIGUSR2</literal>.  Questi sono segnali a scopo generico, e
      differenti applicazioni possono fare cose diverse quando catturano questi
      segnali.</para>

    <para>Supponiamo che hai cambiato il file di configurazione del tuo server
      web&mdash;hai bisogno di dire al server web di rileggere la sua
      configurazione.  Potresti fermare e riavviare <command>httpd</command>, ma
      questo porterebbe a un breve periodo di interruzione del tuo server
      web, che potrebbe non essere gradito.  Molti demoni sono stati scritti per
      rispondere al segnale <literal>SIGHUP</literal> tramite la rilettura
      dei loro file di configurazione.  In questo modo invece di terminare e
      riavviare <command>httpd</command> potresti inviare il segnale
      <literal>SIGHUP</literal>.  Poich&egrave; non esiste un modo standard di
      trattare questi segnali, differenti demoni potrebbero avere un
      comportamento diverso, quindi assicurati di leggere la documentazione per
      il demone in questione.</para>

    <para>I segnali sono inviati utilizzando il comando &man.kill.1;, come
      mostra questo esempio.</para>

    <procedure>
      <title>Inviare un Segnale a un Processo</title>

      <para>Questo esempio mostra come inviare un segnale a &man.inetd.8;.  Il
        file di configurazione di &man.inetd.8; &egrave;
        <filename>/etc/inetd.conf</filename>, e &man.inetd.8; rilegge questo
        file di configurazione quando riceve il segnale
        <literal>SIGHUP</literal>.</para>

      <step>
        <para>Cerca il process ID del processo a cui vuoi mandare il segnale.
          Puoi utilizzare &man.ps.1; e &man.grep.1; per farlo.  Il comando
          &man.grep.1; viene utilizzato per perlustrare attraverso l'output,
          cercando la stringa da te specificata.  Questo comando viene eseguito
          in modalit&agrave; utente, e &man.inetd.8; viene eseguito in
          modalit&agrave; <username>root</username>, quindi le opzioni da dare
          a &man.ps.1; sono <option>ax</option>.</para>

        <screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

        <para>Come puoi vedere il PID di &man.inetd.8; &egrave; 198.  In alcuni
          casi potrebbe apparire nel risultato anche il comando
          <literal>grep inetd</literal>.  Questo dipende dal modo utilizzato
          da &man.ps.1; nell'elencare la lista dei processi in
          esecuzione.</para>
      </step>

      <step>
        <para>Usa il comando &man.kill.1; per inviare il segnale.  Poich&egrave;
          &man.inetd.8; viene eseguito in modalit&agrave;
          <username>root</username> prima devi usare il comando &man.su.1; per
          diventare <username>root</username>.</para>

        <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

        <para>Come avviene per la maggior parte dei comandi Unix, il comando
          &man.kill.1; non stampa il risultato dell'operazione se questa ha
          avuto successo.  Se mandi un segnale a un processo del quale non sei
          il proprietario allora vedrai il messaggio <errorname>kill:
            <replaceable>PID</replaceable>: Operazione non permessa</errorname>.
          Se sbagli il PID invierai il segnale al processo sbagliato, il che
          potrebbe essere dannoso, o, se hai fortuna, manderai il segnale
          a un PID che in quel momento non &egrave; in uso, e in questo caso
          vedrai il messaggio <errorname>kill: <replaceable>PID</replaceable>:
            Nessun processo</errorname>.</para>

        <note>
          <title>Perch&egrave; Usare <command>/bin/kill</command>?</title>

          <para>Molte shell forniscono il comando <command>kill</command> come
            comando built-in; ossia, la shell invia il segnale in modo
            diretto, senza dover eseguire <filename>/bin/kill</filename>.  Tutto
            ci&ograve; pu&ograve; essere molto utile, ma le diverse shell hanno
            una sintassi diversa per specificare il nome del segnale da inviare.
            Invece di cercare di imparare tutte queste sintassi, pu&ograve;
            essere pi&ugrave; semplice usare direttamente il comando
            <command>/bin/kill <replaceable>...</replaceable></command>.</para>
        </note>
      </step>
    </procedure>

    <para>L'invio di altri segnali &egrave; analogo, basta sostituire
      all'occorrenza <literal>TERM</literal> o <literal>KILL</literal> nella
      linea di comando.</para>

    <important>
      <para>Terminare processi in modo random su un sistema pu&ograve; essere
        una cattiva idea.  In particolare, il processo &man.init.8;, con process
        ID 1, &egrave; un caso molto speciale.  Eseguire <command>/bin/kill -s
          KILL 1</command> &egrave; un modo veloce per arrestare il tuo sistema.
        Controlla <emphasis>Sempre</emphasis> due volte gli argomenti quando
        esegui &man.kill.1; <emphasis>prima</emphasis> di premere
        <keycap>Invio</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Le Shell</title>

    <indexterm><primary>shell</primary></indexterm>
    <indexterm><primary>riga di comando</primary></indexterm>

    <para>In FreeBSD, la maggior parte del lavoro di tutti i giorni viene svolto
      tramite un'interfaccia a riga di comando chiamata shell.  Uno dei compiti
      principali di una shell &egrave; quello di prendere in input dei comandi
      ed eseguirli.  Inoltre molte shell hanno delle funzioni built-in
      (incorporate) utili nei lavori ordinari come la gestione dei file, la
      sostituzione dei nomi dei file, la modifica della riga di comando, la
      creazione di macro di comandi, e la gestione delle variabili d'ambiente.
      FreeBSD si propone con una serie di shell, come la Shell Bourne,
      <command>sh</command>, e la versione successiva della C-shell,
      <command>tcsh</command>.  Molte altre shell sono disponibili nella FreeBSD
      Ports Collection, come le shell <command>zsh</command> e
      <command>bash</command>.</para>

    <para>Quale shell devi usare?  &Egrave; veramente una questione di gusti.
      Se sei un programmatore di C potresti sentirti a tuo agio con una shell
      C-like come la <command>tcsh</command>.  Se vieni da Linux o non sei
      pratico dell'interfaccia a riga di comando di Unix potresti provare la
      <command>bash</command>.  Il fatto &egrave; che ogni shell ha delle
      caratteristiche che possono o meno combaciare con il tuo ambiente di
      lavoro preferito, e quindi devi scegliere tu stesso quale shell
      utilizzare.</para>

    <para>Una caratteristica comune in una shell &egrave; il completamento dei
      nomi dei file.  Dopo aver digitato alcuni dei primi caratteri di un
      comando o di un nome di file, la shell di solito pu&ograve; completare
      in modo automatico il resto del comando o del nome del file tramite la
      pressione del tasto <keycap>Tab</keycap> sulla tastiera.  Ecco un'esempio.
      Supponiamo che hai due file chiamati <filename>foobar</filename> e
      <filename>foo.bar</filename>.  Vuoi cancellare
      <filename>foo.bar</filename>.  Quello che dovresti digitare sulla tastiera
      &egrave;:
      <command>rm
        fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>La shell dovrebbe visualizzare <command>rm
      foo[BEEP].bar</command>.</para>

    <para>Il [BEEP] &egrave; la campanella della console, che mi segnala che la
      shell &egrave; incapace di completare interamente il nome del file
      poich&egrave; esiste pi&ugrave; di una sola corrispondenza.  Sia
      <filename>foobar</filename> che <filename>foo.bar</filename> iniziano con
      <literal>fo</literal>, tuttavia la shell &egrave; riuscita a completarlo
      in <literal>foo</literal>.  A questo punto premendo <literal>.</literal>,
      e poi di nuovo <keycap>Tab</keycap>, la shell sar&agrave; in grado di
      completare da sola il resto del nome del file.</para>

    <indexterm><primary>variabili d'ambiente</primary></indexterm>

    <para>Un'altro aspetto di una shell &egrave; l'uso delle variabili
      d'ambiente.  Le variabili d'ambiente sono una coppia di valori mutevoli
      memorizzati nello spazio dell'ambiente della shell.  Questo spazio
      pu&ograve; essere letto dai programmi invocati dalla shell, e di
      conseguenza questo spazio pu&ograve; contenere le configurazioni di molti
      programmi.  Qui sotto c'&egrave; una lista delle variabili d'ambiente
      pi&ugrave; comuni con il loro rispettivo significato:</para>

    <indexterm><primary>variabili d'ambiente</primary></indexterm>

    <informaltable frame="none">
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Variabile</entry>

            <entry>Descrizione</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><envar>USER</envar></entry>

            <entry>Il nome dell'utente attualmente loggato.</entry>
          </row>

          <row>
            <entry><envar>PATH</envar></entry>

            <entry>Lista di directory separate da due punti utilizzate per
              la ricerca dei binari.</entry>
          </row>

          <row>
            <entry><envar>DISPLAY</envar></entry>

            <entry>Nome di rete del display X11 a cui connettersi, se
              disponibile.</entry>
          </row>

          <row>
            <entry><envar>SHELL</envar></entry>

            <entry>La shell corrente.</entry>
          </row>

          <row>
            <entry><envar>TERM</envar></entry>

            <entry>Il nome del terminale dell'utente.  Usato per determinare
              le capacit&agrave; del terminale.</entry>
          </row>

          <row>
            <entry><envar>TERMCAP</envar></entry>

            <entry>Serie di elementi di codici di escape del terminale
              utilizzati per realizzare svariate funzioni del terminale.</entry>
          </row>

          <row>
            <entry><envar>OSTYPE</envar></entry>

            <entry>Il tipo di sistema operativo. FreeBSD, ad esempio.</entry>
          </row>

          <row>
            <entry><envar>MACHTYPE</envar></entry>

            <entry>L'architettura della CPU su cui il sistema gira.</entry>
          </row>

          <row>
            <entry><envar>EDITOR</envar></entry>

            <entry>L'editor di testo preferito dall'utente.</entry>
          </row>

          <row>
            <entry><envar>PAGER</envar></entry>

            <entry>L'impaginatore di testo preferito dall'utente.</entry>
          </row>

          <row>
            <entry><envar>MANPATH</envar></entry>

            <entry>Lista di directory separate da due punti utilizzate nella
              ricerca delle pagine man.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>shell Bourne</primary></indexterm>

    <para>Il modo di settare una variabile d'ambiente varia leggermente a
      seconda della shell utilizzata.  Per esempio, nelle shell C-Style come
      <command>tcsh</command> e <command>csh</command>, puoi usare
      <command>setenv</command> per settare le variabili d'ambiente.  Sotto le
      shell Bourne come <command>sh</command> e <command>bash</command>, puoi
      usare <command>export</command> per settare le tue variabili d'ambiente
      correnti.  Per esempio, per settare o modificare la variabile d'ambiente
      <envar>EDITOR</envar> a <filename>/usr/local/bin/emacs</filename>, sotto
      <command>csh</command> o <command>tcsh</command> si pu&ograve; utilizzare
      il comando:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Sotto le shell Bourne:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Con la maggior parte delle shell puoi inoltre creare un'espansione
      di una variabile d'ambiente mettendo sulla riga di comando il simbolo
      <literal>$</literal> davanti al nome della variabile stessa.  Per esempio,
      <command>echo $TERM</command> visualizzer&agrave; ci&ograve; che
      corrisponde a <envar>$TERM</envar>, poich&egrave; la shell espande
      <envar>$TERM</envar> e passa il risultato a
      <command>echo</command>.</para>

    <para>Le shell trattano molti caratteri speciali, chiamati meta-caratteri
      come rappresentazioni speciali di dati.  Il pi&ugrave; comune di questi
      &egrave; il simbolo <literal>*</literal>, che rappresenta diverse
      istanze di caratteri in un nome di file.  Questi meta-caratteri possono
      essere usati per la sostituzione dei nomi di file.  Per esempio, digitando
      <command>echo *</command> &egrave; quasi come aver digitato
      <command>ls</command> poich&egrave; la shell prende tutti i file che
      corrispondono a <literal>*</literal> e li mette sulla riga di comando
      con <command>echo</command> che quindi li visualizza.</para>

    <para>Per impedire alla shell di interpretare questi caratteri speciali,
      questi possono essere messi in escape mettendo subito prima di essi un
      backslash (<literal>\</literal>).  <command>echo $TERM</command>
      visualizza il tipo del tuo terminale. <command>echo \$TERM</command>
      visualizza <envar>$TERM</envar> cos&igrave; com'&egrave;.</para>

    <sect2 id="changing-shells">
      <title>Cambiare la Propria Shell</title>

      <para>Il modo pi&ugrave; semplice per cambiare la propria shell &egrave;
        quello di usare il comando <command>chsh</command>.  Eseguendo
        <command>chsh</command> verr&agrave; invocato l'editor definito nella
        tua variabile d'ambiente <envar>EDITOR</envar>; nel caso in cui questa
        non sia stata settata, verr&agrave; invocato <command>vi</command>.
        Modifica la riga <quote>Shell:</quote> in base alle tue esigenze.</para>

      <para>Puoi anche eseguire <command>chsh</command> con l'opzione
        <option>-s</option>; in questo modo verr&agrave; settata la shell in
        modo diretto, senza che sia necessario invocare l'editor.  Per
        esempio, se vuoi cambiare la tua shell in <command>bash</command>,
        potresti digitare il seguente comando:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Comunque eseguendo <command>chsh</command> con nessun parametro e
        modificando la shell all'interno dell'editor funzioner&agrave; lo
        stesso.</para>

      <note>
        <para>La shell che desideri utilizzare <emphasis>deve</emphasis> essere
          presente nel file <filename>/etc/shells</filename>.  Se hai installato
          una shell dalla <link linkend="ports">collezione dei port</link>,
          allora la nuova shell dovrebbe essere gi&agrave; stata inserita nel
          suddetto file in modo automatico.  Se installi una shell manualmente,
          questo lavoro lo devi fare tu.</para>

      <para>Per esempio, se installi <command>bash</command> a mano e la
        metti sotto <filename>/usr/local/bin</filename>, dovresti fare
        questo:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Dopo averlo fatto riavvia <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Editor di Testo</title>

    <indexterm><primary>editor di testo</primary></indexterm>
    <indexterm><primary>editor</primary></indexterm>

    <para>La maggior parte del lavoro di configurazione in FreeBSD viene fatto
      tramite la modifica di file di testo.  Perci&ograve;, &egrave; una buona
      idea familiarizzare con un'editor di testo.  FreeBSD si presenta con
      alcuni editor come parte base del sistema, e molti altri sono disponibili
      nella collezione dei port.</para>

    <indexterm><primary><command>ee</command></primary></indexterm>

    <para>L'editor pi&ugrave; semplice e pi&ugrave; facile da imparare si chiama
      <application>ee</application>, che sta per easy editor.  Per avviare
      <application>ee</application>, puoi digitare sulla riga di comando
      <command>ee filename</command> dove <literal>filename</literal> &egrave;
      il nome del file che deve essere modificato.  Per esempio, per modificare
      <filename>/etc/rc.conf</filename>, devi digitare <command>ee
        /etc/rc.conf</command>.  Una volta all'interno di <command>ee</command>,
      tutti i comandi per azionare le funzioni dell'editor sono elencati nella
      parte superiore del video.   Il carattere <literal>^</literal> &egrave; il
      tasto <keycap>Ctrl</keycap> della tastiera, quindi <literal>^e</literal>
      espande la combinazioni di tasti <keycombo
        action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>.
      Per uscire da <application>ee</application>, premi il tasto
      <keycap>Esc</keycap>, quindi conferma l'uscita dall'editor.  Se il file
      ha subito delle modifiche ti verr&agrave; chiesto se le vuoi
      salvare.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editor</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editor</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>

    <para>FreeBSD ha come parte base del sistema anche editor di testo
      pi&ugrave; potenti come <command>vi</command>, mentre altri editor, come
      <command>emacs</command> e <command>vim</command>, sono inclusi nella
      FreeBSD Ports Collection.  Questi editor offrono molte pi&ugrave;
      funzionalit&agrave; e molta pi&ugrave; potenza a costo di essere un poco
      pi&ugrave; complicati da imparare ad utilizzare.  Comunque se intendi
      utilizzare in modo intensivo un editor, imparando ad utilizzare un editor
      potente come <command>vim</command> o <command>emacs</command>
      risparmierai a lungo andare un sacco di tempo.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Dispositivi e Nodi di Dispositivo</title>

    <para>Il termine dispositivo viene usato prevalentemente per specificare le
      unit&agrave; hardware all'interno di un sistema, come i dischi, le
      stampanti, le schede grafiche, e le tastiere.  Durante la fase di avvio di
      FreeBSD, la maggior parte delle cose che vengono visualizzate da FreeBSD
      riguardano i dispositivi che sono stati rilevati.  Puoi riesaminare
      questi messaggi di avvio guardando il file
      <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Per esempio, <devicename>acd0</devicename> &egrave; il primo drive
      CDROM IDE, mentre <devicename>kbd0</devicename> rappresenta la
      tastiera.</para>

    <para>In un sistema operativo Unix la maggior parte di questi dispositivi
      sono accessibili tramite dei file speciali chiamati nodi di dispositivo,
      i quali sono posti nella directory <filename>/dev</filename>.</para>

    <sect2>
      <title>Creare i Nodi di Dispositivo</title>

      <para>Quando aggiungi un nuovo dispositivo al tuo sistema, o ricompili il
        kernel per supportare dispositivi aggiuntivi, hai bisogno di creare per
        questi nuovi dispositivi uno o pi&ugrave; nodi di dispositivo.</para>

      <sect3>
        <title>Script MAKEDEV</title>

        <para>Sui sistemi senza il <literal>DEVFS</literal> (tutte le versioni
          di FreeBSD antecedenti la 5.0), i nodi di dispositivo sono creati
          usando lo script &man.MAKEDEV.8; come mostrato qui sotto:</para>

        <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV ad1</userinput></screen>

        <para>Questo esempio creer&agrave; gli opportuni nodi di dispositivo
          per il secondo drive IDE.</para>
      </sect3>

      <sect3>
        <title><literal>DEVFS</literal> (DEVice File System)</title>

        <para>Il file system device, o <literal>DEVFS</literal>, fornisce la
          disponibilit&agrave; dello spazio dei nomi dei dispositivi del kernel
          allo spazio dei nomi globale del file system.  Invece di dover creare
          o modificare i nodi di dispositivo, <literal>DEVFS</literal> mantiene
          in modo automatico questo particolare file system.</para>

        <para>Guarda la pagina man di &man.devfs.5; per maggiori
          informazioni.</para>

        <para><literal>DEVFS</literal> viene usato di default su
          FreeBSD&nbsp;5.0.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="consoles">
    <title>Console Virtuali &amp; terminali</title>

    <indexterm><primary>console virtuali</primary></indexterm>
    <indexterm><primary>terminale</primary></indexterm>

    <para>FreeBSD pu&ograve; essere usato in vari modi.  Uno di questi &egrave;
      quello di digitare i comandi tramite un terminale testuale.  Quando si
      utilizza FreeBSD in questo modo si ha velocemente nelle proprie mani molta
      della flessibilit&agrave; e della potenza di un sistema operativo &unix;.
      Questa sezione descrive cosa sono i <quote>terminali</quote> e le
      <quote>console</quote>, e come si possono utilizzare in FreeBSD.</para>

    <sect2 id="consoles-intro">
      <title>La console</title>

      <indexterm><primary>console</primary></indexterm>

      <para>Se non hai configurato FreeBSD in modo tale da avviare in modo
        automatico l'ambiente grafico durante l'avvio, il sistema ti
        fornir&agrave; un prompt di login dopo la fase di avvio, esattamente
        dopo che gli script di avvio sono stati eseguiti.  Dovresti vedere
        qualcosa simile a questo:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>I messaggi potrebbero essere leggermente diversi sul tuo sistema,
        tuttavia dovresti vedere qualcosa di analogo.  In questo momento ci
        interessano le ultime due righe.  Analizziamo la penultima riga:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Questa riga contiene alcune informazioni sul sistema che hai appena
        avviato.  Sei di fronte a una console <quote>FreeBSD</quote>, che sta
        girando su un processore Intel o su un processore compatibile con
        l'architettura x86<footnote>
          <para>Questo &egrave; il significato di <literal>i386</literal>.
            Nota che anche se non stai eseguendo FreeBSD su una CPU della serie
            386 di Intel, questo messaggio resta <literal>i386</literal>.  Non
            si riferisce al tipo del tuo processore, ma bens&igrave;
            all'<quote>architettura</quote> del processore.</para></footnote>.
        Il nome di questa macchina (tutte le macchine &unix; hanno un nome)
        &egrave; <hostid>pc3.example.org</hostid>, e in questo momento sei di
        fronte alla sua console di sistema&mdash;il terminale
        <devicename>ttyv0</devicename>.</para>

      <para>Infine, l'ultima riga &egrave; sempre:</para>

      <programlisting>login:</programlisting>

      <para>Qui devi digitare il tuo <quote>username</quote> per loggarti in
        FreeBSD.  La prossima sezione descrive come fare ad effettuare il login
        su FreeBSD.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Loggarsi in FreeBSD</title>

      <para>FreeBSD &egrave; un sistema multi-utente e multi-processo.  Questa
        &egrave; la descrizione formale che viene usualmente attribuita a un
        sistema che pu&ograve; essere usato da diverse persone, le quali
        eseguono contemporaneamente molti programmi su una singola
        macchina.</para>

      <para>Ogni sistema multi-utente necessita di qualche metodo che distingua
        un <quote>utente</quote> in modo univoco.  In FreeBSD (e in tutti i
        sistemi operativi &unix;-like), questo viene realizzato richiedendo che
        ogni utente debba <quote>loggarsi</quote> nel sistema prima che possa
        eseguire qualche programma.  Ogni utente ha un nome univoco (lo
        <quote>username</quote>) e uno personale, e una chiave segreta (la
        <quote>password</quote>).  FreeBSD richiede entrambe queste due cose
        prima di dare la possibilit&agrave; ad un utente di eseguire qualche
        programma.</para>

      <indexterm><primary>script di avvio</primary></indexterm>

      <para>Giusto dopo la fase di avvio di FreeBSD e quando gli script di avvio
        sono stati eseguiti<footnote>
          <para>Gli script di avvio sono programmi che vengono eseguiti in modo
            automatico durante la fase di avvio di FreeBSD.  Il loro compito
            principale &egrave; quello di settare delle cose che potranno essere
            utilizzate da qualsiasi altra cosa venga eseguita, ed avviare i
            servizi che potresti avere configurato in modo tale da essere
            eseguiti in background per realizzare cose utili.</para>
        </footnote>, ti viene presentato un prompt dove inserire un valido
        username:</para>

      <screen>login:</screen>

      <para>Giusto per questo esempio, assumiamo che il tuo username sia
        <username>john</username>.  Al prompt digita <literal>john</literal> e
        premi <keycap>Invio</keycap>.  Ti verr&agrave; presentato un prompt
        dove inserire la <quote>password</quote>:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Digita la password di <username>john</username>, e premi
        <keycap>Invio</keycap>.  La password <emphasis>non viene
          visualizzata!</emphasis>  Non ti devi preoccupare di questo per ora.
        &Egrave; sufficiente sapere che &egrave; una questione di
        sicurezza.</para>

      <para>Se hai digitato la tua password in modo corretto, dovresti essere
        loggato in FreeBSD e sei quindi pronto per provare tutti i comandi
        disponibili.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Console multiple</title>

      <para>Eseguire comandi &unix; in una sola console va bene, tuttavia
        FreeBSD pu&ograve; eseguire pi&ugrave; programmi alla volta.  Avere una
        sola console dove poter digitare i comandi pu&ograve; essere un
        p&ograve; uno spreco quando un sistema operativo come FreeBSD &egrave;
        in grado di eseguire dozzine di programmi contemporaneamente.  &Egrave;
        in questo caso che le <quote>console virtuali</quote> possono essere
        molto utili.</para>

      <para>FreeBSD pu&ograve; essere configurato in modo tale da poter
        utilizzare differenti console virtuali.  Puoi passare da una console
        virtuale ad un'altra digitando un paio di tasti sulla tastiera.  Ogni
        console ha il proprio canale di output indipendente, e FreeBSD si
        occupa di redirigere correttamente l'input della tastiera e l'output del
        monitor quando passi da una console virtuale in un'altra.</para>

      <para>In FreeBSD alcune combinazioni speciali di tasti sono state
        riservate per il passaggio tra le console<footnote>
          <para>Una descrizione abbastanza tecnica ed accurata di tutti i
            dettagli della console di FreeBSD e dei driver della tastiera
            pu&ograve; essere trovata nelle pagine man di &man.syscons.4;,
            &man.atkbd.4;, &man.vidcontrol.1; e &man.kbdcontrol.1;.  Qui non
            approfondiremo i dettagli, ma il lettore interessato pu&ograve;
            sempre consultare le pagine man per una spiegazione dettagliata
            e completa su come funzionano queste cose.</para>
        </footnote>.  Puoi usare
        <keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
        <keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>, fino a
        <keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo> per
        cambiare console su FreeBSD.</para>

      <para>Quando passi da una console ad un'altra, FreeBSD si preoccupa di
        salvare e ripristinare l'output a video.  Il risultato &egrave;
        l'<quote>illusione</quote> di avere pi&ugrave; schermi e pi&ugrave;
        tastiere <quote>virtuali</quote> che puoi utilizzare per dare in pasto a
        FreeBSD dei comandi.  I programmi che lanci su una console virtuale
        rimarranno in esecuzione anche quando la console non &egrave; visibile.
        L'esecuzione di questi programmi continua quando passi in un'altra
        console virtuale.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title>Il file <filename>/etc/ttys</filename></title>

      <para>La configurazione di default di FreeBSD prevede l'avvio del sistema
        con 8 console virtuali.  Comunque questo non &egrave; un settaggio
        obbligatorio, e puoi facilmente personalizzare la tua installazione in
        modo tale da avviare il sistema con qualche console virtuale in
        pi&ugrave;.  Il numero e i settaggi delle console virtuali sono
        configurati nel file <filename>/etc/ttys</filename>.</para>

      <para>Puoi usare il file <filename>/etc/ttys</filename> per configurare
        le console virtuali di FreeBSD.  In questo file ogni riga non commentata
        (le righe che non iniziano con il carattere <literal>#</literal>)
        contiene il settaggio di un singolo terminale o di una singola console
        virtuale.  La versione di default di questo file contenuta in FreeBSD
        configura 9 console virtuale, e ne abilita 8 di queste.  Si tratta delle
        righe che iniziano con <literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Terminali virtuali
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Per una descrizione pi&ugrave; dettagliata su ogni colonna di questo
        file e per tutte le opzioni che puoi utilizzare per settare le console
        virtuali, consulta la pagina man &man.ttys.5;.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Console in modalit&agrave; single user</title>

      <para>Una descrizione dettagliata del significato della
        <quote>modalit&agrave; single user</quote> pu&ograve; essere trovata
        nella <xref linkend="boot-singleuser">.  &Egrave; bene notare che
        c'&egrave; un'unica console quando avvii FreeBSD in modalit&agrave;
        single user.  Le console virtuali non sono disponibili.  Anche i
        settaggi della console in modalit&agrave; single user possono essere
        trovati nel file <filename>/etc/ttys</filename>.  Guarda la riga che
        inizia con <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# Se la console &egrave; definita "insecure", allora il processo init richieder&agrave; la password di root
# quando entrerai in modalit&agrave; single-user.
console none                            unknown off secure</programlisting>

      <note>
        <para>Come riportato nel commento sopra la riga
          <literal>console</literal>, puoi modificare questa riga cambiando
          <literal>secure</literal> in <literal>insecure</literal>.  Se lo fai,
          quando FreeBSD viene avviato in modalit&agrave; single user,
          verr&agrave; chiesta la password di <username>root</username>.</para>

        <para><emphasis>Pensaci comunque due volte a settare il parametro
          <literal>insecure</literal>.</emphasis>  Se non ricordi pi&ugrave;
          la password di <username>root</username>, riuscire ad avviare il
          sistema in modalit&agrave; single user sar&agrave; molto complesso.
          &Egrave; ancora possibile, ma potrebbe essere molto difficile per chi
          non conosce molto bene il meccanismo di avvio di FreeBSD e i relativi
          programmi.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Per Maggiori Informazioni</title>

    <sect2 id="basics-man">
      <title>Le Pagine Man</title>

      <indexterm><primary>pagine man</primary></indexterm>

      <para>La documentazione pi&ugrave; esauriente su FreeBSD &egrave;
        costituita dalle pagine man. Quasi tutti i programmi sul sistema hanno
        un piccolo manuale di riferimento che spiega il funzionamento di base e
        i vari argomenti del programma stesso. Questi manuali possono essere
        visualizzati con il comando <command>man</command>.  L'uso del comando
        <command>man</command> &egrave; semplice:</para>

      <screen>&prompt.user; <userinput>man <replaceable>command</replaceable></userinput></screen>

      <para><literal>command</literal> &egrave; il nome del comando di cui
        desideri maggiori informazioni.  Per esempio, per sapere di pi&ugrave;
        circa il comando <command>ls</command> digita:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Il manuale in linea &egrave; diviso in sezione numerate:</para>

      <orderedlist>
        <listitem>
          <para>Comandi utente.</para>
        </listitem>

        <listitem>
          <para>System call e codici di errore.</para>
        </listitem>

        <listitem>
          <para>Funzioni della libreria C.</para>
        </listitem>

        <listitem>
          <para>Driver dei dispositivi.</para>
        </listitem>

        <listitem>
          <para>Formati di file.</para>
        </listitem>

        <listitem>
          <para>Giochi e altri passatempo.</para>
        </listitem>

        <listitem>
          <para>Informazioni varie.</para>
        </listitem>

        <listitem>
          <para>Comandi di mantenimento e di funzionamento del sistema.</para>
        </listitem>

        <listitem>
          <para>Sviluppo del kernel.</para>
        </listitem>
      </orderedlist>

      <para>In qualche caso, lo stesso soggetto pu&ograve; apparire in
        pi&ugrave; di una sezione del manuale in linea.  Per esempio, esiste
        un comando utente <command>chmod</command> e una system call
        <function>chmod()</function>.  In questo caso, puoi dire al comando
        <command>man</command> quale vuoi specificando la sezione:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>In questo caso verr&agrave; visualizzata la pagina man del comando
        utente <command>chmod</command>.  I riferimenti di una sezione
        particolare del manuale in linea sono tradizionalmente posti tra
        parentesi all'interno della documentazione, quindi &man.chmod.1; fa
        riferimento al comando utente <command>chmod</command> e &man.chmod.2;
        fa riferimento alla system call.</para>

      <para>Tutto questo va bene se conosci il nome del comando e desideri
        semplicemente sapere come usarlo, ma cosa succede se non ricordi il nome
        del comando?  Puoi usare <command>man</command> con l'opzione
        <option>-k</option> per ricercare tramite parole chiavi nelle
        descrizioni dei comandi:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Con questo comando ti verr&agrave; presentata una lista di comandi
        che hanno la parola chiave <quote>mail</quote> nella loro descrizione.
        Di fatto questo meccanismo funziona proprio come il comando
        <command>apropos</command>.</para>

      <para>Stai dando un'occhiata a tutti quei comandi fantastici che si
        trovano in <filename>/usr/bin</filename> ma non hai la pi&ugrave;
        pallida idea di cosa fanno la maggior parte di essi?  Semplicemente
        digita:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>oppure</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

      <para>che &egrave; la stessa cosa.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>I File Info di GNU</title>

      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>FreeBSD include molte applicazioni e utility prodotti dalla Free
        Software Foundation (FSF).  Oltre alle pagine man, questi programmi
        hanno dei pi&ugrave; ampi documenti in ipertesto chiamati file
        <literal>info</literal> che possono essere visualizzati con il comando
        <command>info</command>, o se hai installato
        <application>emacs</application>, con la modalit&agrave; info di
        <application>emacs</application>.</para>

      <para>Per usare il comando &man.info.1;, digita semplicemente:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Per una breve introduzione, digita <literal>h</literal>.  Per un
        rapido riferimento dei comandi, digita <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
