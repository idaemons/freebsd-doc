<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.22
-->

<chapter id="basics">
  <title>Basi di Unix</title>

  <sect1>
    <title>Sinossi</title>

    <para><emphasis>Revisione di Chris Shumway
      <email>cshumway@cdrom.com</email>, 10 Mar 2000.</emphasis></para>

    <para>Nel seguente capitolo vengono  esaminati i comandi e le
      funzionalit&agrave; di base del sistema operativo FreeBSD.  Se
      non si &egrave; mai utilizzato FreeBSD prima d'ora, si consiglia
      di leggere attentamente questo capitolo prima di provare a
      cercare aiuto altrove.</para>
  </sect1>

  <sect1 id="permissions">
    <title>I Permessi</title>

    <para>FreeBSD ha radici storiche nell'UNIX BSD e deriva
      perci&ograve; gran parte delle sue caratteristiche fondamentali da
      diversi concetti chiave di UNIX.  La prima, e forse la
      pi&ugrave; rinomata, &egrave; che FreeBSD &egrave; un sistema
      operativo multi-utente.
      Il sistema pu&ograve; gestire svariati utenti, tutti
      impegnati simultaneamente in compiti non necessariamente
      correlati fra loro.  Esso &egrave; responsabile della gestione e
      della suddivisione appropriata delle richieste di utilizzo dei
      dispositivi hardware, delle periferiche, della memoria, e della
      CPU in modo equo tra tutti gli utenti.</para>

    <para>Dato che il sistema &egrave; in grado di supportare
      pi&ugrave; utenti, qualsiasi cosa esso gestisce &egrave;
      provvista di un insieme di permessi che regolano chi vi
      pu&ograve; accedere in lettura, scrittura ed esecuzione.
      Tali permessi vengono memorizzati mediante un ottetto
      suddiviso in tre parti, una per il proprietario del file, una
      per il gruppo al quale il file appartiene, e una per chiunque
      altro vi voglia accedere. Questa rappresentazione numerica dei
      permessi funziona in questo modo:</para>

    <informaltable frame="none">
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Valore</entry>

            <entry>Permesso</entry>

            <entry>Elenco Directory</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>0</entry>

            <entry>Lettura no, scrittura no, esecuzione no</entry>

            <entry><literal>---</literal></entry>
          </row>

          <row>
            <entry>1</entry>

            <entry>Lettura no, scrittura no, esecuzione</entry>

            <entry><literal>--x</literal></entry>
          </row>

          <row>
            <entry>2</entry>

            <entry>Lettura no, scrittura, esecuzione no</entry>

            <entry><literal>-w-</literal></entry>
          </row>

          <row>
            <entry>3</entry>

            <entry>Lettura no, scrittura, esecuzione</entry>

            <entry><literal>-wx</literal></entry>
          </row>

          <row>
            <entry>4</entry>

            <entry>Lettura, scrittura no, esecuzione no</entry>

            <entry><literal>r--</literal></entry>
          </row>

          <row>
            <entry>5</entry>

            <entry>Lettura, scrittura no, esecuzione</entry>

            <entry><literal>r-x</literal></entry>
          </row>

          <row>
            <entry>6</entry>

            <entry>Lettura, scrittura, esecuzione no</entry>

            <entry><literal>rw-</literal></entry>
          </row>

          <row>
            <entry>7</entry>

            <entry>Lettura, scrittura, esecuzione</entry>

            <entry><literal>rwx</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Utilizzando il comando <command>ls -l</command> per ottenere
      un elenco esteso della directory, la prima colonna
      visualizzer&agrave; i permessi del file per il proprietario, il
      gruppo e tutti gli altri utenti. Ecco precisamente come
      apparirebbe</para>

    <screen>-rw-r--r--</screen>

    <para>Il primo carattere, da sinistra verso destra,
      &egrave; un carattere speciale che indica se si tratta di un
      file regolare, di una directory, di un dispositivo speciale a
      caratteri o a blocchi, di un socket, o di un qualsiasi altro
      dispositivo speciale pseudo-file.  I successivi tre caratteri,
      precisamente <literal>rw-</literal> danno i permessi per il
      proprietario del file.  I tre caratteri che seguono, cio&egrave;
      <literal>r--</literal> forniscono i permessi per il gruppo al
      quale il suddetto file appartiene.  Infine gli ultimi tre
      caratteri danno i permessi per chiunque altro.  Un segno meno
      significa che il permesso &egrave; negato.  Nel caso del file
      d'esempio, i permessi sono impostati in modo tale che il
      proprietario pu&ograve; leggere e scrivere il file, il gruppo
      pu&ograve; leggerlo, cos&igrave; come tutti gli altri utenti.
      In base alla tabella precedente, i permessi per questo file
      sarebbero <literal>644</literal>, dove ogni cifra rappresenta
      una delle tre parti del permesso d'accesso al file.</para>

    <para>Fin qui tutto bene, ma ci si potrebbe chiedere: come fa il
      sistema a controllare i permessi sui dispositivi? FreeBSD in
      effetti tratta la maggior parte dei dispositivi alla stregua di
      file, che i programmi possono aprire, leggere e scrivere
      proprio come qualsiasi altro file.  Questi file speciali di
      dispositivo si trovano nella directory
      <filename>/dev</filename>.</para>

    <para>Anche le directory vengono trattate come file e hanno
      perci&ograve; permessi di lettura, scrittura, esecuzione.  Il
      bit di esecuzione ha nel caso di una directory un significato
      leggermente diverso da quello dei file.  Quando una directory
      &egrave contrassegnata come eseguibile, significa che pu&ograve;
      essere visitata, per esempio, pu&ograve; essere fatto un elenco
      del contenuto delle sue sotto-directory (anche con il permesso
      in lettura della directory stessa negato. N.d.T.).</para>

    <para>Vi sono altri tipi di permessi, ma essi sono per lo
      pi&ugrave;  usati in circostanze speciali come nel caso degli
      eseguibili di tipo <emphasis>setuid</emphasis> e delle directory
      con bit <emphasis>sticky</emphasis>.  Se si desidera avere
      maggiori informazioni sui permessi dei file e su come
      impostarli, si dia un'occhiata alla manpage
      &man.chmod.1;.</para>
  </sect1>

  <sect1 id="dirstructure">
    <title>Struttura Delle Directory</title>

    <para>Dal momento che FreeBSD utilizza il proprio file system per
      svolgere molte delle operazioni fondamentali del sistema, la
      gerarchia di tale file system &egrave; estremamente importante.
      Poich&eacute; la manpage &man.hier.7; fornisce una completa
      descrizione della sua struttura, non verr&agrave; duplicata
      qui.  Per maggiori informazioni si consulti quindi
      &man.hier.7;.</para>

    <para>Di particolare importanza &egrave; la radice di tutte le
      altre directory, cio&egrave; la directory /.  Questa directory
      &egrave; la prima ad essere montata al momento dell'avvio e
      contiene il sistema base necessario per il caricamento.  La
      directory principale (<emphasis>root</emphasis>) contiene
      inoltre i <emphasis>punti di montaggio</emphasis> per ogni altro
      file system che si volesse montare successivamente.</para>

    <para>Un punto di montaggio &egrave; una directory dove file
      system addizionali possono essere innestati su quello
      principale.  Fra i punti di montaggio standard ci sono
      <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/mnt</filename>, e <filename>/cdrom</filename>.
      Queste directory hanno solitamente una voce corrispondente nel
      file <filename>/etc/fstab</filename>.
      <filename>/etc/fstab</filename> &egrave; una tabella dei vari
      file system e dei punti di montaggio, usata come riferimento dal
      sistema.  La maggior parte dei file system in
      <filename>/etc/fstab</filename> vengono montati automaticamente
      al momento dell'avvio del sistema dallo script &man.rc.8; a meno
      che essi non contengano l'opzione <option>noauto</option>.
      Si consulti la pagina del manuale &man.fstab.5; per maggiori
      informazioni sul formato del file
      <filename>/etc/fstab</filename> e sulle opzioni che pu&ograve;
      contenere.</para>
  </sect1>

  <sect1 id="shells">
    <title>Le Shell</title>

    <para>In FreeBSD, gran parte del lavoro di tutti i giorni viene
      svolto attraverso un interfaccia a riga di comando chiamata
      shell.  Il compito principale di una shell &egrave; quello di
      prendere i comandi dal canale di input e di eseguirli.  Molte
      shell possiedono anche funzioni interne per agevolare i compiti
      pi&ugrave; frequenti come un gestore dei file, regole per la
      scelta selettiva dei file, funzioni di editing della linea di
      comando, macro, e variabili d'ambiente.  FreeBSD viene fornito
      con un alcune shell standard, come la sh, Bourne Shell, e la
      csh, C-shell.  Molte altre sono disponibili nella FreeBSD
      Ports Collection, dotate di maggior potenzialit&agrave;, come la
      tcsh e la bash.</para>

    <para>Quale shell usare?  &Egrave; decisamente una
      questione di gusti.  Se siete programmatori C potreste
      trovarvi pi&ugrave; a vostro agio con una shell simil-C come la
      tcsh.  Se provenite dal mondo Linux o siete novizi
      dell'interfaccia a linea di comando propria di UNIX potreste
      provare la bash.  Il punto &egrave; che ogni shell ha
      caratteristiche uniche che potrebbero o meno adattarsi al vostro
      ambiente di lavoro preferito, e che si ha sempre alla fine la
      possibilit&agrave; di scegliere quale usare.</para>

    <para>Una caratteristica comune ad ogni shell &egrave; il
      completamento automatico del nome di un file.  Dopo
      l'inserimento di alcuni caratteri iniziali di un comando o del
      nome di un file, si pu&ograve; fare in modo che la shell
      completi automaticamente la parte restante del comando o del
      nome del file premendo il tasto di tabulazione sulla tastiera.
      Ecco un esempio.  Si hanno due file chiamati rispettivamente
      <filename>foobar</filename> e <filename>foo.bar</filename> e si
      desidera eliminare <filename>foo.bar</filename>.  A tal fine si
      dovrebbe digitare sulla  tastiera:
      <command>rm fo[TAB].[TAB]</command>.</para>

    <para>La shell visualizzer&agrave; <command>rm
      foo[BEEP].bar</command>.</para>

    <para>Il [BEEP] &egrave; l'allarme della console, con cui la shell
      avvisa che non &egrave; in grado di completare totalmente il
      nome del file, perch&eacute; vi sono pi&ugrave;
      possibilit&agrave;.  Sia <filename>foobar</filename> che
      <filename>foo.bar</filename> iniziano con <literal>fo</literal>,
      tuttavia essa pu&ograve; completare solamente fino a
      <literal>foo</literal>.
      Una volta inserito un <literal>.</literal> e dopo aver premuto il
      tasto di tabulazione, la shell sar&agrave; in grado di
      completare il nome del file autonomamente.</para>

    <para>Un'altra funzionalit&agrave; interessante della shell
      &egrave; quella fornita con le variabili d'ambiente. Queste sono
      coppie variabile/chiave, immagazzinate nello spazio ambiente della
      shell.  Questo spazio pu&ograve; essere letto da un qualsiasi
      programma invocato dalla shell, e perci&ograve; pu&ograve;
      contenere parte della configurazione dello stesso.  Ecco un
      elenco delle variabili d'ambiente pi&ugrave; comuni e il loro
      significato:</para>

    <informaltable frame="none">
      <tgroup cols="2">
        <thead>
          <row>
            <entry>Variabile</entry>

            <entry>Descrizione</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><envar>USER</envar></entry>

            <entry>Nome dell'utente correntemente registrato.</entry>
          </row>

          <row>
            <entry><envar>PATH</envar></entry>

            <entry>Elenco di directory separate da : in cui ricercare
              gli eseguibili.</entry>
          </row>

          <row>
            <entry><envar>DISPLAY</envar></entry>

            <entry>Nome di rete del display X11 al quale connettersi,
              se disponibile.</entry>
          </row>

          <row>
            <entry><envar>SHELL</envar></entry>

            <entry>La shell corrente.</entry>
          </row>

          <row>
            <entry><envar>TERM</envar></entry>

            <entry>Il nome del terminale dell'utente.  Utilizzata per
              determinare le caratteristiche del terminale.</entry>
          </row>

          <row>
            <entry><envar>TERMCAP</envar></entry>

            <entry>Voce del database con i codici d'escape del
              terminale per eseguire varie funzioni del terminale.</entry>
          </row>

          <row>
            <entry><envar>OSTYPE</envar></entry>

            <entry>Il tipo di sistema operativo.  Ad esempio, FreeBSD.</entry>
          </row>

          <row>
            <entry><envar>MACHTYPE</envar></entry>

            <entry>L'architettura della CPU sul quale il sistema sta
              operando.</entry>
          </row>

          <row>
            <entry><envar>EDITOR</envar></entry>

            <entry>L'editor di testi preferito dell'utente.</entry>
          </row>

          <row>
            <entry><envar>PAGER</envar></entry>

            <entry>Il visualizzatore di testi preferito dell'utente.</entry>
          </row>

          <row>
            <entry><envar>MANPATH</envar></entry>

            <entry>Elenco di directory separate da : in cui ricercare
              le pagine del manuale.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>La visualizzazione o l'impostazione di una variabile
      d'ambiente differisce da shell a shell.  Per esempio, nelle
      shell con sintassi simil-C come la tcsh e la csh, si deve usare
      <command>setenv</command> per impostare o visualizzare le
      variabili d'ambiente.  Con le shell Bourne come la sh e la
      bash, si devono usare i comandi <command>set</command> e
      <command>export</command>  Per esempio, per impostare o
      modificare la variabile d'ambiente <envar>EDITOR</envar>,
      utilizzando la csh o la tcsh, un comando come il seguente
      imposterebbe <envar>EDITOR</envar> a
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Utilizzando le Bourne shell:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Si pu&ograve; fare in modo anche che le shell espandano la
      variabile d'ambiente, anteponendole un carattere di
      <literal>$</literal> sulla linea di comando.  Per esempio,
      <command>echo $TERM</command> stamperebbe ci&ograve; a cui
      &egrave; impostata <envar>$TERM</envar>, perch&eacute; la shell
      espande <envar>$TERM</envar> e lo passa ad echo.</para>

    <para>Le shell trattano parecchi caratteri speciali, detti
      meta-caratteri come rappresentazioni speciali dei dati.  Il
      pi&ugrave; comune &egrave; il carattere <literal>*</literal>,
      che rappresenta un numero qualsiasi di caratteri nel nome del
      file.  Questi meta-caratteri speciali possono essere utilizzati
      per fare una selezione sui nomi dei file.  Per esempio,
      digitare <command>echo *</command> &egrave; la stessa cosa che
      digitare <command>ls</command>, perch&eacute; la shell prende in
      considerazione tutti i file che corrispondono a
      <command>*</command> e li inserisce sulla linea di comando di
      echo per visualizzarli.</para>

    <para>Per prevenire che la shell interpreti questi caratteri
      speciali, si deve farli precedere da un carattere di barra
      inversa (<literal>\</literal>).
      <command>echo $TERM</command> stampa il valore a cui
      &egrave; impostato il proprio terminale.  <command>echo
      \$TERM</command> stampa <envar>$TERM</envar> cos&igrave;
      com'&egrave;.</para>

    <sect2 id="changing-shells">
      <title>Cambiare La Propria Shell</title>

      <para>Il modo pi&ugrave; semplice per cambiare la propria shell
        &egrave; quello di utilizzare il comando
        <command>chsh</command>.  Lanciando <command>chsh</command> si
        entrer&agrave; nel proprio editor, specificato dalla variabile
        d'ambiente <envar>EDITOR</envar>; se non &egrave; impostata,
        si acceder&agrave; a <command>vi</command>.  Si
        modificher&agrave; quindi la riga <quote>Shell:</quote> in
        base alle proprie preferenze.</para>

      <para>&Egrave; anche possibile fornire al comando
        <command>chsh</command> l'opzione <option>-s</option>; questa
        imposter&agrave; la shell voluta , senza dover operare all'interno
        dell'editor.  Per esempio, se si desidera cambiare la propria
        shell nella bash, il seguente comando dovrebbe servire allo
        scopo:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>La stessa cosa si pu&ograve; ottenere lanciando
        <command>chsh</command> senza alcun parametro ed editando il
        campo shell.</para>

      <note>
        <para>La shell che si desidera usare <emphasis>deve</emphasis>
          essere elencata nel file <filename>/etc/shells</filename>.  Se
          si &egrave; installata una shell dalla <link
            linkend="ports">ports collection</link>, allora essa
          dovrebbe essere gi&agrave; stata inserita automaticamente.  Se
          &egrave; stata installata a mano, si dovr&agrave; invece
          aggiungerne il percorso in detto file.</para>

        <para>Per esempio, se si &egrave; installato la
          <command>bash</command> manualmente e la si &egrave; messa
          nella directory <filename>/usr/local/bin</filename>, si
          dovrebbe dare il comando:</para>

        <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

        <para>Quindi rilanciare il comando <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Gli Editor Di Testo</title>

    <para>Gran parte del lavoro di configurazione in FreeBSD viene
      fatto editando file di testo.  Per questo motivo, sarebbe bene
      acquisire una certa familiarit&agrave; con un editor di testi.
      Diversi ne vengono forniti con il sistema base di FreeBSD, e
      molti altri sono disponibili nella port collection.</para>

    <para>L'editor pi&ugrave; facile e semplice da imparare &egrave;
      un editor di nome <application>ee</application>, che sta per
      easy editor.  Per avviare <application>ee</application>, si deve
      digitare sulla riga dei comandi <command>ee filename</command>,
      dove <literal>filename</literal> &egrave; il nome del file che
      deve essere editato.
      Per esempio, per editare il file
      <filename>/etc/rc.conf</filename>, digitare <command>ee
      /etc/rc.conf</command>.  Una volta all'interno di ee, tutti i
      comandi per utilizzare le funzionalit&agrave; dell'editor
      sono elencate nella parte superiore dello schermo.  Il carattere
      <literal>^</literal> corrisponde al tasto Ctrl della tastiera,
      perci&ograve; ^e corrisponde alla pressione del tasto Ctrl
      pi&ugrave; la lettera <literal>e</literal>.  Per uscire da
      <application>ee</application>, si prema il tasto Esc, quindi si
      scelga l'opzione leave editor.  L'editor chieder&agrave; se si
      desidera salvare le modifiche eventualmente fatte al
      file.</para>

    <para>Altri editor di testo pi&ugrave; potenti sono gi&agrave;
      presenti nel sistema base di FreeBSD, come
      <application>vi</application>, e nella ports collection come
      <application>emacs</application> e
      <application>vim</application>.  Tali editor offrono molte
      pi&ugrave; funzionalit&agrave; e potenza, con lo scotto
      per&ograve; di essere un poco pi&ugrave; complicati da
      imparare.  Tuttavia se si sa gi&agrave; che si dovr&agrave;
      usare spesso un editor, imparare ad usarne uno po' pi&ugrave;
      potente come <application>vim</application> o
      <application>emacs</application> far&agrave; a lungo andare
      risparmiare tantissimo tempo.</para>
  </sect1>

  <sect1>
    <title>Per Maggiori Informazioni...</title>

    <sect2 id="basics-man">
      <title>Le Manual Pages</title>

      <para>La documentazione pi&ugrave; esauriente su FreeBSD
        &egrave; in forma di man pages. Quasi ogni programma del
        sistema ha un breve manuale di riferimento, che spiega le
        operazioni di base e le varie caratteristiche del programma.
        Questi manuali possono essere visualizzati con il comando man.
        L'uso di tale comando &egrave; semplicissimo:</para>

      <screen>&prompt.user; <userinput>man <replaceable>comando</replaceable></userinput></screen>

      <para>dove <literal>comando</literal> &egrave; il nome del
        comando sul quale si desidera avere informazioni.  Per
        esempio, per conoscere tutti i particolari del comando
        <command>ls</command> si digiti:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Il manuale in linea &egrave; suddiviso in sezioni
        cos&igrave; numerate:</para>

      <orderedlist>
        <listitem>
          <para>Comandi Utente.</para>
        </listitem>

        <listitem>
          <para>Chiamate di sistema e codici d'errore.</para>
        </listitem>

        <listitem>
          <para>Funzioni delle librerie C.</para>
        </listitem>

        <listitem>
          <para>Driver di dispositivo.</para>
        </listitem>

        <listitem>
          <para>Formati dei file.</para>
        </listitem>

        <listitem>
          <para>Giochi e altri passatempi.</para>
        </listitem>

        <listitem>
          <para>Informazioni varie.</para>
        </listitem>

        <listitem>
          <para>Comandi di gestione e mantenimento del sistema.</para>
        </listitem>

        <listitem>
          <para>Sviluppo Kernel.</para>
        </listitem>
      </orderedlist>

      <para>In alcuni casi, il medesimo argomento pu&ograve; apparire in
        pi&ugrave; di una sezione del manuale in linea.  Per esempio,
        esiste un comando utente chmod e una chiamata di sistema
        <literal>chmod()</literal>.  In questo caso, si pu&ograve;
        specificare il comando desiderato del manuale, indicandone la
        sezione di appartenenza:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Ci&ograve; visualizzer&agrave; la pagina del manuale per
        il comando utente <command>chmod</command>. I riferimenti a
        una particolare sezione del manuale in linea sono
        tradizionalmente posti tra parentesi nei vari documenti,
        perci&ograve; &man.chmod.1; fa riferimento al comando
        utente <command>chmod</command> e &man.chmod.2; si riferisce
        alla chiamata di sistema omonima.</para>

      <para>Tutto questo &egrave; abbastanza ovvio se si conosce il
        nome del comando e se si desidera semplicemente approfondire
        l'argomento, ma cosa fare nel caso non lo si ricordi?
        &Egrave; possibile utilizzare lo stesso comando man per
        ricercare delle parole chiave nelle descrizioni dei comandi
        utilizzando l'opzione <option>-k</option>:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Con questo comando viene presentata tutta una lista di
        comandi che hanno la parola chiave <quote>mail</quote> nella
        loro descrizione.  Questo &egrave; in effetti del tutto
        equivalente ad usare il comando apropos.</para>

      <para>Cos&igrave;: si sono visti tutti quei fantasiosi comandi
        nella directory <filename>/usr/bin</filename> ma non si ha la
        pi&ugrave; pallida idea di che cosa fanno effettivamente?  Si
        digiti semplicemente:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>oppure</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

      <para>che fa la medesima cosa.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>I File Info di GNU</title>

      <para>FreeBSD include molte applicazioni e accessori prodotti
        dalla Free Software Foundation (FSF).  In aggiunta alle man
        pages, tali programmi vengono forniti con dei documenti
        ipertestuali molto pi&ugrave; esaurienti chiamati file
        <literal>info</literal> che possono essere visualizzati con il
        comando <command>info</command> oppure, se si &egrave;
        provveduto ad installare <application>emacs</application>,
        mediante la modalit&agrave; info di
        <application>emacs</application>.</para>

      <para>Per utilizzare il comando &man.info.1;, si digiti:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Per una breve introduzione al programma stesso, premere
        <literal>h</literal>.  Per una guida rapida ai comandi, digitare
        <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
