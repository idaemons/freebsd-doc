<!--
     The FreeBSD Documentation Project
     The FreeBSD Simplified Chinese Project

     Original Revision: 1.30
     $FreeBSD$
-->

<chapter id="GEOM">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Tom</firstname>
	<surname>Rhodes</surname>
	<contrib>原作 </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>GEOM： 模块化磁盘变换框架</title>

  <sect1 id="GEOM-synopsis">
    <title>概述</title>

    <indexterm>
      <primary>GEOM</primary>
    </indexterm>
    <indexterm>
      <primary>GEOM 磁盘框架</primary>
      <see>GEOM</see>
    </indexterm>

    <para>本章将介绍以 &os; GEOM 框架来使用磁盘。
      这包括了使用这一框架来配置的主要的 <acronym
      role="Redundant Array of Inexpensive Disks">RAID</acronym>
      控制工具。 这一仗不会深入讨论 GEOM
      如何处理或控制 I/O、 其下层的子系统或代码。
      您可以从 &man.geom.4; 联机手册及其众多 SEE ALSO 参考文献中得到这些信息。
      这一章也不是对 <acronym>RAID</acronym> 配置的权威介绍，
      它只介绍由 支持GEOM 的 <acronym>RAID</acronym>
      级别。</para>

    <para>读完这章， 您将了解：</para>

    <itemizedlist>
      <listitem>
	<para>通过 GEOM 支持的 <acronym>RAID</acronym> 类型。</para>
      </listitem>

      <listitem>
	<para>如何使用基本工具来配置和管理不同的 <acronym>RAID</acronym>
	  级别。</para>
      </listitem>

      <listitem>
        <para>如何通过 GEOM 使用镜像、 条带、 加密和挂接在远程的磁盘设备。</para>
      </listitem>

      <listitem>
	<para>如何排除挂接在 GEOM 框架上的磁盘设备的问题。</para>
      </listitem>
    </itemizedlist>

    <para>阅读这章之前， 您应：</para>

    <itemizedlist>
      <listitem>
	<para>理解 &os; 如何处理磁盘设备
	  (<xref linkend="disks">)。</para>
      <listitem>
	<para>了解如何配置和安装新的 &os; 内核
	  (<xref linkend="kernelconfig">)。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="GEOM-intro">
    <title>GEOM 介绍</title>

    <para>GEOM 允许访问和控制类 (classes) &mdash; 主引导记录、
      <acronym>BSD</acronym> 标签 (label)， 等等 &mdash; 通过使用
      provider， 或在
      <filename role="directory">/dev</filename> 中的特殊文件。
      它支持许多软件 <acronym>RAID</acronym> 配置， GEOM 能够向操作系统，
      以及在其上运行的工具提供透明的访问方式。</para>
  </sect1>

  <sect1 id="GEOM-striping">
  <sect1info>
    <authorgroup>
      <author>
	<firstname>Tom</firstname>
	<surname>Rhodes</surname>
	<contrib>原作 </contrib>
      </author>
      <author>
	<firstname>Murray</firstname>
	<surname>Stokely</surname>
      </author>
    </authorgroup>
  </sect1info>

    <title>RAID0 - 条带</title>

    <indexterm>
      <primary>GEOM</primary>
    </indexterm>
    <indexterm>
      <primary>条带</primary>
    </indexterm>

    <para>条带是一种将多个磁盘驱动器合并为一个卷的方法。
      许多情况下， 这是通过硬件控制器来完成的。 GEOM
      磁盘子系统提供了 <acronym>RAID</acronym>0 的软件支持，
      它也成为磁盘条带。</para>

    <para>在 <acronym>RAID</acronym>0 系统中， 数据被分为多个块，
      这些块将分别写入阵列的所有磁盘。 与先前需要等待系统将 256k
      数据写到一块磁盘上不同， <acronym>RAID</acronym>0 系统，
      能够同时分别将打碎的 64k 写到四块磁盘上， 从而提供更好的 I/O
      性能。 这一性能提升还能够通过使用多个磁盘控制器来进一步改进。</para>

    <para>在 <acronym>RAID</acronym>0 条带中的每一个盘的尺寸必须一样，
      因为 I/O 请求是分散到多个盘上的， 以便让这些盘上的读写并行完成。</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="geom/striping" align="center">
        </imageobject>

        <textobject>
          <phrase>磁盘条带图</phrase>
        </textobject>
      </mediaobject>

    <procedure>
      <title>在未格式化的 ATA 磁盘上建立条带</title>

      <step><para>加载 <filename>geom_stripe</filename>
        模块：</para>

    <screen>&prompt.root; <userinput>kldload geom_stripe</userinput></screen>
	</step>

      <step><para>确信存在合适的挂接点 (mount point)。 如果这个卷将成为根分区，
        那么暂时把它挂接到其他位置i， 如 <filename
        role="directory">/mnt</filename>：</para>

        <screen>&prompt.root; <userinput>mkdir /mnt</userinput></screen>
      </step>

      <step><para>确定将被做成条带卷的磁盘的设备名，
        并创建新的条带设备。 举例而言，
        要将两个未用的、 尚未分区的 <acronym>ATA</acronym> 磁盘
        <filename>/dev/ad2</filename> 和
        <filename>/dev/ad3</filename> 做成一个条带设备：</para>

        <screen>&prompt.root; <userinput>gstripe label -v st0 /dev/ad2 /dev/ad3</userinput></screen>

<!-- 
    <para>A message should be returned explaining that meta data has
      been stored on the devices.
XXX: What message?  Put it inside the screen output above.
-->
      </step>

      <step><para>接着需要写标准的 label， 也就是通常所说的分区表到新卷上，
        并安装标准的引导代码：</para>

        <screen>&prompt.root; <userinput>bsdlabel -wB /dev/stripe/st0</userinput></screen>

      </step>

      <step><para>上述过程将在
        <filename role="directory">/dev/stripe</filename>
        目录中的 <devicename>st0</devicename> 设备基础上建立两个新设备。
        这包括 <devicename>st0a</devicename> 和
        <devicename>st0c</devicename>。 这时， 就可以在
        <devicename>st0a</devicename> 设备上用下述
        <command>newfs</command> 命令来建立文件系统了：</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/stripe/st0a</userinput></screen>

      <para>在屏幕上将滚过一些数字， 整个操作应该能在数秒内完成。
        现在可以挂接刚刚做好的卷了。</para>
    </step>
  </procedure>

  <para>要挂接刚创建的条带盘：</para>

  <screen>&prompt.root; <userinput>mount /dev/stripe/st0a /mnt</userinput></screen>

  <para>要在启动过程中自动挂接这个条带上的文件系统，
    需要把关于卷的信息放到
    <filename>/etc/fstab</filename> 文件中：</para>

  <screen>&prompt.root; <userinput>echo "/dev/stripe/st0a /mnt ufs rw 2 2" \</userinput>
    <userinput>&gt;&gt; /etc/fstab</userinput></screen>

  <para>此外， <filename>geom_stripe</filename> 模块也必须通过在
    <filename>/boot/loader.conf</filename> 中增加下述设置，
    以便在系统初始化过程中自动加载。</para>

  <screen>&prompt.root; <userinput>echo 'geom_stripe_load="YES"' &gt;&gt; /boot/loader.conf</userinput></screen>

  </sect1>

  <sect1 id="GEOM-mirror">
    <title>RAID1 - 镜像</title>

    <indexterm>
      <primary>GEOM</primary>
    </indexterm>
    <indexterm>
      <primary>磁盘镜像</primary>
    </indexterm>

    <para>镜像是一种许多公司和家庭用户使用的不需中断的备份技术。
      当存在镜像时， 它的意思是说 磁盘B 简单地复制 磁盘A。
      或者， 也可能是 磁盘C+D
      复制 磁盘A+B。 无论磁盘如何配置， 共同的特征，
      都是磁盘或卷的信息会被复制。 随后，在无需中断服务或访问的情况下，
      可以很容易地复原和备份这些信息， 甚至把它们存储到其他更安全的地方。</para>

    <para>要开始做这件事， 首先要确保系统中有两个同样大的磁盘驱动器，
      下面的例子假定使用直接访问方式 (Direct Access， &man.da.4;)
      <acronym>SCSI</acronym> 的磁盘。</para>

    <para>首先需要把 &os; 安装到第一块磁盘上， 并建立两个分区。
      第一个分区将成为交换区， 其尺寸应该是两倍的
      <acronym>RAM</acronym> 尺寸， 而余下的空间，
      则作为根 (<filename role="directory">/</filename>) 文件系统来使用。
      当然， 也可以为其他挂接点划分不同的分区；
      但是， 这将使难度提高一个量级，
      因为您将不得不手工修改 &man.bsdlabel.8; 和 &man.fdisk.8;
      的设置。</para>

    <para>重新启动系统， 并等待其完全初始化完。
      当这个过程完成之后， 以 <username>root</username>
      用户的身份登录。</para>

    <para>创建 <filename>/dev/mirror/gm</filename> 设备，
      并将其连接到 <filename>/dev/da1</filename>：</para>

    <screen>&prompt.root; <userinput>gmirror label -vnb round-robin gm0 /dev/da1</userinput></screen>

    <para>系统应会给出下列回应：</para>
    <screen>
Metadata value stored on /dev/da1.
Done.</screen>

    <para>初始化 GEOM， 这将加载
      <filename>/boot/kernel/geom_mirror.ko</filename> 内核模块：</para>

    <screen>&prompt.root; <userinput>gmirror load</userinput></screen>

    <note>
      <para>这个命令应该会在
	<filename role="directory">/dev/mirror</filename>
	目录中创建
	<devicename>gm0</devicename> 设备节点。</para>
    </note>

    <para>在刚创建的 <devicename>gm0</devicename>
      设备上安装通用的 <command>fdisk</command> 标签以及引导区代码：</para>

    <screen>&prompt.root; <userinput>fdisk -vBI /dev/mirror/gm0</userinput></screen>

    <para>接下来安装通用的 <command>bsdlabel</command>
      信息：</para>

    <screen>&prompt.root; <userinput>bsdlabel -wB /dev/mirror/gm0s1</userinput></screen>

    <note>
      <para>如果存在多个区段 (slice) 或分区 (partition)，
	则需要修改一部分上面命令的参数。
	它们必须与另一个盘上对应的区段和分区匹配。</para>
    </note>

    <para>使用 &man.newfs.8; 工具来在 <devicename>gm0s1a</devicename>
      设备上建立默认的 <acronym>UFS</acronym>
      文件系统：</para>

    <screen>&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1a</userinput></screen>

    <para>这将让系统输出很多信息和一系列数字。 不必为此担心，
      只需看看是否有错误提示就可以了， 如果没问题， 接下来把它挂到
      <filename role="directory">/mnt</filename> 挂接点上面：</para>

    <screen>&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput></screen>

    <para>现在需要把所有引导盘上的数据迁移到新的文件系统上了。
      下面的例子使用了 &man.dump.8; 和 &man.restore.8;
      这两个命令； 不过， 用 &man.dd.1; 在这里也可以达到完全一样的目的。</para>

    <screen>&prompt.root; <userinput>dump -L -0 -f- / |(cd /mnt &amp;&amp; restore -r -v -f-)</userinput></screen>

    <para>这个操作必须在所有文件系统上都作一遍。 您可以将前述命令中的文件系统，
      改为所希望的文件系统的位置。</para>

    <para>接下来应该编辑复制出来的 <filename>/mnt/etc/fstab</filename>
      文件， 并删去或注释掉交换文件
      <footnote>
	<para>需要注意的是，
	在 <filename>fstab</filename> 注释掉交换文件，
	通常会需要您以其他方式重建交换空间。
	请参见 <xref linkend="adding-swap-space"> 以了解进一步的细节。</para>
      </footnote>。 修改其他文件系统对应的信息，
      以便让它们使用新盘。 参考下面的例子：</para>

    <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
#/dev/da0s2b             none            swap    sw              0       0
/dev/mirror/gm0s1a       /               ufs     rw              1       1</programlisting>

    <para>接下来应在当前和新 root 分区中分别建立一个 <filename>boot.config</filename> 文件。 它会
      <quote>帮助</quote> 系统的 <acronym>BIOS</acronym>
      从正确的驱动器上引导：</para>

    <screen>&prompt.root; <userinput>echo "1:da(1,a)/boot/loader" &gt; /boot.config</userinput></screen>

    <screen>&prompt.root; <userinput>echo "1:da(1,a)/boot/loader" &gt; /mnt/boot.config</userinput></screen>

    <note>
      <para>在所有的分区上都放这些是为了保证系统能够正确引导。
        如果由于某种原因系统无法从新的根分区读数据，
        则还有一根救命稻草。</para>
    </note>

    <para>用下面的命令来确保系统引导时会加载 <filename>geom_mirror.ko</filename>：</para>

    <screen>&prompt.root; <userinput>echo 'geom_mirror_load="YES"' &gt;&gt; /mnt/boot/loader.conf</userinput></screen>

    <para>最后重新启动系统：</para>

    <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

    <para>如果一切顺利， 系统将从
      <devicename>gm0s1a</devicename> 设备启动， 并给出 <command>login</command>
      提示等待用户登录。 如果发生错误， 请查阅接下来的故障排除环节。 我们接着将
      <devicename>da0</devicename> 磁盘也加入 <devicename>gm0</devicename>
      设备：</para>

    <screen>&prompt.root; <userinput>gmirror configure -a gm0</userinput>
&prompt.root; <userinput>gmirror insert gm0 /dev/da0</userinput></screen>

    <para>此处 <option>-a</option> 告诉 &man.gmirror.8; 采用自动同步，
      或换言之： 自动地将磁盘的写操作做镜像处理。 联机手册中详细解释了如何重建，
      以及替换磁盘， 只不过它用 <devicename>data</devicename>
      表示这里的 <devicename>gm0</devicename>。</para>

    <sect2>
      <title>故障排除</title>

      <sect3>
	<title>系统拒绝引导</title>

	<para>如果系统引导时出现类似下面的提示：</para>

	<programlisting>ffs_mountroot: can't find rootvp
Root mount failed: 6
mountroot></programlisting>

	<para>这种情况应使用电源或复位按钮重启机器。
	  在引导菜单中， 选择第六 (6) 个选项。
	  这将让系统进入 &man.loader.8; 提示符。
	  在此处手工加载内核模块：</para>

	<screen>OK? <userinput>load geom_mirror</userinput>
OK? <userinput>boot</userinput></screen>

	<para>如果这样做能解决问题， 则说明由于某种原因模块没有被正确加载。
	  可以通过在内核配置文件中加入：</para>

	<programlisting>options	GEOM_MIRROR</programlisting>

	<para>然后重新编译和安装内核来解决这个问题。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="geom-ggate">
    <title>GEOM Gate 网络设备</title>

    <para>通过 gate 工具， GEOM 支持以远程方式使用设备， 例如磁盘、
      CD-ROM、 文件等等。 这和 <acronym>NFS</acronym> 类似。</para>

    <para>在开始工作之前， 首先要创建一个导出文件。
      这个文件的作用是指定谁可以访问导出的资源，
      以及提供何种级别的访问授权。 例如，
      要把第一块 <acronym>SCSI</acronym> 盘的第四个 slice 导出，
      对应的 <filename>/etc/gg.exports</filename> 会是类似下面的样子：</para>

    <programlisting>192.168.1.0/24 RW /dev/da0s4d</programlisting>

    <para>这表示允许同属私有子网的所有机器访问
      <devicename>da0s4d</devicename> 分区上的文件系统。</para>

    <para>要导出这个设备， 首先请确认它没有被挂接，
      然后是启动 &man.ggated.8; 服务：</para>

    <screen>&prompt.root; <userinput>ggated</userinput></screen>

    <para>现在我们将在客户机上 <command>mount</command> 该设备，
      使用下面的命令：</para>

    <screen>&prompt.root; <userinput>ggatec create -o rw 192.168.1.1 /dev/da0s4d</userinput>
ggate0
&prompt.root; <userinput>mount /dev/ggate0 /mnt</userinput></screen>

    <para>到此为止， 设备应该已经可以通过挂接点
      <filename role="directory">/mnt</filename> 访问了。</para>

    <note>
      <para>请注意， 如果设备已经被服务器或网络上的任何其他机器挂接，
	则前述操作将会失败。</para>
    </note>

    <para>如果不再需要使用这个设备，
      就可以使用 &man.umount.8; 命令来安全地将其卸下了，
      这一点和其他磁盘设备类似。</para>
  </sect1>

  <sect1 id="geom-glabel">
    <title>为磁盘设备添加卷标</title>

    <indexterm>
      <primary>GEOM</primary>
    </indexterm>
    <indexterm>
      <primary>磁盘卷标</primary>
    </indexterm>

    <para>在系统初始化的过程中， &os; 内核会为检测到的设备创建设备节点。
      这种检测方式存在一些问题， 例如，
      在通过 <acronym>USB</acronym> 添加设备时应如何处理？
      很可能有闪存盘设备最初被识别为
      <devicename>da0</devicename> 而在这之后， 则由
      <devicename>da0</devicename> 变成了
      <devicename>da1</devicename>。 而这则会在挂接
      <filename>/etc/fstab</filename> 中的文件系统时造成问题，
      这些问题， 还可能在系统引导时导致无法正常启动。</para>

    <para>解决这个问题的一个方法是以连接拓扑方式链式地进行
      <acronym>SCSI</acronym> 设备命名， 这样，
      当在 <acronym>SCSI</acronym> 卡上增加新设备时， 这些设备将使用一个未用的编号。
      但如果 <acronym>USB</acronym> 设备取代了主 <acronym>SCSI</acronym> 磁盘的位置呢？
      由于 <acronym>USB</acronym> 通常会在 <acronym>SCSI</acronym> 卡之前检测到，
      因此很可能出现这种现象。 当然， 可以通过在系统引导之后再插入这些设备来绕过这个问题。
      另一种绕过这个问题的方法， 则是只使用
      <acronym>ATA</acronym> 驱动器， 并避免在
      <filename>/etc/fstab</filename> 中列出
      <acronym>SCSI</acronym> 设备。</para>

    <para>还有一种更好的解决方法。 通过使用
      <command>glabel</command> 工具， 管理员或用户可以为磁盘设备打上标签， 并在
      <filename>/etc/fstab</filename> 中使用这些标签。 由于
      <command>glabel</command> 会将标签保存在对应 provider 的最后一个扇区，
      在系统重启之后， 它仍会持续存在。 因此， 通过将具体的设备替换为使用标签表示，
      无论设备节点变成什么， 文件系统都能够顺利地完成挂接。</para>

    <note>
      <para>这并不是说标签一定是永久性的。
	<command>glabel</command> 工具既可以创建永久性标签， 也可以创建临时性标签。
	在重启时， 只有永久性标签会保持。 请参见联机手册 &man.glabel.8;
	以了解两者之间的差异。</para>
    </note>

    <sect2>
      <title>标签类型和使用示范</title>

      <para>有两种类型的标签， 一种是普通标签， 另一种是文件系统标签。
	两者的差异体现在是否能够自动检测， 以及是否在重启后保持。 这些标签会放到
	<filename class="directory">/dev</filename> 中的特殊目录中，
	这些目录的名字取决于文件系统类型。 例如，
	<acronym>UFS</acronym>2 文件系统的标签会创建到
	<filename class="directory">/dev/ufs2</filename>
	目录中。</para>

      <para>普通标签在系统下次重启时会消失， 这些标签会创建到
	<filename class="directory">/dev/label</filename> 目录中，
	很适合测试之用。</para>

<!-- XXXTR: How do you create a file system label without running newfs
            or when there is no newfs (e.g.: cd9660)? -->

      <para>永久性标签可以使用
	<command>tunefs</command> 或 <command>newfs</command>
	工具来创建。 要为
	<acronym>UFS</acronym>2 文件系统创建标签， 而不破坏其上的数据，
	可以使用下面的命令：</para>

      <screen>&prompt.root; <userinput>tunefs -L <replaceable>home</replaceable> <replaceable>/dev/da3</replaceable></userinput></screen>

      <warning>
	<para>如果文件系统满了， 这可能会导致数据损坏； 不过， 如果文件系统快满了，
	  此时应首先删除一些无用的文件， 而不是增加标签。</para>
      </warning>

      <para>现在， 您应可以在
	<filename class="directory">/dev/ufs2</filename> 目录中看到标签，
	并将其加入 <filename>/etc/fstab</filename>：</para>

      <programlisting>/dev/ufs2/home		/home            ufs     rw              2      2</programlisting>

      <note>
	<para>当运行 <command>tunefs</command> 时， 应首先卸下文件系统。</para>
      </note>

      <para>现在可以像平时一样挂接文件系统了：</para>

      <screen>&prompt.root; <userinput>mount /home</userinput></screen>

      <para>下列命令可以清除标签：</para>

      <screen>&prompt.root; <userinput>glabel destroy home</userinput></screen>

      <para>现在， 只要在系统引导时通过 <filename>/boot/loader.conf</filename> 配置加载了内核模块
	<filename>geom_label.ko</filename>， 或在联编内核时指定了
	<literal>GEOM_LABEL</literal> 选项，
	设备节点由于增删设备而顺序发生变化时， 就不会影响文件系统的挂接了。</para>

      <para>通过使用 <command>newfs</command> 命令的
	<option>-L</option> 参数， 可以在创建文件系统时为其添加默认的标签。
	请参见联机手册 &man.newfs.8; 以了解进一步的详情。</para>
    </sect2>
  </sect1>

<!--
  <sect1 id="geom-gjournal">
    <title>通过 GEOM 实现 UFS 日志</title>
    
    <indexterm>
      <primary>GEOM</primary>
    </indexterm>
    <indexterm>
      <primary>日志</primary>
    </indexterm>

    <para>随着 &os;&nbsp;7.0 的发布， 实现了长期为人们所期待的
      <acronym>UFS</acronym> 日志。 这个实现采用了
      <acronym>GEOM</acronym> 子系统， 可以很容易地使用 &man.gjournal.8; 工具来进行配置。</para>

    <para>日志是什么？ 日志的作用是保存文件系统事务的记录， 换言之，
      完成一次完整的磁盘写入操作所需的变动， 这些记录会在元数据以及文件数据写盘之前，
      写入到磁盘中。 这种事务日志可以在随后用于重放并完成文件系统事务，
      以避免文件系统出现不一致的问题。</para>

    <para>这种方法是另一种阻止文件系统丢失数据并发生不一致的方法。 与 Soft Updates
      追踪并确保元数据更新顺序这种方法不同， 它会实际地将日志保存到磁盘最后的扇区，
      或另外一块磁盘上。</para>

    <para>与其他文件系统的日志实现不同，
      <command>gjournal</command> 采用的是基于块， 而不是作为文件系统的一部分的方式 -
      它只是作为一种
      <acronym>GEOM</acronym> 扩展实现。</para>

    <para>如果希望启用 <command>gjournal</command>，
      &os; 内核需要下列选项 - 这是 7.X 系统上的默认配置：</para>

    <programlisting>options	UFS_GJOURNAL</programlisting>

    <para>现在， 可以为空闲的文件系统创建日志了。 对于新增的 <acronym>SCSI</acronym> 磁盘
      <devicename>da4</devicename>， 具体的操作步骤为：</para>

    <screen>&prompt.root; <userinput>gjournal label /dev/da4</userinput>
    <userinput>gjournal load</userinput></screen>

    <para>这样， 就会出现一个与
      <devicename>/dev/da4</devicename> 设备节点对应的
      <devicename>/dev/da4.journal</devicename> 设备节点。
      接下来， 可以在这个设备上简历文件系统：</para>

    <screen>&prompt.root; <userinput>newfs -O 2 -J /dev/da4.journal</userinput></screen>

    <para>这个命令将建立一个包含日志的
      <acronym>UFS</acronym>2 文件系统。</para>

    <para>然后就可以用 <command>mount</command> 命令来挂接设备了：</para>

    <screen>&prompt.root <userinput>mount /dev/da4.journal /mnt</userinput></screen>

    <note>
      <para>当磁盘包含多个 slice 时， 每个 slice 上都会建立日志。
	例如， 如果有 ad4s1 和 ad4s2
	这两个 slice， 则 <command>gjournal</command> 会建立
	ad4s1.journal 和 ad4s2.journal。 如果连续运行两次这个命令， 则会建立
	<quote>多层日志</quote>。</para>
    </note>

    <para>在某些情况下， 可能会希望在其他磁盘上保存日志。 对于这些情形，
      日志提供者或存储设备， 应在启用日志的设备后给出。 在暨存的文件系统上，
      可以用 <command>tunefs</command> 来启用日志； 不过，
      在尝试修改文件系统之前， 您应对其进行备份。 多数情况下，
      <command>gjournal</command> 会因为无法建立日志而失败， 在误用
      <command>tunefs</command> 时， 这可能导致失败。</para>
  </sect1>
-->
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
