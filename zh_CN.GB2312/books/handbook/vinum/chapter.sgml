<!--
	The Vinum Volume Manager
	By Greg Lehey (grog at lemis dot com)

	Added to the Handbook by Hiten Pandya <hiten@FreeBSD.org>
	and Tom Rhodes <trhodes@FreeBSD.org>

	For the FreeBSD Documentation Project
        The FreeBSD Simplified Chinese Project

	Original Revision: 1.32
	$FreeBSD$
-->

<chapter id="vinum-vinum">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Greg</firstname>
	<surname>Lehey</surname>
	<contrib>Originally written by </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Vinum 卷管理程序</title>
  
  <sect1 id="vinum-synopsis">
    <title>概述</title>

    <para>无论您有什么样的磁盘，总会有一些潜在问题：</para>
      <itemizedlist>
        <listitem>
          <para>它们可能容量太小。</para>
        </listitem>

        <listitem>
          <para>它们可能速度太慢。</para>
        </listitem>

        <listitem>
          <para>它们可能也太不可靠。</para>
        </listitem>
      </itemizedlist>

<para>一些用户采取一些技术来保护他们免与受到这些问题的影响，
例如使用多个， 有些时候甚至是冗余的， 磁盘。</para>

<para>除了支持许多种不同的硬件 RAID 控制器之外，
FreeBSD 的基本系统中包括了 Vinum 卷管理器， 它是一个用以实现磁盘驱动器的块设备。</para>

<para>Vinum 提供了比传统磁盘存储更好的灵活性、性能和可靠性，
它还实现了 RAID-0, RAID-1, 以及 RAID-5
并可以单独和组合使用。</para>

<para>这一章对传统磁盘存储的潜在问题进行了简要说明，并介绍了 Vinum 卷管理器。</para>

  </sect1>

  <sect1 id="vinum-intro">
    <title>磁盘容量太小</title>

    <indexterm><primary>Vinum</primary></indexterm>
    <indexterm><primary>RAID</primary>
    <secondary>Software</secondary></indexterm>
    
    <para><emphasis>Vinum</emphasis> 是一个所谓的 <emphasis>卷管
    理工具</emphasis>, 是能够解决这三个问题的虚拟磁盘驱动程序。
    让我们来仔细地看看这些问题。已经有针对这些问题的很多方法被提出和实现了：
      </para>


    <para>磁盘越大，存储的数据也就越多。您经常会发现您需要
    一个比您可使用的磁盘大得多的文件系统。 无可否认，这个问题
    已经没有十年前那样严峻了，但它仍然存在。通过创建一个在许多
    磁盘上存储数据的抽象设备，一些系统可以解决这个问题。</para>
  </sect1>

  <sect1 id="vinum-access-bottlenecks">
    <title>访问瓶颈</title>

    <para>现代系统经常需要用一个高度并发的方式来访问数据。
      例如，巨大的FTP 或HTTP 服务器可以支持数以千计的并发会话，
      可以有多个连到外部世界的100&nbsp;Mbit/s , 
      这远远地超过了绝大多数磁盘的数据传输速率。</para>

    <para>当前的磁盘驱动器最高可以以70&nbsp;MB/s的速度传输数据,
     但这个值在一个有许多不受约束的进程访问一个驱动器的环境中变得并不重要，
     它们可能只完成了这些值的一小部分。这样一种情况下，从磁盘子
     系统的角度来看问题就更加有趣：重要的参数是在子系统上的负
     荷，换句话说是传输占用了驱动器多少时间。</para>

    <para>在任何磁盘传输中, 驱动器必须先寻道, 等待磁头访问第一个扇区,
      然后执行传输.  这些动作看起来可能很细小:
       我们不会感有任何中断。
      </para>

    <para><anchor id="vinum-latency"> 假设传输10&nbsp;kB数据，
      : 现在的高性能磁盘平均寻道时间是3.5ms。
        最快的驱动器可以旋转在15,000 rpm，, 所以平均寻址时间为2ms.
       在70&nbsp;MB/s的速度传输时, 数据的传输时间大约150&nbsp;&mu;s,
      几乎无法和寻址时间相比.  在这样一种情况下, 高效的传输也会降低到
      1&nbsp;MB/s 显然传输的快慢依赖与所传输数据的大小。
      </para>

    <para>对于这个瓶颈的一般和明显的解决方法是采用
      <quote>多个磁盘</quote>:而不是只使用一个大磁盘,
      它使用几个比较小的磁盘联合起来形成一个大的磁盘. 
      每个磁盘都可以独立地进行传输数据，所以通过使用多个磁盘
      大大提高了数据吞吐量。
    </para>

    <para>当然，所要求的吞吐量的提高要比磁盘的数量小得多。
      尽管每个驱动器并行传输数据，但没有办法确保请求能够平均
      分配到每个驱动器上。不可避免一个驱动器的负载可能比另一个要高得多。
     </para>

    <indexterm>
      <primary>磁盘的串连</primary>
    </indexterm>
    <indexterm>
      <primary>Vinum</primary>
      <secondary>串连</secondary>
    </indexterm>

    <para>磁盘的负载平衡很大程度依赖于驱动器上数据的共享方式.
      在下面的讨论中, 将磁盘存储想象成一个巨大的数据扇区，像一本书的页
      那样用编号来设定地址. 最明显的方法是把虚拟磁盘分成许多连续的扇区组，
      每个扇区大小就是独立的磁盘大小，用这种方法来存储数据，
      就像把一本厚厚的书分成很多小的章节。
      这个方法叫做
      <emphasis>串联</emphasis> 它有一个优点就是磁盘不需要
      有任何特定的大小关系。
      当访问到的虚拟磁盘根据它的地址空间来分布的时候，它能工作得
     很好。当访问集中在一个比较小的区域的时候，性能的提高没有显著的改进。
      <xref linkend="vinum-concat"> 
      举例说明了用串联组织的方式来分配存储单元的顺序。
      </para>

    <para>
      <figure id="vinum-concat">
	<title>串联组织</title>
	<graphic fileref="vinum/vinum-concat">
      </figure>
    </para>

    <indexterm>
      <primary>disk striping</primary>
    </indexterm>
    <indexterm>
      <primary>Vinum</primary>
      <secondary>striping</secondary>
    </indexterm>

    <para>另外一种影射方法是把地址空间分布在比较小的容量相同的磁盘上，
     从而能够在不同的设备上存储它们。例如，前256 个扇区可能存储在第一
     个磁盘上，接着的256 个扇区存储在另一个磁盘上等等。 写满最后一个磁
     盘后，进程会重复以前的工作，直到所有的磁盘被写满。这个影射叫做
      <emphasis>分段(striping)</emphasis> 或者 <acronym>RAID-0</acronym>

    <footnote>
      <indexterm><primary>RAID</primary></indexterm>
    
      <para><acronym>RAID</acronym> 代表<emphasis>廉价磁盘容错(Redundant
      Array of Inexpensive Disks)</emphasis> 提供各种容错机制，
      但后面这个术语可能会有些让人误解：它不提供冗余功能。</para> </footnote>.

    分段要求很精确地寻址，通过多个磁盘进行数据传输的时候，它
    可能会引起额外的I/O 负载，但它也可能提供更多的连续负载。
    <xref linkend="vinum-striped"> 显示了用分段形式分配的存储单元的顺序。
    </para>

    <para>
      <figure id="vinum-striped">
        <title>分段组织</title>
	<graphic fileref="vinum/vinum-striped">
      </figure>
    </para>
  </sect1>

  <sect1 id="vinum-data-integrity">
    <title>数据的完整性</title>

      <para>T当前磁盘的最后一个问题是它们不太可靠。虽然磁盘驱动器
      的可靠性在过去几年有了很大的提高，它们仍然是会损坏的服务器的
      最核心组件。当它们发生故障的时候, 结果可能是灾难性的:
       替换一个坏的磁盘驱动器，然后恢复数据可能要花费几天时间。
      </para>

      <indexterm>
	<primary>disk mirroring</primary>
      </indexterm>
      <indexterm>
	<primary>Vinum</primary>
	<secondary>mirroring</secondary>
      </indexterm>
      <indexterm>
	<primary>RAID-1</primary>
      </indexterm>
      
      <para>解决这个问题的传统方法是建立镜象
	<emphasis>镜象</emphasis>, 在不同的物理硬件上对数据做两个拷贝。
	 由于<acronym>RAID</acronym> 的出现levels, 所以这个技术也被叫做
	<acronym>第一级RAID</acronym> 或者
	<acronym>RAID-1</acronym>. 任何写到卷的数据也会被写到镜象上，所
        以可以从任何一个拷贝读取数据，如果其中有一个失败了，数据就可以
        在其他驱动器上访问到。</para>
    
      <para>镜象有两个问题：</para>
    
	<itemizedlist>
	  <listitem>
	    <para>价格.  它需要两倍的存储容量。</para>
	  </listitem>

	  <listitem>
	    <para>性能影响。  写入操作必须在两个驱动器上执行，所以它们
	    花费两倍的带宽。读取数据并不会影响性能：看起来它们会更快。</para>
	  </listitem>
	</itemizedlist>

      <para><indexterm><primary>RAID-5</primary></indexterm>一个
	可选的方案采用 <emphasis>parity</emphasis>,
	其实现了 <acronym>RAID</acronym>  2, 3, 4 和
	5.  当然, <acronym>RAID-5</acronym> 是最有趣的。
	As implemented in Vinum, it is a variant on a
	striped organization which dedicates one block of each stripe
	to parity of the other blocks. As implemented by Vinum, a
	<acronym>RAID-5</acronym> plex is similar to a striped plex,
	except that it implements <acronym>RAID-5</acronym> by
	including a parity block in each stripe.  As required by
	<acronym>RAID-5</acronym>, the location of this parity block
	changes from one stripe to the next.  The numbers in the data
	blocks indicate the relative block numbers.</para>

      <para>
	<figure id="vinum-raid5-org">
	  <title>RAID-5 Organization ** 翻译进行中 **</title>
	  <graphic fileref="vinum/vinum-raid5-org">
	</figure>
      </para>

      <!-- WIP -->
      <para>本节尚未翻译</para>
  </sect1>

  <sect1 id="vinum-objects">
    <title>Vinum 目标</title>
      <para>为了解决这些问题，Vinum 提出了一个四层的目标结构：</para>

      <itemizedlist>
	<listitem>
	  <para>T最显著的目标是虚拟磁盘, 叫做
	    <emphasis>卷(volume)</emphasis>.  卷本质上与一个UNIX 磁盘
	    驱动器有同样的属性，虽然它们是有些不太一样。它们没有大小的限制。
	    </para>
	</listitem>

	<listitem>
	  <para>卷下面是 <emphasis>plexes</emphasis>,
	    每一个表示卷的所有地址空间。在层次结构中的这个水平能够提供
	    冗余功能。可以把plex 想象成用一个镜象排列的方式组织起来的
	    独立磁盘，每个都包含同样的数据。</para>
	</listitem>

	<listitem>
	  <para>由于Vinum 存在于UNIX 磁盘存储框架中,所以它也可能
	  使用UNIX 分区作为多个磁盘plex 的组成部分,
	   但事实上这并不可靠:UNIX 磁盘只能有有限数量的分区。
	    取而代之，Vinum 把一个简单的UNIX 分区 (the <emphasis>drive</emphasis>)
	    分解成叫做<emphasis>subdisks</emphasis>的相邻区域, 它可以使用这个
           来为plex 建立块。</para>
	</listitem>
      
	<listitem>
	  <para>Subdisks 位于 Vinum <emphasis>驱动器上</emphasis>,
	   当前的UNIX 分区。Vinum 驱动器可以包含很多的subdisks。
	    除了驱动器开始的一小块区域用来存储配置和描述信息以外，整个
	    驱动器都可以用于存储数据。</para>
	</listitem>
      </itemizedlist>

      <para>下面的章节描述了这些目标提供了Vinum 所要求的功能的方法。</para>

    <sect2>
      <title>卷的大小要求</title>

      <para>在Vinum的配置中，Plex可以把多个subdisk 分布在所有的驱动上。
       结果, 每个独立的驱动器的大小都不会限制plex 的大小，从而不会限制卷的大小
	</para>
    </sect2>
    
    <sect2>
      <title>多余的数据存储</title>
      <para>Vinum 通过给一个卷连上多个plex 来完成镜象的功能。
	每个plex 是一个在一个卷中的数据的描述。一个卷可以包含一个
	到八个plex。</para>

      <para>Although虽然一个plex 描述了一个卷的所有数据，,
	但可能描述的部分被物理地丢失了。可能是设计的问题
	（没有为plex 部分定义一个subdisk）也可能是意外的故障
	（由于驱动器的故障导致）。只要至少有一个plex 能够为
	 卷的完全地址范围提供数据，卷就能够正常工作。
	</para>
    </sect2>
    
    <sect2>
      <title>性能问题</title>

      <para>Vinum 在plex 水平既执行串联也执行分段：</para>

      <itemizedlist>
	<listitem>
	  <para>一个<emphasis>串连的plex</emphasis>轮流使用
	    每个subdisk 的地址空间。</para>
	</listitem>

	<listitem>
	  <para>一个 <emphasis>分段的plex</emphasis> 在每个subdisk 上
	  划分数据. Subdisk 必须是大小一样的，为了从一个连接的plex 中
	  区分开它，必须至少有两个subdisk。 </para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>哪种plex 组织更有效？</title>
      <para>FreeBSD &rel.current提供的Vinum 版本能实现两种plex:</para>
    
      <itemizedlist>
	<listitem>
	  <para>串联的plex 更加灵活：它们可以包含任何数量的subdisk，
	  subdisk 也可能有不同的长度。Plex 可以通过添加额外的subdisk 
	  来得到扩展。 它们需要更少的
	    <acronym>CPU</acronym> 时钟相对分段plexes, 尽管
	     <acronym>CPU</acronym> 上的负载差异是不可测量的。
	      另一方面，它们的负载可能不平衡，一个磁盘可能负载很重，
	      而其他的可能很空闲。</para>
        </listitem>

	<listitem>
	  <para>分段(<acronym>RAID-0</acronym>) plexes 的最大优点是
	  它们减少了负载不平衡的情况: 通过选择一个最合适大小的分段
	  (大约是256&nbsp;kB), 您甚至可以在各个组成的驱动器上降低负载
	    .  这种方法的缺点是在subdisk 上受到非常复杂的编码限制
	    : 它们必须是同样大小, 通过添加新的subdisk 来扩展一个plex 
	    是非常复杂的,以至Vinum 当前没有实现它.  Vinum 利用一个额外
	    的，代价不高的限制：一个分段的plex 必须有至少两个subdisk，
	    因为否则的话，它是无法从一个连接的plex 进行区分的。</para>
	</listitem>
      </itemizedlist>
    
      <para><xref linkend="vinum-comparison"> 总结一下每个plex 组织
      的优点和缺点.</para>
    
      <table id="vinum-comparison" frame="none">
	<title>Vinum Plex组织图</title>
	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>Plex 类型</entry>
	  	<entry>最少subdisks</entry>
	  	<entry>可否添加subdisks</entry>
	  	<entry>必须相同大小</entry>
	  	<entry>应用</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>串联 </entry>
	      <entry>1</entry>
	      <entry>可以</entry>
	      <entry>不可以</entry>
	      <entry>带有很大弹性和适中性能的大数据量存储。
	        </entry>
	    </row>
	    
	    <row>
	      <entry>分段</entry>
	      <entry>2</entry>
	      <entry>不可以</entry>
	      <entry>可以</entry>
	      <entry>大量并发访问时,具有较高性能。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>
  
  <sect1 id="vinum-examples">
    <title>一些例子</title>

    <para>Vinum 维护着一个描述以一个独立系统为目标
    <emphasis>配置数据库</emphasis>的。最初，用户通过&man.vinum.8;
    工具的帮助从一个或多个配置文件创建配置数据库。Vinum 在它的控制
    下在每个磁盘(Vinum 叫 <emphasis>device</emphasis>) 上存储一个
    它的配置数据库的拷贝。这个数据库在每个状态变化的时候被升级，
    以便能精确地回复每个Vinum 目标的状态。
     </para>
  
    <sect2>
      <title>配置文件</title>
      <para>配置文件描述了独立的 Vinum.一个简单卷的定义可能是这样的:</para>

      <programlisting>
    drive a device /dev/da3h
    volume myvol
      plex org concat
        sd length 512m drive a</programlisting>

      <para>这个文件描述了四个Vinum 目标:</para>

      <itemizedlist>
	<listitem>
	  <para><emphasis>drive</emphasis> 行描述了一个磁盘分区（驱动器）
	    和与下面的硬件相关的它的位置。它给出了一个符号名
	     <emphasis>a</emphasis>.  这个与设备名称分开的符号名允许
	     磁盘从一个位置移动到另一个位置而不会搞混。
	    </para>
	</listitem>

	<listitem>
	  <para> <emphasis>volume</emphasis> 行描述了一个卷。
	    唯一的必须属性是名称，在这个例子中是
	    <emphasis>myvol</emphasis>.</para>
	</listitem>

	<listitem>
	  <para><emphasis>plex</emphasis> 行定义了一个plex。
	    唯一需要的参数是组织,在这个例子中是
	    <emphasis>concat</emphasis>. 没有名称是必然的:
	    系统自动通过添加suffix
	    <emphasis>.p</emphasis><emphasis>x</emphasis>px 
	    来从卷名称产生一个名字,这里的<emphasis>x</emphasis> 
	    是在卷中的plex 的编号。而这个plex 将被
	    叫做<emphasis>myvol.p0</emphasis>。</para>
	      
	    
	</listitem>

	<listitem>
	  <para> <emphasis>sd</emphasis> 行描述了一个subdisk。
	    最小的说明是存储subdisk 的驱动器名称，和subdisk 的长度。
	    对于plex，没有名称也是必然的：系统自动通过添加
	    suffix <emphasis>.s</emphasis><emphasis>x</emphasis> 
	    来分配源自plex 的名称，这里 <emphasis>x</emphasis>是plex 中subdisk 的编号。
	    Vinum 给这个subdisk 命名为<emphasis>myvol.p0.s0</emphasis>。</para>
	</listitem>
      </itemizedlist>

      <para>处理完这个文件后, &man.vinum.8会产生下面的输出：</para>

      <programlisting width="97">
      &prompt.root; vinum -&gt; <userinput>create config1</userinput>
      Configuration summary
      Drives:         1 (4 configured)
      Volumes:        1 (4 configured)
      Plexes:         1 (8 configured)
      Subdisks:       1 (16 configured)
     
	D a                     State: up       Device /dev/da3h        Avail: 2061/2573 MB (80%)
	
	V myvol                 State: up       Plexes:       1 Size:        512 MB
	
	P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
	
	S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB</programlisting>

      <para>这个输出显示了&man.vinum.8简要的列表格式。
	 图<xref linkend="vinum-simple-vol">中它用图形来表示这一点。</para>

      <para>
	<figure id="vinum-simple-vol">
	  <title>一个简单的Vinum 卷</title>
	  <graphic fileref="vinum/vinum-simple-vol">
	</figure>
      </para>

      <para>下面这个图显示了一个由按顺序排列的subdisk 组成的plex。
      在这个小小的例子中，卷包含一个plex，plex 包含一个subdisk。
      </para>

      <para>这个特殊的卷与一个传统的磁盘分区没有什么特别的优势。
      下面的章节会描述到几个非常有趣的配置方法。
      This particular volume has no specific advantage over a
	conventional disk partition.  It contains a single plex, so it
	is not redundant.  The plex contains a single subdisk, so
	there is no difference in storage allocation from a
	conventional disk partition.  The following sections
	illustrate various more interesting configuration
	methods.</para>
    </sect2>

    <sect2>
      <title>增强的可靠性：镜象 ** 翻译进行中 **</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Optimizing Performance ** 翻译进行中 **</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Resilience and Performance ** 翻译进行中 **</title>

      <para><anchor id="vinum-resilience"></para>

      <para>
	<figure id="vinum-raid10-vol">
	  <title>A Mirrored, Striped Vinum Volume</title>
	  <graphic fileref="vinum/vinum-raid10-vol">
        </figure>
      </para>
    </sect2>
  </sect1>
  
  <sect1 id="vinum-object-naming">
    <title>Object Naming ** 翻译进行中 **</title>

    <para></para>

    <sect2>
      <title>Creating File Systems ** 翻译进行中 **</title>

	<para></para>

    </sect2>
  </sect1>
  
  <sect1 id="vinum-config">
    <title>Configuring Vinum  ** 翻译进行中 **</title>

    <para></para>


    <sect2>
      <title>Startup  ** 翻译进行中 **</title>

      <para></para>
  
      <sect3 id="vinum-rc-startup">
	<title>Automatic Startup ** 翻译进行中 **</title>

        <para></para>

      </sect3>
    </sect2>
  </sect1>

  <sect1 id="vinum-root">
    <title>Using Vinum for the Root Filesystem ** 翻译进行中 **</title>

    <para></para>

    <sect2>
      <title>Starting up Vinum Early Enough for the Root
	Filesystem  ** 翻译进行中 **</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Making a Vinum-based Root Volume Accessible to the
	Bootstrap  ** 翻译进行中 **</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Example of a Vinum-based Root Setup ** 翻译进行中 **</title>

      <para></para>
    </sect2>

    <sect2>
      <title>Troubleshooting ** 翻译进行中 **</title>

      <sect3>
	<title>System Bootstrap Loads, but System Does Not Boot</title>
	<para></para>
      </sect3>

      <sect3>
	<title>Only Primary Bootstrap Loads ** 翻译进行中 **</title>

	<para></para>
      </sect3>

      <sect3 id="vinum-root-panic">
	<title>Nothing Boots, the Bootstrap
	  Panics ** 翻译进行中 **</title>

	<para></para>
      </sect3>
    </sect2>

    <sect2 id="vinum-root-4x">
      <title>Differences for FreeBSD 4.X ** 翻译进行中 **</title>

      <para></para>
    </sect2>
  </sect1>
</chapter>

