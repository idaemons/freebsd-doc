<!--
     The FreeBSD Mongolian Documentation Project

     Original revision 1.321

     $FreeBSD$
-->

<chapter id="security">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Мэтью</firstname>
	<surname>Диллон</surname>
	<contrib>Энэ бүлгийн ихэнх хэсгийг security(7) гарын авлагын хуудаснаас авсан бөгөөд
		security(7) гарын авлагын хуудсыг бичсэн </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Цагаанхүүгийн</firstname>
	<surname>Ганболд</surname>
	<contrib>Орчуулсан  </contrib>
 	<!-- Dec 2006 -->
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Аюулгүй байдал</title>
  <indexterm><primary>аюулгүй байдал</primary></indexterm>

  <sect1 id="security-synopsis">
    <title>Ерөнхий агуулга</title>

    <para>Энэ бүлэг нь системийн аюулгүй байдлын ухагдахуунуудын үндэс, зарим нэг нийтлэг  
	практикийн сайн аргууд болон &os; дэх зарим нэг дэвшилттэй сэдвүүдийг
	танилцуулах болно. Энд дурдагдсан олон сэдвүүдийг бас системийн болон Интернэтийн 
	аюулгүй байдалд хэрэглэж болох юм. Интернэт нь хүн бүр таны найрсаг хөрш байхыг 
	хүсдэг <quote>найзархаг</quote> газар байхаа аль хэдийн больсон. 
	Өөрийн системийг аюулгүй болгох нь таны өгөгдөл, оюуны өмч, цаг хугацаа зэрэг 
	олон зүйлсийг хакерууд зэргийн савраас хамгаалахад хойшлуулашгүй чухал юм.</para>

    <para>&os; нь таны систем болон сүлжээний аюулгүй байдал болон бүрэн бүтэн байдлыг 
	хангаж байдаг хэрэгслүүд болон арга замуудын цуглуулгыг агуулдаг.</para>

    <para>Энэ бүлгийг уншсаны дараа, та дараах зүйлсийг мэдэх болно:</para>

    <itemizedlist>
      <listitem>
	<para>&os;-ийн хувьд системийн аюулгүй байдлын үндсэн ухагдахуунууд.</para>
      </listitem>

      <listitem>
	<para>&os;-д байдаг <acronym>DES</acronym> болон <acronym>MD5</acronym> 
	зэрэг төрөл бүрийн нууцлах арга замуудын талаар.</para>
      </listitem>

      <listitem>
	<para>Нэг удаагийн нууц үгийн нэвтрэлтийг хэрхэн тохируулах талаар.</para>
      </listitem>

      <listitem>
	<para><acronym>TCP</acronym> Wrappers буюу 
	<acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдыг <application>inetd</application>-д ашиглан 
	хэрхэн тохируулах талаар.</para>
      </listitem>

      <listitem>
	<para>&os;-ийн 5.0-с өмнөх хувилбарууд дээр <application>KerberosIV</application>-г 
	хэрхэн тохируулах талаар.</para>
      </listitem>

      <listitem>
	<para>&os; дээр <application>Kerberos5</application>-г хэрхэн тохируулах талаар.</para>
      </listitem>

      <listitem>
	<para>IPsec-г хэрхэн тохируулж &os;/&windows; машинуудын хооронд 
	<acronym>VPN</acronym> үүсгэх талаар.</para>
      </listitem>
     
      <listitem>
	<para>&os;-ийн <acronym>SSH</acronym> шийдэл болох <application>OpenSSH</application>-г 
	хэрхэн тохируулж ашиглах талаар.</para>
      </listitem>

      <listitem>
	<para>Файлын системийн  <acronym>ACL</acronym>-үүд гэж юу болох, тэдгээрийг 
	хэрхэн ашиглах талаар.</para>
      </listitem>

      <listitem>
	<para><application>Portaudit</application> хэрэгслийг хэрхэн ашиглаж 
	Портын цуглуулгаас суулгагдсан гуравдагч програм хангамжийн багцуудыг аудит хийх талаар.</para>
      </listitem>

      <listitem>
	<para>&os;-ийн аюулгүй байдлын зөвлөмжүүдийн сонордуулгуудыг хэрхэн хэрэглэх талаар.</para>
      </listitem>

      <listitem>
	<para>Процессийн Бүртгэл хөтлөх гэж юу болох талаар ойлголттой болж 
	түүнийг &os; дээр хэрхэн идэвхжүүлэх талаар.</para>
      </listitem>
    </itemizedlist>

    <para>Энэ бүлгийг уншихаасаа өмнө, та дараах зүйлсийг мэдэх шаардлагатай:</para>

    <itemizedlist>
      <listitem>
	<para>&os; болон Интернэтийн үндсэн ухагдахуунуудыг ойлгох.</para>
      </listitem>
    </itemizedlist>

    <para>Энэ номонд нийтдээ аюулгүй байдлын нэмэлт сэдвүүд хамрагдсан болно.
	Жишээ нь Mandatory Access Control буюу 
	Шаардлагатай Хандалтын Хяналт <xref linkend="mac">-д,  
	Интернэт галт ханануудын талаар <xref linkend="firewalls">-д 
	хэлэлцэгдсэн байгаа.</para>
  </sect1>

  <sect1 id="security-intro">
    <title>Танилцуулга</title>

    <para>Аюулгүй байдал нь системийн администратораас эхэлж түүнтэй дуусдаг 
	үйл ажиллагаа юм. BSD &unix; олон хэрэглэгчийн системүүд нь угаасаа 
	зарим нэг аюулгүй байдлыг хангаж байдаг боловч тэдгээр хэрэглэгчдийг  
	<quote>үнэнч</quote> байлгахыг эрмэлздэг аюулгүй байдлын нэмэлт 
	арга замуудыг бүтээж түүний ажиллагааг хангах ажил нь сисадмины магадгүй 
	ганц, хамгийн том үүргүүдийн нэг юм. Таныг аюулгүй болгосон зөвхөн тэр 
	хэмжээгээр машинууд нь аюулгүй байдаг бөгөөд аюулгүй байдлын санаа зовнилууд 
	нь хүний ая тухтай хялбар байлгах гэсэн хэрэгцээтэй үргэлж тэмцэлдэж байдаг. Ерөнхийдөө 
	&unix; системүүд нь асар олон тооны зэрэгцээ процессуудыг ажиллуулах 
	чадвартай бөгөөд эдгээр процессуудын ихэнх нь серверүүд болон ажилладаг 
	&mdash; энэ нь гаднын зүйлс тэдэнтэй холбогдож ярилцах боломжтой 
	гэсэн үг юм. Өчигдрийн миникомпьютерууд, мэйнфрэймүүдээс өнөөгийн 
	ширээний компьютерууд болж компьютерууд нь сүлжээнд холбогдож  
	сүлжээнүүд нь хоорондоо холбогдох тусам аюулгүй байдал нь улам илүү том 
	асуудал болсоор байна.</para>

    <para>Системийн аюулгүй байдал нь сүйрүүлэхийг оролдсон эсвэл системийг 
	ашиглагдахааргүй болгох гэсэн, гэхдээ <username>root</username> 
	бүртгэлийг буулган авах (<quote>root-г эвдэх</quote>) оролдлого 
	хийдэггүй, халдлагууд зэрэг төрөл бүрийн халдлагуудыг зогсоохтой бас 
	хамааралтай юм. Аюулгүй байдлын санаа зовнилуудыг хэд хэдэн зэрэглэлд 
	хувааж болно:</para>

    <orderedlist>
      <listitem>
	<para>Үйлчилгээг зогсоох халдлагууд.</para>
      </listitem>

      <listitem>
	<para>Хэрэглэгчийн бүртгэл буулган авалтууд.</para>
      </listitem>

      <listitem>
	<para>Хандаж болох серверүүдээр дамжин root-г буулган авах.</para>
      </listitem>

      <listitem>
	<para>Хэрэглэгчийн бүртгэлүүдээс дамжин root-г буулган авах.</para>
      </listitem>

      <listitem>
	<para>Арын хаалга үүсгэлт.</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>DoS халдлагууд</primary>
      <see>Үйлчилгээг Зогсоох (DoS)</see>
    </indexterm>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>DoS халдлагууд</secondary>
      <see>Үйлчилгээг Зогсоох (DoS)</see>
    </indexterm>
    <indexterm><primary>Үйлчилгээг Зогсоох (DoS)</primary></indexterm>

    <para>Үйлчилгээг зогсоох халдлага нь машиныг хэрэгцээтэй эх үүсвэрээс нь салгах 
	үйлдэл юм. Ихэвчлэн DoS халдлагууд нь сүйрүүлэхийг оролдсон эсвэл 
	машиныг түүн дээрх серверүүд болон сүлжээний стекийг эзэмдэн ашиглах 
	боломжгүй болгодог балмадаар хүчлэх арга замууд юм. Зарим DoS халдлагууд 
	нь сүлжээний стек дэх алдаануудыг ашиглан ганц пакетаар машиныг сүйрүүлэхийг 
	оролддог. Үүнийг зөвхөн алдааны засварыг цөмд хийснээр засах боломжтой. 
	Систем дээрх хөнөөлтэй нөхцөлд байх тэр серверийн дуудлагыг хязгаарладаг 
	тохируулгуудыг зөв зааж серверүүд уруу хийсэн халдлагуудыг ихэвчлэн засаж болдог. 
	Сүлжээний балмадаар хүчлэх халдлагуудын эсрэг арга хэмжээ авахад илүү 
	төвөгтэй байдаг. Жишээ нь хууран мэхэлсэн пакетийн халдлагыг зогсоох 
	бараг л боломжгүй, таны системийг Интернэтээс салгахад хүргэж болох юм.
	Энэ нь таны машиныг зогсоож чадахгүй байж болох боловч таны Интернэтийн 
	холболтыг дүүргэж болно.</para>

    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>бүртгэл буулган авалтууд</secondary>
    </indexterm>

    <para>Хэрэглэгчийн бүртгэлийг буулган авах халдлага нь DoS халдлагаас илүү их 
	тохиолддог. Одоо болтол олон сисадминууд стандарт <application>telnetd</application>, 
	<application>rlogind</application>, <application>rshd</application>,
      болон <application>ftpd</application> серверүүдийг өөрсдийн машинууд 
	дээр ажиллуулсаар байна. Анхдагчаар серверүүд нь шифрлэсэн холболт дээр 
	ажилладаггүй. Ийм холболт дээр хэрэв та багагүй хэмжээний хэрэглэгчидтэй 
	бөгөөд тэдгээр хэрэглэгчдээс нэг болон хэд хэд нь алсаас (энэ нь систем уруу нэвтрэн 
	орох хамгийн нийтлэг тав тухтай арга юм) таны систем уруу нэвтрэн 
	орж байгаа бол тэдгээр хэрэглэгчийн  нууц үг дундаасаа сүлжээгээр шиншлэгдэн алдагдах 
	боломжтой байдаг. Анхааралтай системийн админ тэр хэрэглэгчийн 
	алсаас хандсан бүртгэлүүд дээрээс бүр амжилттай болсон нэвтрэлтүүдэд хүртэл сэжигтэй 
	эхлэл  хаягууд  байгаа эсэхийг хайн шинжилдэг.</para>

    <para>Халдагч хэрэглэгчийн бүртгэлд хандаж чадсаны дараа <username>root</username>-г 
	бас эвдэж чадна гэдгийг үргэлж бодож байх хэрэгтэй. Гэхдээ жинхэнэ амьдрал дээр бол 
	сайн аюулгүй байдлыг хангаж нууцлаг болгосон байнга ажиллагааг нь хянаж байдаг систем дээр 
	хэрэглэгчийн бүртгэлд хандах нь халдагч заавал ч үгүй <username>root</username> 
	эрхэд хандаж чадна гэсэн үг биш юм. Энэ ялгааг зөв салгаж ойлгох хэрэгтэй. Учир нь 
	<username>root</username> уруу хандах боломжгүй халдагч ерөнхийдөө өөрийн 
	мөрийг баллаж нууж чаддаггүй бөгөөд тухайн хэрэглэгчийн файлуудыг замбараагүйтүүлэх 
	эсвэл машиныг сүйрүүлэхээс илүүтэйг хийж чаддаггүй. Хэрэглэгчид нь сисадминууд шиг 
	аюулгүй байдлын арга хэмжээг тэр болгон авдаггүй болохоор хэрэглэгчийн бүртгэлийн 
	буулган авалт нь маш элбэг байдаг юм.</para>

    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>арын хаалганууд</secondary>
    </indexterm>

    <para>Машин дээрх <username>root</username> бүртгэлийг эвдэх боломжит олон 
	аргууд байдгийг системийн администраторууд санаж байх хэрэгтэй. Халдагч нь 
	<username>root</username>-н нууц үгийг мэдэж болно. Эсвэл халдагч root 
	эрхээр ажилладаг серверт алдаа олж сүлжээгээр тэр сервер уруу дамжин орж
	<username>root</username>-г эвдэж болно. Эсвэл халдагч нь suid-root 
	програмд алдаа байгааг мэдэж хэрэглэгчийн бүртгэлийг эвдэн орсныхоо дараа 
	тэр алдаагаар дамжин <username>root</username>-г эвдэн орж болох юм.
	Хэрэв халдагч машин дээрх <username>root</username>-г эвдэх аргаа 
	олсон бол заавал арын хаалга суулгах шаардлагагүй болж болох юм. 
	<username>root</username>-н цоорхойнуудын олонхийг тухайн үед аль хэдийн 
	олоод хаачихсан байдаг бөгөөд энэ үед халдагчид өөрийн мөрөө цэвэрлэхэд ихээхэн 
	ажиллагаа шаарддаг болохоор ихэнх халдагчид арын хаалга суулгадаг. 
	Арын хаалга нь систем уруу хандах <username>root</username> хандалтыг 
	халдагчид амархнаар дахин олж авах боломжийг олгодог боловч энэ нь ухаалаг системийн 
	администраторт халдлагыг амархнаар илрүүлэх боломжийг бас олгодог юм. 
	Халдагчийн хамгийн эхлээд эвдэн орсон цоорхойг хааж чаддаггүй болохоор арын хаалга 
	суулгахыг  боломжгүй болгох нь магадгүй таны аюулгүй байдалд ашиггүй байж болох юм.</para>

    <para>Аюулгүй байдлын засварууд нь олон давхраатай <quote>сонгины хальс</quote> 
	хандлагаар үргэлж шийдэгдэж байх шаардлагатай бөгөөд тэдгээрийг дараах маягаар 
	зэрэглэж болно:</para>

    <orderedlist>
      <listitem>
	<para><username>root</username> болон staff бүртгэлүүдийг нууцлаг/аюулгүй болгох.</para>
      </listitem>

      <listitem>
	<para><username>root</username>&ndash;ажилладаг серверүүд 
	болон suid/sgid хоёртын файлуудыг аюулгүй болгох.</para>
      </listitem>

      <listitem>
	<para>Хэрэглэгчийн бүртгэлүүдийг аюулгүй болгох.</para>
      </listitem>

      <listitem>
	<para>Нууц үгийн файлыг аюулгүй болгох.</para>
      </listitem>

      <listitem>
	<para>Цөмийн гол хэсэг, түүхий төхөөрөмжүүд болон 
	файлын системүүдийг аюулгүй болгох.</para>
      </listitem>

      <listitem>
	<para>Системд хийгдсэн зохисгүй өөрчлөлтүүдийг түргэн илрүүлэх.</para>
      </listitem>

      <listitem>
	<para>Параной буюу хэт зовнил.</para>
      </listitem>
    </orderedlist>

    <para>Энэ бүлгийн дараагийн хэсэг нь дээр дурдсан зүйлсүүдийг илүү гүнзгийгээр 
	авч үзэх болно.</para>
  </sect1>

  <sect1 id="securing-freebsd">
    <title>&os;-н аюулгүй байдлыг хангах нь</title>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>&os;-н аюулгүй байдлыг хангах нь</secondary>
    </indexterm>

    <note>
      <title>Тушаалыг Протоколтой харьцуулахад (Command vs. Protocol)</title>
      <para>Энэ баримтын туршид бид <application>тод</application> текстээр 
	програмыг <command>monospaced</command> фонтоор тусгай тушаалуудыг 
	тэмдэглэх болно. Протоколууд ердийн фонт ашиглах болно. Тэмдэглэгээний энэ 
	ялгаа нь ssh зэргийн хувьд ашигтай, учир нь энэ ssh нь протоколоос гадна 
	бас тушаал юм.</para>
    </note>

    <para>Үүнээс хойшх хэсгүүд нь түрүүчийн бүлгийн <link linkend="security-intro">
	сүүлийн хэсэг</link>т дурдсан таны &os; системийг аюулгүй болгох аргуудыг 
	авч үзнэ.</para>

    <sect2 id="securing-root-and-staff">
      <title><username>root</username> бүртгэл болон staff бүртгэлүүдийг 
	аюулгүй болгох</title>
      <indexterm>
        <primary><command>su</command></primary>
      </indexterm>

      <para>Эхлээд хэрэв та <username>root</username> бүртгэлийг аюулгүй болгоогүй 
	бол staff бүртгэлүүдийг аюулгүй болгоход санаа зовсны хэрэггүй. Ихэнх системүүд 
	<username>root</username> бүртгэлд нууц үг өгсөн байдаг. Таны эхний хийх 
	зүйл бол нууц үг <emphasis>үргэлж</emphasis> эвдэгдэж болно гэдгийг 
	бодох хэрэгтэй. Энэ нь та нууц үгээ устгах хэрэгтэй гэсэн үг биш юм. Нууц үг нь 
	машин уруу консол хандалт хийхэд үргэлж хэрэгтэй байдаг. Энэ нь юу гэсэн үг вэ 
	гэхээр та нууц үгийг консолоос гадна эсвэл болж өгвөл бүр &man.su.1; тушаалтай 
	ашиглаж болохоор хийх ёсгүй гэсэн үг юм. Жишээ нь 
	<command>telnet</command> эсвэл <command>rlogin</command>-р хийгдэх 
	шууд <username>root</username> нэвтрэлтүүдийг хаах pty-уудын тохиргоог insecure 
	буюу аюултай гэж <filename>/etc/ttys</filename> файлд заасан эсэхийг шалгаарай. 
	Хэрэв бусад нэвтрэх үйлчилгээнүүд болох <application>sshd</application> 
	зэргийг ашиглаж байгаа бол шууд <username>root</username> нэвтрэлтүүдийг 
	бас хаасан эсэхийг шалгаарай. Та үүнийг <filename>/etc/ssh/sshd_config</filename> 
	файлыг засварлан <literal>PermitRootLogin</literal> тохируулгыг 
	<literal>NO</literal> болгон зааж өгөөрэй. Хандах арга бүр &mdash;
	FTP зэрэг үйлчилгээнүүдээр ихэвчлэн эвдлэн ордог болохыг бодолцох хэрэгтэй. 
	Шууд <username>root</username> нэвтрэлтүүд зөвхөн системийн консолоор хийгдэхэд  
	зөвшөөрөгдөх ёстой.</para>
      <indexterm>
        <primary><groupname>wheel</groupname></primary>
      </indexterm>

      <para>Мэдээж систем админы хувьд та <username>root</username> 
	уруу орж чадаж байх ёстой болохоор бид хэдэн цоорхой үлдээдэг. 
	Гэхдээ эдгээр цоорхойнууд нь нэмэлт нууц үг шалгаж ажилладаг байхаар 
	бид хийдэг. <username>root</username>-г хандах боломжтой 
	байлгах нэг арга нь тохирох staff бүртгэлүүдийг <groupname>wheel</groupname> 
	бүлэгт (<filename>/etc/group</filename> файлд) нэмэх явдал юм. 
	<groupname>wheel</groupname> бүлэгт оруулсан staff-ийн гишүүдэд 
	<username>root</username> уруу <command>su</command> хийхийг 
	зөвшөөрдөг. Та staff-ийн гишүүдийг тэдгээрийн нууц үгийн оруулгад 
	<groupname>wheel</groupname> бүлэгт оруулан байрлуулж  анхнаас нь 
	<groupname>wheel</groupname> хандалт өгч хэзээ ч болохгүй. 
	Staff бүртгэлүүдийг <groupname>staff</groupname> бүлэгт 
	оруулах ёстой бөгөөд тэгээд дараа нь <filename>/etc/group</filename> 
	файлын <groupname>wheel</groupname> бүлэгт нэмэх ёстой. 
	Зөвхөн <username>root</username> хандалт заавал шаардлагатай 
	тийм staff-ийн гишүүдийг <groupname>wheel</groupname> бүлэгт 
	оруулах ёстой. Kerberos зэрэг жинхэнээ шалгуулж нэвтрэх аргыг ашиглаж 
	байх тохиолдолд заавал <groupname>wheel</groupname> бүлэгт оруулалгүйгээр 
	<username>root</username> бүртгэл дэх Kerberos-ийн 
	<filename>.k5login</filename> файлыг ашиглаж 
	<username>root</username> уруу &man.ksu.1; хийхийг зөвшөөрөх 
	бас боломжтой байдаг. Энэ нь магадгүй давуу шийдэл байж болох юм. 
	Учир нь хэрэв халдагч таны нууц үгийн файлыг олж аван staff бүртгэлийг 
	эвдлэн орж чадах бол <groupname>wheel</groupname> арга нь 
	халдагчид <username>root</username>-г эвдэх боломжийг олгосон хэвээр 
	байдаг юм. <groupname>wheel</groupname> аргатай байх нь огт аргагүй 
	байхаас илүү боловч энэ нь заавал ч үгүй хамгийн аюулгүй сонголт бас биш 
	юм.</para>

      <para>Бүртгэлийг бүрэн түгжихийн тулд &man.pw.8; тушаалыг ашиглах 
	хэрэгтэй:</para>

      <screen>&prompt.root;<userinput>pw lock <replaceable>staff</replaceable></userinput></screen>

      <para>Энэ нь &man.ssh.1;-ийг оролцуулаад хэрэглэгчийг ямар ч 
	арга ашиглан нэвтрэн орохыг хориглоно.</para>

      <para>Бүртгэлүүдэд хандахыг хориглох өөр нэг арга бол 
	нууцлагдсан нууц үгийг ганц <quote><literal>*</literal></quote>  
	тэмдэгтээр солих явдал юм. Энэ тэмдэгт нь нууцлагдсан 
	нууц үгтэй хэзээ ч таарахгүй бөгөөд хэрэглэгчийн 
	хандалтыг хаах болно. Жишээ нь доор дурдсан staff бүртгэлийг:</para>

      <programlisting>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Ийм болгон өөрчлөх хэрэгтэй:</para>

      <programlisting>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Энэ нь <username>foobar</username> хэрэглэгчийг ердийн 
	аргууд ашиглан нэвтрэн орох боломжийг хаадаг. Энэ хандалт 
	хязгаарлах арга нь <application>Kerberos</application> ашиглаж 
	байгаа сайтууд эсвэл хэрэглэгч &man.ssh.1; ашиглан түлхүүрүүд 
	тохируулсан тохиолдлууд зэрэгт ажилладаггүй.</para>

      <para>Эдгээр аюулгүй байдлын арга замууд нь бас таныг илүү хязгаарласан 
	серверээс арай бага хязгаарласан машин уруу нэвтрэн орж байна гэж тооцдог. 
	Жишээ нь хэрэв таны гол хайрцаг чинь бүх л төрлийн серверүүд ажиллуулж байвал 
	таны ажлын компьютер чинь ямрыг ч ажиллуулах ёсгүй. Өөрийн компьютерийг 
	боломжийн аюулгүй болгохын тулд та ерөөсөө сервергүй болтол аль болох цөөн 
	сервер ажиллуулах хэрэгтэй бөгөөд та нууц үгээр хамгаалагдсан дэлгэц хоослогч 
	ажиллуулах хэрэгтэй. Мэдээж ажлын компьютер уруу физик хандалт өгвөл 
	халдагч ямар ч төрлийн аюулгүй байдлыг та хангасан байлаа гэсэн эвдэж 
	чадна. Энэ нь таны бодох ёстой асуудлын нэг юм. Гэхдээ эвдлэн оролтуудын 
	олонхи нь алсаас сүлжээгээр дамжин таны ажлын компьютер эсвэл серверүүдэд 
	физик хандалт байхгүй хүмүүсээс ирдэг гэдгийг та бас л бодолцох хэрэгтэй юм.</para>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>Kereberos мэтийг ашиглах нь танд staff бүртгэлийн нууц үгийг нэг газар 
	өөрчлөх эсвэл хаах боломжийг олгох бөгөөд staff-ийн гишүүдийн бүртгэл байж болох 
	бүх машинууд дээр нэн даруй бас үйлчилдэг. Хэрэв staff-ийн гишүүний бүртгэл 
	эвдэгдсэн бол түүний нууц үгийг бүх машинууд дээр нэн даруй өөрчлөх тэр боломжийг 
	дутуу үнэлэх ёсгүй юм. Тусдаа байгаа нууц үгүүдийг N машинууд дээр өөрчлөх нь 
	зовлонтой байдаг. Мөн та Kerberos-д нууц үг дахин өгөлтийг ноогдуулж болох 
	бөгөөд Kerberos тасалбарыг хэсэг хугацааны дараа дуусдагаар хийж болохоос 
	гадна Kerberos систем нь тодорхой хугацааны (жишээ нь сар бүр) дараа 
	хэрэглэгчийг шинэ нууц үг сонгохыг шаарддагаар бас тохируулж болдог.</para>
    </sect2>

    <sect2>
      <title>root-ажилладаг серверүүд болон suid/sgid хоёртын файлуудыг аюулгүй болгох</title>

      <indexterm>
        <primary><command>ntalk</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>comsat</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>finger</command></primary>
      </indexterm>
      <indexterm>
        <primary>sandboxes</primary>
      </indexterm>
      <indexterm>
        <primary><application>sshd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>telnetd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>rshd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>rlogind</application></primary>
      </indexterm>

      <para>Хянамгай сисадмин илүү ч үгүй дутуу ч үгүй зөвхөн өөрийн хэрэгтэй серверүүдийг 
	ажиллуулдаг. Гуравдагч талын серверүүд ихэвчлэн хамгийн алдаатай байх 
	хандлагатай гэдгийг санаж байх хэрэгтэй. Жишээ нь 
	<application>imapd</application> эсвэл 
	<application>popper</application> серверийн хуучин хувилбарыг 
	ажиллуулна гэдэг нь универсал <username>root</username> тасалбарыг 
	бүх дэлхийд өгч байна гэсэн үг юм. Та няхуур шалгаагүй сервер битгий ажиллуул. 
	Олон серверүүд заавал <username>root</username> эрхээр ажиллах 
	шаардлагагүй байдаг. Жишээ нь <application>ntalk</application>,
	<application>comsat</application>, болон 
	<application>finger</application> дэмонуудыг тусгай хэрэглэгчийн 
	<firstterm>sandboxes буюу хамгаалагдсан хязгаарлагдмал орчинд</firstterm> 
	ажиллуулах боломжтой байдаг. Хамгаалагдсан хязгаарлагдмал орчин нь 
	асар их төвгүүдийг давж хийгээгүй л бол төгс биш бөгөөд өмнө дурдсан сонгины 
	хандлагаар аюулгүй байдалд хандах нь хэвээр байна: хэрэв хэн нэгэн нь 
	хамгаалагдсан хязгаарлагдмал орчинд ажиллаж байгаа серверт эвдэн орж 
	чадсан ч гэсэн тэд хамгаалагдсан хязгаарлагдмал орчныг бас эвдэн гарах хэрэг 
	болно. Аль болох олон давхаргыг халдагч эвдлэх ёстой болох тусам тэдгээрийн 
	амжилттай болох нь улам багасах болно. Урьд нь root цоорхойнууд нь 
	системийн үндсэн серверүүдээс авахуулаад бараг л бүх 
	<username>root</username> ажилладаг сервер дээр олдож байсан.
	Хэрэв таны ажиллуулдаг машин уруу хүмүүс зөвхөн <application>sshd</application> 
	ашиглан нэвтэрдэг бөгөөд <application>telnetd</application>,
	<application>rshd</application> эсвэл
	<application>rlogind</application> хэзээ ч ашиглан нэвтэрдэггүй 
	бол эдгээр үйлчилгээнүүдийг хаагаарай!</para>
      
      <para>Одоо &os; нь <application>ntalkd</application>,
	<application>comsat</application>, болон
	<application>finger</application> үйлчилгээнүүдийг хамгаалагдсан 
	хязгаарлагдмал орчинд анхдагчаар ажиллуулдаг. Хамгаалагдсан хязгаарлагдмал 
	орчинд ажиллуулж болох өөр нэг програм нь &man.named.8; юм. 
	<filename>/etc/defaults/rc.conf</filename> нь 
	<application>named</application>-г хамгаалагдсан хязгаарлагдмал 
	орчинд ажиллуулахад шаардлагатай нэмэлт өгөгдлүүдийг тайлбар хэлбэрээр агуулсан 
	байдаг. Таны шинэ систем эсвэл байгаа системээ шинэчилж байгаагаас хамааран 
	тэдгээр хамгаалагдсан хязгаарлагдмал орчинд ашиглагдах тусгай хэрэглэгчийн 
	бүртгэлүүд суулгагдаагүй байж болох юм. Хянамгай сисадмин судалгаа хийж  
	серверүүдийг хамгаалагдсан хязгаарлагдмал орчинд аль болох 
	ажиллуулдаг.</para>
      <indexterm>
        <primary><application>sendmail</application></primary>
      </indexterm>

      <para>Хамгаалагдсан хязгаарлагдмал орчинд ерөнхийдөө ажилладаггүй хэд хэдэн 
	серверүүд байдаг: <application>sendmail</application>,
	<application>popper</application>,
	<application>imapd</application>, <application>ftpd</application>,
	болон бусад. Эдгээрийн зарим шиг бас өөр серверүүд байдаг боловч 
	тэдгээрийг суулгах нь таны хүсэж байгаагаас илүү (амархан байх гэсэн асуудал 
	энд сөхөгдөж байна) их ажиллагаа шаардаж магадгүй юм. Та эдгээр серверүүдийг 
	магадгүй <username>root</username> эрхээр ажиллуулж тэдгээрт учирч болох 
	эвдрэн оролтуудыг илрүүлэх өөр арга замуудад найдах хэрэгтэй болж болох юм.</para>

      <para>Системийн өөр нэг том боломжтой <username>root</username> цоорхойнууд 
	бол системд суусан suid-root болон sgid хоёртын файлууд юм. 
	<application>rlogin</application> зэрэг эдгээрийн ихэнх нь 
	<filename>/bin</filename>, <filename>/sbin</filename>,
	<filename>/usr/bin</filename>, эсвэл <filename>/usr/sbin</filename>
	сангуудад байрладаг. Юу ч 100% аюулгүй байдаггүй боловч системийн анхдагч 
	suid болон sgid хоёртын файлууд нь боломжийн хэрээр аюулгүй гэж тооцогддог. 
	Гэсэн хэдий ч эдгээр хоёртын файлуудад <username>root</username> цоорхойнууд 
	үе үе олддог. <application>xterm</application>-г (энэ нь ихэвчлэн suid 
	байдаг) эмзэг болгосон <username>root</username> цоорхойнууд 1998 онд 
	<literal>Xlib</literal>-д олджээ. Харамсахаасаа өмнө аюулгүй байж 
	байсан нь дээр учраас хянамгай сисадмин зөвхөн staff ажиллуулах ёстойгоор 
	staff зөвхөн хандаж чадах тусгай бүлэгт зөвшөөрч suid хоёртын файлуудыг 
	хязгаарладаг бөгөөд хэн ч ашигладаггүй suid хоёртын файлуудыг ажиллуулж болохгүй 
	болгодог (<command>chmod 000</command>). Дэлгэцгүй серверт ер нь 
	<application>xterm</application> хоёртын файл хэрэгцээгүй юм. 
	Sgid хоёртын файлууд нь бас л аюултай юм. Хэрэв халдагч  sgid-kmem 
	хоёртын файлыг эвдэж чадвал тэр <filename>/dev/kmem</filename>-г 
	уншиж чадах бөгөөд ингэснээр нууц үгтэй дурын бүртгэлийг эвдэн орж 
	шифрлэсэн нууц үгийн файлыг уншихад хүргэдэг. Бас <literal>kmem</literal> 
	бүлгийг эвдсэн халдагч secure буюу аюулгүй аргаар дамжин нэвтрэн орсон хэрэглэгчдийн 
	ашиглаж байгаа pty-уудаар илгээгдсэн гарын товчнуудын даралтуудыг 
	хянаж чаддаг. <groupname>tty</groupname> бүлгийг эвдсэн халдагч 
	бараг дурын хэрэглэгчийн tty-д бичиж чадна. Хэрэв хэрэглэгч гар дуурайх боломж бүхий 
	терминал програм эсвэл эмулятор ажиллуулж байгаа бол хэрэглэгчийн терминалыг 
	тушаал буцаан харуулахаар болгодог өгөгдлийн урсгалыг халдагч үүсгэж дараа нь 
	тэр тушаалыг тэр хэрэглэгчийн эрхээр ажиллуулдаг.</para>
    </sect2>

    <sect2 id="secure-users">
      <title>Хэрэглэгчийн бүртгэлүүдийг аюулгүй болгох</title>

      <para>Хэрэглэгчийн бүртгэлүүдийг аюулгүй болгох нь ихэвчлэн хамгийн хэцүү 
	байдаг. Та өөрийн staff-д ширүүн хандалтын хязгаарлалтууд оногдуулж 
	тэдгээрийн нууц үгүүдийг <quote>од болгож</quote> болох боловч 
	та ердийн хэрэглэгчийн бүртгэлүүдийг яг ингэж хязгаарлаж чадахгүй байж болох 
	юм. Хэрэв та хангалттай хяналттай байх юм бол таны аз болж хэрэглэгчийн 
	бүртгэлүүдийг зөвөөр аюулгүй болгож чадна. Хэрэв үгүй бол та тэдгээр 
	бүртгэлүүдийг хянахдаа ердөө л илүү сонор сэрэмжтэй байх хэрэгтэй. 
	ssh болон Kerberos-г хэрэглэгчийн бүртгэлүүдэд ашиглах нь 
	нэмэлт удирдлага болон техникийн дэмжлэг шаардлагатайгаас болоод 
	илүү асуудалтай байдаг боловч энэ нь шифрлэсэн нууц үгийн файлыг бодох юм 
	бол маш сайн шийдэл хэвээр байдаг.</para>
    </sect2>

    <sect2>
      <title>Нууц үгийн файлыг аюулгүй болгох</title>

      <para>Цорын ганц итгэлтэй арга бол аль болох олон нууц үгүүдийг од болгон 
	тэдгээр бүртгэлүүдэд хандахын тулд ssh эсвэл Kerberos ашигла.
	Шифрлэгдсэн нууц үгийн файлыг (<filename>/etc/spwd.db</filename>) 
	зөвхөн <username>root</username> уншиж чаддаг боловч халдагч 
	root-бичих хандалт олж авч чадаагүй ч гэсэн тэр файлд унших эрх олж авах 
	боломжтой байж болох юм.</para>

      <para>Таны аюулгүй байдлын скриптүүд нууц үгийн файлд хийгдсэн өөрчлөлтүүдийг 
	үргэлж шалгаж тайлагнах шаардлагатай (доорх <link
	  linkend="security-integrity">Файлын бүрэн бүтэн байдлыг шалгах</link> 
	хэсгийг үзнэ үү).</para>
    </sect2>

    <sect2>
      <title>Цөмийн гол хэсэг, түүхий төхөөрөмжүүд болон файлын системүүдийг аюулгүй болгох</title>

      <para>Хэрэв халдагч <username>root</username>-г эвдсэн бол тэр юуг ч хийж чадах 
	боловч зарим ашиг сонирхлууд байдаг. Жишээ нь орчин үеийн ихэнх цөмүүдэд 
	пакет шиншлэх төхөөрөмжийн драйвер бүтээгдсэн байдаг. &os;-д энэ нь 
	<devicename>bpf</devicename> төхөөрөмж гэж нэрлэгддэг. Халдагч 
	ердөө буулган авсан машин дээрээ пакет шиншлэгчийг ажиллуулахыг оролддог. 
	Та халдагчид энэ боломжийг өгөх хэрэггүй бөгөөд ихэнх системүүдэд 
	<devicename>bpf</devicename> төхөөрөмжийг эмхэтгэн оруулах 
	шаардлагагүй юм.</para>

      <indexterm>
        <primary><command>sysctl</command></primary>
      </indexterm>
      <para>Гэхдээ <devicename>bpf</devicename> төхөөрөмжийг хаасан ч гэсэн 
	та <filename>/dev/mem</filename> болон <filename>/dev/kmem</filename> 
	файлуудад бас санаа тавих хэрэгтэй. Энэнээс болоод халдагч түүхий (raw) 
	төхөөрөмжүүдэд бичиж чадсан хэвээр байна. Мөн цөмийн бас нэг боломж болох 
	модуль ачаалагч гэж нэрлэгддэг &man.kldload.8; байдаг. Самбаатай 
	халдагч KLD модуль ашиглаад өөрийн <devicename>bpf</devicename> 
	төхөөрөмж эсвэл бусад шиншлэх төхөөрөмжийг ажиллаж байгаа цөмд суулгадаг. 
	Эдгээр асуудлуудаас зайлсхийхийн тулд та цөмийг илүү өндөр аюулгүй байдлын 
	түвшинд ядаж аюулгүйн түвшин 1-д ажиллуулах хэрэгтэй. Аюулгүй түвшин 
	<command>sysctl</command> тушаалаар <varname>kern.securelevel</varname> 
	хувьсагчийн тусламжтай тохируулагдаж болно. Аюулгүйн түвшинг 1 болгосны дараа 
	түүхий төхөөрөмжүүдэд бичих хандалт хийхийг хориглох бөгөөд <literal>schg</literal> 
	зэрэг <command>chflags</command> тугууд үйлчлэх болно. Мөн та 
	чухал эхлүүлэх хоёртын файлууд, сангууд болон скрипт файлууд, ер нь аюулгүйн 
	түвшин заагдах хүртэл ажиллаж байгаа бүгдэд <literal>schg</literal> туг 
	байгаа эсэхийг шалгах хэрэгтэй. Энэ нь хэтэрхий болж болох бөгөөд 
	таныг илүү өндөр аюулгүйн түвшинд ажиллаж байгаа үед системийг шинэчлэхийг  
	бүр илүү төвөгтэй болгодог юм. Та буулт хийж системийн бүх файл болон санд 
	<literal>schg</literal> тугийг зааж өгөлгүйгээр системийг өндөр аюулгүйн 
	түвшинд ажиллуулж болох юм. Өөр нэг боломж нь <filename>/</filename> 
	болон <filename>/usr</filename> санг ердөө л зөвхөн уншихаар холбох явдал 
	юм. Хамгаалах  зүйлдээ хэт ширүүн байх нь булаан эзлэлтийн бүх чухал илрүүлэлтийг 
	бас болиулж болохыг санахад илүүдэхгүй.</para>
    </sect2>

    <sect2 id="security-integrity">
      <title>Файлын бүрэн бүтэн байдлыг шалгах нь: Хоёртын файлууд, Тохиргооны файлууд,
	гэх мэт.</title>

      <para>Тэр мөч ирэхэд, та зөвхөн системийн гол тохиргоо болон хяналтын файлуудаа 
	ая тухын хүчин зүйл урьтахаас хамаагүй өмнө хамгаалж чадна. 
	Жишээ нь	<command>chflags</command> тушаал ашиглан 
	<filename>/</filename> болон <filename>/usr</filename> 
	сангууд дахь ихэнх файлуудад <literal>schg</literal> битийг тохируулах нь 
	магадгүй үр ашиггүй байж болох бөгөөд учир нь ингэснээр файлуудыг хамгаалахын  
	хажуугаар бас илрүүлэх цонхыг хаадаг юм. Таны аюулгүй байдлын сонгины  
	сүүлийн давхарга нь илрүүлэлт бөгөөд энэ нь хамгийн чухал юм. Хэрэв та боломжит 
	халдагчдыг илрүүлж чадахгүй л бол аюулгүй байдлын бусад үлдсэн асуудлуудын талаар 
	бодоод ч бараг хэрэггүй юм (эсвэл бүр дэмий юм, аюулгүй байдлыг танд буруу ойлгуулахад
	хүргэдэг).  Сонгины ажлын хагас нь халдагчийг үйлдэл дээр нь 
	барихын тулд түүнийг зогсоохын оронд харин удаашруулах явдал юм.</para>

      <para>Халдлагыг илрүүлэх хамгийн сайн арга бол өөрчлөгдсөн, алга болсон, эсвэл 
	гэнэтийн файлуудыг хайх явдал юм. Өөрчлөгдсөн файлуудыг хайх хамгийн сайн арга 
	бол тэдгээрийг өөр (ихэвчлэн төвлөрсөн) хязгаарлагдмал хандалттай системээс хайх 
	явдал юм. Өөрийн аюулгүй байдлын скриптийг нэмэлт аюулгүй байдал хангасан 
	хязгаарлагдмал хандалттай систем дээр бичих нь тэдгээрийг боломжит халдагчдад 
	бараг харагдуулдаггүй бөгөөд энэ нь чухал юм. Давуу талыг хамгийн ихээр авахын 
	тулд ерөнхийдөө хязгаарлагдмал хандалттай хайрцагт бусад машинуудад хандах 
	тэр ач холбогдолтой хандалтыг өгөх хэрэгтэй. Үүнийг ихэвчлэн бусад машинуудын зөвхөн 
	унших NFS экспортыг хязгаарлагдмал хандалттай хайрцагт өгөх эсвэл ssh түлхүүр 
	хослолыг тохируулж хязгаарлагдмал хандалттай хайрцгийг бусад машинууд уруу ssh 
	хийхийг зөвшөөрөх  замаар хийдэг. Өөрийн сүлжээний урсгалыг тооцохгүй юм бол NFS нь 
	хамгийн харагддаггүй арга юм &mdash; энэ нь клиент хайрцаг бүр дэх файлын 
	системүүдийг монитор хийхийг танд зөвшөөрч бараг л илэрдэггүй. Хэрэв таны 
	хязгаарлагдмал хандалттай сервер нь клиент хайрцагнууд уруу hub буюу салаалагч эсвэл 
	чиглүүлэлтийн хэд хэдэн давхаргаар дамжин холбогдсон бол NFS арга нь хэтэрхий 
	аюултай (сүлжээний хувьд) байж болох бөгөөд ssh-ийг ашиглах нь түүний гаргадаг  
	аудит мөрийн замуудтай байсан ч гэсэн магадгүй илүү сонголт байж болох юм.</para>

      <para>Монитор хийгдэх клиент систем уруу хандахад хамгийн багаар бодоход унших эрхийг 
	та хязгаарлагдмал хандалттай хайрцагт өгсний дараа яг мониторыг хийхдээ скрипт бичих 
	хэрэгтэй. Өгөгдсөн NFS холболтод &man.find.1; болон &man.md5.1; зэрэг 
	энгийн системийн хэрэгслүүд ашиглан та скриптүүд бичиж болно. Клиент хайрцгийн 
	файлуудад өдөрт нэг удаа физикээр md5 хийж <filename>/etc</filename> болон
	<filename>/usr/local/etc</filename> сангууд дахь хяналтын файлуудыг 
	бүр илүү давтамжтайгаар шалгаж байх нь зүйтэй юм. Хязгаарлагдмал хандалттай 
	машины зөв гэж тооцсон md5 мэдээлэлтэй харьцуулахад тарахгүй файлууд олдвол 
	сисадминд үүнийг очиж шалгахыг хашгиран мэдээлэх ёстой. Аюулгүй байдлын сайн 
	скрипт нь тохирохгүй suid хоёртын файлууд болон <filename>/</filename> болон
	<filename>/usr</filename> зэрэг системийн хуваалтууд дээрх шинээр үүссэн 
	эсвэл устгагдсан файлуудыг бас шалгадаг.</para>

      <para>NFS биш ssh-ийг ашиглаж байх үед аюулгүй байдлыг скрипт бичих нь бүр илүү хэцүү 
	байдаг. Та скриптүүдийг харагдуулж ажиллуулахын тулд тэдгээрийг клиент хайрцаг уруу үндсэндээ 
	<command>scp</command> хийх хэрэгтэй бөгөөд аюулгүй байдлаа бодох юм бол 
	та тэдгээр скриптүүдийн ашигладаг хоёртын файлуудыг (find гэх зэрэг) бас 
	<command>scp</command> хийх хэрэгтэй юм. 
	Клиент хайрцаг дээрх <application>ssh</application> клиент аль хэдийн 
	эвдэгдсэн байж болох юм. Аюултай холболтоор ажиллаж байгаа бол ssh-г ашиглах нь 
	шаардлагатай байж болох боловч бас түүнтэй ажиллахад бүр илүү хэцүү байдаг юм.</para>

      <para>Аюулгүй байдлын сайн скрипт нь 
	<filename>.rhosts</filename>, <filename>.shosts</filename>,
	<filename>.ssh/authorized_keys</filename> гэх зэрэг 
	<literal>MD5</literal> шалгалтын хүрээний гадуур байх хэрэглэгч болон 
	staff-ийн гишүүдийн хандалтын тохиргооны файлууд дахь өөрчлөлтүүдийг бас 
	шалгадаг.</para>

      <para>Хэрэв та асар их хэрэглэгчийн дискний зайтай бол тэдгээр хуваалтууд 
	дээр байгаа файл бүр дээр ажиллахад хэт удаж болох юм. Энэ тохиолдолд suid 
	хоёртын файлуудыг хаах холболтын тугуудыг зааж өгөх нь зүйтэй юм. 
	<literal>nosuid</literal> нь таны хайж байгаа тэр тохируулга юм. 
	Энэ давхаргын зорилго нь эвдлэн оролтын оролдлогуудыг амжилттай эсвэл 
	амжилтгүй болсноос үл хамааран илрүүлэх явдал учраас ямар ч гэсэн ядаж 
	долоо хоногт нэг удаа та тэдгээр файлуудыг магадгүй шалгаж байх 
	хэрэгтэй юм.</para>

      <para>Процессийн бүртгэл хийх нь (&man.accton.8;-г үзнэ үү) эвдлэн оролтын 
	дараах үнэлэх арга замууд болон тусалж болох харьцангуй бага ачаалал бүхий 
	үйлдлийн системийн боломж юм. Энэ нь эвдлэн орсны дараа файлыг хөндөөгүй хэвээр 
	гэж үзэн халдагч систем уруу хэрхэн эвдлэн орсныг мөрдөхөд ялангуяа ашигтай 
	байдаг.</para>

      <para>Эцэст нь аюулгүй байдлын скриптүүд нь бүртгэлийн файлуудыг процесс хийх ёстой 
	бөгөөд бүртгэлүүд өөрсдөө аль болох аюулгүй байдлаар үүсгэгдэх ёстой бөгөөд 
	алсын syslog нь их ашигтай байж болох юм. Халдагч өөрийн мөрийг арилгахыг 
	оролдох бөгөөд эхний эвдлэн оролтын арга болон хугацааг мөрдөхөд сисадмины хувьд  
	бүртгэлийн файлууд нь маш чухал байдаг юм. Бүртгэлийн файлуудын байнгын бичлэгийг 
	хадгалах нэг арга нь системийн консолыг сериал порт уруу ажиллуулж консолуудыг 
	хянаж аюулгүй машин дээр мэдээллийг цуглуулах явдал юм.</para>
    </sect2>

    <sect2>
      <title>Параной буюу хэт зовнил</title>

      <para>Бага зэргийн хэт зовнил буруудахгүй. Дүрэм болгож тав тухтай байдлыг 
	алдагдуулдаггүй дурын тооны аюулгүй байдлын боломжуудыг сисадмин нэмж болох бөгөөд 
	зарим анхаарлыг бодолцон тав тухтай байдалд <emphasis>нөлөөлөх</emphasis> 
	аюулгүй байдлын боломжуудыг бас нэмж болох юм. Бүр илүү чухал нь аюулгүй 
	байдлын администратор үүнийг бага зэрэг хольж хэрэглэж болно &mdash; хэрэв та энэ  
	баримтад дурдсан заавруудыг үгчлэн ашиглавал энэ баримтыг уншсан ирээдүйн халдагчид 
	та өөрийн арга замуудыг заан өгч байна гэсэн үг юм.</para>
    </sect2>

    <sect2>
      <title>Үйлчилгээг Зогсоох Халдлагууд</title>
      <indexterm><primary>Үйлчилгээг Зогсоох (DoS)</primary></indexterm>

      <para>Энэ хэсэг нь Үйлчилгээг Зогсоох халдлагуудыг хамарна. DoS халдлага нь 
	ихэвчлэн пакетийн халдлага байдаг. Таны сүлжээг дүүргэж байгаа орчин үеийн 
	хууран мэхэлсэн пакетийн халдлагуудын эсрэг нэг их юм хийж чадахгүй ч гэсэн 
	халдлагууд таны серверүүдийг унагахгүйн тулд та ерөнхийдөө хохирлыг 
	хязгаарлаж болно:</para>

      <orderedlist>
	<listitem>
	  <para>Серверийн fork хийлтийг хязгаарлах.</para>
	</listitem>

	<listitem>
	  <para>Springboard буюу бусад халдлагуудыг хязгаарлах (ICMP хариу халдлагууд, ping
	    цацалт, гэх мэт.).</para>
	</listitem>

	<listitem>
	  <para>Цөмийн чиглүүлэлтийн кэшийг хэт ачаалах.</para>
	</listitem>
      </orderedlist>

      <para>Нийтлэг DoS халдлагын дүр зураг бол fork хийгдэж байгаа серверт 
	халдаж түүнээр асар их хүүхэд процесс  үүсгүүлж эцсийн эцэст хост системийн 
	хувьд санах ой, файлын тодорхойлогчууд гэх мэтүүд дуусч зогсоход 
	хүргэдэг. <application>inetd</application> (&man.inetd.8;-г 
	үзнэ үү) нь энэ төрлийн халдлагыг хязгаарлах хэд хэдэн тохируулгатай. 
	Машиныг зогсоохоос хамгаалах боломжтой боловч ерөнхийдөө  үйлчилгээг 
	халдлагад өртүүлэхгүй байх боломжгүйг энд тэмдэглэх нь зүйтэй юм. 
	<application>inetd</application> гарын авлагын хуудсыг 
	анхааралтай уншиж <option>-c</option>, <option>-C</option>,
	болон <option>-R</option> тохируулгуудад ялангуяа анхаарлаа 
	хандуулаарай. Хууран мэхэлсэн IP халдлагууд нь 
	<application>inetd</application> дахь  
	<option>-C</option> тохируулгыг хуурах учраас ихэвчлэн тохируулгуудын 
	хослолыг ашиглах шаардлагатай. Зарим дан серверүүд өөрийн 
	fork хийгдэхийг хязгаарлах параметрүүдтэй байдаг.</para>

      <para><application>Sendmail</application> нь 
	<option>-OMaxDaemonChildren</option> тохируулгатай байдаг бөгөөд 
	энэ нь <application>Sendmail</application>-ийг ачаалал хязгаарлах тохируулгатай ажиллуулж ачааллын 
	хоцрогдол үүсгэснээс хавьгүй илүүтэйгээр ажилладаг. Та 
	<application>Sendmail</application>-г ажиллуулахдаа 
	хүссэн ачааллыг даахаар гэхдээ компьютерийг унагахаар их хэмжээний тоогоор 
	<application>Sendmail</application>-үүдийг ажиллуулах биш түүнээс 
	багаар <literal>MaxDaemonChildren</literal> параметрийг 
	хангалттай өндрөөр тавьж өгөх хэрэгтэй. Мөн <application>sendmail</application>-ийг дарааллын 
	горимоор (<option>-ODeliveryMode=queued</option>) ажиллуулах 
	болон дэмонг (<command>sendmail -bd</command>) дараалалтай 
	(<command>sendmail -q15m</command>) ажиллуулдгаас тусад нь ажиллуулах нь 
	чухал юм. Хэрэв та шууд илгээх горимыг хүсэж байгаа бол та дарааллыг  
	<option>-q1m</option> зэргээр бүр бага интервалаар ажиллуулах боломжтой 
	боловч <literal>MaxDaemonChildren</literal> тохируулгыг боломжийн 
	утгаар хоорондоо холбоотой амжилтгүйтлүүдээс <application>sendmail</application>-ийг  хамгаалахын 
	<emphasis>тулд</emphasis> зааж өгсөн эсэхээ шалгаарай.</para>

      <para><application>Syslogd</application>-д шууд халдаж болох учраас аль болох 
	<option>-s</option> тохируулгыг эсвэл <option>-a</option> тохируулгыг ашиглахыг 
	танд зөвлөдөг.</para>

      <para>Шууд халдлага хийгдэж болох <application>TCP Wrapper</application>-ийн 
	буцах identd зэрэг буцан холбогддог үйлчилгээнүүдийн хувьд та маш хянамгай байх 
	хэрэгтэй. Ийм учраас та <application>TCP Wrapper</application>-ийн 
	буцах identd боломжийг ерөнхийдөө ашиглах хэрэггүй юм.</para>

      <para>Та өөрийн захын чиглүүлэгчүүд дээрээ дотоод үйлчилгээнүүд уруугаа 
	гаднаас хандуулахгүй болгож галт ханаар хамгаалах нь зүйтэй юм. 
	Үүний цаадах санаа нь гаднаас ирж болзошгүй сүлжээ дүүргэх халдлагаас өөрийн LAN-г 
	хамгаалах явдал бөгөөд сүлжээн дээр тулгуурласан <username>root</username> 
	эрхийг буулгахаас дотоод үйлчилгээнүүдийг хамгаалах зүйлс тийм их биш юм. 
	exclusive буюу хамааруулаагүй галт ханыг үргэлж тохируулах хэрэгтэй, өөрөөр хэлбэл 
	<quote>A, B, C, D болон M-Z портуудаас <emphasis>бусад</emphasis> 
	бүгдийг галт ханаар хамгаалах хэрэгтэй</quote>. Ингэснээр та 
	<application>named</application> (хэрэв та бүсийн хувьд анхдагч бол),
	<application>ntalkd</application>,
	<application>sendmail</application> болон бусад Интернэтээс хандах 
	үйлчилгээнүүд зэрэг зарим нэг тусгай үйлчилгээнүүдийн портуудаас бусад бүх бага 
	дугаарын портуудыг галт ханаар хамгаалж чадах юм. Хэрэв та галт ханыг өөр 
	аргаар &mdash; inclusive буюу хамааруулсан эсвэл зөвшөөрсөн галт хана маягаар  
	тохируулахыг оролдвол хэд хэдэн үйлчилгээнүүдийг <quote>хаахаа</quote> 
	мартаж магадгүй юм, эсвэл та шинэ дотоод үйлчилгээ нэмээд галт ханаа шинэчлэхээ 
	мартаж болох юм. Та галт хана дээр зөвшөөрсөнтэй адил үйлдлийг нэвтрүүлэхийн 
	тулд бага дугаарын портуудыг нээлгүйгээр өндөр дугаарын портуудыг онгойлгож 
	болох юм. Мөн &os; нь динамик холболтод хэрэглэгддэг портуудыг 
	<command>sysctl</command>-ийн төрөл бүрийн 
	<varname>net.inet.ip.portrange</varname> хувьсагчуудаар 
	(<command>sysctl -a | fgrep portrange</command>) 
	хянах боломжийг танд олгодгийг бас тэмдэглэх нь зүйтэй юм. Энэ нь бас таны 
	галт ханын тохиргооны төвөгтэй байдлыг амарчилдаг юм. Жишээ нь 
	та ердийн 4000-аас 5000 хүртэлх портууд болон 49152-оос 65535 хүртэлх 
	өндөр дугаарын портуудыг ашигладаг бол 4000-аас бага бүгдийг 
	өөрийн галт хана дээр хаах хэрэгтэй (мэдээж Интернэтээс ханддаг хэдэн тусгай портуудаас 
	бусад).</para>

      <para>Өөр нийтлэг DoS халдлагуудын нэг нь springboard халдлага юм 
	&mdash; сервер, дотоод сүлжээ эсвэл бусад машиныг хариу үйлдэл хийхийг нь 
	ихэсгэж хэт ачаалахад хүргэдэг халдлага юм. Ийм маягийн хамгийн нийтлэг 
	халдлага нь <emphasis>ICMP ping broadcast буюу цацалт</emphasis> 
	юм. Халдагч таны LAN-ий цацах хаяг уруу илгээсэн ping пакетийнхаа  
	эхлэл IP хаягийг халдахыг хүсэж байгаа машиныхаа IP хаягаар сольж хуурдаг. 
	Хэрэв таны захын чиглүүлэгчүүд цацах хаяг уруу илгээх ping пакетуудыг 
	зогсоохоор тохируулагдаагүй бол таны LAN хангалттай хариу үүсгэн хууран мэхэлсэн 
	эхлэл хаяг уруу илгээж, ялангуяа халдагч хэдэн арван цацах хаягууд уруу өөр өөр 
	хэдэн арван сүлжээнүүдээр дамжин энэ башир аргаа ашигласан үед, хохирогчийг 
	дүүргэдэг. 120 мегабайтаас илүү хэмжээний цацах халдлага одоогоор 
	хэмжигдээд байна. Энэ төрлийн хоёр дахь нийтлэг халдлага нь ICMP-ийн алдаа 
	тайлагнах системийн эсрэг халдлага юм. ICMP алдааны мэдэгдэл үүсгэдэг 
	пакетуудыг бүтээж халдагч серверийн орж ирж байгаа сүлжээг дүүргэж ингэснээр 
	серверийг өөрийн гарах сүлжээг ICMP хариунуудаар дүүргэхэд хүргэдэг. 
	Энэ төрлийн халдлага нь ялангуяа хэрэв сервер үүсгэж байгаа ICMP хариунуудаа 
	хангалттай хурднаар шавхан гаргаж чадахгүй байгаа бол серверийг санах ойгүй болгож 
	сүйрүүлж бас болох юм. <application>sysctl</application>-ийн 
	<literal>net.inet.icmp.icmplim</literal> хувьсагчийг ашиглан 
	эдгээр халдлагуудыг хязгаарлах хэрэгтэй. Springboard төрлийн халдлагуудын 
	сүүлийн гол ангилал нь udp цуурай үйлчилгээ зэрэг зарим дотоод 
	<application>inetd</application> үйлчилгээнүүдтэй холбоотой юм. 
	Халдагч UDP пакетийг хууран мэхэлж A болон B сервер нь хоёулаа таны LAN-д байгаа 
	тийм A серверийн цуурай порт дээрх эхлэл хаягаар болон  төгсгөл хаягийг B серверийн 
	цуурай порт дээрх хаягаар сольдог. Уг хоёр сервер дараа нь энэ ганц пакетийг 
	хоорондоо шидэлцдэг.  Эдгээр серверүүд болон тэдгээрийн LAN-г энэ маягаар 
	халдагч хэдхэн пакетуудыг хатган оруулан хэт ачаалж чаддаг.	
	Үүнтэй адил асуудлууд дотоод <application>chargen</application> портод 
	бас байдаг. Чадварлаг сисадмин эдгээр бүх дотоод inetd тест үйлчилгээнүүдийг 
	хаадаг.</para>

      <para>Хууран мэхэлсэн пакетийн халдлагуудыг цөмийн чиглүүлэлтийн кэшийг хэт ачаалахад 
	хэрэглэж болдог. <varname>net.inet.ip.rtexpire</varname>,
	<varname>rtminexpire</varname>, болон <varname>rtmaxcache</varname>
	<command>sysctl</command> параметрүүдийг үзнэ үү. Дурын эхлэл 
	IP хаягийг ашигласан хууран мэхэлсэн пакетийн халдлага нь чиглүүлэлтийн хүснэгтэд түр зуур 
	кэш хийгдсэн чиглүүлэлтийг цөмөөр  үүсгүүлэхэд хүргэдэг бөгөөд энэ нь 
	<command>netstat -rna | fgrep W3</command> тушаалаар харагддаг. 
	Эдгээр чиглүүлэлтүүд нь ихэвчлэн 1600 секунд орчим хугацааны дотор дуусдаг.
	Хэрэв цөм кэш хийгдсэн чиглүүлэлтийн хүснэгт хэтэрхий том болсныг илрүүлэх юм бол 
	<varname>rtexpire</varname> динамикаар багасгадаг боловч 
	<varname>rtminexpire</varname>-с бага болтол хэзээ ч багасгадаггүй. 
	Хоёр асуудал байдаг:</para>
	
      <orderedlist>
	<listitem>
	  <para>Бага ачаалагдсан сервер гэнэт халдлагад өртөхөд цөм хангалттай хурдан 
		хариу үйлдэл хийдэггүй.</para>
	</listitem>
	
	<listitem>
	  <para><varname>rtminexpire</varname> хувьсагч нь 
		үргэлжилсэн халдлагыг цөм дааж чадахаар хангалттай бага байдаггүй.</para>
	</listitem>
      </orderedlist>
      
      <para>Хэрэв таны серверүүд Интернэтэд T3 эсвэл илүү хурдаар холбогдсон бол 
	&man.sysctl.8;-оор 
	<varname>rtexpire</varname> болон <varname>rtminexpire</varname> 
	хувьсагчуудыг хоёуланг гараар дарж бичихдээ хянамгай байх хэрэгтэй. 
	Аль ч параметрийг (машиныг сүйрүүлэхийг та хүсээгүй л бол) хэзээ ч битгий 
	0 болгоорой. Эдгээр параметрүүдийг хоёуланг нь 2 секунд болгох нь 
	чиглүүлэлтийн хүснэгтийг халдлагаас хамгаалахад хангалттай байх ёстой.</para>
    </sect2>

    <sect2>
      <title>Kerberos болон SSH-тэй холбоотой хандалтын асуудлууд</title>
      <indexterm><primary><command>ssh</command></primary></indexterm>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>Хэрэв та Kerberos болон ssh-г хоёуланг ашиглахаар бол цөөн хэдэн асуудлуудыг 
	дурдах хэрэгтэй. Kerberos 5 нь жинхэнийг шалгах маш сайн нэвтрэлтийн протокол 
	боловч түүнийг ашигласан <application>telnet</application> болон 
	<application>rlogin</application>-д байдаг алдаанууд нь энэ хоёр програмыг 
	хоёртын урсгалтай ажиллахад тохиромжгүй болгодог. Мөн <option>-x</option> 
	тохируулгыг ашиглахгүй л бол анхдагчаар Kerberos нь сессийг шифрлэдэггүй. 
	<application>ssh</application> нь бүгдийг шифрлэдэг.</para>

      <para>Ssh нь анхдагчаар шифрлэсэн түлхүүрүүдээ дамжуулдгаас бусад бүх л талаараа зэгсэн 
	сайн ажилладаг. Энэ нь юу гэсэн үг вэ гэхээр та хэрэв системийн бусад хэсэгт хандах боломж 
	олгодог түлхүүрүүд бүхий аюулгүй ажлын компьютертай бөгөөд та аюултай машин уруу ssh 
	хийвэл таны түлхүүрүүд ашиглагдах боломжтой гэсэн үг юм. Яг түлхүүрүүд нь өөрсдөө 
	ил гардаггүй боловч ssh нь таны нэвтэрсэн хугацааны туршид зориулж дамжуулах порт 
	суулгадаг бөгөөд хэрэв халдагч аюулгүй машин дээрх <username>root</username>-г 
	эвдсэн бол тэрхүү портыг таны түлхүүрүүдийг ашиглахын тулд хэрэглэн  таны түлхүүрээр 
	тайлагдах өөр бусад машинуудад хандах боломжийг олж авах боломжтой юм.</para>

      <para>Бид staff нэвтрэлтүүдийн хувьд аль болох ssh-г Kerberos-той цуг ашиглахыг 
	зөвлөдөг. <application>Ssh</application> нь Kerberos-ийн дэмжлэгтэй 
	эмхэтгэгдэж болдог. Энэ нь ил гарсан байж болзошгүй ssh түлхүүрүүдэд 
	найдах таны найдварыг багасгахын хамт нууц үгүүдийг Kerberos-оор хамгаалдаг.
	Ssh түлхүүрүүд нь аюулгүй машинуудын автоматчилагдсан ажлуудад (Kerberos-оор 
	хийхэд таарахгүй) зөвхөн хэрэглэгдэх ёстой. Мөн бид таныг ssh-ийн тохиргоондоо 
	key-forwarding буюу түлхүүр дамжуулалтыг болиулах эсвэл ssh-ийн  
	<filename>authorized_keys</filename> файлдаа зөвхөн тусгайлсан 
	машинуудаас нэвтрэхэд түлхүүрийг ашиглаж болохоор болгож зөвшөөрдөг 
	<literal>from=IP/DOMAIN</literal> тохируулгыг ашиглахыг зөвлөдөг.</para>
    </sect2>
  </sect1>

  <sect1 id="crypt">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Билл</firstname>
	  <surname>Свингл</surname>
	  <contrib>Хэсгүүдийг дахин бичиж шинэчилсэн </contrib>
	</author>
      </authorgroup>
      <!-- 21 Mar 2000 -->
    </sect1info>

    <title>DES, MD5, болон Crypt</title>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>crypt</secondary>
    </indexterm>

    <indexterm><primary>crypt</primary></indexterm>
    <indexterm><primary>Blowfish</primary></indexterm>
    <indexterm><primary>DES</primary></indexterm>
    <indexterm><primary>MD5</primary></indexterm>

    <para>&unix; систем дээрх хэрэглэгч бүрийн хувьд нууц үг бүртгэлтэй нь холбоотой 
	байдаг. Мэдээж эдгээр нууц үгүүд нь зөвхөн хэрэглэгч ба үйлдлийн системд 
	мэдэгдэж байх ёстой. Эдгээр нууц үгүүдийг нууцлаг байлгахын тулд тэдгээрийг 
	<quote>one-way hash буюу үл буцах хэш</quote> гэгддэг шифрлэхэд амархан 
	боловч буцааж болдоггүй аргаар шифрлэдэг. Өөрөөр хэлбэл хормын өмнө 
	мэдээж гэж хэлсэн бидний хэлсэн үг яг жинхэнэдээ үнэн биш юм: үйлдлийн систем
	өөрөө нууц үгийг <emphasis>жинхэнэдээ</emphasis> мэддэггүй. 
	Энэ нь зөвхөн нууц үгийн <emphasis>шифрлэсэн</emphasis> хэлбэрийг 
	мэддэг. <quote>plain-text буюу ердийн уншигдах текст </quote> 
	хэлбэрийн нууц үгийг авах цорын ганц арга нь боломжит нууц үгүүдийн орон зайгаас 
	балмадаар хүчлэн хайх явдал юм.</para>

    <para>Харамсалтай нь &unix; бий болсон тэр үед нууц үгийг аюулгүй аргаар 
	шифрлэх цорын ганц арга нь DES, Data Encryption Standard буюу 
	Өгөгдөл Шифрлэх Стандарт дээр үндэслэсэн байлаа. Энэ нь АНУ-д оршин 
	сууж байсан хэрэглэгчдийн хувьд тийм ч асуудалтай биш байсан юм, гэхдээ 
	DES-ийн эх код АНУ-аас гадагшаа экспорт хийгдэж болохгүй байсан 
	учир &os; нь АНУ-ын хуулийг дагахын хажуугаар DES-ийг ашигласан хэвээр
	байсан бусад бүх &unix; төрлүүдтэй нийцтэй байх арга замыг хайж олоход 
	хүрсэн юм.</para>

    <para>Үүний шийдэл нь АНУ-ын хэрэглэгчид DES сангуудыг суулгаж ашиглах боломжтой 
	мөртлөө олон улсын хэрэглэгчид гадагш экспорт хийгдэж болох шифрлэх аргатай бас 
	байхаар шифрийн сангуудыг хуваасан явдал байлаа. Ингэж &os; нь 
	MD5-ийг өөрийн анхдагч шифрлэх аргаа болгон ашиглах болсон юм. MD5 нь 
	DES-ээс илүү аюулгүй нууцлаг гэгддэг бөгөөд DES-ийг суулгах нь үндсэндээ 
	нийцтэй байх шалтгаануудын улмаас зориулагдсан юм.</para>

    <sect2>
      <title>Өөрийн Crypt арга замыг таних нь</title>

      <para>Одоогоор шифрийн сан DES, MD5 болон Blowfish хэш функцуудыг дэмждэг.
	Анхдагчаар &os; нь MD5 ашиглан нууц үгүүдийг шифрлэдэг.</para>

      <para>&os; аль шифрлэх аргыг тохируулж ашиглаж байгааг мэдэх хялбар байдаг. 
	<filename>/etc/master.passwd</filename> файл дахь шифрлэсэн 
	нууц үгийг шалгах нь нэг арга юм. MD5 хэшээр шифрлэгдсэн нууц үгүүд нь 
	DES-р шифрлэгдсэнийгээ бодох юм бол урт бөгөөд <literal>&dollar;1&dollar;</literal> 
	тэмдэгтээр бас эхэлдэг. <literal>&dollar;2a&dollar;</literal> 
	тэмдэгтээр эхэлсэн нууц үгүүд Blowfish хэш функцаар шифрлэгдсэн байдаг. 
	DES мөр нь ямар нэг тусгайлан таньж болох шинж тэмдэггүй  байдаг боловч 
	тэд MD5 нууц үгүүдээс богино бөгөөд <literal>&dollar;</literal> 
	тэмдэгт ордоггүй 64 тэмдэгттэй цагаан толгойгоор кодчилогддог, тиймээс 
	долларын тэмдэгтээр эхлээгүй харьцангуй богино мөр ихэвчлэн DES нууц үг 
	байдаг.</para>

      <para>Шинэ нууц үгүүдэд ашиглагдах нууц үгийн хэлбэр нь нэвтрэлтийн 
	<literal>passwd_format</literal> боломжийн тусламжтай 
	<filename>/etc/login.conf</filename> файлд хянагддаг бөгөөд 
	энэ хувьсагч нь <literal>des</literal>, <literal>md5</literal> 
	эсвэл <literal>blf</literal> утгуудыг авдаг. Нэвтрэлтийн 
	боломжуудын талаар дэлгэрэнгүй мэдээллийг &man.login.conf.5; 
	гарын авлагын хуудаснаас үзнэ үү.</para>

    </sect2>
  </sect1>

  <sect1 id="one-time-passwords">
    <title>Нэг удаагийн нууц үгүүд</title>
    <indexterm><primary>нэг удаагийн нууц үгүүд</primary></indexterm>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>нэг удаагийн нууц үгүүд</secondary>
    </indexterm>

    <para>Анхдагчаар &os; OPIE (One-time Passwords
      In Everything буюу Бүхэнд зориулсан нэг удаагийн нууц үгүүд) дэмжлэгтэй 
	байдаг бөгөөд энэ нь MD5 хэшийг анхдагчаар ашигладаг.</para>

    <para>Бид гурван өөр төрлийн нууц үгийг доор хэлэлцэх болно. Эхнийх нь таны ердийн 
	&unix; загварын эсвэл Kerberos нууц үг юм; бид үүнийг <quote>&unix; нууц үг</quote> 
	гэж нэрлэх болно. Хоёр дахь төрөл нь OPIE &man.opiekey.1; програмаар 
	үүсгэгдэж  &man.opiepasswd.1; програм болон нэвтрэлт хүлээх мөр хүлээн авах 
	нэг удаагийн нууц үг юм; бид үүнийг <quote>нэг удаагийн нууц үг</quote> гэх болно. 
	Сүүлийн төрөл нууц үг бол <command>opiekey</command> програмд 
	(заримдаа <command>opiepasswd</command> програмууд) өгдөг 
	нууцлаг нууц үг бөгөөд үүнийг ашиглан дээрх програмууд нэг удаагийн нууц үг 
	үүсгэдэг; бид үүнийг <quote>нууцлаг нууц үг</quote> гэх буюу эсвэл 
	зүгээр л шалгагдаагүй <quote>нууц үг</quote> гэх болно.</para>

    <para>Нууцлаг нууц үг нь таны &unix; нууц үгтэй ямар ч холбоогүй юм; тэдгээр нь 
	адил байж болох боловч ингэхийг зөвлөдөггүй. OPIE нууцлаг нууц үгүүд нь 
	хуучин &unix; нууц үгүүд шиг 8 тэмдэгтэд хязгаарлагддаггүй
	<footnote><para>&os; дээр стандарт нэвтрэх нууц үг уртаараа 128 тэмдэгт 
	хүртэл байж болдог.</para></footnote> бөгөөд таны хүссэн хэмжээний 
	урттай байж болдог. Зургаа эсвэл долоон үг бүхий өгүүлбэрээс тогтох нууц үгүүд 
	нэлээн элбэг байдаг. Ихэнх хэсгийн хувьд OPIE систем &unix;-ийн нууц үгийн 
	системээс бүр мөсөн ангид ажилладаг.</para>

    <para>Нууц үгээс гадна OPIE-д чухал өгөгдлийн өөр хоёр хэсэг байдаг. Нэг нь 
	<quote>seed буюу үр</quote> эсвэл <quote>key буюу түлхүүр</quote> гэгддэг 
	бөгөөд 2 үсэг болон таван тооноос тогтдог. Нөгөөдөх нь <quote>давталтын тоо</quote> 
	буюу 1-ээс 100 хүртэлх тоо юм. OPIE нэг удаагийн нууц үгийг үр болон нууцлаг 
	нууц үгийг нийлүүлэн MD5 хэшийг давталтын тоогоор ашиглан үүсгэж үр дүнг нь 
	зургаан богино Англи үг болгодог. Эдгээр зургаан Англи үг нь таны нэг удаагийн нууц 
	үг юм. Нэвтрэлт шалгах систем (үндсэндээ PAM) ашигласан хамгийн сүүлийн нэг удаагийн 
	нууц үгийг хадгалж байдаг бөгөөд хэрэглэгчийн өгсөн нууц үгийн хэш өмнөх нууц үгтэй таарч 
	байвал хэрэглэгчийг нэвтрүүлдэг. Үл буцах хэш ашиглагддаг болохоор хэрэв 
	амжилттайгаар ашиглагдсан нууц үгийг олж авсан бол дараа дараагийн нэг удаагийн 
	нууц үгүүдийг үүсгэх боломжгүй байдаг; хэрэглэгч болон нэвтрэлтийн програмыг хамгийн 
	сүүлийн хэлбэрт адилхан байлгаж байхын тулд давталтын тоо амжилттай нэвтрэлт хийгдэх бүрийн 
	дараа багасаж байдаг. Давталтын тоо 1 хүрэх үед OPIE дахин хийгдэх 
	хэрэгтэй болно.</para>

    <para>Систем болгоны хувьд хэдэн програмууд байдаг бөгөөд тэдгээрийг бид энд 
	хэлэлцэх болно. <command>opiekey</command> програм давталтын 
	тоо, үр болон нууцлаг нууц үгийг хүлээн авч нэг удаагийн нууц үг эсвэл 
	нэг удаагийн нууц үгүүдийн үргэлжилсэн жагсаалтыг үүсгэдэг. 
	<command>opiepasswd</command> програмыг OPIE-г эхлүүлэх болон 
	нууц үг, давталтын тоо эсвэл үр өөрчлөхөд ашигладаг; энэ нь  
	нууцлаг нэвтрэх үгс аль эсвэл давталтын тоо, үр болон нэг удаагийн нууц үгийг 
	авдаг. <command>opieinfo</command> програм тохирох итгэмжлэлүүдийн 
	файлуудыг (<filename>/etc/opiekeys</filename>) шалгаж 
	ажиллуулсан хэрэглэгчийн одоогийн давталтын тоо болон үрийг дэлгэцэд 
	гаргадаг.</para>

    <para>Бид дөрвөн өөр төрлийн үйлдлийн талаар хэлэлцэх болно. Эхнийх нь аюулгүй 
	холболтоор <command>opiepasswd</command> ашиглаж нэг удаагийн нууц үгүүдийг 
	эхний удаа тохируулах эсвэл өөрийн нууц үг эсвэл үрийг өөрчлөх үйлдэл юм. 
	Хоёр дахь үйлдэл нь <command>opiepasswd</command>-г аюултай холболтоор, 
	<command>opiekey</command> тушаалыг аюулгүй холболтоор ашиглаж 
	адил үйлдлийг хийх явдал юм. Гурав дахь нь <command>opiekey</command>-г 
	аюултай холболтоор ашиглан нэвтрэн орох үйлдэл юм. Дөрөв дэх нь 
	<command>opiekey</command>-г ашиглан хэд хэдэн түлхүүрүүд үүсгэх үйлдэл 
	бөгөөд гадагшаа аюулгүй холболтуудгүй газрууд уруу явахдаа тэдгээр түлхүүрүүдийг бичин авч 
	эсвэл хэвлэн аваад өөртөө авч явж болох юм.</para>

    <sect2>
      <title>Аюулгүй холболт эхлүүлэх</title>
      <para>OPIE-г эхний удаа эхлүүлэхдээ <command>opiepasswd</command> 
	тушаалыг ажиллуул:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
</screen>

      <para><prompt>Enter new secret pass phrase:</prompt> эсвэл
        <prompt>Enter secret password:</prompt> мөрүүд дээр та 
	нууц үг эсвэл өгүүлбэр оруулах ёстой. Энэ нь таны нэвтрэхдээ ашиглах 
	нууц үг биш гэдгийг санах хэрэгтэй, үүнийг ашиглаж таны нэг удаагийн 
	нэвтрэх түлхүүрийг үүсгэдэг. <quote>ID</quote> мөр таны 
	тухайн үеийн параметрүүд болох таны нэвтрэх нэр, давталтын тоо болон 
	үрийг өгдөг. Нэвтрэн орох үед систем эдгээр параметрүүдийг санаж 
	танд тэдгээрийг санах шаардлагагүйгээр буцаан үзүүлдэг. Сүүлийн мөр нь 
	тэдгээр параметрүүд болон таны нууцлаг нууц үгт харгалзах нэг удаагийн 
	нууц үгийг өгдөг; хэрэв та нэн даруй дахин нэвтэрвэл энэ нэг удаагийн нууц үг 
	нь таны ашиглах тэр нууц үг юм.</para>
    </sect2>

    <sect2>
      <title>Аюултай холболт эхлүүлэх</title>
      
      <para>Өөрийн нууцлаг нууц үгийг аюултай холболтоор эхэлж өгөхдөө эсвэл 
	өөрчлөхдөө <command>opiekey</command> ажиллуулж болох тийм газар уруу 
	аюулгүй холболттой байж байх шаардлагатай; энэ нь таны итгэж байгаа машин 
	дээр бүрхүүлийн тушаал хүлээх мөр хэлбэрээр байж болно. Та бас давталтын тоог 
	(100 боломжийн утга байж болох юм) бодож өгөх хэрэгтэй бөгөөд та өөрөө үр 
	бодож олох эсвэл дурын үүсгэснийг ашиглах хэрэгтэй. Аюултай холболтоор 
	(таны эхлүүлж байгаа машин уруу) <command>opiepasswd</command> 
	тушаалыг ашигла:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
</screen>

      <para>Анхдагч үрийг хүлээж авах бол <keycap>Return</keycap> дар.
	Дараа нь хандах нууц үгийг оруулахын өмнө аюулгүй холболт уруугаа 
	орж адил параметрүүдийг өгөөрэй:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</screen>

      <para>Одоо аюултай холболт уруугаа шилжиж үүсгэсэн нэг удаагийн нууц үгээ 
	тохирох програм уруу хуулаарай.</para>
    </sect2>

    <sect2>
      <title>Нэг удаагийн нууц үг ганцыг үүсгэх нь</title>

      <para>OPIE-г эхлүүлэн тохируулж нэвтэрсний дараа танд иймэрхүү тушаал 
	хүлээх мөр харуулагдана:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para>Энэ дашрамд тэмдэглэн хэлэхэд OPIE тушаал хүлээх мөрүүд ашигтай боломжтой 
	байдаг: хэрэв та нууц үг хүлээх мөр дээр <keycap>Return</keycap> 
	дарвал хүлээх мөр цуурайг идэвхжүүлж таны юу бичиж байгааг танд харуулдаг. 
	Та хэвлэсэн зүйлээсээ харж магадгүй нууц үгийг гараараа бичиж оруулахыг 
	оролдож байгаа бол энэ маш ашигтай байж болох юм.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>Энэ үед нэвтрэлт хүлээх мөрөнд хариулахын тулд та өөрийн нэг удаагийн нууц үгийг 
	үүсгэх хэрэгтэй болно. Үүнийг <command>opiekey</command> тушаал итгэн ажиллуулж 
	чадах тийм систем дээрээ хийх хэрэгтэй. (DOS, &windows; болон &macos;-д 
	зориулсан эдгээрийн хувилбарууд байдаг) Эдгээрт давталтын тоо болон үр тушаалын 
	мөрийн тохируулга хэлбэрээр хэрэгтэй байдаг. Та нэвтрэн орж байгаа машиныхаа 
	нэвтрэлт хүлээх мөрөөс эдгээрийг шууд хуулан тавьж болох юм.</para>

      <para>Итгэсэн систем дээрээ:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Одоо та өөрийн нэг удаагийн нууц үгтэй болсон болохоор нэвтрэлтээ 
	үргэлжлүүлж болно.</para>
    </sect2>

    <sect2>
      <title>Нэг удаагийн нууц үг олныг үүсгэх нь</title>

      <para>Заримдаа та итгэсэн машин эсвэл аюулгүй холболт уруу хандах боломжгүй 
	тийм газар очих хэрэгтэй болдог. Энэ тохиолдолд <command>opiekey</command> 
	тушаал ашиглаж хэд хэдэн нэг удаагийн нууц үгүүдийг урьдчилан үүсгэж хэвлэн 
	биедээ авч явах боломжтой юм. Жишээ нь:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para><option>-n 5</option> нь дараалсан таван түлхүүрийг үүсгэхийг, 
	<option>30</option> нь сүүлийн давталтын тоог хэд байх ёстойг зааж өгч 
	байгаа юм. Эдгээр нь ашиглах бололцоотойг <emphasis>урвуу</emphasis>
	дарааллаар дэлгэцэнд харуулдгийг тэмдэглэх нь зүйтэй. Хэрэв та хэт санаа 
	зовниж байгаа бол та үр дүнг гараар бичиж авахыг хүсэж болох юм; 
	эсвэл <command>lpr</command> уруу хуулан авч тавьж болох юм. Мөр бүр 
	давталтын тоо болон нэг удаагийн нууц үгийг харуулж байгааг анхаараарай; 
	та нууц үгүүдийг хэрэглэх бүртээ тэдгээрийг арилгаж энэ хэвлэсэн арга тань ашигтай 
	хэвээр болохыг мэдэж болох юм.</para>
    </sect2>

    <sect2>
      <title>&unix; нууц үгүүдийг ашиглахыг хязгаарлах нь</title>

      <para>OPIE нь &unix; нууц үгүүдийн ашиглалтыг нэвтрэлтийн сессийн IP хаяг дээр тулгуурлан 
	хязгаарлаж чаддаг. Тохирох файл нь <filename>/etc/opieaccess</filename> 
	бөгөөд энэ файл нь анхдагчаар байдаг. Энэ файлын талаар болон 
	үүнийг ашигласнаар та аюулгүй байдлын ямар зүйлсүүдийг бодолцож анхаарах ёстой талаар 
	дэлгэрэнгүй мэдээллийг &man.opieaccess.5;-с шалгана уу.</para>
	
      <para>Энд жишээ <filename>opieaccess</filename> файл байна:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>Энэ мөр нь &unix; нууц үгүүдийг ямар ч үед ашиглахын тулд эхлэл IP хаягийг  
	(хууран мэхлэхэд хүрч болох тийм эмзэг) заагдсан утга болон багтай тааруулах 
	боломжийг хэрэглэгчдэд олгодог.</para>
	
      <para><filename>opieaccess</filename> дахь аль ч дүрэм таарахгүй байгаа 
	бол анхдагчаар OPIE биш нэвтрэлтүүдийг хааж үгүйсгэдэг.</para>

    </sect2>
  </sect1>

  <sect1 id="tcpwrappers">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Бичсэн </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm><primary>TCP Гүйцэтгэлийг хялбаршуулагчид</primary></indexterm>
      
    <title>TCP Гүйцэтгэлийг хялбаршуулагчид</title>

    <para>&man.inetd.8;-г мэддэг хэн бүхэн <acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдын 
	талаар заримдаа сонссон байх. Гэхдээ цөөн хүмүүс энэ боломжийн 
	сүлжээний орчин дахь ашигтай талыг бүрэн ойлгодог юм шиг санагддаг. 
	Хүн бүхэн сүлжээний холболтууд зохицуулах галт хана суулгахыг хүсдэг 
	юм шиг санагддаг.  Галт хана олон төрлийн хэрэглээтэй боловч 
	холболт үүсгэгч уруу текст илгээх зэрэг зарим зүйлсийг галт хана хийж  
	чаддаггүй. Энд дурдсан <acronym>TCP</acronym> програм энэ мэтийг болон 
	үүнээс илүүг хийдэг. Дараагийн хэдэн хэсэгт <acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдын 
	олон боломжуудыг хэлэлцэх бөгөөд боломжтой үед нь жишээ тохиргооны 
	мөрийг үзүүлэх болно.</para>

    <para><acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчид програм хангамж нь 
	<command>inetd</command>-ийн чадваруудыг сервер бүрийн 
	хувьд түүний доор хянагдаж болохоор дэмжин өргөтгөдөг. Энэ аргыг ашиглан 
	бүртгэл хөтлөх дэмжлэг нэмэх, холболтууд уруу мэдэгдэл буцаах, дэмонд 
	зөвхөн дотоод холболтуудыг хүлээн авахыг зөвшөөрөх гэх мэт үйлдлүүдийг 
	хийх боломжтой. Эдгээр боломжуудын заримыг галт хана суулган тохируулж хийж  
	болох боловч энэ нь зөвхөн хамгаалалтын нэмэлт давхарга болохоос гадна 
	галт ханын үзүүлж чаддагаас илүү хяналтыг олгодог юм.</para>

    <para><acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдын ийнхүү нэмэгдсэн  
	ажиллагаа нь сайн галт ханыг солихоор зүйл гэж ойлгогдох ёсгүй юм. 
	<acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчид нь галт хана 
	эсвэл өөр бусад аюулгүй байдлыг нэмэгдүүлэгч програмуудын хамтаар 
	ашиглагдаж системийн хувьд хамгаалалтын нэмэлт давхарга болон аятайхан 
	үйлчлэх боломжтой юм.</para>

    <para>Энэ нь <command>inetd</command>-ийн тохиргооны өргөтгөл болохоор 
	энэхүү баримтыг уншигч таныг <link linkend="network-inetd">inetd тохиргоо</link> 
	хэсгийг уншсан гэдэгт найдаж байна.</para>

    <note>
      <para>&man.inetd.8;-ээр ажиллуулагдсан програмууд яг жинхэнээрээ 
	<quote>дэмонууд</quote> биш боловч тэдгээрийг уламжлалаар дэмонууд гэдэг. 
	Энэ ухагдахууныг бид энэ хэсэгт бас ашиглах болно.</para>
    </note>

    <sect2>
      <title>Эхний тохиргоо</title>

      <para><acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдыг &os;-д 
	ашиглахад  байх цорын ганц шаардлага нь <command>inetd</command> серверийг 
	<filename>rc.conf</filename> файлаас <option>-Ww</option> 
	тохируулгатай ажиллуулсан эсэхийг шалгах явдал юм; энэ нь анхдагч тохиргоо 
	юм. Мэдээж <filename>/etc/hosts.allow</filename> файлын 
	зөв тохиргоо бас байгааг хүлээж байдаг боловч эдгээр тохиолдлуудад 
	&man.syslogd.8; системийн бүртгэлүүдэд мэдэгдлүүд шиддэг.</para>

      <note>
	<para>Бусад <acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчдын 
	шийдлүүдтэй харьцуулах юм бол <filename>hosts.deny</filename> 
	файлыг хэрэглэхээ больсон. Тохиргооны бүх сонголтууд 
	<filename>/etc/hosts.allow</filename> файлд байх шаардлагатай.</para>
      </note>

      <para>Хамгийн амархан тохиргоогоороо бол дэмоны холболтын бодлогууд 
	зөвшөөрөгдсөн эсвэл хаагдсаны аль нэгээр <filename>/etc/hosts.allow</filename> 
	файл дахь тохируулгуудаас хамааран тохируулагддаг. &os; дээрх анхдагч 
	тохиргоо нь <command>inetd</command>-ээр эхэлсэн дэмон бүр уруу хийгдэх 
	холболтыг зөвшөөрдөг. Үүнийг өөрчлөх талаар зөвхөн үндсэн тохиргооны тухай  
	дурдсаны дараа хэлэлцэх болно.</para>

      <para>Үндсэн тохиргоо ихэвчлэн <literal>дэмон : хаяг : үйлдэл</literal> 
	хэлбэрийг авдаг. Энд байгаа <literal>дэмон</literal> нь 
	<command>inetd</command>-ийн эхлүүлсэн дэмоны нэр юм. 
	<literal>Хаяг</literal> нь зөв хостын нэр, <literal>address</literal> 
	хаяг эсвэл дөрвөлжин хаалтан ([&nbsp;]) доторх IPv6 хаяг байж болно. 
	Үйлдэл талбар нь allow буюу зөвшөөрөх эсвэл deny буюу эрхийг хориглох эсвэл   
	хандалтыг хаахын аль нэг байна. Тохиргоо эхний тохирсон дүрэм журмын дагуу ажилладаг гэдгийг 
	санах хэрэгтэй, энэ нь тохирох дүрмийг тохиргооны файлаас өсөх дарааллаар 
	хайна гэсэн үг юм. Тохирох дүрэм олдвол тэр дүрэм ашиглагдаж хайх 
	процесс зогсоно.</para>

      <para>Бусад хэд хэдэн тохируулгууд байдаг боловч тэдгээрийг энэ хэсгийн сүүлд 
	тайлбарлах болно. Хялбар тохиргооны мөр ганцхан тэр мэдээллийн дагуу амархнаар 
	хийгдэж болно. Жишээ нь 
	<filename role="package">mail/qpopper</filename> дэмоноор дамжин 
	хийгдэж болох <acronym>POP</acronym>3 холболтуудыг зөвшөөрөхийн тулд 
	дараах мөрүүд <filename>hosts.allow</filename> файлд нэмж хийгдэх 
	хэрэгтэй:</para>

      <programlisting># This line is required for POP3 connections:
qpopper : ALL : allow</programlisting>

      <para>Энэ мөрийн нэмснийхээ дараа <command>inetd</command>-г дахин эхлүүлэх 
	хэрэгтэй. Үүнийг &man.kill.1; тушаал эсвэл <filename>/etc/rc.d/inetd</filename>-г 
	<parameter>restart</parameter> параметртай ашиглан хийж болно.</para>
      </sect2>

      <sect2>
        <title>Дэвшилтэт тохиргоо</title>

      <para><acronym>TCP</acronym> Гүйцэтгэлийг хялбаршуулагчид нь бас дэвшилтэт 
	тохируулгуудтай байдаг; тэдгээр нь холболтуудтай хэрхэн ажиллахыг илүүтэйгээр 
	хянах боломжийг олгодог. Зарим тохиолдолд тодорхой хостууд эсвэл дэмон 
	холболтууд уруу тайлбар буцаах нь зүйтэй санаа байж болох юм. Бусад 
	тохиолдолд магадгүй бүртгэлийн файл бичигдэх ёстой эсвэл цахим захидал 
	администратор уруу илгээгдэж болох юм. Бусад тохиолдлууд үйлчилгээг зөвхөн 
	дотоод холболтууддаа ашиглахыг шаардаж болох юм. Эдгээр нь бүгдээрээ  
	<literal>орлуулагддаг тэмдэгтүүд</literal>, өргөтгөх тэмдэгтүүд болон 
	гадаад тушаалыг ажиллуулах зэрэг тохиргооны сонголтуудын тусламжтай хийгдэх 
	боломжтой юм. Дараагийн хоёр хэсэгт эдгээр тохиолдлуудын талаар бичсэн 
	байгаа.</para>
	
      <sect3>
	<title>Гадаад тушаалууд</title>

	<para>Холболтыг хааж түүнийг тогтоохыг оролдсон хүн уруу шалтгааныг нь 
	илгээх тохиолдол гарчээ гэж бодъё. Үүнийг яаж хийх вэ? Энэ үйлдлийг 
	<option>twist</option> тохируулга ашиглан хийх боломжтой. 
	Холболт тогтоохоор оролдоход <option>twist</option> тохируулга 
	бүрхүүлийн тушаал эсвэл скрипт ажилуулахаар дуудагддаг. 
	<filename>hosts.allow</filename> файлд үүний жишээ аль хэдийн 
	орсон байдаг:</para>

	<programlisting># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

	<para>Энэ жишээ нь <quote>You are not allowed to use <literal>daemon</literal>
	  from <literal>hostname</literal>.</quote> буюу 
	<quote>Та <literal>дэмон</literal>ыг <literal>hostname</literal>-с 
	ашиглах зөвшөөрөлгүй.</quote> гэсэн мэдэгдлийг хандалтын файлд урьдаар 
	тохируулагдаагүй дэмон бүрийн хувьд буцаадаг. Энэ нь тогтоогдсон холболт дөнгөж 
	салсны дараа холболтыг эхлүүлэгч уруу хариултыг буцааж илгээхэд маш их ашигтай 
	байдаг. Буцсан мэдэгдэл бүр <literal>"</literal> тэмдэгтүүд дотор 
	заавал байх <emphasis>шаардлагатай</emphasis>; энэ дүрмэнд ямар нэг 
	жич зөвшөөрөл байхгүй.</para>

	<warning>
	  <para>Хэрэв халдагч эсвэл бүлэг халдагчид эдгээр дэмонуудыг холболт хийх 
	хүсэлтээр цутгаж чадах юм бол серверийн эсрэг үйлчилгээг зогсоох халдлага явуулах 
	боломжтой байж болох юм.</para>
	</warning>

	<para>Өөр нэг боломж нь эдгээр тохиолдлуудад <option>spawn</option> 
	тохируулгыг ашиглах явдал юм. <option>twist</option> тохируулгын 
	нэгэн адил <option>spawn</option> тохируулга нь холболтуудыг сохроор 
	хааж гадаад бүрхүүлийн тушаалууд эсвэл скриптүүдийг ажиллуулахад ашиглагдаж 
	болно. <option>twist</option> тохируулгаас ялгаатай тал нь 
	<option>spawn</option> нь холболт тогтоосон хүн уруу хариулт буцааж 
	илгээдэггүй. Жишээ нь дараах тохиргооны мөр байжээ гэж бодъё:</para>

	<programlisting># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</programlisting>

	<para>Энэ нь <hostid role="fqdn">*.example.com</hostid> домэйноос 
	ирсэн бүх холболтын оролдлогуудаас татгалзахын зэрэгцээ хостын нэр, <acronym>IP</acronym> 
	хаяг  болон тэдний хандалт хийхийг оролдсон дэмонг <filename>/var/log/connections.log</filename> 
	файл уруу бүртгэнэ.</para>

	<para>Дээр тайлбарласан орлуулах тэмдэгтүүдээс гадна, өөрөөр хэлбэл 
	%a тэмдэгтээс гадна бусад цөөн хэдэн тэмдэгтүүд бас байдаг. Бүрэн жагсаалтыг 
	&man.hosts.access.5; гарын авлагын хуудаснаас үзнэ үү.</para>
      </sect3>

      <sect3>
	<title>Орлуулагддаг тэмдэгтүүдийн тохиргоонууд</title>

	<para>Энэ хүртэл <literal>ALL</literal> жишээ бүх л жишээнүүдэд 
	ашиглагдлаа. Ажиллагааг арай цаашлуулж өргөтгөх бусад тохируулгууд 
	байдаг. Жишээ нь <literal>ALL</literal> нь дэмон, домэйн эсвэл 
	<acronym>IP</acronym> хаягийн аль нэгтэй тааруулах зорилгоор 
	ашиглагдаж болох юм. Өөр нэг орлуулагддаг тэмдэгт нь 
	<acronym>IP</acronym> хаягаа өөрчлөн хуурсан байж болох дурын хостыг 
	тааруулах <literal>PARANOID</literal> тохируулга юм. Өөрөөр хэлбэл 
	<literal>paranoid буюу хэт зовнил</literal> нь 
	өөрийн хостын нэрээс өөр <acronym>IP</acronym> хаягтай машинаас 
	холболт хийгдэх бүр түүнд тохирох үйлдлийг тодорхойлоход ашиглагдаж 
	болох юм. Дараах жишээ энэ хэлэлцүүлэгт арай илүү ойлголт өгч магадгүй 
	юм:</para>

	<programlisting># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</programlisting>

	<para>Энэ жишээн дээр <command>sendmail</command> уруу хийгдэж байгаа 
	өөрийнхөө хостын нэрээс өөр <acronym>IP</acronym> хаягтай холболтын бүх 
	хүсэлтүүдээс татгалзан хааж байна.</para>

	<caution>
	  <para>Хэрэв клиент эсвэл сервер эвдэрхий <acronym>DNS</acronym> 
	суулгацтай бол <literal>PARANOID</literal>-ийг ашиглах нь серверүүдийг 
	ноцтойгоор зэрэмдэг болгож болох юм. Иймд администраторын зохион байгуулалт 
	болон хуваарилалт хийхийг зөвлөж байна.</para>
	</caution>

	<para>Орлуулагддаг тэмдэгтүүдийн талаар болон тэдэнтэй холбоотой ажиллагааны 
	талаар дэлгэрэнгүйг &man.hosts.access.5; гарын авлагын хуудаснаас 
	үзээрэй.</para>

	<para>Тусгай тохиргооны аль ч мөрүүдийн өмнө дээрх нь ажиллана, эхний тохиргооны 
	мөр <filename>hosts.allow</filename> файлд тайлбар болгон хаагдах 
	шаардлагатай. Үүнийг энэ хэсгийн эхэнд тэмдэглэж хэлсэн байгаа.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="kerberosIV">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Марк</firstname>
	  <surname>Мюррей</surname>
	  <contrib>Хойно дурдсан хүний бичсэн дээр тулгуурлан хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Марк</firstname>
	  <surname>Дэйпоз</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>KerberosIV</application></title>

    <para>Kerberos нь хэрэглэгчид өөрсдийгөө нууцлаг серверийн үйлчилгээнүүдийн 
	тусламжтайгаар таниулан нэвтрэх боломжийг олгодог сүлжээний нэмэлт систем/протокол юм.
	Алсын нэвтрэлт, алсын хуулбар, нууцлаг систем хоорондох файл хуулбарлалт болон 
	бусад аюул ихтэй үйлдлүүд зэрэг үйлчилгээнүүд харьцангуй аюулгүй хийгдэж илүү хяналт хийж 
	болохоор болсон.</para>

    <para>Дараах заавруудыг &os;-тэй цуг түгээгддэг Kerberos-ийг хэрхэн тохируулах гарын авлага 
	болгон хэрэглэж болох юм. Гэхдээ та бүрэн тайлбарын талаар харгалзах гарын авлагын 
	хуудаснуудад хандаж үзэх шаардлагатай.</para>

    <sect2>
      <title><application>KerberosIV</application> суулгах нь</title>

      <indexterm><primary>MIT</primary></indexterm>
      <indexterm>
	<primary>KerberosIV</primary>
	<secondary>суулгах нь</secondary>
      </indexterm>
      <para>Kerberos нь &os;-ийн нэмэлт бүрэлдэхүүн хэсэг юм. Энэ програм хангамжийг 
	суулгах хамгийн амархан арга нь &os; эхэлж суулгах үед <application>sysinstall</application>-д 
	<literal>krb4</literal> эсвэл <literal>krb5</literal> түгээлтийг сонгон 
	суулгах явдал юм. Энэ нь Kerberos-ийн <quote>eBones</quote> (KerberosIV) 
	эсвэл <quote>Heimdal</quote> (Kerberos5) шийдлүүдийг суулгах болно. 
	Эдгээр нь АНУ/Канадаас гадна хөгжүүлэгдсэн  учраас АНУ-ын криптограф 
	код дээрх экспортын хязгаарлагдмал хяналтын үед бусад улсуудын системийн эзэмшигчдэд 
	ашиглагдах боломжтой болсон юм. Иймээс эдгээр шийдлүүд нь орсон байдаг.</para>

      <para>Үүнээс гадна Kerberos-ийн MIT шийдэл портуудын цуглуулгын 
	<filename role="package">security/krb5</filename> санд байдаг.</para>
    </sect2>

    <sect2>
      <title>Эхний мэдээллийн бааз үүсгэх</title>
      
      <para>Энэ нь Kerberos сервер дээр зөвхөн хийгддэг. Эхлээд хуучин Kerberos мэдээллийн 
	баазууд байгаа эсэхийг шалгаарай. Та <filename>/etc/kerberosIV</filename> сан 
	уруу орж зөвхөн дараах файлууд байгааг шалгаарай:</para>
	  
      <screen>&prompt.root; <userinput>cd /etc/kerberosIV</userinput>
&prompt.root; <userinput>ls</userinput>
README		krb.conf        krb.realms</screen>
	  
      <para>Хэрэв аль нэг нэмэлт файлууд (<filename>principal.*</filename>
	эсвэл <filename>master_key</filename> зэрэг) байвал 
	<command>kdb_destroy</command> тушаал ашиглаж хуучин Kerberos мэдээллийн 
	баазыг устгах эсвэл хэрэв Kerberos ажиллахгүй байгаа бол ердөө л нэмэлт файлуудыг 
	устгах хэрэгтэй.</para>
	  
      <para>Та одоо өөрийн Kerberos хүрээг (realm) зааж өгөхдөө <filename>krb.conf</filename> 
	болон <filename>krb.realms</filename> файлуудыг засварлах шаардлагатай. 
	Энэ тохиолдолд хүрээ нь <literal>EXAMPLE.COM</literal> болох бөгөөд 
	сервер нь <hostid role="fqdn">grunt.example.com</hostid> болох юм. 
	Бид <filename>krb.conf</filename> файлыг засварлаж эсвэл 
	үүсгэнэ:</para>
	  
      <screen>&prompt.root; <userinput>cat krb.conf</userinput>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</screen>
	  
      <para>Энэ тохиолдолд бусад хүрээнүүд тэнд байх хэрэггүй. Тэдгээр нь энд машиныг хэрхэн 
	олон хүрээнүүдийг мэдэхээр хийгдэх жишээ маягаар байгаа болно. Хялбараа бодоод 
	та тэдгээрийг оруулахгүйг хүсэж болох юм.</para>
	  
      <para>Эхний мөр нь систем ажиллах хүрээг нэрлэж байна. Бусад мөрүүд нь хүрээ/хост 
	оруулгуудыг агуулна. Мөр дэх эхнийх нь хүрээ бөгөөд хоёр дахь нь 
	<quote>түлхүүр түгээх төв</quote> болж байгаа хүрээн дэх хост юм. 
	Хостын нэрийн дараах <literal>admin server</literal> нь хост бас 
	удирдах мэдээллийн баазаар хангаж байна гэсэн үг юм. Эдгээр ухагдахуунуудын 
	тайлбаруудын талаар Kerberos-ийн гарын авлагын хуудаснуудаас зөвлөгөө 
	авна уу.</para>
	  
      <para>Одоо бид <hostid role="fqdn">grunt.example.com</hostid>-г 
	<literal>EXAMPLE.COM</literal> хүрээ уруу нэмэх ёстой бөгөөд 
	бас <literal>EXAMPLE.COM</literal> хүрээний 
	<hostid role="domainname">.example.com</hostid> домэйн дэх бүх 
	хостуудыг оруулан нэмж өгөх хэрэгтэй. <filename>krb.realms</filename> 
	файл дараах байдлаар шинэчлэгдэх болно:</para>
	  
      <screen>&prompt.root; <userinput>cat krb.realms</userinput>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</screen>
	  
      <para>Дахин хэлэхэд бусад хүрээнүүд тэнд байх шаардлагагүй. Тэдгээр нь энд машиныг хэрхэн 
	олон хүрээнүүдийг мэдэхээр хийгдэх жишээ маягаар байгаа болно. Хялбараа бодоод 
	та тэдгээрийг оруулахгүйг хүсэж болох юм.</para>
	  
      <para>Эхний мөр нь <emphasis>тусгай</emphasis> системийг нэрлэгдсэн 
	хүрээ уруу оруулж байна. Бусад мөрүүд нэрлэгдсэн хүрээнд тухайн дэд домэйны 
	системүүдийг хэрхэн анхдагчаар болгож байгааг харуулна.</para>
	  
      <para>Одоо бид мэдээллийн сан үүсгэхэд бэлэн боллоо. Энэ нь зөвхөн 
	Kerberos сервер (эсвэл Түлхүүр Түгээх Төв) дээр ажиллах ёстой. 
	<command>kdb_init</command> тушаал ажиллуулж үүнийг хийнэ:</para>
	  
      <screen>&prompt.root; <userinput>kdb_init</userinput>
<prompt>Realm name [default  ATHENA.MIT.EDU ]:</prompt> <userinput>EXAMPLE.COM</userinput>
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.
		
<prompt>Enter Kerberos master key:</prompt> </screen>
	  
      <para>Одоо бид локал машин дээрх серверүүд авч болгохоор болгохын тулд түлхүүрийг 
	хадгалах хэрэгтэй. <command>kstash</command> тушаал ашиглаж үүнийг 
	хийнэ:</para>
	
      <screen>&prompt.root; <userinput>kstash</userinput>
	      
<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!</screen>
	
      <para>Энэ нь шифрлэгдсэн мастер нууц үгийг 
	<filename>/etc/kerberosIV/master_key</filename>-д хадгална.</para>
    </sect2>
    
    <sect2>
      <title>Бүгдийг ажиллахаар болгох</title>
	
      <indexterm>
	<primary>KerberosIV</primary>
	<secondary>эхний эхлүүлэлт</secondary>
      </indexterm>

      <para>Kerberos-оор аюулгүй болгогдох систем <emphasis>бүрийн</emphasis> 
	хувьд хоёр удирдагч мэдээллийн баазад нэмэгдэх шаардлагатай. Тэдгээрийн нэрс нь 
	<literal>kpasswd</literal> болон <literal>rcmd</literal> байна. 
	Эдгээр хоёр удирдагч нь систем бүрийн хувьд хувь системийн нэртэй тохиолдлуудын 
	хамтаар хийгдэнэ.</para>
	  
      <para>Эдгээр <application>kpasswd</application> болон 
	<application>rcmd</application> дэмонууд нь бусад системүүдэд 
	Kerberos нууц үгнүүдийг өөрчилж &man.rcp.1;,
	&man.rlogin.1; болон &man.rsh.1; зэрэг тушаалуудыг ажиллуулахыг 
	зөвшөөрдөг.</para>
	  
      <para>Одоо эдгээр оруулгуудыг нэмэцгээе:</para>
	    
      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>passwd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: passwd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- enter RANDOM here
Verifying password

<prompt>New Password:</prompt> &lt;---- enter RANDOM here

<prompt>Random password [y] ?</prompt> <userinput>y</userinput>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt> <userinput>rcmd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt>

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>		&lt;---- enter RANDOM here
Verifying password

<prompt>New Password:</prompt>           &lt;---- enter RANDOM here

<prompt>Random password [y] ?</prompt>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>         &lt;---- null entry here will cause an exit</screen>
    </sect2>

    <sect2>
      <title>Серверийн файлыг үүсгэх</title>
      
      <para>Одоо бид машин бүр дээр үйлчилгээнүүдийг тодорхойлдог бүх тохиолдлуудыг 
	гаргаж авах хэрэгтэй. Энэ зорилгоор бид <command>ext_srvtab</command> 
	тушаалыг ашиглана. Энэ нь файл үүсгэх бөгөөд түүнийг Kerberos-ийн 
	клиент бүрийн <filename>/etc</filename> сан уруу 
	<emphasis>аюулгүйн үүднээс</emphasis> хуулах эсвэл шилжүүлэх хэрэгтэй.
	Энэ файл нь сервер болон клиент бүр дээр байх хэрэгтэй бөгөөд Kerberos-ийн 
	ажиллагаанд шийдвэрлэх зүйл болдог.</para>


      <screen>&prompt.root; <userinput>ext_srvtab grunt</userinput>
<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating 'grunt-new-srvtab'....</screen>

      <para>Одоо, энэ тушаал зөвхөн түр зуурын файл үүсгэдэг бөгөөд тэр файлын нэрийг 
	бүх серверүүд авч чадахаар <filename>srvtab</filename> болгон нэрлэх 
	шаардлагатай. &man.mv.1; тушаал ашиглаж эх систем дээрх байрлал уруу 
	шилжүүл:</para>

      <screen>&prompt.root; <userinput>mv grunt-new-srvtab srvtab</userinput></screen>

      <para>Хэрэв файл нь клиент системд зориулагдсан бөгөөд сүлжээ нь аюулгүй биш 
	гэж бодогдвол <filename><replaceable>client</replaceable>-new-srvtab</filename> 
	файлыг шилжүүлж болох зөөвөрлөгч уруу хуулж физик аюулгүйн үүднээс тээвэрлэж 
	болно. Үүнийг клиентийн <filename>/etc</filename> сан дотор 
	<filename>srvtab</filename> болгон нэрлэж 600 горимд байгаа эсэхийг 
	шалгаарай:</para>

      <screen>&prompt.root; <userinput>mv grumble-new-srvtab srvtab</userinput>
&prompt.root; <userinput>chmod 600 srvtab</userinput></screen>
    </sect2>
    
    <sect2>
      <title>Мэдээллийн санг нутагшуулах</title>

      <para>Бид одоо зарим хэрэглэгчийг мэдээллийн баазад оруулах хэрэгтэй. Эхлээд 
	<username>jane</username> хэрэглэгчид зориулсан оруулгыг үүсгэе. 
	Үүнийг <command>kdb_edit</command> тушаал ашиглаж хийнэ:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: jane, Instance: , kdc_key_ver: 1
<prompt>New Password:</prompt>                &lt;---- enter a secure password here
Verifying password

<prompt>New Password:</prompt>                &lt;---- re-enter the password here
Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		   &lt;---- null entry here will cause an exit</screen>
    </sect2>

    <sect2>
      <title>Бүгдийг тест хийх</title>
      
      <para>Эхлээд бид Kerberos дэмонууд ажиллуулах шаардлагатай. Хэрэв та 
	өөрийн <filename>/etc/rc.conf</filename> файлыг зөв засварласан 
	бол дахин ачаалахад энэ нь автоматаар хийгдэх ёстойг санаарай. 
	Энэ нь зөвхөн Kerberos сервер дээр шаардлагатай. kerberos-ийн 
	клиентүүд хэрэгтэй зүйлээ автоматаар <filename>/etc/kerberosIV</filename> 
	сангаас авах болно.</para>
	  
      <screen>&prompt.root; <userinput>kerberos &amp;</userinput>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
&prompt.root; <userinput>kadmind -n &amp;</userinput>
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>
	  
      <para>Одоо бид <command>kinit</command> тушаал ашиглаж 
	бидний дээр үүсгэсэн <username>jane</username> ID-д зориулсан тасалбарыг авахыг 
	оролдож болно:</para>
	  
      <screen>&prompt.user; <userinput>kinit jane</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane"
<prompt>Password:</prompt> </screen>
	  
      <para>Токенууд бидэнд үнэхээр байгаа эсэхийг <command>klist</command> ашиглан 
	үзэхийг оролдоорой:</para>
	  
      <screen>&prompt.user; <userinput>klist</userinput>
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>

      <para>Одоо <application>kpasswd</application> дэмон 
	Kerberos-ийн мэдээллийн баазад нэвтрэлтийн зөвшөөрөл авч чадах эсэхийг шалгахын
	тулд нууц үгийг &man.passwd.1; ашиглан өөрчлөхийг оролдоорой:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
realm EXAMPLE.COM
<prompt>Old password for jane:</prompt>
<prompt>New Password for jane:</prompt>
Verifying password
<prompt>New Password for jane:</prompt>
Password changed.</screen>
    </sect2>

    <sect2>
      <title><command>su</command> зөвшөөрлүүдийг нэмэх</title>
      
      <para>Kerberos нь <username>root</username> зөвшөөрлүүд 
	хэрэгтэй хэрэглэгч <emphasis>бүрд</emphasis> өөрсдийнх нь 
	<emphasis>тусдаа</emphasis> &man.su.1; нууц үгийг өгөхийг 
	бидэнд зөвшөөрдөг. Одоо бид &man.su.1;-аар танигдан зөвшөөрөгдсөн 
	ID-г <username>root</username> уруу нэмж болно. Үүнийг 
	<username>root</username>-г удирдагчтай холбосон тохиолдолтой 
	байснаар хянаж болно. <command>kdb_edit</command> ашиглан 
	Kerberos-ийн мэдээллийн баазад <literal>jane.root</literal> 
	оруулгыг бид үүсгэж болно:</para>
	  
      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt> <userinput>root</userinput>

&lt;Not found&gt;, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- enter a SECURE password here
Verifying password

<prompt>New Password:</prompt>    	 	 &lt;---- re-enter the password here

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt> <userinput>12</userinput> &lt;--- Keep this short!
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		         &lt;---- null entry here will cause an exit</screen>
	  
      <para>Одоо үүнийг ажиллаж байгааг шалгаж токенуудыг авахыг оролдоорой:</para>
      
      <screen>&prompt.root; <userinput>kinit jane.root</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane.root"
<prompt>Password:</prompt></screen>
	  
      <para>Одоо бид хэрэглэгчийг <username>root</username>-ийн
	  <filename>.klogin</filename> файлд нэмэх хэрэгтэй:</para>
	  
      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>
	  
      <para>Одоо &man.su.1; хийхийг оролдоод үз:</para>
	  
      <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt></screen>
	  
      <para>тэгээд ямар токенууд бидэнд байгааг хараарай:</para>
	  
      <screen>&prompt.root; <userinput>klist</userinput>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>
    </sect2>

    <sect2>
      <title>Бусад тушаалуудыг ашиглах</title>
      
      <para>Өмнөх жишээн дээр бид <literal>jane</literal> гэж нэрлэгдсэн 
	удирдагчийг <literal>root</literal> тохиолдолтой үүсгэсэн. 
	Энэ нь удирдагчтай адил нэртэй хэрэглэгч дээр үндэслэсэн бөгөөд энэ нь 
	Kerberos-ийн анхдагч юм; <username>root</username>-ийн гэр сан дахь 
	<filename>.klogin</filename> файлд шаардлагатай оруулгууд байвал 
	<literal>&lt;username&gt;.</literal><username>root</username> 
	хэлбэрийн <literal>&lt;principal&gt;.&lt;instance&gt;</literal> нь 
	тэр <literal>&lt;username&gt;</literal>-г <username>root</username> 
	уруу &man.su.1; хийхийг зөвшөөрдөг:</para>
	  
      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>
      
      <para>хэрэв хэрэглэгч үүнтэй адил хэлбэрийн өөрийн гэр сангийн мөрүүдтэй бол:</para>
      
      <screen>&prompt.user; <userinput>cat ~/.klogin</userinput>
jane@EXAMPLE.COM
jack@EXAMPLE.COM</screen>
	  
      <para>Энэ нь өөрсдийгөө 
	<username>jane</username> эсвэл <username>jack</username> гэж 
	таниулсан (<command>kinit</command>-ийн тусламжтай, дээр дурдсаныг үз)  
	<literal>EXAMPLE.COM</literal> хүрээний хэнд ч 
	&man.rlogin.1;, &man.rsh.1; эсвэл &man.rcp.1; ашиглан энэ систем 
	(<hostid>grunt</hostid>) дээрх <username>jane</username>-ий бүртгэл 
	эсвэл файлуудад хандахыг зөвшөөрдөг.</para>
	  
      <para>Жишээ нь <username>jane</username> одоо өөр систем уруу Kerberos 
	ашиглан нэвтрэн орж байна:</para>
	  
	    <screen>&prompt.user; <userinput>kinit</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
&prompt.user; <userinput>rlogin grunt</userinput>
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
	  
      <para>Эсвэл <username>jack</username> яг тэр машин дээрх <username>jane</username> бүртгэл 
	уруу нэвтрэн орж байна (<username>jane</username> дээрхтэй адил <filename>.klogin</filename>-ийг 
	тохируулсан бөгөөд Kerberos хариуцсан хүн удирдагч <emphasis>jack</emphasis>-ийг хоосон 
	тохиолдолтой тохируулсан):</para>
	  
      <screen>&prompt.user; <userinput>kinit</userinput>
&prompt.user; <userinput>rlogin grunt -l jane</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
    </sect2>
  </sect1>

  <sect1 id="kerberos5">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Тиллмэн</firstname>
	  <surname>Хоожсон</surname>
	  <contrib>Хойно дурдсан хүний бичсэн дээр тулгуурлан хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Марк</firstname>
	  <surname>Мюррей</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>Kerberos5</application></title>

    <para>&os;-5.1-ээс хойшх &os;-ийн хувилбар бүр зөвхөн 
	<application>Kerberos5</application>-д зориулсан дэмжлэгийг 
	оруулсан байдаг. <application>Kerberos5</application> нь 
	орсон цорын ганц хувилбар болохоор түүний тохиргоо олон талаараа 
	<application>KerberosIV</application>-д байдагтай адил 
	байдаг. Дараах мэдээлэл &os;-5.0-с хойшх хувилбар дахь 
	<application>Kerberos5</application>-тай хамаатай.
	<application>KerberosIV</application> багцыг ашиглахыг 
	хүсэж байгаа хэрэглэгчид <filename role="package">security/krb4</filename> 
	портыг суулгаж болно.</para>

    <para>Kerberos нь хэрэглэгчид өөрсдийгөө нууцлаг серверийн үйлчилгээнүүдийн 
	тусламжтайгаар таниулан нэвтрэх боломжийг олгодог сүлжээний нэмэлт систем/протокол юм.
	Алсын нэвтрэлт, алсын хуулбар, нууцлаг систем хоорондох файл хуулбарлалт болон 
	бусад аюул ихтэй үйлдлүүд зэрэг үйлчилгээнүүд харьцангуй аюулгүй хийгдэж илүү хяналт хийж 
	болохоор болсон.</para>

    <para><application>Kerberos</application> нь хэн бэ гэдгийг шалгах прокси систем 
	юм. Энэ нь бас итгэгдсэн гуравдагч нэвтрэлт таних систем гэж тайлбарлагдаж 
	болно. <application>Kerberos</application> нь зөвхөн нэг функцыг 
	хангадаг &mdash; сүлжээн дээр хэрэглэгчдэд өөрсдийгөө аюулгүйгээр таниулах 
	боломжийг хангаж өгдөг. Энэ нь шалгаж таних функцууд (хэрэглэгчдийн 
	хийхийг зөвшөөрдөг) эсвэл аудит функцуудын (тэдгээр хэрэглэгчид юу хийснийг) 
	үүргийг гүйцэтгэдэггүй. Клиент болон сервер өөрийгөө таниулж батлахаар 
	<application>Kerberos</application>-г ашигласны дараа тэд бизнесээ бодож 
	өөрсдийн бүх холболтуудаа шифрлэж нууцлал болон бүрэн бүтэн байдлаа хадгалан 
	баталгаажуулж болно.</para>

    <para>Иймээс <application>Kerberos</application>-ийг нэвтрэлт танилт болон 
	аудит үйлчилгээнүүдийг хангадаг бусад аюулгүй байдлын аргуудтай цуг ашиглахыг 
	маш ихээр зөвлөдөг.</para>

    <para>Дараах заавруудыг &os;-д зориулан түгээгдсэн <application>Kerberos</application>-ийг 
	хэрхэн тохируулах гарын авлага болгон ашиглаж болно. Гэхдээ та тохирох гарын авлагын 
	хуудаснуудаас бүрэн тайлбарын талаар лавлах хэрэгтэй.</para>

    <para><application>Kerberos</application>-ийн суулгацыг үзүүлэх зорилгоор 
	төрөл бүрийн нэрийн талбарууд дараах байдлаар зохицуулагдана:</para>

    <itemizedlist>
      <listitem>
	<para><acronym>DNS</acronym> домэйн (<quote>бүс</quote>)
	  нь example.org байна.</para>
      </listitem>

      <listitem>
	<para><application>Kerberos</application> хүрээ нь 
	  EXAMPLE.ORG байна.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Хэрэв та дотооддоо ажиллуулах бодолтой байсан ч гэсэн <application>Kerberos</application>-ийг 
	суулгаж тохируулахдаа жинхэнэ домэйны нэрүүдийг ашиглана уу. Энэ нь 
	<acronym>DNS</acronym>-ийн асуудлуудыг тойрон гарч 
	бусад <application>Kerberos</application> хүрээнүүдтэй хийх 
	хоорондын үйлдлийг баталгаажуулдаг.</para>
    </note>

    <sect2>
      <title>Түүх</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>түүх</secondary>
      </indexterm>

      <para><application>Kerberos</application>-ийг <acronym>MIT</acronym> 
	анх сүлжээний аюулгүй байдлын асуудлуудын шийдэл болгож хийсэн. 
	<application>Kerberos</application> протокол нь хүчирхэг криптографыг 
	ашигладаг бөгөөд клиент нь аюултай сүлжээний холболтоор өөрийгөө хэн бэ гэдгийг 
	серверт (болон эсрэгээр) баталж чадах боломжийг олгодог.</para>

      <para><application>Kerberos</application> нь сүлжээний танин шалгах 
	протоколын нэрээс гадна програмыг (жишээ нь <application>Kerberos</application> 
	телнет) шийдвэрлэж байгаа програмуудыг тайлбарласан тайлбар бас болдог. 
	Протоколын одоогийн хувилбар нь 5 бөгөөд <acronym>RFC</acronym>&nbsp;1510-д 
	тайлбарласан байдаг.</para>

      <para>Өргөн хүрээний үйлдлийн системүүдийг хамарсан энэ протоколын хэд хэдэн чөлөөтэй 
	шийдлүүд  байдаг. <application>Kerberos</application> анх хөгжүүлэгдсэн 
	Массачусетсийн Технологийн Институт (<acronym>MIT</acronym>) нь 
	өөрийн <application>Kerberos</application> багцыг хөгжүүлсээр байна. 
	Энэ багц нь <acronym>US</acronym>-д криптограф бүтээгдэхүүн болж нийтлэг 
	хэрэглэгддэг бөгөөд энэ нь түүхээс авч үзэхэд <acronym>US</acronym>-ын 
	экспортын дүрэм журмуудаас болсон юм. <acronym>MIT</acronym>
	<application>Kerberos</application> нь порт 
	(<filename role="package">security/krb5</filename>) хэлбэрээр байдаг.
	Heimdal <application>Kerberos</application> нь өөр шийдлийн 5-р 
	хувилбар бөгөөд экспортын дүрэм журмуудыг тойрон гарах зорилгоор 
	<acronym>US</acronym>-ээс гадна хамааралгүйгээр хөгжүүлэгдсэн (
	бөгөөд ихэвчлэн арилжааны бус &unix; төрлүүдэд орсон байдаг) юм. 
	Heimdal <application>Kerberos</application> түгээлт нь 
	порт (<filename role="package">security/heimdal</filename>) 
	хэлбэрээр байдаг бөгөөд үүний хамгийн бага суулгац үндсэн &os; суулгацад 
	орсон байдаг.</para>

    <para>Аль болох олон үзэгчдийг хамрахын тулд эдгээр зааврууд нь &os;-д орсон 
	Heimdal түгээлтийг ашиглаж байна гэж тооцдог.</para>

    </sect2>

    <sect2>
      <title>Heimdal <acronym>KDC</acronym> суулгаж тохируулах</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Түлхүүр Түгээх Төв</secondary>
      </indexterm>

      <para>Түлхүүр Түгээх Төв (<acronym>KDC</acronym>) нь 
	<application>Kerberos</application>-ийн хангадаг төвлөрсөн нэвтрэлт таних 
	үйлчилгээ юм &mdash; энэ нь <application>Kerberos</application> 
	тасалбарууд өгдөг компьютер юм. <acronym>KDC</acronym> нь 
	<application>Kerberos</application> хүрээний бусад бүх компьютеруудад 
	 <quote>итгэгдсэн</quote> гэж тооцогддог бөгөөд аюулгүй байдлын санаа зовнилыг 
	дээшлүүлдэг.</para>

    <para><application>Kerberos</application> серверийг ажиллуулж байхад маш цөөн тооцооллын 
	эх үүсвэрийг шаарддаг боловч аюулгүй байдлын шалтгаанаас болоод зөвхөн 
	<acronym>KDC</acronym> болон ажиллах тусдаа зориулагдсан машинтай байхыг 
	зөвлөдгийг санаарай.</para>

    <para><acronym>KDC</acronym>-г тохируулж эхлэхдээ таны 
	<filename>/etc/rc.conf</filename> файлд <acronym>KDC</acronym> 
	болж ажиллах зөв тохиргоо хийгдсэн эсэхийг шалгаарай (өөрийн системийн хувьд 
	та замуудыг өөрчлөх хэрэгтэй байж болох юм):</para>

    <programlisting>kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

      <para>Дараа нь бид таны <application>Kerberos</application> тохиргооны 
	файл <filename>/etc/krb5.conf</filename>-г тохируулна:</para>

      <programlisting>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</programlisting>

      <para>Энэ <filename>/etc/krb5.conf</filename> файл нь 
	таны <acronym>KDC</acronym> нь бүрэн баталгаажсан хостын нэр 
	<hostid role="fqdn">kerberos.example.org</hostid>-тэй байна 
	гэж үзэж байгааг санаарай. Хэрэв таны <acronym>KDC</acronym> өөр 
	хостын нэртэй бол та өөрийн бүсийн файлдаа CNAME (alias)-ийг нэмэх 
	хэрэгтэй.</para>

      <note>
	<para>Зөв тохируулсан <acronym>BIND</acronym> <acronym>DNS</acronym> 
	сервер бүхий том сүлжээнүүдэд өмнөх жишээ нь:</para>

	<programlisting>[libdefaults]
      default_realm = EXAMPLE.ORG</programlisting>

	<para>болж дараах мөрүүдийг <hostid role="fqdn">example.org</hostid> 
	бүсийн файлд нэмж цэгцэлж болно:</para>

	<programlisting>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</programlisting></note>

      <note>
        <para><application>Kerberos</application> үйлчилгээнүүдийг хэрэглэгчдэд 
	хүртээмжтэй болгохын тулд та эсвэл бүрэн тохируулсан <filename>/etc/krb5.conf</filename> 
	файлтай эсвэл хамгийн багаар тохируулсан <filename>/etc/krb5.conf</filename> 
	файл <emphasis>болон</emphasis> зөв тохируулсан DNS сервертэй байх 
	<emphasis>ёстой</emphasis>.</para>
      </note>

      <para>Дараа нь бид <application>Kerberos</application> мэдээллийн бааз 
	үүсгэнэ. Энэ мэдээллийн бааз нь мастер нууц үгээр шифрлэсэн бүх удирдагчдын 
	түлхүүрүүдийг  агуулдаг. Та энэ нууц үгийг тогтоох шаардлагагүй, энэ нь 
	файлд (<filename>/var/heimdal/m-key</filename>) хадгалагдах болно.
	Мастер түлхүүр үүсгэхийн тулд <command>kstash</command> тушаалыг 
	ажиллуулж нууц үгээ оруулаарай.</para>

      <para>Мастер түлхүүр үүсгэгдсэний дараа та мэдээллийн баазыг 
	<command>kadmin</command> програмыг <literal>-l</literal> 
	тохируулгатай (<quote>локал</quote> гэсэн утгатай) ашиглан эхлүүлж болно.
	Энэ тохируулга нь <command>kadmin</command>-д мэдээллийн баазын 
	файлыг <command>kadmind</command> сүлжээний үйлчилгээгээр 
	дамжилгүйгээр шууд өөрчлөхийг заадаг. Энэ нь мэдээллийн бааз үүсэхээс 
	өмнө түүн уруу хандахыг оролдох асуудлыг (яг л өндөг, тахианы аль нь түрүүлж гарсан
 	гэж маргадаг тэр асуудлын адил) зохицуулдаг. <command>kadmin</command> 
	хүлээх мөртэй болсныхоо дараа та өөрийн хүрээнүүдийн эхний мэдээллийн санг 
	<command>init</command> тушаал ашиглан үүсгээрэй.</para>

      <para>Эцэст нь <command>kadmin</command>-ы горимд байхдаа өөрийн 
	эхний удирдагчийг <command>add</command> тушаал ашиглан үүсгээрэй. 
	Одоохондоо удирдагчийн хувьд анхдагч тохируулгуудыг сонгоорой, та 
	тэдгээрийг сүүлд нь <command>modify</command> тушаал ашиглан 
	өөрчилж чадна. Та аль ч тушаал хүлээх мөрөнд <literal>?</literal> 
	тушаал ашиглаж байгаа боломжит тохируулгуудыг харж болохыг 
	санаарай.</para>

      <para>Мэдээллийн сан үүсгэлтийн жишээ сесс доор байна:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
Master key: <userinput>xxxxxxxx</userinput>
Verifying password - Master key: <userinput>xxxxxxxx</userinput>

&prompt.root; <userinput>kadmin -l</userinput>
kadmin> <userinput>init EXAMPLE.ORG</userinput>
Realm max ticket life [unlimited]:
kadmin> <userinput>add tillman</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: <userinput>xxxxxxxx</userinput>
Verifying password - Password: <userinput>xxxxxxxx</userinput></screen>

      <para>Одоо <acronym>KDC</acronym> үйлчилгээнүүдийг эхлүүлэх цаг болжээ.
	Үйлчилгээнүүдийг эхлүүлэхдээ <command>/etc/rc.d/kerberos start</command> болон 
	<command>/etc/rc.d/kadmind start</command> тушаалуудыг 
	ажиллуулна. Энэ үед танд ямар ч kerberos хийгдсэн дэмон байхгүйг санаарай, 
	гэхдээ та <acronym>KDC</acronym>-ийн өөрийнх нь тушаалын мөрөөс үүсгэсэн удирдагчид
	(хэрэглэгч) зориулсан тасалбарыг авч жагсаан <acronym>KDC</acronym>-г ажиллаж байгаа 
	гэдгийг та баталж чадаж байх ёстой:</para>

      <screen>&prompt.user; <userinput>kinit <replaceable>tillman</replaceable></userinput>
tillman@EXAMPLE.ORG's Password:

&prompt.user; <userinput>klist</userinput>
Credentials cache: FILE:<filename>/tmp/krb5cc_500</filename>
	Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</screen>

	<para>Та дууссаныхаа дараа тасалбарыг буцааж болно:</para>

	<screen>&prompt.user; <userinput>k5destroy</userinput></screen>
      </sect2>

      <sect2>
	<title>Серверийг <application>Kerberos</application> хийн Heimdal үйлчилгээнүүдтэй  
	идэвхжүүлэх</title>

        <indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>үйлчилгээнүүдийг идэвхжүүлэх</secondary>
        </indexterm>

	<para>Эхлээд бидэнд <application>Kerberos</application>-ийн тохиргооны 
	файл <filename>/etc/krb5.conf</filename>-ийн хуулбар хэрэг болно. 
	Ингэхийн тулд <acronym>KDC</acronym>-ээс түүнийг аюулгүй аргаар 
	(&man.scp.1; зэрэг сүлжээний хэрэгслүүд эсвэл физикээр уян диск ашиглан) 
	клиент компьютер уруу ердөө л хуулах хэрэгтэй.</para>

	<para>Дараа нь танд <filename>/etc/krb5.keytab</filename> файл 
	хэрэгтэй. Энэ нь <application>Kerberos</application> хийгдсэн 
	дэмонууд бүхий сервер болон ажлын станц хоёрын гол ялгаа юм &mdash; 
	сервер нь <filename>keytab</filename> файлтай байх шаардлагатай. 
	Энэ файл нь өөрийг нь зөвшөөрдөг серверийн хост түлхүүр болон өөрсдийнхөө 
	нэрийг (identity) шалгах <acronym>KDC</acronym>-г агуулдаг. 
	Хэрэв түлхүүр нь нийтэд мэдэгдвэл серверийн аюулгүй байдал эвдэрч болох учир 
	энэ нь сервер уруу аюулгүйн үүднээс дамжуулагдах ёстой. Энэ нь шууд утгаараа 
	<acronym>FTP</acronym> зэрэг цэвэр текст сувгаар дамжуулах нь маш буруу 
	гэсэн үг юм.</para>

	<para>Ихэвчлэн сервер уруу <filename>keytab</filename> файлыг 
	<command>kadmin</command> тушаал ашиглан дамжуулдаг. 
	Энэ нь тохиромжтой байдаг бөгөөд учир нь та бас хостын удирдагчийг 
	(<filename>krb5.keytab</filename> файлын <acronym>KDC</acronym> 
	төгсгөл) <command>kadmin</command> тушаал ашиглан үүсгэх хэрэгтэй 
	болдог.</para>

	<para>Та тасалбарыг аль хэдийн авсан байх ёстой бөгөөд энэ тасалбар нь 
	<filename>kadmind.acl</filename> файлын <command>kadmin</command> 
	интерфэйсийг ашиглаж болохоор зөвшөөрөгдсөн байх ёстойг санаарай. 
	Heimdal-ийн мэдээллийн хуудаснуудын (<command>info heimdal</command>) 
	<quote>Алсын удирдлага</quote> гэсэн гарчигтай хэсгээс хандалт хянах жагсаалтуудыг 
	дизайн хийх талаар дэлгэрэнгүйг үзнэ үү. Хэрэв та алсын <command>kadmin</command> 
	хандалтыг идэвхжүүлэхийг хүсэхгүй байгаа бол та <acronym>KDC</acronym> уруу
	ердөө л аюулгүйгээр холбогдож (локал консолоор, &man.ssh.1; эсвэл 
	<application>Kerberos</application> &man.telnet.1;) удирдлагыг локалаар 
	өөр дээрээсээ <command>kadmin -l</command> тушаал ашиглан хийж болно.</para>

	<para><filename>/etc/krb5.conf</filename> файлыг суулгасны дараа та 
	<application>Kerberos</application> серверээс <command>kadmin</command> 
	тушаалыг ашиглаж болно. <command>add --random-key</command> тушаал нь 
	серверийн хост удирдагчийг нэмэх боломжийг танд олгох бөгөөд <command>ext</command> 
	тушаал нь серверийн хост удирдагчийг өөрийн keytab уруу задлах боломжийг танд олгоно.
	Жишээ нь:</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> add --random-key host/myserver.example.org</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin><userinput> ext host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

	<para><command>ext</command> тушаал нь (<quote>extract</quote> гэдгийг 
	богиноор илэрхийлнэ) задалсан түлхүүрийг анхдагчаар <filename>/etc/krb5.keytab</filename> 
	файлд хадгалдаг.</para>

	<para>Хэрэв таны хувьд <acronym>KDC</acronym> дээр <command>kadmind</command> 
	ажиллахгүй байгаа бөгөөд (магадгүй аюулгүй байдлын шалтгаануудаас болоод) 
	тэгээд <command>kadmin</command> уруу алсаас хандах боломжгүй бол та 
	хост удирдагчийг (<username>host/myserver.EXAMPLE.ORG</username>) 
	шууд <acronym>KDC</acronym> дээр нэмж дараа нь доор дурдсантай адилаар түүнийг түр 
	зуурын файл уруу (<acronym>KDC</acronym> дээрх 
	<filename>/etc/krb5.keytab</filename> файлыг дарж бичихээс сэргийлж) 
	задалж болно:</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> ext --keytab=/tmp/example.keytab host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

	<para>Та дараа нь keytab-ийг аюулгүйгээр (жишээ нь <command>scp</command> эсвэл 
	уян диск ашиглан) сервер компьютер уруу  хуулж болно. <acronym>KDC</acronym> 
	дээрх keytab-ийг дарж бичихээс сэргийлж keytab нэрийг анхдагч бишээр зааж өгсөн 
	эсэхээ шалгаарай.</para>

	<para>Энэ мөчид хүрэх үед таны сервер <acronym>KDC</acronym>-тэй 
	(<filename>krb5.conf</filename> файлтай учраас) холбогдож чадах бөгөөд 
	(<filename>krb5.keytab</filename> файлтай учраас) өөрийгөө таниулан баталж 
	чадна. Одоо та зарим нэг <application>Kerberos</application> үйлчилгээнүүдийг 
	идэвхжүүлэхэд бэлэн болжээ. Энэ жишээн дээр бид <command>telnet</command> 
	үйлчилгээг <filename>/etc/inetd.conf</filename> файлд доор дурдсантай төстэй 
	мөрийг оруулан идэвхжүүлж дараа нь &man.inetd.8; үйлчилгээг 
	<command>/etc/rc.d/inetd restart</command> тушаалын тусламжтай 
	дахин ачаалах болно:</para>

	<programlisting>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</programlisting>

	<para>Хамгийн чухал нь <command>-a</command> төрөл (нэвтрэлт танихад) 
	хэрэглэгчид тохируулагдсан. Илүү дэлгэрэнгүйг &man.telnetd.8; гарын 
	авлагын хуудаснаас лавлана уу.</para>

      </sect2>

      <sect2>
	<title>Клиентийг <application>Kerberos</application> хийн Heimdal үйлчилгээтэйгээр идэвхжүүлэх</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>клиентүүдийг тохируулах</secondary>
	</indexterm>

	<para>Клиент компьютерийг тохируулах нь маш амархан. 
	<application>Kerberos</application> тохиргоо хийгдсэний дараа танд зөвхөн 
	<filename>/etc/krb5.conf</filename>-д байрлах 
	<application>Kerberos</application> тохиргооны файл хэрэгтэй. 
	Үүнийг ердөө л аюулгүйгээр клиент компьютер уруу <acronym>KDC</acronym>-ээс 
	хуулна.</para>

	<para>Клиентээсээ <command>kinit</command>, <command>klist</command>, болон
	  <command>kdestroy</command> тушаалуудыг үүсгэсэн удирдагчийнхаа хувьд 
	тасалбар олж авах, үзүүлэх, болон дараа нь устгахад ашиглахыг оролдон клиент 
	компьютераа тест хийгээрэй. Та <application>Kerberos</application> 
	програмуудыг ашиглан <application>Kerberos</application> хийгдсэн 
	серверүүд уруу холбогдож чадах ёстой бөгөөд хэрэв ингэж ажиллаж болохгүй байгаа 
	бөгөөд тасалбар олж авах нь асуудалтай байгаа бол энэ нь клиент эсвэл 
	<acronym>KDC</acronym>-тэй холбоотой биш сервертэй холбоотой 
	асуудал юм.</para>

	<para><command>telnet</command> зэрэг програмыг тест хийж байх үед 
	таны нууц үг цэвэр текстээр бишээр илгээгдэж байгааг шалгахын тулд пакет 
	шиншлэгч (&man.tcpdump.1; зэрэг) ашиглаад үзээрэй. 
	<command>telnet</command>-ийг бүх өгөгдлийн урсгалыг шифрлэдэг  
	(<command>ssh</command>-тэй адил) <literal>-x</literal> тохируулгатай 
	ашиглахыг оролдоорой.</para>

	<para>Төрөл бүрийн гол биш <application>Kerberos</application> клиент 
	програмууд нь бас анхдагчаар суудаг. Энэ нь үндсэн Heimdal суулгацын 
	<quote>хамгийн бага</quote> мөн чанар юм: <command>telnet</command> 
	нь цорын ганц <application>Kerberos</application> хийгдсэн үйлчилгээ 
	юм.</para>

	<para>Heimdal порт нь зарим нэг дутуу програмуудыг нэмдэг: 
	<command>ftp</command>, <command>rsh</command>,
	  <command>rcp</command>, <command>rlogin</command> болон 
	бусад цөөн хэдэн нийтлэг биш програмуудын <application>Kerberos</application> 
	хийгдсэн хувилбаруудыг нэмдэг. <acronym>MIT</acronym> порт нь бас 
	<application>Kerberos</application> клиент програмуудын бүрэн цуглуулгыг 
	агуулдаг.</para>

      </sect2>

      <sect2>
	<title>Хэрэглэгчийн тохиргооны файлууд: <filename>.k5login</filename> болон <filename>.k5users</filename></title>

	<indexterm>
	  <primary><filename>.k5login</filename></primary>
	</indexterm>

	<indexterm>
	  <primary><filename>.k5users</filename></primary>
	</indexterm>

	<para>Хүрээн дэх хэрэглэгчийн хувьд ихэнхдээ өөрсдийнх нь <application>Kerberos</application> 
	удирдагчийг (<username>tillman@EXAMPLE.ORG</username> зэрэг) 
	локал хэрэглэгчийн бүртгэлд (<username>tillman</username> зэрэг локал бүртгэл) 
	харгалзуулж өгсөн байдаг. <command>telnet</command> зэрэг клиент 
	програмууд ихэвчлэн хэрэглэгчийн нэр эсвэл удирдагчийг шаарддаггүй.</para>

	<para>Гэхдээ хааяа нэг та харгалзах <application>Kerberos</application> 
	удирдагчгүй хэн нэгэнд зориулж локал хэрэглэгчийн бүртгэлд хандах хандалтыг 
	өгөхийг хүсэж болох юм. Жишээ нь <username>tillman@EXAMPLE.ORG</username> 
	магадгүй локал хэрэглэгчийн бүртгэл <username>webdevelopers</username>-д 
	хандах хандалт хэрэгтэй байж болох юм. Бусад удирдагчид бас энэ локал бүртгэлд хандах 
	хэрэгтэй байж болох юм.</para>

	<para><filename>.k5login</filename> болон <filename>.k5users</filename> 
	файлууд нь хэрэглэгчдийн гэрийн сангуудад байрладаг бөгөөд 
	<filename>.hosts</filename> болон <filename>.rhosts</filename> 
	файлуудын хүчирхэг хослолын нэгэн адилаар энэ асуудлыг шийдэн ашиглагдаж болох юм. 
	Жишээ нь хэрэв <filename>.k5login</filename> нь дараах агуулгатайгаар:</para>

	<screen>tillman@example.org
jdoe@example.org</screen>

	<para>локал хэрэглэгч <username>webdevelopers</username>-ийн гэр санд 
	байрлаж байвал энд жагсаагдсан хоёр удирдагч хоёулаа хуваалцсан нууц үгийн шаардлагагүйгээр 
	тэр бүртгэл уруу хандах хандалттай болох юм.</para>

	<para>Эдгээр тушаалуудын гарын авлагын хуудаснуудыг уншихыг зөвлөж байна. 
	<command>ksu</command> гарын авлагын хуудас <filename>.k5users</filename> 
	файлын тухай тайлбарладгийг тэмдэглэх нь зүйтэй юм.</para>

      </sect2>

      <sect2>
	<title><application>Kerberos</application>-той холбоотой арга, зальнууд болон алдааг олж  засварлах</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>алдааг олж засварлах</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para>Heimdal эсвэл <acronym>MIT</acronym>
	      <application>Kerberos</application> портууд ашиглах үед 
		таны <envar>PATH</envar> орчны хувьсагч 
		клиентийн програмуудын <application>Kerberos</application> 
		хувилбаруудыг системийн хувилбаруудаас өмнө жагсаасан байхыг 
		шаарддаг.</para>
	  </listitem>

	  <listitem>
	    <para>Таны хүрээний бүх компьютерууд цагийн тохиргоонуудаа адилаар 
		тохируулсан уу? Хэрэв үгүй бол нэвтрэлт танилт амжилтгүй болж 
		болох юм. <xref linkend="network-ntp"> нь 
		<acronym>NTP</acronym> ашиглан цагийг хамгийн сүүлийн 
		хэлбэрт аваачиж адил болгож тохируулах талаар тайлбарладаг.</para>
	  </listitem>

	  <listitem>
	    <para><acronym>MIT</acronym> болон Heimdal нь хоорондоо сайн 
		ажилладаг. <command>kadmin</command>-аас бусад талаараа 
		сайн ажилладаг, учир нь энэ програмын протокол стандартчилагдаагүй.</para>
	  </listitem>

	  <listitem>
	    <para>Та хэрэв өөрийн хостын нэрийг өөрчилбөл бас өөрийн <username>host/</username> 
		удирдагчийг өөрчилж өөрийн keytab-ийг шинэчлэх хэрэгтэй. Энэ нь бас 
		Апачигийн <filename role="package">www/mod_auth_kerb</filename>-д 
		хэрэглэгддэг <username>www/</username> удирдагч зэрэг тусгай keytab 
		оруулгуудад хамаатай юм.</para>
	  </listitem>

	  <listitem>
	    <para>Таны хүрээний бүх хостууд <acronym>DNS</acronym>-д (эсвэл
	     	хамгийн багадаа <filename>/etc/hosts</filename>-ийн хувьд) танигдаж 
		(урагш болон эсрэгээр танигдаж) байх ёстой. CNAME-үүд ажиллах боловч A болон PTR 
		бичлэгүүд зөв бөгөөд байрандаа байж байх ёстой. Алдааны мэдэгдэл нь 
		тийм ч ойлгогдохоор байдаггүй, жишээ нь: <errorname>Kerberos5
		refuses authentication because Read req
	      failed: Key table entry not found буюу орчуулбал 
		Унших Req амжилтгүй болсон болохоор Kerberos5 нь нэвтрэлт танилтаас 
		татгалзаж байна</errorname>.</para>
	  </listitem>

	  <listitem>
	    <para>Таны <acronym>KDC</acronym>-ийн хувьд магадгүй клиент маягаар 
		харьцаж байгаа зарим үйлдлийн системүүд setuid
	      <username>root</username> болохын тулд <command>ksu</command>
		тушаалд зөвшөөрлүүдийг тохируулдаггүй. Энэ нь <command>ksu</command> 
		ажиллахгүй гэсэн үг бөгөөд аюулгүй байдлын хувьд сайн боловч залхаамаар 
		байдаг. Энэ  нь <acronym>KDC</acronym>-ийн алдаа биш юм.</para>
	  </listitem>

	  <listitem>
	    <para><acronym>MIT</acronym>
	      <application>Kerberos</application>-той байхад хэрэв та 
		анхдагч 10 цагаас арай урт амьдрах хугацаа бүхий тасалбартай удирдагчийг 
		зөвшөөрөхийг хүсвэл <command>kadmin</command> дээр 
		<command>modify_principal</command> тушаал ашиглан 
		өөрчлөхийг хүссэн удирдагч болон <username>krbtgt</username> 
		удирдагчийн maxlife-ийг өөрчлөх шаардлагатай. Дараа нь 
		удирдагч <literal>-l</literal> тохируулгыг 
		<command>kinit</command>-тай ашиглаж илүү урт амьдрах хугацаатай 
		тасалбарыг авах хүсэлт илгээж болох юм.</para>
	  </listitem>

	  <listitem>
	    <note><para>Хэрэв та өөрийн <acronym>KDC</acronym> дээр 
		алдааг олж засварлахын тулд пакет шиншлэгч ажиллуулж дараа нь 
		ажлын станцаасаа <command>kinit</command>-ийг ажиллуулахад  
		<command>kinit</command>-ийг ажилласан даруй 
		таны <acronym>TGT</acronym> илгээгдэхийг 
		&mdash; таныг бүр нууц үгээ бичихээс өмнө та харах болно! 
		Үүний тайлбар нь <application>Kerberos</application> 
		сервер чөлөөтэйгээр <acronym>TGT</acronym>-ийг (Ticket Granting
	      Ticket буюу Тасалбар Баталгаажуулах Тасалбар) ямар ч танигдаагүй 
		хүсэлтэд дамжуулдаг; гэхдээ <acronym>TGT</acronym> бүр 
		хэрэглэгчийн нууц үгээс гарсан түлхүүр болон шифрлэгдсэн байдаг.
		Тийм болохоор хэрэглэгч өөрсдийн нууц үгийг бичихэд 
		тэр нь <acronym>KDC</acronym> уруу илгээгддэггүй бөгөөд 
		харин <command>kinit</command>-ийн аль хэдийн олж авсан 
		<acronym>TGT</acronym>-г буцааж шифрлэхэд (decrypt) 
		ашиглагддаг. Хэрэв буцааж шифрлэх процесс хүчинтэй хугацаа бүхий  
		хүчинтэй тасалбарыг гаргаж авбал хэрэглэгч хүчинтэй 
		<application>Kerberos</application> итгэмжлэлүүдтэй 
		байна. Эдгээр итгэмжлэлүүд нь ирээдүйд 
		<application>Kerberos</application> сервертэй аюулгүй холболтууд 
		хийхэд зориулагдсан сессийн түлхүүр болон бас <application>Kerberos</application>
		серверийн өөрийнх нь түлхүүрээр шифрлэгдсэн тасалбар-баталгаажуулах 
		тасалбарыг агуулдаг. Шифрлэлтийн хоёр дахь давхарга нь хэрэглэгчид 
		мэдэгддэггүй, гэхдээ энэ нь <acronym>TGT</acronym> бүрийн 
		жинхэнийг шалгахыг <application>Kerberos</application> 
		серверт зөвшөөрч байгаа тэр зүйл юм.</para></note>
	  </listitem>

	  <listitem>
	    <para>Хэрэв та урт амьдрах хугацаатай (жишээ нь долоо хоног) тасалбар ашиглахыг 
		хүсэж байгаа бөгөөд та тасалбар хадгалагдаж байгаа машин уруу 
		<application>OpenSSH</application> ашиглан холбогдож байгаа бол 
		<application>Kerberos</application>
	      <option>TicketCleanup</option> тохируулга <literal>no</literal> 
		гэж <filename>sshd_config</filename> тохиргооны файлд байгаа эсэхийг 
		шалгаарай, тэгэхгүй бол таны тасалбарууд таныг гарах үед устгагдах 
		болно.</para>
	  </listitem>

	  <listitem>
	    <para>Хостын удирдагчид илүү урт амьдрах хугацаатай тасалбартай бас байж болно 
		гэдгийг санаарай. Хэрэв таны хэрэглэгчийн удирдагч долоо хоног амьдрах хугацаатай 
		бөгөөд гэхдээ таны холбогдож байгаа хост 9 цаг амьдрах хугацаатай бол 
		та кэшдээ хугацаа нь дууссан хостын удирдагчтай болж тасалбарын кэш 
		хүссэнээр ажиллахгүй болох болно.</para>
	  </listitem>

	  <listitem>
	    <para>Тусгайлсан муу нууц үгүүдийг ашиглуулахгүйн тулд (<command>kadmind</command> 
		тушаалын гарын авлагын хуудас үүнийг товчхон тайлбарладаг) 
		<filename>krb5.dict</filename> файлыг тохируулахдаа 
		нууц үгийн бодлого тавигдсан удирдагчдад энэ нь зөвхөн хамаатайг санах 
		хэрэгтэй. <filename>krb5.dict</filename> файлуудын хэлбэр 
		хялбар байдаг: нэг мөрт нэг үг (string) байна. <filename>/usr/share/dict/words</filename> 
		симболын холбоос үүсгэх нь ашигтай байж болох юм.</para>
	  </listitem>
        </itemizedlist>

      </sect2>

      <sect2>
	<title><acronym>MIT</acronym> портоос ялгаатай талууд</title>

	<para><acronym>MIT</acronym> болон Heimdal суулгацуудын гол ялгаа нь 
	өөр (гэхдээ орлуулж болох) тушаалууд болон өөр протоколууд ашигладаг 
	<command>kadmin</command> програмтай холбоотой юм. 
	Хэрэв таны <acronym>KDC</acronym> нь <acronym>MIT</acronym> бол 
	та Heimdal <command>kadmin</command> програмыг ашиглаж өөрийн 
	<acronym>KDC</acronym>-г алсаас (эсвэл эсрэг чиглэлд энэ 
	зорилгоор) удирдаж чадахгүй  болдог учир энэ нь их хамаатай юм.</para>

	<para>Клиент програмууд нь бас шал өөр өөр тушаалын мөрийн тохируулгууд авч 
	адил үүргийг гүйцэтгэж болох юм. <acronym>MIT</acronym>
	  <application>Kerberos</application> вэб сайт 
	(<ulink url="http://web.mit.edu/Kerberos/www/"></ulink>) дээрх заавруудыг 
	дагахыг зөвлөж байна. Замын асуудлуудаас болгоомжлоорой: 
	<acronym>MIT</acronym> порт нь анхдагчаар <filename>/usr/local/</filename> 
	уруу суудаг бөгөөд хэрэв таны <envar>PATH</envar> орчны хувьсагч системийн 
	сангуудыг эхлээд жагсаадаг бол <quote>жирийн</quote> системийн програмууд 
	<acronym>MIT</acronym>-ийн оронд ажиллаж болохыг санаарай.</para>

	<note><para><command>telnetd</command> болон <command>klogind</command>-ээр 
	нэвтрэх нэвтрэлтүүд нэг л хачин байдаг тэр шалтгааныг ойлгохыг хүсвэл &os;-ийн хангадаг 
	<acronym>MIT</acronym> <filename role="package">security/krb5</filename> портын 
	суулгасан <filename>/usr/local/share/doc/krb5/README.FreeBSD</filename> 
	файлыг унших хэрэгтэй. Хамгийн чухал нь 
	<quote>кэш файл дахь буруу зөвшөөрлүүд</quote>ийг зөв болгох нь 
	дамжуулагдсан итгэмжлүүдийн эзэмшилтийг зөвөөр солих <command>login.krb5</command> 
	хоёртын файлыг нэвтрэлт танилтад ашиглахыг шаарддаг.</para></note>

	<para><filename>rc.conf</filename> файл дараах тохиргоог агуулж засварлагдсан 
		байх бас шаардлагатай:</para>

	<programlisting>kerberos5_server="/usr/local/sbin/krb5kdc"
kadmind5_server="/usr/local/sbin/kadmind"
kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>

	<para><acronym>MIT</acronym> керберосд зориулсан програмууд 
	<filename role="directory">/usr/local</filename> санд хоёртын файлуудыг 
	суулгадаг болохоор ингэж хийгддэг.</para>
      </sect2>

      <sect2>
	<title><application>Kerberos</application> дахь хязгааруудыг багасгах</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>хязгаарууд болон дутагдлууд</secondary>
	</indexterm>

	<sect3>
	 <title><application>Kerberos</application> нь бүгдийг эсвэл юуг ч биш гэсэн арга юм</title>

	  <para>Сүлжээнд идэвхжүүлэгдсэн үйлчилгээ бүр <application>Kerberos</application>-тэй 
		ажиллахаар засварлагдсан (эсвэл сүлжээний халдлагуудын эсрэг аюулгүй 
		байдлыг хангасан) байх шаардлагатай, тэгэхгүй бол хэрэглэгчдийн 
		итгэмжлэлүүд хулгайлагдаж дахин ашиглагдаж болох юм. Үүний нэг жишээ нь 
		бүх алсын бүрхүүлүүдийг (жишээ нь <command>rsh</command> болон 
		<command>telnet</command>) <application>Kerberos</application> хийн 
		идэвхжүүлсэн мөртлөө нууц үгүүдийг цэвэр текстээр илгээдэг <acronym>POP3</acronym> 
		захидлын серверийг тэгж хувиргахгүй байх явдал юм.</para>

	</sect3>

	<sect3>
	  <title><application>Kerberos</application> нь ганц хэрэглэгчийн ажлын станцуудад зориулагдсан</title>

	  <para>Олон хэрэглэгчийн орчинд <application>Kerberos</application> нь 
		тийм ч аюулгүй биш юм. Энэ нь тасалбаруудыг бүх хэрэглэгчийн хувьд уншигдаж 
		болох <filename>/tmp</filename> санд хадгалдаг учраас тэр юм. 
		Хэрэв хэрэглэгч компьютераа хэд хэдэн бусад хүмүүстэй зэрэг харилцан хуваалцаж 
		байвал (өөрөө хэлбэл олон-хэрэглэгч) хэрэглэгчийн тасалбаруудыг өөр хэрэглэгч 
		хулгайлах (хуулан авах) боломжтой юм.</para>

	  <para>Үүнийг <literal>-c</literal> файлын нэрийн тушаалын мөрийн тохируулгатай 
		эсвэл (илүү зохимжтой) <envar>KRB5CCNAME</envar> орчны хувьсагчтайгаар 
		даван гарч болох юм, гэхдээ ингэх нь их ховор байдаг. Зарчмын хувьд 
		тасалбарыг хэрэглэгчдийн гэр санд хадгалж хялбар файлын зөвшөөрлүүдийг ашиглах нь 
		энэ асуудлыг багасгадаг.</para>

	</sect3>

	<sect3>
	  <title>KDC нь бүтэлгүйтлийн ганц цэг</title>

	  <para>Дизайнаараа бол <acronym>KDC</acronym> нь мастер нууц үгийн 
		мэдээллийн баазаас тогтох бөгөөд түүний нэгэн адил аюулгүй байх ёстой.
		<acronym>KDC</acronym> нь үүн дээр өөр ямар ч үйлчилгээнүүд 
		ажиллуулсан байх ёсгүй бөгөөд физикээр аюулгүй байдлыг нь 
		хангасан байх шаардлагатай. <application>Kerberos</application> 
		нь ижил түлхүүрээр (<quote>мастер</quote> түлхүүр) шифрлэгдсэн бүх 
		нууц үгүүдийг хадгалдаг бөгөөд тэр ижил түлхүүр нь эргээд 
		<acronym>KDC</acronym> дээр файл маягаар хадгалагддаг учраас 
		аюул өндөртэй байдаг.</para>

	  <para>Тэмдэглэн хэлэхэд булаан эзлэгдсэн мастер түлхүүр нь хэн нэг нь айхаар 
		тийм ч муу биш юм. Түлхүүр үг нь зөвхөн <application>Kerberos</application> 
		мэдээллийн баазыг шифрлэхэд болон санамсаргүй тоо үүсгэгчийн үр болон 
		хэрэглэгддэг. Таны <acronym>KDC</acronym> уруу хандахад аюулгүй л 
		байж байвал халдагч мастер түлхүүрээр их юм хийж чадахгүй.</para>

	  <para>Мөн нэмж хэлэхэд хэрэв <acronym>KDC</acronym> нь боломжгүй байвал 
		(магадгүй үйлчилгээ зогсоох халдлага эсвэл сүлжээний асуудлуудаас болоод)
		сүлжээний үйлчилгээнүүд нь нэвтрэлт танилтыг хийж болохгүй болохоор 
		хэрэглэгдэх боломжгүй болох бөгөөд нэг ёсны үйлчилгээ зогсоох халдлагын рецепт 
		болох юм. Үүнийг олон <acronym>KDC</acronym>-тэй (нэг мастер болон 
		нэг буюу хэд хэдэн боолууд) болон хоёрдогч эсвэл нэмэлт, эцсийн нэвтрэлт таних  
		(<acronym>PAM</acronym> нь энэнд маш сайн) болгоомжтой шийдлийн 
		тусламжтайгаар даван гарч болох юм.</para>

	</sect3>

	<sect3>
	  <title><application>Kerberos</application>-ийн дутагдлууд</title>

	  <para><application>Kerberos</application> нь хэрэглэгчид, хостууд болон 
		үйлчилгээнүүдэд өөр хоорондоо бие биенээ таниулах боломжийг олгодог. Гэхдээ энэ нь 
		<acronym>KDC</acronym>-г хэрэглэгчид, хостууд эсвэл үйлчилгээнүүдэд 
		таниулах аргагүй юм. Энэ нь троян хийгдсэн <command>kinit</command> (жишээ нь) 
		тушаал бүх хэрэглэгчийн нэрс болон нууц үгүүдийг бүртгэн бичиж авч болно гэсэн 
		үг юм. <filename role="package">security/tripwire</filename> 
		ч юм уу эсвэл өөр бусад файлын системийн бүрэн бүтэн байдлыг шалгах хэрэгслүүд
		үүнийг арилгаж чадна.</para>

	</sect3>
      </sect2>

      <sect2>
	<title>Эх сурвалжууд болон нэмэлт мэдээллүүд</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>гадаад эх сурвалжууд</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	  <para><ulink
	    url="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">
	    <application>Kerberos</application>-ийн FAQ</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://web.mit.edu/Kerberos/www/dialogue.html">
		Танин шалгах системийг дизайн хийх нь: Дөрвөн үзэгдэл дэх харилцан яриа (диалог)</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510,
	    <application>Kerberos</application> Сүлжээний Танин Шалгах Үйлчилгээ
	    (V5)</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://web.mit.edu/Kerberos/www/"><acronym>MIT</acronym>
	    <application>Kerberos</application>-ийн гэр хуудас</ulink></para>
	</listitem>

	<listitem>
	<para><ulink url="http://www.pdc.kth.se/heimdal/">Heimdal
	  <application>Kerberos</application>-ийн гэр хуудас</ulink></para>
	</listitem>

	</itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="openssl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Бичсэн </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>OpenSSL</title>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>

    <para>Олон хэрэглэгчдийн хайдаг нэг боломж нь &os;-д байдаг 
	<application>OpenSSL</application> багаж юм. 
	<application>OpenSSL</application> нь ердийн холбооны давхарга 
	дээр шифрлэлт дамжуулах давхаргыг хангаж өгдөг; ингэснээр түүнийг сүлжээний 
	програмууд болон үйлчилгээнүүдтэй холбож өгөх боломжийг олгодог.</para>

    <para><application>OpenSSL</application>-ийн зарим нэг хэрэглээнд  
	захидлын клиентүүдийн шифрлэсэн нэвтрэлт, кредит картаар хийх төлбөрүүд гэх мэт 
	вэб дээр тулгуурласан шилжүүлгүүд зэрэг олныг дурдаж болно. 
	<filename role="package">www/apache13-ssl</filename> болон 
	<filename role="package">mail/sylpheed-claws</filename> зэрэг 
	олон портууд нь <application>OpenSSL</application>-тэй бүтээх 
	эмхэтгэлийн дэмжлэгийг санал болгодог.</para>

    <note>
      <para>Ихэнх тохиолдолд Портуудын Цуглуулга нь make хувьсагч 
	<makevar>WITH_OPENSSL_BASE</makevar>-ийг <quote>yes</quote> 
	гэж заагаагүй тохиолдолд  
	<filename role="package">security/openssl</filename> портыг 
	бүтээхийг оролддог.</para>
    </note>

    <para>&os;-д орсон <application>OpenSSL</application>-ийн хувилбар нь 
	Secure Sockets Layer v2/v3 (SSLv2/SSLv3) буюу Аюулгүй Сокетуудын 
	Давхаргын v2/v3 хувилбарууд, Transport Layer Security v1 (TLSv1) буюу 
	Тээврийн Давхаргын Аюулгүй байдлын v1 хувилбарын сүлжээний аюулгүй байдлын 
	протоколуудыг дэмждэг бөгөөд ерөнхий криптограф сан болон ашиглагдаж 
	болох юм.</para>

    <note>
      <para><application>OpenSSL</application> нь 
	<acronym>IDEA</acronym> алгоритмийг дэмждэг боловч Нэгдсэн Улсын 
	патентуудаас болоод анхдагчаар хаалттай байдаг. Үүнийг ашиглахын тулд 
	лицензийг шалгасан байх ёстой бөгөөд хэрэв хязгаарлалтуудыг хүлээн 
	авах боломжтой бол <makevar>MAKE_IDEA</makevar> хувьсагчийг 
	<filename>make.conf</filename> файлд заагж өгөх ёстой байдаг.</para>
    </note>

    <para><application>OpenSSL</application>-ийн хамгийн түгээмэл хэрэглээний 
	нэг бол програм хангамжуудад зориулан ашиглах сертификатуудыг бэлдэх явдал 
	юм. Эдгээр сертификатууд нь компани болон хувь хүмүүсийн итгэмжлэлүүдийг  
	хүчинтэй бөгөөд луйврын биш гэдгийг баталгаажуулдаг. Хэрэв асуудалтай сертификат 
	хэд хэдэн <quote>Certificate Authorities</quote> эсвэл <acronym>CA</acronym>-ууд буюу 
	Сертификатын Эрх мэдэлтнүүдээр шалгагдаагүй бол ихэвчлэн анхааруулга үзүүлдэг. 
	Сертификатын Эрх мэдэлтэн нь <ulink url="http://www.verisign.com">VeriSign</ulink> зэрэг 
	компани байдаг бөгөөд компаниуд эсвэл хувь хүмүүсийн итгэмжлэлүүдийг хүчин төгөлдөр болгохын 
	тулд сертификатуудыг баталгаажуулж өгдөг. Энэ процесс нь өртөгтэй бөгөөд 
	сертификатууд ашиглахад заавал ч үгүй шаардлага болдоггүй; гэхдээ энэ нь 
	паранойд буюу хэт зовнисон хэрэглэгчдийн заримын санааг тайвшруулж болох юм.</para>

    <sect2>
      <title>Сертификатуудыг үүсгэх нь</title>

      <indexterm>
	<primary>OpenSSL</primary>
	<secondary>сертификат үүсгэлт</secondary>
      </indexterm>

      <para>Сертификат үүсгэхийн тулд дараах тушаал байдаг:</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.pem</userinput>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (eg, YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:<userinput><replaceable>SOME PASSWORD</replaceable></userinput>
An optional company name []:<userinput><replaceable>Another Name</replaceable></userinput></screen>

      <para><quote>Common Name</quote> хүлээх мөрийн дараах хариу домэйны 
	нэрийг харуулж байгааг анзаараарай. Энэ мөр нь шалгалт хийх зорилгоор 
	серверийн нэрийг оруулахыг шаарддаг; домэйн нэрээс бусдыг байрлуулах нь 
	ашиггүй сертификат үүсэхэд хүргэдэг. Бусал тохируулгууд, жишээ нь 
	дуусах хугацаа, өөр шифрлэх алгоритмууд гэх мэт тохируулгууд байдаг.
	Бүрэн гүйцэд жагсаалтыг &man.openssl.1; гарын авлагын хуудсыг үзэн 
	авч болно.</para>

      <para>Дээрх тушаалын ажилласан санд хоёр файл одоо байж байх ёстой. 
	Сертификатын хүсэлт <filename>req.pem</filename> нь таны оруулсан итгэмжлэлүүдийг 
	хүчин төгөлдөр болгож хүсэлтийг баталгаажуулан сертификатыг танд буцаах сертификатын 
	эрх мэдэлтэн уруу илгээгдэж болно. Үүсгэгдсэн хоёр дахь файл нь 
	<filename>cert.pem</filename> гэж нэрлэгдэн сертификатын хувийн түлхүүр 
	болох бөгөөд ямар ч байсан гэсэн хамгаалагдсан байх ёстой; хэрэв энэ нь 
	бусдын гарт орох юм бол таны (эсвэл таны серверийн) дүрд тоглон ашиглагдаж болох 
	юм.</para>

      <para><acronym>CA</acronym>-с гарын үсэг шаарддаггүй тохиолдолд 
	өөрөө зурсан сертификатыг үүсгэж болно. Эхлээд <acronym>RSA</acronym> 
	түрхүүр үүсгэх хэрэгтэй:</para>

      <screen>&prompt.root; <userinput>openssl dsaparam -rand -genkey -out <filename>myRSA.key</filename> 1024</userinput></screen>
	
	<para>Дараа нь <acronym>CA</acronym> түлхүүр үүсгэ:</para>

      <screen>&prompt.root; <userinput>openssl gendsa -des3 -out <filename>myca.key</filename> <filename>myRSA.key</filename></userinput></screen>

      <para>Сертификат үүсгэхийн тулд энэ түлхүүрийг ашигла :</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key <filename>myca.key</filename> -out <filename>new.crt</filename></userinput></screen>

      <para>Санд хоёр шинэ файл үүсэх ёстой: сертификатын эрх мэдэлтний гарын 
	үсгийн файл <filename>myca.key</filename> болон сертификат өөрөө 
	<filename>new.crt</filename> байна. Эдгээрийг 
	зөвхөн <username>root</username> унших эрхтэй 
	<filename class="directory">/etc</filename> санд байрлуулах 
	шаардлагатай. Үүнд 0700 зөвшөөрөл байж болох бөгөөд түүнийг 
	<command>chmod</command> хэрэгсэл ашиглан тохируулж болно.</para>
    </sect2>

    <sect2>
      <title>Сертификатуудыг ашиглах нь, жишээ</title>

      <para>Тэгэхээр эдгээр файлууд нь юу хийж чадах вэ? Сайн хэрэглээ болох нэг 
	жишээ нь <application>Sendmail</application>
	<acronym>MTA</acronym> уруу хийгдэх холболтуудыг шифрлэх байж болно. 
	Энэ нь локал <acronym>MTA</acronym> ашиглан захидал илгээх 
	хэрэглэгчдийн цэвэр текст нэвтрэлтийн хэрэглээг болиулах юм.</para>

      <note>
	<para>Зарим <acronym>MUA</acronym>-ууд нь хэрэв хэрэглэгчид дотроо 
	сертификат суулгаагүй бол тэдэнд алдааг харуулдаг болохоор энэ нь 
	ертөнц дээрх хамгийн шилдэг хэрэглээ биш юм. 
	Сертификат суулгах тухай илүү мэдээллийг програм хангамжтай цуг ирсэн 
	баримтаас  үзэх хэрэгтэй.</para>
      </note>

      <para>Дотоод <filename>.mc</filename> файл дотор дараах мөрүүдийг 
	байрлуулах хэрэгтэй:</para>

      <programlisting>dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl</programlisting>

      <para>Дээрх <filename class="directory">/etc/certs/</filename> нь 
	сертификат болон түлхүүр файлуудыг дотооддоо хадгалах сан юм. 
	Сүүлийн хэдэн шаардлагууд нь дотоод <filename>.cf</filename> файлын 
	дахин бүтээлт юм. Үүнийг <filename class="directory">/etc/mail</filename> сан 
	дотроос <command>make <maketarget>install</maketarget></command> тушаал 
	бичин хийж болно. Ингэсний дараа <command>make 
	<maketarget>restart</maketarget></command> тушаалыг ажиллуулаарай, энэ нь 
	<application>Sendmail</application> дэмонг эхлүүлэх ёстой.</para>

      <para>Хэрэв бүгд зүгээр болж өнгөрвөл <filename>/var/log/maillog</filename> 
	файлд ямар ч алдаа бичигдэхгүй бөгөөд <application>Sendmail</application> 
	процессийн жагсаалтад харуулагдана.</para>

      <para>Хялбар тест хийхийн тулд &man.telnet.1; хэрэгсэл ашиглан 
	захидлын серверт холбогдох хэрэгтэй:</para>

      <screen>&prompt.root; <userinput>telnet <replaceable>example.com</replaceable> 25</userinput>
Trying 192.0.34.166...
Connected to <hostid role="fqdn">example.com</hostid>.
Escape character is '^]'.
220 <hostid role="fqdn">example.com</hostid> ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
<userinput>ehlo <replaceable>example.com</replaceable></userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 <hostid role="fqdn">example.com</hostid> closing connection
Connection closed by foreign host.</screen>

      <para>Хэрэв <quote>STARTTLS</quote> мөр гарч ирвэл бүгд зөв ажиллаж 
	байна.</para>
    </sect2>
  </sect1>

  <sect1 id="ipsec">
    <sect1info>
      <authorgroup>
        <author>
  	  <firstname>Ник</firstname>
	  <surname>Клэйтон</surname>
	  <affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
          </affiliation>
          <contrib>Бичсэн </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>IPsec</primary>
    </indexterm>

    <title>IPsec дээгүүр VPN хийх</title>
    <para>FreeBSD гарц машинуудыг ашиглан Интернэтээр тусгаарлагдсан хоёр сүлжээний 
	хооронд VPN үүсгэх.</para>
 
    <sect2>
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Хитэн М.</firstname>
            <surname>Пандиа</surname>
	    <affiliation>
	      <address><email>hmp@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>Бичсэн </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>IPsec-ийг ойлгох нь</title>

      <para>Энэ хэсэг IPsec-ийг тохируулах процессийг тайлбарлаж 
	FreeBSD болон <application>&microsoft.windows; 2000/XP</application> 
	машинуудаас тогтох орчинд түүнийг ашиглан тэдгээрийг өөр хоорондоо аюулгүйгээр 
	холбогдох нөхцөлийг бүрдүүлэх талаар зааварлах болно. IPsec-ийг тохируулахын 
	тулд та өөрчлөн тохируулсан цөм бүтээх ухагдахууныг мэдсэн байх шаардлагатай
	(<xref linkend="kernelconfig">-г үзнэ үү).</para>
    
      <para><emphasis>IPsec</emphasis> нь Интернэт Протокол (IP) давхаргын 
	дээр суудаг протокол юм. Энэ нь хоёр буюу хэд хэдэн хостуудыг аюулгүй байдлаар 
	(нэрээс нь харах юм бол) холбох боломжийг олгодог. FreeBSD IPsec 
	<quote>сүлжээний стек</quote> нь IPv4 болон IPv6 протоколуудыг хоёуланг 
	дэмждэг <ulink url="http://www.kame.net/">KAME</ulink> шийдэл дээр 
	үндэслэсэн.</para>

      <note>
        <para>FreeBSD нь OpenBSD-ээс авсан <quote>Fast IPsec буюу 
	Хурдан IPsec</quote> гэгддэг <quote>тоног төхөөрөмжөөр хурдасгасан</quote> 
	IPsec стектэй. Энэ нь IPsec-ийн ажиллагааг оновчтой болгохын тулд &man.crypto.4; 
	дэд системийн тусламжтайгаар криптограф тоног төхөөрөмжийг (аль болох бүх газар) 
	хэрэглэдэг. Энэ нь шинэ дэд систем бөгөөд IPsec-ийн KAME хувилбарт байдаг 
	бүх боломжуудыг дэмждэггүй. Гэхдээ тоног төхөөрөмжөөр хурдасгасан IPsec-ийг 
	идэвхжүүлэхийн тулд өөрийн цөмийн тохиргооны файлдаа дараах цөмийн тохируулгыг 
	нэмэх хэрэгтэй:</para>

	<indexterm>
	  <primary>цөмийн тохируулгууд</primary>
	  <secondary>FAST_IPSEC</secondary>
	</indexterm>

        <screen>
options	  FAST_IPSEC  # new IPsec (cannot define w/ IPSEC)
        </screen>

        <para>IPsec-ийн KAME шийдлийн оронд <quote>Fast IPsec</quote> 
	дэд системийг ашиглах боломж одоогоор байхгүйг тэмдэглэе. Дэлгэрэнгүй 
	мэдээллийг &man.fast.ipsec.4; гарын авлагын хуудаснаас 
	лавлана уу.</para>
      </note>

      <note>
	<para>Галт хануудад &man.gif.4; туннелийн төлөвийг бас зөв дагаж 
	мөрдөх боломжийг олгохын тулд та өөрийн цөмийн тохиргооны файлдаа 
	<option>IPSEC_FILTERGIF</option> тохируулгыг идэвхжүүлэх 
	хэрэгтэй:</para>

	<screen>
options   IPSEC_FILTERGIF  #filter ipsec packets from a tunnel
	</screen>
      </note>
  
      <indexterm>
	<primary>IPsec</primary>
	<secondary>ESP</secondary>
      </indexterm>
  
      <indexterm>
	<primary>IPsec</primary>
	<secondary>AH</secondary>
      </indexterm>

      <para>IPsec нь хоёр дэд протоколоос тогтоно:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Encapsulated Security Payload
	      (ESP) буюу Хайрцаглагдсан Аюулгүй байдлын ачаа</emphasis> нь 
		гуравдагчийн нөлөөллөөс тэгш хэмт криптограф алгоритмийг 
		(Blowfish, 3DES-тэй адил) ашиглан агуулгыг нь шифрлэж 
		IP пакетийн өгөгдлийг хамгаалдаг.</para>
        </listitem>
        <listitem>
          <para><emphasis>Authentication Header (AH) буюу Нэвтрэлт Танилтын 
		Толгой</emphasis> нь аюулгүй хэш хийх функцаар IP пакетийн толгойн 
		талбаруудыг хэш хийн криптограф хянах нийлбэрийг тооцоолон гуравдагч 
		этгээдийн нөлөөлөл болон хууран мэхлэлтээс IP пакетийн толгойг 
		хамгаалдаг. Үүний дараа пакет дахь мэдээллийг таниулахыг зөвшөөрөх 
		хэшийг агуулсан нэмэлт толгой байдаг.</para>
        </listitem>
      </itemizedlist>
      
      <para><acronym>ESP</acronym> болон <acronym>AH</acronym> нь 
	орчноосоо хамаараад хоёулаа цуг эсвэл тусдаа ашиглагдаж болно.</para>
      
      <indexterm>
	<primary>VPN</primary>
      </indexterm>

      <indexterm>
	<primary>виртуал хувийн сүлжээ</primary>
	<see>VPN</see>
      </indexterm>

      <para>IPsec нь хоёр хостын хоорондох урсгалыг шууд шифрлэх (<emphasis>Transport
	  Mode буюу Тээвэрлэх Горим</emphasis> гэгддэг) буюу эсвэл 
	хоёр корпорацийн сүлжээний хооронд аюулгүй холбоонд ашиглагдаж болох 
	<quote>виртуал туннелиуд</quote> (<emphasis>Tunnel Mode буюу Туннелийн 
	Горим</emphasis> гэгддэг) бүтээхэд хэрэглэгдэж болох юм. Сүүлийнх нь ерөнхийдөө 
	<emphasis>Виртуал Хувийн Сүлжээ (VPN)</emphasis> гэгддэг. 
	FreeBSD-ийн IPsec дэд системийн талаар дэлгэрэнгүй мэдээллийг 
	&man.ipsec.4; гарын авлагын хуудаснаас лавлах хэрэгтэй.</para>
      
      <para>Өөрийн цөмдөө IPsec дэмжлэгийг нэмэхийн тулд та дараах тохируулгуудыг 
	цөмийн тохиргоондоо нэмээрэй:</para>

      <indexterm>
	<primary>цөмийн тохируулгууд</primary>
	<secondary>IPSEC</secondary>
      </indexterm>

      <indexterm>
	<primary>цөмийн тохируулгууд</primary>
	<secondary>IPSEC_ESP</secondary>
      </indexterm>

      <screen>
options   IPSEC        #IP security
options   IPSEC_ESP    #IP security (crypto; define w/ IPSEC)
      </screen>

      <indexterm>
	<primary>цөмийн тохируулгууд</primary>
	<secondary>IPSEC_DEBUG</secondary>
      </indexterm>

      <para>Хэрэв IPsec дибаг хийх дэмжлэг заавал хэрэгтэй бол дараах цөмийн тохируулга 
	бас нэмэгдсэн байх шаардлагатай:</para>

      <screen>
options   IPSEC_DEBUG  #debug for IP security
      </screen>
    </sect2>

    <sect2>
      <title>Асуудал</title>
 
      <para>VPN-ийг байгуулахад ямар нэг стандарт байхгүй. VPN-үүд нь өөр өөрийн давуу болон сул 
	талуудтай төрөл бүрийн технологиудыг ашиглан хийгдэж болно. Энэ хэсэг нь 
	нэг тохиолдлын загвар үзүүлэх бөгөөд энэ тохиолдол дахь VPN-ийг хийхэд 
	хэрэглэгдэх стратегиудыг харуулах болно.</para>
    </sect2>
    
    <sect2> 
      <title>Тохиолдол: Интернэтэд холбогдсон, нэг юм шиг ажиллах хоёр сүлжээ</title>
      
      <indexterm>
	<primary>VPN</primary>
	<secondary>үүсгэх</secondary>
      </indexterm>

      <para>Угтвар нөхцөл дараах маягийн байна:</para>
      
      <itemizedlist>
        <listitem>
          <para>Та хамгийн багадаа хоёр сайттай байна</para>
        </listitem>
        <listitem>
          <para>Хоёр сайт хоёулаа IP-г дотооддоо ашигладаг</para>
        </listitem>
        <listitem>
          <para>FreeBSD дээр нь ажилладаг гарц компьютераар хоёр сайт хоёулаа 
		Интернэтэд холбогдсон.</para>
        </listitem>
        <listitem>
          <para>Хоёр сүлжээний гарц компьютер бүр хамгийн багаар бодоход нэг нийтийн IP 
		хаягтай.</para>
        </listitem>
        <listitem>
          <para>Хоёр сүлжээний дотоод хаягууд нь нийтийн эсвэл хувийн IP хаягууд байж 
		болох юм, энэ нь хамаагүй. Та гарц машин дээр хэрэв шаардлагатай бол 
		NAT ажиллуулсан байж болох юм.</para>
        </listitem>
        <listitem>
          <para>Хоёр сүлжээний дотоод IP хаягууд <emphasis>мөргөлдөхгүй</emphasis>.
		Үүнийг ажиллуулахын тулд VPN технологи болон NAT-ийн хослолыг ашиглах нь 
		онолын хувьд боломжтой боловч би үүнийг хар дарсан зүүд шигээр тохиргоо их төвөгтэй 
		байх болов уу гэж бодож байна.</para>
        </listitem>
      </itemizedlist>
      
      <para>Хоёр сүлжээ дотооддоо хоёулаа адилхан хувийн IP хаягийн хүрээ (өөрөөр хэлбэл 
	хоёулаа <hostid role="ipaddr">192.168.1.x</hostid>) ашиглаж байгаа хоёр 
	сүлжээг холбохыг оролдож байгаагаа хэрэв та мэдэх юм бол  аль нэг сүлжээний IP-г дахин 
	дугаарлах шаардлагатай болно.</para>
 
      <para>Сүлжээний бүтэц иймэрхүү харагдаж болох юм:</para>
 
      <mediaobject>
	<imageobject>
	  <imagedata fileref="security/ipsec-network" align="center">
	</imageobject>

	<textobject>
<literallayout class="monospaced">Сүлжээ #1            [ Дотоод хостууд ]    Хувийн Сүлжээ, 192.168.1.2-254
                      [   Win9x/NT/2K  ]
                      [      UNIX      ]
                               |
                               |
                        .---[fxp1]---.      Хувийн IP, 192.168.1.1
                        |   FreeBSD  |
                        `---[fxp0]---'      Нийтийн IP, A.B.C.D
                               |
                               |
                      -=-=- Интернэт -=-=-
                               |
                               |
                        .---[fxp0]---.      Нийтийн IP, W.X.Y.Z
                        |   FreeBSD  |
                        `---[fxp1]---'      Хувийн IP, 192.168.2.1
                               |
                               |
Сүлжээ #2            [ Internal Hosts ]
                      [   Win9x/NT/2K  ]    Хувийн Сүлжээ, 192.168.2.2-254
                      [      UNIX      ]</literallayout>
	</textobject>
      </mediaobject>
 
      <para>Хоёр нийтийн IP хаяг байгааг анзаарна уу. Нийтлэлийн туршид би эдгээрийг үсгээр 
	орлуулан ашиглах болно. Энэ нийтлэлийн туршид тохиолдох эдгээр үсэгнүүдийн оронд өөрийн 
	нийтийн хаягаар орлуулж тавиарай. Мөн дотроо хоёр гарц машин маань .1 IP хаягтай 
	бөгөөд хоёр сүлжээ маань өөр өөр хувийн IP хаягийн хүрээтэйг (<hostid
        role="ipaddr">192.168.1.x</hostid> болон <hostid
        role="ipaddr">192.168.2.x</hostid>) анхаарна уу. Хувийн сүлжээнүүд дэх бүх 
	машинууд өөрсдийн анхдагч гарцдаа <hostid role="ipaddr">.1</hostid> 
	машиныг ашиглахаар тохируулсан байгаа болно.</para>
 
      <para>Гол зорилго нь сүлжээ талаасаа авч үзэх юм бол сүлжээ болгон нөгөө сүлжээнийхээ машинуудыг 
	яг л нэг чиглүүлэгчид холбоотой юм шиг харж чадан ажиллаж байх ёстой -- гэвч энэ чиглүүлэгч нь 
	хааяа пакетуудыг гээдэг илүү удаан чиглүүлэгч байх юм.</para>
 
      <para>Энэ нь (жишээ нь) <hostid role="ipaddr">192.168.1.20</hostid> машин 
	дараах тушаалыг ажиллуулж</para>
 
      <programlisting>ping 192.168.2.34</programlisting>
 
      <para>нэвт ажиллаж чадах ёстой гэсэн үг юм. &windows; машинууд 
	өөр сүлжээн дээр байх машинуудыг харж файлын хуваалцал санг үзэх зэргийг хийж 
	локал сүлжээн дээр байгаа машинуудыг харж үзэж чаддаг шигээр ажиллаж чадаж байх 
	ёстой.</para>
 
      <para>Тэгээд бүх юм аюулгүй байх хэрэгтэй. Энэ нь хоёр сүлжээний хоорондох 
	урсгал шифрлэгдэх ёстой гэсэн үг юм.</para>
 
      <para>Эдгээр хоёр сүлжээний хооронд VPN үүсгэх нь олон алхамтай 
	процесс юм.  Эдгээр нь:</para>
 
      <orderedlist>
        <listitem>
          <para>Интернэтийн дагуу хоёр сүлжээний хооронд <quote>виртуал</quote> 
		сүлжээний холболт үүсгэнэ.  Ажиллаж байгааг нь шалгаж &man.ping.8; зэрэг 
		багажуудыг ашиглаж тест хийгээрэй.</para>
        </listitem>
 
        <listitem>
          <para>Хоёр сүлжээний хоорондох урсгал харагдахгүйгээр шифрлэгдэж 
		шаардлагатай бол буцаан шифрлэгдэх тэр боломжийг бүрдүүлэх 
		аюулгүй байдлын бодлогуудыг зааж өгөөрэй. Урсгал шифрлэгдэж 
		байгааг эсэхийг шалгаж &man.tcpdump.1; зэрэг багажууд ашиглан 
		тест хийгээрэй.</para>
        </listitem>

        <listitem>
          <para>VPN-ийн дагуу &windows; машинууд нэг нь нөгөөгөө харж байхыг 
		зөвшөөрөх нэмэлт програм хангамжийг FreeBSD гарц машинууд дээр 
		тохируулаарай.</para>
        </listitem>
      </orderedlist>

    <sect3>
      <title>Алхам 1: <quote>виртуал</quote> сүлжээний холболт үүсгэн тест хийх</title>
 
      <para>Сүлжээ #1 дээрх гарц машин (<hostid role="ipaddr">A.B.C.D</hostid> 
	нийтийн IP хаягтай, <hostid role="ipaddr">192.168.1.1</hostid> хувийн 
	IP хаягтай) уруу та нэвтрэн орсон бөгөөд <hostid role="ipaddr">W.X.Y.Z</hostid> 
	IP хаягтай машины хувийн хаяг уруу нь <command>ping 192.168.2.1</command> 
	гэж тушаал ажиллуулъя гэж бодъё. Ингэж ажиллахын тулд юу болох ёстой вэ?</para>

      <orderedlist>
        <listitem>
          <para>Гарц машин <hostid role="ipaddr">192.168.2.1</hostid> уруу 
		яаж хүрэхээ мэдэх ёстой. Өөрөөр хэлбэл энэ нь <hostid
            role="ipaddr">192.168.2.1</hostid> уруу хийгдсэн чиглүүлэлттэй 
		байх хэрэгтэй.</para>
        </listitem>
        <listitem>
          <para><hostid role="ipaddr">192.168.x</hostid> зэрэг хувийн 
		IP хаягууд Интернэт дээр бараг үзэгдэх ёсгүй. Харин 
		<hostid role="ipaddr">192.168.2.1</hostid> уруу таны илгээсэн 
		пакет бүр өөр пакет дотор орсон байх ёстой. Энэ пакет нь 
		<hostid role="ipaddr">A.B.C.D</hostid> машинаас ирсэн маягаар 
		байх ёстой бөгөөд <hostid role="ipaddr">W.X.Y.Z</hostid> уруу 
		илгээгдэх ёстой. Энэ процессийг <firstterm>encapsulation</firstterm> 
		буюу хайрцаглалт гэж нэрлэдэг.</para>
        </listitem>
        <listitem>
          <para>Энэ пакет нь <hostid role="ipaddr">W.X.Y.Z</hostid> дээр ирээд 
		<quote>unencapsulated</quote> буюу буцааж ялгагдан 
		<hostid role="ipaddr">192.168.2.1</hostid> уруу хүргэгдэх 
		хэрэгтэй.</para>
	</listitem>
      </orderedlist>
 
      <para>Та үүнийг хоёр сүлжээний хоорондох <quote>туннель</quote> 
	гэж ойлгож болно. <quote>Туннелийн хоёр амсар</quote> нь 
	<hostid role="ipaddr">A.B.C.D</hostid> болон <hostid
        role="ipaddr">W.X.Y.Z</hostid> IP хаягууд бөгөөд туннельд 
	түүгээр дамжин өнгөрөх хувийн IP хаягуудыг мэдэгдсэн байх шаардлагатай. 
	Туннель нь нийтийн Интернэтээр хувийн IP хаягтай урсгалыг дамжуулахад 
	хэрэглэгдэнэ.</para>
 
      <para>Энэ туннель нь ерөнхий интерфэйс эсвэл FreeBSD дээрх <devicename>gif</devicename> 
	төхөөрөмж ашиглан үүсгэгддэг. Таны бодсоноор гарц машин бүр дээрх 
	<devicename>gif</devicename> интерфэйс нь дөрвөн IP хаягтай 
	байхаар тохируулагдсан байх шаардлагатай; хоёр нь нийтийн IP хаяг, 
	хоёр нь хувийн IP хаяг.</para>
 
      <para>Хоёр машины хувьд gif төхөөрөмжийн дэмжлэг &os;-ийн цөмд эмхэтгэгдсэн 
	байх шаардлагатай. Та дараах мөрийг:</para>
 
      <programlisting>device gif</programlisting>
 
      <para>хоёр машины цөмийн тохиргооны файлд хийн дараа нь эмхэтгэн суулгаж дахин 
	ачаалснаар үүнийг хийж болно.</para>
 
      <para>Туннелийг тохируулах нь хоёр алхамтай процесс юм. Эхлээд туннельд ямар гадаад 
	(эсвэл нийтийн) IP хаягууд байгааг &man.ifconfig.8; ашиглан мэдэгдэх 
	ёстой. Тэгээд дараа нь хувийн IP хаягуудыг &man.ifconfig.8; тушаал ашиглан 
	тохируулах ёстой.</para>
 
      <para>Сүлжээ #1 дэх гарц машин дээр туннелийг тохируулахын тулд та дараах тушаалуудыг 
	ашиглах болно.</para>
 
      <screen>&prompt.root; <userinput>ifconfig <replaceable>gif0</replaceable> create</userinput>
&prompt.root; <userinput>ifconfig <replaceable>gif0</replaceable> tunnel <replaceable>A.B.C.D</replaceable> <replaceable>W.X.Y.Z</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>gif0</replaceable> inet <replaceable>192.168.1.1</replaceable> <replaceable>192.168.2.1</replaceable> netmask <replaceable>0xffffffff</replaceable></userinput>
      </screen>

      <para>Нөгөө нэг гарц машин дээр та адил тушаалуудыг гэхдээ IP хаягуудын дарааллыг 
	эсрэгээр тавин ажиллуулна.</para>

      <screen>&prompt.root; <userinput>ifconfig <replaceable>gif0</replaceable> create</userinput>
&prompt.root; <userinput>ifconfig <replaceable>gif0</replaceable> tunnel <replaceable>W.X.Y.Z</replaceable> <replaceable>A.B.C.D</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>gif0</replaceable> inet <replaceable>192.168.2.1</replaceable> <replaceable>192.168.1.1</replaceable> netmask <replaceable>0xffffffff</replaceable></userinput>
      </screen>
 
      <para>Та дараа нь:</para>
 
      <programlisting>ifconfig gif0</programlisting>
 
      <para>ажиллуулж тохиргоог харж болно.  Жишээ нь сүлжээ #1 дээрх гарц машин 
	дээр та үүнийг харах болно:</para>
 
      <screen>&prompt.root; <userinput>ifconfig gif0</userinput>
gif0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1280
        tunnel inet A.B.C.D --&gt; W.X.Y.Z
        inet 192.168.1.1 --&gt; 192.168.2.1 netmask 0xffffffff
      </screen>

      <para>Эндээс харахад <hostid role="ipaddr">A.B.C.D</hostid> болон 
        <hostid role="ipaddr">W.X.Y.Z</hostid> физик хаягуудын хооронд туннель 
	үүссэн бөгөөд туннелээр зөвшөөрөгдөх урсгал нь <hostid
        role="ipaddr">192.168.1.1</hostid> болон <hostid
        role="ipaddr">192.168.2.1</hostid>-ийн хооронд байна.</para>
 
      <para>Энэ нь бас хоёр машин дээрх чиглүүлэлтийн хүснэгтэд бас оруулга нэмсэн байх 
	бөгөөд та үүнийг <command>netstat -rn</command> тушаал ашиглан шалгаж 
	болно. Доорх гаралт нь сүлжээ #1 дэх гарц машиных юм.</para>
 
      <screen>&prompt.root; <userinput>netstat -rn</userinput>
Routing tables
 
Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...
      </screen>
 
      <para><quote>Flags</quote> утгын харуулж байгаагаар энэ нь хостын чиглүүлэлт 
	бөгөөд энэ нь гарц бүр нөгөө гарц уруу хэрхэн хүрэхээ мэдэх боловч тэд харин 
	өөрсдийнхөө харгалзах сүлжээнүүд уруу хэрхэн хүрэхээ мэдэхгүй гэсэн үг юм. 
	Энэ асуудлыг удахгүй засварлах болно.</para>
 
      <para>Энэ нь хоёр машин дээр хоёулан дээр нь галт хана ажиллаж гэсэн үг юм. 
	Таны VPN урсгалын хувьд үүнийг тойрон гарах шаардлагатай. Та хоёр сүлжээний 
	хоорондох бүх урсгалыг зөвшөөрөх юм уу эсвэл VPN-ий хоёр төгсгөлийг нэгээс нөгөөг 
	хамгаалах галт ханын дүрмүүдийг оруулж болох юм.</para>
 
      <para>Хэрэв VPN-ээр өнгөрөх бүх урсгалыг зөвшөөрөхөөр галт ханыг тохируулах 
	юм бол энэ нь тест хийхийг ихээхэн амарчлах болно. Та дараа нь хэзээ ч галт ханаа 
	илүү чангаруулж болно. Хэрэв та &man.ipfw.8; тушаалыг гарц машинууд дээр 
	ашиглаж байгаа бол дараах</para>

      <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>
 
      <para>тушаал нь хоёр төгсгөлийн цэгийн хоорондох бүх урсгалыг таны галт ханын 
	бусад дүрмүүдийг хөндөлгүйгээр зөвшөөрөх болно. Мэдээж та энэ тушаалыг хоёр 
	гарц хост дээр хоёулан дээр ажиллуулах хэрэгтэй болно.</para>
 
      <para>Нэг гарц машинаас нөгөө уруугаа ping хийхийг зөвшөөрөхөд хангалттай.
	<hostid role="ipaddr">192.168.1.1</hostid> дээр та дараах 
	</para>
 
      <programlisting>ping 192.168.2.1</programlisting>
 
      <para>тушаалыг ажиллуулж хариу хүлээж авахаас гадна мөн нөгөө гарц машин 
	дээрээс бас ингэж хийж чадаж байх ёстой.</para>
 
      <para>Гэхдээ та хоёр сүлжээний дотоод машинууд уруу арай хүрч чадахгүй байх 
	ёстой. Энэ нь чиглүүлэлтээс болж байгаа юм -- гарц машинууд бие бие уруугаа 
	хэрхэн хүрэхээ мэдэж байгаа боловч нэг нэгнийнхээ цаана байгаа сүлжээнд хэрхэн 
	хүрэхийг мэдэхгүй.</para>
 
      <para>Энэ асуудлыг шийдэхийн тулд та гарц машин бүр дээр статик чиглүүлэлт нэмэх 
	хэрэгтэй. Эхний гарц дээр хийх тушаал нь:</para>
 
      <programlisting>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00
      </programlisting>
 
      <para>Энэ нь <quote><hostid role="ipaddr">192.168.2.0</hostid> сүлжээний 
	хостуудад хүрэхийн тулд пакетуудыг <hostid role="ipaddr">192.168.2.1</hostid> 
	хост уруу  илгээ</quote> гэж байна. Та үүнтэй адил тушаалыг нөгөө гарц дээр бас 
	ажиллуулах хэрэгтэй бөгөөд гэхдээ <hostid role="ipaddr">192.168.1.x</hostid> 
	хаягуудыг ашиглах ёстой.</para>
 
      <para>Одоо нэг сүлжээн дэх хостуудын IP урсгал нөгөө сүлжээний хостуудад хүрэх боломжтой 
	болно.</para>
 
      <para>Энэ нь одоо хоёр сүлжээний хооронд VPN-ий гуравны хоёрыг үүсгэж байгаа бөгөөд 
	аль болох <quote>виртуал</quote>аар үүсгэгдсэн <quote>сүлжээ</quote> юм. 
	Энэ нь одоохондоо хувийн биш байгаа. Та үүнийг &man.ping.8; болон &man.tcpdump.1;
	ашиглан тест хийж болно. Гарц хост уруу нэвтрэн орж дараах тушаалыг ажиллуулна</para>
 
      <programlisting>tcpdump dst host 192.168.2.1</programlisting>

      <para>Тэр хост дээрээ өөр сессээр дараах тушаалыг ажиллуулна</para>

      <programlisting>ping 192.168.2.1</programlisting>
 
      <para>Та иймэрхүү гаралтыг харах болно:</para>
 
      <programlisting>
16:10:24.018080 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
      </programlisting>
 
      <para>Эндээс харахад ICMP мэдэгдлүүд нааш цааш шифрлэгдэлгүй явж байна. 
	Хэрэв та пакетуудаас өгөгдлийн байтуудыг илүүтэйгээр авахын тулд &man.tcpdump.1; 
	уруу <option>-s</option> параметрийг өгч ашигласан бол илүү мэдээлэл 
	та харж болох юм.</para>
 
      <para>Энэ нь мэдээж хүлээн авах боломжгүй зүйл юм. Дараагийн хэсэгт 
	хоёр сүлжээний хоорондох холболтыг бүх урсгал нь автоматаар шифрлэгдэхээр   
	аюулгүй болгох талаар хэлэлцэх болно.</para>
 
      <itemizedlist>
        <title>Дүгнэн хэлэхэд:</title>
        <listitem>
          <para>Хоёр цөмийг <quote>device gif</quote> мөртэйгөөр тохируулна.</para>
        </listitem>
        <listitem>
          <para>Гарц хост #1 дээрх <filename>/etc/rc.conf</filename> файлд засвар хийн 
		дараах мөрүүдийг нэмнэ (шаардлагатай тохиолдолд IP хаягуудыг сольно).</para>
          <programlisting>gif_interfaces="gif0"
gifconfig_gif0="A.B.C.D W.X.Y.Z"
ifconfig_gif0="inet 192.168.1.1 192.168.2.1 netmask 0xffffffff"
static_routes="vpn"
route_vpn="192.168.2.0 192.168.2.1 netmask 0xffffff00"
          </programlisting>
        </listitem>

        <listitem>
          <para>Хоёр хост дээрх гарц скриптийг (<filename>/etc/rc.firewall</filename>, 
		эсвэл үүнтэй адил) засварлаж доор дурдсаныг нэмнэ.</para>

          <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>
        </listitem>
        <listitem>
          <para>IP хаягуудын дарааллыг эсрэгээр болгон гарц хост #2 дээрх 
		<filename>/etc/rc.conf</filename> файлд адил өөрчлөлтийг 
		хийнэ.</para>
        </listitem>
      </itemizedlist>
    </sect3>

    <sect3>
      <title>Алхам 2: Холболтыг аюулгүй болгох</title>
 
      <para>Холболтыг аюулгүй болгохын тулд бид IPsec-ийг ашиглах болно. IPsec нь 
	хоёр хостыг шифрлэлтийн түлхүүр дээр зөвшилцүүлж дараа нь уг хоёр хостын хооронд 
	өгөгдлийг шифрлэхийн тулд энэ түлхүүрийг ашиглах арга замыг өгдөг.</para>
 
      <para>Энд тохиргооны хоёр талбарыг бодолцох хэрэгтэй.</para>
 
      <orderedlist>
        <listitem>
          <para>Ашиглах шифрлэлтийн арга зам дээр хоёр хост зөвшилцөх тийм арга зам 
		байх ёстой. Хоёр хост энэ арга зам дээр зөвшилцсөний дараа тэдгээрийн 
		хооронд <quote>аюулгүй байдлын нэгдэл</quote> байна гэж 
		үздэг.</para>
        </listitem>
        <listitem>
          <para>Аль урсгалыг шифрлэх ёстойг заах арга зам байх ёстой. Мэдээж та өөрийн бүх 
		гарч байгаа урсгалаа шифрлэхийг хүсэхгүй байх -- та зөвхөн VPN-ий хэсэг 
		болсон урсгалыг шифрлэхийг хүснэ. Аль урсгалыг шифрлэхийг тодорхойлохын 
		тулд хийгдэх дүрмүүд нь <quote>security policies</quote> буюу 
		<quote>аюулгүй байдлын бодлогууд</quote> гэгдэнэ.</para>
         </listitem>
       </orderedlist>
 
       <para>Аюулгүй байдлын нэгдлүүд болон аюулгүй байдлын бодлогуудын ажиллагааг 
	цөм хангаж байдаг бөгөөд хэрэглэгчдийн талбарын програмуудаар засварлагдаж 
	болно. Гэхдээ үүнийг хийхийн өмнө IPsec болон Encapsulated 
	Security Payload (ESP) буюу Хайрцаглагдсан Аюулгүй байдлын Ачаа 
	протоколыг цөм дэмжихээр та тохируулах хэрэгтэй. Цөмийг:</para>
 
       <indexterm>
	 <primary>цөмийн тохируулгууд</primary>
	 <secondary>IPSEC</secondary>
       </indexterm>

       <programlisting>options IPSEC
options IPSEC_ESP
       </programlisting>
 
       <para>тохируулгатай тохируулан дахин эмхэтгэж суулгаад ачаалан үүнийг хийнэ. 
	Урьдын адил та хоёр гарц машин дээрх цөмийн хувьд үүнийг хийх ёстой.</para>
 
       <indexterm>
	 <primary>IKE</primary>
       </indexterm>

       <para>Аюулгүй байдлын нэгдлүүдийг тохируулах үед танд хоёр сонголт байна.
	Шифрлэлтийн алгоритм, шифрлэлтийн түлхүүрүүд гэх зэргүүдийг сонгож 
	тэдгээр нэгдлүүдийг хоёр хостын хооронд гараараа тохируулж болох бөгөөд 
	эсвэл эдгээрийг хийх Internet Key Exchange protocol (IKE) буюу 
	Интернэтийн Түлхүүр Солилцох протоколыг шийддэг дэмонуудыг та ашиглаж 
	болно.</para>
 
       <para>Би сүүлийнхийг зөвлөж байна.  Өөр бусдыг тооцохгүй юм бол үүнийг 
	тохируулах нь амархан.</para>
 
       <indexterm>
	 <primary>IPsec</primary>
	 <secondary>аюулгүй байдлын бодлогууд</secondary>
       </indexterm>

       <indexterm>
	 <primary><command>setkey</command></primary>
       </indexterm>

       <para>Аюулгүй байдлын бодлогуудыг засварлах болон үзүүлэхдээ &man.setkey.8;-г 
	ашиглан хийдэг. Адилтгах юм бол <command>setkey</command> нь цөмийн 
	аюулгүй байдлын бодлогын хүснэгтүүдэд &man.route.8; цөмийн чиглүүлэлтийн 
	хүснэгтүүдэд зориулагдсан шиг зориулагдсан байна. <command>setkey</command> 
	нь бас одоогийн аюулгүй байдлын нэгдлүүдийг үзүүлж чадах бөгөөд адилтган  
	цааш үргэлжлүүлбэл энэ нь бас <command>netstat -r</command> тушаалын 
	нэгэн адил болох юм.</para>
 
       <para>FreeBSD-ээр аюулгүй байдлын нэгдлүүдийг удирдах дэмонуудын хувьд хэд хэдэн 
	сонголт байдаг. Энэ нийтлэл нь эдгээрийн нэг &os;-ийн Портуудын цуглуулгын 
	<filename role="package">security/ipsec-tools</filename>-д байдаг 
	<application>racoon</application>-ийг хэрхэн ашиглах талаар тайлбарлах болно.</para>
 
       <indexterm>
	 <primary>racoon</primary>
       </indexterm>

       <para><application>racoon</application> програм хангамж хоёр гарц машин 
	дээр хоёулан дээр нь ажиллах ёстой. Энэ нь хост бүр дээр VPN-ий нөгөө төгсгөлийн IP хаяг болон
	нууц түлхүүртэйгээр (таны сонгох түлхүүр байх бөгөөд хоёр гарц машин дээр ижил байх ёстой) 
	тохируулагддаг.</para>
 
       <para>Дараа нь хоёр дэмон нэг нэгэндээ хандаж тэдгээр нь өөрсдөө хэн хэн гэж хэлснээ  
	(таны тохируулсан нууц түлхүүрийг ашиглан) баталгаажуулдаг. Дэмонууд дараа нь 
	шинэ нууц түлхүүрийг үүсгэж түүнийг ашиглан VPN-ээр урсгалыг шифрлэдэг. 
	Тэд энэ нууцаа үе үе өөрчилдөг бөгөөд халдагч түлхүүрүүдийн аль нэгийг эвдсэн ч (цагаа 
	тулахаар энэ нь онолын хувьд бараг боломжгүй зүйл) гэсэн энэ нь халдагчид муу юм 
	хийх боломж олгодоггүй -- түлхүүрийг эвдэх тэр үед хоёр дэмон өөр түлхүүрийг сонгосон байна.</para>
 
       <para><application>racoon</application>-ий тохиргооны файл <filename>${PREFIX}/etc/racoon</filename>-д 
	байрлана. Та энд тохиргооны файлыг олох ёстой бөгөөд түүнд нэг их өөрчлөлт хийгдэх ёсгүй. 
	Таны өөрчлөх шаардлагатай <application>racoon</application>-ий тохиргооны файлын өөр нэг бүрэлдэхүүн хэсэг нь 
	<quote>pre-shared key буюу урьдчилан хуваалцсан түлхүүр</quote> юм.</para>
 
       <para><application>racoon</application>-ий анхдагч тохиргоо үүнийг <filename>${PREFIX}/etc/racoon/psk.txt</filename>-д 
	байгаа гэж боддог. Урьдчилан хуваалцсан түлхүүр нь таны урсгалыг VPN-ийн дагуу шифрлэх 
	түлхүүр <emphasis>биш</emphasis> бөгөөд харин энэ нь ердөө л түлхүүр удирдах дэмонуудыг нэг нь 
	нөгөөдөө итгэхийг зөвшөөрөх токен гэдгийг тэмдэглэж хэлэх нь зүйтэй юм.</para>

       <para><filename>psk.txt</filename> нь таны ажиллаж байгаа алсын сайт бүрийн 
	мөрийг агуулсан байна. Хоёр сайт бүхий энэ жишээн дээр <filename>psk.txt</filename> 
	файл бүр нэг мөрийг агуулсан байна (VPN-ий төгсгөлүүд бүр зөвхөн нөгөө төгсгөлтэйгээ 
	ажилладаг).</para>
 
       <para>Гарц хост #1 дээр энэ мөр иймэрхүү харагдах ёстой:</para>
 
       <programlisting>W.X.Y.Z            secret</programlisting>
 
       <para>Энэ нь алсын төгсгөлийн <emphasis>нийтийн</emphasis> IP хаяг, хоосон зай, 
	тэгээд нууц үгийг илэрхийлэх текст мэдээлэл байна. Мэдээж та өөрийн түлхүүртээ 
	<quote>secret</quote> гэдгийг ашиглах ёсгүй -- нууц үгийг сонгох энгийн дүрэм энд 
	үйлчилнэ.</para>
 
       <para>Гарц хост #2 дээр энэ мөр иймэрхүү харагдах ёстой</para>
 
       <programlisting>A.B.C.D            secret</programlisting>
 
       <para>Энэ нь алсын төгсгөлийн IP хаяг болон адилхан нууц түлхүүр байна. 
	<filename>psk.txt</filename> нь <application>racoon</application> ажиллахаас өмнө 
	<literal>0600</literal> (өөрөөр хэлбэл <username>root</username>-д 
	зөвхөн унших/бичих) горимд байна.</para>
 
       <para>Та <application>racoon</application>-ийг хоёр гарц машин дээр ажиллуулах ёстой. Та бас 
	UDP-ээр ISAKMP (Internet Security Association
         Key Management Protocol буюу Интернэтийн Аюулгүй байдлын Нэгдлийн Түлхүүр 
	Удирдах Протокол) порт уруу зөөгдөх IKE урсгалыг зөвшөөрөх галт ханын зарим 
	дүрмүүдийг нэмэх хэрэгтэй. Дахин хэлэхэд энэ нь таны галт ханын дүрмийн олонлогт 
	нэлээн эрт байх шаардлагатай.</para>
 
       <programlisting>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
       </programlisting>
 
       <para><application>racoon</application> ажилласны дараа та нэг гарц хостоос нөгөө гарц хост уруу ping хийж 
	үзэж болно. Холболт нь шифрлэгдээгүй байх боловч <application>racoon</application> дараа нь аюулгүй байдлын 
	нэгдлүүдийг хоёр хостын хооронд тохируулна -- энэ нь хором болж өнгөрч болох бөгөөд 
	ping тушаал хариу өгч эхлэх хүртэл богино саатал маягаар танд харагдаж болох юм.</para>
 
       <para>Аюулгүй байдлын нэгдэл тохируулагдсаны дараа та үүнийг &man.setkey.8; ашиглан 
	үзэж болно.</para>
 
       <programlisting>setkey -D</programlisting>
 
       <para>тушаалыг аль нэг хост дээр ажиллуулж аюулгүй байдлын нэгдлийн мэдээллийг харна.</para>
 
       <para>Энэ нь асуудлын нэг хагас нь юм.  Нөгөө нэг хагас нь өөрийн аюулгүй байдлын 
	бодлогуудыг тохируулах явдал юм.</para>
 
       <para>Ухаалаг аюулгүй байдлын бодлогыг үүсгэхийн тулд энэ хүртэл юуг хийснээ эргэн 
	харцгаая. Энэ хэлэлцээ нь холболтын төгсгөлийн хоёулангийнх нь  хувьд авч 
	үзнэ.</para>
 
       <para>Таны гадагш илгээх IP пакет бүр пакетийн тухай өгөгдлийг агуулах толгойтой 
	байдаг. Толгой нь эхлэл болон төгсгөлийн IP хаягуудыг агуулдаг. Бидний мэдэж 
	байгаагаар <hostid role="ipaddr">192.168.x.y</hostid> зэрэг 
	хувийн IP хаягууд нийтийн Интернэт дээр ил гарах ёсгүй. Харин тэд эхлээд өөр 
	пакет дотор хайрцаглагдах ёстой. Энэ пакет нь хувийн хаягуудын оронд солигдсон 
	нийтийн эхлэл болон төгсгөл IP хаягуудтай байх ёстой.</para>
 
       <para>Тэгэхээр хэрэв таны гарч байгаа пакет иймэрхүү харагдаж эхэлбэл:</para>
 
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-out-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .----------------------.
  | Src: 192.168.1.1     |
  | Dst: 192.168.2.1     |
  | &lt;other header info&gt;  |
  +----------------------+
  | &lt;packet data&gt;        |
  `----------------------'</literallayout>
	  </textobject>
	</mediaobject>
 
       <para>Дараа нь өөр нэг пакетийн дотор энэ нь хайрцаглагдан иймэрхүү харагдах болно:</para>
 
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-encap-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .--------------------------.
  | Src: A.B.C.D             |
  | Dst: W.X.Y.Z             |
  | &lt;other header info&gt;      |
  +--------------------------+
  | .----------------------. |
  | | Src: 192.168.1.1     | |
  | | Dst: 192.168.2.1     | |
  | | &lt;other header info&gt;  | |
  | +----------------------+ |
  | | &lt;packet data&gt;        | |
  | `----------------------' |
  `--------------------------'</literallayout>
	  </textobject>
	</mediaobject>
 
       <para>Энэ хайрцаглалт нь <devicename>gif</devicename> төхөөрөмжөөр 
	хийгдэнэ. Пакет нь гадна талдаа жинхэнэ IP хаягуудтай байх бөгөөд 
	бидний эхний пакет Интернэт уруу гарах пакет дотор орсон байгааг харж болно.</para>
 
       <para>Мэдээж бид VPN-үүдийн хоорондох бүх урсгалыг шифрлэхийг хүснэ. 
	Та үүнийг иймэрхүүгээр үгчлэн хэлж болно:</para>

       <para><quote>Хэрэв пакет <hostid
         role="ipaddr">A.B.C.D</hostid>-с гарч <hostid
         role="ipaddr">W.X.Y.Z</hostid> уруу чиглэсэн бол шаардлагатай аюулгүй 
	байдлын нэгдлүүдийг ашиглан шифрлэнэ.</quote></para>
 
       <para><quote>Хэрэв пакет нь <hostid
         role="ipaddr">W.X.Y.Z</hostid>-с ирж <hostid
         role="ipaddr">A.B.C.D</hostid> уруу чиглэсэн бол шаардлагатай аюулгүй 
	байдлын нэгдлүүдийг ашиглан буцааж шифрлэнэ.</quote></para>
 
       <para>Ингэж хэлэхэд ер нь бараг л зөв, ойрхон байна, гэхдээ бас тийм ч зөв биш юм. Хэрэв та 
	үүнийг хийсэн бол <hostid role="ipaddr">W.X.Y.Z</hostid>-с гарсан болон 
	түүн уруу чиглэсэн, бүр VPN-ий хэсэг ч биш бүх урсгал шифрлэгдэх болно. Та яг үүнийг 
	хүсээгүй байх. Зөв бодлого нь дараах маягаар байна</para>
 
       <para><quote>Хэрэв пакет <hostid
         role="ipaddr">A.B.C.D</hostid>-с гарч тэр пакет нь өөр пакет дотор орон 
	хайрцаглагдан <hostid
         role="ipaddr">W.X.Y.Z</hostid> уруу чиглэсэн бол шаардлагатай аюулгүй 
	байдлын нэгдлүүдийг ашиглан шифрлэнэ.</quote></para>
 
       <para><quote>Хэрэв пакет нь <hostid
         role="ipaddr">W.X.Y.Z</hostid>-с ирж тэр пакет нь өөр пакет дотор орон 
	хайрцаглагдан <hostid
         role="ipaddr">A.B.C.D</hostid> уруу чиглэсэн бол шаардлагатай аюулгүй 
	байдлын нэгдлүүдийг ашиглан буцааж шифрлэнэ.</quote></para>
 
       <para>Нарийн өөрчлөлт, гэхдээ хэрэгтэй нэгэн.</para>
 
       <para>Аюулгүй байдлын бодлогууд нь бас &man.setkey.8; ашиглагдан заагдана. 
	&man.setkey.8; нь бодлого тодорхойлох тохиргооны хэлтэй байна. Та 
	тохиргооны заавруудыг stdin-ээс оруулж болох бөгөөд эсвэл тохиргооны заавруудыг агуулах 
	файлын нэрийг зааж өгөх <option>-f</option> тохируулгыг ашиглаж болно.</para>
 
       <para>Гарц хост #1-ийн (<hostid role="ipaddr">A.B.C.D</hostid> гэсэн нийтийн 
	IP хаягтай) тохиргоо <hostid role="ipaddr">W.X.Y.Z</hostid> уруу чиглэсэн 
	бүх гарах урсгалыг хүчээр шифрлэхийн тулд:</para>
 
       <programlisting>
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;
       </programlisting>
 
       <para>Эдгээр тушаалуудыг файлд (өөрөөр хэлбэл 
	<filename>/etc/ipsec.conf</filename>) хийгээд ажиллуулаарай</para>

       <screen>&prompt.root; <userinput>setkey -f /etc/ipsec.conf</userinput></screen>
 
       <para><option>spdadd</option> нь бид аюулгүй бодлогын мэдээллийн санд 
	дүрэм нэмэхийг хүсэж байгааг &man.setkey.8;-д хэлж өгч байна. Энэ мөрийн бусад нь 
	энэ бодлогод аль пакет таарахыг заана. <hostid
         role="ipaddr">A.B.C.D/32</hostid> ба <hostid
         role="ipaddr">W.X.Y.Z/32</hostid> нь энэ бодлого хамаарах 
	сүлжээ болон хостуудыг таних IP хаягууд болон сүлжээний багууд юм. Энэ 
	тохиолдолд эдгээр хоёр хостуудын хоорондох урсгалд үүнийг хамааруулахыг 
	бид хүсэж байна. <option>ipencap</option> нь энэ бодлого зөвхөн 
	бусад пакетуудыг хайрцаглах пакетуудад хамаатай гэдгийг цөмд хэлнэ. 
	<option>-P out</option> тохируулга нь энэ бодлого гарах пакетуудад 
	хамаатайг хэлэх бөгөөд <option>ipsec</option> тохируулга нь пакет 
	нууцлагдахыг хэлж байна.</para>
 
       <para>Хоёр дахь мөр нь энэ пакет хэрхэн шифрлэгдэхийг заана. 
	<option>esp</option> нь ашиглагдах протокол байхад <option>tunnel</option> 
	нь пакетийг цаашаагаа IPsec пакет дотор орж хайрцаглалт хийгдэхийг заана. 
	<hostid role="ipaddr">A.B.C.D</hostid> болон <hostid
         role="ipaddr">W.X.Y.Z</hostid>-ийн давхардсан хэрэглээ нь 
	ашиглах аюулгүй байдлын нэгдлийг сонгоход хэрэглэгдэх бөгөөд төгсгөлийн 
	<option>require</option> тохируулга энэ дүрмэнд таарсан пакетуудыг 
	шифрлэх ёстойг зааж байна.</para>
 
       <para>Энэ дүрэм нь зөвхөн гарч байгаа пакетуудтай таарна.  Ирж байгаа пакетийн 
	хувьд танд үүнтэй адил дүрэм хэрэгтэй.</para>
 
       <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</programlisting>
 
       <para>Энэ тохиолдолд <option>out</option>-ийн оронд <option>in</option> 
	тохируулгыг ашиглаж шаардлагын дагуу IP хаягуудыг эсрэгээр болгосныг хараарай.</para>
 
       <para>Нөгөө нэг гарц хостод (<hostid role="ipaddr">W.X.Y.Z</hostid> 
	нийтийн IP хаягтай) үүнтэй адил дүрмүүд хэрэгтэй.</para>
 
       <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</programlisting>
 
       <para>Төгсгөлд нь та ESP болон IPENCAP пакетуудыг нааш цааш зөвшөөрөх 
	галт ханын дүрмүүдийг нэмэх хэрэгтэй. Эдгээр дүрмүүдийг хост бүр дээр 
	нэмэх шаардлагатай.</para>
 
       <programlisting>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
       </programlisting>
 
       <para>Дүрмүүд нь тэгш хэмт учир адилхан дүрмүүдийг та гарц хост бүр дээр ашиглаж 
	болно.</para>
 
       <para>Одоо гарч байгаа пакетууд үүнтэй адил харагдах болно:</para>
 
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="security/ipsec-crypt-pkt" align="center">
	  </imageobject>

	  <textobject>
	    <literallayout class="monospaced">
  .------------------------------.  --------------------------.
  | Src: A.B.C.D                 |                            |
  | Dst: W.X.Y.Z                 |                            |
  | &lt;other header info&gt;          |                            |  Encrypted
  +------------------------------+                            |  packet.
  | .--------------------------. |  -------------.            |  contents
  | | Src: A.B.C.D             | |               |            |  are
  | | Dst: W.X.Y.Z             | |               |            |  completely
  | | &lt;other header info&gt;      | |               |            |- secure
  | +--------------------------+ |               |  Encap'd   |  from third
  | | .----------------------. | |  -.           |  packet    |  party
  | | | Src: 192.168.1.1     | | |   |  Original |- with real |  snooping
  | | | Dst: 192.168.2.1     | | |   |  packet,  |  IP addr   |
  | | | &lt;other header info&gt;  | | |   |- private  |            |
  | | +----------------------+ | |   |  IP addr  |            |
  | | | &lt;packet data&gt;        | | |   |           |            |
  | | `----------------------' | |  -'           |            |
  | `--------------------------' |  -------------'            |
  `------------------------------'  --------------------------'
	    </literallayout>
	  </textobject>
	</mediaobject>

       <para>Тэдгээрийг VPN-ий хамгийн төгсгөлд хүлээн авах үед тэдгээр нь эхлээд 
	буцаан шифрлэгдэнэ (<application>racoon</application>-аар тохиролцсон аюулгүй байдлын нэгдлүүдийг  
	ашиглан).  Тэдгээр нь үүний дараа  хоёр дахь давхаргыг гаргах 
	<devicename>gif</devicename> интерфэйс уруу орж хамгийн дотор байрлах 
	пакеттай үлдэх хүртэл боловсруулагдаад дотоод сүлжээ руу аялах болно.</para>
 
       <para>Өмнө дурдсаны адил та &man.ping.8; тестийг ашиглан аюулгүй байдлыг 
	шалгаж болно. Эхлээд <hostid role="ipaddr">A.B.C.D</hostid> гарц 
	машин уруу нэвтрэн орж дараах тушаалыг ажиллуулна:</para>
 
       <programlisting>tcpdump dst host 192.168.2.1</programlisting>
 
       <para>Тэр хост дээрээ өөр сессээр дараах тушаалыг ажиллуулна</para>
 
       <programlisting>ping 192.168.2.1</programlisting>
 
       <para>Энэ удаад та доор дурдсантай адил гаралтыг харах ёстой:</para>
 
       <programlisting>XXX tcpdump output</programlisting>
 
       <para>Одоо эндээс харах юм бол &man.tcpdump.1; нь ESP пакетуудыг үзүүлж 
	байна. Хэрэв та тэдгээрийг <option>-s</option> тохируулгатай шалгахыг оролдвол  
	шифрлэлтээс болоод (мэдээж) нууцлаг харагдах болно.</para>
 
      <para>Баяр хүргэе.  Та дөнгөж сая алсын хоёр сайтын хооронд VPN 
	тохирууллаа.</para>
 
      <itemizedlist>
        <title>Дүгнэн хэлэхэд</title>
        <listitem>
          <para>Хоёр цөмийг хоёуланг нь дараах тохируулгатай тохируулна:</para>
 
          <programlisting>options IPSEC
options IPSEC_ESP
          </programlisting>
        </listitem>
        <listitem>
          <para><filename
            role="package">security/ipsec-tools</filename> суулгана. Алсын хостын 
		IP хаяг болон тэдгээрийн мэддэг нууц түлхүүрийн оруулгыг нэмж 
		<filename>${PREFIX}/etc/racoon/psk.txt</filename> 
		файлыг хоёр гарц хост дээр хоёулан дээр засварлана. Энэ файлын горим 
		0600 байгааг шалгаарай.</para>
        </listitem>
        <listitem>
          <para>Хост бүр дээрх  <filename>/etc/rc.conf</filename> файлд дараах 
		мөрүүдийг нэмээрэй:</para>
 
          <programlisting>ipsec_enable="YES"
ipsec_file="/etc/ipsec.conf"
          </programlisting>
        </listitem>
        <listitem>
          <para>Хост бүр дээр шаардлагатай spadd мөрүүдийг агуулсан 
		<filename>/etc/ipsec.conf</filename> файл үүсгэна. 1-р гарц 
		хост дээр энэ нь ийм байна:</para>
 
          <programlisting>
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
</programlisting>
 
          <para>2-р гарц хост дээр энэ нь ийм байна:</para>
 
<programlisting>
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
</programlisting>
        </listitem>
        <listitem>
          <para>Хост бүр дээр IKE, ESP, болон IPENCAP урсгалыг зөвшөөрөх 
		галт ханын дүрмүүд нэмээрэй:</para>
 
          <programlisting>
ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
          </programlisting>
        </listitem>
      </itemizedlist>

      <para>Өмнөх хоёр алхам VPN-ийг эхлүүлэн ажиллуулахад хангалттай байх 
	ёстой. Сүлжээ бүрийн машинууд өөр хоорондоо  IP хаягуудаараа 
	хандах боломжтой болох бөгөөд холболтын дагуух бүх урсгал автоматаар 
	аюулгүй шифрлэгдэх болно.</para>
    </sect3> 
    </sect2> 
  </sect1>

  <sect1 id="openssh">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Шерн</firstname>
	  <surname>Ли</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </sect1info>

    <title>OpenSSH</title>
    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>аюулгүй байдал</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> нь алсын машинуудад аюулгүйгээр хандах 
	сүлжээний холболтын хэрэгслүүдийн олонлог юм. <command>rlogin</command>,
      <command>rsh</command>, <command>rcp</command>, болон 
      <command>telnet</command>-ийг энэ програмаар шууд орлуулан ашиглаж болно. 
	Мөн TCP/IP холболтууд аюулгүйгээр SSH-ээр туннель хийгдэж/дамжуулагдаж 
	болдог. <application>OpenSSH</application> нь сэм чагналт, холболт булаан авалт, болон 
	бусад сүлжээний түвшний халдлагуудыг үр дүнтэйгээр устгаж бүх трафикийг шифрлэдэг.</para>

    <para><application>OpenSSH</application>-г OpenBSD төсөл дэмжиж байдаг бөгөөд 
	бүх сүүлийн үеийн алдааны засварууд болон шинэчлэлтүүд бүхий  SSH v1.2.12 дээр 
	тулгуурласан байдаг. Энэ програм нь SSH протокол 1 болон 2-той хоёулантай нь 
	нийцтэй.</para>

    <sect2>
      <title>OpenSSH-ийг ашиглах давуу тал</title>
  
      <para>&man.telnet.1; эсвэл &man.rlogin.1; ашиглаж байх үед сүлжээгээр 
	илгээгдэж байгаа өгөгдөл цэвэр, шифрлэгдээгүй хэлбэрээр байдаг.
	Сүлжээний шиншлэгчид клиент болон серверийн хооронд хаана ч байсан гэсэн 
	таны хэрэглэгч/нууц үгийн мэдээлэл эсвэл таны сессээр дамжсан өгөгдлийг 
	хулгайлж чадна. <application>OpenSSH</application> нь ийм асуудлаас 
	хамгаалж төрөл бүрийн нэвтрэлт таних болон шифрлэх аргуудыг санал болгодог.</para>
    </sect2>

    <sect2>
      <title>sshd-г идэвхжүүлэх</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>идэвхжүүлэх</secondary>
      </indexterm>

      <para><application>sshd</application> нь стандарт &os; суулгацын явцад 
	харуулагдах тохируулга юм. <application>sshd</application> идэвхжсэн 
	эсэхийг харахдаа <filename>rc.conf</filename> файлаас дараах мөрийг 
	шалгаарай:</para>
      <screen>sshd_enable="YES"</screen>
      <para>Энэ нь дараагийн удаа таны систем эхлэхэд <application>OpenSSH</application>-д 
	зориулсан &man.sshd.8; дэмон програмыг дуудна. Мөн <filename>/etc/rc.d/sshd</filename> 
	&man.rc.8; скрипт ашиглан <application>OpenSSH</application>-г эхлүүлэх 
	боломжтой байдаг:</para>

      <programlisting>/etc/rc.d/sshd start</programlisting>
    </sect2>

    <sect2>
      <title>SSH клиент</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>клиент</secondary>
      </indexterm>

      <para>&man.ssh.1; хэрэгсэл &man.rlogin.1;-тэй адил 
	ажилладаг.</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para>Нэвтрэлт нь <command>rlogin</command> эсвэл 
        <command>telnet</command> ашиглан үүсгэгдсэн сесс шиг үргэлжлэх болно. 
	SSH нь хэрэглэгч холбогдоход серверийн жинхэнэ эсэхийг шалгахын тулд 
	түлхүүр хээ шалгах системийг хэрэглэдэг. Хэрэглэгч зөвхөн эхний удаа холбогдоход 
	<literal>yes</literal> гэж оруулахыг шаардана. Дараа дараагийн 
	нэвтрэлт оролдлогууд бүгд хадгалсан хээ шалгах түлхүүртэй харьцуулагдан 
	шалгагддаг. Хэрэв хадгалсан хээ нь дараа дараагийн нэвтрэлтийн оролдлогуудаас 
	хүлээн авсан хээнээс өөр бол SSH клиент нь танд түгшүүр өгнө. Хээнүүд 
	<filename>~/.ssh/known_hosts</filename> файлд эсвэл SSH v2-ийн хээнүүд
	<filename>~/.ssh/known_hosts2</filename> файлд 
	хадгалагдана.</para>

      <para>Анхдагчаар <application>OpenSSH</application> серверүүдийн 
	сүүлийн үеийн хувилбарууд зөвхөн SSH v2 холболтуудыг хүлээн авдаг. 
	Клиент нь хэрэв боломжтой бол 2-р хувилбарыг ашиглах бөгөөд боломжгүй бол 
	1-р хувилбарыг ашигладаг. <option>-1</option> эсвэл
        <option>-2</option> тохируулгуудыг 1-р эсвэл 2-р хувилбаруудад зориулан 
	дамжуулан клиентэд зөвхөн аль нэгийг ашиглахыг хүчилж болно. 1-р хувилбарын 
	нийцтэй байдал нь клиентэд хуучин хувилбаруудтай нийцтэй байх зорилгоор дэмжигдсэн 
	байдаг.</para>
    </sect2>
    
    <sect2>
      <title>Аюулгүй хуулбарлалт</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>аюулгүй хуулбарлалт</secondary>
      </indexterm>
      <indexterm><primary><command>scp</command></primary></indexterm>

      <para>&man.scp.1; тушаал &man.rcp.1;-тэй адил ажилладаг; энэ нь файлыг алсын 
	машинаас эсвэл машин уруу, ялгаатай нь аюулгүйгээр хуулдаг.</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@example.com's password: <userinput>*******</userinput>
COPYRIGHT            100% |*****************************|  4735       
00:00    
&prompt.root;</screen>
      <para>Өмнөх жишээн дээр энэ хостын хувьд хээ нь аль хэдийн хадгалагдсан болохоор 
	&man.scp.1;-ийг энд ашиглах үед шалгагддаг.</para>

      <para>&man.scp.1;-ээр дамжуулсан нэмэлт өгөгдлүүд нь &man.cp.1;-тэй адил бөгөөд 
	эхний нэмэлт өгөгдөлд файл эсвэл файлууд, хоёр дахь дээр очих файлыг 
	зааж өгдөг. Файл нь сүлжээгээр SSH-ээр татагддаг  болохоор файлын нэг эсвэл хэд хэдэн 
	нэмэлт өгөгдлүүд <option>user@host:&lt;path_to_remote_file&gt;</option> 
	хэлбэрийг авдаг.</para>

    </sect2>

    <sect2>
      <title>Тохиргоо</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>тохиргоо</secondary>
      </indexterm>

      <para><application>OpenSSH</application> дэмон болон клиентийн 
	системийн дагуух тохиргооны файлууд <filename>/etc/ssh</filename> 
	санд байрладаг.</para>

      <para><filename>ssh_config</filename> клиентийн тохируулгуудыг 
	тохируулдаг бөгөөд <filename>sshd_config</filename> нь 
	дэмонг тохируулдаг.</para>

      <para>Мөн <option>sshd_program</option> 
	(анхдагчаар <filename>/usr/sbin/sshd</filename>) болон 
	<option>sshd_flags</option> <filename>rc.conf</filename> 
	тохируулгууд тохиргооны түвшнүүдийг илүүтэйгээр хангадаг.</para>
    </sect2>

    <sect2 id="security-ssh-keygen">
      <title>ssh-keygen</title>

      <para>Нууц үгүүдийг ашиглахын оронд &man.ssh-keygen.1; нь 
	хэрэглэгчийг шалгаж танихад DSA эсвэл RSA түлхүүрүүдийг үүсгэхэд 
	хэрэглэгдэж болно:</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t <replaceable>dsa</replaceable></userinput>
Generating public/private dsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_dsa):
Created directory '/home/user/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_dsa.
Your public key has been saved in /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com
</screen>

      <para>&man.ssh-keygen.1; нь шалгаж танихад хэрэглэгдэх нийтийн болон хувийн 
	түлхүүр хослолыг үүсгэнэ. Хувийн түлхүүр <filename>~/.ssh/id_dsa</filename> эсвэл 
        <filename>~/.ssh/id_rsa</filename>-д хадгалагдах бөгөөд харин нийтийн түлхүүр 
	нь <filename>~/.ssh/id_dsa.pub</filename> эсвэл 
        <filename>~/.ssh/id_rsa.pub</filename>-д DSA болон RSA түлхүүрийн төрлүүдэд 
	зориулагдан хадгалагддаг. Тохируулга нь ажиллахын тулд нийтийн түлхүүр нь алсын машины 
	<filename>~/.ssh/authorized_keys</filename> файлд DSA болон RSA түлхүүрүүдийн 
	хоёулангийнх нь хувьд хийгдэх ёстой байдаг. 
	Үүнтэй адилаар нийтийн түлхүүрүүдийн RSA хувилбар нь 
	<filename>~/.ssh/authorized_keys</filename> файлд бас хийгдэх ёстой.</para>

      <para>Энэ нь нууц үгүүдийн оронд SSH түлхүүрүүдийг ашиглан алсын машин уруу 
	холбогдохыг зөвшөөрөх болно.</para>

      <para>Хэрэв нэвтрэх үгнүүд &man.ssh-keygen.1;-д ашиглагдаж байгаа бол 
	хувийн түлхүүрийг хэрэглэхийн тулд хэрэглэгчээс нууц үгийг нэвтрэх болгонд 
	асуудаг. &man.ssh-agent.1; нь урт нэвтрэх үгнүүдийг дахин дахин оруулах 
	тэр зовлонг зөөллөж чадах бөгөөд <xref linkend="security-ssh-agent"> 
	хэсэгт тайлбарлагдсан байгаа болно.</para>

      <warning><para>Төрөл бүрийн тохируулгууд болон файлууд нь 
	таны систем дээр байгаа <application>OpenSSH</application>-ийн 
	хувилбаруудаас шалтгаалан өөр өөр байдаг; асуудалтай учрахгүйн тулд 
	та &man.ssh-keygen.1; гарын авлагын хуудаснаас лавлах 
	хэрэгтэй.</para></warning>
    </sect2>

    <sect2 id="security-ssh-agent">
      <title>ssh-agent болон ssh-add</title>

      <para>&man.ssh-agent.1; болон &man.ssh-add.1; хэрэгслүүд нь 
	нэвтрэх үгнүүдийг дахин дахин бичүүлэлгүйгээр <application>SSH</application> 
	түлхүүрүүдийг санах ойд дуудан ашиглаж болох аргуудаар хангадаг.</para>

      <para>&man.ssh-agent.1; хэрэгсэл нь түүн уруу дуудагдсан хувийн түлхүүр(үүд) 
	ашиглан жинхэнэ эсэхийг шалгах танилтыг зохицуулна. &man.ssh-agent.1; нь өөр програмыг 
	ачаалахад хэрэглэгдэх ёстой. Хамгийн хялбартаа энэ нь  бүрхүүл  
	эсвэл илүү дэвшилттэйгээр ашиглавал цонхны удирдагч ажиллуулж болох 
	юм.</para>

      <para>&man.ssh-agent.1;-ийг бүрхүүлд ашиглахын тулд үүнийг эхлээд 
	бүрхүүлтэй цуг нэмэлт өгөгдөл маягаар ажиллуулах шаардлагатай. Хоёрдугаарт 
	хэн бэ гэдэг мэдээллийг (identity) &man.ssh-add.1;-г ажиллуулан нэмэх хэрэгтэй бөгөөд 
	түүнд хувийн түлхүүрийн нэвтрэх үгнүүдийг өгөх хэрэгтэй. Эдгээр алхмууд 
	хийгдсэний дараа хэрэглэгч харгалзах нийтийн түлхүүр суулгагдсан 
	дурын хост уруу &man.ssh.1; хийж чадах болно. 
	Жишээ нь:</para>

      <screen>&prompt.user; ssh-agent <replaceable>csh</replaceable>
&prompt.user; ssh-add
Enter passphrase for /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)
&prompt.user;</screen>

      <para>X11 дээр &man.ssh-agent.1; хэрэглэхийн тулд &man.ssh-agent.1;-ийн 
	дуудлага <filename>~/.xinitrc</filename>-д байх шаардлагатай. 
	Ингэснээр X11-д ачаалагдсан бүх програмуудад &man.ssh-agent.1;-ийн  
	үйлчилгээнүүдийг  үзүүлэх болно. Жишээ <filename>~/.xinitrc</filename> 
	файл иймэрхүү харагдах болно:</para>

      <programlisting>exec ssh-agent <replaceable>startxfce4</replaceable></programlisting>

      <para>Энэ нь &man.ssh-agent.1;-ийг ажиллуулах бөгөөд тэр нь эргээд 
	X11 эхлэх бүрт <application>XFCE</application>-ийг ажиллуулна.
	Ингэж хийгдсэний дараа өөрчлөлтүүд нь үйлчлэхийн тулд X11 дахин эхэлсний хойно 
	өөрийн SSH түлхүүрүүдийг бүгдийг ачаалахын тулд ердөө л &man.ssh-add.1;-ийг 
	ажиллуулаарай.</para>
    </sect2>

    <sect2 id="security-ssh-tunneling">
      <title>SSH туннель хийх</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>туннель хийх</secondary>
      </indexterm>

      <para><application>OpenSSH</application> нь шифрлэгдсэн сессийн үед өөр протоколыг 
	хайрцаглах туннель үүсгэх чадвартай байдаг.</para>

      <para>Дараах тушаал <application>telnet</application>-д зориулж туннель үүсгэхийг 
	&man.ssh.1;-д хэлж өгнө:</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

      <para><command>ssh</command> тушаал дараах тохируулгуудтай 
	хэрэглэгдэнэ:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>
	  
	  <listitem>
	    <para><command>ssh</command>-ийг протоколын 2-р хувилбарыг 
		ашиглахыг зааж өгнө. (хэрэв та хуучин SSH серверүүдтэй ажиллаж 
		байгаа бол үүнийг битгий ашиглаарай)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>Тушаал байхгүй эсвэл зөвхөн туннель гэдгийг заана. Хэрэв үүнийг 
		орхивол <command>ssh</command> ердийн сесс эхлүүлнэ.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para><command>ssh</command>-ийг ард, далд ажиллуулахыг 
		заана.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Локал туннелийг <replaceable>localport:remotehost:remoteport</replaceable>
		загвараар зааж өгнө.</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>Алсын SSH сервер.</para>
	  </listitem>
	</varlistentry>
      </variablelist>


      <para>SSH туннель нь сонсох сокетийг <hostid>localhost</hostid>-ийн 
	заагдсан порт дээр үүсгэн ажилладаг. Дараа нь локал хост/порт дээр хүлээн 
	авсан дурын холболтыг SSH-ээр дамжуулан заасан алсын хост болон порт уруу 
	илгээдэг.</para>

      <para>Жишээн дээр <hostid>localhost</hostid> дээрх <replaceable>5023</replaceable> 
	порт нь алсын машины <hostid>localhost</hostid> дээрх <replaceable>23</replaceable> 
	порт уруу дамжуулагдаж байна. <replaceable>23</replaceable> нь 
	<application>telnet</application> учир энэ нь SSH туннелээр аюулгүй 
	<application>telnet</application> сесс үүсгэнэ.</para>

      <para>SMTP, POP3, FTP гэх зэрэг ямар ч аюултай TCP протоколуудын 
	гүйцэтгэлийг хялбаршуулахад үүнийг ашиглаж болно.</para>

      <example>
	<title>SMTP-д зориулан SSH ашиглан аюулгүй туннель үүсгэх</title>

        <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>     

        <para>Үүнийг &man.ssh-keygen.1; болон нэмэлт хэрэглэгчийн бүртгэлүүдтэй 
	цуг илүү үл үзэгдэх/төвөггүй SSH туннель хийх орчин үүсгэхэд ашиглаж болно. 
	Түлхүүрүүд нь нууц үг бичихийн оронд ашиглагдаж болох бөгөөд туннелиуд 
	нь тусдаа хэрэглэгч маягаар ажиллаж чадна.</para>
      </example>

      <sect3>
	<title>SSH туннелийн практик жишээнүүд</title>

	<sect4>
	  <title>POP3 сервер уруу аюулгүй хандах</title>

	  <para>Ажил дээр чинь гаднаас холболтууд хүлээн авах SSH сервер байна. 
		Бас тэр оффисийн сүлжээнд POP3 сервер ажиллуулж байгаа 
		захидлын сервер байна. Таны гэр болон оффисийн хоорондын 
		сүлжээ болон сүлжээний зам итгэж болохоор эсвэл итгэж болохооргүй 
		байж магадгүй юм. Ийм учраас та өөрийн захидлыг аюулгүй аргаар 
		шалгах хэрэгтэй юм. Үүний шийдэл нь өөрийн оффисийн SSH сервер 
		уруу SSH холболт үүсгэж захидлын сервер уруу туннель хийх явдал 
		юм.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Туннель эхлэн ажилласны дараа та өөрийн захидлын клиентийнхээ 
		POP3 хүсэлтүүдийг <hostid>localhost</hostid>-ийн 2110 порт уруу 
		илгээхээр зааж өгч болно. Эндэх холболт туннелээр аюулгүйгээр дамжин 
		<hostid>mail.example.com</hostid> уруу илгээгдэнэ.</para>
	</sect4>

	<sect4>
	  <title>Хэцүү галт ханыг тойрон гарах</title>

	  <para>Зарим сүлжээний администраторууд хэтэрхий чанга галт ханын дүрэм ашиглан 
		зөвхөн ирж байгаа холболтууд төдийгүй гарч байгаа холболтуудыг ч бас 
		шүүдэг. Танд алсын машинуудад зөвхөн SSH болон вэбээр аялах 22 болон 
		80-р портуудад хандах боломжийг өгсөн байж болох юм.</para>

	  <para>Та хөгжим цацдаг Ogg Vorbis сервер зэрэг өөр (магадгүй ажилдаа холбоогүй) 
		үйлчилгээ уруу хандахыг магадгүй хүсэж болох юм. Хэрэв энэ Ogg Vorbis 
		сервер нь 22 эсвэл 80-аас бусад өөр порт дээр цацаж байгаа бол 
		та түүнд хандаж чадахгүй юм.</para>

	  <para>Үүний шийдэл нь таны сүлжээний галт ханаас гаднах машин уруу SSH холболт үүсгэж 
		үүнийг Ogg Vorbis сервер уруу туннель хийхэд ашиглах явдал юм.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>Таны урсгал хүлээн авах клиент одоо <hostid>localhost</hostid>-ийн 
		8888 порт уруу заагдах бөгөөд тэр цаашаагаа галт ханыг амжилттайгаар 
		гэтлэн <hostid>music.example.com</hostid> уруу дамжуулагдана.</para>
        </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title><varname>AllowUsers</varname> хэрэглэгчийн тохируулга</title>

      <para>Ямар хэрэглэгчид хаанаас орохыг хязгаарлаж өгөх нь зүйтэй юм. 
	<literal>AllowUsers</literal> тохируулга нь үүнд хүрэх сайн арга 
	юм. Жишээ нь <username>root</username> хэрэглэгчийг зөвхөн 
	<hostid role="ipaddr">192.168.1.32</hostid>-оос орохыг 
	зөвшөөрөхийн тулд доор дурдсантай адил тохируулгыг <filename>/etc/ssh/sshd_config</filename> 
	файлд хийх нь зүйтэй юм:</para>

      <programlisting>AllowUsers root@192.168.1.32</programlisting>

      <para><username>admin</username> хэрэглэгчийг хаанаас ч орохыг зөвшөөрөхийн 
	тулд ердөө л хэрэглэгчийн нэрийг өөрийг нь жагсааж өгнө:</para>

      <programlisting>AllowUsers admin</programlisting>

      <para>Олон хэрэглэгчид нэг мөрөнд жагсаагдах шаардлагатай:</para>

      <programlisting>AllowUsers root@192.168.1.32 admin</programlisting>

      <note>
        <para>Та энэ машин уруу нэвтрэх хэрэгцээтэй хэрэглэгч бүрийг жагсааж өгөх нь чухал юм, 
		тэгэхгүй бол тэдгээр нь орж чадахгүй болно.</para>
      </note>

      <para><filename>/etc/ssh/sshd_config</filename>-д өөрчлөлтүүд хийснийхээ 
	дараа &man.sshd.8;-д өөрийн тохиргооны файлуудыг дахин дуудахыг дараах тушаалыг 
	ажиллуулж та хэлж өгөх ёстой:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sshd reload</userinput></screen>
    </sect2>

    <sect2>
      <title>Нэмэлт унших материалууд</title>
      <para><ulink url="http://www.openssh.com/">OpenSSH</ulink></para>
      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1; 
        &man.ssh-agent.1; &man.ssh-add.1; &man.ssh.config.5;</para>
      <para>&man.sshd.8; &man.sftp-server.8; &man.sshd.config.5;</para>
    </sect2>
  </sect1>

  <sect1 id="fs-acl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Хавь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>ACL</primary>
    </indexterm>
    <title>Файлын системийн хандалт хянах жагсаалтууд</title>

    <para>Хормын хувилбарууд зэрэг файлын системийн өргөжүүлэлтүүдийн хамтаар FreeBSD 5.0 
	болон сүүлийн хувилбарууд Файлын системийн хандалт хянах жагсаалтуудын 
	(<acronym>ACL</acronym>-ууд) аюулгүй байдлыг санал болгодог.</para>

    <para>Хандалт Хянах Жагсаалтууд нь стандарт &unix; зөвшөөрлийн загварыг 
	маш нийцтэй (&posix;.1e) аргаар өргөтгөдөг. Энэ боломж нь администраторт 
	илүү төвөгтэй аюулгүй байдлын загвар болон түүний давуу талыг ашиглахыг 
	зөвшөөрдөг.</para>

    <para><acronym>UFS</acronym> файлын системүүдэд <acronym>ACL</acronym> 
	дэмжлэгийг идэвхжүүлэхийн тулд дараах:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>тохируулгыг цөмд эмхэтгэх шаардлагатай. Хэрэв энэ тохируулга эмхэтгэгдээгүй бол 
	<acronym>ACL</acronym>-ууд дэмжих файлын системийг холбохыг оролдоход 
	анхааруулах мэдэгдэл дэлгэцэд гардаг. Энэ тохируулга <filename>GENERIC</filename> 
	цөмд орсон байдаг. <acronym>ACL</acronym>-ууд нь файлын систем дээр өргөтгөсөн шинж 
	чанаруудыг  идэвхжүүлсэн дээр тулгуурладаг. Өргөтгөсөн шинж чанарууд нь 
	дараа үеийн &unix; файлын систем <acronym>UFS2</acronym>-д төрөлхийн 
	дэмжигдсэн байдаг.</para>

    <note><para><acronym>UFS1</acronym> дээр өргөтгөсөн шинж чанаруудыг тохируулахад  
	<acronym>UFS2</acronym> дээр тохируулахтай харьцуулбал илүү удирдлагын 
	зардал шаардлагатай байдаг. <acronym>UFS2</acronym> дээрх өргөтгөсөн 
	шинж чанаруудын ажиллагаа нь бас бодитойгоор илүү байдаг. Иймээс 
	<acronym>UFS2</acronym>-г <acronym>UFS1</acronym>-ийн оронд 
	хандалт хянах жагсаалтуудад ашиглахыг ерөнхийдөө зөвлөдөг.</para></note>

    <para><acronym>ACL</acronym>-ууд нь <filename>/etc/fstab</filename> файлд 
	нэмэгдэж өгч болох холбох үеийн удирдлагын  <option>acls</option> тугаар 
	идэвхтэй болдог.  Файлын системийн толгой дахь супер блокийн <acronym>ACL</acronym>-ууд тугийг 
	өөрчлөхийн тулд &man.tunefs.8;-ийг ашиглан шургуу замаар холбох үеийн тугийг автоматаар 
	зааж өгч болно. Ерөнхийдөө хэд хэдэн шалтгааны улмаас супер блокийн тугийг  ашиглах нь 
	дээр байдаг:</para>

    <itemizedlist>
      <listitem>
	<para>Холбх үеийн <acronym>ACL</acronym>-ууд туг дахин холболтоор өөрчлөгддөггүй 
	(&man.mount.8; <option>-u</option>), зөвхөн бүрэн гүйцэд 
	&man.umount.8; хийгдэж шинэ &man.mount.8; хийгдсэний дараа болно. 
	Энэ нь бас файлын системийг ашиглаж байх үед дарааллыг нь өөрчилж болохгүй гэсэн үг 
	юм.</para>
      </listitem>

      <listitem>
	<para><filename>fstab</filename>-д мөр байхгүй байсан ч гэсэн эсвэл төхөөрөмжүүдийн 
	дараалал өөрчлөгдсөн ч гэсэн супер блокийн тугийг тохируулах нь файлын системийг үргэлж 
	<acronym>ACL</acronym>-уудыг  идэвхтэйгээр холбоход хүргэдэг. Энэ нь файлын системийг 
	<acronym>ACL</acronym>-уудыг идэвхжүүлэлгүйгээр санамсаргүйгээр холбохоос хамгаалдаг бөгөөд 
	ингэж санамсаргүй холбох нь <acronym>ACL</acronym>-уудыг буруугаар албадаж 
	тэгснээр аюулгүй байдлын асуудлуудад хүргэж болох юм.</para>
      </listitem>
    </itemizedlist>

    <note><para>Бид шинэ &man.mount.8; хийлгүйгээр туг идэвхжүүлдгийг зөвшөөрөхөөр  
	<acronym>ACL</acronym>-уудын ажиллагааг өөрчилж болох юм, гэхдээ бид 
	<acronym>ACL</acronym>-уудыг идэвхжүүлэлгүй санамсаргүйгээр холболт хийхийг 
	болиулахыг хүсдэг бөгөөд учир нь хэрэв та <acronym>ACL</acronym>-уудыг идэвхжүүлээд 
	дараа нь болиулаад өргөтгөсөн шинж чанаруудыг устгалгүйгээр дахин идэвхжүүлбэл та 
	өөртөө нэлээн хэцүү асуудал учруулах зүйлийг хийх болно. Ерөнхийдөө та файлын систем 
	дээр <acronym>ACL</acronym>-уудыг идэвхжүүлсний дараа файлын хамгаалалтууд нь 
	системийн хэрэглэгчдэд зориулагдсан файлуудтай нийцгүй болж болох учир тэдгээрийг 
	болиулж болохгүй бөгөөд <acronym>ACL</acronym>-уудыг дахин идэвхжүүлэх нь 
	зөвшөөрлүүд нь өөрчлөгдсөн байж болох файлуудад өмнөх <acronym>ACL</acronym>-уудыг 
	магадгүй дахин холбож өөр тааварлаж болшгүй ажиллагаанд хүргэж болох юм.</para></note>
      
    <para><acronym>ACL</acronym>-ууд идэвхжүүлсэн файлын системүүд өөрсдийн зөвшөөрлийн 
	тохируулгууд дээрээ <literal>+</literal> (нэмэх) тэмдэг үзэх үед харуулдаг.
	Жишээ нь:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>Энд бид <filename>directory1</filename>,
      <filename>directory2</filename>, болон <filename>directory3</filename> 
	сангууд бүгд <acronym>ACL</acronym>-ууд-ийн давуу талыг авч байгааг харж байна. 
	<filename>public_html</filename> сан тэгэхгүй байна.</para>

    <sect2>
      <title><acronym>ACL</acronym>-уудыг ашиглах нь</title>

      <para>Файлын системийн <acronym>ACL</acronym>-уудыг &man.getfacl.1; 
	хэрэгслээр харж болно. Жишээ нь <filename>test</filename> файл дээрх 
	<acronym>ACL</acronym> тохируулгуудыг харахын тулд дараах тушаалыг 
	ажиллуулах хэрэгтэй:</para>

      <screen>&prompt.user; <userinput>getfacl <filename>test</filename></userinput>
	#file:test
	#owner:1001
	#group:1001
	user::rw-
	group::r--
	other::r--</screen>

      <para>Энэ файлын <acronym>ACL</acronym> тохируулгуудыг өөрчлөхийн тулд 
	&man.setfacl.1; хэрэгслийг ажиллуул. Ажиглаарай:</para>

      <screen>&prompt.user; <userinput>setfacl -k <filename>test</filename></userinput></screen>

      <para><option>-k</option> туг нь тухайн үед тодорхойлогдсон бүх 
	<acronym>ACL</acronym>-уудыг файл эсвэл файлын системээс 
	арилгана. Илүү дээр арга бол <acronym>ACL</acronym>-уудыг 
	ажиллуулахад шаардлагатай үндсэн талбаруудыг орхидог 
	<option>-b</option> тугийг ашиглах явдал юм.</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,group:web:r--,o::--- <filename>test</filename></userinput></screen>

      <para>Дээр дурдсан тушаал дээр <option>-m</option> тохируулга анхдагч 
	<acronym>ACL</acronym> оруулгуудыг өөрчлөхөд хэрэглэгдсэн. 
	Өмнөх тушаалаар устгагдсан болохоор урьдчилан тодорхойлсон оруулгууд 
	байхгүй учир энэ нь анхдагч тохируулгуудыг  сэргээж жагсаасан тохируулгуудаас 
	зааж өгдөг. Хэрэв та систем дээр байхгүй хэрэглэгч эсвэл бүлэг нэмэх бол 
	<errorname>Invalid argument</errorname> буюу Буруу нэмэлт өгөгдөл 
	гэсэн алдаа <devicename>stdout</devicename> уруу хэвлэгдэнэ гэдгийг 
	санаж байх хэрэгтэй.</para>
    </sect2>
  </sect1>

  <sect1 id="security-portaudit">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>Portaudit</primary>
    </indexterm>
    <title>Гуравдагч талын аюулгүй байдлын асуудлуудыг монитор хийх нь</title>

    <para>Сүүлийн жилүүдэд эмзэг асуудлын үнэлгээ хэрхэн зохицуулагдаж байгаа тал дээр 
	аюулгүй байдлын ертөнц олон сайжруулалт хийсэн. Одоогийн байгаа бүх л үйлдлийн 
	системүүд дээр гуравдагч талын хэрэгслүүд суулгаж тохируулдгаас болж системийн 
	халдлагын заналхийлэл ихэсдэг.</para>

    <para>Эмзэг асуудлын үнэлгээ нь аюулгүй байдлын түлхүүр хүчин зүйл бөгөөд 
	&os; нь үндсэн системд зориулан зөвлөгөөнүүдийг гаргадаг боловч 
	гуравдагч талын хэрэгслүүд бүрийн хувьд хийх нь &os; төслийн боломжоос 
	гадуур юм. Мэдэгдэж байгаа асуудлуудыг администраторуудад анхааруулж 
	гуравдагч талын эмзэг асуудлуудыг зөөлрүүлэх арга байдаг. &os;-д нэмэлтээр 
	<application>Portaudit</application> гэгддэг хэрэгсэл зөвхөн энэ 
	зорилгоор байдаг.</para>

    <para><filename role="port">ports-mgmt/portaudit</filename> порт нь 
	&os;-ийн аюулгүй байдлын баг болон портуудын хөгжүүлэгчдийн шинэчилж 
	ажиллагааг нь хангаж байдаг мэдээллийн баазаас мэдэгдэж байгаа аюулгүй байдлын 
	асуудлуудыг шалгадаг.</para>

    <para><application>Portaudit</application>-г ашиглаж эхлэхийн тулд 
	Портуудын цуглуулгаас түүнийг суулгах хэрэгтэй:</para>

    <screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/portaudit &amp;&amp; make install clean</userinput></screen>

    <para>Суулгах процессийн явцад өдөр бүрийн аюулгүй байдлыг шалгах ажиллагаанд 
	<application>Portaudit</application>-н гаралтыг зөвшөөрч 
	&man.periodic.8;-д зориулсан тохиргооны файлуудыг шинэчилдэг. 
	Өдөр тутмын аюулгүй байдлыг шалгах ажиллагаа <username>root</username>-ийн 
	захидлын бүртгэл уруу цахим захидал явуулж түүнийг уг хэрэглэгч уншсан эсэхийг
	баталгаажуулах хэрэгтэй. Өөр ямар ч илүү тохиргоо энд хэрэггүй.</para>

    <para>Суулгасны дараа администратор мэдээллийн баазыг шинэчлэх болон суулгасан 
	багцуудад мэдэгдэж байгаа эмзэг асуудлуудыг үзэхдээ дараах тушаалыг 
	ажиллуулна:</para>

    <screen>&prompt.root; <userinput>portaudit -Fda</userinput></screen>

    <note>
      <para>Мэдээллийн бааз &man.periodic.8; ажиллах үед автоматаар шинэчлэгддэг; 
	иймээс дээрх тушаал заавал шаардлагагүй юм. Энэ нь зөвхөн дараах жишээнүүдэд 
	шаардлагатай.</para>
    </note>

    <para>Портуудын цуглуулгын хэсэг болгон суулгагдсан гуравдагч талын хэрэгслүүдийг 
	ямар ч үед аудит хийхдээ администратор зөвхөн дараах тушаалыг ажиллуулах 
	хэрэгтэй:</para>

    <screen>&prompt.root; <userinput>portaudit -a</userinput></screen>

    <para><application>Portaudit</application> эмзэг асуудалтай багцын хувьд 
	доор дурдсантай адилыг гаргана:</para>

    <programlisting>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</programlisting>

    <para>Үзүүлсэн <acronym>URL</acronym> уруу вэб хөтчийг чиглүүлж администратор 
	асуудалтай байгаа эмзэг асуудлын талаар дэлгэрэнгүй мэдээллийг олж авч 
	болно. Ийм мэдээлэл нь нөлөөлөх хувилбарууд болон &os;-ийн портын хувилбар, 
	аюулгүй байдлын зөвлөгөөнүүд байж болох өөр бусад вэб сайтуудыг агуулж болох 
	юм.</para>

    <para>Товчхондоо <application>Portaudit</application> нь хүчирхэг 
	хэрэгсэл бөгөөд <application>Portupgrade</application> порттой цуг 
	хэрэглэхэд маш ашигтай байдаг.</para>
  </sect1>

  <sect1 id="security-advisories">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>FreeBSD-ийн аюулгүй байдлын зөвлөгөөнүүд</primary>
    </indexterm>
    <title>&os;-ийн аюулгүй байдлын зөвлөгөөнүүд</title>

    <para>Үйлдвэрлэлийн чанарыг хангасан үйлдлийн системүүдийн нэгэн адил &os; 
	<quote>Аюулгүй байдлын зөвлөгөөнүүд</quote> гаргадаг. Эдгээр 
	зөвлөгөөнүүд нь ихэвчлэн аюулгүй байдлын жагсаалтууд уруу илгээгддэг 
	бөгөөд зөвхөн тохирох хувилбаруудад засвар хийгдсэний дараа Errata буюу 
	алдааны хуудсанд тэмдэглэгддэг. Энэ хэсэгт зөвлөгөө гэж юу болох, түүнийг 
	хэрхэн ойлгох болон системд засвар хийхдээ ямар арга хэмжээнүүдийг 
	авах талаар тайлбарлах болно.</para>

    <sect2>
      <title>Зөвлөгөө ямархуу харагдах вэ?</title>

      <para>&os;-ийн аюулгүй байдлын зөвлөгөөнүүд 
	&a.security-notifications.name; захидлын жагсаалтаас авсан доорх
	зөвлөгөөтэй адил харагдах болно.</para>

      <programlisting>=============================================================================
&os;-SA-XX:XX.UTIL                                     Security Advisory
                                                          The &os; Project

Topic:          denial of service due to some problem<co id="co-topic">

Category:       core<co id="co-category">
Module:         sys<co id="co-module">
Announced:      2003-09-23<co id="co-announce">
Credits:        Person@EMAIL-ADDRESS<co id="co-credit">
Affects:        All releases of &os;<co id="co-affects">
                &os; 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<co id="co-corrected">
<acronym>CVE</acronym> Name:	CVE-XXXX-XXXX<co id="co-cve">

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background<co id="co-backround">


II.  Problem Description<co id="co-descript">


III. Impact<co id="co-impact">


IV.  Workaround<co id="co-workaround">


V.   Solution<co id="co-solution">


VI.  Correction details<co id="co-details">


VII. References<co id="co-ref"></programlisting>


      <calloutlist>
	<callout arearefs="co-topic">
	  <para><literal>Topic</literal> буюу сэдэв талбар асуудал юу болохыг яг заасан 
		байдаг. Энэ нь үндсэндээ тухайн үеийн аюулгүй байдлын зөвлөгөөний 
		танилцуулга бөгөөд эмзэг асуудалтай цуг хэрэгслийг тэмдэглэдэг.</para>
	</callout>

	<callout arearefs="co-category">
	  <para>The <literal>Category</literal> буюу зэрэглэл талбар нь хамаарч байгаа 
		системийн хэсгийг хэлдэг бөгөөд <literal>core</literal>, 
		<literal>contrib</literal>, эсвэл <literal>ports</literal>-ийн 
		аль нэг байж болно. <literal>core</literal> зэрэглэл нь эмзэг 
		асуудал &os; үйлдлийн системийн гол хэсэгт нөлөөлнө гэсэн үг юм. 
		<literal>contrib</literal> зэрэглэл нь эмзэг асуудал 
		<application>sendmail</application> зэрэг &os; төсөлд 
		хувь нэмэр болгон оруулсан програм хангамжуудад нөлөөлнө гэсэн үг юм.
		Эцэст нь <literal>ports</literal> зэрэглэл нь эмзэг асуудал 
		портуудын цуглуулганд ордог нэмэлт програм хангамжуудад нөлөөлөхийг 
		харуулдаг.</para>
	</callout>

	<callout arearefs="co-module">
	  <para><literal>Module</literal> талбар нь бүрэлдэхүүн хэсгийн байрлалыг 
		жишээ нь <literal>sys</literal> гэх зэргээр илэрхийлдэг. Энэ жишээн дээр 
		<literal>sys</literal> модуль өртөхийг бид харж байгаа  бөгөөд ийм учраас энэ 
		эмзэг асуудал нь цөм дотор ашиглагдсан бүрэлдэхүүн хэсэгт нөлөөлөх юм.</para>
	</callout>

	<callout arearefs="co-announce">
	  <para><literal>Announced</literal> буюу зарласан талбар нь аюулгүй байдлын 
		зөвлөгөө хэвлэгдсэн эсвэл ертөнцөд зарлагдсан огноог заадаг. Энэ нь 
		аюулгүй байдлын баг асуудал байгааг шалгаж үүний засвар 
		&os;-ийн эх модны архивт итгэмжлэн оруулсныг тогтоосон гэсэн үг юм.</para>
	</callout>

	<callout arearefs="co-credit">
	  <para><literal>Credits</literal> буюу талархал талбар нь эмзэг асуудлыг 
		мэдэж тайлагнасан хувь хүн болон байгууллагыг зааж талархдаг.</para>
	</callout>

	<callout arearefs="co-affects">
	  <para><literal>Affects</literal> буюу нөлөөлөх хувилбарын талбар нь 
		энэ эмзэг асуудал нөлөөлөх &os;-ийн хувилбаруудыг тайлбарладаг. 
		Цөмийн хувьд уг нөлөөлсөн файлууд дээр ажиллуулсан 
		<command>ident</command> тушаалын үр дүнг зэрвэс харж   
		хувилбарыг тодорхойлж болно. Портуудын хувьд 
		<filename>/var/db/pkg</filename> санд портын нэрийн дараа 
		хувилбарын дугаар байдаг. Хэрэв систем нь &os;-ийн <acronym>CVS</acronym> 
		архивтай адил хамгийн сүүлийн хэлбэрт орж өдөр тутам дахин бүтээгдээгүй 
		бол энэ нь нөлөөлөлд орсон хэвээр байх магадлалтай юм.</para>
	</callout>

	<callout arearefs="co-corrected">
	  <para><literal>Corrected</literal> буюу засварласан талбар нь 
		огноо, цаг, цагийн бүс болон засварласан хувилбаруудыг 
		заадаг.</para>
	</callout>

	<callout arearefs="co-cve">
	  <para>Common Vulnerabilities Database system буюу Нийтлэг Эмзэг асуудлуудын 
		Мэдээллийн Баазын системээс эмзэг асуудлуудыг хайхад хэрэглэгдэх 
		магадлалын мэдээлэлд нөөцлөгддөг.</para>
	</callout>

	<callout arearefs="co-backround">
	  <para><literal>Background</literal> талбар нь нөлөөлөлд яг ямар хэрэгсэл  
		орсон талаар мэдээлэл өгдөг. Ихэнхдээ энэ нь &os;-д яагаад тухайн хэрэгсэл 
		байдаг, юунд хэрэглэгддэг болон хэрэгсэл хэрхэн бий болсон талаар байдаг.</para>
	</callout>

	<callout arearefs="co-descript">
	  <para><literal>Problem Description</literal> буюу асуудлын тайлбар талбар нь 
		аюулгүй байдлын цоорхойг гүнзгий тайлбарладаг. Энэ нь гажигтай кодын мэдээлэл 
		эсвэл бүр хэрэгслийг хэрхэн хорлонтойгоор ашиглаж аюулгүй байдлын цоорхой 
		нээдэг тухай мэдээллийг агуулдаг.</para>
	</callout>

	<callout arearefs="co-impact">
	  <para><literal>Impact</literal> буюу үйлчлэл талбар нь асуудал системд 
		ямар төрлийн үйлчлэл үзүүлдгийг тайлбарладаг. Жишээ нь энэ нь 
		үйлчилгээг зогсоох халдлагаас авахуулаад хэрэглэгчдэд өгч болох нэмэлт 
		зөвшөөрлүүд эсвэл халдагчид супер хэрэглэгчийн хандалт өгөх зэрэг 
		юу ч байж болно.</para>
	</callout>

	<callout arearefs="co-workaround">
	  <para><literal>Workaround</literal> буюу тойрон гарах талбар нь 
		боломжит тойрон гарах арга замыг системийг шинэчилж чадахгүй байж болох 
		системийн администраторуудад олгодог. Энэ нь хугацааны шаардлагууд, 
		сүлжээний боломж эсвэл өөр бусад олон шалтгаанаас болдог байж болох 
		юм. Ямар ч байсан гэсэн аюулгүй байдлыг хөнгөнөөр авч үзэж болохгүй 
		бөгөөд нөлөөлөлд орсон систем эсвэл засвар нөхөөс хийгдэх аль эсвэл 
		аюулгүй байдлын цоорхойг тойрон гарах шийдэл хийгдэх 
		шаардлагатай.</para>
	</callout>

	<callout arearefs="co-solution">
	  <para><literal>Solution</literal> буюу шийдэл талбар нь нөлөөлөлд орсон 
		системийг засварлах заавруудыг санал болгодог. Энэ нь системд засвар 
		нөхөөс хийн аюулгүй ажиллуулах алхам алхмаар тест хийгдэж шалгагдсан арга 
		юм.</para>
	</callout>

	<callout arearefs="co-details">
	  <para><literal>Correction Details</literal> буюу засварын нарийн 
		учир талбар нь <acronym>CVS</acronym> салбар эсвэл хувилбарын 
		нэрийн цэгүүдийг доогуур зураас тэмдэгтээр өөрчилж үзүүлдэг. Мөн энэ нь 
		салбар болгон дахь нөлөөлөлд орсон файлуудын хувилбарын дугаарыг бас 
		харуулдаг.</para>
	</callout>

	<callout arearefs="co-ref">
	  <para><literal>References</literal> буюу лавлагаа талбар нь ихэвчлэн 
		бусад мэдээллийн эхүүдийг өгдөг. Энэ нь вэбийн <acronym>URL</acronym>-ууд, 
		номнууд, захидлын жагсаалтууд болон мэдээний бүлгүүдийг агуулж болно.</para>
	</callout>
      </calloutlist>
    </sect2>
  </sect1>

  <sect1 id="security-accounting">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Том</firstname>
	  <surname>Рөүдс</surname>
	  <contrib>Хувь нэмэр болгон оруулсан </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>Процессийн бүртгэл хөтлөх</primary>
    </indexterm>
    <title>Процессийн бүртгэл хөтлөх</title>

    <para>Процессийн бүртгэл хөтлөх аюулгүй байдлын аргыг ашиглаж 
	администраторууд системийн эх үүсвэрүүдийг ашигласан байдал болон тэдгээрийг 
	хэрэглэгчдэд хэрхэн хуваарилсныг мэдэж болох бөгөөд энэ нь системийг монитор 
	хийх боломжийг олгодог. Мөн энэ арга нь хэрэглэгчдийн тушаалуудыг туйлын 
	багаар  мөшгих боломжийг администраторуудад олгодог.</para>

    <para>Энэ нь үнэн хэрэгтээ өөрийн эерэг болон сөрөг талуудтай. Эерэг талуудын нэг нь 
	халдлагыг орсон цэг хүртэл нарийсган олох боломж юм. Сөрөг тал нь процессийн 
	бүртгэл хөтлөлтөөр үүссэн бүртгэлүүд бөгөөд тэдгээр нь дискний зай шаардаж 
	болох юм. Энэ хэсэг процессийн бүртгэл хөтлөлтийн үндсүүдийг администраторуудад 
	таниулах болно.</para>

    <sect2>
      <title>Процессийн бүртгэл хөтлөлтийг идэвхжүүлж хэрэглэх нь</title>
      <para>Процессийн бүртгэл хөтлөлтийг ашиглаж эхлэхээсээ өмнө үүнийг идэвхжүүлэх 
	хэрэгтэй. Үүнийг хийхийн тулд дараах тушаалуудыг ажиллуул:</para>

      <screen>&prompt.root; <userinput>touch <filename>/var/account/acct</filename></userinput>

&prompt.root; <userinput>accton <filename>/var/account/acct</filename></userinput>

&prompt.root; <userinput>echo 'accounting_enable="YES"' &gt;&gt; <filename>/etc/rc.conf</filename></userinput></screen>

      <para>Идэвхтэй болгосны дараа бүртгэл хөтлөлт <acronym>CPU</acronym> 
	статистикууд, тушаалууд гэх мэтийг даган мөшгиж эхэлнэ. Бүртгэлийн 
	бүх бичлэгүүд уншиж болохооргүй хэлбэрээр байдаг бөгөөд тэдгээрийг 
	&man.sa.8; хэрэгсэл ашиглан үзэж болдог. Ямар нэг тохируулгагүйгээр 
	ажиллуулбал <command>sa</command> тушаал нь хэрэглэгч болгоны 
	дуудлагуудын тоо, нийт зарцуулсан хугацааг минутаар, нийт <acronym>CPU</acronym> 
	болон хэрэглэгчийн хугацааг минутаар, дундаж I/O үйлдлүүдийн тоо 
	гэх мэттэй холбоотой мэдээллийг дэлгэцэнд хэвлэн үзүүлдэг.</para>

      <para>Тушаалуудыг ашигласан тухай мэдээллийг харахын тулд &man.lastcomm.1; 
	хэрэгслийг ашиглах хэрэгтэй. <command>lastcomm</command> тушаал нь 
	тухайн &man.ttys.5; дээр хэрэглэгчдийн ажиллуулсан тушаалуудыг 
	үзүүлэхэд хэрэглэгдэж болно, жишээ нь:</para>

      <screen>&prompt.root; <userinput>lastcomm ls
	<username>trhodes</username> ttyp1</userinput></screen>

      <para>Дээрх тушаал нь <literal>ttyp1</literal> терминал дээр <username>trhodes</username> 
	хэрэглэгчийн <command>ls</command> тушаал ашигласан мэдэгдэж байгаа 
	бүгдийг дэлгэцэд харуулах болно.</para>

      <para>Өөр олон ашигтай тохируулгууд байдаг бөгөөд &man.lastcomm.1;, 
	&man.acct.5; болон &man.sa.8; гарын авлагын хуудаснуудад тайлбарласан 
	байдаг.</para>
    </sect2>
  </sect1>  
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
