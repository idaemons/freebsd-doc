<!-- $Id: userppp.sgml,v 1.11 1997-09-24 14:46:06 hanai Exp $ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.26 -->

<sect>ユーザ ppp の設定<label id="userppp">

<!--  この FAQ あるいは手引は, <em>ユーザレベル ppp</em>または
   単に<em>ppp</em>としても知られている ppp を, 
   あなたの FreeBSD 2.0.5 (以降) で動くようにすることを目的としています. 

<p>また, ユーザ ppp を PPP サーバとして使う方法の概略についても述べています. 

<p>このドキュメントは もともと Nik Clayton によって書かれたものですが, 
   現在では何年にもわたる共同作業の成果となっています. 

-->

<p>ユーザ ppp は FreeBSD 2.0.5-RELEASE において, 
   既存のカーネル実装版の PPP に加えて導入されました. 
   それでは, これまでの pppd との違い, すなわち
   この新しい PPP が追加された理由とは いったい何なのでしょうか? 
   マニュアルから引用してみます: 

<quote>
   これはユーザプロセス PPP ソフトウェアパッケージです. 
   通常, PPP は (例えば pppd でそうなっているように) カーネルの一部として
   実装されていますので, デバッグや動作の変更が少々困難です. 
   しかし, この実装では, PPP はトンネルデバイスドライバ (tun) の
   助けにより, ユーザプロセスとして実装されています. 
</quote>

  本質として, これは常に PPP デーモンを実行しておかなくても, 
  必要な時に ppp プログラムを実行できるということを意味します. 
  このプログラムはカーネルとのデータ送受のために一般のトンネルデバイスを
  使うことができるため, PPP インターフェースをカーネルに組み込んでおく
  必要がありません. 

  以降では, ユーザ ppp と pppd のような他の PPP クライアント/サーバ
  ソフトウェアとを区別する必要が無い場合には, ユーザ ppp を単に ppp とだけ
  呼びます. 特に断らない限り, このセクションのすべてのコマンドは root 権限で
  実行する必要があります. 

  訳者注: 以前の日本語ハンドブックでは, iij-ppp のオリジナルアーカイブに
          附属する日本語ドキュメントの参照をおすすめしていました. 
          しかし最近では FreeBSD 独自の拡張がいろいろと追加され, もともとの 
          iij-ppp のドキュメントではカバーしきれなくなって来ています. 
          ですが心配はいりません. 日本語マニュアルプロジェクトから 
          FreeBSD の日本語版マニュアルページが配布されるようになりました. 
          こちらもハンドブックとあわせて参照されることをおすすめします. 

<sect1><heading>スタートの前に</heading>

<p>このドキュメントでは, あなたが
   およそ以下のような状況にあると仮定しています: 

   PPP 接続の使えるインターネットサービスプロバイダ (ISP) のアカウントを
   持っている. さらに, 接続済みのモデム (またはその他のデバイス) があり, 
   プロバイダとの接続が可能なように正しく設定されている. 

   以下の情報を手に入れておく必要があるでしょう: 

<itemize>
   <item><p>プロバイダの電話番号.

   <item><p>ログイン名とパスワード. これは通常の unix 形式のログイン名と
            パスワードの組かもしれませんし, PPP PAP または CHAP の
            ログイン名とパスワードの組かもしれません.

   <item><p>プロバイダのゲートウェイの IP アドレス. 
            ゲートウェイとは, あなたがそこに接続をおこなって, 
            <tt>デフォルトルート</tt>として設定することになるマシンです. 
            もしプロバイダがこのアドレスを明示していなくても大丈夫. 
            適当に設定しておいて, 接続時にプロバイダの PPP サーバから
            教えてもらうことができます. 
         <p>このアドレスは, 以降<tt>HISADDR</tt>と呼ぶことにします. 

   <item><p>プロバイダのネットマスク設定. 繰り返しますが, 不明な場合には
            ネットマスクとして 255.255.255.0 を使用しておけば問題ありません. 

   <item><p>一つ以上のネームサーバの IP アドレス. 通常, IP アドレスが二つ
            プロバイダから指示されているはずです. 自分でネームサーバを
            動かしているのでなければ, この情報は<bf>絶対に</bf>必要です. 

   <item><p>もしプロバイダから固定の IP アドレスとホスト名の割り当てを
         受けているのなら, 同様にそれも必要になるでしょう. 
         そうでなければ, どのアドレス範囲から IP アドレスの割り当てが
         おこなわれるかを知っておく必要があるでしょう. 
         もし範囲が示されていないとしても, 任意の IP アドレスを
         受け入れるようにすることが可能です (後で説明します). 
</itemize>

   もし, これらの情報のうち不明なものがあれば, プロバイダに連絡して
   確認しておいてください. 

<sect1><heading>ppp 対応カーネルの構築</heading>

<p>説明でも述べているように, ``ppp'' はカーネルの ``tun'' デバイスを使います. 
   そのため, このデバイスがカーネルに組み込まれているかどうかを
   確認しておかなくてはいけません. 

   これを確認するには, カーネルコンパイルディレクトリ
   (<tt>/sys/i386/conf</tt> または <tt>/sys/pc98/conf</tt>) に移動して, 
   カーネルコンフィグレーションファイルを調べます. 
   以下の行がどこかに含まれている必要があります. 

<tscreen><verb>
   pseudo-device tun 1
</verb></tscreen>

   元々の GENERIC カーネルは標準でこれを含んでいますので, 
   カスタムカーネルをインストールしているのではなかったり, 
   /sys ディレクトリが存在しないのであれば, 何も変更する必要はありません. 
   <p>この行がカーネルコンフィグレーションファイルに含まれていなかったり, 
   tun デバイスが一つでは足りない場合 (例えば, 同時に 16 本の
   ダイアルアップ PPP 接続を処理できるサーバを立ち上げるとしたら, 
   ``1'' のかわりに ``16'' を指定する必要があるでしょう), この行を追加して
   カーネルの再コンパイルとインストールをおこなう必要があります. 
   それからこの新しいカーネルを使ってブートしてください. 
   カーネルコンフィグレーションの詳細については, 
   <ref id="kernelconfig" name="FreeBSD カーネルのコンフィグレーション">
   を参照してください. 

<p>以下のコマンドを実行することで, 現在のカーネルにトンネルデバイスが
   いくつ組み込まれているかを調べることができます: 

<tscreen><verb>
   # ifconfig -a
   tun0: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1500
           inet 200.10.100.1 --> 203.10.100.24 netmask 0xffffffff
   tun1: flags=8050<POINTOPOINT,RUNNING,MULTICAST> mtu 576
   tun2: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1500
           inet 203.10.100.1 --> 203.10.100.20 netmask 0xffffffff
   tun3: flags=8050<POINTOPOINT,RUNNING,MULTICAST> mtu 1500
</verb></tscreen>

   この例ではトンネルデバイスが四つあって, うち二つに設定がおこなわれていて 
   現在使用中であることがわかります. 

<p>トンネルデバイスがカーネルに組み込まれておらず, 何らかの理由で
   カーネルの再構築ができない場合でも, 方法がないわけではありません. 
   動的にデバイスをロードすることができるはずです. 詳細については 
   modload(8) や lkm(4) など, 適切なマニュアルを参照してください. 

<p>この機会にファイアウォールも設定しておきたいと思っているのであれば, 
   詳細については<ref id="firewalls" name="ファイアウォール">セクションを
   参照してください. 

<sect1><heading>tun デバイスの確認</heading>

<p>ほとんどのユーザは ``tun'' デバイス (tun0) が一つあれば充分でしょう. 
   より多くのデバイスを使う場合 (すなわち, カーネルコンフィグレーション
   ファイルで tun 疑似デバイスの行に `1' 以外の数値を指定している場合), 
   以下で ``tun0'' と書かれている部分をすべて, あなたが使うデバイスの番号に
   あわせて読みかえてください. 

   tun0 デバイスが正しく作成されていることを確認する最も簡単な方法は, 
   それを作り直すことです. そのためには, 以下のコマンドを実行します: 

<tscreen><verb>
   # cd /dev
   # ./MAKEDEV tun0
</verb></tscreen>

<p>カーネルに 16 個のトンネルデバイスを組み込んだのであれば, 
   tun0 だけでなく他の tun デバイスも作成しておく必要があるでしょう: 

<tscreen><verb>
   # cd /dev
   # ./MAKEDEV tun15
</verb></tscreen>

<p>また, カーネルが正しく設定されているかどうかを調べるために
   以下のコマンドを実行して, このような出力が得られることを確認します: 

<tscreen><verb>
   $ ifconfig tun0
   tun0: flags=8050<POINTOPOINT,RUNNING,MULTICAST> mtu 1500
   $ 
</verb></tscreen>

<sect1><heading>名前の解決に関する設定</heading>

<p>リゾルバ (resolver) はシステムの一部分で, IP アドレスとホスト名との
   変換をおこないます. IP アドレスとホスト名を対応させるためのマップを, 
   二つの場所のうちの一つから探すように設定できます. 
   一つめは<tt>/etc/hosts</tt> (<tt>man 5 hosts</tt>) と呼ばれるファイルです. 
   二つめはインターネット ドメインネームサービス (DNS) と呼ばれる
   分散データベースですが, これに関する議論は このドキュメントで扱う範囲を
   越えていますので, これについての説明はおこないません. 

<p>このセクションではリゾルバの設定方法について簡単に説明します. 

<p>リゾルバは名前のマッピングをおこなうシステムコールの集合体です. ただし
   どこからマッピング情報を見つけるのかは, 最初に指示しておく必要があります. 
   これは まず<tt>/etc/host.conf</tt>ファイルを編集することでおこないます. 
   混乱の元になりますので, このファイルを<tt>/etc/hosts.conf</tt>と
   呼んだりしては<bf>いけません</bf> (余分な ``s'' がついていますね). 

<sect2><heading>/etc/host.conf ファイルの編集</heading>

<p>このファイルには 以下の 2 行が書かれているはずです: 

<tscreen><verb>
   hosts
   bind
</verb></tscreen>
   これは, 最初に<tt>/etc/hosts</tt>ファイルを調べ, そこで目的の名前が
   見つけられなかった場合に DNS を引きにいくようリゾルバに指示します. 

<sect2><heading>/etc/hosts(5) ファイルの編集</heading>

<p>このファイルはローカルネットワーク上に存在するマシンの IP アドレスと
   ホスト名を含んでいるはずです. 最低でも ppp を動作させるマシンのエントリが
   含まれている必要があります. そのマシンのホスト名が foo.bar.com で, 
   IP アドレスが 10.0.0.1 であると仮定すると, <tt>/etc/hosts</tt>は
   以下の行を含んでいなければいけません: 

<tscreen><verb>
   127.0.0.1    localhost
   10.0.0.1     foo.bar.com	       foo
</verb></tscreen>

   一つめの行は ``localhost'' を現在のマシンの別名として定義しています. 
   マシン固有の IP アドレスが何であっても, この行の IP アドレスは
   常に 127.0.0.1 でなければいけません. 二つめの行はホスト名 ``foo.bar.com'' 
   (と, その省略形 ``foo'') を IP アドレス 10.0.0.1 にマップします. 

   もしプロバイダから固定の IP アドレスとホスト名を割り当てられて
   いるのであれば, それを 10.0.0.1 エントリのかわりに使ってください. 

<sect2><heading>/etc/resolv.conf ファイルの編集</heading>

<p><tt>/etc/resolv.conf</tt>はリゾルバの振舞いを指定します. 
   もし自前の DNS サーバを走らせているのなら, このファイルは空のままに
   しておくこともできます. 通常は, 以下のように書いておく必要があるでしょう: 

<tscreen><verb>
   nameserver x.x.x.x
   nameserver y.y.y.y
   domain bar.com
</verb></tscreen>
   
   <tt>x.x.x.x</tt> と <tt>y.y.y.y</tt> はプロバイダが指示するアドレスで, 
   接続するプロバイダが提供している「ネームサーバ」を すべて書いてください. 
   ``domain'' に指定するのは このマシンのデフォルトのドメイン名で, おそらく
   書かなくても問題は無いでしょう. このファイルの各エントリの詳細については, 
   resolv.conf のマニュアルページを参照してください. 

<sect1><heading>ppp の設定</heading>

<p>ユーザ ppp と pppd (カーネルレベルの PPP 実装) は
   どちらも<tt>/etc/ppp</tt>ディレクトリに置かれた設定ファイルを使います. 
   ここには設定ファイルのサンプルが用意されていて, ユーザ ppp の設定を
   おこなう際に大変参考になりますので, 削除したりしないでください. 

<p>ppp の設定をするためには, 必要に応じていくつかのファイルを編集する必要が
  あります. 書き込む内容は, プロバイダが静的に IP アドレスを割り当てる 
  (つまり, 固定の IP アドレスを一つ与えられて, 常にそれを使う) か, 
  または動的に IP アドレスを割り当てる (つまり, PPP セッションごとに 
  IP アドレスが変化する可能性がある) かということに ある程度依存します. 

<sect2><heading>静的 IP アドレスによる PPP 接続<label id="userppp:staticIP">
       </heading>

<p>まず<tt>/etc/ppp/ppp.conf</tt>という設定ファイルを作成する必要があります. 
   これは以下の例とほとんど同じようなものになるでしょう. ``:'' で終る行は 
   1 カラム目から始め, その他の行はスペースまたはタブで以下の例のように
   段をつける (インデントする) 必要があることに注意してください. 

<tscreen><verb>
1     default:
2       set device /dev/cuaa0
3       set speed 115200
4       set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" ATE1Q0 OK-AT-OK
\\dATDT\\T TIMEOUT 40 CONNECT"
5     provider:
6       set phone "(0123) 456 7890"
7       set login "TIMEOUT 10 gin:-BREAK-gin: foo word: bar col: ppp"
8       set timeout 300
9       deny lqr
10      set ifaddr x.x.x.x y.y.y.y
11      delete ALL
12      add 0 0 HISADDR
</verb></tscreen>
   ファイルでは行番号を取り除いておいてください. 
   これは解説の際に参照する行を示すためにつけたものです. 

<descrip>
<tag/Line 1:/  デフォルトエントリを指定します. このエントリ中のコマンドは
               ppp が起動された際に自動的に実行されます. 

<tag/Line 2:/  モデムが接続されているデバイスを指定します. 
               COM1: は<tt>/dev/cuaa0</tt>に, 
               COM2: は<tt>/dev/cuaa1</tt>になります. 

<tag/Line 3:/  通信速度 (DTE 速度) を指定します. もし 115200 が使えない
               (最近のモデムなら大抵使えるはずですが) 場合には, 
               かわりに 38400 を指定してみてください. 

<tag/Line 4:/  ダイアルスクリプトを指定します. 
               ユーザ ppp は<tt>chat(8)</tt>言語に似た, 受信待ち文字列と
               送信文字列の対からなるスクリプトを使用します. 
               この言語の機能に関しては, マニュアルページを参照してください. 

<tag/Line 5:/  接続するプロバイダの名前 ``provider'' を
               エントリ名として指定します. 

<tag/Line 6:/  このプロバイダの電話番号を指定します. 複数の電話番号を 
               ``:'' や ``|'' で区切って指定することができます. 
               これら区切り文字の違いについては, ppp のマニュアルページに
               詳しく書かれています. 
               要約すると, 毎回違う番号に かけたいのであれば ``:'' を使います. 
               常に まず先頭の番号にかけてみて, つながらない時にだけ 
               2 番目以降の番号に かけたいのであれば ``|'' を使います. 
               例に示されているように, 常に電話番号全体を引用符で
               くくって (クォートして) おきます. 

<tag/Line 7:/  ダイアルスクリプトと同様に, ログインスクリプトも 
               chat 言語風の記述をおこないます. 
               この例は, 以下のようなログインセッションを使用する
               プロバイダのためのものです: 

<tscreen><verb>
   J. Random Provider
   login: foo
   password: bar
   protocol: ppp
</verb></tscreen>

               このスクリプトは必要に応じて書きかえる必要があるでしょう. 
               PAP や CHAP を使うのなら, ここでログインは おこないませんので
               ログイン文字列は空白のままにしておきます. 
               詳細については <ref id="userppp:PAPnCHAP"
               name="PAP および CHAP による認証">を参照してください. 

<tag/Line 8:/  デフォルトの接続タイムアウト時間を (秒数で) 指定します. 
               この例では, 300 秒間 通信がおこなわれなければ
               自動的に接続を切るように指定しています. 
               タイムアウトさせたくない場合には, この値を 0 に設定します. 

<tag/Line 9:/  Link Quality Report (LQR) パケットを交換するように 
               ppp を設定することもできます. 
               これらのパケットを使い, 物理リンクの品質を調査するのです. 
               LQR に対して ppp のとる戦略は, これらのパケットのうちの 
               いくつかが失われた時に接続を閉じるというものです. 
               この方法は, 2 台のマシンを直接シリアル回線で接続していて, 
               回線が接続されていることを示すために
               モデムの DSR 信号が使えない場合に有効です. 
               回線がデータで飽和してしまうと LQR パケットが「失われ」るため, 
               ppp が早まって接続を閉じてしまうことがあります. 
               LQR の使用を拒否するように設定しておけば, このような問題は
               起こりませんので, (モデムを介して接続する場合には) 用心のため 
               LQR 使用の提案を拒否するように設定しておくのが良いでしょう. 
               デフォルトの設定では, ppp は自分から LQR の使用を提案することは
               ありませんが, 通信相手が LQR の使用を提案してくると, それを
               受け入れてしまいます. 

<tag/Line 10:/ インターフェースのアドレスを指定します. 文字列 x.x.x.x は
               プロバイダに割り当てられた IP アドレスで置きかえてください. 
               文字列 y.y.y.y はプロバイダから指示されたゲートウェイ 
               (接続先となるマシン) の IP アドレスで置きかえてください. 
               プロバイダがゲートウェイのアドレスを指示していない場合は, 
               <tt>10.0.0.2/0</tt> を使用しておいてください. 
               もし「仮の」アドレスを使用する必要がある場合には, 
               <ref id="userppp:dynamicIP" 
               name="動的 IP アドレスによる PPP 接続">に関する指示に従って, 
               <tt>/etc/ppp/ppp.linkup</tt> にエントリを作成していることを
               確認してください. 
               この行が省略されていると, ppp を <tt>-auto</tt> モードや 
               <tt>-dynamic</tt> モードで動作させることはできません. 

<tag/Line 11:/ この PPP 接続で使用する tun デバイスに関する既存のエントリを 
               ルーティングテーブルから すべて削除します. 
               通常, これは必須というわけではありませんが, 
               クリーンな状態で ppp がスタートできるよう保証しておきます. 

<tag/Line 12:/ プロバイダのゲートウェイへの経路をデフォルトルートとして
               追加します. 特殊文字列 <tt>HISADDR</tt> は, 9 行目で指定された
               ゲートウェイのアドレスで置きかえられます. 
               <tt>HISADDR</tt> は 9 行目までは初期化されていませんので, 
               その行よりも後でしか使えないことに注意してください. 
</descrip>

<p>静的な IP アドレスを持っていて, 接続が完了する前にルーティングテーブルの
   エントリが正しく設定されているのであれば, <tt>ppp.linkup</tt> に
   エントリを追加する必要はありません. 
   しかし, この場合でもエントリを追加して, 接続が完了した時点で
   プログラムを呼び出したいことがあるかもしれません. 
   これについては後ほど sendmail を例として説明します. 

<p>これらの設定ファイルのサンプルが<tt>/etc/ppp</tt>ディレクトリに
   置かれています. 

<sect2><heading>動的 IP アドレスによる PPP 接続<label id="userppp:dynamicIP">
       </heading>

<p>プロバイダが静的な IP アドレスの割り当てをおこなっていない場合, 
   <tt>ppp</tt>が相手側のホスト (ゲートウェイ) と交渉して, 
   こちら側と相手側のアドレスを決めるように設定することができます. 
   これは, 起動時には「仮の」アドレスを使っておいて, 
   接続後に IP コンフィグレーション プロトコル (IPCP) を使用して
   ppp が IP アドレスを正しく設定できるようにすることで実現されます. 
   <ref id="userppp:staticIP" name="静的 IP アドレスによる PPP 接続">に
   以下の変更を加える以外は, <tt>ppp.conf</tt> の設定は同じです: 

<tscreen><verb>
10      set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0
</verb></tscreen>

   繰り返しますが, 行番号は取り除いておいてください. 
   これは解説の際に参照する行を示すためにつけたものです. 
   なお, 少なくともスペース 1 個分の段づけ (インデント) が必要です. 

<descrip>
<tag/Line 10:/ ``/'' 文字の後ろの数字は, アドレス交渉の際に固定しておきたい
               ビットの数です. 場合によっては, もっと適切な IP アドレスを
               指定しておきたいこともあるかもしれませんが, 
               ほとんどの場合には 上の例の通りで問題無いはずです. 
               相手側の PPP 実装が壊れていて この設定では動かない場合, 
               最後に <tt>0.0.0.0</tt> を追加すると うまく動くように
               なることがあります: 

<tscreen><verb>
  set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</verb></tscreen>

               このようにすると, ppp は <tt>10.0.0.1</tt> のかわりに 
               <tt>0.0.0.0</tt> を使用して交渉を開始します. 
               ここで <tt>set ifaddr</tt> コマンドの最初の引数として
               <tt>0.0.0.0/0</tt> を指定してはいけません. 
               さもないと, <tt>-auto</tt> モードや <tt>-ddial</tt> モードで
               動作させる際に 初期経路を設定することができなくなります. 
</descrip>

<p><tt>/etc/ppp/ppp.linkup</tt> にもエントリを作成しておく必要があります. 
   <tt>ppp.linkup</tt> は接続が確立された後に使用されます. この時点では, 
   ppp は<bf>実際に</bf>どの IP アドレスを使うべきなのか わかっているはずです. 
   以下のエントリは存在する仮の経路を削除し, 正しい経路を作成します: 

<tscreen><verb>
1     provider:
2       delete ALL
3       add 0 0 HISADDR
</verb></tscreen>

<descrip>
<tag/Line 1:/ 接続を確立する際に, ppp は以下のルールに従って 
              <tt>ppp.linkup</tt> のエントリを検索します: 
              まず <tt>ppp.conf</tt> で使用されたのと同じラベルを探します. 
              もし見つからなければ, ゲートウェイの IP アドレスのエントリを
              探します. このエントリは 4 オクテットの IP アドレス形式の
              ラベルです. それでも まだエントリが見つからなければ, 
              <tt>MYADDR</tt> エントリを探します. 

<tag/Line 2:/ この行は, 使用する tun インターフェースに関する既存の経路を 
              (ダイレクトルートのエントリを除き) すべて削除するよう 
              ppp に指示します. 

<tag/Line 3:/ この行は <tt>HISADDR</tt> への経路をデフォルトルートとして
              追加するように ppp に指示します. <tt>HISADDR</tt> は IPCP で
              決定されたゲートウェイの IP アドレスで置きかえられます. 
</descrip>

<p>詳細なサンプルについては, <tt>/etc/ppp/ppp.conf.sample</tt> ファイル中の 
   pmdemand エントリと <tt>/etc/ppp/ppp.linkup.sample</tt> を参照してください. 

<sect2><heading>かかってきた電話を ppp で受けるには</heading>

<p>このセクションでは ppp をサーバとして設定する方法について説明します. 

<p>かかってきた電話を<tt>ppp</tt>が受けるように設定する場合, 
   <tt>PPP</tt>接続についてだけパケットを転送するようにするのか, 
   すべてのインターフェースについて転送するようにするのか, 
   それとも一切転送をおこなわないのかを決定しなければいけません. 
   PPP 接続についてだけ転送をおこなうためには, <tt>ppp.conf</tt>ファイルに
   以下の行を追加しておきます. 

<tscreen><verb>
    enable proxy
</verb></tscreen>

   すべてのインターフェースについてパケットの転送をおこなう場合には, 
   <tt>/etc/rc.conf</tt>で以下のオプションを指定してください. (このファイルは
   以前のバージョンの FreeBSD では<tt>/etc/sysconfig</tt>と呼ばれていました) 

<tscreen><verb>
    gateway=YES
</verb></tscreen>

<sect3><heading>どの getty を使いますか?</heading>

<p>getty でダイアルアップサービスをおこなう場合の優れた解説が <ref id="dialup" 
   name="FreeBSD でダイアルアップサービスをおこなうための設定">にあります. 

<p>getty に代わるものとしては, 
   <url url="http://www.leo.org/~doering/mgetty/index.html" name="mgetty">
   があります. これは getty をより柔軟にしたもので, 
   ダイアルアップ回線での使用を意図して設計されています. 

<p>mgetty を使う場合の利点は, mgetty が積極的にモデムと<em>通信する</em>
   ということです. つまり, もし<tt>/etc/ttys</tt>でポートを閉じている場合, 
   モデムは電話をとらなくなります. 

<p>最近のバージョンの mgetty (0.99beta 以降) では, PPP ストリームの
   自動検出もサポートされています. これにより, クライアント側で
   スクリプトを準備しなくてもサーバにアクセスすることができます. 

<p>mgetty に関する, より詳細な情報については <ref id="userppp:mgetty" 
   name="Mgetty と AutoPPP"> を参照してください. 

<sect3><heading>ppp の実行許可</heading>

<p>ppp は通常, ID 0 のユーザ (root) として動作しなければいけませんが, 
   以下で説明するように, ppp を通常のユーザとしてサーバモードで実行させたい
   場合には, そのユーザを <tt>/etc/group</tt> の <tt>network</tt> グループに
   追加して, ppp を実行する許可を与えておかなければいけません. 

<sect3><heading>動的 IP ユーザのための ppp シェルの設定</heading>

<p><tt>/etc/ppp/ppp-shell</tt>という名前で, 以下のような内容のファイルを
   作成します: 

<tscreen><verb>
   #!/bin/sh
   IDENT=`echo $0 | sed -e 's/^.*-\(.*\)$/\1/'`
   CALLEDAS="$IDENT"
   TTY=`tty`

   if [ x$IDENT = xdialup ]; then
       IDENT=`basename $TTY`
   fi

   echo "PPP for $CALLEDAS on $TTY"
   echo "Starting PPP for $IDENT"

   exec /usr/sbin/ppp -direct $IDENT
</verb></tscreen>

<p>このスクリプトには実行可能属性をつけておきます. 
   次に, 以下のコマンドを実行し, <tt>ppp-dialup</tt>という名前で
   このスクリプトへのリンクを作成します: 

<tscreen><verb>
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-dialup
</verb></tscreen>

<p>すべてのダイアルアップ ppp ユーザのログイン<em>シェル</em>として
   このスクリプトを使用します. 以下は pchilds というユーザ名の
   ダイアルアップユーザを<tt>/etc/password</tt>へ登録した場合の例です. 
   (パスワードファイルを直接エディタで編集したりせず, 
   <tt>vipw</tt>を使ってください) 

<tscreen><verb>
   pchilds:*:1011:300:Peter Childs PPP:/home/ppp:/etc/ppp/ppp-dialup
</verb></tscreen>

<p>任意のユーザが読むことのできる, <tt>/home/ppp</tt>ディレクトリを
   作成します. <tt>/etc/motd</tt>が表示されないようにするため, 
   このディレクトリには以下のように大きさが 0 バイトのファイルを
   作成しておきます. 

<tscreen><verb>
   -r--r--r--   1 root     wheel           0 May 27 02:23 .hushlogin
   -r--r--r--   1 root     wheel           0 May 27 02:22 .rhosts
</verb></tscreen>

<sect3><heading>静的 IP ユーザのための PPP シェルの設定</heading>

<p>上記と同じように<tt>ppp-shell</tt>ファイルを作成し, 
   静的な IP アドレスを割り当てるアカウントそれぞれについて
   <tt>ppp-shell</tt>へのシンボリックリンクを作成します. 

<p>例えば, クラス C ネットワークの経路制御を必要とする, 
   三人のダイアルアップユーザ fred, sam, mary がいるとすると, 
   以下のコマンドを実行することになります: 

<tscreen><verb>
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-fred
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-sam
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-mary
</verb></tscreen>

<p>これらのユーザのダイアルアップアカウントでは, 上で作成した
   それぞれのシンボリックリンクをログインシェルとして設定しておきます. 
   (つまり, ユーザ mary のログインシェルは<tt>/etc/ppp/ppp-mary</tt>に
   なります). 

<sect3><heading>動的 IP ユーザのための ppp.conf の設定</heading>

<p><tt>/etc/ppp/ppp.conf</tt>ファイルは, 大体以下のような内容になるでしょう: 

<tscreen><verb>
   default:
    set debug phase lcp chat
    set timeout 0

   ttyd0: 
    set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
    enable proxy

   ttyd1:
    set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
    enable proxy
</verb></tscreen>
 
<p>上の例のように段をつける (インデントする) 必要があることに注意してください. 

<p><tt>default:</tt> エントリはセッションごとにロードされます. 
   <tt>/etc/ttys</tt>で有効にしてある各ダイアルアップ回線ごとに一つ, 
   上記の<tt>ttyd0:</tt>のようなエントリを作成します. 
   各行の相手側アドレスとして, それぞれ別の IP アドレスを 
   動的 IP ユーザのための IP アドレスのプールから割り当てておく必要があります. 

<sect3><heading>静的 IP ユーザのための ppp.conf の設定</heading>

<p>上のサンプルの<tt>/etc/ppp/ppp.conf</tt>の内容に加えて, 
   静的に IP を割り当てられたダイアルアップユーザ
   それぞれのためのエントリを追加する必要があります. 
   ここでも fred, sam, mary の例を使うことにしましょう. 
 
<tscreen><verb>
   fred:
    set ifaddr 203.14.100.1 203.14.101.1 255.255.255.255
 
   sam:
    set ifaddr 203.14.100.1 203.14.102.1 255.255.255.255
 
   mary:
    set ifaddr 203.14.100.1 203.14.103.1 255.255.255.255
</verb></tscreen> 

<p>必要であれば, それぞれの静的 IP ユーザに対する経路制御情報も
   <tt>/etc/ppp/ppp.linkup</tt>ファイルに書いておくべきでしょう. 
   以下の例ではクライアントの PPP リンクを経由する, 
   クラス C の<tt>203.14.101.0</tt>ネットワークへの経路を追加しています. 

<tscreen><verb>
   fred:
    add 203.14.101.0 netmask 255.255.255.0 HISADDR
 
   sam:
    add 203.14.102.0 netmask 255.255.255.0 HISADDR
 
   mary:
    add 203.14.103.0 netmask 255.255.255.0 HISADDR
</verb></tscreen> 

<sect3><heading>mgetty, AutoPPP, マイクロソフト拡張の詳細</heading>

<sect4><heading>Mgetty と AutoPPP<label id="userppp:mgetty">
       </heading>

<p>AUTO_PPP オプションつきでコンパイルした mgetty を使えば, mgetty が
   PPP 接続の LCP フェーズを検出して, 自動的に PPP シェルを起動するように
   設定することができます. 
   しかし この場合, デフォルトの login/password シーケンスは発生しないので, 
   ユーザの認証は PAP または CHAP を使っておこなう必要があります. 

<p>このセクションでは, ユーザ (あなた) が問題なく
   AUTO_PPP オプションつきの mgetty (v0.99beta またはそれ以降) の設定, 
   コンパイル, インストールができているものと仮定しています. 
 
<p><tt>/usr/local/etc/mgetty+sendfax/login.config</tt>ファイルが
   以下の行を含んでいることを確認してください: 
 
<tscreen><verb>
   /AutoPPP/ -     -       /etc/ppp/ppp-pap-dialup
</verb></tscreen>
 
<p>これにより, PPP 接続を検出したら mgetty が<tt>ppp-pap-dialup</tt>
   スクリプトを実行するようになります. 
 
<p><tt>/etc/ppp/ppp-pap-dialup</tt>という名前で, 以下のような内容のファイルを
   作成します (このファイルには実行可能属性をつけておく必要があります): 

<tscreen><verb>
   #!/bin/sh
   TTY=`tty`
   IDENT=`basename $TTY`
   exec /usr/sbin/ppp -direct pap$IDENT
</verb></tscreen>   

<p><tt>/etc/ttys</tt>で有効になっている各ダイアルアップ回線ごとに, 
   対応するエントリを一つ<tt>/etc/ppp/ppp.conf</tt>に作成します. 
   これは上で作成した定義と問題なく共存できるでしょう. 

<tscreen><verb>
   papttyd0:
    enable pap
    set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
    enable proxy

   papttyd1:
    enable pap
    set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
    enable proxy
</verb></tscreen>

<p>この方法でログインする それぞれのユーザは, PAP によるユーザ認証を
   おこなうために<tt>/etc/ppp/ppp.secret</tt>ファイルにユーザ名とパスワードを
   書いておくか, または<tt>/etc/password</tt>ファイルを使うように, 

<tscreen><verb>
  enable passwdauth
</verb></tscreen>

   オプションを (/etc/ppp/ppp.conf に) 追加しておく必要があるでしょう. (*)

<p>(*) このオプションは 2.2-961014-SNAP および それ以降のシステムか, 
   または 2.1.x のシステムにおいて ppp のコードを更新している場合にだけ
   使用可能だということに注意してください. 
   (詳細に関しては, 以下のマイクロソフト拡張を参照してください) 

<sect4><heading>マイクロソフト拡張</heading>

<p>2.2-961014-SNAP 以降では, 
   DNS と NetBIOS ネームサーバの自動交渉 (negotiation) をサポートしている
   クライアント (例えば Win95/NT クライアント) との間で
   この機能を使うことができます. 
   プロトコルの詳細については RFC1877 を参照してください. 

<p>これらの拡張機能を<tt>/etc/ppp/ppp.conf</tt>ファイルで有効にした例を
   以下に示します. 

<tscreen><verb>
   default:
    set debug phase lcp chat
    set timeout 0
    enable msext
    set ns 203.14.100.1 203.14.100.2
    set nbns 203.14.100.5
</verb></tscreen>  

<p>これにより, クライアントはプライマリとセカンダリのネームサーバアドレス
   および NetBIOS ネームサーバホストを知ることができます. 

<sect2><heading>PAP および CHAP による認証<label id="userppp:PAPnCHAP">
       </heading>

<p>いくつかのプロバイダでは、PAP または CHAP のいずれかの認証メカニズムを
   使用して接続時の認証をおこなうようにシステムを設定しています. 
   この場合, プロバイダは接続の際に <tt>login:</tt> プロンプトを送信せず, 
   最初から PPP で通信を始めようとするでしょう. 

   PAP ではパスワードがそのまま送られてしまうため, CHAP に比べると安全性が
   低くなりますが, このパスワードはシリアル回線のみを通して送られます. 
   そのため, クラッカーが「盗み聞き」する余地は多くないので, 通常ここの
   セキュリティは問題にはなりません. 

   <ref id="userppp:staticIP" name="静的 IP アドレスによる PPP 接続">または
   <ref id="userppp:dynamicIP" name="動的 IP アドレスによる PPP 接続">の
   セクションに戻って, 以下の変更をおこないます: 

<tscreen><verb>
7       set login
.....
13      set authname MyUserName
14      set authname MyPassword
</verb></tscreen>

   これまでと同様に, 行番号は取り除いておいてください. 
   これは解説の際に参照する行を示すためにつけたものです. 
   なお, 少なくともスペース 1 個分の段づけ (インデント) が必要です. 

<descrip>
<tag/Line 7:/  PAP または CHAP を使用する場合, 通常 プロバイダはサーバへの
               ログインを必要としません. そのため, "set login" 文字列を
               無効にしておかなければいけません. 

<tag/Line 13:/ この行は PAP/CHAP ユーザ名を指定します. <tt>MyUserName</tt> に
               正しい値を入れておく必要があります. 
<tag/Line 14:/ この行は PAP/CHAP パスワードを指定します. <tt>MyPassword</tt> に
               正しい値を入れておく必要があります. 
               PAP と CHAP はデフォルトで受け付けられるようになっていますが, 
               PAP や CHAP を使用するという意思を明示するために, 
<tscreen><verb>
15      accept PAP
</verb></tscreen>
               または
<tscreen><verb>
15      accept CHAP
</verb></tscreen>
               という行を追加しておくのも良いでしょう. 
</descrip>

<p><bf>注:</bf>(<tt>set log +command</tt>で) コマンド記録をオンにしていると, 
   <tt>authkey</tt> も記録されてしまいます. ppp のログファイルの許可モードを
   決定する際には, このことに注意しておいてください. 

<sect2><heading>動作中の ppp の設定変更</heading>

<p>適切なパスワードさえ設定されていれば, バックグラウンドで動作している 
   ppp プログラムと通信することができます. 

<p>通常の設定では, ppp は 3000 + <tt>tunno</tt> 番の TCP ポートをモニタして
   コマンドを待ちうけます. ここで <tt>tunno</tt> は, その ppp が使用する 
   tun デバイスの番号です. 
   ただし, ローカルマシン用のパスワードが <tt>/etc/ppp/ppp.secret</tt> で
   設定されていなければ, その ppp サーバに接続することはできません. 
   パスワードを設定するためには, 以下の行を内容とするファイルを 
   <tt>/etc/ppp/ppp.secret</tt> として作成しておきます: 

<tscreen><verb>
foo MyPassword
</verb></tscreen>

   ここで <tt>foo</tt> はローカルのホスト名 (正しい名前を知るためには 
   <tt>hostname -s</tt> を実行してください) で, <tt>MyPassword</tt> は
   暗号化されていないパスワードそのものです. 
   <tt>/etc/ppp/ppp.secret</tt> は ID 0 のユーザ (root) 以外の誰からも
   アクセス可能であっては<bf>いけません</bf>. 
   つまり, <tt>/</tt>, <tt>/etc</tt> および <tt>/etc/ppp</tt> は
   書き込み可能であってはならず, また <tt>ppp.secret</tt> は 
   ID 0 のユーザ (root) に所有され, 許可モード 0600 であるべきです. 

<p>また, ppp が使用するポート番号を変更することや, TCP ソケットではなく
   ローカル UNIX ドメインのソケットをモニタするように指定することも可能です. 
   詳細に関しては, マニュアルページの <tt>set socket</tt> コマンドを
   参照してください. 

<p>一旦ソケットの設定が終了したら, スクリプト中で <tt>pppctl(8)</tt> を
   使用して, 動作中の ppp を操作することができるでしょう. 

<sect1><heading>システムの最終設定<label id="userppp:final">
       </heading>

<p>これで ppp の設定は終りました. 
   しかし ppp を動かす前に, まだ少し必要なことがあります. 
   それらの設定は, すべて<tt>/etc/rc.conf</tt>ファイルを
   編集することでおこないます. 
   (このファイルは以前には<tt>/etc/sysconfig</tt>と呼ばれていました) 

   このファイルを上から順に設定していきます. 
   まずは ``hostname='' の行が設定されていることを確認します. 
   例えば以下のように: 

<tscreen><verb>
   hostname=foo.bar.com
</verb></tscreen>

<p>もしプロバイダが静的な IP アドレスとホスト名を割り当てているのなら, 
   ホスト名としてそれを使うのが おそらくベストでしょう. 

<p>次に network_interfaces 変数を調べます. 必要に応じて (on demand) 
   プロバイダにダイアルするようにシステムを設定したい場合には, 
   tun0 デバイスがこのリストに追加されていることを確認しておきます. 
   それ以外の場合には, tun0 デバイスをリストから削除しておきます. 

<tscreen><verb>
   network_interfaces="lo0 tun0"
   ifconfig_tun0=
</verb></tscreen>

   <tt>ifconfig_tun0</tt>変数が空で, /etc/start_if.tun0 という名前の
   ファイルが作成されていなければならない ということに注意してください. 
   このファイルの内容は以下のようになります. 

<tscreen><verb>
   ppp -auto mysystem
</verb></tscreen>

   このスクリプトはネットワークの設定時に実行され, 
   ppp デーモンを自動モードで立ち上げます. 
   このマシンがもし LAN のゲートウェイであれば, 
   <tt>-alias</tt> スイッチも使用したいと思うかもしれません. 
   詳細に関しては, マニュアルページを参照してください. 


<p>以下のようにルータプログラムを ``NO'' に設定します. 

<tscreen><verb>
   router_enable=NO            (/etc/rc.conf)
   router=NO                   (/etc/sysconfig)
</verb></tscreen>

   <tt>routed</tt>は, ppp が作成したデフォルトのルーティングテーブル
   エントリを削除してしまう場合がありますので, 
   (初期設定では起動されるようになっている) <tt>routed</tt>デーモンが
   起動されないようにしておくことが重要です. 

<p>``sendmail_flags'' 行が ``-q'' オプションを含まないように
   設定しておいた方がよいでしょう. さもないと, sendmail が
   アドレスを調べようとして発信をおこなってしまう場合があります. 
   以下のような設定で良いでしょう: 

<tscreen><verb>
   sendmail_flags="-bd"
</verb></tscreen>

   この結果, PPP リンクを立ち上げた時には
   いつでも以下のコマンドを実行して, キューにたまっているメールを
   sendmail に送信させる作業が必要になるでしょう. 

<tscreen><verb>
   # /usr/sbin/sendmail -q
</verb></tscreen>

<p>ppp.linkup 中で <tt>!bg</tt> コマンドを使用することで, これを自動的に
   おこなうこともできます: 

<tscreen><verb>
1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m
</verb></tscreen>


<p>こうするのが嫌であれば, SMTP トラフィックをブロックするように
   "dfilter" を設定しておくこともできます. 
   詳細についてはサンプルファイルを参照してください. 

<p>後はマシンをリブートするだけです. 

<p>リブートが終ったら, 

<tscreen><verb>
   # ppp
</verb></tscreen>

   コマンドを実行し, 続いて PPP セッションを開始させるために
   ``dial provider'' と入力することもできますし, 
   (start_if.tun0 スクリプトを作成していない場合に), 
   外部へのトラフィックが発生した時に, ppp が自動的に
   セッションを確立してくれるようにしたいのであれば, 
   以下のコマンドを実行することもできます. 

<tscreen><verb>
   # ppp -auto provider
</verb></tscreen>

<sect1><heading>まとめ</heading>

<p>要約すると, 初めて ppp を設定する際には, 以下のステップが不可欠です: 

<p>クライアント側:

<itemize>
   <item>カーネルに tun デバイスが組み込まれていることを確認. 
   <item><tt>/dev</tt>ディレクトリに tunX デバイスファイルが
         存在することを確認. 
   <item><tt>/etc/ppp/ppp.conf</tt>にエントリを作成. 
         ほとんどのプロバイダでは, <tt>pmdemand</tt> の例で充分でしょう. 
   <item>動的 IP アドレスを使用するなら, <tt>/etc/ppp/ppp.linkup</tt>に
         エントリを作成. 
   <item><tt>/etc/rc.conf</tt> (または <tt>sysconfig</tt>) ファイルを更新. 
   <item>必要に応じてダイヤル (demand dialing) したいのであれば, 
         start_if.tun0 スクリプトを作成. 
</itemize>

<p>サーバ側:
<itemize>
   <item>カーネルに tun デバイスが組み込まれていることを確認. 
   <item><tt>/dev</tt>ディレクトリに tunX デバイスファイルが
         存在することを確認. 
   <item>(vipw(8) コマンドを使って) /etc/passwd にエントリを作成. 
   <item>このユーザのホームディレクトリに
         ``ppp -direct direct-server'' か何かを実行するプロファイルを作成. 
   <item><tt>/etc/ppp/ppp.conf</tt>にエントリを作成. 
         <tt>direct-server</tt>の例で充分でしょう. 
   <item><tt>/etc/ppp/ppp.linkup</tt>にエントリを作成. 
   <item><tt>/etc/rc.conf</tt> (または <tt>sysconfig</tt>) ファイルを更新. 
</itemize>

<sect1><heading>謝辞</heading>

<p>ハンドブックの このセクションは, 1997 年 9 月 7 日に &a.brian によって
   更新されました. 

<p>以下の人々による情報提供, 批評そして提案に感謝します: 

<p>&a.nik
<p>&a.dirkvangulik
<p>&a.pjc
