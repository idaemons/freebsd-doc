<!-- $Id: backups.sgml,v 1.1 1998-07-07 14:35:54 kuriyama Exp $ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.1 -->

<!--
<!DOCTYPE chapt PUBLIC "-//FreeBSD//DTD linuxdoc//EN"> -->
 
<chapt><heading>バックアップ<label id="backups"></heading>
<p><em>訳: &a.yoshiaki; . <newline> 5 July 1998. </em>

  <p>ハードウェアコンパチビリティの問題は現在のコンピュータ業界でもっ
  とも多く起きる種類の問題であり, FreeBSDもこれに無縁ではありません.
  市場にある驚くほど多様な種類の製品をサポートすることによって,
  FreeBSDは 安価に普及している PCハードウェアで動かすことができる
  という利点はこの点では不利でもあります.
  FreeBSDのサポートするハードウェアを徹底的に調べて提供することは不
  可能ですが, このセクションでは FreeBSDに含まれるデバイスドライバとそ
  のドライバがサポートするハードウェアのカタログを示します. 可能で適切
  なものについては特定の製品についての注釈を含めました. また,
  このハンドブックの <ref id="kernelconfig:config"
  name="コンフィグレーションファイル"> のセクションにも
  サポートされているデバイスのリストがありますのでそちらもご覧ください.

   FreeBSD はボランティアプロジェクトでテスト部門には資金がありません
   から, より多くの情報をこのカタログに載せるにはあなたがたユーザに
   頼らなければなりません.  あなた自身の経験により, あるハードウェアが
   FreeBSDで動くか動かないかがわかったとしたら&a.doc;
   へ e-mailして知らせてください. サポートされているハードウェアについて
   の質問は, &a.questions;(詳しいことは
   <ref id="eresources:mail" name="メーリングリスト">を参照してください) へ
   宛ててください. 情報を提供したり質問をする時は FreeBSDのバージョンと使っ
   ているハードウェアのできるだけ詳しい情報を含めることを忘れないでくだ
   さい.

  <sect><heading>* フロッピーへのバックアップはどうでしょう?</heading>
  <sect><heading> テープメディア</heading>
	<p>一般的なテープメディアには 4mm, 8mm, QIC, ミニカートリッジ 
DLT があります.

     <sect1><heading> 4mm (DDS: Digital Data Storage)
	 <label id="backups:tapebackups:4mm"></heading>
<!--gen-->
        <p>4mm テープはワークステーションのバックアップメディアとして
QICから置き換えられつつあります. この傾向は QICドライブの製造のリーダ
であった Archiveを Connerが買収し QICドライブの製造を中止したことで加
速しました. 4mmドライブは小型で静かですが 
8mmドライブの持っているような信頼性の評判はありません.
カートリッジは 8mmカートリッジよりも安価で小型 (3 x 2 x 0.5 インチ
; 76 x 51 x 12 mm) です. 4mmドライブ は 8mm同様にヘリカルスキャン (訳
注: VTRと同様の回転ヘッドを使う方式) を使用しているという理由でヘッド
の寿命は短いです.

<!--spec-->
        <p>これらのドライブのデータスループットは 150kB/s程度から最大
で500kB/s程度の範囲です. データ容量は 1.3GBから 2.0GBです. ハードウェア
圧縮が多くのドライブで可能で, およそ 2倍の容量になります. マルチドライ
ブテープライブラリユニットは1つの筐体に 6ドライブを持つことができ自動的
にテープを交換します. ライブラリの容量は 240GBに達します.
1つの例外です) 送りだしリールと巻き取りリールの両方がカートリッジの中
にあります.

<!--tech-->
        <p> 4mmドライブは 8mmドライブ同様にヘリカルスキャンを使います.
ヘリカルスキャンの利点と欠点は 4mmドライブ と 8mmドライブ共通です.

        <p>テープの寿命は 2000回のパスあるいは 100回のフルパックアップ
です.

     <sect1><heading> 8mm (Exabyte)<label id="backups:tapebackups:8mm">
	 </heading>

<!--gen-->
        <p>8mmテープは SCSIテープドライブとして最もよく使われているもの
で, データ交換用として最良の選択です. ほとんどのサイトには Exabyteの 
2GB 8mmテープドライブがあるでしょう (訳注: Unixワークステーションを何
台も置いているようなサイトには1台くらいはあるというような意味です).
8mmドライブは信頼性が高く, 使いやすく, 静かです. カートリッジは安価で
小型です (4.8 x3.3 x 0.6 インチ; 122 x 84 x 15 mm). 欠点は
, テープとヘッドの相対的な速度が高速なために比較的ヘッドとテープの寿命
が短いことです.

<!--spec-->
        <p>データスループットは 250kB/s程度から 500kB/s程度の範囲です.
データ容量は 300MBから 7GBです. ハードウェア圧縮が多くのドライブで可
能で,およそ 2倍の容量になります. 単一のユニットのドライブから, 1つの
筐体に6台のドライブと 120巻のテープを持ったマルチドライブ
テープライブラリまで利用することができます. ライブラリではテープは
ユニットにより自動的に交換されます. ライブラリの容量は 
840GB以上に達します.

<!--tech-->
        <p>データはヘリカルスキャンを使ってテープに記録されます.
ヘリカルスキャン方式ではヘッドはメディアに対してある傾き (約6度) に配
置されます.  テープはヘッドのある円筒の周の 270度にわたって接触します.
テープが円筒面を走行する間, 円筒は回転しています.
この結果,  高密度のデータのつまったトラックは, 狭い間隔でテープの上端と
下端の間を斜めに横切ります. 

     <sect1><heading> QIC<label id="backups:tapebackups:qic"></heading>
<!--gen-->
        <p>QIC-150テープとドライブはたぶん最も一般的に使われている
ドライブとメディアでしょう. QICテープドライブは現実的なバックアップ
ドライブとして少なくとも高価なものではありません. 
欠点はメディアのコストです. QICテープは 8mmや 4mmテープに比較して 
GBあたりのデータの保存で5倍ほど高価です. 
しかしあなたの必要とする量が半ダース程のテープで十分であれば, QICは正
しい選択となるかもしれません. QICは <em>最も</em>一般的なテープドライ
ブです. すべてのサイトに QICドライブのどれかの容量のものがあります.
問題は, QICは同じようなテープ (まったく同じ場合もある) に多様な記録密度
があることです. QICドライブは静かではありません. これらのドライブはデー
タ記録を開始する前に音をたててシークしますし, リード, ライト, シークの
時にはっきりと聞こえる音を出します.
 QICテープの大きさは (6 x 4 x 0.7 インチ;
152 x 102 x 17 mm).<ref id="backups:tapebackups:mini"
name="ミニカートリッジ">  で使われている 1/4インチ幅のテープについては
別に議論します. テープライブラリやチェンジャはありません.

<!--spec-->
        <p>データスループットは 150kB/sから 500kB/sの範囲です. データ容量
の範囲は 40MBから 15GBです. ハードウェア圧縮が最近の多くのドライブで使
えるようになっています. QICドライブは DATドライブに置き換えられつつあ
り, あまり頻繁には利用されなくなっています.

<!--tech-->
        <p>データは複数のトラックにわかれてテープに記録されます. 
トラックはテープメディアの長さ方向の一端からもう一方の端までです. 
(訳注: 1トラックの read/write が終わるとテープの走行方向を反転させ
次のトラックの read/write を行います)
トラックの数と, それに対応するトラックの幅はテープの容量によって
変わります. すべてではありませんがほとんどの最近のドライブは
少なくとも読み出しについては (場合によっては書き込みも) 
下位互換性があります.  QICはデータの安全性についてはよいと
いわれています (ヘリカルスキャンドライブに比べて機構は単純でより
丈夫です).

        <p>テープは 5000回のバックアップで寿命となるでしょう.


     <sect1><heading> * ミニカートリッジ<label id="backups:tapebackups:mini">
</heading>

     <sect1><heading> DLT<label id="backups:tapebackups:dlt"></heading>
<!--gen-->
        <p>DLTはここに示したドライブのタイプの中で最高速のデータ
転送レートです.
 1/2インチ (12.5mm) テープが単リールのカートリッジ (4 x 4 x 1 
インチ; 100 x 100 x 25 mm) に入っています. カートリッジのひとつの
側面全体がスイングゲートになっています. 
ドライブの機構がこのゲートを開け, テープ
リーダを引き出します.  テープリーダには楕円形の穴があり, ドライブ
がテープを引っ掛けるのに使います. 巻き取りのためのリールはドライブの中
にあります. ここに挙げた他のカートリッジはすべて (9トラックテープはただ
1つの例外です) 送りだしリールと巻き取りリールの両方がカートリッジの中
にあります.

<!--spec-->
        データスループットは約1.5MB/sで, 4mm, 8mm, QIC テープドライブ
の3倍です. データ容量は単一のドライブで 10GBから 20GBの範囲です.
マルチテープチェンジャ,マルチテープドライブ,5から 900巻のテープを1から
20ドライブで扱うマルチドライブテープライブラリがあり, 50GBから 9TBの容量が得
られます.

<!--tech-->
        データは (QICテープのように) テープの走行方向と並行に複数ある
トラックへ記録されます. 2つのトラックに同時書き込みを行います. 
Read/Writeヘッドの寿命は比較的長いと言えます.
 テープの走行が止まればヘッドとテープの間の相対運動はありません.

  <sect1><heading> 新品のテープを最初に使う場合</heading>
        <p>新品の完全な空テープを読もうとしたり書き込もうとすると処理
は失敗するでしょう. 次のようなコンソールメッセージが出るでしょう.
<tscreen><verb>
        st0(ncr1:4:0): NOT READY asc:4,1
        st0(ncr1:4:0):  Logical unit is in process of becoming ready
</verb></tscreen>

テープに識別ブロック (Identifire Block:block number 0) がありません.
QIC-525標準の採用されている QICテープドライブのすべてで識別ブロックをテー
プに書きます. 2つの解決方法があります.

        <p>(訳注: 方法1)<tt>mt fsf 1</tt> によってテープドライブは識別
	ブロックをテープに書きます.

        <p>(訳注: 方法2)フロントパネルのボタンを押してテープをとりだします.
        <p>再びテープを入れ,データをテープに <tt>dump(8)</tt>します.
        <p><tt>dump(8)</tt> はそのうちに <tt>DUMP: End of tape
detected</tt> と表示し, コンソールには <tt>HARDWARE FAILURE
info:280 asc:80,96</tt>と表示されるでしょう.
        <p> <tt>mt rewind</tt>を使ってテープを巻戻します.
        <p>この次からはテープの操作は成功するでしょう.

<sect><heading>バックアッププログラム<label id="backup:programs"></heading>
        <p>よく使われる3つのプログラムは<tt>dump(8)</tt>,
<tt>tar(1)</tt>, <tt>cpio(1)</tt>です.

     <sect1><heading> ダンプとリストア</heading>
<!--gen-->
        <p><tt>dump(8)</tt> と <tt>restore(8)</tt> は伝統的な Unixの
バックアッププログラムです. これらはドライブのファイルシステム上の
ファイル,リンク,ディレクトリをディスクブロックの集まりとして処理します.
<tt>dump(8)</tt>はデバイスやファイルシステム全体をバックアップし, 
一部分のバックアップや, <tt>ln(1)</tt>によるソフトリンクや他のファイル
システムをマウントを行った, 1つ以上のファイルシステムにまたがる
ディレクトリツリーのバックアップはできません.
<tt>dump(8)</tt>はファイルやディレクトリを構成するデータブロックを
テープに書くだけで, ファイルやディレクトリをテープに書くことはありません.
<tt>dump(8)</tt>には初期の ATT UNIXのバージョン 6 (1975年ごろ) に由来する
癖が残っています. デフォルトのパラメタは 9トラックテープ (6250 bpi) に
適したものになっていて現在の高密度メディア (最大 62,182 ftpi) に適して
いません. 現在のテープドライブの容量を有効に利用するため, デフォルト
値をコマンドラインで置き換えなければなりません.

        <p><tt>rdump(8)</tt> と <tt>rrestore(8)</tt> は他の
コンピュータに接続されているテープドライブにネットワーク経由で
バックアップをします.
どちらのプログラムもリモートテープドライブにアクセスするために
<tt>rcmd(3)</tt>と <tt>ruserok(3)</tt>に依存しています. このためユーザ
がバックアップを実行するためには <tt>rhosts</tt>によるリモートアクセス
が必要です. <p><tt>rdump(8)</tt> と <tt>rrestore(8)</tt>の引数は
リモートコンピュータに適切なものを用います.

<tt>rrestore(8)</tt>はリモートコンピュータから使うのに適しています.
(例えば FreeBSDコンピュータより komodoという名前の Sunに接続されている
Exabyteテープドライブへ 
<tt>/sbin/rdump
0dsbfu 54000 13000 126 komodo:/dev/nrst8 /dev/rsd0a 2>&amp;1</tt>
として <tt>rdump</tt>したような場合の restoreに使います)
警告: セキュリティは <tt>rhosts</tt>の管理にかかっています.
あなたの状況を注意深く調べてください.

     <sect1><heading> Tar</heading>
<!--gen-->
        <p><tt>tar(1)</tt> ATT Unix のバージョン 6 (1975ごろ) に
さかのぼる事ができます. <tt>tar(1)</tt>はファイルシステムと
協調して機能し, ファイルやディレクトリをテープに書きます. 
<tt>tar(1)</tt>は<tt>cpio(1)</tt>で使えるようなフルレンジのオプション
は持ちませんが <tt>cpio(1)</tt>で使うような奇妙なコマンドパイプライン
は必要ありません.

        <p>大部分の <tt>tar(1)</tt> にはネットワーク経由のバックアップの
機能はありませんが, FreeBSD で使用されている GNU の <tt>tar(1)</tt> は,
<tt>rdump</tt> とおなじ構文でリモートデバイスを扱うことができます.
komodo というホスト名の Sun に繋いである Exabyte のテープデバイスに対して
<tt>tar(1)</tt> を実行するには, 次のようにします.
<tt>/usr/bin/tar cf komodo:/dev/nrst8 . 2>&amp;1</tt>
リモートデバイスをサポートしていない tar を使用している場合は,
パイプラインと <tt>rsh(1)</tt>を使うことで, リモートテープデバイスに
データを送る事ができます. (コマンド使用例はまだです)

     <sect1><heading> Cpio</heading>
<!--gen-->
        <p><tt>cpio(1)</tt> は本来,  Unixファイルを磁気メディアで交換
するためのプログラムです.  <tt>cpio(1)</tt>はバイトスワッピング, 
多くの異なるアーカイブフォーマットの書き込みのオプション(それ以外にも
多数のオプションがあります)があり, パイプで他のプログラムにデータを
渡す事もできます. この最後に挙げた特徴により, <tt>cpio(1)</tt>は
インストールメディアについては優れた選択です. 
<tt>cpio(1)</tt>は<tt>STDIN</tt>からの入力でなければならず,
ディレクトリツリーの探索やファイルリストについての機能はありません. 
	<p><tt>cpio(1)</tt>はネットワーク経由のバックアップの機能はあ
りません. リモートテープドライブにはパイプラインと <tt>rsh(1)</tt>
を使って送る事ができます. (コマンド使用例はまだです)

     <sect1><heading> Pax</heading>
<!--gen-->

	<p><tt>pax(1)</tt> は <tt>tar</tt> と <tt>cpio</tt> に対する
	IEEE/POSIX の回答です. 長年の間, 様々なバージョンの <tt>tar</tt> や
	<tt>cpio</tt> は, 互いにわずかながら非互換性を有していました.
	各々をしらみ潰しに標準化する代わりに, POSIXは新しいアーカイブ
	ユーティリティを作ることにしました. <tt>pax</tt> は専用に
	開発された新しいフォーマットに加えて, いくつもの cpio や tar の
	フォーマットの読み書きに対応しようと試みています. コマンド群は
	<tt>tar</tt> よりも <tt>cpio</tt> の方にいくぶん似ています.


     <sect1><heading><label id="backups:programs:amanda"><htmlurl url="http://www.freebsd.org/ports/misc.html#amanda-2.4.0" name="Amanda"></heading>
        <p>Amanda (Advanced Maryland Network Disk Archiver) は単一の
プログラムではなくクライアント/サーバ型のバックアップシステムです. 
Amanda サーバは, Amandaクライアントであるネットワークでサーバに接続
された複数のコンピュータから一つのテープドライブへバックアップを
おこないます. 
このような場合の一般的な問題はいくつもの大容量のディスクからデータ
ディレクトリをテープにバックアップするには時間がかかりすぎてしまう
という事です.  Amanda はこの問題を解決します. Amandaは同時に複数の
ファイルシステムのバックアップをおこなう時に 「ホールディングディスク」
を使う事ができます.
Amandaの設定ファイルに書いたすべてのファイルシステムのフルバックアップを
特定の間隔でとるために「アーカイブセット」と呼ばれるテープグループを
作ります. これには夜間に作られるすべてのファイルシステムの増分 
(あるいは差分として) のバックアップも含みます.
障害の起きたファイルシステムの回復には最も新しいフルバックアップと
増分のバックアップが必要です.

        <p>設定ファイルでバックアップのコントロールと Amanda による
ネットワークトラフィック量を設定します. Amanda はデータをテープに
書くのにバックアッププログラムのいずれかを使うでしょう. 
Amandaはその一部分でもパッケージでも利用可能ですが, デフォルトでは
インストールされません. 

     <sect1><heading>何もしない</heading>
	<p>「何もしない」というのはコンピュータのプログラムでは
ありませんが, バックアップの戦略として最も広く採用されている物です. 
これには初期投資が必要ありません. したがわなければならない
バックアップスケジュールもありません. ただ何もしないだけです. 
もしデータに何かが起きたら, 苦笑いして耐えてください.

        <p>あなたにとって時間やデータの価値が少ないかあるいはまったくない
のであれば「何もしない」のはあなたのコンピュータに最も適した
バックアッププログラムでしょう. しかし注意してください. 
Unix は便利なツールです. 6ヶ月も使っていれば価値のあるファイルの山が
でき上がっているでしょう.

	<p>「何もしない」は <tt>/usr/obj</tt> やその他の, コンピュータに
よってつくり出されたディレクトリツリーについては適切な方法です. 一つの
例はこのハンドブックのファイルで, これらは <tt>SGML</tt>のファイルより
生成された物です. <tt>HTML</tt>ファイルのバックアップを作る必要は
ありません.  <tt>SGML</tt>のソースファイルは定期的にバックアップ
します. 

     <sect1><heading>どのバックアッププログラムが最適でしょう?</heading>
        <p><em>定期的に </em><tt>dump(8)</tt>しましょう. Elizabeth
D. Zwicky はここで検討したプログラムすべてについて拷問的なテストを
おこないました.  すべてのデータと Unixファイルシステムの状態すべてを
保存するには明らかに <tt>dump(8)</tt>でしょう.  Elizabethは大きく変化
に富んだ異常な状態 (いくつかはあまり異常でもない状態のものもあります)
 になっているファイルシステムで, それぞれのプログラムで
ファイルシステムのバックアップとリストアを行ってテストしました. 
特色のある状態には, ホールを持つファイル, ホールとヌルブロックを持つ
ファイル, 奇妙な文字をファイル名に持つファイル, 読み出し不可, 
書き込み不可のファイル, デバイスファイル, バックアップ中にファイルの
サイズを変更する, バックアップ中にファイルの作成/削除をおこなうなどが
あります. 彼女は1991年10月の LISA Vで結果の発表をしています.

  <sect2><heading>緊急時のリストア手順</heading>
     <sect3><heading> 災難の起きる前に</heading>
        <p>起き得るどのような災難に対しても以下の 4ステップだけが必要な
準備です.

        <p>ステップ 1では, ファイルシステムテーブル(<tt>/etc/fstab</tt>)
やブートメッセージで示されるすべてのディスクの disklabelをそれぞれ2コピー
づつプリント (<tt>例えば disklabel sd0 | lpr を実行します</tt>) します.

        <p>ステップ 2では, boot と fixitフロッピーにそのシステムの
すべてのデバイスドライバが含まれているか確認します. 最も簡単な確認の
方法は, フロッピーをドライブに入れてリブートし, ブートメッセージを
確認することです. あなたのシステムのデバイスがすべて含まれ, 
機能していれば,  step 3へ飛んでください.

        <p>そうでないなら, そのシステムのすべてのディスクをマウントでき,
テープドライブにもアクセスできる 2種類のカスタムブート
フロッピーディスクを作る必要があります. これらのフロッピーには 
<tt>fdisk(8)</tt>,
<tt>disklabel(8)</tt>, <tt>newfs(8)</tt>, <tt>mount(8)</tt>, と利用したい
バックアッププログラムが入っていなければなりません. これらのプログラム
はスタティックリンクされたプログラムである必要があります.
<tt>dump(8)</tt>を使うのであればフロッピーに <tt>restore(8)</tt>を
入れる必要があります. 

	<p>ステップ 3では, 通常の方法でバックアップを作ります. 
最新のバックアップの後でおこなわれた変更は回復することはできません. 
バックアップテープにライトプロテクトをしてください.

        <p>ステップ 4では, フロッピー (boot.flp と fixit.flp あるいは
ステップ 2で作った2枚のカスタムブートフロッピーディスクです) と
バックアップテープのテストをします.
 手順のノートを作りましょう. このノートはブートフロッピーディスク,
バックアップテープに入れておきプリントアウトしておきます. あなたが
リストアをおこなうような時はおそらく錯乱状態でしょうからこのノートは
バックアップを破壊してしまうようなことを防ぐのに役立つでしょう
 (どのようにして破壊するって?
<tt>tar xvf /dev/rst0</tt>とする替りに偶然 <tt>tar cvf /dev/rst0</tt> 
とタイプしてバックアップテープに上書きしてしまうかもしれません).

訳注: 上書きはライトプロテクトをしておけば防げますが, なんらかの原因で
プロテクトがはずれているかもしれません.
ちなみに訳者の経験から言えば上のようなミスタイプは結構起きます.

        <p>安全性を増すために, 毎回ブートフロッピーディスクを作り,
2巻のバックアップテープを取ります. 一方を離れた場所に保管します. 
離れた場所は同じ建物の地下室ではいけません. 世界貿易センタービルに
あった数多くの会社は苦い経験よりこの教訓を得ました.  
離れた場所とはコンピュータやディスクドライブからかなり離れていて
物理的に分離されていなければなりません.

        <p>ブートフロッピーディスクを作るスクリプトの一例
<tscreen><verb>
 #!/bin/sh
 #
 # create a restore floppy	リストアフロッピーの作成
 # 
 # format the floppy		フロッピーのフォーマット
 #
 PATH=/bin:/sbin:/usr/sbin:/usr/bin

 fdformat -q fd0
 if [ $? -ne 0 ]
 then
         echo "Bad floppy, please use a new one"
         exit 1
 fi

 # place boot blocks on the floppy フロッピーにブートブロックを書く
 #
 disklabel -w -B -b /usr/mdec/fdboot -s /usr/mdec/bootfd /dev/rfd0c fd1440

 #
 # newfs the one and only partition	ただ1つのパーティションを newfs
 #
 newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/rfd0a

 #
 # mount the new floppy		新しいフロッピーをマウント
 #
 mount /dev/fd0a /mnt

 #
 # create required directories	必要なディレクトリの作成
 #
 mkdir /mnt/dev
 mkdir /mnt/bin
 mkdir /mnt/sbin
 mkdir /mnt/etc
 mkdir /mnt/root
 mkdir /mnt/mnt                 # for the root partition
 mkdir /mnt/tmp
 mkdir /mnt/var

 #
 # populate the directories
 #
 # 				MINIカーネルがない場合は作ります
 if [ ! -x /sys/compile/MINI/kernel ]
 then
         cat << EOM
 The MINI kernel does not exist, please create one.
 Here is an example config file:
 # 				MINIカーネルの config fileの例
 # MINI -- A kernel to get FreeBSD on onto a disk.
 #
 machine                "i386"
 cpu            "I486_CPU"
 ident          MINI
 maxusers       5

 options                INET                    # needed for _tcp _icmpstat _ip
stat
                                         #            _udpstat _tcpstat _udb
 options                FFS                     #Berkeley Fast File System
 options                FAT_CURSOR              #block cursor in syscons or pcc
ons
 options                SCSI_DELAY=15           #Be pessimistic about Joe SCSI
device
 options                NCONS=2                 #1 virtual consoles
 options                USERCONFIG              #Allow user configuration with
-c XXX

 config         kernel  root on sd0 swap on sd0 and sd1 dumps on sd0

 controller     isa0
 controller     pci0

 controller     fdc0    at isa? port "IO_FD1" bio irq 6 drq 2 vector fdintr
 disk           fd0     at fdc0 drive 0

 controller     ncr0

 controller     scbus0

 device         sc0     at isa? port "IO_KBD" tty irq 1 vector scintr
 device         npx0    at isa? port "IO_NPX" irq 13 vector npxintr

 device         sd0
 device         sd1
 device         sd2

 device         st0

 pseudo-device  loop            # required by INET
 pseudo-device  gzip            # Exec gzipped a.out's
 EOM
         exit 1
 fi

 cp -f /sys/compile/MINI/kernel /mnt

 gzip -c -best /sbin/init > /mnt/sbin/init
 gzip -c -best /sbin/fsck > /mnt/sbin/fsck
 gzip -c -best /sbin/mount > /mnt/sbin/mount
 gzip -c -best /sbin/halt > /mnt/sbin/halt
 gzip -c -best /sbin/restore > /mnt/sbin/restore

 gzip -c -best /bin/sh > /mnt/bin/sh
 gzip -c -best /bin/sync > /mnt/bin/sync

 cp /root/.profile /mnt/root

 cp -f /dev/MAKEDEV /mnt/dev
 chmod 755 /mnt/dev/MAKEDEV

 chmod 500 /mnt/sbin/init
 chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
 chmod 555 /mnt/bin/sh /mnt/bin/sync
 chmod 6555 /mnt/sbin/restore

 #
 # create the devices nodes	デバイスノードを作る
 #
 cd /mnt/dev
 ./MAKEDEV std
 ./MAKEDEV sd0
 ./MAKEDEV sd1
 ./MAKEDEV sd2
 ./MAKEDEV st0
 ./MAKEDEV pty0
 cd /

 #
 # create minimum filesystem table  最小限のファイルシステムテーブル
 #
 cat > /mnt/etc/fstab <<EOM
 /dev/fd0a      /       ufs     rw 1 1
 EOM

 #
 # create minimum passwd file	最小限のパスワードファイル
 #
 cat > /mnt/etc/passwd <<EOM
 root:*:0:0:Charlie &:/root:/bin/sh
 EOM

 cat > /mnt/etc/master.passwd <<EOM
 root::0:0::0:0:Charlie &:/root:/bin/sh
 EOM

 chmod 600 /mnt/etc/master.passwd
 chmod 644 /mnt/etc/passwd
 /usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

 #
 # umount the floppy and inform the user	フロッピーを unmount
 #
 /sbin/umount /mnt
</verb></tscreen>

     <sect2><heading>災難の後に</heading>
        <p>重要な問題は, ハードウェアが生き残ったかどうかです.
定期的なバックアップを取っていればソフトウェアについて心配する必要はあ
りません.

        <p>ハードウェアがダメージを受けていたら, 最初にそのダメージを
受けた部品を交換してください.

        <p>ハードウェアに問題がなければ, フロッピーをチェックしてくださ
い.カスタムブートフロッピーディスクを使っているのであればシングルユーザ
("boot:"プロンプトの出た時に "-s" とタイプしてください) でブートしてくださ
い. それから次の「ファイルシステムを1つずつ回復する」を読んでください.

   <p>boot.flp と fixit.flp を使っているのであればこのまま読み続けてくださ
い. boot.flp を入れてブートしてください. 本来のインストールメニューが表
示されるはずです. (ここで) "fixit XXX"オプションを選びます. 指示の通り
fixit.flp を入れてください. <tt>restore</tt>とその他の必要なプログラムは
<tt>/mnt2/stand</tt>に置かれています.

        <p>ファイルシステムを一つずつ回復する

        <p>最初のディスクのrootパーティションを<tt>mount(8) (例えば mount
/dev/sd0a /mntのように) </tt>マウントして見てください. ディスクラベルが
破壊されている場合は <tt>disklabel(8)</tt>を使ってあらかじめプリントし
ておいた通りにパーティションを作り直しラベルをつけてセーブしてください.
<tt>newfs(8)</tt>を使いファイルシステムを作り直します. ルー
トパーティションを読み書き可能にマウント ("<tt>mount -u -o rw
/mnt</tt>") しなおします. バックアッププログラムとバックアップテープを
使ってこのファイルシステムのデータを回復します (例えば <tt>restore vrf
/dev/st0</tt>とします). ファイルシステムをアンマウント (<tt>umount 
/mnt</tt>など) して, 障害を受けたファイルシステムそれぞれについて繰り返
してください.

        <p>システムが動き出したら, 新しいテープにデータをバックアップ
してください. どのような理由で再び事故が起きたりデータが失われるかはわか
りません. これに時間を費す事で, 後々の災難から救われる事になります.

     <sect2><heading>* 災難対策をしていませんでした. どうしたらいいでしょう?</heading>
