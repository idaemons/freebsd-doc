<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.10
     $Id: chapter.sgml,v 1.1.1.1 1999-04-08 15:46:01 kuriyama Exp $
-->

<chapter id="serialcomms">
  <title>シリアル通信</title>

  <sect1 id="serial">
    <title>シリアル接続の基礎</title>

    <para><emphasis>Assembled from FAQ.</emphasis></para>

    <para>このセクションには,
      シリアルポートについての一般的な情報が書かれていま す.
      あなたが求めている情報が, もしここで見つからなかった場合には,
      ハン ドブックの端末とダイアルアップのセクションを見てください.
    </para>

    <para><filename>ttyd<replaceable>X</replaceable></filename>
      (または <filename>cuaa<replaceable>X</replaceable></filename>)
      デバイスは, アプリケーション上
      でシリアルポートをオープンする時に使用する,
      標準的なデバイスです.  プロセスがデバイスをオープンする際, 端末
      I/O 設定の デフォルトセットが使用されます.  これらの設定内容は,
      次のコマンドで確認することができます. </para>

    <screen>&prompt.root; <userinput>stty -a -f /dev/ttyd1</userinput></screen>

    <para>このデバイスの設定を変更した場合, その設定はデバイスが
      クローズされるまで有効です.  デバイスが再びオープンされる時,
      デフォルトの設定値に戻ります.
      デフォルトの設定を変更するためには,
      &ldquo;初期状態&rdquo;を設定した
      いデバイスをオープンして調節することができます.  例えば, ttyd5
      というデバイスに対して, デフォルトで <acronym>CLOCAL</acronym>
      モードを ON にして, 8 bits の設定をおこない,
      <emphasis>XON/XOFF</emphasis>
      フロー制御を行うように設定したい場合は,  次のようにします.
    </para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyid5 clocal cs8 ixon ixoff</userinput></screen>

    <para>このコマンドを記述するのに適しているファイルは,
      <filename>/etc/rc.serial</filename>   です.
      アプリケーションが<filename>ttyd5</filename>
      をオープンするときに,
      デフォルトでこの設定をおこなうようになります.  これらの設定は,
      好きなように変更することができます.</para>

    <para>また, &ldquo;固定状態&rdquo;のデバイスに調節を行うことで,
      ある一定の設定が
      アプリケーションに変更されることを防ぐこともできます. 例えば,
      <filename>ttyd5</filename> のスピードを 57600 bps
      に固定したい場合には,  次のようにします. </para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyld5 57600</userinput></screen>

	<para>これで, <filename>ttyd5</filename> をオープンして,
      シリアルポートの転送スピードを
      変更しようとするアプリケーションは 57600 bps
      に固定されるでしょう.</para>

    <para>本来, デバイスの初期状態を変更したり設定を固定するのは,
      <username>root</username> だけが行うべきです.
      <filename>MAKEDEV</filename>
      スクリプトがデバイスエントリを作成する時は,
      これをおこない<emphasis>ません</emphasis>.</para>
  </sect1>

  <sect1 id="term">
    <title>シリアル端末</title>

    <para><emphasis>原作:  &a.kelly;<!-- <br> -->
	28 July 1996</emphasis></para>

    <para><emphasis>訳: &a.max;</emphasis></para>

    <para>シリアル端末を利用することで,
      コンピュータのコンソールのそばにいないと きや,
      手近にネットワーク接続されているコンピュータがないときでも,
      FreeBSD の機能を便利に, かつ安価に利用することができます.
      ここでは, FreeBSD
      にシリアル端末を接続する方法を解説します.</para>

    <sect2 id="term-uses">
      <title>端末の種類と利用方法</title>

      <para>もともと Unix システムにはコンソールがありませんでした.
	ユー ザはコンピュータのシリアル
	ポートに接続された端末からログインして
	プログラムを利用していました.
	ちょうどモデムと通信ソフトを使ってリモート
	のコンピュータにログインし, テキスト
	ベースのプログラムを利用するのと よく似ています.</para>

      <para>最近の PC は,
	高品質の画像を表示できるコンソールを搭載していま すが,
	ほとんどすべての Unix 系 OS には未だにシリアル
	ポートを使ってログ インするための機能があり, FreeBSD
	でもこの機能がサポートされています.
	現在使用されていないシリアル
	ポートに端末を接続することでシステムに ログインし,
	通常はコンソールや Xウィンドウ システムの
	<command>xterm</command> のウィ ンドウ上で起動しているテキスト
	ベースのプログラムであれば何
	でも利用することができます.</para>

      <para>職場での利用ということで考えるならば, FreeBSD
	が動作しているコンピュー タに接続された何台ものシリアル端末を
	各社員の机に配置するというようなこ とが可能です. また,
	家庭での利用方法としては, 余っている古い IBM PC や  Macintosh
	を FreeBSD が動いているパワフルなコンピュータの端末として利
	用することができます. 普通ならシングルユーザのコンピュータを,
	パワフ
	ルなマルチユーザのシステムに変えることができるのです.</para>

      <para>FreeBSD では, 以下に挙げる3種類の端末が利用できます.</para>

      <itemizedlist>
	<listitem>
	  <para><link linkend="term-dumb">ダム (dumb) 端末</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-pcs">PCを利用した端末</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-x">X 端末</link></para>
	</listitem>
      </itemizedlist>

      <para>以下は, それぞれについての解説です.</para>

      <sect3 id="term-dumb">
	<title>ダム端末</title>

	<para>ダム端末は, シリアルライン経由でのコンピュータとの接続専
	  用のハードウェアです. ダム端末は,
	  テキストの送受信および表示ができる
	  程度の計算能力しかもっていないので, &ldquo;dumb&rdquo;
	  (間抜け) というように呼ば れています.
	  この端末上でプログラムを実行することはできません. テキスト
	  エディタ, コンパイラ, E-mail,
	  ゲームなどなどのプログラムを実行するのは,
	  ダム端末を接続しているコンピュータの方です.</para>

	<para>Digital Equipment社の VT-100 や, Wyse社の WY-75
	  を初めとして,  多くのメーカが何百種類もの
	  ダム端末を作っています. ほとんどどんな種 類のダム端末でも
	  FreeBSD に接続して使用できます. さらに, 高性能の端
	  末の中には画像を取り扱えるものもありますが,
	  限られた数のソフトウェア
	  パッケージしかこういった機能には対応していません.</para>

	<para>ダム端末は, X ウィンドウ システムで提供されるようなグラ
	  フィックアプリケーションを必要としない
	  職場で広く用いられています.</para>
      </sect3>

      <sect3 id="term-pcs">
	<title>PC を端末として利用する</title>

	<para><link linkend="term-dumb">ダム端末</link>
	  がテキストの表示およ
	  び送受信の機能をそなえただけのものならば, 言うまでもなく,
	  どんなPC もダム端末になり得ます.
	  必要なものは適切なケーブルと, そのPCの上
	  で動作する<emphasis>端末エミュレーション</emphasis>
	  を行うソフトウェアのみです.</para>

	<para>このような環境は, 家庭においてよく利用されます.
	  たとえば, あなたの同居 人が FreeBSD
	  のコンソールを専有している時などに, あまりパワーのないコ
	  ンピュータを FreeBSD システムにシリアル端末として接続し,
	  その端末上で
	  テキストだけを用いる作業をおこなうことができます.</para>
      </sect3>

      <sect3 id="term-x">
	<title>X 端末</title>

	<para>X 端末は, 既存のものの中で最も洗練された種類の端末といえ
	  ます. X 端末は, たいていの場合シリアル ポートではなく,
	  イーサネッ
	  トのようなネットワークを利用した接続をおこないます. また,
	  アプリケーション の利用においても,
	  テキストベースのものだけでなく, X アプリケーション
	  の利用が可能です.</para>

	<para>ここでは, 参考までに  端末について紹介しただけで, X 端
	  末の設定や利用についての解説は
	  <emphasis>おこないません</emphasis>.</para>
      </sect3>
    </sect2>

    <sect2 id="term-cables-ports">
      <title>ケーブルとポート</title>

      <para>シリアル端末を FreeBSD システムに接続するためには,
	適切なケー ブルと,
	端末を接続するためのシリアルポートが必要です. ここでは, これ
	らについて説明します. もし既にあなたの利用したい端末と,
	その端末 を接続するためのケーブルについてよく理解していれば,
	<link linkend="term-config">設定</link>
	の章まで読み飛ばしてください.</para>

      <sect3 id="term-cables">
	<title>ケーブル</title>

	<para>端末の接続は, シリアルポートを利用します. そこで, 端末を
	  FreeBSD システムに接続するためには, シリアルケーブル
	  (RS-232C ケーブ ルとも呼ばれています)
	  が必要となります.</para>

	<para>シリアルケーブルには2種類のケーブルがあります.
	  どちらの種類の ケーブルを使わなければいけないかは,
	  どんな端末を接続したいかによります.</para>

	<itemizedlist>
	  <listitem>
	    <para>もし, PC を端末として利用したい場合は,  <link
		linkend="term-null">ヌルモデム</link> ケーブル
	      (リバースケーブルもしくは
	      クロスケーブルと呼ばれることもしばしばあります)
	      を使用してください.  ヌルモデムケーブルは,
	      コンピュータ同士や端末同士を接続するために用い
	      られるケーブルです.</para>
	  </listitem>

	  <listitem>
	    <para>もし, 本物の端末を接続するのであれば, その端末につい
	      てきたドキュメントからどのようなケーブルを
	      使うべきか調べてください. も しドキュメントがない場合は,
	      まず <link linkend="term-null">ヌルモデム</link>
	      ケーブルを試してみて, うまくいかない場合は <link
		linkend="term-std">スタンダード</link> ケーブル
	      (しばしばストレートケーブルと呼 ばれます)
	      を試してみてください.</para>
	  </listitem>
	</itemizedlist>

	<para>また, 端末側と FreeBSD 側の <emphasis>両方の</emphasis>
	  シリア ポート の形状が,
	  あなたが使用しようとしているケーブルについているコネクタの形
	  状と一致していなければなりません.</para>

	<sect4 id="term-null">
	  <title>ヌルモデムケーブル</title>

	  <para>ヌルモデムケーブル (またはリバースケーブルあるいはクロ
	    スケーブル) は, たとえば &ldquo;signal ground&rdquo;
	    信号のように, いくつかの信 号はそのまま通しますが,
	    他の信号は途中で入れ替えて通します. たとえば, &ldquo;send
	    data&rdquo; 信号のピンは, 反対側のコネクタの
	    &ldquo;receive data&rdquo; 信号の
	    ピンと繋がっています.</para>

	  <para>自分で使うケーブルは自分で作りたいということであれば,
	    以下にター ミナルを接続する際に推奨される
	    ヌルモデムケーブルの結線を示しておきま す. この表では,
	    RS-232C の信号線の名前と,  DB-25 コネクタ上のピンの番
	    号を示しています.</para>

	  <informaltable frame="none">
	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry>Signal</entry>
		  <entry>Pin #</entry>
		  <entry></entry>
		  <entry>Pin #</entry>
		  <entry>Signal</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>TxD</entry>
		  <entry>2</entry>
		  <entry>connects to</entry>
		  <entry>3</entry>
		  <entry>RxD</entry>
		</row>

		<row>
		  <entry>RxD</entry>
		  <entry>3</entry>
		  <entry>connects to</entry>
		  <entry>2</entry>
		  <entry>TxD</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>connects to</entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DSR</entry>
		  <entry>6</entry>
		  <entry>connects to</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>

		<row>
		  <entry>SG</entry>
		  <entry>7</entry>
		  <entry>connects to</entry>
		  <entry>7</entry>
		  <entry>SG</entry>
		</row>

		<row>
		  <entry>DCD</entry>
		  <entry>8</entry>
		  <entry>connects to</entry>
		  <entry>4</entry>
		  <entry>RTS</entry>
		</row>

		<row>
		  <entry>RTS</entry>
		  <entry>4</entry>
		  <entry></entry>
		  <entry>5</entry>
		  <entry>CTS</entry>
		</row>

		<row>
		  <entry>CTS</entry>
		  <entry>5</entry>
		  <entry>connects to</entry>
		  <entry>8</entry>
		  <entry>DCD</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <note>
	    <para>DCD と RST では, コネクタ内部でピン4を5に接続し,
	      そして逆側のコネクタのピン8と接続します.</para>
	  </note>
	</sect4>

	<sect4 id="term-std">
	  <title>スタンダード RS-232C ケーブル</title>

	  <para>スタンダードシリアルケーブル
	    (またはストレートケーブル)  の場合は, すべての RS-232C
	    信号をそのまま通します. つまり, 片方の &ldquo;send
	    data&rdquo; 信号のピンは, 逆側の &ldquo;send data&rdquo;
	    信号のピンと繋がっています.  モデムを FreeBSD
	    に接続するときや, 一部の端末を接続するときにこのタイプの
	    ケーブルを使用します.</para>
	</sect4>
      </sect3>

      <sect3 id="term-ports">
	<title>ポート</title>

	<para>シリアルポートは,  FreeBSDが動作しているホスト
	  コンピュータと端
	  末の間でデータのやりとりを行うために用いるデバイスです.
	  ここでは,  現在存在するポートの種類と FreeBSD
	  でのポートのアクセス方法について解 説します.</para>

	<sect4 id="term-portkinds">
	  <title>ポートの種類</title>

	  <para>シリアルポートには何種類かのものがあります.
	    ケーブルを購 入したり自作したりする前に,
	    そのケーブルのコネクタの形状が端末および FreeBSD
	    システムのポートの形状と一致していることを
	    確認してください.</para>

	  <para>ほとんどの端末は DB25 ポートを搭載しています.
	    FreeBSDが動作しているも のを含めて, PCは DB25 または DB9
	    ポートを搭載しています. マルチポート
	    のシリアルカードの場合は, RJ-12 や RJ-45
	    のポートを搭載しているかもし れません.</para>

	  <para>利用されているポートの種類に関しては,
	    ハードウェアについてきたドキュメ ントを参照してください.
	    また, 多くの場合, ポートの形状から判断すること
	    もできるでしょう.</para>
	</sect4>

	<sect4 id="term-portnames">
	  <title>ポートの名前</title>

	  <para>FreeBSDでは,  <filename>/dev</filename>
	    ディレクトリ内のエントリを介
	    してシリアルポートへのアクセスがおこなわれます.
	    2種類の異なったエン トリがあります. </para>

	  <itemizedlist>
	    <listitem>
	      <para>着信用のポートの名前は, <filename>
		  /dev/ttyd<replaceable>x</replaceable></filename> (
		<replaceable>x</replaceable> は 0から始まるポート番号)
		となっています. 一般に端末の接続には
		着信用ポートを用います. 着信用のポートでは,
		シリアルラインのデータ キャリア検出 (DCD)
		信号がオンになっている必要があります.</para>
	    </listitem>

	    <listitem>
	      <para>発信用のポートの名前は, <filename>
		  /dev/cuaa<replaceable>x</replaceable></filename>
		となっています.
		発信用のポートは普通モデムの接続に用い, 端末の接続には
		利用しません. ただ,
		ケーブルまたは端末がキャリア検出信号を使えない
		タイプのものの場合は,
		発信用のポートを使うとよいでしょう.</para>
	    </listitem>
	  </itemizedlist>

	  <para>詳しくは, &man.sio.4;
	    のマニュアルをご覧ください.</para>

	      <para>たとえば, 端末を一つ目のシリアルポート (DOS
	    でいうところの <devicename>COM1</devicename>) に接
	    続したとすると,  <filename>/dev/ttyd0</filename>
	    がこの端末を指すことになります.  また,
	    二つ目のシリアルポート (<devicename>COM2</devicename>)
	    ならば <filename>/dev/ttyd1</filename> となり,
	    以下この形式のデバイスエントリを使います.</para>

	      <para>各シリアルポート,
	    特にマルチポートのシリアルカードを利用する ために, kernel
	    の設定をおこなう必要がある場合がありますので, 注意してくだ
	    さい. 詳しくは, <link linkend="kernelconfig">FreeBSD
	      カーネルのコンフィグレーション</link>
	    をご覧ください.</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2 id="term-config">
      <title>設定</title>

      <para>ここでは, 端末からのログインを可能にするために必要な
	FreeBSD  側の設定について解説します.
	既に端末を接続するポートが利用できるように  kernel
	の設定をおこない, 端末が接続されているものと考えて, 解説を進め
	ます.</para>

      <para>簡単に言えば, プロセス管理や初期化をおこなっている
	<command>init</command> プロセス に対して,
	ログイン名を読み込み <command>login</command>
	プログラムを起動している  <command>getty</command>
	を実行するように指示します.</para>

      <para>これをおこなうには,  <filename>/etc/ttys</filename>
	の内容を編集する必要があります.  まず,  <command>su</command>
	コマンドで root になって,  <filename>/etc/ttys</filename>
	に以下の 変更を加えてください.</para>

      <procedure>
	<step>
	  <para>端末を接続するポートの <filename>/dev</filename>
	    のエントリが含ま れている行がまだ存在しなければ, これを
	    <filename>/etc/ttys</filename> に追加してく ださい.</para>
	</step>

	<step>
	  <para><filename>/usr/libexec/getty</filename>
	    が対象となるポートに対して
	    実行されるように指定してください. また,
	    <filename>/etc/gettytab</filename> ファイ ル内の適切な
	    <replaceable>getty</replaceable>
	    タイプのエントリを指定してください.</para>
	</step>

	<step>
	  <para>デフォルトのターミナルタイプを指定してください.</para>
	</step>

	<step>
	  <para>対象となるポートを &ldquo;on&rdquo;
	    に設定してください.</para>
	</step>

	<step>
	  <para>そのポートが &ldquo;secure&rdquo;
	    であるかどうかを指定してください.</para>
	</step>

	<step>
	  <para><command>init</command> に
	    <filename>/etc/ttys</filename> を読み込みなおさせてく
	    ださい.</para>
	</step>
      </procedure>

      <para>また, 必要に応じて <filename>/etc/gettytab</filename>
	を変更し, 上の 2で使用する
	<replaceable>getty</replaceable> のエントリを追加してください.
	このドキュメントではこの方
	法については特に解説しませんので, &man.gettytab.5;
	および &man.getty.8; のマニュアルをご覧ください.</para>

	  <para>以下では, 上のステップについて詳しく解説します.
	実例を用いて, 何をす べきかを解説していきます.  Wyse-50 と,
	古い IBM の 286 マシン上で通信 ソフト Procomm を使って VT-100
	エミュレーションをおこなっているものを端
	末の例として紹介します. また,  Wyse は 2番目のポートに,
	286マシンは 6 番目のポート
	(マルチポートのシリアルカード上のポート) に接続します.</para>

      <para><filename>/etc/ttys</filename> について,
	より詳しくは, &man.ttys.5; のマニュアルをご覧
	ください.</para>

      <sect3 id="term-etcttys">
	<title><filename>/etc/ttys</filename> へのエントリの追加</title>

	<para>既にエントリがある場合を除いて, まず初めに
	  <filename>/etc/ttys</filename>
	  にエントリを追加しなければいけません.</para>

	<para><filename>/etc/ttys</filename> には,
	  FreeBSDシステム上のログインを許可するすべての
	  ポートを記述します. たとえば, 一つ目の仮想コンソール
	  <filename>ttyv0</filename> のエン
	  トリもこのファイルにあります. このエントリのおかげで,
	  コンソールからの ログインが可能になっています.
	  このファイルには, 他の仮想コンソール, シ
	  リアルポートおよび仮想端末のエントリも含まれています.
	  端末を接続する 場合は, そのポートの
	  <filename>/dev</filename> のエントリを,
	  <filename>/dev</filename> の部分
	  を省略して記述します.</para>

	<para>FreeBSD のインストール当初の状態では,
	  <filename>ttyd0</filename> から <filename>ttyd3</filename>
	  までの,  初めの四つのシリアルポートのエントリが
	  <filename>/etc/ttys</filename> に記述され ています.
	  これらのポートのいずれかに端末を接続する場合は, 新たなエント
	  リを追加する必要はありません.</para>

	<para>ここで紹介している例では,
	  既にファイルにエントリが存在する 2番目のシリ アルポート,
	  <filename>ttyd1</filename> に Wyse-50 を接続しています.
	  一方,  6番目のシ リアルポートに接続する
	  286マシン用のエントリは, 新たに追加してやらな
	  ければなりません. 以下に, エントリを追加した後の
	  <filename>/etc/ttys</filename> か ら抜粋して示します.
	</para>

	<programlisting>
ttyd1   "/usr/libexec/getty std.9600"   unknown off secure
ttyd5</programlisting>
      </sect3>

      <sect3 id="term-getty">
	<title><replaceable>getty</replaceable> タイプの指定</title>

	<para>次に,
	  端末からのログインを処理するプログラムの指定をおこな います.
	  FreeBSDでは, 標準的には
	  <filename>/usr/libexec/getty</filename> をこの目的
	  で利用しています. <prompt>login:</prompt>
	  プロンプトを送り出しているのは, このプロ グラムです.</para>

	<para><command>getty</command> プログラムは,
	  コマンドラインパラメータとして,
	  <replaceable>getty</replaceable> タイプをとります. ただし,
	  このパラメータは必須ではあ りません.
	  <replaceable>getty</replaceable> タイプは,
	  ボーレートやパリティといった, 接続され
	  た端末の特徴を表すものです.  <command>getty</command>
	  プログラムは, 与えられた  <replaceable>getty</replaceable>
	  タイプに対応したこれらの特徴を
	  <filename>/etc/gettytab</filename> から 読み込みます.</para>

	<para>ファイル <filename>/etc/gettytab</filename> には,
	  新旧の端末に関する多数のエントリ が記述されています.
	  ほとんどの場合,  <literal>std</literal>
	  という文字列で始まる名前 のエントリを使えば,
	  接続された端末に対してログインセッションを提供す
	  ることができます. これらのエントリを利用した場合,
	  パリティは無視されま す. 110 bps から 115200 bps
	  までのボーレートに対応した <literal>std</literal> のエン
	  トリがあります. 当然,
	  新たなエントリを追加することも可能です.
	  &man.gettytab.5; のマニュアルに,
	  さらに詳しく解説されています.</para>

	<para><filename>/etc/ttys</filename> の <emphasis
	    remap=tt>getty</emphasis> タイプの設定をする際は,
	  端末側の通信 パラメータの設定が,  <emphasis
	    remap=tt>getty</emphasis>
	  タイプのものと一致していることを確認し てください.</para>

	<para>紹介している実例では,  Wyse50 はパリティなし 38400 bps
	  で接続していま す. また,  286 マシンの方は, パリティなし
	  19200 bps の接続です. 以下は,
	  この段階でのこの二つの端末に関する
	  <filename>/etc/ttys</filename> の設定です. </para>

	<programlisting>
ttyd1   "/usr/libexec/getty std.38400"   unknown off secure
ttyd5   "/usr/libexec/getty std.19200"</programlisting>

	<para>ここで, 実行するプログラムを指定している
	  2番目のフィールドが, ダブルクォー
	  テーションに囲まれていることに注意してください.
	  こうしないと,   <command>getty</command> のタイプの指定が,
	  つぎのフィールドとして判断されてしまう可 能性があるので,
	  十分注意することが必要です.</para>
      </sect3>

      <sect3 id="term-deftermtype">
	<title>デフォルトのターミナルタイプの指定</title>

	<para><filename>/etc/ttys</filename> の 3番目のフィールドには,
	  そのポートのター ミナルタイプのデフォルトを指定します.
	  ダイアルアップ用のポートの場合 は,
	  ユーザがどのタイプの端末あるいは
	  通信ソフトを利用してダイアルアップ
	  してくるかは分からないので,  <literal>unknown</literal> や
	  <literal>dialup</literal> を記述するの が一般的です. 一方,
	  直結された端末の場合, ターミナルタイプが変わるこ
	  とはありませんから,
	  このフィールドには実際のターミナルタイプを記述し
	  ます.</para>

	<para>一般に, ユーザは <filename>.login</filename> や
	  <filename>.profile</filename> などのファイル内で
	  <command>tset</command> コマンドを使って,
	  ターミナルタイプをチェックし, 必要ならば
	  ターミナルタイプの入力を求めるプロンプトを
	  表示するようにします. この とき,
	  <filename>/etc/ttys</filename>
	  の中でターミナルタイプが指定されていれば,
	  このプロンプトを表示せずに先に進むことが可能です.</para>

	<para>FreeBSD 上で, どのターミナルタイプを利用できるかは,
	  <filename>/usr/share/misc/termcap</filename> をご覧ください.
	  このファイルには, お
	  よそ 600 のターミナルタイプが定義されています.
	  必要ならば, 新たなエン
	  トリを追加することも可能です. 詳しくは &man.termcap.5;
	  のマニュアルをご覧ください.</para>

	<para>紹介している例では,  Wyse-50 のターミナルタイプは
	  Wyse-50 です (もっ
	  とも他のタイプをエミュレートすることも可能ですが, ここでは
	  Wyse-50 モー ドで使用します. ). また,  286マシン上では
	  Procomm が VT-100 エミュレー
	  ションをおこなうように設定されています. 以下が, まだ未完成の
	  <filename>/etc/ttys</filename> の関連部分です. </para>

	<programlisting>
ttyd1   "/usr/libexec/getty std.38400"   wy50  off secure
ttyd5   "/usr/libexec/getty std.19200"	 vt100</programlisting>
      </sect3>

      <sect3 id="term-enable">
	<title>ポートを利用可能にする</title>

	<para><filename>/etc/ttys</filename> のつぎのフィールド,
	  つまり 4番目のフィー ルドは,
	  そのポートをアクティブにするかどうかの設定です.
	  このフィールド に <literal>on</literal> を指定すると,
	  <command>init</command> プロセスが2番目のフィールドに書かれ
	  たプログラム,  <command>getty</command> を実行し,
	  ログインのためのプロンプトを送り出 すようになります.
	  このフィールドに <literal>off</literal> を記述すると,
	  <command>getty</command>  は起動されず,
	  よってこのポートからのログインもできなくなります.</para>

	<para>ということで, 当然このフィールドには
	  <literal>on</literal> を指定します. 以下が
	  <filename>/etc/ttys</filename> です. それぞれのポートを
	  <literal>on</literal> にしました. </para>

	<programlisting>
ttyd1   "/usr/libexec/getty std.38400"   wy50  on secure
ttyd5   "/usr/libexec/getty std.19200"	 vt100 on</programlisting>
      </sect3>

      <sect3 id="term-secure">
	<title>``secure'' なポートの指定</title>

	<para>とうとう最後のフィールドの設定です.
	  (実際にはここでは触れ ませんが,
	  オプショナルな<literal>window</literal>
	  の設定のフィールドも存在するので,
	  ほぼ最後のフィールドといった方が正確かもしれません. )
	  最後のフィールド では,
	  そのポートが安全かどうかを指定します.</para>

	<para>ここで, &ldquo;安全&rdquo;
	  なポートとはどういうポートのことでしょう?</para>

	<para>これは,  root のアカウント (または, ユーザ ID が 0
	  のアカウント) がロ グインしてもよいポートということです.
	  安全でないポートでは,  root のロ
	  グインは許可されません.</para>

	<para>では, どのように安全なポートとそうでない
	  ポートを使えばよいでしょう?</para>

	<para>ポートを安全ではないとすることで,
	  そのポートに接続された端末からは,  root
	  のログインを禁止することができます. FreeBSDシステムの root
	  のパス ワードを知っている人は,
	  まず一般ユーザとしてログインしなければなりませ ん.
	  スーパユーザの特権を得るためには, そのうえで
	  <command>su</command> コマンドを
	  利用しなければいけません.</para>

	<!-- kuriyama - Eng ver has bare login -->
	<para>これによって,  root アカウントが不正に利用された場合に,
	  その経過を調査 する上で二つの記録を利用できるようになります.
	  <command>login</command> と  <command>su</command>
	  コマンドは, 共にシステムのログに記録を残します (また,
	  ログイン は <filename>wtmp</filename> にも記録を残します.
	  ).</para>

	<para>ポートを安全なものとして指定すると, その端末からの root
	  のログインが可 能になります. root
	  のパスワードを知っている人は, 単に root としてログ
	  インできます. この場合は, 当然ログインの記録や
	  <command>su</command> コマンドのログ は残りません.</para>

	<para>では, どちらを使うべきでしょうか?</para>

	<para>単純に &ldquo;insecure&rdquo; を使うのがよいでしょう.
	  公共の場所にある訳では<emphasis>な い</emphasis>端末や,
	  鍵のかかったドアの内側にある端末<emphasis>にも</emphasis>
	  &ldquo;insecure&rdquo; を指 定する方がよいでしょう.
	  スーパユーザの特権が必要な場合でも, ログイ ンして
	  <command>su</command> を実行するのは,
	  ごく簡単なことなんですから.</para>

	<para>以下に, ようやく完成した <filename>/etc/ttys</filename>
	  のエントリに端末の場所を表
	  すコメントを追加したものを示します. </para>

	<programlisting>
ttyd1   "/usr/libexec/getty std.38400"   wy50  on insecure # Kitchen
ttyd5   "/usr/libexec/getty std.19200"	 vt100 on insecure # Guest bathroom</programlisting>
      </sect3>

      <sect3 id="term-hup">
	<title><command>init</command> にファイル
	  <filename>/etc/ttys</filename> の再読み 込みをさせる</title>

	<para>FreeBSD をブートすると, 最初に起動されるプロセス,
	  <command>init</command>が  <filename>/etc/ttys</filename>
	  を読み込んで, 記述されているプログラムを利用可能な
	  ポートに対して実行し,
	  ログインプロンプトを送り出させます.</para>

	<para><filename>/etc/ttys</filename> の編集が終わった後,
	  <command>init</command> に変更を認識させるた めに, わざわざ
	  FreeBSD をブートしなおしたくはないでしょう. このような
	  場合のために,  <command>init</command> は,
	  <literal>SIGHUP</literal> (hangup) シグナルを受信すると,
	  <filename>/etc/ttys</filename>
	  を読み込みなおすようになっています.</para>

	<para><filename>/etc/ttys</filename> の変更を保存したら,
	  以下のようなコマンドを実行して,   <command>init</command>
	  に対して SIGHUP を送信します. </para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<para>(<command>init</command> プロセスのプロセス ID は
	  <emphasis>常に</emphasis> 1です. )</para>

	<para>すべての設定が正しくおこなわれ,
	  すべてのケーブルがただしく接続されてい て,
	  かつ端末の電源が入っていれば,
	  端末にはログインプロンプトが表示され ているはずです. これで,
	  これらの端末からの最初のログインの準備が完了で す!</para>
      </sect3>
    </sect2>

    <sect2 id="term-debug">
      <title>トラブルシューティング</title>

      <para>細心の注意を払って設定をおこなっても,
	ときには端末の接続がう まくいかない場合があるでしょう. 以下に,
	よく見られる問題とその解決方法 を示します.</para>

      <variablelist>
	<varlistentry><term>ログインプロンプトが表示されない</term>
	  <listitem>
	    <para>端末の電源が接続され,
	      スイッチが入っていることを確認してください. もし,  PC
	      を端末として利用している場合は,
	      通信ソフトが適切なシリアルポー
	      トを利用する設定になっているかどうか確かめてください.
	    </para>

	    <para>ケーブルがしっかりと端末と
	      FreeBSDが動作しているコンピュータの両方に接続され
	      ていることを確認してください. また,
	      正しい種類のケーブルを利用している
	      か確かめてください.</para>

	    <para>端末と FreeBSD
	      の間の通信速度とパリティの設定が一致していることを確認
	      してください.
	      出力をモニタに表示するタイプの端末の場合は, モニタ
	      のコントラストと明るさの設定を確認してください. また,
	      出力が印刷 されるタイプの端末の場合は,
	      紙とインクが十分にあるかどうかを確かめてく
	      ださい.</para>

	    <para><command>getty</command> が動いていて,
	      端末を認識していることを確認してください. 以
	      下のコマンドで動作中の <command>getty</command>
	      プロセスのリストを得ることができます.

	      <screen>&prompt.root; <userinput>ps -axww|grep getty</userinput></screen>

	      その端末に対する <command>getty</command>
	      の情報が表示されるはずです. たとえば, 以下
	      の表示例は,  <command>getty</command> は
	      2番目のシリアルポート (<literal>ttyd1</literal>) に対し
	      て <filename>/etc/gettytab</filename> 中の
	      <literal>std.38400</literal> のエントリを使って動作し
	      ているということを示しています. </para>

	    <screen>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1</screen>

	    <para>もし,  <command>getty</command>
	      プロセスが一つも動いていないようであれば,
	      <filename>/etc/ttys</filename> の中で,
	      そのポートを利用可能にする設定をしたかどう
	      か確かめてください. また,  <command>kill -HUP
		1</command> を確実に実行してください.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term>
	    ログインプロンプトの代わりにゴミが表示される</term>
	  <listitem>
	    <para>端末と FreeBSD
	      の間の通信速度およびパリティの設定が一致していることを確
	      かめてください. また,  <command>getty</command>
	      プロセスの情報を調べて, 適切な
	      <replaceable>getty</replaceable>
	      のタイプが使用されていることを確認してください. 間違った
	      <emphasis remap=tt>getty</emphasis>
	      タイプが使用されている場合は,
	      <filename>/etc/ttys</filename> を修正し てから,
	      <command>kill -HUP 1</command>
	      を実行してください.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term>文字が重複して表示される,
	    入力したパスワードが表示される</term>
	  <listitem>
	    <para>端末または通信ソフトの設定で, &ldquo;半二重 (half
	      duplex)&rdquo;あるいは&ldquo;ローカ
	      ルエコー&rdquo;となっているところを, &ldquo;全二重 (full
	      duplex)&rdquo;に変更してく ださい.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 id="dialup">
    <title>ダイアルインサービス</title>

    <para><emphasis>原作: &a.ghelmer;.</emphasis></para>

    <para><emphasis>訳: &a.max;.<!-- <br> -->
	6 September 1996.</emphasis></para>

    <para>このドキュメントでは, FreeBSD
      で外部からのモデムによるアクセスを受け付
      けるための設定に関してまとめてあります. このドキュメントは筆者が
      FreeBSD 1.0, 1.1 および 1.1.5.1 での経験と, 他の UNIX 系 OS
      での経験を 基に書いたものですが,
      必ずしも十分な内容でないかもしれませんし, 掲載し
      た実例もあなたが今お使いの環境とは一致しないかもしれません.
      また, 筆者 はこのドキュメントに従って行われた作業で
      データが失われたりシステムが破 壊されるようなことがあっても,
      一切責任をとれません.</para>

    <sect2 id="dialup-prereqs">
      <title>設定を始める前に</title>

      <para>筆者は, 読者が FreeBSD
	に関する基本的な知識をもっていることを仮定して
	このドキュメントをまとめました. まず, FreeBSD
	が既にインストールされ ていて, UNIX
	系環境においてファイルの編集の方法やシステムに付属のマニュ
	アルを参照する方法を知っている必要があります. また,
	以下に示すように,  FreeBSD
	の特定のバージョンが必要となりますし, いくつかの用語に関する
	知識,
	そしてモデムや多少の配線に関する知識も必要となります.</para>

      <sect3>
	<title>FreeBSD のバージョン</title>

	<para>まず, FreeBSD のバージョンは 1.1 以上を使用してください
	  (バージョン  2.x でもかまいません. ). FreeBSD 1.0 には,
	  2種類のシリアル ドライバ が含まれているので,
	  混乱の元となり得ます. また, FreeBSD のシリアル  ディバイス
	  ドライバ (<devicename>sio</devicename>) は,
	  バージョンを追う毎に改善されてき ていますので,
	  より新しいバージョンの FreeBSD を使用することで, よりよ い,
	  より効率の高いドライバを利用することができるはずです.</para>
      </sect3>

      <sect3>
	<title>用語解説</title>

	<para>以下, 簡単にいくつかの用語について解説しておきます.</para>

	<variablelist>
	  <varlistentry><term>bps</term>
	    <listitem>
	      <para>Bits per Second　の略で,
		データの転送速度を表す単位.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>DTE</term>
	    <listitem>
	      <para>Data Terminal Equipment の略.
		たとえばコンピュータ本体のこと.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>DCE</term>
	    <listitem>
	      <para>Data Communications Equipment の略で,
		具体的にはモデムのこと.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>RS-232</term>
	    <listitem>
	      <para>EIA (米電気産業協会)
		のハードウェア間シリアル通信の標準規 格.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>これらの用語やデータ通信一般に関して,
	  より詳しい情報が必要な場合は,  <emphasis>The RS-232
	    Bible</emphasis> という本 (誰か ISBN 分かる方いませんか?)
	  が参考 になると思います.</para>

	<para>通信においてのデータ転送速度に関して,
	  このドキュメントでは &ldquo;ボーレー ト&rdquo; (baud rate)
	  ではなく, &ldquo;bps&rdquo; (bits per second)
	  をその単位として 使うことにします. これは,
	  ボーというのは一定時間に生じる電気的状態の変
	  化の数を表す単位にすぎず, <emphasis remap=bf>bps</emphasis>
	  という単位の方が実体に即しているか らです. (少なくとも,
	  こういう表現をしておけば, 意地の悪い人に怒られる
	  こともないのではないかと思います. )</para>
      </sect3>

      <sect3>
	<title>外づけモデムと内蔵モデムについて</title>

	<para>ダイアルアップのサービスに関していえば,
	  外づけのモデムの方が適している ようです. これは,
	  多くの外づけのモデムは設定を不揮発ラムに書き込んで半
	  永久的に保存することができますし, また RS-232
	  に関する重要な情報を知る
	  ための点滅するライトによるインディケータが
	  搭載されているからです. 点滅 するライトは,
	  システムを見に来た訪問者に強い印象を与えるという効果だけ
	  でなく, モデムが適切に動作しているかどうかを知るためにも
	  有効です.</para>

	<para>一方, たいていの内蔵型のモデムには
	  不揮発性ラムが搭載されていないため,  ディップ
	  スイッチの変更以外に設定を保存する方法がありません. また, も
	  しインディケータがついていても, おそらくコンピュータのケース
	  カバーが 外されていなければその状態を確認するのは
	  難しいでしょう.</para>
      </sect3>

      <sect3>
	<title>モデムとケーブル</title>

	<para>以下のことに関して, 予め知っておく必要があります.</para>

	<itemizedlist>
	  <listitem>
	    <para>コンピュータとモデムの間での通信が
	      行えるようにするための接続方 法.
	      (内蔵型の場合は接続の必要はありません)</para>
	  </listitem>

	  <listitem>
	    <para>お使いのモデムのコマンドについての知識,
	      あるいはコマンドの解説 の在処</para>
	  </listitem>

	  <listitem>
	    <para>(通信ソフトを使っての)
	      モデムの不揮発ラムに保存可能な設定の変更 方法</para>
	  </listitem>
	</itemizedlist>

	<para>1番目のモデムの接続はたいてい簡単に行えるはずです.
	  ほとんどのストレー ト シリアル ケーブルが使えるでしょう.
	  使用すべきケーブルは, 両端に適 切なコネクタ (DB-25 または
	  DB-9 の雄または雌) のついた, DCE-DTE 間接 続用のもので,
	  以下の信号線が接続されていなければなりません.</para>

	<itemizedlist>
	  <listitem>
	    <para>Transmitted Data (<acronym>SD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Received Data (<acronym>RD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Request to Send (<acronym>RTS</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Clear to Send (<acronym>CTS</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Data Set Ready (<acronym>DSR</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Data Terminal Ready (<acronym>DTR</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Carrier Detect (<acronym>CD</acronym>)</para>
	  </listitem>

	  <listitem>
	    <para>Signal Ground (<acronym>SG</acronym>)</para>
	  </listitem>
	</itemizedlist>

	<para>FreeBSD で 2400bps 以上の転送速度を利用する場合には,
	  フロー制御のため に <acronym>RTS</acronym> 信号と
	  <acronym>CTS</acronym> 信号が必要です. また,
	  接続の確立と回線の切 断を検出するために
	  <acronym>CD</acronym> 信号を利用します. さらに,
	  <acronym>DTR</acronym> 信号を使っ
	  て回線切断後のモデムのリセットを行います. ケーブルの中には,
	  総ての必要 な信号線が接続されていないものもありますので,
	  たとえば, 回線切断後でも ログイン
	  セッションが残ってしまうといった問題が発生した場合などには,
	  ケーブルに問題がある可能性もあります.</para>

	<para>次に, お使いのモデムにもよりますが,
	  もしモデムのコマンドをよく覚えてい ない場合は,
	  モデムのマニュアルをすぐに参照できるようにしておいてくださ
	  い. このドキュメントでは例として USR Sportstar の 14,400 bps
	  の外づけ型 モデムのコマンドを示しておきます.
	  他の種類のモデムをお使いの場合も, 参
	  考になるかもしれません.</para>

	<para>最後に, FreeBSDで快適にモデムを使うためにも,
	  モデムの設定方法を知って おく必要があります. FreeBSD も他の
	  UNIX 系 OS と同様, 回線の接続およ
	  び切断の検出や回線の切断および回線切断後の
	  モデムの初期化にハードウェア  シグナルを利用します. FreeBSD
	  は, モデムに対するコマンドの送信やモデ
	  ムの状態の監視を行いません. パソコンで運用されている BBS
	  への接続に慣 れている方にとっては,
	  ちょっとめんどうかもしれませんね.</para>
      </sect3>

      <sect3>
	<title>シリアル インタフェースについて</title>

	<para>FreeBSD では, NS8250-, NS16450-, NS16550- および
	  NS16550A- に基づ いた EIA RS-232C (CCITT V.24)
	  規格のシリアル インタフェースをサポート しています. 8250
	  および 16450 ベースのディバイスには1文字のキャラクタ
	  バッファが搭載されています. また, 16550 系のディバイスには,
	  16文字分 のバッファが搭載されていて,
	  はるかによいパフォーマンスを得られます.  (ただし, 無印の
	  16550 では, バグがあって 16 文字バッファが利用できませ
	  んので, 可能であれば 16550A
	  系のディバイスを利用してください. ) 1文字 のバッファの物は,
	  16550 系のものと比べて OS にかける負荷が大きいので,  16550A
	  系ディバイスの利用を強く推奨します. 多数のシリアル
	  ポートを利 用する場合や, 負荷の高いシステムにおいては,
	  16550A 系ディバイスを使う ことで,
	  エラー発生率を低く押さえることができます.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>概要</title>

      <para>FreeBSD は以下の手順でモデムからのログインを受付ます.
	<command>init</command> から起 動された
	<command>getty</command> のプロセスが, 割り当てられたシリアル
	ポート (この 例では <filename>/dev/ttyd0</filename>)
	がオープンされるのを辛抱強く待ちます.  <command>ps
	  ax</command> コマンドを実行すると,
	以下のような出力が得られるはずです.</para>

      <screen> 4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0</screen>

      <para>ユーザがモデムに電話をかけ, モデム同士が接続されると,
	モデムの <acronym>CD</acronym> が検出されます. その結果,
	kernel がキャリア信号を検出して,  <command>getty</command>
	によるポートのオープンの処理が終了します.
	<command>getty</command> は,  <prompt>login:</prompt>
	プロンプトを指定されている初期回線速度で送信します.
	<command>getty</command> は,
	正常に文字列を受信できるかどうか監視し, 通常の設定では,
	もし以上な文字列を検出した場合 (理由としては,
	<command>getty</command> の速度とモデ
	ムの接続速度が異なっているような場合が考えられます. ),
	正常に文字列が 受信できるまで, <command>getty</command>
	は速度を変え続けます.</para>

      <para><command>getty</command> が正しい速度を検出すれば,
	ユーザに対して <prompt>login:</prompt> プロン
	プトが表示されるはずです. ユーザがログイン名を入力すると,
	<command>getty</command>  は
	<filename>/usr/bin/login</filename> を起動して,
	パスワードの入力を要求し, その
	後ユーザのシェルを起動します.</para>

      <para>それでは, 続いて設定についての解説です.</para>
    </sect2>

    <sect2>
      <title>kernel の設定</title>

      <para>通常, FreeBSD の kernel は, PC-DOS の世界で
	<devicename>COM1:</devicename>, <devicename>COM2:</devicename>
	, <devicename>COM3:</devicename> および
	<devicename>COM4:</devicename> と呼ばれる四つのシリアル ポートを
	探す
	ように設定されています. また, FreeBSD では, 現在のところ
	Boca の 1008
	や 2016 のような, 単純なマルチポートのシリアル
	インタフェースもサポー
	トしています. (マルチポートのシリアル ボードに関しての
	kernel の設定
	については, &man.sio.4; のマニュアルを参照してください. )
	デフォルト
	の kernel は, COM ポートだけを探します.</para>

      <para>搭載されているシリアル ポートのいずれかを, kernel
	が認識しているかどう か確認したい場合は, kernel
	起動時のメッセージを注意深く見ているか, あ るいは
	<command>/sbin/dmesg</command> コマンドを使って,
	ブート時の出力メッセージ を確認してください. 特に,
	<literal>sio</literal> で始まるメッセージをよく見てくださ い.
	参考までに, 以下のコマンドで <literal>sio</literal>
	という文字列を含むメッセージ
	だけを表示することができます.</para>

      <screen>&prompt.root; <userinput>/sbin/dmesg | grep 'sio'</userinput></screen>

      <para>たとえば, シリアル ポートを四つ持つシステムの場合は,
	以下のようなシリ アル ポートに関するメッセージが kernel
	によって表示されます.</para>

      <screen>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A</screen>

      <para>もし, kernel に正常に認識されないポートがある場合は,
	おそらくカスタマ イズした kernel
	を構築する必要があるでしょう.</para>

      <para>kernel 構築と構築のための設定に関しては, BSD System
	Manager's Manual の &ldquo;Building Berkeley Kernels with
	Config (config コマンドによる BSD kernel の構築) &rdquo;
	[ソース ファイルは <filename>/usr/src/share/doc/smm</filename>
	にあります]と &ldquo;FreeBSD Configuration Options&rdquo; [
	<filename>/sys/conf/options</filename> および <filename>
	  /sys/<replaceable>arch</replaceable>/conf/options.<replaceable>arch
	  </replaceable></filename> の  <emphasis>arch</emphasis>
	の部分をたとえば <filename>i386</filename> としたファイル ]
	を参照 してください.</para>

      <para>kernel の設定と構築をするためには, kernel のソース
	(FreeBSD 1.1 では <filename>srcdist/srcsys.??</filename>,
	FreeBSD 1.1.5.1 では  <filename>srcdist/sys.??</filename>,
	またFreeBSD 2.0 では総てのソース)を展開
	する必要があります.</para>

      <para>まだ自分のシステムの kernel 用のコンフィギュレーション
	ファイルを作っ ていない場合は,
	<filename>/sys/i386/conf</filename> に <command>cd</command>
	して作成してくださ い. 初めてコンフィギュレーション
	ファイルを作る場合は, まず <filename>GENERICAH</filename>
	(FreeBSD 1.x で BusTek の SCSI コントローラを使っている場合は
	<filename>GENERICBT</filename>) というファイルを,
	<filename>YOURSYS</filename> にコピーしてください. ここ で,
	<filename>YOURSYS</filename> はあなたのシステム名で,
	大文字である必要があります.  このファイルを編集して,
	ディバイスに関する記述を変更します.</para>

      <programlisting>
device		sio0	at isa? port "IO_COM1" tty irq 4 vector siointr
device		sio1	at isa? port "IO_COM2" tty irq 3 vector siointr
device		sio2	at isa? port "IO_COM3" tty irq 5 vector siointr
device		sio3	at isa? port "IO_COM4" tty irq 9 vector siointr</programlisting>

      <para>システムに搭載されていないディバイスに関する記述は,
	コメントアウトまた
	は削除してしまってかまいません.
	Boca の BB2016 のようなマルチポートの
	シリアル ボードをお持ちの場合は, &man.sio.4;
	のマニュアルを見て, マ
	ルチポートのボードのためのコンフィギュレーション
	ファイルの記述のし方
	に関して確認してください. ディバイスのフラグの
	指定方法がバージョンによっ
	て異なりますので, 別のバージョンの FreeBSD
	で利用していたコンフィギュ
	レーション ファイルを流用する場合には
	十分注意してください.</para>

      <note>
	<para>なお, <literal>port "IO_COM1"</literal>,
	  <literal>IO_COM2</literal>, <literal>IO_COM3</literal>
	  および  <literal>IO_COM4</literal> は,
	  それぞれのポートの一般的なアドレスである
	  <literal>0x3f8</literal>, <literal>0x2f8</literal>,
	  <literal>0x3e8</literal> および <literal>0x2e8</literal>
	  を表します. また, 割り込 み番号 4, 3, 5 と 9 は, それぞれ
	  <devicename>COM1:</devicename> から
	  <devicename>COM4:</devicename> のポー トで一般的に使用される
	  IRQ です. また, ISA バスのコンピュータの場合,
	  一般的なシリアルポートは複数のポートで一つの IRQ
	  を共有することが
	  <emphasis>できません</emphasis>ので注意が必要です.
	  (マルチポートのシリアル ボードの 場合は, 複数の 16550A
	  ベースのポートで一つまたは二つの IRQ を共有する
	  ための機構を備えています. )</para>
      </note>

      <para>コンフィギュレーション ファイルの編集が終わったら,
	&ldquo;Building Berkeley Kernels with Config (config
	コマンドによる BSD kernel の構築)&rdquo;  および
	  &man.config.8; のマニュアルにしたがって,
	<command>config</command> コマンド を使って kernel
	構築のためのディレクトリを作成した後, kernel の構築,
	インストールおよびテストを行ってください.</para>
    </sect2>

    <sect2>
      <title>ディバイス スペシャル ファイル</title>

      <para>kernel に組み込まれているほとんどのディバイスは,
	<filename>/dev</filename> ディレ クトリにある,
	&ldquo;ディバイス スペシャル
	ファイル&rdquo;を介してアクセスされ ます.
	<devicename>sio</devicename> ディバイスの場合は, 着信用の
	<filename>/dev/ttyd<replaceable>?</replaceable></filename>
	およ び, 発信用の
	<filename>/dev/cua0<replaceable>?</replaceable></filename>
	が利用されます. さらに, FreeBSD の 1.1.5 以降では,
	初期化ディバイス
	(<filename>/dev/ttyi<replaceable>?</replaceable></filename> と
	<filename>/dev/cuai0<replaceable>?</replaceable></filename>)
	およびロッキング ディバイス
	(<filename>/dev/ttyld<replaceable>?</replaceable></filename>
	と
	<filename>/dev/cual0<replaceable>?</replaceable></filename>)
	も合わせて利用されます. 初期化ディバイスは, 通信
	ポートがオープンされる度に,
	そのポートの初期設定を行うために使われます.  たとえば,
	<literal>CTS/RTS</literal>
	によるフロー制御を行うモデムが接続されてい る場合の
	<literal>crtscts</literal>
	などのパラメータの初期化が行われます. ロッキング
	ディバイスは, ポートの設定をロックし,
	他のユーザやプログラムにこれらを
	変更されることのないようにするために利用されます.
	通信ポートの設定, 初 期化とロックおよび設定の変更に関しては,
	それぞれ &man.termios.4;, &man.sio.4; と &man.stty.1;
	のマニュアルをご覧ください.</para>

      <sect3>
	<title>ディバイス スペシャル ファイルの作成</title>

	<para>ディバイス スペシャル ファイルの管理は, ディレクトリ
	  <filename>/dev</filename>
	  にあるシェル スクリプト <command>MAKEDEV</command>
	  によって行います. (FreeBSD
	  1.1.5 の &man.MAKEDEV.8; のマニュアルの <acronym>COM</acronym>
	  ポートに関する記述は,
	  かなりいい加減なので無視してください. )
	  <command>MAKEDEV</command> を使って,
	  <devicename>COM1:</devicename> (ポート 0)
	  をダイアルアップのポートとして利用するためのディ
	  バイス スペシャル ファイルを作るには,
	  <filename>/dev</filename> に <command>cd</command> して
	  から, <command>MAKEDEV ttyd0</command> と実行してください.
	  同様に, <command>MAKEDEV
	    ttyd1</command> とすることで, <devicename>COM2:</devicename>
	  (ポート 1)  用のディバイス スペシャル ファイル
	  を作成することができます.</para>

	<para><command>MAKEDEV</command> は,
	  <filename>/dev/ttyd<replaceable>?</replaceable></filename>
	  のディバイス ファイルだけでなく,
	  <filename>/dev/cua0<replaceable>?</replaceable></filename>
	  (および FreeBSD 1.1.5 以降では総ての初期化ディバイ
	  スとロッキング ディバイスのスペシャル ファイル)
	  も作成します. さらに,  もしシリアル端末用のスペシャル
	  ファイル
	  <filename>/dev/tty0<replaceable>?</replaceable></filename>
	  が存在すれ ば, それらの削除も行います.</para>

	<para>ディバイス スペシャル ファイルの作成後,
	  これらのファイルのパーミション が適切に設定されていて,
	  これらのディバイスを利用してもよいユーザのみが
	  読み書きできるようになっていることを確認してください. (特に
	  <filename>/dev/cua*</filename>
	  のパーミションには注意を払ってください. ) この確認 を怠ると,
	  一般のユーザがあなたのモデムを使うことができるようなことにな
	  りかねません. デフォルトの <filename>/dev/cua*</filename>
	  のパーミションは, 以下の ようになっていて,
	  たいていの場合適切なものだと思います.</para>

	<screen>crw-rw----    1 uucp     dialer    28, 129 Feb 15 14:38 /dev/cua01
crw-rw----    1 uucp     dialer    28, 161 Feb 15 14:38 /dev/cuai01
crw-rw----    1 uucp     dialer    28, 193 Feb 15 14:38 /dev/cual01</screen>

	<para>上の設定では, ユーザ <username>uucp</username> と,
	  グループ <username>dialer</username> に属するユーザ
	  が発信用のディバイスを利用できます.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>設定ファイル</title>

      <para>FreeBSD のシステムへのダイアル
	アップによるアクセスを実現するために編
	集が必要と思われる設定ファイルが, <filename>/etc</filename>
	ディレクトリに三つあ ります. まず,
	<filename>/etc/gettytab</filename> には,
	<filename>/usr/libexec/getty</filename>
	デーモンの設定を記述します. つぎに,
	<filename>/etc/ttys</filename> に保存されている情報から,
	<filename>/sbin/init</filename> はど の
	<filename>tty</filename> ディバイスに対して
	<command>getty</command> のプロセスを実行するべきか判
	断します. 最後に, お使いの FreeBSD が 1.1.5.1 以降のものならば
	<filename>/etc/rc.serial</filename> スクリプトに,
	それ以前のものならば  <filename>/etc/rc.local</filename>
	スクリプトにシリアル ポートの初期化のためのコマ
	ンドを記述することができます.</para>

      <para>UNIX にダイアル アップ モデムを接続する方法には,
	二つの考え方がありま す. 一つの方法は, ダイアル
	インしてくるユーザの接続速度に関係なく, 常
	にモデムとローカルのコンピュータの RS-232
	インタフェースの接続速度を一 定に保つように設定する方法です.
	この設定の長所は, ユーザがダイアル イ ンして接続されると,
	即座にシステムからのログイン プロンプトが送信され
	るということです. 短所は,
	システムが実際のモデム間の速度を知ることがで きないために,
	Emacs のようなフル スクリーンのプログラムが, 端末との接
	続速度が遅い場合でも,
	そのような場合に効果的な方法で画面出力を行わない
	点です.</para>

      <para>もう一つは, モデムの RS-232
	インタフェースとコンピュータの接続速度を,
	モデム間の接続速度に応じて変化させるような設定です. たとえば,
	モデム間 の接続が V.32bis (14.4 Kbps) ならば,
	モデムとコンピュータの間の接続を  19.2 Kbps とし,
	モデム間の接続が 2400 bps の時には, モデムとコンピュー タ間も
	2400 bps で接続するような設定をします. この場合,
	<command>getty</command> は,  モデムが返すリザルト
	コードからモデムとコンピュータの接続速度を認識す
	ることができませんので, <command>getty</command> は,
	まず初期速度で <prompt>login:</prompt> とい
	う文字列を送信して, それに対する応答の文字列を監視します.
	ここで, ユー ザ側の端末に無意味な文字列が表示された場合,
	ユーザは意味のある文字列を 受信するまで
	<literal>&lt;Enter&gt;</literal>
	キーを繰り返し押さなければならない
	ということを知っていると仮定しています.
	もし接続速度が間違っている場合, <command>getty</command> は,
	ユーザから送られた文字を無意味な文字列として扱い, 次の
	速度を試します. そして, ここで再度 <prompt>login:</prompt>
	プロンプトを送信します.
	この一連の動作が異常な回数繰り返されることも考えられますが,
	普通は1度 か2度のキー入力があれば,
	ユーザはまともなプロンプトを受信できます. こ
	のログインの動作が前者の固定速度による方法に
	比べて美しくないのは明らか ですが, この方法では,
	低速度で接続しているユーザに対するフル スクリー
	ンのプログラムからのレスポンスが改善されます.</para>

      <para>このドキュメントでは, 両方の設定方法について解説しますが,
	どちらかとい うとモデム間の速度に応じて RS-232
	インタフェースの速度が変化するような
	設定の方に偏った説明になってしまうと思います.</para>

      <sect3>
	<title><filename>/etc/gettytab</filename></title>

	<para><filename>/etc/gettytab</filename> は, &man.getty.8;
	  の設定ファイルで, &man.termcap.5;
	  と同様の形式で記述されます. ファイルのフォーマットや定
	  義できる機能についての詳細については, &man.gettytab.5;
	  のマニュアルを
	  ご覧ください.</para>

	<sect4>
	  <title>固定速度の設定</title>

	  <para>モデムとコンピュータ間の通信速度を固定して使う場合,
	    おそらく  <filename>/etc/gettytab</filename>
	    に特に変更を加える必要はないはずです.</para>
	</sect4>

	<sect4>
	  <title>可変速度の設定</title>

	  <para><command>getty</command>
	    が利用するモデムとコンピュータの接続速度に関する情報を
	    <filename>/etc/gettytab</filename>
	    に記述する必要があります. もし, 2400 bps のモ
	    デムをお使いになるのであれば, 既存の
	    <literal>D2400</literal> のエントリがそのまま利
	    用できるでしょう. このエントリは FreeBSD の 1.1.5.1 の
	    <filename>gettytab</filename>  には既に含まれていますので,
	    あなたの FreeBSD のバージョンでこのエント
	    リが存在しているのであれば,
	    新たに追加する必要はありません.</para>

	  <programlisting>
#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</programlisting>

	  <para>高速モデムをお使いの場合は, おそらく
	    <filename>/etc/gettytab</filename> に新たなエ
	    ントリを追加する必要があります. 以下の例は, 14.4 Kbps
	    のモデムを, 最 大インタフェース速度を 19.2 Kbps
	    として利用するためのエントリです.</para>

	  <programlisting>
#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

	  <para>上記の例を利用した場合, FreeBSD 1.1.5
	    以降ではパリティなし, 8ビットの 接続が行われます. FreeBSD
	    1.1 では, <literal>:np:</literal> パラメータをファイルの
	    先頭の
	    <literal>std.<replaceable>xxx</replaceable></literal>
	    のエントリに追加することで, パリティなし,
	    8ビットの接続が行われますが,
	    このパラメータを追加しなければ接続は偶数 パリティ,
	    7ビットになります.</para>

	  <para>上記の例では, まず 19.2 Kbps (V.32bis)
	    によるモデムとコンピュータ間の 接続を試み, 続いて 9600 bps
	    (V.32), 2400 bps, 1200 bps, 300 bpsと順に 試み, 再び 19.2
	    Kbps による接続を試みるという循環に入ります. この接続
	    速度の循環は, <literal>nx=</literal>(&ldquo;next
	    table&rdquo;) の機能で実現されています. ま た,
	    各行はそれぞれ <literal>tc=</literal>(&ldquo;table
	    continuation&rdquo;) の機能を使って,
	    その他の接続速度に依存した &ldquo;標準的な&rdquo;
	    設定を取り込んでいます.</para>

	  <para>もし, お使いのモデムが 28.8 Kbps であったり, 14.4 Kbps
	    の圧縮転送の機 能を有効に利用したい場合は, 19.2 Kbps
	    よりも速い速度を利用するように 設定する必要があります.
	    以下に 57.6 Kbps から接続を試みる
	    <filename>gettytab</filename>
	    の設定例を示しておきます.</para>

	  <programlisting>
#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

	  <para>もし, お使いの CPU が低速のものであったり, CPU
	    に対する負荷が高い場合 で, 16550A 系のシリアル
	    ポートをお使いでない場合, 57.6 Kbps の接続に おいて, sio
	    の &ldquo;silo&rdquo;
	    エラーが発生するかもしれません.</para>
	</sect4>
      </sect3>

      <sect3 id="dialup-ttys">
	<title><filename>/etc/ttys</filename></title>

	<para><filename>/etc/ttys</filename> には,
	  <command>init</command> が監視すべき <filename>tty</filename>
	  のリストを記<!-- kuriyama - filename? -->
	  述します. さらに, <filename>/etc/ttys</filename> は,
	  <command>login</command> に対してセキュリ
	  ティに関する情報を提供します. (ユーザ
	  <username>root</username> は, <literal>secure</literal> とマー
	  クされている <emphasis remap=tt>tty</emphasis>
	  のみからログインできます. ) 詳しくは
	  &man.ttys.5; のマニュアルをご覧ください.</para>
	<!-- kuriyama - remap=tt? -->

	<para><filename>/etc/ttys</filename> の既存の行を変更するか,
	  あるいは新しい行を追加して,  <command>init</command>
	  が自動的に新しいダイアル アップ サービス用のポートに対して
	  <command>getty</command>
	  プロセスを起動するようにしてください. 書式は, 固定速度の設
	  定か可変速度の設定かに関わらず, 以下のとおりです.</para>

	<programlisting>
ttyd0   "/usr/libexec/getty xxx"   dialup on</programlisting>

	<para>1番目の項目は, このエントリで対象とするディバイス
	  スペシャル ファイル です. 上の例では
	  <literal>ttyd0</literal> として,
	  <filename>/dev/ttyd0</filename> を <command>getty</command>
	  に監視させることを表しています. 2番目の項目
	  <literal>"/usr/libexec/getty
	    <replaceable>xxx</replaceable>"</literal>
	  (<replaceable>xxx</replaceable> は初期段階で使われる
	  <filename>gettytab</filename> のエントリ
	  に置き換えてください. ) が, <command>init</command>
	  がこのディバイスに対して起動する プロセスです. 3番目の
	  <literal>dialup</literal> は, デフォルトのターミナル
	  タイプで す. 4番目の <literal>on</literal> は,
	  この行が有効であることを <command>init</command> に対して示
	  しています. 5番目の項目に <literal>secure</literal>
	  を指定することもできますが, これ は,
	  たとえばシステムのコンソールのように,
	  物理的に安全な端末に対しての
	  み指定するようにしてください.</para>

	<para>デフォルトのターミナル タイプ (上記の例では
	  <literal>dialup</literal>) は, ローカル
	  のユーザの好みによって異なってきます. ユーザがログイン
	  スクリプトをカ スタマイズして, ターミナル タイプが
	  <literal>dialup</literal> の時には自動的に他のター ミナル
	  タイプを設定できるように, ダイアル
	  アップのポートのデフォルトの ターミナル タイプには
	  <literal>dialup</literal> が伝統的に用いられています.
	  しかし,  筆者のサイトでは, ほとんどのユーザが VT102
	  エミュレイションを使ってい るので, ダイアル
	  アップのポートのデフォルト ターミナル タイプとして
	  <literal>vt102</literal> を指定しています.</para>

	<para><filename>/etc/ttys</filename> の修正がすんだら,
	  以下のようなコマンドを使って
	  <command>init</command> プロセスに <acronym>HUP</acronym>
	  シグナルを送り, <filename>/etc/ttys</filename> を
	  読み込み直させてください.

	  <screen>&prompt.root; <userinput>kill -1 1</userinput></screen>

	  ただ, もし初めてシステムを設定しているのであれば,
	  モデムが適切に設定さ
	  れて接続されるまでは, <command>init</command>
	  に対してシグナルを送らない方がいいか
	  もしれません.</para>

	<sect4>
	  <title>固定速度の設定</title>

	  <para>速度を固定する設定では, <filename>/etc/ttys</filename>
	    の中で, <command>getty</command> に対し
	    て固定速度のエントリを指定する必要があります. たとえば,
	    以下の例はポー トのスピードが 19.2 Kbps
	    に固定されたモデムのための <filename>ttys</filename>
	    のエント リです.</para>

	  <programlisting>
ttyd0   "/usr/libexec/getty std.19200"   dialup on</programlisting>

	  <para>別の速度でモデムのポートのスピードを固定したい場合は,
	    <filename>/etc/gettytab</filename>
	    から適切なエントリを選んで, 上の例の
	    <literal>std.19200</literal> の部分を
	    <literal>std.<replaceable>speed</replaceable></literal>
	    として, 適切な速度のも のに置き換えてください.</para>
	</sect4>

	<sect4>
	  <title>可変速度の設定</title>

	  <para>可変速度の設定では, <filename>ttys</filename>
	    のエントリが, <filename>/etc/gettytab</filename>
	    の中の適切な &ldquo;自動速度調整&rdquo;
	    の初期設定のエントリを参照していなければな りません.
	    たとえば, もし前述の 19.2 Kbps
	    から接続を試みる可変速度の設 定例
	    (<literal>V19200</literal> の
	    <filename>gettytab</filename> エントリ)をそのまま
	    <emphasis remap=tt>ttys</emphasis> に追 加したのであれば,
	    <filename>ttys</filename>
	    エントリは以下のようになります.</para>

	  <programlisting>
ttyd0   "/usr/libexec/getty V19200"   dialup on</programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title><filename>/etc/rc.serial</filename> または
	  <filename>/etc/rc.local</filename></title>

	<para>V.32, V.32bis または V.34
	  モデムのような高速モデムを利用する場合, ハー ドウェア
	  (<filename>RTS/CTS</filename>)
	  フロー制御を行う必要があります. FreeBSD kernel のモデム
	  ポートにハードウェア フロー制御のフラグを設定するため の
	  <command>stty</command> コマンドを, FreeBSD 1.1.5.1 以降では
	  <filename>/etc/rc.serial</filename> に, FreeBSD 1.1 では
	  <filename>/etc/rc.local</filename> に 記述できます.</para>

	<para>たとえば, FreeBSD 1.1.5.1 の
	  <filename>/etc/rc.serial</filename> のサンプルは以下
	  のとおりです.</para>

	<programlisting>
#!/bin/sh
#
# Serial port initial configuration

stty -f /dev/ttyid1 crtscts
stty -f /dev/cuai01 crtscts</programlisting>

	<para>この例では, <literal>termio</literal> のフラグ
	  <literal>crtscts</literal> をシリアル ポート #1
	  (<devicename>COM2:</devicename>) のダイアル
	  インおよびダイアル アウトの初期化ディバイスに
	  設定しています.</para>

	<para>古い FreeBSD 1.1 では, 以下のエントリが
	  <literal>crtscts</literal> フラグを設定する ために
	  <filename>/etc/rc.local</filename>
	  に追加されていました.</para>

	<programlisting>
# Set serial ports to use RTS/CTS flow control
stty -f /dev/ttyd0 crtscts
stty -f /dev/ttyd1 crtscts
stty -f /dev/ttyd2 crtscts
stty -f /dev/ttyd3 crtscts</programlisting>

	<para>FreeBSD 1.1 には初期化のためのディバイス スペシャル
	  ファイルがないので,  ディバイス
	  ファイルそのものにフラグを設定して, その後はフラグをクリア
	  してしまうような極悪人が現れないことを願うしかありません.
	</para>
      </sect3>
    </sect2>

    <sect2>
      <title>モデムの設定</title>

      <para>もし, あなたのモデムがパラメータを不揮発ラムに
	保存できるタイプならば,  PC-DOS 上の Telix や FreeBSD 上の
	<command>tip</command> などのような通信プログラム を使って,
	パラメータを設定してください.  <command>getty</command>
	が利用する初期速度でモデムに接続して, 以下の条件を満たすよ
	うに不揮発ラムの設定を変更してください.</para>

      <itemizedlist>
	<listitem>
	  <para>接続時に <acronym>CD</acronym> 信号がオンになる</para>
	</listitem>

	<listitem>
	  <para>接続時に <acronym>DTR</acronym> がオンになり,
	    <abbrev>DTR</abbrev> オフで回線を切断しモ
	    デムをリセットする.</para>
	</listitem>

	<listitem>
	  <para>送信時フロー制御には <acronym>CTS</acronym> を利用.</para>
	</listitem>

	<listitem>
	  <para><acronym>XON/XOFF</acronym>
	    によるフロー制御を行わない.</para>
	</listitem>

	<listitem>
	  <para>受信時のフロー制御は <acronym>RTS</acronym> を使用.</para>
	</listitem>

	<listitem>
	  <para>Quiet mode (リザルト コードを返さない)</para>
	</listitem>

	<listitem>
	  <para>コマンド エコーを返さない.</para>
	</listitem>
      </itemizedlist>

      <para>これらを実現するためのコマンドやディップ
	スイッチの設定に関しては, モ
	デムのマニュアルを参照してください.</para>

      <para>以下に, USRobotics Sportster の 14,400 bps
	の外づけモデムの設定例を示 しておきます.</para>

      <programlisting>
ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>ことのついでに, たとえば, V42.bis や MNP5
	のデータ圧縮を使用するかど
	うかなどのモデムの他の設定について確認,
	調整しておくのもよいかもしれま せん.</para>

      <para>さらに, USRobotics Sportster の 14,400 bps
	の外づけモデムでは, 以下の ようなディップ
	スイッチの設定も必要です. 他のモデムをお使いの方も, 以
	下の例を設定の参考にしてください.</para>

      <itemizedlist>
	<listitem>
	  <para>スイッチ1: UP &mdash; DTR 標準</para>
	</listitem>

	<listitem>
	  <para>スイッチ2: 無視 (リザルト
	    コードを単語形式にするか数値形式にす るか)</para>
	</listitem>

	<listitem>
	  <para>スイッチ3: UP &mdash; リザルト コードを返さない</para>
	</listitem>

	<listitem>
	  <para>スイッチ4: DOWN &mdash; コマンド エコーを返さない</para>
	</listitem>

	<listitem>
	  <para>スイッチ5: UP &mdash; 自動着信</para>
	</listitem>

	<listitem>
	  <para>スイッチ6: UP &mdash; CD 標準</para>
	</listitem>

	<listitem>
	  <para>スイッチ7: UP &mdash;
	    不揮発ラムからデフォルト値をロードする</para>
	</listitem>

	<listitem>
	  <para>スイッチ8: 無視 (Smart Mode/Dumb Mode)</para>
	</listitem>
      </itemizedlist>

      <para>リザルト コードを返さないように設定しておかないと,
	<command>getty</command> が誤っ て <prompt>login:</prompt>
	プロンプトをコマンド モードのモデムに送信してしまった場 合に,
	モデムがこの入力をエコーしたり, この入力に対するリザルト
	コード を返してしまったりすることになります. この結果として,
	モデムと  <command>getty</command>
	の間で延々と無意味なやりとりが続いたというケースを聞いたこ
	とがあります.</para>

      <sect3>
	<title>固定速度の設定</title>

	<para>固定速度の設定では,
	  モデムとコンピュータ間の通信速度をモデムとモデム間
	  の接続速度に関係なく, 常に一定に保つように,
	  モデムを設定する必要があり ます. USRobotics Sportster の
	  14,400 bps 外づけモデムの場合, 以下のコ マンドで,
	  モデムとコンピュータ間の速度が, コマンド送信時の速度に固定さ
	  れます.</para>

	<programlisting>
ATZ
AT&amp;B1&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>可変速度の設定</title>

	<para>可変速度の設定では, シリアル ポートの速度が,
	  着信速度に応じて変化する ように設定しなければいけません.
	  USRobotics Sporster の 14,400 bps 外 づけモデムの場合,
	  以下のコマンドで, エラー訂正機能を利用した通信の場合 は,
	  コマンドを送信した時の通信速度にシリアル
	  ポートの速度を固定し, エ ラー訂正機能を利用しない接続では,
	  シリアル ポートの速度が変化するよう に設定されます.</para>

	<programlisting>
ATZ
AT&amp;B2&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>モデムの設定の確認</title>

	<para>ほとんどの高速モデムには,
	  現在の設定をある程度人間にも理解できる形式に
	  して表示させるコマンドがあります. USRobotics Sporster の
	  14,400 bps  外づけモデムの場合は, <command>ATI5</command>
	  コマンドで, 現在の不揮発ラムの設定を 表示することができます.
	  さらに, ディップ スイッチの設定も含めた現在の
	  設定を確認するためには, <command>ATZ</command>
	  コマンドを送信してから, <command>ATI4</command>
	  コマンドを送信してください.</para>

	<para>他のメーカーのモデムをお使いの場合は,
	  モデムのマニュアルで設定値の確認
	  方法を確認してください.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>トラブルシューティング</title>

      <para>以下の手順でダイアル アップ
	モデムの動作を確認することができます.</para>

      <sect3>
	<title>FreeBSD システムの動作確認</title>

	<para>モデムを FreeBSD システムに接続し,
	  システムをブートします. あなたのモ
	  デムにモデムの状態を確認するためのインジケータがあれば,
	  <acronym>DTR</acronym> のイ
	  ンジケータの状態に注目してください. もし,
	  システムのコンソールに  <prompt>login:</prompt>
	  プロンプトが表示された時に, <acronym>DTR</acronym>
	  のインジケータが点灯 すれば, FreeBSD が適切なポートに対して
	  <command>getty</command> を起動し, モデムへ
	  の着信を待っている状態であることを意味しています.</para>

	<para>もし <acronym>DTR</acronym>
	  のインジケータが点灯しない場合は, システムのコンソールか ら
	  FreeBSD にログインして, <command>ps ax</command> を実行し,
	  FreeBSD が 適切なポー トに対して<command>getty</command>
	  プロセスを起動しようとしているのかどうか確認して ください.
	  プロセスに関する情報の中に, 以下のような行が表示されるはずで
	  す.</para>

	<screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1</screen>

	<para>モデムにまだ着信がない状態の時に,
	  以下のように上とは異なる出力があった
	  場合, <command>getty</command> は既にモデム
	  ポートのオープンを終了したということに
	  なります.

	  <screen>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0</screen>

	  <command>getty</command> は, <acronym>CD</acronym>
	  (carrier detect) 信号がオンの状態になるまで,
	  ポートのオープンを完了することはできませんので,
	  この場合は接続に問題が
	  あるか, あるいはモデムの設定に問題があることが考えられます.
	</para>

	<para>もし, 適切なポートをオープンしようとしている
	  <command>getty</command> が見あたらない 場合は, 再度
	  <filename>/etc/ttys</filename> の内容を確認し,
	  書式などに誤りがないか 調べてみてください. また, ログ
	  ファイル <filename>/var/log/messages</filename> に
	  <command>init</command> および <command>getty</command>
	  から何か出力がないかどうかも確認してみてく ださい.
	  もし何かメッセージが記録されていたら, 再度
	  <filename>/etc/ttys</filename> ,
	  <filename>/etc/gettytab</filename> の二つの設定ファイルと,
	  ディバイス スペシャル  <!-- kuriyama - ? to replaceble -->
	  ファイル <filename>/dev/ttyd?</filename> を確認し,
	  記述に誤りがないか, 足りないエ ントリがないか,
	  足りないディバイス スペシャルファイルがないかといった
	  点について調べてみてください.</para>
      </sect3>

      <sect3>
	<title>モデムで接続してみる</title>

	<para>実際にモデムを使って別のコンピュータから
	  接続してみてください. この時,  8ビット, パリティなし,
	  1ストップ ビットで接続するようにしてください.
	  接続後すぐにプロンプトが返ってこない場合や,
	  無意味な文字列が表示される 場合は, 1秒に1回くらいの割合で
	  <literal>&lt;Enter&gt;</literal> キーを押してみて ください.
	  しばらくたって, なおも <prompt>login:</prompt>
	  プロンプトが現れない場合 は, <command>BREAK</command>
	  信号を送信してみてください. この時, 端末側で使って
	  いるモデムが高速モデムならば,
	  このモデムのインタフェースの接続速度を固 定してから,
	  再度ダイアル インしてみてください. (たとえば, USRobotics
	  Sportster の場合は, <command>AT&amp;B1</command>)</para>

	<para>それでもまだ <prompt>login:</prompt>
	  プロンプトが表示されない場合は,
	  <filename>/etc/gettytab</filename>
	  の以下の点について再度確認してみてください.</para>

	<itemizedlist>
	  <listitem>
	    <para><filename>/etc/ttys</filename> の対応する行の
	      2番目の項目で,  <filename>/etc/gettytab</filename>
	      の中で定義されているエントリが指定されているか</para>
	  </listitem>

	  <listitem>
	    <para>各 <literal>nx=</literal> で
	      <filename>/etc/gettytab</filename>
	      の中で定義されているもの が指定されているか</para>
	  </listitem>

	  <listitem>
	    <para>各 <literal>tc=</literal> で
	      <filename>/etc/gettytab</filename>
	      の中で定義されているもの が指定されているか</para>
	  </listitem>
	</itemizedlist>

	<para>もしダイアル インしても, FreeBSD
	  システム側のモデムが応答しない場合は,  FreeBSD 側のモデムが
	  <acronym>DTR</acronym>
	  がオンになった時に電話にでるように設定さ
	  れているかを確認してください.
	  もしモデムの設定に問題がなさそうならば,
	  モデムのインジケータ (がもしあれば) で,
	  <acronym>DTR</acronym> がオンになっているか
	  を確認してください.</para>

	<para>この確認のステップを数回繰り返しても
	  うまくいかない場合は, 一度休憩して,
	  しばらくたってから挑戦してみましょう. それでもだめなら,
	  おそらく &a.questions;
	  にあなたのモデムについての情報と問題を書いたメールを送れ ば,
	  メーリング
	  リストのメンバーが問題の解決を助けるべく努力してくれる
	  でしょう.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>謝辞</title>

      <para>以下の方々から,
	多くのコメントやアドバイスをいただきました. ここに謝意
	を表します.</para>

      <variablelist>
	<varlistentry><term>Sean Kelly</term>
	  <listitem>
	    <para>&lt;kelly@fsl.noaa.gov&gt; 多くのすばらしい助言をいた
	      だきました</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 id="dialout">
    <title>ダイアルアウトサービス</title>

    <para><emphasis>原作: FAQ からの情報</emphasis></para>

    <para><emphasis>訳: &a.jp.tmaruya;.<!-- <br> -->
	31 December 1996.</emphasis></para>

    <para>以下はモデムを利用して他のコンピュータと
      接続する方法を説明しています.
      これはリモートホストとターミナル接続を確立するための
      適切な方法です.</para>

    <para>これは BBS に接続するときによく使います.</para>

    <para>この種の接続は PPP 接続に問題がある場合, Internet
      上にあるファイルを 転送するのに非常に役に立ちます. FTP
      で何らかのファイルを転送したいのに  PPP
      接続を確立できない場合は, ファイルを FTP
      転送するためにターミナルセッション を利用します. そして ZMODEM
      を利用してファイルを転送します.</para>

    <sect2>
      <title><command>tip</command> や <command>cu</command>
	が実行できないはなぜ?</title>

      <para>あなたのシステムで <command>tip</command> や
	<command>cu</command> というプログラムは
	<username>uucp</username> や <username>dialer</username>
	というグループに所属しているユーザのみが
	実行できるようになっているのでしょう. リモートホストやモデムを
	利用できる <username>dialer</username>
	のグループにあなたのアカウントを 加えましょう.</para>

      <para>もしくは下記のコマンドを使うことによって, そのシステムで
	<command>tip</command> や <command>cu</command>
	を誰でも使えるようになります:</para>

      <screen>&prompt.root; <userinput>chmod 4511 /usr/bin/tip</userinput></screen>

      <para> このコマンドは <command>cu</command>
	に対しておこなう必要はありません, それは
	<command>cu</command> は <command>tip</command>
	に対するハードリンクだからです.</para>
    </sect2>

    <sect2>
      <title>私の Hayes モデムはサポートされていません,
	どうしよう?</title>

      <para>実際, <command>tip</command> の
	マニュアルページは古くなっています. 既に Hayes
	ダイアラが組み込まれています. <filename>/etc/remote</filename>
	ファイル中で <literal>at=hayes</literal>
	を使ってください.</para>

      <para>Hayes ドライバは, 最近のモデムの新しい機能である
	<literal>BUSY</literal>, <literal>NO DIALTONE</literal>,
	<literal>CONNECT 115200</literal>などのメッセージを
	認識できるほど賢くはなく, 単に混乱を起こすだけです.
	<command>tip</command>を使う場合には,
	(<command>ATX0&amp;W</command> とするなどして) これらの
	メッセージを表示させないようにしなくてはいけません.</para>

      <para>また, <command>tip</command> のダイアルのタイムアウトは
	60秒です. モデムの タイムアウト設定はそれより短くすべきであり,
	そうしないと  <command>tip</command>
	は通信に問題があると判断するでしょう.
	<command>ATS7=45&amp;W</command>  を実行してください.</para>

      <para>実際, デフォルトの <command>tip</command> は Hayes
	の完全なサポートを しているわけではありません. 解決方法は
	<filename>/usr/src/usr.bin/tip/tip</filename> の下の
	<filename>tipconf.h</filename>  を変更することです.
	もちろんこれにはソース配布ファイルが必要です.</para>

      <para><literal>#define HAYES 0</literal> と記述されている行を
	<literal>#define HAYES 1</literal> と変更し, そして
	<command>make</command>, <command>make install</command>
	を実行します.  これでうまく動作するでしょう.</para>
    </sect2>

    <sect2 id="direct-at">
      <title>これらの AT コマンドを入力するには?</title>

      <para><filename>/etc/remote</filename> ファイルの中で
	&ldquo;direct&rdquo; エントリを作ります.  たとえばモデムが
	1番目のシリアルポートである <filename>/dev/cuaa0</filename>
	に接続されている場合, 次のようにします:</para>

      <programlisting>
cuaa0:dv=/dev/cuaa0:br#19200:pa=none</programlisting>

      <para>モデムがサポートする最大の bps レートを br
	フィールドに使います.  そして <command>tip cuaa0</command>
	を実行すると, モデムが利用できるようになります.</para>

      <para><filename>/dev/cuaa0</filename>
	がシステムに存在しない場合は, 次のようにします:</para>

      <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>./MAKEDEV cuaa0</userinput></screen>

      <para>または root になって以下のように cu
	コマンドを実行します:</para>

      <screen>&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>

      <para><replaceable>line</replaceable>
	にはシリアルポートを指定します (例えば
	<filename>/dev/cuaa0</filename>).  そして
	<replaceable>speed</replaceable> には接続する速度を指定します
	(例えば <literal>57600</literal>).  その後 AT
	コマンドを実行したら, <command>~.</command>
	と入力すれば終了します.</para>
    </sect2>

    <sect2>
      <title>pn 機能の <literal>@</literal> 記号が使えません!</title>

      <para>電話番号 (pn) 機能の中での <literal>@</literal> 記号は,
	tip に <filename>/etc/phone</filename>
	にある電話番号を参照するように伝えます.  しかし
	<literal>@</literal> の文字は <filename>/etc/remote</filename>
	のような 設定ファイルの中では特殊文字となります.
	バックスラッシュを使ってエスケープをおこないます:</para>

      <programlisting>
pn=\@</programlisting>
    </sect2>

    <sect2>
      <title>コマンドラインから電話番号を指定するには?</title>

      <para>&ldquo;generic&rdquo; エントリと呼ばれるものを
	<filename>/etc/remote</filename> に追加します.
	例えば次のようにします:</para>

      <programlisting>
tip115200|Dial any phone number at 115200 bps:\
	    :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600bps:\
	    :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>そして </para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>のように利用できます.
	<command>tip</command> より <command>cu</command> を使いたい場合,
	<command>cu</command> の generic エントリを使います:

	<programlisting>
cu115200|Use cu to dial any number at 115200bps:\
	:dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:</programlisting>

	そして</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>

      <para> と実行します.</para>
    </sect2>

    <sect2>
      <title>毎回 bps レートを入力しなければいけませんか?</title>

      <para><literal>tip1200</literal> や <literal>cu1200</literal>
	用のエントリを記述し,  適切な通信速度を br
	フィールドに設定します.  <command>tip</command> は 1200 bps
	が正しいデフォルト値であるとみなすので,
	<literal>tip1200</literal> エントリを参照します. もちろん 1200
	bps  を使わなければならないわけではありません.</para>
    </sect2>

    <sect2>
      <title>ターミナルサーバを経由して
	複数のホストへアクセスしたいんです.</title>

      <para>毎回接続されるのを待って
	<command>CONNECT &lt;host&gt;</command> と入力する
	かわりに, tip の <literal>cm</literal> 機能を使います.
	例えば, <filename>/etc/remote</filename>
	に次のようなエントリを追加します:

	<programlisting>
pain|pain.deep13.com|Forrester's machine:\
	:cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
	:cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
	:dv=/dev/cua02:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

	これで, <command>tip pain</command> や
	<command>tip muffin</command> と実行すると
	pain や muffin のホストに接続することができ,
	<command>tip deep13</command>
	を実行するとターミナルサーバに接続します.</para>
    </sect2>

    <sect2>
      <title>tip を使ってそれぞれのサイトの
	複数の回線に接続できますか?</title>

      <para>これは大学に電話回線がいくつかあって
	数千人の学生が接続しようとする 場合によくある問題です.</para>

      <para>あなたの大学のエントリを <filename>/etc/remote</filename>
	ファイルに作成して,  <literal>pn</literal> のフィールドには
	<literal>@</literal> を使います:</para>

      <programlisting>
big-university:\
	:pn=\@:tc=dialout
dialout:\
	:dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:</programlisting>

      <para>そして <filename>/etc/phone</filename>
	ファイルに大学の電話番号の一覧を書きます:</para>

      <programlisting>
big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

      <para><command>tip</command> は一連の電話番号を試みて,
	最終的に接続できなければあきらめます.
	リトライを続けさせたい場合は, <command>tip</command> を while
	ループに入れて 実行します.</para>
    </sect2>

    <sect2>
      <title>CTRL+P を 1回送るために 2度押す必要があるのはなぜ?</title>

      <para>CTRL+P は通常 &ldquo;force (強制)&rdquo; 文字であり,
	<command>tip</command> に次の文字が
	リテラルデータであることを伝えます. force
	文字は&ldquo;変数の設定&rdquo; を意味する
	<command>~s</command>
	エスケープによって他の文字にすることができます.</para>

      <para><command>
	  ~sforce=<replaceable>single-char</replaceable></command>
	と入力して改行します.  <replaceable>single-char</replaceable>
	は, 任意の 1バイト文字です.
	<replaceable>single-char</replaceable> を省略すると NUL
	文字になり,  これは CTRL+2 や CTRL+SPACE
	を押しても入力できます.
	いくつかのターミナルサーバで使われているのを 見ただけですが,
	<replaceable>single-char</replaceable> に SHIFT+CTRL+6
	に割り当てるのもよいでしょう.</para>

      <para><filename>&#36;HOME/.tiprc</filename>
	に次のように定義することで,  任意の文字を force
	文字として利用できます:</para>

      <programlisting>
force=&lt;single-char&gt;</programlisting>
    </sect2>

    <sect2>
      <title>打ち込んだ文字が突然すべて大文字になりました??</title>

      <para>CTRL+A を押してしまい, caps-lock
	キーが壊れている場合のために設計された  <command>tip</command>
	の &ldquo;raise character&rdquo; モードに入ったのでしょう.
	既に述べたように <command>~s</command> を使って,
	<literal>raisechar</literal> をより適切な値に
	変更してください. もしこれら両方の機能を使用しないのであれば,
	force 文字と同じ設定にすることもできます.</para>

      <!-- kuriyama - file tiprc /file -->
      <para>以下は CTRL+2 や CTRL+A などを頻繁に使う必要のある Emacs
	ユーザにうってつけの. tiprc ファイルのサンプルです:</para>

      <programlisting>
force=^^
raisechar=^^</programlisting>

      <para>^^ は SHIFT+CTRL+6 です.</para>
    </sect2>

    <sect2>
      <title><command>tip</command> でファイルを転送するには?</title>

      <para>もし他の UNIX のシステムと接続しているなら,
	<command>~p</command>(put) や  <command>~t</command>(take)
	でファイルの送受信ができます. これらのコマンドは
	相手のシステムの上で <command>cat</command> や
	<command>echo</command> を実行することで 送受信をします.
	書式は以下のようになります:</para>

      <cmdsynopsis>
	<command>~p</command>
	<arg choice="plain">ローカルのファイル名</arg>
	<arg choice="opt">リモートのファイル名</arg>
      </cmdsynopsis>
      <cmdsynopsis>
	<command>~t</command>
	<arg choice="plain">リモートのファイル名</arg>
	<arg choice="opt">ローカルのファイル名</arg>
      </cmdsynopsis>

      <para>この方法ではエラーチェックをおこないませんので, zmodem
	などの他のプロトコルを使った方がよいでしょう.</para>
    </sect2>

    <sect2>
      <title><command>tip</command> から zmodem を実行するには?</title>

      <para>ファイルを受信するには,
	リモート側で送信プログラムを起動します.  そして <command>~C
	  rz</command> と入力すると, ローカル側へのファイルの受信が
	始まります.</para>

      <para>ファイルを送信するには,
	リモート側で受信プログラムを起動します.  そして <command>~C sz
	  <replaceable>files</replaceable></command> と入力すると,
	リモート側への ファイルの送信が始まります.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../handbook.sgml" "part" "chapter")
     End:
-->
