'\"
'\" Copyright (c) 1993 The Regents of the University of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" SCCS: @(#) tclsh.1 1.12 96/03/25 20:25:06
.\" jpman %Id: tclsh.1,v 1.2 1998/09/30 14:34:52 horikawa Stab %
'\" 
.so /usr/share/tmac/tcl.macros
.TH tclsh 1 "" Tcl "Tcl Applications"
.BS
'\" 下記の注を翻訳しても問題無い旨
'\" John.Ousterhout@Eng.Sun.COM (John Ousterhout) 氏より確認済
'\" (cf [man-jp 286]) 15 Aug 1997 <horikawa@jp.freebsd.org>
'\" Note:  do not modify the .SH NAME line immediately below!
.SH 名称
tclsh \- Tcl インタプリタを含むシンプルなシェル
.SH 書式
\fBtclsh\fR ?\fIfileName arg arg ...\fR?
.BE

.SH 解説
.PP
\fBtclsh\fR は標準入力あるいはファイルから Tcl コマンドを読み取って
評価する、シェル風のアプリケーションです。
引数なしで起動されると対話的に動作します。
すなわち、標準入力から Tcl コマンドを読み取り、
コマンドの結果とエラーメッセージを標準出力に出力します。
\fBtclsh\fR の実行は、\fBexit\fR コマンドが実行されるか、
あるいは標準入力で EOF が検出されるまで続きます。
もしユーザのホームディレクトリに \fB.tclshrc\fR というファイルが
存在すると、
\fBtclsh\fR は、標準入力から最初のコマンドを読み取る直前に、
ファイル \fB.tclshrc\fR を Tcl スクリプトとして評価します。

.SH スクリプトファイル
.PP
もし \fBtclsh\fR が引数付きで起動されると、
最初の引数がスクリプトファイル名となり、
残りの引数は変数としてスクリプトで利用可能になります (後述)。
\fBtclsh\fR は標準入力からコマンドを読む代わりに
指定されたファイルから Tcl コマンドを読み取り、
その終端に達すると終了します。
この場合 \fB.tclshrc\fR は自動的には評価されませんが、
必要ならスクリプトファイルの方でいつも \fBsource\fR することができます。
.PP
作成した Tcl スクリプトの先頭行が
.CS
\fB#!/usr/local/bin/tclsh\fR
.CE
のようになっていて、そのファイルに実行可能の印が付けられていれば、
そのスクリプトファイルをシェルから直接起動することができます。
ここでは \fBtclsh\fR がデフォルトディレクトリ /usr/local/bin に
インストールされていることを仮定しています。
もし別の場所にインストールされているのなら、
それに合わせて上の行を修正しなければなりません。
多くの UNIX システムでは、\fB#!\fR 行の長さは約 30 文字を越えられませんので、
\fBtclsh\fR の実行ファイルが短いパス名でアクセスできることを
確認しておいて下さい。
.PP
もっとよい方法は、スクリプトファイルの先頭 3 行を以下のようにすることです:
.CS
\fB#!/bin/sh
# 次の行で tclsh をリスタート \e
exec tclsh "$0" "$@"\fR
.CE
この方法には前節で示した方法に比べ、3 つの利点があります。
第 1 に、\fBtclsh\fR バイナリの位置をスクリプト中に直接記述する必要が
ありません。\fBtclsh\fR はシェルのサーチパス内のどこにあっても構いません。
第 2 に、前の方法で問題となったパス名 30 文字問題を回避しています。
第 3 に、この方法は \fBtclsh\fR 自体がシェルスクリプトであったとしても
動作します (複数アーキテクチャ/複数 OS を取り扱うためにこのような
方式をとっているシステムがあります。\fBtclsh\fR スクリプトが
いくつかのバイナリから一つを選んで実行するのです)。
この 3 行により、\fBsh\fR と \fBtclsh\fR の両方がスクリプトを処理する
ことになりますが、\fBexec\fR は \fBsh\fR によってのみ実行されます。
最初に \fBsh\fR がスクリプトを処理します。
\fBsh\fR は第 2 行をコメントとみなし、3 行目を実行します。
\fBexec\fR ステートメントがシェルの処理を中止させ、
それに代えて \fBtclsh\fR を起動します。
この \fBtclsh\fR がスクリプト全体を再処理します。
\fBtclsh\fR が起動すると、\fBtclsh\fR はこれら 3 行すべてをコメントと
みなします。2 行目の行末にあるバックスラッシュのせいで、
3 行目が 2 行目のコメントの一部として扱われるからです。

.SH 変数
.PP
\fBtclsh\fR は以下の Tcl 変数を設定します:
.TP 15
\fBargc\fR
\fIarg\fR 引数の数を保持します (もし一つもなければ 0)。
スクリプトファイルの名前は数えません。
.TP 15
\fBargv\fR
\fIarg\fR 引数を順に要素とする Tcl リストを保持します。
\fIarg\fR 引数がない場合は空文字列となります。
.TP 15
\fBargv0\fR
もし指定されていれば \fIfileName\fR を保持します。
そうでなければ、\fBtclsh\fR が起動された名前を保持します。
.TP 15
\fBtcl_interactive\fR
\fBtclsh\fR が対話的に実行されている (\fIfileName\fR 指定がなく
標準入力が端末風デバイスである) 場合は 1、
そうでなければ 0 を保持します。

.SH プロンプト
.PP
\fBtclsh\fR が対話的に起動されると、
コマンドの入力プロンプトとして普通、``\fB% \fR'' を表示します。
このプロンプトは、変数 \fBtcl_prompt1\fR および \fBtcl_prompt2\fR を
設定することで変更できます。
変数 \fBtcl_prompt1\fR が存在する場合、
それはプロンプトを出力する Tcl スクリプトから成っていなければなりません。
つまり \fBtclsh\fR はプロンプトを出力する代わりに \fBtcl_prompt1\fR を
評価します。
変数 \fBtcl_prompt2\fR は、改行を入力したが現在のコマンドがまだ完了していない
場合に、上と同様に用いられます。
もし \fBtcl_prompt2\fR が設定されていなければ、
不完全なコマンドに対してプロンプトは出力されません。

.SH キーワード
argument, interpreter, prompt, script file, shell
