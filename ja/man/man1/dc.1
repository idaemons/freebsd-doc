.TH DC 1 "07 Apr 1994" "GNU Project"
.\" jpman %Id: dc.1,v 1.4 1997/07/26 21:29:52 horikawa Stab %
.ds dc \fIdc\fP
.ds Dc \fIDc\fP
.SH 名称
dc \- 任意精度の計算機
.SH 書式
dc
.SH
解説
.PP
\*(dc は、逆ポーランド形式の無限精度の計算が行える卓上計算機です。
この電卓は、定義やマクロ呼び出しも行えます。
普通、 \*(dc  は標準入力から読み込みます。
コマンドライン引数が与えられた時は、それはファイル名となり、
\*(dc はそのファイルを読み込み、ファイルの内容を実行した後で、
標準入力から入力を取ります。
全ての正常な出力は標準出力へ送られます。
全てのエラー出力は標準出力へ送られます。
.PP
逆ポーランド記法計算機は、数をスタックに保存します。
数字を入力すると、それをスタックに積み上げます。
計算操作は、引数をスタックから取り出し、結果をスタックに積み上げます。
.PP
数字を
.IR dc 
に入力するためには、数字 (小数点が有っても構いません) を入力します。
指数表現はサポートされていません。
負の数字を入力するためには、 ``_'' で始まる数字を入力します。
``-'' は減算の二項演算子として使われているので、
このために利用することはできません。
引き続いて 2 つの数字を入力するためには、あいだに空白文字か改行文字を
入力します。
これらは、コマンドとしての意味はありません。
.PD
.SH
表示コマンド
.TP
.B p
スタックを変更することなく、スタックの先頭の値を表示します。
改行文字が、数値の後に表示されます。
.TP
.B P
スタックの先頭の値を表示し、スタックから取り出します。
改行文字は、後に表示されません。
.TP
.B f
変更することなく、
.ig
全てのレジスタの内容と
..
スタックの内容全部を表示します。
これは、忘れてしまった時に使ったり、あるコマンドがどのような効果を
もたらすのかを知りたい時には、良いコマンドです。
.PD
.SH
計算
.TP
.B +
二つの値をスタックから取り出し、加算を行い、結果をスタックに積みます。
結果の精度は、引数の値にだけによって決まり、十分正確です。
.TP
.B -
二つの値を取り出し、最初に取り出した値を 2 番目に取り出した値から
引きます。その後、結果をスタックに積みます。
.TP
.B *
二つの値を取り出し、かけ算を行い、結果をスタックに積みます。
結果の小数の桁数は、現在の精度値 ( 以下参照 ) によって制御され、
かけ算を行った値には依存しません。
.TP
.B /
二つの値を取り出し、最初に取り出した値を 2 番目に取り出した値で割り、
結果をスタックに積みます。
小数の桁数は、精度値によって指定されます。
.TP
.B %
二つの値を取り出し、
.B /
で計算された割算の余りを計算し、結果をスタックに積みます。
割算は、精度値で指定された小数の桁数で行われ、
余りも同じ小数の桁数で計算されます。
.TP
.B ^
二つの値を取り出し、最初に取り出した値を指数とし、
2 つめの値を底として指数計算します。
指数の小数点以下は無視されます。
精度値は、結果の小数の桁数を指定します。
.TP
.B v
一つの値を取り出し、自乗根を求め、結果をスタックに積みます。
精度値は、結果の小数の桁数を指定します。
.PP
ほとんどの演算子は、 ``精度値'' に影響を受けます。
``精度値'' は、
.B k
コマンドで設定することができます。
デフォルトの精度値はゼロです。これは、足し算と引き算を除く全ての算術は
整数値の結果を出すことを意味しています。
.PP
剰余演算
.B %
には、少し説明が必要です。
引数 ``a'' と ``b'' にて ``a - (b * (a / b))'' を計算しますが、
``a / b'' は現在の精度値に基づいて計算されます。
.SH
スタックの制御
.TP
.B c
スタックを消去し、空にします。
.TP
.B d
スタック先頭の値を複製し、スタックに積みます。
したがって、 ``4d*p'' は 4 の自乗を計算し、表示します。
.SH
レジスタ
.PP
\*(dc は、256 個のメモリレジスタを持っています。
各レジスタは、一文字の名前を持っています。
数字や文字列をレジスタに保存し、後で取り出すことができます。
.TP
.BI s r
スタックの先頭から値を取り出し、レジスタ
.IR r 
に保存します。
.TP
.BI l r
レジスタ
.I r
の値を複製し、それをスタックに積みます。
これは、
.IR r 
の内容を変更しません。
.PP
各レジスタは、それ自身のスタックを持っています。
現在のレジスタ値は、レジスタスタックの先頭です。
.TP
.BI S r
( メイン ) スタックの先頭の値を取り出し、レジスタ
.IR r 
のスタックにそれを積みます。
レジスタの以前の値は、アクセスできなくなります。
.TP
.BI L r
レジスタ
.IR r 
のスタックの先頭の値を取り出し、それをメインスタックに積みます。
レジスタ
.IR r 
のスタックにあった以前の値がもしあれば、
.BI l r
コマンドを使ってアクセス可能となります。
.ig
.PP
.B f
コマンドは、全ての内容が保存されているレジスタのリストを、
その内容ともに表示します。
各レジスタの現在の内容 ( つまりレジスタスタックの先頭 ) 
だけが表示されます。
..
.SH
パラメータ
.PP
\*(dc は、その操作を制御するための 3 つのパラメータを持っています:
精度と、入力の基数、出力の基数です。
精度は、ほとんどの算術操作の結果で保存される小数の桁数を指定します。
入力の基数は、入力された数字の解釈を制御します。
入力された全ての数字はこの基数をつかっているとされます。
出力の基数は、表示する数字で使われます。
.PP
入力と出力の基数は、分離されたパラメータです。
等しく設定しなくてもいいですが、これは便利だったり紛らわしかったりします。
入力の基数は 2 から 36 の範囲でなければなりません。
出力の基数は最低 2 でなければなりません。
精度はゼロ以上でなければなりません。
精度は、現在の入力基数や出力基数に関係なく、いつも 10 進の桁数で決められます。
.TP
.B i
スタックの先頭から値を取り出し、入力基数を設定するために使います。
.TP
.B o
スタックの先頭から値を取り出し、出力基数を設定するために使います。
.TP
.B k
スタックの先頭から値を取り出し、精度を設定するために使います。
.TP
.B I
現在の入力基数をスタックに積みます。
.TP
.B O
現在の出力基数をスタックに積みます。
.TP
.B K
現在の精度をスタックに積みます。
.SH
文字列
.PP
\*(dc は、数と同じように文字列を操作できます。
文字列に対してできる唯一のことは、それを表示し、マクロとして
実行することです。 
マクロとは、 \*(dc コマンドとして実行される文字列の内容のことです。
全てのレジスタとスタックは文字列を保存できます。
そして、 \*(dc はいつも、与えられたデータが文字列か数字かを
知っています。
算術操作のようないくつかのコマンドは、数を必要としており、
文字列が与えられた場合はエラーが表示されます。
他のコマンドは、数字か文字列を受け入れることができます。
例えば、
.B p
コマンドは、両方を受け付けることができ、データをその型に応じて
表示します。
.TP
.BI [ characters ]
(左右の釣合のとれた、
.B [
と
.B ]
で囲まれた
)
.I characters
という文字列を作り、それをスタックに積みます。
例えば、
.B [foo]P
は文字列
.B foo
を表示します (が、改行文字は表示しません)。
.TP
.B x
スタックから値を取り出し、マクロとして実行します。
普通、これは文字列です。数の場合は、単純にその値がスタックに
積み戻されます。
例えば、
.B [1p]x
は、マクロ
.B 1p
を実行します。
.B 1p
は、
.B 1
をスタックに積み、別の行に
.B 1
を表示します。
.PP
マクロは、しばしばレジスタにも保存されます。
.B [1p]sa
は、
.B 1
を表示するためのマクロを
レジスタ
.BR a 
に保存します。
.B lax
でこのマクロは実行できます。
.TP
.BI > r
スタックから 2 つの値を取り出し、それらを数と仮定して比較し、
もともとのスタックの先頭が大きい場合、レジスタ
.I r
の内容を実行します。
したがって、
.B 1 2>a
は、レジスタ
.BR a 
の内容を実行しますが、
.B 2 1>a
では実行しません。
.TP
.BI < r
似ていますが、もともとのスタックの先頭が小さい場合にマクロを実行します。
.TP
.BI = r
似ていますが、二つの取り出された値が等しい場合にマクロが実行されます。
.ig
これは、二つの文字列の等価性を比較するためにも使うことができます。
..
.TP
.B ?
端末から行を読み込み、実行します。
このコマンドは、ユーザからの入力を要求するためのマクロで使えます。
.TP
.B q
マクロを終了し、実行されたマクロからも終了します。
一番上のレベルか、一番上のレベルから直接呼ばれたマクロから呼ばれると、
.B q
コマンドは \*(dc を終了します。
.TP
.B Q
スタックから値を取り出し、それを終了すべきマクロレベル数として、
その数のマクロを終了します。
したがって、
.B 3Q
は、 3 つのレベルを終了します。
.B Q
コマンドでは、 \*(dc を終了することはありません。
.SH
状態の問い合わせ
.TP
.B Z
スタックから値を取り出し、その桁数 (文字列の場合は、文字数) を計算し、
その値をスタックに積みます。
.TP
.B X
スタックから値を取り出し、その小数点以下の桁数を計算し、
その値をスタックに積みます。文字列の場合、スタックには
.\" -1.
0
が積まれます。
.TP
.B z
現在のスタックの深さを、スタックに積みます。
スタックの深さとは、
.B z
コマンドが実行される前のスタックのデータ数です。
.SH
その他のさまざまなこと
.TP
.B !
与えられた行をシステムコマンドとして実行します ( シェルエスケープ ) 。
.\"(訳注)シェルエスケープは、訳者が付け足しました。
.\" 2.2.1R 対象(1997/05/04) Takeshi MUTOH <mutoh@info.nara-k.ac.jp>
.TP
.B #
与えられた行をコメントとして取り扱います。
.TP
.BI : r
スタックから 2 つの値を取り出します。
スタックの先頭から 2 番目だった値で配列
.IR r 
をインデックスし、スタックの先頭だった値をそこに保存します。
.TP
.BI ; r
スタックから値を取り出し、配列
.IR r 
のインデックスとして利用します。
配列から選ばれた値は、その後でスタックに積まれます。
.SH
注釈
.PP
配列操作
.B :
と
.B ;
は、普通
.IR bc 
の歴史的な実装だけで使われます
( GNU の
.I bc
は、自分でそれを含んでおり、 \*(dc を実行する必要はありません) 。
コメント操作
.B #
は、歴史的な
.IR dc 
の実装には含まれない、新しいコマンドです。
.SH
バグ
.PP
バグ報告は、
.BR bug-gnu-utils@prep.ai.mit.edu 
に電子メールでお願いします。
単語 ``dc'' を ``Subject:'' フィールドのどこかに入れておいてください。
.SH 歴史
.I dc
コマンドは、
Version 1 AT&T UNIX
から導入されました。
