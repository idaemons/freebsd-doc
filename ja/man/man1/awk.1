.\" jpman %Id: awk.1,v 1.3 1997/04/17 13:23:21 horikawa Stab %
.ds PX \s-1POSIX\s+1
.ds UX \s-1UNIX\s+1
.ds AN \s-1ANSI\s+1
.TH AWK 1 "Apr 18 1994" "Free Software Foundation" "Utility Commands"
.SH 名称
awk \- GNU awk パターン検索・処理言語
.SH 書式
.B awk
[ POSIX or GNU style options ]
.B \-f
.I program-file
[
.B \-\^\-
] file .\^.\^.
.br
.B awk
[ POSIX or GNU style options ]
[
.B \-\^\-
]
.I program-text
file .\^.\^.
.SH 解説
.I gawk
は GNU プロジェクトが実装した プログラミング言語 AWK の処理系です。
本処理系は \*(PX 1003.2 コマンド言語とユーティリティ規約に定められた
言語の定義に適合しています。
本バージョンはまた、Aho、Kernighan、Weinberger の著書『
.I The AWK Programming Language
』の記述にもとづいており、
System V Release 4 \*(UX の
.I awk
の付加機能も含んでいます。
.I gawk
はまた、GNU 独自の拡張も提供します。
.PP
コマンドラインは、
.I awk
へのオプション、(もし
.B \-f
または
.B \-\^\-file
オプションにより指定されていなければ)AWK のプログラムテキスト、そして
残りの引数列からなります。
この残りの引数列は、定義済み AWK 変数
.BR ARGC ,
.B ARGV
を用いることで参照できます。
.SH オプション
.PP
.I gawk
へのオプションは、伝統的な \*(PX 形式の一文字オプションと、GNU 形式の
ロングオプションがあります。
\*(PX 形式のオプションは単一の ``\-'' で始まり、一方 GNU 形式のもの
は ``\-\^\-'' で始まります。GNU 形式のロングオプションは GNU の独自仕様と 
\*(PX の必須仕様の両方について用意されています。
他の実装による AWK では、伝統的な一文字オプションのみを受け付けるものが
多いようです。
.PP
\*(PX 標準に従い、
.I awk
独自仕様のオプションは
.B \-W
オプションへの引数で与えます。
複数の
.B \-W
オプションを指定することもできますし、
複数の引数をコンマで区切って、もしくは引用符で括り空白で区切ることで
一度にまとめて
.B \-W
オプションに与えることもできます。
.B \-W
オプションへの引数では、大文字小文字の区別は行なわれません。後述の
ように、各
.B \-W
オプションには、それに対応する GNU 形式のロングオプション
が存在します。GNU 形式のロングオプションへの引数は、空白を入れずに
.B =
でつないで指定するか、その次のコマンドライン引数として渡すことができます。
.PP
.I gawk
は以下のオプションを受け付けます。
.TP
.PD 0
.BI \-F " fs"
.TP
.PD
.BI \-\^\-field-separator= fs
入力フィールドセパレータ(変数
.B FS
の値)を
.I fs
とします。
.TP
.PD 0
\fB\-v\fI var\fB\^=\^\fIval\fR
.TP
.PD
\fB\-\^\-assign=\fIvar\fB\^=\^\fIval\fR
プログラムを実行する前に、変数
.I var
に値
.I val
を設定します。このようにして設定
した変数は、 AWK プログラムの
.B BEGIN
ブロック内でも参照できます。
.TP
.PD 0
.BI \-f " program-file"
.TP
.PD
.BI \-\^\-file= program-file
.B awk
への第一引数を用いるかわりに、AWK プログラムをファイル 
.I program-file
から読み込みます。
.B \-f
(または
.B \-\^\-file
) オプションは複数回使
用することができます。
.TP
.PD 0
.BI \-mf= NNN
.TP
.BI \-mr= NNN
さまざまなメモリの制限値を
.I NNN
に設定します。フラグ
.B f
は最大フィールド数、フラグ
.B r
は最大レコードサイズを設定します。この2つのフラグと
.B \-m 
オプションは、AT&T ベル研究所バージョンの \*(UX
.I awk
に由来しています。しかし、
.I awk
にはこのような制限はありませんので、
.I awk
では本オプションは無視されます。
.TP \w'\fB\-\^\-copyright\fR'u+1n
.PD 0
.B "\-W compat"
.TP
.PD
.B \-\^\-compat
.I 互換
モードで動作します。互換モードでは、
.I awk
は \*(UX
.I awk
と等価な動作を行い、GNU 独自拡張は解釈できません。
詳しくは後述の
.B "GNU 拡張"
を参照してください。
.TP
.PD 0
.B "\-W copyleft"
.TP
.PD 0
.B "\-W copyright"
.TP
.PD 0
.B \-\^\-copyleft
.TP
.PD
.B \-\^\-copyright
GNU の著作権表示の短いバージョンを標準エラー出力へ書き出します。
.TP
.PD 0
.B "\-W help"
.TP
.PD 0
.B "\-W usage"
.TP
.PD 0
.B \-\^\-help
.TP
.PD
.B \-\^\-usage
短めのオプション一覧を標準エラー出力へ書き出します。GNU コーディング規約に
従い、本オプションを指定すると
.I awk
はただちに終了し、成功を意味する終了ステータスを返します。
.TP
.PD 0
.B "\-W lint"
.TP
.PD 0
.B \-\^\-lint
他の AWK での処理が疑わしい、あるいは他の AWK との互換性がない構造が
ある場合に警告を行います。
.ig
.\" This option is left undocumented, on purpose.
.TP
.PD 0
.B "\-W nostalgia"
.TP
.PD
.B \-\^\-nostalgia
長い間
.I awk
を使ってきたユーザのために郷愁の瞬間を提供します。
..
.TP
.PD 0
.B "\-W posix"
.TP
.PD
.B \-\^\-posix
.I 互換
モードをオンにし、更に以下の制約が課せられます。
.RS
.TP \w'\(bu'u+1n
\(bu
.B \ex
エスケープシーケンスを解釈しません。
.TP
\(bu
キーワード
.B function
に対応する別名
.B func
を解釈しません。
.TP
\(bu
演算子
.B ^
や
.B ^=
のかわりに
.B **
や
.B **=
を用いることができません。
.RE
.TP
.PD 0
.BI "\-W source=" program-text
.TP
.PD
.BI \-\^\-source= program-text
.I program-text
を AWK プログラムとして用います。本オプションにより、ライブラリ化された関数(
.B \-f
または
.B \-\^\-file
オプションを用いて読み込む)とコマンドラインから入力されたプログラムを
簡単に合成することができます。
これは、主にシェルスクリプトで用いられる中規模から大規模な AWK プログラム
のために用意されました。
.sp .5
.B "\-W source="
形式においては、そのコマンドライン引数の残りの部分を
.I program-text
として解釈します。
よって、同じ引数内でこれ以上
.B \-W
のオプション引数を続けることはできません。
.TP
.PD 0
.B "\-W version"
.TP
.PD
.B \-\^\-version
実行された
.I awk
プログラムのバージョン情報を標準エラー出力へ書き出します。これは主に、
あなたが使用している
.I awk
プログラムが Free Software Foundation が配布してい
るプログラムのうち、最新のものであるかどうかを知る場合に便利です。本オ
プションを指定すると、GNU コーディング規約に従い、
.I awk
はただちに終了し、成功を意味する終了ス
テータスを返します。
.TP
.B \-\^\-
オプションの終了を意味します。AWK に ``\-'' から始まるオプションではない
引数を与える場合に便利です。
これは主に、他の \*(PX プログラムの多くが引数に対して行
う解釈と一貫性を保つためにあります。
.PP
互換モードでは、他のオプションは不正であるとされるか、無視されます。通
常の実行において、プログラムテキストがコマンドラインに指定されていれば、
不明なオプションは、AWK プログラムに
.B ARGV
配列を通して渡されます。これ
は、AWK プログラムを ``#!'' 機構を用いて実行する場合に特に便利です。
.SH AWK プログラムの実行
.PP
AWK プログラムは、パターンとアクションの組の列と、(もし必要なら)関数定義か
らなります。
.RS
.PP
\fIpattern\fB	{ \fIaction statements\fB }\fR
.br
\fBfunction \fIname\fB(\fIparameter list\fB) { \fIstatements\fB }\fR
.RE
.PP
.I gawk
はまず、
.I program-file
(複数可)が指定されていればそれから、
.B "\-W source="
の引数から、あるいは、最初のオプションではない引数から
プログラムを読み込みます。
.B \-f
と
.B "\-W source="
オプションは、コマンドラインで複数回指定できます。
.I gawk
は、すべての
.I program-file
とコマンドラインで指定したプログラムを結
合して使用します。新しく作った AWK プログラム一つ一つに
AWK 関数のライブラリを埋め込む必要が無いので、この機能はライブラリの構築に
便利です。
また、ライブラリ関数とコマンドラインで指定したプログラムとを混合して使
うことも可能にしています。
.PP
環境変数
.B AWKPATH
により、
.B \-f
オプションで指定されたファイルを検索するパスを指定できます。
.B AWKPATH
が設定されていない場合のデフォルトパスは
\fB".:/usr/lib/awk:/usr/local/lib/awk"\fR です。
.B \-f
オプションで指定したファイル名が ``/'' を含んでいる場合は、
パス検索は行われません。
.PP
.I awk
は、 AWK プログラムを以下の順序で実行します。
.RS
.TP \w'4.'u+1n
1.
.B \-v
オプションで指定された変数への代入をすべて行う
.TP
2.
プログラムを内部形式にコンパイルする
.TP
3.
(もし存在すれば)
.B BEGIN
ブロック(複数存在可)を実行する
.TP
4.
配列
.B ARGV
で指定されたファイルを順に読み、処理を行う(コマンドラインでファイル名が
指定されていなければ、標準入力に対して処理を行う)。
.RE
.PP
コマンドラインで指定されたファイル名が
.IB var = val
という形式ならば、それ
は変数への代入であると解釈されます。変数
.I var
は値
.I val
に設定されます
(これは、すべての
.B BEGIN
ブロックを実行したあとに行われます)。コマンドライン
での変数の代入は、AWK が入力をフィールドやレコードに分割するためのセパレータ
を実行時に変更するのに便利です。また、1つのデータファイルに
対し数回処理を行う必要がある場合、状態をコントロールするのにも便利です。
.PP
配列
.B ARGV
の要素に空(\fB""\fR)がある場合、
.I awk
はその要素を無視します。
.PP
.I awk
は、入力された各行に対してマッチする
.I パターン
が AWK プログラム内にあるかどうかを
検索します。その行にマッチしたパターンすべてについて、それぞれ対応する
.I アクション
が実行されます。
パターンは、プログラムテキストに出現した順序で検索されます。
.PP
入力がつきると、
.I awk
は(もしあれば)
.B END
ブロック(複数存在可)を実行します。
.SH 変数とフィールド
AWK における変数は動的、すなわち、最初に使用されたときに生成されます。
変数の値は、浮動小数か、文字列か、あるいは両方です。変数の用い
られ方により変化します。AWK ではまた、1次元配列を利用することができます。
多次元配列
も、擬似的にではありますが、利用可能です。プログラム実行開始時に、
いくつかの定義済み変数が設定されます。
.SS フィールド
.PP
入力ファイルから1行を読み込むと、
.I awk
はその行を
.I フィールド
に分割しま
す。分割する際には、変数
.B FS
の値がフィールドセパレータとして参照されます。
.B FS
の値が1文字なら、その
文字を境にフィールドが分割されます。1文字でないなら、
.B FS
は正規表現である
と解釈されます。特殊な場合として
.B FS
が単一の空白のときには、フィールドは
連続した空白とタブにより分割されます。変数
.B IGNORECASE
(下記参照)の
値は、
.B FS
が正規表現の場合、フィールド分割にも影響を与えることに注意してください。
.PP
変数
.B FIELDWIDTHS
の値が空白で区切られた数字の列である場合、各フィールドは
固定長であると解釈され、
.I awk
は指定された幅ごとにフィールドの
分割を行います。この場合、
.B FS
の値は無視されます。
.B FS
に新たに値を設定
することにより、この
.B FIELDWIDTHS
の効果を打ち消し、標準の動作に戻すことができます。
.PP
各フィールドの値は、左から
.BR $1 ,
.B $2 
等という名前で参照できます。
.B $0
は
行全体です。フィールドに値を代入することもできます。フィールドは定数だ
けでなく、変数によって参照することもできます。以下の例では、入力行の 5 
番目のフィールドの値を出力します。
.RS
.PP
.ft B
n = 5
.br
print $n
.ft R
.RE
.PP
変数 NF は、自動的にその行のフィールドの数に設定されます。
.PP
存在しないフィールド(すなわち、
.B $NF
より右のフィールド)を参照した結果は
空文字列になります。しかしながら、存在しないフィールドへの代入(たとえ
ば、
.BR $(NF+2) = 5
)は
.B NF
の値を増加させ、間のフィールドには空文字が設定されます。
さらに
.B $0
の値は、フィールドの値を変数
.B OFS
の値で結合したものに再設定されます。
負のフィールド番号への参照は致命的エラーとなります。
.SS 組み込み変数
.PP
AWK の組込み変数は以下のとおりです。
.PP
.TP \w'\fBFIELDWIDTHS\fR'u+1n
.B ARGC
コマンドライン引数の個数(
.I awk
へのオプションと、プログラム指定は含みま
せん)。
.TP
.B ARGIND
現在処理中のファイル名が格納されている配列
.B ARGV
のインデックス。
.TP
.B ARGV
コマンドライン引数の配列。配列は、 0 から
.B ARGC
\- 1 までのインデックスを
持ちます。
.B ARGV
の内容を変更することで、入力に用いるファイル名を変
更することができます。
.TP
.B CONVFMT
数値の変換フォーマット。デフォルト値は \fB"%.6g"\fR です。
.TP
.B ENVIRON
現在の環境変数の値からなる配列。配列は、環境変数名によりインデックスされ
、各要素の値はその環境変数の値です(たとえば、環境変数
.B HOME
は \fBENVIRON["HOME"]\fP で参照できます)。本配列に
代入を行っても、
.I awk
からリダイレクトや
.B system()
関数により実行される
プログラムの環境には影響を与えません(これは、将来の
.I awk
では変更される可能性があります)。
.\" but don't hold your breath...
.TP
.B ERRNO
.B getline
のリダイレクト、
.B getline
による読み込み、
.B close()
関数の実行時のいずれかにシステムエラーが発生した場合、変数
.B ERRNO
にはエラーの内容を示した文字列が設定されます。
.TP
.B FIELDWIDTHS
空白で区切られたフィールド長のリスト。もしこの値が設定されていれば、
.I awk
は 
.B FS
の値を用いてフィールド分割するかわりに、固定長のフィールド分割を行
います。固定長のフィールド分割機能はまだ実験的なもので、
.I awk
が改良されるに従
って意味が変化する可能性があります。
.TP
.B FILENAME
現在の入力ファイル名。もし、コマンドラインで入力ファイルが指定されてい
なければ、
.B FILENAME
の値は ``\-'' です。しかしながら、
.B BEGIN
ブロック内では 
.B FILENAME
は未定義です。
.TP
.B FNR
現在の入力ファイルにおける入力レコード番号。
.TP
.B FS
入力フィールドセパレータ。デフォルトでは単一の空白です。
.TP
.B IGNORECASE
すべての正規表現において大文字小文字の区別を制御します。もし、
.B IGNORECASE
が 0 でない値に設定されていれば、ルールのパターンマッチ、
.B FS
によるフィールド分割、
.B ~
と
.B !~
による正規表現マッチ、定義済み関数
.BR gsub() ,
.BR index() ,
.BR match() ,
.BR split() ,
.B sub()
において大文字と小文字の違いは無視されます。このため、
.B IGNORECASE
が 0 以外の
値なら、
.B /aB/
は \fB"ab"\fP、\fB"aB"\fP、\fB"Ab"\fP、\fB"AB"\fP のいずれにもマッチすることになります。
他のAWK 変数と同様に
.B IGNORECASE
のデフォルト値は 0 なので、通常は
正規表現において大文字と小文字は区別されます。
.TP
.B NF
現在の入力レコードのフィールド数。
.TP
.B NR
現在までに読み込んだ入力レコード数の合計。
.TP
.B OFMT
数字の出力フォーマット。デフォルト値は \fB"%.6g"\fR です。
.TP
.B OFS
出力フィールドセパレータ。デフォルトは空白です。
.TP
.B ORS
出力レコードセパレータ。デフォルトは改行です。
.TP
.B RS
入力レコードセパレータ。デフォルトは改行です。
.B RS
は例外的な変数で、
値の最初の1文字のみがレコード分割に用いられます(これは、将来リリースされる
.I awk
では変更されているかもしれません)。もし
.B RS
が空文字列に設定されていたなら、
レコードは空行によって分割されます。この場合、
.B FS
の値が何であろうとも、改行はつねにフィールドセパレータとしての役割を
果たします。
.TP
.B RSTART
.B match()
によりマッチした最初の文字の位置。0 はマッチしなかったことを示します。
.TP
.B RLENGTH
.B match()
によりマッチした文字列の長さ。\-1 はマッチしなかったことを示します。
.TP
.B SUBSEP
多次元配列を実現する際に用いられる、配列のインデックスを結合する文字。
デフォルト値は \fB"\e034"\fR です。
.SS 配列
.PP
配列は、ブラケット
.RB ( [
と
.BR ] )
の間の式によってインデックスを指定します。もし式が式
のリスト(式, 式, ...) なら、式の値を変数
.B SUBSEP
の値を区切りとして
結合した文字列をインデックスとして用います。これにより、多次元配列を
シミュレートしています。たとえば、
.PP
.RS
.ft B
i = "A" ;\^ j = "B" ;\^ k = "C"
.br
x[i, j, k] = "hello, world\en"
.ft R
.RE
.PP
は、文字列 \fB"hello, world\en"\fR を、文字列 \fB"A\e034B\e034C"\fR で
インデックスした配列 x の要素に代入しています。
AWK の配列はすべて、文字列によりインデックスを行う連想配列です。
.PP
特殊な演算子
.B in
を
.B if
または
.B while
ステートメントで用いることによって、あるインデックス値に
おける配列の値が定義されているかを調べることができます。
.PP
.RS
.ft B
.nf
if (val in array)
	print array[val]
.fi
.ft
.RE
.PP
もし、配列が多次元インデックスを持つなら、
.B "(i, j) in array"
を用います。
.PP
.B in
はまた、
.B for
ループ中で、配列のすべてのインデックス値について繰り返すために
用いることができます。以下の方法で、配列のすべての要素の値を表示する
ことができます。
.PP
.RS
.ft B
.nf
for (i in array)
	print array[i]
.fi
.ft
.RE
.PP
配列の要素は、
.B delete
ステートメントを用いて削除することができます。
.B delete
ステートメントはまた、
配列全体を削除するのにも使えます。
.SS 変数の型と変換
.PP
変数とフィールドは、(浮動小数の)数値または文字列、あるいは両方として
扱われます。
変数の値がどのように解釈されるかは、変数の使われ方によって変化します。
数式中で用いられれば変数は数値として解釈され、文字列として用いられれ
ば文字列として解釈されます。
.PP
変数の値を強制的に数値であると解釈させたい場合は、変数に 0 を加えます
(var + 0)。文字列と解釈させたい場合は空文字列を結合します(var "")。
.PP
文字列を数値に変換する必要がある場合、変換は
.IR atof (3)
によって行われます。
数値を文字列に変換する場合は、変数
.B CONVFMT
の値をフォーマット文字列として用いて、
.IR sprintf (3)
により行われます。AWK ではすべての数値は浮動小数ですが、整数値はつねに整数
として変換が行われます。
.PP
よって、以下の場合、
.PP
.RS
.ft B
.nf
CONVFMT = "%2.2f"
a = 12
b = a ""
.fi
.ft R
.RE
.PP
変数
.B b
は文字列値 \fB"12"\fR となり、"12.00" とはなりません。
.PP
.I gawk
は、以下のようにして比較を行います: 
2つの変数が数値なら数値として比
較します。もし片方が数値で片方が`数値'文字列なら、数値として比較されます。
片方が数値でない文字列なら、数値のほうが文字列に変換され、文字列として
比較されます。両方とも文字列なら、文字列として比較されます。\*(PX 標準に従う
なら、両方とも数値文字列の場合は数値として比較しますが、これは明ら
かに間違いです。
.I awk
はそのような動作をしません。
.PP
初期化されていない変数は、数値としては 0 を、文字列としては空文字列を持ちます。
.SH パターンとアクション
awk は行指向の言語です。まずパターン、次にアクションが続きます。アクショ
ンは
.B {
と
.B }
で囲みます。パターンまたはアクションは省略することもできます。
もちろん、両方とも
省略してしまっては意味がありません。
パターンがない場合、アクションはすべての入力行に
対して適用されます。省略されたアクションは以下と等価です。
.RS
.PP
.B "{ print }"
.RE
.PP
これは行全体を出力します。
.PP
コメントは ``#'' で始まり、行末まで続きます。空行は、複数ステートメントの
間をあけるのに使うことができます。
通常、ステートメントは改行で終わります。ただし、
以下の記号で行が終わる場合にはこの限りではありません: 
``,'', ``{'', ``?'', ``:'',
``&&'', ``||''。
.B do
または
.B else
で終わる行は、ステートメントが自動的に以降
の行へ継続されます。また、改行の直前に ``\e'' を置くことで、
行を継続することができます。この場合、その改行は無視されます。
.PP
``;'' で区切ることにより、1行に複数のステートメントを記述することができ
ます。アクション部におけるステートメントだけではなく、
パターンとアクションの対自体も ``;'' で区切って複数置くことができます。
.SS パターン
AWK のパターンは、以下のうちのいずれかです。
.PP
.RS
.nf
.B BEGIN
.B END
.BI / "regular expression" /
.I "relational expression"
.IB pattern " && " pattern
.IB pattern " || " pattern
.IB pattern " ? " pattern " : " pattern
.BI ( pattern )
.BI ! " pattern"
.IB pattern1 ", " pattern2
.fi
.RE
.PP
.B BEGIN
と
.B END
は特殊なパターンであり、入力と比較されることはありません。すべての 
.B BEGIN
パターンに対応したアクション部は結合されます。結合されたアクションは
すべての入力ファイルの読み込みに先立って実行されます。同様にすべての
.B END
ブロックは結合され、すべての入力ファイルの処理後(あるいは、exit ステートメント
が実行されたとき)に実行されます。
.B BEGIN
と
.B END
はパターン式内で他のパターンと混ぜて使うことはできません。また、
.B BEGIN
と
.B END
パターンはアクション部を省略することができません。
.PP
.BI / "regular expression" /
パターンでは、正規表現にマッチした入力行に対してアクション
が実行されます。正規表現は
.IR egrep (1)
と同じものが使えます。あとに要約を示します。
.PP
関係式では、後述のアクションについての節で示す演算子を用いることが
できます。
これらは概して、特定のフィールドが正規表現にマッチするかどうかを
調べるために用いられます
($2 ~ /foo/ 等)。
.PP
演算子
.BR && ,
.BR || ,
.B !
は、それぞれ C 言語での論理AND、論理OR、論理NOT と等価です。
C 言語と同様に、評価値が確定した時点で以降の評価を打ち切ります。
これらは複数のパターン式を結合するために使用されます。
他のプログラミング言語と同様、括弧によって評価順序を変更することができます。
.PP
?\^: 演算子は C 言語のものと同様です。もし、最初のパターンが真なら、
テストのために 2 番目のパターンが用いられ、そうでなければ 3 番目のパターンが
用いられます。2 番目と 3 番目のパターンのどちらかだけが評価されます。
.PP
.IB pattern1 ", " pattern2
形式は
.I 範囲パターン
と呼ばれます。範囲パターンは、
.I pattern1 
にマッチするレコードから、
.I pattern2
にマッチする行レコードまでのすべてにマッチします。
この形式は、他のパターン式と混合して用いることはできません。
.SS 正規表現
awk の正規表現は
.I egrep
のものと同様に、拡張された正規表現です。
以下の構成要素から成り立っています。
.TP \w'\fB[^\fIabc...\fB]\fR'u+2n
.I c
メタ文字ではない
.I c
にマッチする。
.TP
.I \ec
リテラル文字
.I c
にマッチする。
.TP
.B .
改行以外の任意の一文字にマッチする。
.TP
.B ^
行頭、または文字列の先頭にマッチする。
.TP
.B $
行末、または文字列の終端にマッチする。
.TP
.BI [ abc... ]
abc... のいずれか一文字にマッチする(文字クラス)。
.TP
.BI [^ abc... ]
abc... と改行を除く任意の一文字にマッチする(否定文字クラス)。
.TP
.IB r1 | r2
.I r1
または
.I r2
にマッチする(選言)。
.TP
.I r1r2
.I r1
の直後に
.I r2
が続くものにマッチする(結合)。
.TP
.IB r +
.I r
の 1 回以上の繰り返しにマッチする。
.TP
.IB r *
.I r
の 0 回以上の繰り返しにマッチする。
.TP
.IB r ?
.I r
の 0 回または 1 回の繰り返しにマッチする。
.TP
.BI ( r )
.I r
にマッチする(グループ化)。
.PP
文字列定数中で用いることができるエスケープシーケンス(後述参照)は、
正規表現中でも使用することができます。
.SS アクション
アクションは、ブレース
.B {
と
.B }
で囲みます。アクションは通常の代入、条件文、
ループ文等からなります。演算子、制御文、入出力文は C 言語とほぼ同様です。
.SS 演算子
.PP
AWK での演算子を、優先順位の低いものから順に示します。
.PP
.TP "\w'\fB*= /= %= ^=\fR'u+1n"
.PD 0
.B "= += \-="
.TP
.PD
.B "*= /= %= ^="
代入。絶対的な代入
.BI ( var " = " value )
と演算子代入(その他の形式)がサポートされています。
.TP
.B ?:
C 言語の条件式と同様です。
.IB expr1 " ? " expr2 " : " expr3\c
の形式で使います。もし 
.I expr1
が真なら式の値は
.I expr2
になり、そうでなければ
.I expr3
になります。
.I expr2
か
.I expr3
のうち片方のみが評価されます。
.TP
.B ||
論理 OR。
.TP
.B &&
論理 AND。
.TP
.B "~ !~"
正規表現マッチ、否定のマッチ。
.B 注意:
.B ~
と
.B !~
の左辺に正規表現定数
.RB ( /foo/ 等)
を用いてはいけません。正
規表現定数は右辺にのみ置くことができます。式
.BI "/foo/ ~ " exp
は
\fB(($0 ~ /foo/) ~ \fIexp\fB)\fR と等価であり、これは通常意図するものとは異なります。
.TP
.PD 0
.B "< >"
.TP
.PD 0
.B "<= >="
.TP
.PD
.B "!= =="
通常の関係演算子。
.TP
.I blank
文字列の結合。
.TP
.B "+ \-"
加算、減算。
.TP
.B "* / %"
乗算、除算、剰余。
.TP
.B "+ \- !"
単項プラス、単項マイナス、論理否定。
.TP
.B ^
べき乗(\fB**\fR も同様の意味で使用できる。また \fB**=\fR 代入演算子も存在する)。
.TP
.B "++ \-\^\-"
インクリメント、デクリメント。前置も後置も可能。
.TP
.B $
フィールド参照
.SS 制御ステートメント
.PP
制御ステートメントは以下のとおりです。
.PP
.RS
.nf
\fBif (\fIcondition\fB) \fIstatement\fR [ \fBelse\fI statement \fR]
\fBwhile (\fIcondition\fB) \fIstatement \fR
\fBdo \fIstatement \fBwhile (\fIcondition\fB)\fR
\fBfor (\fIexpr1\fB; \fIexpr2\fB; \fIexpr3\fB) \fIstatement\fR
\fBfor (\fIvar \fBin\fI array\fB) \fIstatement\fR
\fBbreak\fR
\fBcontinue\fR
\fBdelete \fIarray\^\fB[\^\fIindex\^\fB]\fR
\fBdelete \fIarray\^\fR
\fBexit\fR [ \fIexpression\fR ]
\fB{ \fIstatements \fB}
.fi
.RE
.SS 入出力ステートメント
.PP
入出力ステートメントは以下のとおりです。
.PP
.TP "\w'\fBprintf \fI書式, 式の列\fR'u+1n"
.BI close( filename )
ファイルまたはパイプ(下記参照)をクローズします。
.TP
.B getline
次のレコードを
.B $0
に読み込みます。
.BR NF ,
.BR NR ,
.B FNR
が設定されます。
.TP
.BI "getline <" file
ファイル
.I file
から次のレコードを
.B $0
に読み込みます。
.B NF
が設定されます。
.TP
.BI getline " var"
次のレコードを変数
.I var
に読み込みます。
.BR NF ,
.B FNR
が設定されます。
.TP
.BI getline " var" " <" file
ファイル
.I file
から次のレコードを変数
.I var
に読み込みます。
.TP
.B next
現在のレコードに対する処理を終了し、次のレコードを読み込み、AWK プログ
ラムの最初のパターンから処理を開始します。
C 言語の continue と類似した意味を持ちます。
もし、入力データの終端に達した場合、
.B END
ブロックが存在すれば実行されます。
.TP
.B "next file"
現在の入力ファイルに対する処理を終了し、次の入力ファイルからレコードを
読み込みます。
.B FILENAME
が更新され、
.B FNR
が 1 にリセットされ、AWK プログラムの
最初のパターンから処理が開始されます。入力データの終端に達したときは、
もし存在すれば、
.B END
ブロックが実行されます。
.TP
.B print
現在のレコードを出力します。
.TP
.BI print " expr-list"
式を出力します。各式は
.B OFS
の値で区切られます。出力されるレコードの最後に
は
.B ORS
の値が付加されます。
.TP
.BI print " expr-list" " >" file
式をファイル
.I file
に出力します。各式は
.B OFS
の値で区切られます。出力されるレコードの
最後には
.B ORS
の値が付加されます。
.TP
.BI printf " fmt, expr-list"
書式付き出力です。
.TP
.BI printf " fmt, expr-list" " >" file
ファイル
.I file
への書式付き出力です。
.TP
.BI system( cmd-line )
コマンド
.I cmd-line
を実行し、終了ステータスを返します(\*(PX に対応しない
システムでは使用できない場合があります)。
.PP
その他の形式のリダイレクトとして以下のものが利用可能です。
.B print
と
.B printf 
に対して、
.BI >> file
を指定すると出力はファイル
.I file
に追加され、
.BI | " command"
は出力をパイプに対して行います。同様に、
.IB command "| getline"
はコマンドの出力から 
.B getline
を行ないます。
.B getline
はファイル終端では 0 を、エラー時には \-1 を返します。
.SS \fIprintf\fP\^ ステートメント
.PP
AWK での
.B printf
ステートメントと
.B sprintf()
関数(後述参照)は、以下の変換指定書式を受け付けることができます。
.TP
.B %c
1つの \s-1ASCII\s+1 文字。
.B %c
に対応する引数が数値なら、その値を \s-1ASCII\s+1 コードとみなし
て文字に変換します。そうでなければ、引数は文字列であると解釈され、その1
文字目が出力されます。
.TP
.B %d
10進数(整数部分)。
.TP
.B %i
.B %d
と同じです。
.TP
.B %e
.B [-]d.ddddddE[+-]dd
という形式の浮動小数。
.TP
.B %f
.B [-]ddd.dddddd
という形式の浮動小数。
.TP
.B %g
.B %e
と
.B %f
の短い方の形式の浮動小数。余計な 0 は省略されます。
.TP
.B %o
符号なしの 8 進数(整数)。
.TP
.B %s
文字列。
.TP
.B %x
符号なしの 16 進数(整数)。
.TP
.B %X
.B %x
と同様。ただし、
.B abcdef
のかわりに
.B ABCDEF
を用います。
.TP
.B %%
単一の文字
.B %
。引数は使用しません。
.PP
.B %
と上記のコントロール文字との間にオプショナルな追加のパラメータを置く
ことができます。以下にそれらを示します。
.TP
.B \-
左寄せ。
.TP
.I width
フィールドが指定した幅
.I width
になるように拡張されます。もし、
.I width
が 0 で始まる数値の場合、
フィールドは 0 によって拡張されます。さもなければ、空白で拡張されます。
これは数値ではない出力に対しても適用できます。
.TP
.BI . prec
文字列の最大長、または、小数点以下の桁数を指定します。
.PP
\*(AN C の
.B printf()
の動的な幅
.I width
と精度
.I prec
の指定機能が使用できます。幅または精
度の指定部分に
.B *
を指定することで、その値を
.B printf
または
.B sprintf()
への引数で指定できます。
.SS 特殊ファイル名
.PP
入出力リダイレクトを行う場合、
.I awk
が内部で解釈する特殊なファイル名があります。
これらのファイル名により、親プロセス(通常はシェルです)から受け継いだ
ファイルディスクリプタを用いて入出力を行ったり、実行中の
.I awk
プロセスに関する情報を得ることができます。
特殊ファイル名は以下のとおりです。
.TP \w'\fB/dev/stdout\fR'u+1n
.B /dev/pid
現在の
.I awk
プロセスのプロセスID(10進数で、最後に改行が付きます)を
読み込むことができます。
.TP
.B /dev/ppid
親プロセスのプロセスID(10進数で、最後に改行が付きます)を
読み込むことができます。
.TP
.B /dev/pgrpid
現在の awk プロセスのプロセスグループ ID(10進数で、最後に改行が付きます)
を読み込むことができます。
.TP
.B /dev/user
このファイルを読むことで、改行で終わる単一のレコードが得られます。
各フィールドは空白で区切られています。
.B $1
は
.IR getuid (2)
システムコールの値、
.B $2
は 
.IR geteuid (2)
システムコールの値、
.B $3
は
.IR getgid (2)
システムコールの値、$4 
は
.IR getegid (2)
システムコールの値です。もし、さらにフィールドがあれば、
それは
.IR getgroups (2)
システムコールが返すグループ ID のリストです。
全てのシステムで複数のグループがサポートされているわけではありません。
.TP
.B /dev/stdin
標準入力。
.TP
.B /dev/stdout
標準出力。
.TP
.B /dev/stderr
標準エラー出力。
.TP
.BI /dev/fd/\^ n
オープンされたファイルディスクリプタ
.I n
に対応しているファイル。
.PP
エラーメッセージを出力するには、以下の方法が便利です。
.PP
.RS
.ft B
print "You blew it!" > "/dev/stderr"
.ft R
.RE
.PP
もしこの機能が無かったら、次のようにするしかないところです。
.PP
.RS
.ft B
print "You blew it!" | "cat 1>&2"
.ft R
.RE
.PP
これらのファイル名は、コマンドラインのデータファイル指定で使うこともできます。
.SS 数値関数
.PP
AWK は以下の定義済み数値関数を持っています。
.PP
.TP \w'\fBsrand(\^\fIexpr\^\fB)\fR'u+1n
.BI atan2( y , " x" )
.I y/x
の逆正接(ラジアン単位)。
.TP
.BI cos( expr )
余弦(与える値はラジアン)。
.TP
.BI exp( expr )
指数関数。
.TP
.BI int( expr )
整数への切捨て。
.TP
.BI log( expr )
自然対数。
.TP
.B rand()
0 から 1 の間の乱数。
.TP
.BI sin( expr )
正弦(与える値はラジアン)。
.TP
.BI sqrt( expr )
平方根。
.TP
.BI srand( expr )
式
.I expr
の値を乱数生成関数の種として用います。式が指定されなかった場合は、
時刻が用いられます。直前の種の値を返します。
.SS 文字列関数
.PP
AWK は以下の定義済み文字列関数を持っています。
.PP
.TP "\w'\fBsprintf(\^\fIfmt\fB\^, \fIexpr-list\^\fB)\fR'u+1n"
\fBgsub(\fIr\fB, \fIs\fB, \fIt\fB)\fR
文字列
.I t
中で正規表現
.I r
にマッチした部分をすべて
.I s
に置換します。置換の個数を返します。
.I t
を指定しなかった場合は
.B $0
が用いられます。
.TP
.BI index( s , " t" )
文字列
.I s
中に含まれる文字列
.I t
の位置を返します。
.I t
が含まれていない場合は 0 を返します。
.TP
.BI length( s )
文字列
.I s
の長さを返します。
.I s を指定しなかった場合には
.B $0
の長さを返します。
.TP
.BI match( s , " r" )
文字列
.I s
中で正規表現
.I r
にマッチする位置を返します。マッチしない場合は 0 を
返します。
.B RSTART
と
.B RLENGTH
の値が設定されます。
.TP
\fBsplit(\fIs\fB, \fIa\fB, \fIr\fB)\fR
文字列
.I s
を正規表現
.I r
を用いて分割し、配列
.I a
に格納します。
フィールド数を返します。
.I r
が省略され
た場合は
.B FS
が用いられます。配列
.I a
の内容は、分割前にクリアされます。
.TP
.BI sprintf( fmt , " expr-list" )
書式
.I fmt
に従って
.I exp-list
を整形表示し、結果の文字列を返します。
.TP
\fBsub(\fIr\fB, \fIs\fB, \fIt\fB)\fR
.B gsub()
と似てますが、最初にマッチした文字列のみが置換されます。
.TP
\fBsubstr(\fIs\fB, \fIi\fB, \fIn\fB)\fR
文字列
.I s
の
.I i
文字目から始まる
.I n
文字の部分文字列を返します。
.I n
が省略された場合、
.I i
文字目以降の部分文字列が返されます。
.TP
.BI tolower( str )
文字列
.I str
をコピーし、大文字をすべて小文字に変換したものを返します。
アルファベットでない文字は変化しません。
.TP
.BI toupper( str )
文字列
.I str
をコピーし、小文字をすべて大文字に変換したものを返します。
アルファベットでない文字は変化しません。
.SS 時間関数
.PP
タイムスタンプを含んだログファイルの処理は
AWK プログラムの主な使い道の1つですから、
.I awk
はタイムスタンプを取り出したり、フォーマット
するための 2 つの関数を提供します。
.PP
.TP "\w'\fBsystime()\fR'u+1n"
.B systime()
エポックからの経過秒数を返します
(\*(PX システムでは、エポックは UTC で 1970 年 1 月 1 日 0:00 です)。
.TP
\fBstrftime(\fIformat\fR, \fItimestamp\fB)\fR
書式
.I format
に従って
.I timestamp
をフォーマットします。
.I timestamp
は 
.B systime()
が返す値と同じ形式でなければなりません。
.I timestamp
が省略された
場合、現在の
.B systime()
の値が用いられます。利用可能なフォーマットにつ
いては、\*(AN C の
.B strftime()
関数の仕様を参照して下さい。パブリックドメイン
な
.IR strftime (3)
とそのマニュアルページが
.I awk
とともに配布されています。もし、
.I awk
を作成するためにその
.B strftime
を用いた場合は、そのマニュアルに記述さ
れている変換書式が
.I awk
でも利用可能です。
.SS 文字列定数
.PP
AWK での文字列定数は、ダブルクォート(\fB"\fR)に狭まれた文字の列です。
文字列内では、C 言語のようにいくつかの
.I エスケープシーケンス
が使えます。
.PP
.TP \w'\fB\e\^\fIddd\fR'u+1n
.B \e\e
バックスラッシュそのもの。
.TP
.B \ea
「警告」文字。通常は \s-1ASCII\s+1 \s-1BEL\s+1 文字です。
.TP
.B \eb
バックスペース。
.TP
.B \ef
改ページ。
.TP
.B \en
改行。
.TP
.B \er
復帰(キャリッジリターン)。
.TP
.B \et
水平タブ。
.TP
.B \ev
垂直タブ。
.TP
.BI \ex "\^hex digits"
.B \ex
に続く 16 進数で表現された文字。\*(AN C と同様に、
.B \ex
に続くすべての 16 進数字
はエスケープシーケンスの一部であるとみなされます。
(この機能によりコミッティによる言語デザインが分かります。)
たとえば、\fB"\ex1B"\fR は 
\s-1ASCII\s+1 \s-1ESC\s+1 (エスケープ) 文字です。
.TP
.BI \e ddd
1桁か2桁か3桁の 8 進数で表現された文字。たとえば、 \fB"\e033"\fR は 
\s-1ASCII\s+1 \s-1ESC\s+1 (エスケープ) 文字です。
.TP
.BI \e c
文字 c そのもの。
.PP
エスケープシーケンスは正規表現定数内でも用いることができます(たとえば、
.B "/[\ \et\ef\en\er\ev]/"
は空白文字にマッチします)。
.SH 関数
AWK では関数を以下のようにして定義します。
.PP
.RS
\fBfunction \fIname\fB(\fIparameter list\fB) { \fIstatements \fB}\fR
.RE
.PP
関数は、アクション部から呼び出されたときに実行されます。
関数呼び出しにおいて与えられた実引数が、関数宣言における仮引数に
受け渡されます。
このとき配列の場合は参照渡しが行われ、他の変数の場合は値渡しで行われます。
.PP
元々 AWK に関数は備わっていませんでしたので、局所変数の機構はあまり
スマートではありません。
局所変数は引数リストの余分な引数として宣言します。局所変数と関
数引数を区別するため、余分な空白で区切るのが慣習です。たとえば、以下のよ
うにします。
.PP
.RS
.ft B
.nf
function  f(p, q,     a, b) {	# a と b は局所変数
			..... }

/abc/	{ ... ; f(1, 2) ; ... }
.fi
.ft R
.RE
.PP
関数呼び出しにおける左括弧は、空白を狭まずに関数名の直後に
置かなければいけません。
これは、文字列結合演算子との曖昧さを生じさせないために必要です。
この制限は、上述の組み込み関数にはあてはまりません。
.PP
関数は、他の関数を呼び出したり、自分自身を再帰的に呼び出すことができます。
局所変数として用いられる関数引数は、関数起動時に空文字列および 0 
に初期化されます。
.PP
.B function
のかわりに
.B func
を用いることができます。
.SH 例
.nf
``/etc/passwd'' から全ユーザのログイン名を取り出し、ソートして出力する。

.ft B
	BEGIN	{ FS = ":" }
		{ print $1 | "sort" }

.ft R
ファイルの行数を数える。

.ft B
		{ nlines++ }
	END	{ print nlines }

.ft R
行番号をつける。

.ft B
	{ print FNR, $0 }

.ft R
全ファイルを通した行番号をつける。

.ft B
	{ print NR, $0 }
.ft R
.fi
.SH 関連項目
.IR egrep (1),
.IR getpid (2),
.IR getppid (2),
.IR getpgrp (2),
.IR getuid (2),
.IR geteuid (2),
.IR getgid (2),
.IR getegid (2),
.IR getgroups (2)
.PP
.IR "The AWK Programming Language" ,
Alfred V. Aho, Brian W. Kernighan, Peter J. Weinberger,
Addison-Wesley, 1988. ISBN 0-201-07981-X.
.PP
.IR "The AWK Manual" ,
Edition 0.15, published by the Free Software Foundation, 1993.
.SH POSIX 互換
.I awk
は最新版の \*(UX
.I awk
との互換性だけでなく、\*(PX 標準との互換性も追求しています。
このため
.I awk
には以下のような機能が取り入れられています。
これらの機能は AWK 本には述べられていませんが、
System V Release 4 および \*(PX 標準の
.I awk
が有している機能です。
.PP
プログラム実行前に変数代入を行なう
.B \-v
オプションは新しい物です。
AWK 本によれば、コマンドラインで指定された変数代入は
.I awk
が引数をファイル名としてオープンする際に行なわれることになります。つまり
これは
.B BEGIN
ブロックの実行後です。しかしながら初期の頃の実装では、引数の中でファイル名に
先立って変数代入が指定されている場合には、代入は
.B BEGIN
ブロック実行の
.I 前に
行われていました。そしてアプリケーションは、この「仕様」に依存する
ようになりました。
.I awk
がそのドキュメントに合うように直された時、昔の動作に依存している
アプリケーションの便宜を図るためにこのオプションが加えられました。
(この仕様は AT&T および GNU の開発者達によって合意されました。)
.PP
独自機能のための
.B \-W
オプションは \*(PX 標準に従ったものです。
.PP
引数の列に特別なオプション ``\fB\-\^\-\fP'' を指定すると、
.I awk
はそこがオプションの終わりであると解釈します。
互換モードにおいては未定義オプションは警告が出力され、それ以外のものは
無視されます。
通常の実行においては残りの引数は AWK プログラムに引き渡されます。
.PP
AWK 本は
.B srand()
の返り値を定義していません。
System V Release 4 版の \*(UX
.I awk
(と \*(PX 標準)
では、その関数が使っている種を返します。
したがって
.I awk
における
.B srand()
も現在の種を返すようにしてあります。
.PP
その他にも以下のような新機能があります。
.B \-f
オプションの複数回使用 (MKS
.IR awk に倣いました);
.B ENVIRON
配列;
エスケープシーケンス
.B \ea
と
.B \ev
(
.I awk
で最初に実装され、AT&T の
.I awk
にフィードバックされました);
組み込み関数
.B tolower()
と
.B toupper()
(AT&T に倣いました);
.B printf
における \*(AN C 変換指定
(AT&T 版で最初に実装されました)。
.SH GNU 拡張
.I gawk
は \*(PX
.I awk
に対していくつかの拡張が行なわれています。
この節ではそれらについて解説します。
.B "\-W compat"
オプション付きで
.I awk
を起動することによって、
ここで述べられている拡張機能をすべて禁止することができます。
.PP
.I awk
が持つ以下の機能は
\*(PX
.I awk
では使用できません。
.RS
.TP \w'\(bu'u+1n
\(bu
エスケープシーケンス
.B \ex
。
.TP
\(bu
関数
.B systime()
および
.B strftime()
。
.TP
\(bu
入出力リダイレクトで利用可能な特殊ファイル名。
.TP
\(bu
変数
.B ARGIND
および
.B ERRNO
は特殊変数ではありません。
.TP
\(bu
変数
.B IGNORECASE
とその副作用は利用できません。
.TP
\(bu
変数
.B FIELDWIDTHS
と固定長フィールド分割。
.TP
\(bu
.B \-f
オプションで指定されたファイル名について行われるパス検索。
よって、環境変数
.B AWKPATH
は特殊な変数ではありません。
.TP
\(bu
現在の入力ファイルに対する処理を終わらせるために使用される
.B "next file"
。
.TP
\(bu
配列全体を削除するために使用される
.BI delete " 配列"
。
.RE
.PP
AWK 本は関数
.B close()
の返り値を定義していません。
.I gawk
の
.B close()
は、ファイルやパイプをクローズする際に呼び出す
.IR fclose (3)、
や
.IR pclose (3)、
からの返り値を返します。
.PP
オプション
.B "\-W compat"
付きで
.I awk
を起動し
.B \-F
オプションへの引数
.I fs
として ``t'' を与えた場合に、
.B FS
の値はタブ文字に設定されます。
これは少々見苦しい特殊事例ですので、デフォルトの動作としては
採用されていません。
.B "\-W posix"
を指定した場合にも、この動作は行なわれません。
.ig
.PP
If
.I awk
was compiled for debugging, it will
accept the following additional options:
.TP
.PD 0
.B \-Wparsedebug
.TP
.PD
.B \-\^\-parsedebug
Turn on
.IR yacc (1)
or
.IR bison (1)
debugging output during program parsing.
This option should only be of interest to the
.I awk
maintainers, and may not even be compiled into
.IR awk .
..
.SH 歴史的機能
.I awk
は歴代の AWK の実装にあった二つの機能を備えています。
一つめとして、組み込み関数
.B length()
は引数無しで呼び出せるだけでなく、さらに括弧無しでも呼び出せます!
したがって
.RS
.PP
.ft B
a = length
.ft R
.RE
.PP
は以下の2例と同じです。
.RS
.PP
.ft B
a = length()
.br
a = length($0)
.ft R
.RE
.PP
\*(PX 標準ではこの機能は ``deprecated'' と注意書きされており、
.I awk
ではコマンドラインで
.B "\-W lint"
を指定した場合に、この機能の使用に対して警告を出力します。
.PP
もう一つは、
.BR while 、
.BR for 、
.B do
ループ本体の外でも
.B continue
ステートメントを使用できるという機能です。
伝統的な AWK の実装では、このように使用した
.B continue
ステートメントを
.B next
ステートメントと等価なものとして扱ってきました。
.I gawk
では
.B "\-W posix"
が指定されていない場合に、この機能を使うことができます。
.SH 環境変数
環境に
.B POSIXLY_CORRECT
が存在する場合には、
.I awk
はコマンドラインで
.B \-\-posix
が指定されている時と全く同じ動作をします。
このとき
.B \-\-lint
が指定されていると
.I awk
はこの作用についての警告メッセージを出力します。
.SH バグ
コマンドラインでの変数代入機能を使用するには、変数への代入を直接
コマンドラインに書けばよく、
.B \-F
オプションをつける必要はありません。
このオプションは昔の
.I awk
との互換性のためだけに残されています。
.PP
ファイル
.B /dev/fd
および
.BR /dev/stdin 、
.BR /dev/stdout 、
.B /dev/stderr
を実際にサポートしているシステムでの
.I awk
からは、それらがないシステムとは違った出力が得られるかもしれません。
.I awk
はそれらのファイルを内部で解釈する際に標準出力への出力を
.B /dev/stdout 
への出力と同期させますが、それらのファイルを持つシステムでは
出力はそれぞれ異なるファイルへ向けられます。
利用者の方で気を付けるようにしてください(Caveat Emptor)。
.SH バージョン情報
このマニュアルは
.I awk 
バージョン 2.15 について書かれています。
.PP
バージョン 2.11 にあったオプション
.BR \-c 、
.BR \-V 、
.BR \-C 、
.ig
.BR \-D 、
..
.BR \-a 、
.B \-e
は、バージョン 2.15 以降では使用できません。
バージョン 2.16 のマニュアルでは、この事実の記述さえ無くなるでしょう。
.SH 作者
\*(UX
.I awk
の最初のバージョンは、AT&T ベル研究所の Alfred Aho と
Peter Weinberger および Brian Kernighan によって設計、実装されました。
Brian Kernighan はその保守と改良を続けています。
.PP
Free Software Foundation の Paul Rubin と Jay Fenlason
が、Seventh Edition \*(UX で配布された最初のバージョンの
.I awk
と互換性を持つように
.I gawk 
を書きました。
John Woods は数々のバグ修正を送って下さいました。
David Trueman は、Arnold Robbins が送って下さった内容をもとに、
.I gawk
を新バージョンの \*(UX
.I awk
互換にしました。
.PP
DOS への最初の移植は Conrad Kwok と Scott Garfinkle によって
行なわれました。
現在は Scott Deifik が DOS 版の保守をしています。
Pat Rankin は VMS への移植を行ない、Michal Jaegermann は Atari ST への
移植を行ないました。
OS/2 への移植は Kai Uwe Rommel が Darrel Hankerson の助けを借りて
行ないました。
.SH 謝辞
ベル研究所の Brian Kernighan はテストおよびデバッグの間、貴重な助力を
提供して下さいました。
感謝致します。
