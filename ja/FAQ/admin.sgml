<!-- $Id: admin.sgml,v 1.7 1998-07-19 05:41:12 kuriyama Exp $ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.6 --> 

  <sect>
    <heading>システム管理<label id="admin"></heading>
    <p><em>訳: &a.nishika;.<newline>12 November 1997.</em>

    <sect1>
      <heading>システムスタートアップファイルはどこにあるのですか?</heading>

      <p>2.0.5R から 2.2.1R までは, プライマリコンフィグレーションファイルは
      <tt>/etc/sysconfig</tt> にあります. オプションはすべて, このファイルと
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?rc"
      name="/etc/rc"> および <tt>/etc/netstart</tt>といった, 
      別のファイルに指定されています. 

      <p>ファイル <tt>/etc/sysconfig</tt> を見て, システムに適合するように
      変更してください. このファイルはそれぞれの場所に何を書けばいいのかを表す
      コメントがたくさん書かれています. 

      <p>2.2.2 に続くリリース と 3.0 では, <tt>/etc/sysconfig</tt> は, 
      より分りやすい名前の <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)"
      name="rc.conf"> に改名され, それに従って
      書式もいくぶん改められます. <tt>/etc/netstart</tt> も
      <tt>/etc/rc.network</tt> に改名され, 全部のファイルを
      <tt><htmlurl url="http://www.freebsd.org/cgi/man.cgi?cp"
      name="cp"> /usr/src/etc/rc* /etc</tt>で一度にコピーすることが
      出来るようになります. 

      <p>ファイル <tt>/etc/rc.local</tt> は常にここにあり, <htmlurl
      url="http://www.freebsd.org/cgi/ports.cgi?^inn" name="INN">
      や <tt/http/ といった追加のサービス開始や
      カスタムオプションを記述するために使われるでしょう. 

      <p>ファイル <tt>/etc/rc.serial</tt> はシリアルポートの初期化
      (例えばポートの設定を固定したり等々) のためにあります. 

      <p>ファイル <tt>/etc/rc.i386</tt> は iBCS2 エミュレーションのような
      Intel アーキテクチャ固有の設定や PC システムコンソール設定のためにあります. 

      <p>2.1.0R からは, "ローカル" スタートアップファイルをディレクトリ 
      <tt>/etc/sysconfig</tt> (または <tt>/etc/rc.conf</tt>) 
      の中に作って指定することもできます:

      <verb>
        # Location of local startup files.
        local_startup=/usr/local/etc/rc.local.d
      </verb>

      <p>.sh で終わるそれぞれのファイルは, アルファベット順に実行されます. 

      <p>ファイル名を変えることなくある一定の順序で確実に実行したいのであれば, 
      順序が保証されるように以下のようにして, 
      それぞれのファイルの頭に数値をつけるようなデザインを
      使うことができます:

      <verb>
        10news.sh
        15httpd.sh
        20ssh.sh
      </verb>

      <p>この方法は見苦しく (あるいは SysV のように :-)) なりますが, 
      <tt>/etc/rc.local</tt> を 手品のような編集でソートするようなことなく
      ローカルの追加パッケージを使うためには, シンプルでしかもよく使われる
      手法ではあります. ほとんどの ports/packages は 
      <tt>/usr/local/etc/rc.d</tt> をローカルスタートアップディレクトリ
      であると仮定しています. 

    <sect1>
      <heading>簡単にユーザを追加するにはどうすればいいのですか?</heading>

      <p><htmlurl url="http://www.freebsd.org/cgi/man.cgi?adduser"
      name="adduser"> コマンドを使用してください. 

      <p>Ollivier Robert によって Perl で書かれた ``<tt/new-account/'' と
      呼ばれるパッケージもあります. これについては
      <tt>&lt;roberto@FreeBSD.ORG&gt;</tt> にたずねてみてください. 
      現在さらなる開発をおこなっています. 

      <p>また, ユーザを削除するには <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rmuser" name="rmuser">
      コマンドを使用してください. 

    <sect1>
      <heading>FreeBSD システムに新しいハードディスクを追加するには?</heading>

      <p><url url="http://www.freebsd.org/tutorials/diskformat" 
       name="www.freebsd.org"> に書かれているディスクフォーマット
       チュートリアルを参照して下さい.

    <sect1>
      <heading>新しいリムーバブルドライブを持っていますが, どうやって使うの?</heading>

      <p>そのリムーバブルドライブが ZIP であれ EZ drive であれ 
      (あるいはもしそういう風に使いたいのなら, フロッピーであれ), 
      またハードディスクであれ, 一旦システムにインストールされて認識され, 
      カートリッジ, フロッピー等々が挿入されていれば, 
      ことはどのデバイスでも全く同じように進みます. 

      <p><label id="disklabel"> (このセクションは<url
      url="http://vinyl.quickweb.com/mark/FreeBSD/ZIP-FAQ.html"
      name="Mark Mayo's ZIP FAQ"> に基づいています.)

      <p>ZIP ドライブやフロッピーで, すでに DOS のファイルシステムで
      フォーマットしてある場合, 次のコマンドを使うことができます. 
      これはフロッピーの場合です. 

      <verb>
        mount -t msdos /dev/fd0c /floppy
      </verb>

      <p>出荷時の設定の ZIP ディスクではこうです. 

      <verb>
        mount -t msdos /dev/sd2s4 /zip
      </verb>

      <p>その他のディスクに関しては, <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?fdisk" name="fdisk">
      や <tt>/stand/sysinstall</tt> を使って, どのようにレイアウト
      されているか確かめてください. 

      <p>以降は ZIP ドライブが 3 番目の SCSI ディスクで, 
      sd2 と認識されている場合の例です. 

      <p>他人と共有しなければならないフロッピーやリムーバブルディスク
      でなければ, BSD ファイルシステムを載せてしまうのが良い考えでしょう. 
      ロングファイル名もサポートされ, パフォーマンスは少なくとも 
      2 倍は向上しますし, おまけにずっと安定しています. 
      まず最初に, DOS レベルでのパーティション / ファイルシステムを
      無効にしておく必要があります. 使用するのは <tt/fdisk/ でも
      <tt>/stand/sysinstall</tt> でも結構です. 
      複数のオペレーティングシステムを入れることを考慮する
      必要がないような容量の小さなドライブの場合は, 
      次のように FAT パーティションテーブル (スライス) 
      全体を飛ばして, BSD のパーティション設定を行うだけで良いでしょう. 

      <verb>
        dd if=/dev/zero of=/dev/rsd2 count=2
        disklabel -Brw sd2 auto
      </verb>

      <p>複数の BSD パーティションをつくる場合, disklabel か
      <tt>/stand/sysinstall</tt> を使います. 固定ディスク上にスワップ領域
      を加える場合はそういうことをしたいと思うのはもっともですが, 
      ZIP のようなリムーバブルドライブの上ではそういう考えは不適切
      でしょう. 

      <p>最後に, 新しいファイルシステムをつくります. ディスク全体を使用する
      ZIP ドライブの場合は, 以下のようにします. 

      <verb>
        newfs /dev/rsd2c
      </verb>

      <p>次にマウントします. 

      <verb>
        mount /dev/sd2c /zip
      </verb>

      <p>また, 次のような行を <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?fstab"
      name="/etc/fstab"> に入れておくのも良い考えでしょう. 
      "mount /zip" と入力するだけでマウントできるようになります. 

      <verb>
        /dev/sd2c /zip ffs rw,noauto 0 0
      </verb>

    <sect1>
       <heading>どのようにしたら DOS の拡張パーティションをマウントできますか?</heading>

       <p>DOS 拡張パーティションはすべての基本パーティションの後に
       認識されます. たとえば, 2台目の SCSIドライブの拡張パーティションに 
       "E" パーティションがあるとしますと, これは /dev にスライス 5 
       のスペシャルファイルを作る必要があり, /dev/sd1s5 としてマウントされます. 

      <verb>
        # cd /dev
        # ./MAKEDEV sd1s5
        # mount -t msdos /dev/sd1s5 /dos/e
      </verb>

    <sect1>
       <heading>他のシステムのファイルシステムを FreeBSD でマウントすることはできますか?</heading>

       <p><bf/ Digital UNIX/ UFS CDROM は直接 FreeBSD でマウント
       することができます. Digital UNIX やそれ以外のシステムのサポートする
       UFS のディスクパーティションをマウントすることはもっと複雑
       なことで, オペレーティングシステムのディスクパーティション
       の詳細に依存します. 

       <p><bf/ Linux/: 2.2 以降は <bf/ext2fs/ パーティションをサポートします. 
       マニュアルの <htmlurl
       url="http://www.freebsd.org/cgi/man.cgi?mount_ext2fs"
       name="mount_ext2fs"> を見てください. より多くの情報があります. 

       <p>この問題について他の情報があれば, 他の人から感謝されるでしょう. 

    <sect1>
      <heading>どのようにしたら FreeBSD を NT ローダーからブートさせることができますか?</heading>

      <p>FreeBSD のネイティブルートパーティションの最初のセクタを
      ファイルにして DOS/NT パーティション上に置くという画期的な
      アイディアがあります. 
      ファイル名を <tt>c:&bsol;bootsect.bsd</tt> 
      (<tt>c:&bsol;bootsect.dos</tt> からの発想です) 
      としたとします. <tt>c:&bsol;boot.ini</tt> 
      ファイルを次のように編集します:

      <verb>
        [boot loader]
        timeout=30
        default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
        [operating systems]
        multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
        C:\BOOTSECT.BSD="FreeBSD"
        C:\="DOS"
      </verb>

      <p>この手順では DOS, NT, FreeBSD その他が<bf/同じ/ディスクのそれぞれの 
      fdisk パーティションにインストールされているとしています. 
      私の場合は, DOS と NT は最初のパーティション, FreeBSDは 2番目にあります. 
      また, FreeBSD は MBR を<bf/使わずに/, ネイティブパーティションから
      ブートするようにインストールしてあります. 
      (訳注: FreeBSD のインストールではブートマネジャを使わずに標準 
      MBR を使う場合に相当します)

      <p>(もし NTFS に変換してしまっているなら) DOS フォーマットの
      フロッピーディスクか FAT パーティションを <tt>/mnt</tt> に DOS 
      マウントします. 

      <verb>
        dd if=/dev/rsd0a of=/mnt/bootsect.bsd bs=512 count=1
      </verb>

      <p>リブートして DOS か NT に切替えます. NTFS ユーザは 
      <tt/bootsect.bsd/ や <tt/bootsect.lnx/ をフロッピーディスクから
      <tt/C:&bsol;/ へコピーします. <tt/boot.ini/ のファイル属性 
      (パーミッション) の変更を以下のようにおこないます:

      <verb>
        attrib -s -r c:\boot.ini
      </verb>

      <p>上の例の <tt/boot.ini/ で示したような正しいエントリを加え, 
      ファイル属性を元に戻します. 

      <verb>
        attrib -r -s c:\boot.ini
      </verb>

      <p>FreeBSD が MBR からブートするようになっている場合, 
      それぞれのネイティブパーティションからブートするように設定した後で, 
      DOS から ``<tt/fdisk/'' コマンドを実行して元に戻してください. 

    <sect1>
      <heading>
        FreeBSD と Linux を LILO からブートするには?
      </heading>

      <p>FreeBSD と Linux が同じディスクにインストールされている場合,
      単に Linux 以外の OS をブートするための LILO のインストール手順に
      従えばいいだけです. 非常に簡単にではありますが, 記してみましょう:

      <p>Linux をブートし, <tt>/etc/lilo.conf</tt> に以下の行を加えて
      ください:
      <verb>
      other=/dev/hda2
             table=/dev/hda
             label=FreeBSD
      </verb>
      (上記の手順は FreeBSD のスライスが Linux から <tt>/dev/hda2</tt>
      という名前で見えていると仮定しています; あなたの設定にあわせて
      ください) その後, <tt>lilo</tt> を root で実行すれば完了です.

      <p>FreeBSD が別のディスクにインストールされているのなら, LILO の
      エントリに ``<tt>loader=/boot/chain.b</tt>'' を追加してください.
      例えば, このようになります:
      <verb>
      other=/dev/sdb4
             table=/dev/sdb
             loader=/boot/chain.b
             label=FreeBSD
      </verb>

      <p>場合によっては, 二つ目のディスクを正しく起動するために FreeBSD
      ブートローダに BIOS ドライブ番号を指定する必要があるかもしれません.
      例えば, FreeBSD SCSI ディスクが BIOS によって BIOS ディスク 1 と
      して認識されるのなら, FreeBSD のブートローダのプロンプトで, 次の
      ように指定する必要があります:
      <verb>
      Boot: 1:sd(0,a)/kernel
      </verb>

      <p>FreeBSD 2.2.5 やそれ以降の版では, ブート時に上記のことを行なう
      だけで自動的に <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?boot(8)" name="boot(8)">
      が設定されます.

      <p><htmlurl 
      url="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html"
      name="Linux+FreeBSD mini-HOWTO"> が FreeBSD と Linux とを相互に
      使えるようにするためのよい参考資料になるでしょう.

    <sect1>
      <heading>
       FreeBSD と Linux を BootEasy からブートするには?
      </heading>

      <p>LILO をマスターブートレコード (MBR) ではなく Linux のブート
      パーティションにインストールしてください. これで BootEasy から
      LILO をブートできるようになります.

      <p>Windows95 と Linux を使用している場合は, いずれにせよ後者の方が
      お勧めです. Windows95 を再インストールする必要にかられたとき, 
      Linux をブート可能に戻す手続きが簡単ですむからです
      (Windows95 は偏屈なオペレーティングシステムで, マスターブートレコード 
      (MBR) から他のオペレーティングシステムを追い払ってしまうのです).

    <sect1>
      <heading>
        「危険覚悟の専用 (dangerously dedicated) ディスク」は健康に悪いの?
      </heading>

      <p><label id="dedicate">
      インストール作業中, ハードディスクのパーティションを切る際に
      2 つの方法を選ぶことができます. デフォルトの方法では, fdisk の
      テーブルエントリ (FreeBSD ではスライスと呼ばれる) を使って, 
      自身のパーティションを使用する FreeBSD のスライスを, 同じマシン
      の他のオペレーティングシステムと互換性のある形にします. 
      それに付随して, ブートセレクタをインストールすれば, ディスク上の
      使用可能なオペレーションシステムを切り替えることができます. 

      <p>さて, これは確かに PC の世界からやって来た人々にとっては
      一般的なお話でしょうが, ここで Unix の世界の方からやって来た, 
      FreeBSD が動作する, しかも FreeBSD だけが動作するマシンをセットアップ
      しようとしている人の場合を考えてみましょう. 彼らは
      オペレーティングシステムがディスク全体を, その始めのセクタから
      終りの 1 つに至るまで使い切る, 古典的な Unix の流儀に慣れ親しんで
      います. このような, FreeBSD が 1 日 24 時間, 1 週間に 7 日走り続け, 
      他のオペレーティングシステムがブートされることなど有り得ないマシン
      では, 正しい fdisk のテーブルは何の役にも立ちません. 結果, もし
      sysinstall の fdisk エディタで ``A)ll FreeBSD'' を選択し, 続く質問に
      ``No'' と答えれば, こちらのモードを選択したことになります. 
      この場合, BSD のブートストラップがこのドライブの MBR になるので, 
      ブートマネージャ等にスペースが残されていないことに注意してください. 
      何かを MBR にインストールすれば, BSD のブートストラップに
      ダメージを与えることになるでしょう. 

      <p>では, なぜこれが 「危険覚悟の」と言われるのでしょう?
      このモードのディスクが, 通常の PC のユーティリティが有効な fdisk
      テーブルと見なす情報を持っていないからです. ユーティリティの出来
      如何によりますが, そのようなディスクを発見したとき, 警告を
      出すものもあります. また, もっと悪い場合, 確認も通告もなしに
      BSD のブートストラップにダメージを与えるものもあるでしょう. 
      PC ではより広範囲で使われているあるオペレーティングシステムは, 
      そういう非ユーザフレンドリーな行為をすることでよく知られています
      (もちろん, その行為は「ユーザフレンドリ」の名の元で
      行われるわけですが). 少なくとも 1 種の, 例えば HP Netserver 
      で使用されていた (もちろん, そこだけではありませんが) Award の 
      BIOS は, 有効な fdisk テーブルを持っていないと認識した全ての
      ハードディスクを無視することで知られています. 
      ブート時にこの現象が起こると, BIOS はそのようなディスクをさっさと
      無視してフロッピードライブを読みに行き, しかも ``Read error'' 
      というあっさりしたメッセージしか吐きません. 感動ものでしょ? 
      多分彼らにとってはこれが「ユーザフレンドリ」なんでしょうね. 
      よくわかりませんけど. 

      <p>このモードの利点はいくつかあります. FreeBSD がディスク全体を所有でき, 
      1980 年代の素朴なパーティショニングモデルのためだけに, いくつもの
      本来不要な「トラック」を無駄使いする必要がなくなります. 
      このモデルは, パーティショニングをどのようにすべきかという点に関して, 
      いくらか不自然で, 今では無意味でさえある制限を課します. 
      この制限は, しばしば PC に OS をインストールする際の最大の頭痛の種と
      なります. パーティショニングの情報を fdisk のテーブルに保存する際に
      2 つの異なる, 冗長な方法が用意されているがゆえに, 結果として
      ジオメトリの不整合を引き起こすのです. <ref id="missing_os"
      name="Missing Operating System"> の章をご覧下さい. 
      「危険覚悟の専用」モードでは, BSD のブートストラップはセクタ 0 
      から始まりますが, BIOS のディスクジオメトリ「変換」の方式とは
      無関係に, 常に等しい C/H/S の値に変換される唯一のセクタ
      なのです. したがって, ブートしなくなる危険を犯すことなしに, 
      異なる変換方式を採用しているシステム / コントローラ間で, 
      ディスクを交換することができるのです. 

      <p>「危険覚悟の専用ディスク」を通常の PC での使用法に
      戻すには, 原則として 2 つ方法があります. 1 つは十分な NULL 
      バイトを MBR に書き込んで, きたるべきインストーラにディスク
      はまっさらだと思い込ませる方法です. 例えば, こんな感じです. 
          
      <verb>
        dd if=/dev/zero of=/dev/rsd0 count=15
      </verb>

      <p>また, マニュアルには書かれていない DOS の「機能」

      <verb>
        fdisk /mbr
      </verb>

      <p>は, BSD ブートストラップを追い払ってくれる上に, 
      新しいマスターブートレコードをインストールしてくれます. 

    <sect1>
      <heading>どのようにしたらスワップ領域を増やせますか?</heading>

      <p>スワップパーティションのサイズを増やすのが最良の方法ですが, 
      別のディスクを追加しなくて済むという利点のある方法があります. 

      <p>スワップを別のディスク上に追加することは, 単純に同じディスク上
      にスワップを追加する場合よりも高速に動作するようになります. 
      例に挙げれば, あるディスク上のソースをコンパイルしているとして, 
      スワップが別のディスク上に作られていれば, これらが同じディスク上
      にある場合よりも断然速いです. SCSI ディスクの場合は特にそうだと言えます. 

      <p> IDE ドライブは同時に同じチャネル上の複数のドライブには
      アクセスできません (FreeBSD は mode 4 をサポートしていないので, 
      すべての IDE ディスク I/O は ``programmed'' です). 
      IDE の場合であってもやはり, スワップを別のハードディスク上に
      作成することをおすすめします. 
      ドライブは実に安いものです, 心配するだけ無駄です. 

      <p>よいサーバと非常に高速なネットワーク環境でないのであれば, 
      スワップを NFS 上に置こうというのは本当にばかげた考えです. 

      <p>これは 64MBの vn-swap を作る例です (ここでは <tt>/usr/swap0</tt> 
      としますが, もちろん好きな名前を使うことができます).

      <p>カーネルが次の行を含むコンフィグファイルから構成されているかを
      確認します. GENERIC カーネルには, この行が含まれています. 

      <verb>
        pseudo-device   vn 1   #Vnode driver (turns a file into a device)
      </verb>

      <enum>
        <item>vn デバイスを作ります
        <verb>
          cd /dev
          sh ./MAKEDEV vn0
        </verb>

        <item>スワップファイルを作ります (<tt>/usr/swap0</tt>)

        <verb>
          dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
        </verb>

        <item><tt>/etc/rc.conf</tt> でスワップファイルを有効化させます

        <verb>
          swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
        </verb>

        <item>マシンをリブートします
      </enum>

      <p>スワップファイルをすぐに有効化させたいのなら以下のようにタイプします
      <verb>
        vnconfig -ce /dev/vn0c /usr/swap0 swap
      </verb>

    <sect1>
      <heading>プリンタのセットアップで問題があります</heading>

      <p>ハンドブックのプリンタの部分を参照してください. 
      探している問題のほとんどが書かれているはずです. 
      <url url="../handbook/printing.html" 
      name="ハンドブック中のプリンタの利用">をご覧ください. 

    <sect1>
      <heading>私のシステムのキーボードマッピングは間違っています. </heading>

      <p>kbdcontrol プログラムは, キーボードマップファイルを読み込むための
      オプションを備えています. 
      <tt>/usr/share/syscons/keymaps</tt> の下にたくさんのマップファイルがあります. 
      システムに関連のあるものを一つ選んで, ロードしてください. 

      <verb>
        kbdcontrol -l uk.iso
      </verb>

      <tt>/usr/share/syscons/keymaps</tt> と拡張子 <tt/.kbd/ は
      どちらも <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?kbdcontrol"
      name="kbdcontrol"> によって使用されます. 

      <p>これは <tt>/etc/sysconfig</tt> (または <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)"
      name="rc.conf">) 中で設定することができます. 
      このファイル中にあるそれぞれのコメントを参照してください. 

      <p>2.0.5R やそれ以降の版では, テキストフォントやキーボードマッピングに
      関係のあるものはすべて, <tt>/usr/share/examples/syscons</tt> 
      の中におさめられています. 

      <p>現在以下のマッピングがサポートされています:

      <itemize>
        <!-- generate by `kbdmap -p' -->
        <item>Belgian ISO-8859-1 
        <item>Brazilian 275 keyboard Codepage 850 
        <item>Brazilian 275 keyboard ISO-8859-1 
        <item>Danish Codepage 865 
        <item>Danish ISO-8859-1 
        <item>French ISO-8859-1 
        <item>German Codepage 850 
        <item>German ISO-8859-1 
        <item>Italian ISO-8859-1 
        <item>Japanese 106 
        <item>Japanese 106x 
        <item>Latin American 
        <item>Norwegian ISO-8859-1 
        <item>Polish ISO-8859-2 (programmer's) 
        <item>Russian Codepage 866 (alternative) 
        <item>Russian koi8-r (shift) 
        <item>Russian koi8-r 
        <item>Spanish ISO-8859-1 
        <item>Swedish Codepage 850 
        <item>Swedish ISO-8859-1 
        <item>Swiss-German ISO-8859-1 
        <item>United Kingdom Codepage 850 
        <item>United Kingdom ISO-8859-1 
        <item>United States of America ISO-8859-1 
        <item>United States of America dvorak 
        <item>United States of America dvorakx 
      </itemize>

    <sect1>
      <heading>ユーザディスククォータが正常に動作していないようです. </heading>

      <p>
      <enum>
        <item>'/' にはディスククォータを設定しないでください, 

        <item>クォータファイルが置かれるファイルシステム上に
        クォータファイルを置くようにしてください. つまり:
        <verb>
          FS      QUOTA FILE
          /usr    /usr/admin/quotas
          /home   /home/admin/quotas
          ...
        </verb>
      </enum>

    <sect1>
      <heading>わたしの ccd の何が適合していない (Inappropriate) のでしょう?</heading>

      <p>このような症状が現れます:

      <verb>
        # ccdconfig -C
        ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format
        #
      </verb>

      <p>通常この現象はタイプを ' 未使用 (unused)' のまま放っておかれた
      'c' パーティションをつなげようとした場合に現れます. ccd ドライバは
      FS_BSDFFS タイプをベースとするパーティションを要求します. 
      つなげようとしているディスクのディスクラベルを編集して, 
      パーティションのタイプを '4.2BSD' に変更してください. 

    <sect1>
      <heading>どうしてわたしの ccd のディスクラベルを変更することができないのでしょう?</heading>

      <p>このような症状が現れます:

      <verb>
        # disklabel ccd0
        (it prints something sensible here, so let's try to edit it)
        # disklabel -e ccd0
        (edit, save, quit)
        disklabel: ioctl DIOCWDINFO: No disk label on disk;
        use "disklabel -r" to install initial label
        #
      </verb>

      <p>これは ccd から返されるディスクラベルが, 実はディスク上にはない
      まったくの偽の情報だからです. これを明示的に書き直すことで
      問題を解消できます, このようになります:

      <verb>
        # disklabel ccd0 > /tmp/disklabel.tmp
        # disklabel -Rr ccd0 /tmp/disklabel.tmp
        # disklabel -e ccd0
        (this will work now)
      </verb>

    <sect1>
      <heading>FreeBSD は System V の IPC プリミティブをサポートしますか? </heading>

      <p>はい. FreeBSD は System-V スタイルの IPC をサポートします. 
      共有メモリ, メッセージ, セマフォが含まれます. 以下の行を
      カーネルコンフィグファイルに加えると, サポートが有効になります. 

      <verb>
        options    SYSVSHM
        options    "SHMMAXPGS=64"   # 256Kb of sharable memory
        options    SYSVSEM          # enable for semaphores
        options    SYSVMSG          # enable for messaging
      </verb>

      <p>コンパイルしてインストールしてください. 

      <p><bf/注:/ GIMP を実行したい場合は, SHMMAXPGS を 4096(16M) 
      くらい馬鹿でかい数字に増やす必要があります. X11R6 の共有メモリは 
      256Kb で十分です. 

    <sect1>
      <heading>
        UUCP で mail を配送するには sendmail をどう使えばよいのですか?<label id="uucpmail">
      </heading>

      <p>FreeBSD に付属している sendmail は, インターネットに直接
      つながっているサイトにあわせて設定してあります. UUCP 経由で mail 
      を交換したい場合には sendmail の設定ファイルを改めてインストール
      しなければなりません. 

      <p><tt>/etc/sendmail.cf</tt>を自分の手で改造するのは純粋主義者の
      やるような事です. sendmailの version 8 は <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?m4" name="m4"> のような
      プリプロセッサを通して設定ファイルを生成する新しいアプローチを
      取っており, より抽象化されたレベルの設定ファイルを編集します. 
      以下のディレクトリの中にある設定ファイルを使用してください. 

      <verb>
        /usr/src/usr.sbin/sendmail/cf
      </verb>

      <p>もしすべてのソースをインストールしていない場合には sendmail 
      の設定ツールは, 別の tar ファイルにまとめてあります. CD-ROM が 
      mount されている場合には, 次のようにしてください. 

      <verb>
        cd /usr/src
        tar -xvzf /cdrom/dists/src/ssmailcf.aa
      </verb>

      <p>これはたった数 100Kbyte ですから心配ないでしょう. <tt>cf</tt> 
      ディレクトリにある <tt>README</tt> に, m4 での設定の基本的な説明があります. 

      <p>UUCP での配送のためには, <em>mailertable</em> を使用すれば
      よいでしょう. これによって, sendmail が配送方式を決定するデータベースを
      作成することができます. 

      <p>まずはじめに, <tt>.mc</tt> ファイルを作成しなければなりません. 
      <tt>/usr/src/usr.sbin/sendmail/cf/cf</tt> というディレクトリが, 
      これらのファイルを作成する場所です. 既にいくつか例があると思います. 
      これから作成するファイルの名前を <tt>foo.mc</tt> とすると, 
      <tt>sendmail.cf</tt> を求めているような形式に変換するには, 
      次のようにしてください. 

      <verb>
        cd /usr/src/usr.sbin/sendmail/cf/cf
        make foo.cf
        cp foo.cf /etc/sendmail.cf
      </verb>

      <p>標準的な <tt>.mc</tt> ファイルは次のようになります. 

      <verb>
        include(`../m4/cf.m4')
        VERSIONID(`Your version number')
        OSTYPE(bsd4.4)

        FEATURE(nodns)
        FEATURE(nocanonify)
        FEATURE(mailertable)

        define(`UUCP_RELAY', your.uucp.relay)
        define(`UUCP_MAX_SIZE', 200000)

        MAILER(local)
        MAILER(smtp)
        MAILER(uucp)

        Cw    your.alias.host.name
        Cw    youruucpnodename.UUCP
      </verb>

      <p><em>nodns</em> と <em>nocanonify</em> という指定をすることで, 
      mail の配送に DNS を使用しなくなります. <em>UUCP_RELAY</em> という
      行に関しては, ある理由から必要ですがそれは聞かないでください. 
      .UUCPで終わる仮想ドメインを処理することのできるインターネット上での
      ホスト名をここに書いてください. 通常は, ISP の mail リレーホストを
      書くことになると思います. 

      <p>これが終了したら, 次に <tt>/etc/mailertable</tt> というファイル
      が必要です. 標準的な例は次のとおりです. 

      <verb>
        #
        # makemap hash /etc/mailertable.db < /etc/mailertable
        #
        horus.interface-business.de   uucp-dom:horus
        .interface-business.de        uucp-dom:if-bus
        interface-business.de         uucp-dom:if-bus
        .heep.sax.de                  smtp8:%1
        horus.UUCP                    uucp-dom:horus
        if-bus.UUCP                   uucp-dom:if-bus
        .                             uucp-dom:sax
      </verb>

      <p>見れば分かるように, これは実在する設定のファイルです. はじめの
      3 行はドメイン名で指定されたメールが default の経路で配送されずに, 
      ``近道'' するために UUCP で隣りのサイトに送るための特別な状況を
      処理するものです. 
      次の行は Ethernet でつながっているローカルのドメインに対しては 
      SMTP で送るための設定です. 
      最後に, UUCP での隣りのサイトが. UUCP で終わる仮想ドメインの書式で
      指定されており, default の rule を ``uucp-neighbour!recipient'' 
      で上書きするためのものです. 一番最後の行はいつもドットを一つ書きます. 
      これは, ここまでの行でマッチしなかったすべてのホストにマッチし, 
      このサイトから世界に向けて出ていくための mail gateway に UUCP 
      で配送するためのものです. 
      <tt>uucp-dom:</tt> に続けて書かれているノード名は, 
      <tt>uuname</tt> コマンドで指定することによって UUCP 
      で直接配送される正しいノード名でなければなりません. 

      <p>最後に, このファイルは使用する前に DBM データベースのファイルに
      変換する必要があります. これをおこなうコマンドラインは mailertable
      の最初のコメントに書いてあります. mailertable を変更した時には, 
      必ずこのコマンドを実行してください. 

      <p>最後のヒントです: もし特定のメール配送がうまく作動するかどうか
      確かめたい場合には, sendmail の<tt>-bt</tt> オプションを
      使用してください. このオプションによって sendmail は
      <em>アドレステストモード</em>で起動します. ``0 '' の後に
      配送したいアドレスを書いてください. 最後の行に, 実際に使用される 
      mail agent, この mail agent で送られる送信先のホスト, そして 
      (多分変換されている) アドレスが表示されます. このモードを抜けるには 
      Control-D を押してください. 

      <verb>
        j@uriah 191% sendmail -bt
        ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
        Enter <ruleset> <address>
        > 0 foo@interface-business.de
        rewrite: ruleset  0   input: foo @ interface-business . de
        ...
        rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
        < @ interface-business . de >
        > ^D
        j@uriah 192%
      </verb>

    <sect1>
      <heading>
        ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの?
        <label id="ispmail">
      </heading>

      <p>静的に IP アドレスが割り当てられる場合は, デフォルトの状態を
      変更する必要はありません. 割り当てられた名前をホストネームと
      するだけで, sendmail が後のことを引き受けてくれます. 

      <p>ダイアルアップ <bf/ppp/ をインターネット接続に使用し, 動的に IP
      アドレスが割り当てられる場合は, インターネットサービスプロバイダ
      (ISP) のメールサーバにメールボックスがあるはずです. ISP のドメイン
      が <tt/myISP.com/ で, あなたのユーザ名が <tt/user/ だと仮定します. 
      また, あなたが自分のマシンを <tt/bsd.home/ と呼んでおり, ISP が
      <tt/relay.myISP.com/ をメールリレーとして使用できると言っていると
      しましょう. 

      <p>メールボックスからメールを取ってくるためには, retrieval (回収)
      エージェントをインストールする必要があります. <bf/Fetchmail/ は
      多種多様なプロトコルをサポートしているのでお勧めです. ISP が
      使用しているのは大抵 POP3 プロトコルです. ユーザ ppp を使用している場合, 
      <tt>/etc/ppp/ppp.linkup</tt> に以下のように記述すると, インターネットと
      接続が完了した時点で自動的にメールを取得するようになります. 

      <verb>
        MYADDR:
          !bg su user -c fetchmail
      </verb>

      <p>この例では, <tt/user/ が <tt/bsd.home/ にアカウントを持ち, 
      <tt/bsd.home/ 上の <tt/user/ のホームディレクトリに, 以下のような
      <tt/.fetchmailrc/ ファイルがつくられていることを想定しています. 

      <verb>
        poll myISP.com protocol pop3 fetchall pass MySecret;
      </verb>

      <p>言うまでもなく, このファイルは <tt/user/ 以外のユーザが読むことが
      出来ないようにしなくてはなりません. 内容にパスワード <tt/MySecret/ が
      含まれているからです. 

      <p>正しい <bf/from:/ ヘッダをつけてメールを送るためには, sendmail に
      <tt/user@bsd.home/ ではなく <tt/user@myISP.com/ を使用するよう教える
      必要があります. メールをより早く転送するために, 全てのメールを
      <tt/relay.myISP.com/ へ送るように sendmail に指示しておくのも良い
      でしょう. 

      <p>上の要件を満たすには, 以下のような <tt/.mc/ ファイルが適しています. 

      <verb>
        VERSIONID(`bsd.home.mc version 1.0')
        OSTYPE(bsd4.4)dnl
        FEATURE(nouucp)dnl
        MAILER(local)dnl
        MAILER(smtp)dnl
        Cwlocalhost
        Cwbsd.home
        MASQUERADE_AS(`myISP.com')dnl
        FEATURE(allmasquerade)dnl
        FEATURE(masquerade_envelope)dnl
        FEATURE(nocanonify)dnl
        FEATURE(nodns)dnl
        define(SMART_HOST, `relay.myISP.com')
        Dmbsd.home
        define(`confDOMAIN_NAME',`bsd.home')dnl
        define(`confDELIVERY_MODE', `deferred')dnl
      </verb>

      <p><tt/.mc/ ファイルから <tt/sendmail.cf/ への変換方法については, 
      前のセクションを参照してください. sendmail.cf を更新した後に
      sendmail をリスタートするのもお忘れなく. 

    <sect1>
      <heading>しまった! root のパスワードを忘れてしまった!</heading>

      <p>あわてないで下さい! 単にシステムを再起動し, シングルユーザモード
      に移るために Boot: と表示されるプロンプトで -s と入力してください.
      どのシェルを使うのかという質問には, ENTER キーを押してください.
      # プロンプトに移ることができるでしょう. <tt>mount -a /</tt> と入力
      して, root ファイルシステムを読み書きできるようにマウントし直した後,
      <tt/passwd root/ と入力して root のパスワードを設定し直して下さい.
      その後, <tt/exit/ と入力すれば, ブートが続けられます.

    <sect1>
      <heading>Control-Alt-Delete でシステムがリブートしないようにするにはどうすればいい?</heading>

      <p>コンソールで使っているキーマップを編集して, <tt/rbt/ という
      キーワードを <tt/nop/ に置き換えて下さい. デフォルトキーマップは,
      <tt>/usr/share/syscons/keymaps/us.iso.kbd</tt> にあります. その
      変更を反映させようとして, このキーマップのロードを明示的に行なう
      ために, <tt>/etc/rc.conf</tt> を実行すべきかもしれません. もちろん
      他の国のキーマップを使っているのであれば, 代わりにそのキーマップ
      ファイルを編集して下さい.

  </sect>

