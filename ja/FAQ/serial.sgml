<!-- $Id: serial.sgml,v 1.3 1998-05-25 01:17:30 hanai Exp $ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.2 --> 

  <sect>
    <heading>シリアル接続<label id="serial"></heading>
    <p><em>訳: &a.ryo;.<newline>16 November 1997.</em>

    <p>このセクションでは, FreeBSD でシリアル接続をする時の一般的な質問に答えます.
    PPP および SLIP については,
    <ref id="networking" name="ネットワーキング">のセクションを参照してください.

    <sect1>
      <heading>どうやったら FreeBSD がシリアルポートを認識したことを知る事ができますか?</heading>

      <p>FreeBSD のカーネルがブートする時, カーネルはその設定にしたがって,
      システムのシリアルポートを検出します. 起動時に表示されるメッセージをよく観察するか,
      起動後に次のコマンドを実行する事によって確認できます.

      <verb>
        dmesg | grep sio
      </verb>

      <p>ここに上に挙げたコマンドの出力例を示します.

      <verb>
        sio0 at 0x3f8-0x3ff irq 4 on isa
        sio0: type 16550A
        sio1 at 0x2f8-0x2ff irq 3 on isa
        sio1: type 16550A
      </verb>

      <p>これは, 二つのシリアルポートを示しています. 1番めは,
      irq が 4 で <tt/0x3f8/ のポートアドレスを使用しています.
      そして, 16550A-type UART チップが存在します. 2番目は, 同じチップを使っていますが,
      irq は 3 で, <tt/0x2f8/ のポートアドレスを使用しています. 内蔵のモデムカードは,
      通常のシリアルポートと同じように扱われますが,
      常時シリアルポートにモデムが接続されているという点で異なります.

      <p><tt/GENERIC/ カーネルは,
      上の例と同じ irq とポートアドレスの設定の二つのシリアルポートをサポートしています.
      これらの設定があなたのシステムに合わない場合,
      またはモデムカードを追加した場合やカーネルの設定以上にシリアルポートを持っている場合は,
      カーネルを再構築 (リコンフィグ) してください.
      詳しくは, <ref id="make-kernel" name="カーネルコンフィグレーション"> のセクションを参照してください.

    <sect1>
      <heading> どうやったら FreeBSD がモデムカードを認識したことを知ることができますか?</heading>

      <p>前の質問を参照してください.

    <sect1>
      <heading>2.0.5 にアップグレードしたら <tt/tty0X/ が見つからなくなってしまったのですが</heading>

      <p>心配ありません. <tt/ttydX/ に統合されました.
      ただ, 古い設定ファイルのすべてを更新する必要があります.

    <sect1>
      <heading>どうやったら FreeBSD でシリアルポートにアクセスできますか?</heading>

      <p>3番目のポート <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?sio"
      name="sio2"> (DOS では, COM3 と呼ばれます.) には,
      ダイヤルアウトデバイスとしては <tt>/dev/cuaa2</tt>,
      ダイヤルインデバイスとして <tt>/dev/ttyd2</tt> があります.
      それではこの両者にはどのような違いがあるのでしょうか?

      <p>まず, ダイヤルインの時には <tt/ttydX/ を使います.
      <tt>/dev/ttydX</tt> をブロッキングモードでオープンすると,
      プロセスは対応する <tt/cuaaX/ デバイスがインアクティブになるのを待ちます.
      次に CD ラインがアクティブになるのを待ちます. <tt/cuaaX/ デバイスをオープンすると,
      シリアルポートが<tt/ttydX/ デバイスによってすでに使われていないかどうかを確認します.
      もしこのポートが使用可能であれば, ポートの使用権を <tt/ttydX/ から ``奪い取る'' のです.
      また, <tt/cuaXX/ デバイスは CD ラインを監視しません. この仕組みと自動応答モデムによって,
      リモートユーザーをログインさせたり, 同じモデムでダイヤルアウトしたりすることができ,
      システムのあらゆるトラブルの面倒を見ることができるでしょう.

    <sect1>
      <heading>マルチポートシリアルカードをサポートさせるにはどうしたらよいのでしょうか?</heading>

      <p>繰り返しになりますが, <ref id="make-kernel" name="カーネルコンフィグレーション"> のセクションでは,
      あなたのカーネルの設定についての情報が得られるでしょう.
      マルチポートシリアルカードを使用するためには, カーネルの設定ファイルに,
      カードの持つそれぞれのシリアルポートに対応する <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?sio"
      name="sio">
      の行を記述する必要があります. しかし, irq とベクターは一つのエントリにのみ記述してください.
      カード上のすべてのポートは一つの irq を共有しなければなりません. 一貫性を持たせるためにも,
      最後のシリアルポートの所で irq を指定してください.
      また, <tt/COM&lowbar;MULTIPORT/ オプションも付けてください.

      <p>次に示す例は, AST の 4 ポートシリアルカードを irq 7 で設定したものです.

      <verb>
        options "COM_MULTIPORT"
        device sio4 at isa? port 0x2a0 tty flags 0x781
        device sio5 at isa? port 0x2a8 tty flags 0x781
        device sio6 at isa? port 0x2b0 tty flags 0x781
        device sio7 at isa? port 0x2b8 tty flags 0x781 irq 7 vector siointr
      </verb>

      <p>このフラグはマスタポートがマイナーナンバー 7 (<tt/0x700/) を持っていて,
      検出時の診断機能を有効にし (<tt/0x080/), そしてすべてのポートで irq を共有する (<tt/0x001/)
      ということを意味しています.

    <sect1>
      <heading> FreeBSD で複数のマルチポートシリアルカード間で irq を共有することはできますか?</heading>

      <p>現在のところはできません. それぞれのカード毎に異なった irq を使ってください.

    <sect1>
      <heading>ポートにデフォルトのパラメータを設定する事は出来ますか?</heading>

      <p><tt/ttydX/ デバイス (または <tt/cuaaX/ デバイス) は,
      アプリケーションのためにオープンする標準的なデバイスです.
      プロセスがそのポートをオープンする時, プロセスはデフォルトの端末 I/O 設定を取得します.
      これらの設定は次のコマンドで確認することができます.

      <verb>
        stty -a -f /dev/ttyd1
      </verb>

      <p>このデバイスに対する設定を変更した場合, その設定はデバイスをクローズするまで有効です.
      デバイスを再オープンした場合, それらの設定はデフォルトに戻ってしまいます.
      デフォルトの設定に変更を加えるために, ``初期設定'' デバイスをオープンし,
      設定を修正することができます.
      例えば, <tt/CLOCAL/ モード, 8 ビット, <tt>XON/XOFF</tt> フロー制御という設定を
      ttyd5 のデフォルトにしたい場合, 次のようにおこなってください.

      <verb>
        stty -f /dev/ttyid5 clocal cs8 ixon ixoff
      </verb>

      <p>この設定をおこなうためのコマンドを記述するのに適切なファイルは,
      <tt>/etc/rc.serial</tt> です. これでアプリケーションが<tt/ttyd5/ をオープンした時に,
      これらの設定をデフォルトで取得します. しかし, こういったリンクによる設定は変更可能です.

      <p>``設定固定'' デバイスを調整してやることによって,
      アプリケーションによる設定の変更を禁止することができます. 例えば, <tt/ttyd5/
      の通信速度を 57600 bps に固定するには, 次のように行ってください.
          
      <verb>
        stty -f /dev/ttyld5 57600
      </verb>

      <p>これにより, アプリケーションは <tt/ttyd5/ をオープンし,
      ポートの通信速度を変更しようとしますが, 通信速度は 57600 bps のままになります.

      <p>当然のことながら, 初期設定デバイスおよび, 設定固定デバイスは
      <tt/root/ のみが書き込みできるようになっていなければなりません. 
      しかし, <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?MAKEDEV"
      name="MAKEDEV"> スクリプトはデバイスエントリを作成する時に, 
      このような設定は行いません. 
 
    <sect1>
      <heading>どのようにしたら モデム経由でダイヤルアップログインができるのでしょうか?</heading>

      <p>つまり, インターネットサービスプロバイダーになりたいのですね. 
      それにはまず, 1 台ないし複数の自動応答モデムが必要です. 
      モデムには, キャリアーを検出した時には CD信号を出力し,
      そうでない場合には出力しないことが必要とされます. また <tt/DTR/ 信号が
      on から off になった時には, 電話回線を切断し, モデム自身をリセットしなければなりません. 
      おそらく, <tt>RTS/CTS</tt> フロー制御を使うか,
      ローカルフロー制御をまったく使わないかのどちらかでしょう.
      最後に, コンピュータとモデムの間は固定速度でなければなりません.
      ただ, (ダイヤルアップの発呼者に対して親切であるためには) こちらのモデムと相手側のモデムの間の速度を,
      モデム間で自動調整できるようにすべきでしょう. 

      <p>多くあるヘイズコマンド互換モデムに対して, 次のコマンドはこれらの設定をおこない,
      その設定を不揮発性メモリーに保存します. 

      <verb>
        AT &amp;C1 &amp;D3 &amp;K3 &amp;Q6 S0=1 &amp;W
      </verb>

      <p>MS-DOS のターミナルプログラムに頼らずに AT コマンドを送出するには,
      <ref id="direct-at" name="これらの AT コマンドを入力するには"> のセクション以下を参照してください.

      <p>次に, モデム用のエントリを <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?ttys"  
      name="/etc/ttys"> に作成しましょう. 
      このファイルには, オペレーティングシステムがログインを待っているすべてのポートが記述されています.
      以下のような行を追加してください. 

      <verb>
        ttyd1 "/usr/libexec/getty std.57600" dialup on insecure
      </verb>

      <p>この行は, 2 番目のシリアルポート (<tt>/dev/ttyd1</tt>) には,
      57600 bps の通信速度でノンパリティ (<tt/std.57600/ : これは <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?gettytab"
      name="/etc/gettytab">に記述されています.)
      のモデムが接続されていることを示しています. このポートの端末タイプは ``dialup'' です.
      またこのポートは, ``on'' すなわちログイン可能であり,
      ``insecure'' これは <tt/root/ がこのポートから直接ログインするのは,
      許可されていないということを意味します. このようなダイヤルインポートに対しては, 
      <tt/ttydX/ のエントリを使用してください. 

      <p>これが一般的な, ターミナルタイプとして ``dialup'' を使う方法です. 
      多くのユーザーは, .profile や .login で, login 時の端末タイプが dialup であった場合には,
      実際の端末タイプをユーザーに問い合わせるように設定しています.
      この例は, ポートが ``insecure'' でした. このポートで <tt/root/ になるには,
      一般ユーザーとしてログインし, それから ``<htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?su"
      name="su">'' を使って <tt/root/ になってください.
      もし, ``secure'' を指定したならば, 直接 <tt/root/ がそのポートからログインできます. 

      <p><htmlurl url="http://www.freebsd.org/cgi/man.cgi?ttys"
      name="/etc/ttys"> に変更を加えた後は, hungup もしくは<tt/HUP/ シグナルを
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?init"
      name="init"> プロセスに送る必要があります. 

      <verb>
        kill -HUP 1
      </verb>

      <p>この操作は init プロセスに <htmlurl url="http://www.freebsd.org/cgi/man.cgi?ttys"
      name="/etc/ttys"> を再読み込みさせます. 
      これにより, init プロセスは getty プロセスを すべての ``on'' となっているポートに起動させます.
      次のようにして, ポートがログイン可能かを知ることができます. 

      <verb>
        ps -ax | grep '[t]tyd1'
      </verb>

      <p>ログイン可能であれば, 次のような出力が得られるはずです. 

      <verb>
        747 ??  I      0:00.04 /usr/libexec/getty std.57600 ttyd1
      </verb>

    <sect1>
      <heading>ダムターミナルを FreeBSD マシンに接続するにはどうしたらよいのでしょうか?</heading>

      <p>もし, 他のコンピューターを FreeBSD の端末として接続したいのならば,
      お互いのシリアルポート間をつなぐヌルモデムケーブル
      [訳注: リバースケーブルもしくはクロスケーブルとも呼ばれます.]
      を用意してください. もし, 既製の端末を使う場合は, 付属するマニュアルを参照してください. 

      <p>そして, <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?ttys"
      name="/etc/ttys"> を上と同じように変更してください.
      例えば, WYSE-50 という端末を 5 番目のポートに接続するならば,
      次のようなエントリを使用してください.

      <verb>
        ttyd4 "/usr/libexec/getty std.38400" wyse50 on secure
      </verb>

      <p>この例は, <tt>/dev/ttyd4</tt> ポートにノンパリティー,
      端末タイプが wyse50, 通信速度が 38400 bps (<tt/std.38400/ : この設定は, 
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?gettytab"
      name="/etc/gettytab"> に記述されています.) の端末が存在しており,
      <tt/root/ のログインが許可されている (secure) であることを示しています. 

    <sect1>
      <heading>どうして <tt/tip/ や <tt/cu/ が動かないのですか?</heading>

      <p>おそらくあなたのシステムでは <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip"> や <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?cu" name="cu"> は <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?uucp" name="uucp"> ユーザーか,
      <tt/dialer/ グループによってのみ実行可能なのでしょう. <tt/dialer/
      グループは, モデムやリモートシステムにアクセスするユーザーを管理するために,
      使用することができます.
      それには, /etc/group ファイルの dialer グループにあなた自身を追加してください. 

      <p>そうする代わりに, 次のようにタイプすることにより, あなたのシステムの全ユーザーが
      <tt/tip/ や <tt/cu/ を実行できるようになります. 

      <verb>
        # chmod 4511 /usr/bin/cu
        # chmod 4511 /usr/bin/tip
      </verb>

    <sect1>
      <heading>私の Hayes モデムはサポートされていないのですが, どうしたらいいのでしょうか. </heading>

      <p>実際, <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?tip"
      name="tip"> のオンラインマニュアルは古くなっています.
      すでに, Hayes ダイアラーが実装されています.
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?remote"
      name="/etc/remote"> ファイルで, ``<tt/at=hayes/'' と指定してください.

      <p>Hayes ドライバは, 最近のモデムの新しい機能である, <tt/BUSY/,
      <tt/NO DIALTONE/, <tt/CONNECT 115200/ などのメッセージを認識できるほど賢くはなく,
      単に混乱を起こすだけです. <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip"> を使う場合には,
      (<tt/ATX0&amp;W/とするなどして) これらのメッセージを表示させないようにしなくてはいけません. 

      <p>また, <tt/tip/ のダイヤルのタイムアウトは 60 秒です.
      モデムのタイムアウト設定はそれより短くすべきであり,
      そうしないと <tt/tip/ は通信に問題があると判断するでしょう.
      <tt/ATS7=45&amp;W/ を実行してください.

      <p>実際, デフォルトの <tt/tip/ は Hayes の完全なサポートをしているわけではありません.
      解決方法は <tt>/usr/src/usr.bin/tip/tip</tt> の下の<tt/tipconf.h/を変更することです.
      もちろん, これにはソース配布ファイルが必要です.

      <p>``<tt/#define HAYES 0/'' と記述されている行を ``<tt/#define HAYES1/'' と変更し,
      そして ``<tt/make/'' and ``<tt/make install/'' を実行します.
      これでうまく動作するでしょう.

    <sect1>
      <heading>これらの AT コマンドを入力するには?<label id="direct-at"></heading>

      <p><htmlurl url="http://www.freebsd.org/cgi/man.cgi?remote"
      name="/etc/remote"> ファイルの中で ``<tt/direct/'' エントリを作ります. 
      たとえばモデムが 1番目のシリアルポートである <tt>/dev/cuaa0</tt>に接続されている場合,
      次のようにします:

      <verb>
        cuaa0:dv=/dev/cuaa0:br#19200:pa=none
      </verb>

      <p>モデムがサポートする最大の bps レートを br フィールドに使います.
      そして <htmlurl url="http://www.freebsd.org/cgi/man.cgi?tip"
      name="tip cuaa0"> を実行すると, モデムが利用できるようになります.

      <p><tt>/dev/cuaa0</tt>がシステムに存在しない場合は, 次のようにします:

      <verb>
        # cd /dev
        # ./MAKEDEV cuaa0
      </verb>

      <p>または <tt/root/ になって以下のように <tt/cu/ コマンドを実行します:

      <verb>
        # cu -l``line'' -s``speed''
      </verb>

      <p>``line'' にはシリアルポートを指定します (例えば <tt>/dev/cuaa0</tt>).
      そして ``speed'' には接続する速度を指定します (例えば <tt>57600</tt>).
      その後 AT コマンドを実行したら, <tt>~.</tt>と入力すれば終了します.

    <sect1>
      <heading>pn 機能の <tt/@/ 記号が使えません!</heading>

      <p>電話番号 (pn) 機能の中での <tt/@/ 記号は, tip に <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?phones(5)" name="/etc/phones">
      にある電話番号を参照するように伝えます. しかし <tt/@/ の文字は
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?remote"
      name="/etc/remote"> のような設定ファイルの中では特殊文字となります.
      そこで, バックスラッシュを使ってエスケープを行います:

      <verb>
        pn=\@
      </verb>

    <sect1>
      <heading>コマンドラインから電話番号を指定するには?</heading>

      <p>``<tt/generic/'' エントリと呼ばれるものを <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?remote"
      name="/etc/remote"> に追加します.
      例えば, 次のようにします:

      <verb>
        tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
        tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:
      </verb>

      <p>そして ``<tt/tip -115200 5551234/'' のように利用できます.
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?tip"
      name="tip"> より <htmlurl url="http://www.freebsd.org/cgi/man.cgi?cu"
      name="cu"> を使いたい場合, cu の generic エントリを使います:

      <verb>
        cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:
      </verb>

      <p>そして ``<tt/cu 5551234 -s 115200/'' と実行します.

    <sect1>
      <heading>毎回 bps レートを入力しなければいけませんか?</heading>

      <p><tt/tip1200/ や <tt/cu1200/ 用のエントリを記述し, 適切な通信速度を br
      フィールドに設定します. <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?tip"
      name="tip"> は 1200 bps が正しいデフォルト値であるとみなすので,
      ``<tt/tip1200/'' エントリを参照します.
      もちろん 1200 bps を使わなければならないわけではありません.

    <sect1>
      <heading>ターミナルサーバを経由して複数のホストへアクセスしたいのですが. </heading>

      <p>毎回接続されるのを待って ``<tt/CONNECT &lt;host&gt;/'' と入力するかわりに,
      <tt/tip/ の <tt/cm/ 機能を使います. 例えば, <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?remote" name="/etc/remote">
      に次のようなエントリを追加します:

      <verb>
        pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
        muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
        deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cua02:br#38400:at=hayes:du:pa=none:pn=5551234:
      </verb>

      <p>これで, ``<tt/tip pain/'' や ``<tt/tip muffin/'' と実行すると
      pain や muffin のホストに接続することができ,
      ``<tt/tip deep13/'' を実行するとターミナルサーバに接続します.

    <sect1>
      <heading><tt/tip/ を使ってそれぞれのサイトの複数の回線に接続できますか?</heading>

      <p>これは大学に電話回線がいくつかあって,
      数千人の学生が接続しようとする場合によくある問題です. 

      <p>あなたの大学のエントリを <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?remote" name="/etc/remote">
      ファイルに作成して, <tt/pn/ のフィールドには <tt>\@</tt> を使います:

      <verb>
        big-university:\
        :pn=\@:tc=dialout
        dialout:\
        :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:
      </verb>

      <p>そして <htmlurl url="http://www.freebsd.org/cgi/man.cgi?phones"
      name="/etc/phones"> ファイルに大学の電話番号の一覧を書きます:

      <verb>
        big-university 5551111
        big-university 5551112
        big-university 5551113
        big-university 5551114
      </verb>

      <p><htmlurl url="http://www.freebsd.org/cgi/man.cgi?tip"
      name="tip"> は一連の電話番号を上から順に試みて, 
      最終的に接続できなければあきらめます. リトライを続けさせたい場合は,
      <tt/tip/ を while ループに入れて実行します. 

    <sect1>
      <heading>CTRL+P を 1回送るために 2度押す必要があるのはなぜ? </heading>

      <p>CTRL+P は通常 ``force (強制)'' 文字であり, <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip">
      に次の文字がリテラルデータであることを伝えます.
      force 文字は「変数の設定」を意味する <tt/~s/ エスケープによって,
      他の文字にすることができます. 

      <p>``<tt/~sforce=&lt;single-char&gt;/'' と入力して改行します.
      <tt/&lt;single-char&gt;/ は, 任意の 1 バイト文字です.
      <tt/&lt;single-char&gt;/ を省略すると NUL 文字になり,
      これは CTRL+2 や CTRL+SPACE を押しても入力できます.
      いくつかのターミナルサーバで使われているのを見ただけですが,
      <tt/&lt;single-char&gt;/ に SHIFT+CTRL+6 に割り当てるのもよいでしょう.

      <p><tt>&dollar;HOME/.tiprc</tt> に次のように定義することで,
      任意の文字を force 文字として利用できます:

      <verb>
        force=<single-char>
      </verb>

    <sect1>
      <heading>打ち込んだ文字が突然すべて大文字になりました??</heading>

      <p>CTRL+A を押してしまい, caps-lock キーが壊れている場合のために設計された
      ``<htmlurl url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip">''
      の ``raise character'' モードに入ったのでしょう.
      既に述べた <tt/~s/ を使って, ``raisechar'' をより適切な値に変更してください.
      もしこれら両方の機能を使用しないのであれば, force 文字と同じ設定にすることもできます.

      <p>以下は CTRL+2 や CTRL+A などを頻繁に使う必要のある Emacs ユーザにうってつけの
      .tiprc ファイルのサンプルです:

      <verb>
        force=^^
        raisechar=^^
      </verb>

      <p>^^ は SHIFT+CTRL+6 です.

    <sect1>
      <heading> <tt/tip/ でファイルを転送するには?</heading>

      <p>もし他の UNIX のシステムと接続しているなら,
      <tt/~p/ (送信) や <tt/~t/ (受信) でファイルの送受信ができます.
      これらのコマンドは, 相手のシステムの上で
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?cat"
      name="cat"> や <htmlurl url="http://www.freebsd.org/cgi/man.cgi?echo"
      name="echo"> を実行することで送受信をします. 書式は以下のようになります:

      <verb>
        ~p <ローカルのファイル名> [<リモートのファイル名>]
        ~t <リモートのファイル名> [<ローカルのファイル名>]
      </verb>

      <p>この方法ではエラーチェックを行いませんので,
      zmodem などの他のプロトコルを使った方がよいでしょう.

    <sect1>
      <heading> <tt/tip/ から zmodem を実行するには?</heading>

      <p>まず始めに, FreeBSD の ports コレクション (<htmlurl
      url="http://www.freebsd.org/cgi/ports.cgi?^lrzsz" 
      name="lrzsz">と <htmlurl
      url="http://www.freebsd.org/cgi/ports.cgi?^rzsz" name="rzsz">
      との, 2つの通信カテゴリーのプログラムのどちらか) をインストールします.

      <p>ファイルを受信するには, リモート側で送信プログラムを起動します.
      そして, エンターキーを押してから ``<tt/~C rz/'' (lrzsz をインストールした場合,
      ``<tt/~C lrz/'') と入力すると, ローカル側へのファイルの受信が始まります.

      <p>ファイルを送信するには, リモート側で受信プログラムを起動します.
      そして, エンターキーを押してから  ``<tt/~C sz &lt;files&gt;/''
      (lrzsz をインストールした場合, ``<tt/~C lsz &lt;files&gt;/'')
      と入力すると, リモート側へのファイルの送信が始まります.

    <sect1>
     <heading>設定が正しいのにもかかわらず,
     FreeBSD がシリアルポートを見付けられません. </heading>

     <p>マザーボードやシリアルカードが Acer の UART チップを使った物の場合,
     FreeBSD の sio ドライバでは正しく検出する事が出来ません. 
     この問題を解決するためには,
     <url url="http://www.lemis.com/serial-port-patch.html"
     name="www.lemis.com"> からパッチを入手してください.

  </sect>
