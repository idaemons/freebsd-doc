.\" Copyright (c) 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)mdoc.samples.7	8.2 (Berkeley) 12/30/93
.\" %FreeBSD: src/share/man/man7/mdoc.samples.7,v 1.28.2.9 2001/03/13 17:54:18 ru Exp %
.\"
.\" This tutorial sampler invokes every macro in the package several
.\" times and is guaranteed to give a worst case performance
.\" for an already extremely slow package.
.\"
.\" jpman %Id: mdoc.samples.7,v 1.4 1999/01/21 17:52:58 kuma Stab %
.\"
.\" WORD:	display		表示内容
.\" WORD:	angle bracket	カギ括弧 <>
.\" WORD:	keep		キープ
.\" WORD:	display		ディスプレイ
.\" WORD:	literal		リテラル
.\" WORD:	content macro	コンテントマクロ
.\" WORD:	command modifier	コマンド修飾子
.\" WORD:	enclosure	囲い
.\" WORD:	quoting		クォート
.\" WORD:	nest		入れ子
.\" WORD:	block ragged	凹凸ブロック
.\" WORD:	constant width character	定幅文字
.\"
.Dd December 30, 1993
.Os
.Dt MDOC.SAMPLES 7
.Sh 名称
.Nm mdoc.samples
.Nd
.Nm \-mdoc
を使って
.Bx
マニュアルを書くためのチュートリアルサンプル
.Sh 書式
.Nm man mdoc.samples
.Sh 解説
.Xr troff 1
用の
.Em コンテントベース
でかつ
.Em 領域ベース
なフォーマットパッケージである
.Nm \-mdoc
マクロパッケージを使って
.Bx
マニュアルを書くためのチュートリアルサンプルです。
前身である
.Xr \-man 7
パッケージはフォントの操作や他の写植方法の詳細は個々の作者に任せた
ページレイアウトベースのものでした。
.Nm \-mdoc
では、ページレイアウトマクロは
タイトル、セクションのヘッダ、ディスプレイ、リストのマクロからなる
.Em "ページ構造領域"
を形成しています。
ページ構造領域に加え、
さらにマニュアル領域および一般テキスト領域の 2 つの領域があります。
一般テキスト領域はテキストの一部をクォートしたり、強調するといったような作業を
実行するマクロとして定義されています。
マニュアル領域はコマンドやルーチン、それに
.Bx
の関連ファイルを記述するための日常使用されるインフォーマルな言葉の
サブセットであるマクロとして定義されています。
マニュアル領域のマクロはコマンド名、コマンド行の引数とオプション、
関数名、関数のパラメータ、パス名、変数名、他のマニュアルページへの
クロスリファレンスなどを扱います。
これらの領域の項目は作者とマニュアルページの将来のユーザの両者に
とって価値のあるものです。
マニュアル間で一貫性を高めることによって将来のドキュメントツールへの
移行が容易になることが望まれます。
.Pp
マニュアルのエントリは、実際の長さに関わらず、
また男女の区別をするような意図なしで、
.Ux
のマニュアルページを通して、単純に man ページとして参照されています。
.Sh さあ、始めよう
通常チュートリアルドキュメントは、そこに示された題材をすぐに使いたい時
に読むものですので、このドキュメントのユーザはせっかちな人だと
仮定しています。
このドキュメントの残りの部分で説明されている題材は以下のような構成に
なっています。
.Bl -enum -offset indent
.It
.Tn "TROFF に特有な表現"
.Bl -tag -width flag -compact -offset indent
.It "マクロの使用方法" 
.It "引数に空白文字を指定する"
.It "行末の空白文字 (警告)"
.It "特殊文字のエスケープ"
.El
.It
.Tn "MAN ページの分析"
.Bl -tag -width flag -compact -offset indent
.It "マニュアルページのテンプレート"
.El
.It
.Tn "タイトルマクロ"
.It
.Tn "マニュアル領域および一般テキスト領域の紹介"
.Bl -tag -width flag -compact -offset indent
.It "この名前には何が...?"
.It "一般的な構文"
.El
.It
.Tn "マニュアル領域"
.Bl -tag -width flag -compact -offset indent
.It "アドレス"
.It "作者名"
.It "引数"
.It "コンフィギュレーション宣言 (セクション 4 のみ)"
.It "コマンド修飾子"
.It "定義済みの変数"
.It "errno  (セクション 2 のみ)"
.It "環境変数"
.It "関数の引数"
.It "関数の宣言"
.It "フラグ"
.It "関数 (ライブラリルーチン)"
.It "関数の型"
.\" .It "ヘッダファイル (ソースコードを含む)"
.It "ライブラリ名"
.It "対話的なコマンド"
.It "名称"
.It "オプション"
.It "パス名"
.It "標準"
.It "変数"
.It "クロスリファレンス"
.El
.It
.Tn "一般テキスト領域"
.Bl -tag -width flag -compact -offset indent
.It "AT&T マクロ"
.It "BSD マクロ"
.It "FreeBSD/NetBSD/OpenBSD マクロ"
.It "UNIX マクロ"
.It "囲い/クォート マクロ"
.Bl -tag -width flag -compact -offset indent
.It "カギ括弧 <> によるクォート/囲い"
.It "角括弧 [] によるクォート/囲い"
.It "二重引用符マクロ/囲い"
.It "括弧 () によるクォート/囲い"
.It "一重引用符によるクォート/囲い"
.It "プレフィックスマクロ"
.El
.It "no\-op もしくは通常テキストマクロ"
.It "空白なしマクロ"
.It "セクションのクロスリファレンス"
.It "参考文献と引用"
.It "戻り値 (セクション 2 および 3 のみ)"
.It "商標名 (頭字語とタイプ名)"
.It "拡張引数"
.El
.It
.Tn "ページ構造領域"
.Bl -tag -width flag -compact -offset indent
.It "セクションヘッダ"
.It "段落と行スペース"
.It "キープ"
.It "例示とディスプレイ"
.It "フォントモード (強調、リテラル、およびシンボリック)"
.It "リストと列"
.El
.It
.Tn "定義済みの文字列"
.It
.Tn "診断"
.It
.Tn "GROFF、TROFF、および NROFF を使用したフォーマッティング"
.It
.Tn "バグ"
.El
.Sh TROFF に特有な表現
.Nm \-mdoc
パッケージは man ページを記述するプロセスを簡単にすることを
目的としています。
.Nm \-mdoc
を使うために
.Xr troff 1
のゴタゴタした詳細を学ぶ必要がないのが理想ですが、
いくつか片付けるべき避けられない制限事項があります。
また、このパッケージは高速で
.Em ない
ということも予め警告しておきます。
.Ss マクロの使用方法
.Xr troff 1
のように、マクロは
.Ql \&\.
(ドット文字)
を行頭に置き、それに続けて 2 文字からなるマクロの名称を指定することによって
呼び出されます。
引数はマクロの後にスペースで区切って指定することができます。
行頭にドット文字を指定することによって
.Xr troff 1
にそれに続く 2 文字をマクロ名として解釈するよう指示しています。
マクロを起動せずに、ある文脈の行の先頭に
.Ql \&\.
(ドット文字)
を置くためには、
.Ql \&\.
(ドット) の前にエスケープシーケンス
.Ql \e&
を指定します。
.Ql \e&
は文字通りスペース幅が 0 として解釈され、出力には現れません。
.Pp
一般的に
.Xr troff 1
マクロは引数を 9 つまで取ることができ、それ以上指定された引数は無視されます。
.Nm \-mdoc
でのほとんどのマクロは 9 つの引数を取ることができ、
限られた場合にのみ引数は次の行に続けて指定することができます (
.Sx 拡張引数
セクションを参照)。
いくつかのマクロは引用符に囲まれた引数を扱うことができます (下の
.Sx 引数に空白文字を指定する
セクションを参照)。
.Pp
.Nm \-mdoc
での一般テキスト領域とマニュアル領域のほとんどのマクロは特別であり、
その引数のリストは呼び出し可能なマクロ名として
.Em 解析
されます。
これは一般テキスト領域またはマニュアル領域のマクロ名に一致し、
呼び出し可能であると判断された引数リストの中の引数は、
実行されるか、それが処理される時に呼び出されることを意味しています。
この場合、引数はマクロ名にも関わらず、
.Ql \&\.
(ドット)
で前置されません。
このようにしてたくさんのマクロを入れ子にすることができます。
例えばオプションマクロ
.Ql \&.Op
はフラグマクロ
.Ql \&Fl
と引数マクロ
.Ql \&Ar
を
.Em 呼び出して
、オプションのフラグを引数とともに指定することができます。
.Bl -tag -width "\&.Op \&Fl s \&Ar bytes" -offset indent
.It Op Fl s Ar bytes
は
.Li \&.Op \&Fl s \&Ar bytes
によって生成される
.El
.Pp
2 文字からなる文字列をマクロ名として解釈されないようにするには、
その文字列の前にエスケープシーケンス
.Ql \e&
を指定します。
.Bl -tag -width "\&.Op \&Fl s \&Ar bytes" -offset indent
.It Op \&Fl s \&Ar bytes
は
.Li \&.Op \e&Fl s \e&Ar bytes
によって生成される
.El
.Pp
ここで文字列
.Ql \&Fl
と
.Ql \&Ar
はマクロとして解釈されていません。
本ドキュメントと関連のクイックリファレンスマニュアル
.Xr mdoc 7
を通して、
引数リストが呼び出し可能な引数として解析されるマクロは「解析される」、
引数リストから呼び出されることができるマクロは「呼び出し可能」
と表現します。
.Nm \-mdoc
のほとんどすべてのマクロは解析されるのですから、これは技術的には
.Em 不謹慎な
ことですが、常にマクロを「呼び出し可能である」とか「他のマクロを
呼び出すことができる」と表現するのは面倒なことであるため、
「解析される」という用語が使われています。
.Ss 引数に空白文字を指定する
ひとつ以上の空白文字を含む文字列をひとつの引数として指定したい場合が
よくあります。
これは 9 個を越える引数を指定できないという制限に対処したり、
引数のリストにある特有な配置をおこなうことが必要なマクロに引数を指定するような
場合に必要となることがあります。
たとえば、関数マクロ
.Ql \&.Fn
では最初の引数は関数名であり、残りの引数が関数のパラメータであることが
必要です。
.Tn "ANSI C"
の括弧で囲まれたパラメータリストにおける関数のパラメータの宣言の規定に
より、各パラメータは最低でも 2 語の文字列となります。
たとえば
.Fa int foo
のようになります。
.Pp
空白を含む引数を指定するには 2 通りの方法があります。
.Em 実装における注 :
解析の前に個々の引数を再割り当てすることによって、
引用符の間に空白を含めて渡すのが最も便利な方法なのですが、
.Tn AT&T
の
.Xr troff
のすべてのマクロを実装するには処理速度およびメモリ使用量の点で
かなり高価な方法となります。
.Xr groff
では高価な処理にはなりませんが、移植性のため、この方法は
空白を含めることが最も必要である以下のマクロだけに限っています。
.Pp
.Bl -tag -width 4n -offset indent -compact
.It Li \&Cd
コンフィギュレーション宣言 (セクション 4 の
.Sx SYNOPSIS )
.It Li \&Bl
リスト開始 (幅指定用)
.It Li \&Em
テキスト強調
.It Li \&Fn
関数 (セクション 2 と 4)
.It Li \&It
リストの項目
.It Li \&Li
リテラルテキスト
.It Li \&Sy
シンボリックテキスト
.It Li \&%B
書籍のタイトル
.It Li \&%J
定期刊行物のタイトル
.It Li \&%O
参照の追加的な注釈
.It Li \&%R
報告書のタイトル (参照の中で)
.It Li \&%T
書籍もしくは定期刊行物の中の記事のタイトル
.El
.Pp
空白を含む文字列を渡すのに、固定空白、すなわち詰め込まれない空白文字
.Ql \e\ 
を使う方法があります。すなわち、空白の前にエスケープ文字
.Ql \e
を指定する方法です。
この方法はどのマクロでも使うことができますが、1 行を越える長さのテキストの
調整の邪魔になるという副作用があります。
.Xr troff
では固定空白は他の印刷可能文字と同様に扱われ、通常期待されるように、
そこで文字列を空白や改行で分けることを行なわなくなります。
この方法は文字列が行の境界をまたがないであろう場合に有用です。
例えば、
.Bl -tag -width "fetch(char *str)" -offset indent
.It Fn fetch char\ *str
は
.Ql \&.Fn fetch char\e *str
によって生成される
.It Fn fetch "char *str"
は
.Ql \&.Fn fetch "\\*qchar *str\\*q"
でも生成される
.El
.Pp
もし
.Ql \e
や引用符が省かれると、
.Ql \&.Fn
は引数を 3 つ取り、その結果は
.Pp
.Dl Fn fetch char *str
.Pp
となります。
.Pp
パラメータのリストが改行の境界をまたぐ場合に何がおこるかについては、
.Sx バグ
のセクションを参照してください。
.Ss 行末の空白文字
.Xr troff
は行末に空白文字があると混乱してしまうことがあります。
<空白><行末>の文字シーケンスからすべての空白文字を取り除くのは良い予防策です。
どうしても行末に空白文字をおく必要性が出てきた場合は、
詰め込まれない空白とエスケープ文字
.Ql \e&
を使用することによって対応できます。
例えば、
.Ql string\e\ \e&
のようにします。
.Ss 特殊文字のエスケープ
改行
.Ql \en
のような特殊文字は
.Ql \e
を
.Ql \ee
で置き換える
(すなわち
.Ql \een
とする) ことによって、バックスラッシュを残して扱うことができます。
.Sh MAN ページの分析
man ページの本文はファイル
.Pa /usr/share/misc/mdoc.template
の基本テンプレートを使って容易に作り上げることができます。
.Pa /usr/share/examples/mdoc
にはいくつかのサンプルの man ページが収められています。
.Pp
.Ss マニュアルページのテンプレート
.Bd -literal -offset indent
\&.\e" 以下の項目はすべての man ページで必要な項目です。
\&.Dd 月\ 日, 年
\&.Os オペレーティングシステム [バージョン/リリース]
\&.Dt ドキュメントタイトル [セクション番号] [ボリューム]
\&.Sh NAME
\&.Nm 名称
\&.Nd 名称の 1 行での説明
\&.Sh SYNOPSIS
\&.Sh DESCRIPTION
\&.\e" 以下の項目については、必要に応じてコメントをはずして使用してく
\&.\e" ださい。
\&.\e" .Sh IMPLEMENTATION NOTES
\&.\e" この次の項目はセクション 2, 3, 9 でのみ必要な、関数の
\&.\e" 戻り値です。
\&.\e" .Sh RETURN VALUES
\&.\e" 次の項目はセクション 1, 6, 7, 8, 9 でのみ必要なものです。
\&.\e" .Sh ENVIRONMENT
\&.\e" .Sh FILES
\&.\e" .Sh EXAMPLES
\&.\e" 次の項目はセクション 1, 6, 7, 8, 9 でのみ必要なものです。
\&.\e"     ((シェルへの)コマンドの戻り値と fprintf/stderr の型の診断
\&.\e"      です。)
\&.\e" .Sh DIAGNOSTICS
\&.\e" .Sh COMPATIBILITY
\&.\e" 次の項目はセクション 2, 3, 9 でのみ必要な、エラーハンドリングと
\&.\e" シグナルハンドリングです。
\&.\e" .Sh ERRORS
\&.\e" .Sh SEE ALSO
\&.\e" .Sh STANDARDS
\&.\e" .Sh HISTORY
\&.\e" .Sh AUTHORS
\&.\e" .Sh BUGS
.Ed
.Pp
このテンプレートにおける最初の項目はマクロ
.Pq Li \&.Dd , \&.Os , \&.Dt
であり、それぞれドキュメントの日付、
man ページもしくは題材となっているソースの開発や変更のベースとなった
オペレーティングシステム、
.Pq Em 大文字で
man ページタイトルをそのページが属するマニュアルのセクション番号とともに
指定したもの、となっています。
これらのマクロはそのページを識別するものであり、後述の
.Sx タイトルマクロ
で議論されています。
.Pp
テンプレート中の残りの項目はセクションのヘッダ
.Pq Li \&.Sh
であり、それらのうち
.Sx NAME
と
.Sx SYNOPSIS
と
.Sx DESCRIPTION
は必須項目です。
これらのヘッダについては
.Sx マニュアル領域
を説明した後、
.Sx ページ構造領域
で議論されます。
いくつかのコンテントマクロはページレイアウトマクロの説明に
使われていますので、ページレイアウトマクロの前にコンテントマクロについて
読むことを推奨します。
.Sh タイトルマクロ
タイトルマクロはページ構造領域の最初の部分ですが、man ページを
前日に書き始めたいという人のために、最初に分けて記述されます。
3 つのヘッダマクロでドキュメントか man ページのタイトル、
オペレーティングシステム、および原著の日付を指定します。
これらのマクロはドキュメントの最初に一度だけ呼び出されるもので、
ヘッダとフッタを構成するためだけに使用されます。
.Bl -tag -width 6n
.It Li \&.Dt ドキュメントタイトル セクション番号 [ボリューム]
ドキュメントタイトルは man ページの主題であり、troff の制限により
.Tn 大文字
でなければいけません。
セクション番号は 1,\ ...,\ 9 となり、これが指定されると
ボリュームタイトルを省略してもかまいません。
.Pp
.Fx
では、次のセクション番号と解説について後述します:
.Pp
.Bl -column SMM -offset indent -compact
.It Li 1	FreeBSD General Commands Manual
.It Li 2	FreeBSD System Calls Manaul
.It Li 3	FreeBSD Library Calls Manual
.It Li 4	FreeBSD Kernel Interfaces Manual
.It Li 5	FreeBSD File Formats Manual
.It Li 6	FreeBSD Games Manual
.It Li 7	FreeBSD Miscellaneous Information Manual
.It Li 8	FreeBSD System Manager's Manual
.It Li 9	FreeBSD Kernel Developers Guide
.El
.Pp
ボリュームタイトルは任意のものか、以下のうちいずれかになります。
.\" .Cl
.\" USD	UNIX User's Supplementary Documents
.\" .Cl
.\" PS1	UNIX Programmer's Supplementary Documents
.Pp
.Bl -column SMM -offset indent -compact
.It Li AMD	UNIX Ancestral Manual Documents
.It Li SMM	UNIX System Manager's Manual
.It Li URM	UNIX Reference Manual
.It Li PRM	UNIX Programmer's Manual
.El
.Pp
デフォルトのボリュームは
セクション 1, 6, 7 では
.Li URM
、セクション 8 では
.Li SMM
、セクション 2, 3, 4, 5 では
.Li PRM
となっています。
.\" .Cl
.\" MMI	UNIX Manual Master Index
.\" .Cl
.\" CON	UNIX Contributed Software Manual
.\" .Cl
.\" LOC	UNIX Local Manual
.It Li \&.Os オペレーティングシステム リリース番号
オペレーティングシステムの名称には一般的な頭字語 (略称)
を使わなければなりません。
例えば、
.Tn BSD
や
.Fx
や
.Tn ATT
といったものです。
リリース番号は、例えば4.3, 4.3+Tahoe, V.3, V.4 というような各システム
での標準のリリースの命名法を使用します。
認識されない引数はページのフッタ中に記述された通りに表示されます。
以下にフッタの典型的な例を示します。
.Pp
.Dl \&.Os BSD 4.3
.Pp
や
.Dl \&.Os FreeBSD 2.2
.Pp
ローカルで作られたセットの例。
.Pp
.Dl \&.Os CS Department
.Pp
Berkeley でのデフォルトである、引数なしの
.Ql \&.Os
はサイト固有のファイル
.Pa /usr/share/tmac/mdoc/doc-common
において
.Tn BSD
として定義されています。
これは実際には
.Tn LOCAL
として定義すべきです。
.Ql \&.Os
マクロがない場合は、ページの左下角はみにくくなるであろうことに
注意してください。
.It Li \&.Dd 月 日, 年
日付は次のようにフォーマルな形式で記述しなければなりません。
.Pp
.Dl January 25, 1989
.El
.Sh マニュアル領域および一般テキスト領域の紹介
.Ss この名前には何が...?
マニュアル領域のマクロ名はコマンドやサブルーチン、それに関連ファイルを
説明するために使われている日常のインフォーマルな言葉から取られています。
この言葉と少し違うバリエーションのものが man ページを書く上での
3 つの異なった面を記述するのに使われます。
最初のものは、
.Nm \-mdoc
マクロ使用方法の説明です。
2 番目のものは
.Nm \-mdoc
マクロを用いた
.Ux
コマンドの記述です。
3 番目はコマンドを通常の言葉の感覚でユーザに示したものです。
これはすなわち、man ページのテキスト中でのコマンドの議論となります。
.Pp
最初のケースでは、
.Xr troff 1
マクロはそれ自身、一種のコマンドとなっています。
troff コマンドは一般的に以下のような形式をとります。
.Bd -filled -offset indent
\&.Va argument1 argument2 ... argument9
.Ed
.Pp
.Ql \&.Va
はマクロコマンドもしくは要求を示しており、それに続くものは
すべて引数として処理されます。
2 番目のケースでは、コンテントマクロを使用する
.Ux
コマンドの記述がもう少し含まれます。
典型的な
.Sx SYNOPSIS
コマンド行はこのように表示されます。
.Bd -filled -offset indent
.Nm filter
.Op Fl flag
.Ar infile outfile
.Ed
.Pp
ここで
.Nm filter
はコマンド名であり、角括弧で囲まれた文字列
.Fl flag
は
.Em フラグ
引数で、これは角括弧で囲むことによってオプションであることを示しています。
.Nm \-mdoc
の用語では
.Ar infile
と
.Ar outfile
は
.Em 引数
と称されています。
上の例のフォーマットを行なったマクロは以下のものです。
.Bd -literal -offset indent
\&.Nm filter
\&.Op \&Fl flag
\&.Ar infile outfile
.Ed
.Pp
3 番目のケースでは、コマンドの説明や構文に上記の例の両方が使われ、
さらに細かい記述が追加されるでしょう。
上の例での引数
.Ar infile
と
.Ar outfile
は
.Em オペランド
もしくは
.Em ファイル引数
として参照されます。
コマンド行の引数のリストはかなり長くなる場合もあります。
.Bl -tag -width make -offset indent
.It Nm make
.Op Fl eiknqrstv
.Op Fl D Ar variable
.Op Fl d Ar flags
.Op Fl f Ar makefile
.Bk -words
.Op Fl I Ar directory
.Ek
.Op Fl j Ar max_jobs
.Op Ar variable=value
.Bk -words
.Op Ar target ...
.Ek
.El
.Pp
ここではコマンド
.Nm make
について記述しており、
.Ar makefile
をフラグ
.Fl f
の引数としています。
またオプションのファイルオペランド
.Ar target
についても議論しています。
言葉での説明では、こういった詳細な記述が混乱を防いでくれますが、
.Nm \-mdoc
パッケージにはフラグ
.Em への
引数のためのマクロがありません。
その代わりに
.Ar target
のようなオペランドやファイル引数に使われる引数マクロ
.Ql \&Ar
が
.Ar variable
のようなフラグへの引数にも使われます。
この make コマンド行は以下の指定により生成されています。
.Bd -literal -offset indent
\&.Nm make
\&.Op Fl eiknqrstv
\&.Op Fl D Ar variable
\&.Op Fl d Ar flags
\&.Op Fl f Ar makefile
\&.Op Fl I Ar directory
\&.Op Fl j Ar max_jobs
\&.Op Ar variable=value
\&.Bk -words
\&.Op Ar target ...
\&.Ek
.Ed
.Pp
マクロ
.Ql \&.Bk
と
.Ql \&.Ek
は
.Sx キープ
セクションにおいて解説されています。
.Ss 一般的な構文
マニュアル領域と一般テキスト領域のマクロはいくつかの小さな違い
があるものの、同様な構文を使用しています。
.Ql \&.Ar ,
.Ql \&.Fl ,
.Ql \&.Nm ,
.Ql \&.Pa
は引数なしで呼び出された時のみ異なります。
.Ql \&.Fn
と
.Ql \&.Xr
は引数のリストの順番が異なります。
マクロ
.Ql \&.Op
と
.Ql \&.Fn
には入れ子の制限があります。
すべてのコンテントマクロが句読点を認識し、正しく扱うには、
各々の句読点文字が先行する空白で分離されている必要があります。
以下のように指定されている場合、
.Pp
.Dl \&.Li sptr, ptr),
.Pp
その結果は以下のようになります。
.Pp
.Dl Li sptr, ptr),
.Pp
ここでは句読点は認識されずすべての出力はリテラルなフォントで行なわれて
います。句読点が空白文字で区切られている場合、
.Pp
.Dl \&.Li "sptr , ptr ) ,"
.Pp
結果は以下のようになります。
.Pp
.Dl Li sptr , ptr ) ,
.Pp
今度は句読点が認識され、出力はデフォルトのフォントで行なわれ
リテラルフォントの文字列と区別されています。
.Pp
.Ql \e&
でエスケープすることによって句読点文字の特別な意味を取り除くことができます。
.Xr troff
はマクロ言語としての限界から、数学、論理学、もしくは以下の引用符の
集合のメンバを含んだ文字列を表現するのは困難です。
.Bd -literal -offset indent-two
\&{+,\-,/,*,\&%,<,>,<=,>=,=,==,&,`,',"}
.Ed
.Pp
.Xr troff
が文字によって示唆されている操作もしくは評価を実際に行なっていることが、
その問題の原因となっています。
.Ql \e&
でこれらをエスケープすることによって、これらの文字が予期せずに
評価されることを防止することができます。
最初のコンテントマクロは、以下の
.Ql \&.Ad
において、その典型的な構文が示されています。
.Sh マニュアル領域
.Ss アドレスマクロ
アドレスマクロは addr1[,addr2[,addr3]] の形式からなるアドレスを識別します。
.Pp
.Dl 使い方: .Ad address ... \*(Pu
.Bl -tag -width ".Ad f1 , f2 , f3 :" -compact -offset 14n
.It Li \&.Ad addr1
.Ad addr1
.It Li \&.Ad addr1\ .
.Ad addr1 .
.It Li \&.Ad addr1\ , file2
.Ad addr1 , file2
.It Li \&.Ad f1\ , f2\ , f3\ :
.Ad f1 , f2 , f3 :
.It Li \&.Ad addr\ )\ )\ ,
.Ad addr ) ) ,
.El
.Pp
.Ql \&.Ad
を引数なしで呼び出すのはエラーです。
.Ql \&.Ad
は他のマクロから呼び出し可能で解析されます。
.Ss 作者名
.Ql \&.An
マクロは文書化されている項目の作者の名前、もしくは実際の
マニュアルページの作者の名前を指定するために使われます。
名前の情報の後のすべての引数は句読点として扱われます。
.Pp
.Dl 使い方: .An author_name \*(Pu
.Bl -tag -width ".An Joe Author ) ) ," -compact -offset 14n
.It Li \&.An Joe\ Author
.An Joe Author
.It Li \&.An Joe\ Author\ ,
.An Joe\ Author ,
.It Li \&.An Joe\ Author\ \&Aq\ nobody@FreeBSD.ORG
.An Joe Author Aq nobody@FreeBSD.ORG
.It Li \&.An Joe\ Author\ )\ )\ ,
.An Joe Author ) ) ,
.El
.Pp
.Ql \&.An
マクロは解析され、呼び出し可能です。
.Ql \&.An
を引数なしで呼び出すのはエラーです。
.Pp
.Sx AUTHORS
セクションでは、
.Ql \&.An
要求は改行を引き起こし、各新規の名前がそれぞれの行に表示されます。
この動作が望ましくない場合、
.Bd -literal -offset indent
\&.An -nosplit
.Ed
.Pp
呼び出しで無効化可能です。
それぞれの行に表示させる動作に戻したい場合は、
.Bd -literal -offset indent
\&.An -split
.Ed
呼び出しを使用します。
.Ss 引数マクロ
引数マクロ
.Ql \&.Ar
はコマンド行の引数を参照する際に使用することができます。
.Pp
.Dl 使い方: .Ar argument ... \*(Pu
.Bl -tag -width ".Ar file1 file2" -compact -offset 15n
.It Li \&.Ar
.Ar
.It Li \&.Ar file1
.Ar file1
.It Li \&.Ar file1\ .
.Ar file1 .
.It Li \&.Ar file1 file2
.Ar file1 file2
.It Li \&.Ar f1 f2 f3\ :
.Ar f1 f2 f3 :
.It Li \&.Ar file\ )\ )\ ,
.Ar file ) ) ,
.El
.Pp
.Ql \&.Ar
が引数なしで呼び出されると、
.Ql Ar
として扱われます。
.Ql \&.Ar
マクロは解析され、呼び出し可能です。
.Ss コンフィギュレーション宣言 (セクション 4 のみ)
.Ql \&.Cd
マクロはセクション 4 のマニュアルにおいて、デバイスインタフェースの
.Xr config 8
による宣言の説明に使われます。
このマクロは引用符 (2 重引用符のみ) で囲まれた引数を取ることができます。
.Pp
.Bl -tag -width "device le0 at scode?" -offset indent
.It Cd "device le0 at scode?"
は
.Ql ".Cd device le0 at scode?"
によって生成されます。
.El
.Ss コマンド修飾子
コマンド修飾子は
.Ql \&.Cm
マクロがすべての引数の前にダッシュ文字を付けないことを除いて、
.Ql \&.Fl
(フラグ) コマンドと同じです。
伝統的にフラグはダッシュ文字に引き続いて指定されますが、
いくつかのコマンドやコマンドのサブセットはこの方法を使っていません。
コマンド修飾子はエディタコマンドのような対話的なコマンドでも
指定されることがあります。
.Sx フラグ
のセクションを参照してください。
.Ss 定義済みの変数
インクルードファイルにおいて定義されている変数は
.Ql \&.Dv
マクロによって指定します。
.Pp
.Dl 使い方: .Dv defined_variable ... \*(Pu
.Bl -tag -width ".Dv MAXHOSTNAMELEN" -compact -offset 14n
.It Li ".Dv MAXHOSTNAMELEN"
.Dv MAXHOSTNAMELEN
.It Li ".Dv TIOCGPGRP )"
.Dv TIOCGPGRP )
.El
.Pp
.Ql \&.Dv
を引数なしで呼び出すのはエラーです。
.Ql \&.Dv
は解析され、呼び出し可能です。
.Ss errno (セクション 2 のみ)
エラーマクロ
.Ql \&.Er
はセクション 2 のライブラリルーチンにおけるエラーの戻り値を指定します。
下記の 2 番目の例では
.Ql \&.Er
は一般テキスト領域マクロである
.Ql \&.Bq
(これはセクション 2 のマニュアルページで使われています) と共に使われています。
.Pp
.Dl 使い方: .Er ERRNOTYPE ... \*(Pu
.Bl -tag -width ".Bq Er ENOTDIR" -compact -offset 14n
.It Li \&.Er ENOENT
.Er ENOENT
.It Li \&.Er ENOENT\ )\ ;
.Er ENOENT ) ;
.It Li \&.Bq \&Er ENOTDIR
.Bq Er ENOTDIR
.El
.Pp
.Ql \&.Er
を引数なしで呼び出すのはエラーです。
.Ql \&.Er
は解析され、呼び出し可能です。
.Ss 環境変数
.Ql \&.Ev
マクロは環境変数を指定します。
.Pp
.Dl 使い方: .Ev argument ... \*(Pu
.Bl -tag -width ".Ev PRINTER ) ) ," -compact -offset 14n
.It Li \&.Ev DISPLAY
.Ev  DISPLAY
.It Li \&.Ev PATH\ .
.Ev PATH .
.It Li \&.Ev PRINTER\ )\ )\ ,
.Ev PRINTER ) ) ,
.El
.Pp
.Ql \&.Ev
を引数なしで呼び出すのはエラーです。
.Ql \&.Ev
は解析され、呼び出し可能です。
.Ss 関数の引数
.Ql \&.Fa
マクロは関数の引数 (パラメータ) を
マニュアルの
.Sx SYNOPSIS
のセクション外、もしくは
.Sx SYNOPSIS
のセクション内で参照する場合に使われます。
パラメータのリストが
.Ql \&.Fn
マクロでは長すぎる場合は、
囲って使うマクロ
.Ql \&.Fo
と
.Ql \&.Fc
を使わなければなりません。
.Ql \&.Fa
は構造体のメンバを参照する場合にも使われます。
.Pp
.Dl 使い方: .Fa function_argument ... \*(Pu
.Bl -tag -width ".Fa d_namlen\ )\ )\ ," -compact -offset 14n
.It Li \&.Fa d_namlen\ )\ )\ ,
.Fa d_namlen ) ) ,
.It Li \&.Fa iov_len
.Fa iov_len
.El
.Pp
.Ql \&.Fa
を引数なしで呼び出すのはエラーです。
.Ql \&.Fa
は解析され、呼び出し可能です。
.Ss 関数の宣言
.Ql \&.Fd
マクロは
.Sx SYNOPSIS
セクションにおいて、セクション 2 または 3 の関数の説明で使われます。
.Ql \&.Fd
マクロから他のマクロを呼び出すことはなく、他のマクロから呼び出すことも
できません。
.Pp
.Dl 使い方: .Fd include_file (or defined variable)
.Pp
.Sx SYNOPSIS
セクションにおいて、関数がすでに示されていて改行が入っていない場合、
.Ql \&.Fd
によって改行が挿入されます。
これによって前の関数呼び出しと次の関数の宣言の間に最適な行間が設定されます。
.Ss フラグ
.Ql \&.Fl
マクロはコマンド行のフラグを扱います。
フラグの前にはダッシュ
.Ql \-
が挿入されます。
対話的なコマンドのフラグでは、ダッシュがフラグの前には挿入されませんが、
.Ql \&.Cm
(コマンド修飾子) マクロは、ダッシュを付けないことを除き、同じ働きをします。
.Pp
.Dl 使い方: .Fl argument ... \*(Pu
.Bl -tag -width ".Fl \-s \-t \-v" -compact -offset 14n
.It Li \&.Fl
.Fl
.It Li \&.Fl cfv
.Fl cfv
.It Li \&.Fl cfv\ .
.Fl cfv .
.It Li \&.Fl s v t
.Fl s v t
.It Li \&.Fl -\ ,
.Fl - ,
.It Li \&.Fl xyz\ )\ ,
.Fl xyz ) ,
.El
.Pp
引数なしで
.Ql \&.Fl
マクロを指定すると、標準入力/標準出力を意味するダッシュとなります。
ひとつのダッシュに
.Ql \&.Fl
マクロを使用すると、2 つダッシュとなることに注意して下さい。
.Ql \&.Fl
マクロは解析され、呼び出し可能です。
.Ss 関数 (ライブラリルーチン)
.Ql \&.Fn
マクロは ANSI C の記法を規範としています。
.Bd -literal
使い方: .Fn [type] function [[type] parameters ... \*(Pu]
.Ed
.Bl -tag -width ".Fn .int align. .const * char *sptrsxx" -compact
.It Li "\&.Fn getchar"
.Fn getchar
.It Li "\&.Fn strlen ) ,"
.Fn strlen ) ,
.It Li \&.Fn "\\*qint align\\*q" "\\*qconst * char *sptrs\\*q" ,
.Fn "int align" "const * char *sptrs" ,
.El
.Pp
.Ql \&.Fn
を引数を指定せずに呼び出すのはエラーです。
.Ql \&.Fn
マクロは解析され、呼び出し可能です。他のマクロの呼び出しは
.Ql \&.Fn
の呼び出しの終了を意味することに注意して下さい
(閉じ括弧がその点で挿入されます)。
.Pp
9 個以上のパラメータをとる関数 (これは滅多にないことですが) では、
.Ql \&.Fo
マクロ (関数オープン) と
.Ql \&.Fc
マクロ (関数クローズ) を
.Ql \&.Fa
(関数引数) と共に使って、この制限を回避することができます。
以下にその例を示します。
.Bd -literal -offset indent
\&.Ft int
\&.Fo res_mkquery
\&.Fa "int op"
\&.Fa "char *dname"
\&.Fa "int class"
\&.Fa "int type"
\&.Fa "char *data"
\&.Fa "int datalen"
\&.Fa "struct rrec *newrr"
\&.Fa "char *buf"
\&.Fa "int buflen"
\&.Fc
.Ed
.Pp
これは以下のような結果になります。
.Bd -filled -offset indent
.Ft int
.Fo res_mkquery
.Fa "int op"
.Fa "char *dname"
.Fa "int class"
.Fa "int type"
.Fa "char *data"
.Fa "int datalen"
.Fa "struct rrec *newrr"
.Fa "char *buf"
.Fa "int buflen"
.Fc
.Ed
.Pp
.Ql \&.Fo
と
.Ql \&.Fc
マクロは解析され、呼び出し可能です。
.Sx SYNOPSIS
セクションでは、関数は常に行の先頭から開始されます。
.Sx SYNOPSIS
セクションにおいて、複数の関数が示されており、関数の型が示されない場合、
改行が挿入され、現在の関数名とその前の関数名の間に最適な改行量が設定されます。
現在、
.Ql \&.Fn
は troff の行の長さに対して、語の境界をチェックしておらず、予期しない
場所で改行が挿入されてしまうことがあります。
これは近い将来修正されるでしょう。
.Ss 関数の型
このマクロは
.Sx SYNOPSIS
セクションで使うものです。
man ページ中の他の場所でも問題なく使うことができますが、
セクション 2 と 3 の
.Sx SYNOPSIS
セクションでカーネルの通常の形式で関数の型を示すことがこのマクロの目的です
(このマクロは関数名が次の行に置かれるように改行を挿入します)。
.Pp
.Dl 使い方: .Ft type ... \*(Pu
.Bl -tag -width "\&.Ft struct stat" -offset 14n -compact
.It Li \&.Ft struct stat
.Ft struct stat
.El
.Pp
.Ql \&.Ft
は他のマクロからは呼び出せません。
.Ss 対話的なコマンド
.Ql \&.Ic
マクロは対話的なコマンド、もしくは内部コマンドを指定します。
.Pp
.Dl 使い方: .Ic argument ... \*(Pu
.Bl -tag -width ".Ic setenv , unsetenvxx" -compact -offset 14n
.It Li \&.Ic :wq
.Ic :wq
.It Li \&.Ic do while {...}
.Ic do while {...}
.It Li \&.Ic setenv\ , unsetenv
.Ic setenv , unsetenv
.El
.Pp
.Ql \&.Ic
を引数なしで呼び出すのはエラーです。
.Ql \&.Ic
マクロは解析され、呼び出し可能です。
.Ss ライブラリ名
.Ql \&.Lb
マクロは、関数がどのライブラリに組み込まれるかを指定します。
.Pp
.Dl 使い方: .Lb argument ... \*(Pu
.Pp
.Ql \&.Lb 
マクロに対して使用可能な引数と結果は次の通りです:
.Pp
.Bl -tag -width "libnetgraph" -compact -offset indent
.It Li "libc"
.Lb libc
.It Li "libc_r"
.Lb libc_r
.It Li "libcalendar"
.Lb libcalendar
.It Li "libcam"
.Lb libcam
.It Li "libcompat"
.Lb libcompat
.It Li "libcrypt"
.Lb libcrypt
.It Li "libdevstat"
.Lb libdevstat
.It Li "libdisk"
.Lb libdisk
.It Li "libedit"
.Lb libedit
.It Li "libfetch"
.Lb libfetch
.It Li "libipsec"
.Lb libipsec
.It Li "libipx"
.Lb libipx
.It Li "libkvm"
.Lb libkvm
.It Li "libm"
.Lb libm
.It Li "libmd"
.Lb libmd
.It Li "libnetgraph"
.Lb libnetgraph
.It Li "libposix1e"
.Lb libposix1e
.It Li "libskey"
.Lb libskey
.It Li "libusb"
.Lb libusb
.It Li "libutil"
.Lb libutil
.It Li "libvgl"
.Lb libvgl
.El
.Ss 名称マクロ
.Ql \&.Nm
マクロは文書のタイトルやサブジェクト名を指定するために使われます。
このマクロは最初に呼び出された時の引数を覚えておくという特性を持っており、
それは常にそのページのサブジェクト名であるべきです。
引数なしで呼び出されると
.Ql \&.Nm
は作者の作業を少なくするためだけの目的で、最初の名称を出力します。
注:
セクション 2 または 3 のドキュメントの関数名は
.Sx NAME
セクションにおいて
.Ql \&.Nm
で指定され、
.Sx SYNOPSIS
セクションや残りのセクションでは
.Ql \&.Fn
で指定されます。
.Xr csh 1
での
.Ql while
コマンドのキーワードのような対話的なコマンドでは
.Ql \&.Ic
マクロを使うべきです。
.Ql \&.Ic
はほとんど
.Ql \&.Nm
と同一ですが、
それが最初に使われたときの引数を記憶することはできません。
.Pp
.Dl 使い方: .Nm argument ... \*(Pu
.Bl -tag -width ".Nm mdoc.sample" -compact -offset 14n
.It Li \&.Nm mdoc.sample
.Nm  mdoc.sample
.It Li \&.Nm \e-mdoc
.Nm \-mdoc .
.It Li \&.Nm foo\ )\ )\ ,
.Nm foo ) ) ,
.It Li \&.Nm
.Nm
.El
.Pp
.Ql \&.Nm
マクロは解析され、呼び出し可能です。
.Ss オプション
.Ql \&.Op
マクロはコマンド行の残りのすべての引数を
オプションであることを示す角括弧で囲み、
末尾の句読点は角括弧の外に置きます。
.Ql \&.Oc
マクロと
.Ql \&.Oo
マクロは複数行に渡って使うことができます。
.Pp
.Dl 使い方: .Op options ... \*(Pu
.Bl -tag -width ".Op Fl c Ar objfil Op Ar corfil ," -compact -offset indent
.It Li \&.Op
.Op
.It Li ".Op Fl k"
.Op Fl k
.It Li ".Op Fl k ) ."
.Op Fl k ) .
.It Li ".Op Fl k Ar kookfile"
.Op Fl k Ar kookfile
.It Li ".Op Fl k Ar kookfile ,"
.Op Fl k Ar kookfile ,
.It Li ".Op Ar objfil Op Ar corfil"
.Op Ar objfil Op Ar corfil
.It Li ".Op Fl c Ar objfil Op Ar corfil ,"
.Op Fl c Ar objfil Op Ar corfil ,
.It Li \&.Op word1 word2
.Op word1 word2
.El
.Pp
.Ql \&.Oc
マクロと
.Ql \&.Oo
マクロ:
.Bd -literal -offset indent
\&.Oo
\&.Op \&Fl k \&Ar kilobytes
\&.Op \&Fl i \&Ar interval
\&.Op \&Fl c \&Ar count
\&.Oc
.Ed
.Pp
出力結果:
.Oo
.Op Fl k Ar kilobytes
.Op Fl i Ar interval
.Op Fl c Ar count
.Oc
.Pp
.Ql \&.Op
と
.Ql \&.Oc
と
.Ql \&.Oo
マクロは解析され、呼び出し可能です。
.Ss パス名
.Ql \&.Pa
マクロはパス名もしくはファイル名をフォーマットします。
.Pp
.Dl 使い方: .Pa pathname \*(Pu
.Bl -tag -width ".Pa /tmp/fooXXXXX ) ." -compact -offset 14n
.It Li \&.Pa /usr/share
.Pa /usr/share
.It Li \&.Pa /tmp/fooXXXXX\ )\ .
.Pa /tmp/fooXXXXX ) .
.El
.Pp
.Ql \&.Pa
マクロは解析され、呼び出し可能です。
.Ss 規格
.Ql \&.St
マクロは、規格の短縮名称を正式名称に置換します。
.Pp
.Dl 使い方: .St abbreviature
.Pp
使用可能な
.Dq 短縮名称/正式名称
の組は次の通りです:
.Bl -tag -width "-p1003.2-92XX." -compact -offset indent
.It Li "-ansiC"
.St -ansiC
.It Li "-ansiC-89"
.St -ansiC-89
.It Li "-ieee754"
.St -ieee754
.It Li "-iso8802-3"
.St -iso8802-3
.It Li "-isoC"
.St -isoC
.It Li "-isoC-99"
.St -isoC-99
.It Li "-p1003.1"
.St -p1003.1
.It Li "-p1003.1-88"
.St -p1003.1-88
.It Li "-p1003.1-90"
.St -p1003.1-90
.It Li "-p1003.1-96"
.St -p1003.1-96
.It Li "-p1003.1b-93"
.St -p1003.1b-93
.It Li "-p1003.1g-2000"
.St -p1003.1g-2000
.It Li "-p1003.2"
.St -p1003.2
.It Li "-p1003.2-92"
.St -p1003.2-92
.It Li "-susv2"
.St -susv2
.It Li "-xpg3"
.St -xpg3
.It Li "-xpg4"
.St -xpg4
.It Li "-xpg4.2"
.St -xpg4.2
.El
.Ss 変数
一般的な変数への参照です。
.Pp
.Dl 使い方: .Va variable ... \*(Pu
.Bl -tag -width ".Va char s ] ) ) ," -compact -offset 14n
.It Li \&.Va count
.Va count
.It Li \&.Va settimer ,
.Va settimer ,
.It Li \&.Va int\ *prt\ )\ :
.Va int\ *prt ) :
.It Li \&.Va char\ s\ ]\ )\ )\ ,
.Va char\ s ] ) ) ,
.El
.Pp
.Ql \&.Va
を引数なしで呼び出すのはエラーです。
.Ql \&.Va
マクロは解析され、呼び出し可能です。
.Ss マニュアルページのクロスリファレンス
.Ql \&.Xr
マクロは最初の引数にマニュアルページの名称を取り、もしあれば次の引数に
セクションのページ数か句読点を取ります。
すべての残りの引数は句読点と見なされます。
.Pp
.Dl 使い方: .Xr man_page [1,...,9] \*(Pu
.Bl -tag -width ".Xr mdoc 7 ) ) ," -compact -offset 14n
.It Li \&.Xr mdoc
.Xr mdoc
.It Li \&.Xr mdoc\ ,
.Xr mdoc ,
.It Li \&.Xr mdoc 7
.Xr mdoc 7
.It Li \&.Xr mdoc 7\ )\ )\ ,
.Xr mdoc 7 ) ) ,
.El
.Pp
.Ql \&.Xr
マクロは解析され、呼び出し可能です。
.Ql \&.Xr
を引数なしで呼び出すのはエラーです。
.Sh 一般テキスト領域
.Ss AT&T マクロ
.Bd -literal -offset indent -compact
使い方: .At [v6 | v7 | 32v | V.1 | V.4] ... \*(Pu
.Ed
.Bl -tag -width ".At v6 ) ," -compact -offset 14n
.It Li ".At"
.At
.It Li ".At v6 ."
.At v6 .
.El
.Pp
.Ql \&.At
マクロは解析
.Em されず
、呼び出し
.Em 不可能
です。
最大 2 つまでの引数を取ることができます。
.Ss BSD マクロ
.Dl 使い方: .Bx [Version/release] ... \*(Pu
.Bl -tag -width ".Bx 4.3 ) ," -compact -offset 14n
.It Li ".Bx"
.Bx
.It Li ".Bx 4.3 ."
.Bx 4.3 .
.El
.Pp
.Ql \&.Bx
マクロは解析され、呼び出し可能です。
.Ss FreeBSD/NetBSD/OpenBSD マクロ
.Bd -literal -offset indent -compact
使い方: .Fx [ Version.release ] ... \*(Pu
.Ed
.Bl -tag -width ".Fx 2.2 ) ," -compact -offset 14n
.It Li ".Fx 2.2 ."
.Fx 2.2 .
.El
.Pp
.Bd -literal -offset indent -compact
使い方: .Nx [ Version.release ] ... \*(Pu
.Ed
.Bl -tag -width ".Nx 1.4 ) ," -compact -offset 14n
.It Li ".Nx 1.4 ."
.Nx 1.4 .
.El
.Pp
.Bd -literal -offset indent -compact
使い方: .Ox [ Version.release ] ... \*(Pu
.Ed
.Bl -tag -width ".Ox 2.5 ) ," -compact -offset 14n
.It Li ".Ox 2.5 ."
.Ox 2.5 .
.El
.Pp
.Ql \&.Fx ,
.Ql \&.Nx ,
.Ql \&.Ox
マクロは解析され、呼び出し可能です。
最大 2 つまでの引数を取ることができます。
.Ss UNIX マクロ
.Dl 使い方: .Ux ... \*(Pu
.Bl -tag -width ".Ux 4.3 ) ," -compact -offset 14n
.It Li ".Ux"
.Ux
.El
.Pp
.Ql \&.Ux
マクロは解析され、呼び出し可能です。
.Ss 囲い/クォートマクロ
囲いの概念はクォートと似たものです。
1 つ以上の文字列が引用符や括弧のような文字のペアで囲まれている
オブジェクトを指します。
クォートと囲いという用語はこの文書を通して同じ意味で使われます。
ほとんどの 1 行の囲いマクロはクォート (quote) のヒントとするために、小文字の
.Ql q
で終了しますが、いくつかの例外があります。
各々の囲いマクロに対し、開始マクロと終了マクロのペアもあり、それぞれ小文字の
.Ql o
と
.Ql c
で終了します。
これらは 1 行以上のテキストに渡って使うことができますが、
入れ子にする場合に制限があります。
その中では 1 行形式のクォートマクロのみ使用することができます。
.Pp
.Bd -filled -offset indent
.Bl -column "クォート " "終了 " "開始 " "クォートされたリテラル " XX文字列XX
.Em " クォート	終了	開始	機能	結果"
\&.Aq	.Ac	.Ao	カギ括弧による囲い	<文字列>
\&.Bq	.Bc	.Bo	角括弧による囲い	[文字列]
\&.Dq	.Dc	.Do	2 重引用符	``文字列''
	.Ec	.Eo	囲い文字列 (XXによる)	XX文字列XX
\&.Pq	.Pc	.Po	括弧による囲い	(文字列)
\&.Ql			クォートされたリテラル	`st' または文字列
\&.Qq	.Qc	.Qo	まっすぐな 2 重引用符	"文字列"
\&.Sq	.Sc	.So	1 重引用符	`文字列'
.El
.Ed
.Pp
下記の不正なマクロを除き、すべてのクォートマクロは解析され、呼び出し可能です。
句読点がひとつずつ置かれていて、スペースで区切られていれば、
すべてのクォートマクロは句読点を適切に扱います。
クォートマクロは開く句読点、閉じる句読点
(訳注: 句読点には括弧なども含みます) を調べ、
それが囲む文字列より前か後かを決めます。
これによって、ある程度の入れ子が可能になっています。
.Bl -tag -width xxx,xxxx
.It Li \&.Ec , \&.Eo
これらのマクロは各々開始および終了の文字列を最初の引数に取ります。
.It Li \&.Ql
リテラルをクォートするマクロは
.Xr troff
では
.Xr nroff
と異なった処理を行ないます。
.Xr nroff
でフォーマットされた場合、クォート指定されたリテラルは常にクォートされます。
.Xr troff
でフォーマットされた場合は、アイテムの幅が固定幅文字 3 つ分より
狭い場合にのみクォートされます。
これはリテラル (固定幅) のフォントの変更があまり気づかれないものであるため、
短い文字列を良く見えるようにするためです。
.It Li \&.Pf
プレフィックスマクロは呼び出し可能ではありませんが、解析されます。
.Bl -tag -width "(namexx" -offset indent
.It Li ".Pf ( Fa name2"
は
.Pf ( Fa name2
となります。
.El
.Pp
.Ql \&.Ns
(空白なし) マクロはサフィックス機能と同様の作用があります。
.El
.Pp
クォートの例:
.Bl -tag -width ".Aq Pa ctype.h ) ,xxxxxxxx" -compact -offset indent
.It Li \&.Aq
.Aq
.It Li \&.Aq \&Ar ctype.h\ )\ ,
.Aq Ar ctype.h ) ,
.It Li \&.Bq
.Bq
.It Li \&.Bq \&Em Greek \&, French \&.
.Bq Em Greek , French .
.It Li \&.Dq
.Dq
.It Li ".Dq string abc ."
.Dq string abc .
.It Li ".Dq \'^[A-Z]\'"
.Dq \'^[A-Z]\'
.It Li "\&.Ql man mdoc"
.Ql man mdoc
.It Li \&.Qq
.Qq
.It Li "\&.Qq string ) ,"
.Qq string ) ,
.It Li "\&.Qq string Ns ),"
.Qq string Ns ),
.It Li \&.Sq
.Sq
.It Li "\&.Sq string
.Sq string
.El
.Pp
囲いマクロの入れ子についての良い例については、
オプションマクロ
.Ql \&.Op
を参照してください。
このマクロは上でリストされているような囲いマクロと同じベースの上に
作られています。
拡張引数リストマクロ
.Ql \&.Xo
と
.Ql \&.Xc
もまた同じルーチンをベースに作られており、
.Nm \-mdoc
マクロの使い方の非常に良い例となっています。
.Ss no\-op もしくは通常テキストマクロ
.Ql \&.No
マクロはマクロコマンド行において、コンテントマクロの構文形式に従うが、
フォーマットされては
.Em ならない
単語をハックするものです。
.Ss 空白なしマクロ
.Ql \&.Ns
マクロはマクロ間での不要な空白を除去します。
これはフラグと引数の間に空白を含まない古いスタイルの引数リストを使う場合に
便利です。
.Bl -tag -width ".Op Fl I Ns Ar directoryxx" -offset indent
.It Li ".Op Fl I Ns Ar directory"
これは以下の結果になります。
.Op Fl I Ns Ar directory
.El
.Pp
注: 
.Ql \&.Ns
マクロは他のマクロ名が続かなければ、スペースを除去したあとに
.Ql \&.No
マクロを常に起動します。
.Ql \&.Ns
マクロは解析され、呼び出し可能です。
.Ss セクションのクロスリファレンス
.Ql \&.Sx
マクロは同一文書内でのセクションのヘッダへの参照を指定します。
これは解析され、呼び出し可能です。
.Pp
.Bl -tag -width "Li \&.Sx FILES" -offset 14n
.It Li \&.Sx FILES
.Sx FILES
.El
.Ss 参考文献と引用
以下のマクロは多少なりとも参考文献を扱えるようにと意図したものです。
これらのマクロは、せいぜい参照スタイルの参考文献のサブセットを手動で
作成しやすくする程度です。
.Pp
.Bl -tag -width 6n -offset indent -compact
.It Li ".Rs"
参考文献の開始。
改行を挿入してから、参考文献の終了マクロが読み込まれるまで
参考文献の情報を収集する。
.It Li ".Re"
参考文献の終了。
参考文献が表示される。
.It Li ".%A"
参考文献の作者名。1 回の呼び出しにつき、作者名をひとつ指定する。
.It Li ".%B"
書籍のタイトル。
.It Li ".\&%C"
市 / 場所。
.It Li ".\&%D"
日付。
.It Li ".%J"
定期刊行物の名称。
.It Li ".%N"
発行番号。
.It Li ".%O"
追加情報。
.It Li ".%P"
ページ番号。
.It Li ".%R"
報告書の名称。
.It Li ".%T"
記事のタイトル。
.It Li ".%V"
巻数。
.El
.Pp
.Ql %
で始まるマクロは呼び出し不可能ですが、
呼び出し側に戻る商標名マクロだけは解析されます。
(現時点では予期できないことです。)
商標名のみ解析されるのは
.Xr troff Ns / Ns Xr ditroff
の出力をきれいにするためです。
.Ss 戻り値
.Ql \&.Rv
マクロは
.Sx RETURN VALUES
のセクションで使うテキストを生成します。
.Pp
.Dl 使い方: .Rv [-std function]
.Pp
.Ql \&.Rv -std atexit
これは以下のテキストを生成します。
.Pp
.Rv -std atexit
.Pp
.Fl std
オプションはセクション 2 と 3 のマニュアルページでのみ有効です。
.Ss 商標名 (頭字語とタイプ名)
商標名マクロは一般的に長さが 2 文字を越えるすべてが大文字の単語用
に使われる小さな大文字のマクロです。
.Pp
.Dl 使い方: .Tn symbol ... \*(Pu
.Bl -tag -width ".Tn ASCII" -compact -offset 14n
.It Li \&.Tn DEC
.Tn DEC
.It Li \&.Tn ASCII
.Tn ASCII
.El
.Pp
.Ql \&.Tn
マクロは解析され、他のマクロから呼び出し可能です。
.Ss 拡張引数
.Ql \&.Xo
と
.Ql \&.Xc
マクロでマクロの境界における引数リストを拡張することができます。
引数リストは
.Ql \&.Op
のようなすべての引数が 1 行中に指定されていることを前提としている
マクロの中では行に渡って拡張することができません。
.Pp
以下に空白モードマクロをスペーシングをオフにするために使った
.Ql \&.Xo
での例を示します。
.Bd -literal -offset indent
\&.Sm off
\&.It Xo Sy I Ar operation
\&.No \een Ar count No \een
\&.Xc
\&.Sm on
.Ed
.Pp
これは以下のような結果になります。
.Bd -filled -offset indent
.Bl -tag -width flag -compact
.Sm off
.It Xo Sy I Ar operation
.No \en Ar count No \en
.Xc
.Sm on
.El
.Ed
.Pp
例をもうひとつ:
.Bd -literal -offset indent
\&.Sm off
\&.It Cm S No \&/ Ar old_pattern Xo
\&.No \&/ Ar new_pattern
\&.No \&/ Op Cm g
\&.Xc
\&.Sm on
.Ed
.Pp
これは以下のような結果になります。
.Bd -filled -offset indent
.Bl -tag -width flag -compact
.Sm off
.It Cm S No \&/ Ar old_pattern Xo
.No \&/ Ar new_pattern
.No \&/ Op Cm g
.Xc
.Sm on
.El
.Ed
.Pp
囲いマクロを使った
.Ql \&.Xo
の他の例:
変数の値をテストして下さい。
.Bd -literal -offset indent
\&.It Xo
\&.Ic .ifndef
\&.Oo \e&! Oc Ns Ar variable
\&.Op Ar operator variable ...
\&.Xc
.Ed
.Pp
結果は以下の通りです。
.Bd -filled -offset indent
.Bl -tag -width flag -compact
.It Xo
.Ic .ifndef
.Oo \&! Oc Ns Ar variable
.Op Ar operator variable ...
.Xc
.El
.Ed
.Pp
上のすべての例では
.Ql \&.It
(リスト項目) マクロの引数リストに
.Ql \&.Xo
マクロを使用しています。
拡張マクロが使われることはあまりありません。
使われるとすれば、リスト項目の引数リストを拡張する場合です。
残念なことに、これが拡張マクロが最も懲り性であるところでもあります。
最初の 2 つの例では、スペーシングはオフになっています。
3 番目では、ある箇所にはスペーシングを入れることが望ましいのですが、
出力全体に入れたいわけではありません。
そのような状況でこれらのマクロが適切に動作するためには、
.Ql \&.Xo
と
.Ql \&.Xc
マクロが 3 番目の例にあるように指定されていることを確認してください。
.Ql \&.Xo
マクロが置かれた
.Ql \&.It
の引数リストに他のものが置かれると、スペーシングがどうなるかは予測不可能です。
この場合、
.Ql \&.Ns
(空白なしマクロ)
は行中の最初もしくは最後のマクロに指定してはいけません。
現在
.Bx
でリリースされている 900 のマニュアルページ (実際のページでは約 1500
ページ) のうち 15 のマニュアルページでのみしか
.Ql \&.Xo
が使われていません。
.Sh ページ構造領域
.Ss セクションヘッダ
以下にリストされている、最初の 3 つのセクションヘッダマクロ
.Ql \&.Sh
はすべての man ページで必須のものです。
残りのセクションヘッダはマニュアルページの作者の裁量において、
推奨されているものです。
.Ql \&.Sh
マクロは 9 つまでの引数を取ることができます。
これは解析されますが、呼び出し不可能です。
.Bl -tag -width ".Sh SYNOPSIS"
.It \&.Sh NAME
.Ql \&.Sh NAME (訳注: 名称)
マクロは必須のものです。
これが指定されていないと、ヘッダとフッタ、それにデフォルトの
ページレイアウトが設定されず、結果はかなり好ましくないものになるでしょう。
.Sx NAME
セクションは最低 3 つの項目からなります。
最初のものは名称マクロ
.Ql \&.Nm
であり、man ページのサブジェクトとなります。
2 番目のものは名称説明マクロ
.Ql \&.Nd
であり、サブジェクト名を 3 つめの項目、
すなわちその名称の説明と分離します。
説明に割り当てられるスペースは小さいものですので、
できるだけ簡潔で分かりやすいものでなければなりません。
.It \&.Sh SYNOPSIS
.Sx SYNOPSIS (訳注: 書式)
セクションはその man ページのサブジェクトとなっている項目の
典型的な使用法を説明します。
必須のマクロは
.Ql ".Nm" ,
.Ql ".Cd" ,
.Ql ".Fn"
のいずれかです。
(他には
.Ql ".Fo" ,
.Ql ".Fc" ,
.Ql ".Fd" ,
.Ql ".Ft"
のマクロも必要な場合があります。)
関数名マクロ
.Ql ".Fn"
はセクション 2 と 3 のマニュアルページにおいて必須のもので、
コマンドと一般名称マクロ
.Ql \&.Nm
はセクション 1, 5, 6, 7, 8 で必須の項目です。
セクション 4 のマニュアルでは
.Ql ".Nm"
か
.Ql ".Fd"
、もしくはコンフィギュレーションデバイス使用法マクロ
.Ql ".Cd"
が必要です。
その他のいくつかのマクロが下に示すような書式行を生成するために必要なこと
があります。
.Pp
.Bd -filled -offset indent
.Nm cat
.Op Fl benstuv
.Op Fl
.Ar
.Ed
.Pp
以下のマクロが使われています。
.Pp
.Dl \&.Nm cat
.Dl \&.Op \&Fl benstuv
.Dl \&.Op \&Fl
.Dl \&.Ar
.Pp
.Sy 注 :
マクロ
.Ql \&.Op ,
.Ql \&.Fl ,
.Ql \&.Ar
はパイプの文字
.Ql \*(Ba
を認識し、下記のようなコマンド行
.Pp
.Dl ".Op Fl a | Fl b"
.Pp
はうまくいきません。
.Xr troff
は通常 \*(Ba を特別のオペレータとして解釈します。
この他で \*(Ba が使える場合については
.Sx 定義済みの文字列
セクションを参照して下さい。
.It \&.Sh DESCRIPTION
.Sx DESCRIPTION (訳注: 解説)
セクションでの最初のテキストは、ほとんどの場合ではそのコマンド、
関数もしくはファイルについての短い段落で、オプションの構文リストと
それぞれの説明がそれに続きます。
そのようなリストを作成するには
リスト開始マクロ
.Ql \&.Bl
、リスト項目マクロ
.Ql \&.It
、リスト終了マクロ
.Ql \&.El
を使います (後述の
.Sx リストと列
セクションを参照)。
.El
.Pp
以下の
.Ql \&.Sh
のセクションヘッダはマニュアルページの好ましいレイアウトの一部であり、
一貫性を保つために適切に使われなければなりません。
これらは使われる順番にリストされています。
.Bl -tag -width 書式
.It \&.Sh ENVIRONMENT (訳注: 環境変数)
.Sx ENVIRONMENT
セクションは関連する環境変数を明らかにし、
それらの振舞や使用方法を示します。
.It \&.Sh EXAMPLES (訳注: 使用例、実行例)
使用例、実行例を作成するには様々な方法があります。
詳細については、下の
.Sx 例示とディスプレイ
のセクションを参照してください。
.It \&.Sh FILES (訳注: 関連ファイル)
man ページのサブジェクトによって使用されるか生成されるファイルで、
.Sx FILES
のセクション中でマクロ
.Ql \&.Pa
によってリストされます。
.It \&.Sh SEE ALSO (訳注: 関連項目)
.Sx SEE ALSO
セクションには、その man ページの題材に関する資料への参照と
他の関連する man ページへのクロスリファレンスが記載されます。
クロスリファレンスは
.Ql \&.Xr
マクロによって指定されます。
.Sx SEE ALSO
セクションでのクロスリファレンスはセクション番号順に並べ、
セクション中ではカンマで区切ってアルファベット順に並べなければなりません。
以下に例を示します。
.Pp
.Xr ls 1 ,
.Xr ps 1 ,
.Xr group 5 ,
.Xr passwd 5
.Pp
ここで参考スタイルである
.Xr refer 1
は適応されていません。
.It \&.Sh STANDARDS (訳注: 規格)
コマンドやライブラリ関数やファイルが、
.St -p1003.2
や
.St -ansiC
のような特定の実装によるものであれば、ここで記述します。
もしコマンドがどの規格にも基づいていなければ、その歴史は
.Sx HISTORY
のセクションで説明されなければなりません。
.It \&.Sh HISTORY (訳注: 歴史)
特定の規格に基づいていないコマンドは、
このセクションでその歴史の概要が説明されるべきです。
.It \&.Sh AUTHORS (訳注: 作者)
クレジットが必要であれば、ここで入れます。
人物名を指定するには
.Ql \&.An
マクロを使用すべきです。
.It \&.Sh DIAGNOSTICS (訳注: 診断)
コマンドからの診断はこのセクションに入れます。
.It \&.Sh ERRORS (訳注: エラー)
特定のエラーハンドリング、特にライブラリ関数
(man ページのセクション 2, 3, 9) でのエラーハンドリングは、ここで説明します。
.Ql \&.Er
マクロが errno を記述するために使われます。
.It \&.Sh BUGS (訳注: バグ)
あきらかな問題はここで記述します。
.El
.Pp
ユーザ指定の
.Ql \&.Sh
セクションを追加することができます。
たとえば、このセクションは以下のように設定されています。
.Bd -literal -offset 14n
\&.Sh ページ構造領域
.Ed
.Ss 段落と行スペース
.Bl -tag -width 6n
.It \&.Pp
.Ql \&.Pp
段落コマンド
は必要な場合に行スペースを指定するために使われます。
このマクロは
.Ql \&.Sh
マクロや
.Ql \&.Ss
マクロのあと、それに
.Ql \&.Bl
マクロの前では必要ありません。
(
.Ql \&.Bl
マクロは -compact フラグが指定されていなければ、縦方向の距離を宣言します
)。
.El
.\" This worked with version one, need to redo for version three
.\" .Pp
.\" .Ds I
.\" .Cw (ax+bx+c) \ is\ produced\ by\ \&
.\" .\".Cw (ax+bx+c) \&.Va_by_) \&_and_\& \&[?/]m_b1_e1_f1[?/]\&
.\" .Cl Cx \t\t
.\" .Li \&.Cx\ (
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Va ax
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Sy \+
.\" .Cx
.\" .Cl Cx \&(\&
.\" .Va ax
.\" .Cx +
.\" .Va by
.\" .Cx +
.\" .Va c )
.\" .Cx \t
.\" .Em is produced by
.\" .Cx \t
.\" .Li \&.Va by
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Sy \+
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Va c )
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Cx
.\" .Cx
.\" .Cw
.\" .De
.\" .Pp
.\" This example shows the same equation in a different format.
.\" The spaces
.\" around the
.\" .Li \&+
.\" signs were forced with
.\" .Li \e :
.\" .Pp
.\" .Ds I
.\" .Cw (ax\ +\ bx\ +\ c) \ is\ produced\ by\ \&
.\" .\".Cw (ax+bx+c) \&.Va_by_) \&_and_\& \&[?/]m_b1_e1_f1[?/]\&
.\" .Cl Cx \t\t
.\" .Li \&.Cx\ (
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Va a
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Sy x
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Cx \e\ +\e\ \e&
.\" .Cx
.\" .Cl Cx \&(\&
.\" .Va a
.\" .Sy x
.\" .Cx \ +\ \&
.\" .Va b
.\" .Sy y
.\" .Cx \ +\ \&
.\" .Va c )
.\" .Cx \t
.\" .Em is produced by
.\" .Cl Cx \t\t
.\" .Li \&.Va b
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Sy y
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Cx \e\ +\e\ \e&
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Va c )
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Cx
.\" .Cx
.\" .Cw
.\" .De
.\" .Pp
.\" The incantation below was
.\" lifted from the
.\" .Xr adb 1
.\" manual page:
.\" .Pp
.\" .Ds I
.\" .Cw \&[?/]m_b1_e1_f1[?/]\& is\ produced\ by
.\" .Cl Cx \t\t
.\" .Li \&.Cx Op Sy ?/
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Nm m
.\" .Cx
.\" .Cl Cx Op Sy ?/
.\" .Nm m
.\" .Ad \ b1 e1 f1
.\" .Op Sy ?/
.\" .Cx \t
.\" .Em is produced by
.\" .Cx \t
.\" .Li \&.Ar \e\ b1 e1 f1
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Op Sy ?/
.\" .Cx
.\" .Cl Cx \t\t
.\" .Li \&.Cx
.\" .Cx
.\" .Cw
.\" .De
.\" .Pp
.Ss キープ
現在実装されているキープは単語に対するものだけです。
それらは
.Ql \&.Bk
(キープ開始) マクロと
.Ql \&.Ek
(キープ終了) マクロです。
.Ql \&.Bk
に指定できるオプションは
.Fl words
のみであり、これはオプションの途中で改行が入らないようにするのに便利です。
コマンド行の引数を生成する例 (
.Sx この名前には何が...?
セクションを参照) において、キープは
.Xr nroff
がフラグと引数を別の行に分けないように使われています。
(実際には、オプションマクロがこの目的で使われていましたが、
オプションが行中にわたって散らばってしまうと
一般的に見栄えが悪くなるという理由により
.Xr troff
で右揃えのマージンを強制的に行なう (宗教的な) 決定がなされてから、
オプションマクロをこの目的で使わないようになりました。
キープマクロについてはもっと機能を向上する作業が必要であり、
.Fl line
オプションを追加していく必要があります。)
.Ss 例示とディスプレイ
ディスプレイには 5 つのタイプがあります。
即席 1 行インデントディスプレイ
.Ql \&.D1
、即席 1 行リテラルディスプレイ
.Ql \&.Dl
、それに
ディスプレイ開始マクロ
.Ql \&.Bd
とディスプレイ終了マクロ
.Ql \&.Ed
を使用するリテラルブロック、フィルブロックおよび凸凹ブロックです。
.Pp
.Bl -tag -width \&.Dlxx
.It Li \&.D1
(D-いち) インデントされたテキストを 1 行表示します。
このマクロは解析されますが、呼び出し不可能です。
.Pp
.D1 Fl ldghfstru
.Pp
これは次の指定で生成されたものです。
.Li \&.D1 \&Fl ldghfstru
.It Li \&.Dl
(D-エル)
インデントされた
.Em リテラル
テキストを 1 行表示します。
.Ql \&.Dl
マクロの例は本ファイルの中に渡って使われています。
これによって 1 行のテキストのインデント (表示) が可能になります。
このマクロは解析され、他のマクロを認識することができますが、
デフォルトのフォントは固定幅 (リテラル) にセットされています。
しかしながら、呼び出しは不可能です。
.Pp
.Dl % ls -ldg /usr/local/bin
.Pp
これは
.Li \&.Dl % ls -ldg /usr/local/bin
から生成されています。
.It Li \&.Bd
ディスプレイ開始です。
.Ql \&.Bd
によるディスプレイは
.Ql \&.Ed
マクロによって終了しなければなりません。
ディスプレイはディスプレイ内およびリスト内で入れ子にすることができます。
.Ql \&.Bd
は以下の書式をとります。
.Pp
.Dl ".Bd ディスプレイタイプ [-offset オフセット値] [-compact]"
.Pp
ディスプレイタイプは以下の 4 つのタイプの内の 1 つでなければならず、
インデント
.Ql \&.Bd
のオフセット値を指定することができます。
.Pp
.Bl -tag -width "file ファイル名  " -compact
.It Fl ragged
テキストのブロックをタイプされた通りに表示します。
右マージン (と左マージン) のエッジは左に不揃いに寄せられます。
.It Fl filled
フィル (フォーマット) されたブロックを表示します。
テキストのブロックがフォーマットされます
(エッジは左非揃えではなく、フィルされます)。
.It Fl literal
リテラルなブロックを表示します。
ソースコードや、単純にタブもしくはスペースで整えられたテキストで便利です。
.It Fl file Ar ファイル名
.Fl file
フラグに続く名称のファイルが読み込まれ、表示されます。
表示はリテラルなモードで行われ、タブは定幅文字 8 つ分に固定されますが、
ファイル中のすべての
.Xr troff/ Ns Nm \-mdoc
コマンドは解釈されます。
.It Fl offset Ar 文字列
.Fl offset
が以下の文字列のいずれかとともに指定されていると、
その文字列は次のテキストのブロックのインデントのレベルを示すものとして
解釈されます。
.Pp
.Bl -tag -width "indent-two" -compact
.It Ar left
ブロックを現在の左マージンに揃えます。
これは
.Ql \&.Bd
のデフォルトのモードです。
.It Ar center
ブロックを中央揃えにします。
残念ながら現時点では、
単にブロックの左側を仮想的な中央マージンに揃えるだけです。
.It Ar indent
デフォルトのインデント値もしくはタブの分だけインデントします。
デフォルトのインデント値はディスプレイ
.Ql \&.D1
でも使われ、これら 2 つのタイプのディスプレイを使った場合、
行が揃うことが保証されています。
このインデントは通常 6n か約 2/3 インチ (定幅文字 6 つ分) です。
.It Ar indent-two
デフォルトのインデント値の 2 倍分インデントします。
.It Ar right
これはブロックをページの右端から約 2 インチ離して
.Em 左
揃えします。
このマクロはちゃんと動作する必要があるのですが、
.Xr troff
ではまったくちゃんと動作してくれていません。
.El
.El
.It ".Ed"
ディスプレイ終了。
.El
.Ss フォントモード
マニュアルページのテキストの見栄えを変更するマクロは 5 つあります。
.Bl -tag -width \&.Emxx
.It \&.Em
テキストは
.Ql \&.Em
マクロで強調することができます。
強調の場合、通常イタリック体のフォントが使われます。
.Pp
.Dl 使い方: .Em argument ... \*(Pu
.Bl -tag -width ".Em vide infra ) ) ," -compact -offset 14n
.It Li ".Em does not"
.Em does not
.It Li ".Em exceed 1024 ."
.Em exceed 1024 .
.It Li ".Em vide infra ) ) ,"
.Em vide infra ) ) ,
.El
.Pp
.Ql \&.Em
マクロは解析され、呼び出し可能です。
.Ql \&.Em
を引数なしで呼び出すのはエラーです。
.It \&.Li
リテラルマクロ
.Ql \&.Li
は特殊文字や変数定数、その他タイプされた通りに表示する必要があるものに
使用することができます。
.Pp
.Dl 使い方: .Li argument ... \*(Pu
.Bl -tag -width ".Li cntrl-D ) ,"  -compact -offset 14n
.It Li \&.Li \een
.Li \en
.It Li \&.Li M1 M2 M3\ ;
.Li M1 M2 M3 ;
.It Li \&.Li cntrl-D\ )\ ,
.Li cntrl-D ) ,
.It Li \&.Li 1024\ ...
.Li 1024 ...
.El
.Pp
.Ql \&.Li
マクロは解析され、呼び出し可能です。
.It \&.Sy
シンボリック体強調マクロはシンボリックの意味でも
伝統的な英語の使いかたにおいても、
通常はボールドマクロとなっています。
.Pp
.Dl 使い方: .Sy symbol ... \*(Pu
.Bl -tag -width ".Sy Important Noticex" -compact -offset 14n
.It Li \&.Sy Important Notice
.Sy Important Notice
.El
.Pp
.Ql \&.Sy
マクロは解析され、呼び出し可能です。
.Ql \&.Sy
の引数は引用符で囲むことができます。
.It Li \&.Bf
フォントモード開始。
フォントモード
.Ql \&.Bf
は
.Ql \&.Ef
マクロで終了しなければなりません。
フォントモードは他のフォントモードと入れ子にすることができます。
.Ql \&.Bf
は次の構文を取ります。
.Pp
.Dl ".Bf フォントモード"
.Pp
フォントモードは以下の 3 つのタイプのうちのいずれかでなければなりません。
.Pp
.Bl -tag -width "file file_name  " -compact
.It Sy \&Em | Fl emphasis
強調モード。
.Ql \&.Em
マクロがテキストブロック全体に使われているのと同様です。
.It Sy \&Li | Fl literal
リテラルモード。
.Ql \&.Li
マクロがテキストブロック全体に使われているのと同様です。
.It Sy \&Sy | Fl symbolic
シンボリックモード。
.Ql \&.Sy
マクロがテキストブロック全体に使われているのと同様です。
.El
.It ".Ef"
フォントモードの終了。
.El
.Ss タグつきリストと列
リスト開始マクロ
.Ql ".Bl"
で開始されるリストにはいくつかのタイプがあります。
リスト中の項目は項目マクロ
.Ql ".It"
で指定され、各リストは
.Ql ".El"
マクロで終了しなければなりません。
リストはリスト自身やディスプレイの中で入れ子にすることができます。
列はリストの中で使うことができますが、
リストが列の中で使えるかどうかは検証されていません。
.Pp
さらに、タグの幅、リストのオフセット、コンパクトさ
(項目間の空白行が許されているかどうか) のような、
いくつかのリストの属性を指定することができます。
本ドキュメントのほとんどはタグ
.Pq Fl tag
スタイルリストでフォーマットされています。
各種リストタイプは、調子を変えるためにオーバーハング
.Pq Fl ohang
でリストしました。
このリストのタイプは
.Tn TeX
のユーザに非常に人気のあるものですが、tag リストで構成されたページを
何ページも読んだ後には幾分変に見えるでしょう。
以下のリストタイプを
.Ql ".Bl"
で使うことができます。
.Pp
.Bl -ohang -compact
.It Fl bullet
.It Fl item
.It Fl enum
これら 3 つは最も単純なリストのタイプです。
一旦
.Ql ".Bl"
マクロが与えられると、リスト中の項目は単に
.Ql ".It"
マクロによってのみ構成される行で指定されます。
例として、簡単な列挙リストのソーステキストは、このようになります。
.Bd -literal -offset indent-two
\&.Bl -enum -compact
\&.It
\&ひとつめはここ。
\&.It
\&そしてふたつめ。
\&.It
\&最後にみっつめはここ。
\&.El
.Ed
.Pp
これらの結果は以下のようになります。
.Pp
.Bl -enum -offset indent-two -compact
.It
ひとつめはここ。
.It
そしてふたつめ。
.It
最後にみっつめはここ。
.El
.Pp
簡単な bullet リスト構成の例を示します。
.Bd -literal -offset indent-two
\&.Bl -bullet -compact
\&.It
\&ひとつめの bullet。
\&.It
\&これはふたつめの bullet。
\&.El
.Ed
.Pp
その結果はこうなります。
.Bl -bullet -offset indent-two -compact
.It
ひとつめの bullet。
.It
これはふたつめの bullet。
.El
.Pp
.It Fl tag
.It Fl diag
.It Fl hang
.It Fl ohang
.It Fl inset
これらのリストタイプは
.Ql \&.It
マクロによって指定されている引数からラベルを生成します。
そして、
.Em inset
では、次のテキストへそのラベルを挿入します。
.Em hang
では、次のテキストをラベルの位置へインデントします。
.Em ohang
(オーバーハング) では、次のテキストをラベルの位置にぶら下げ、インデントしません。
.Em tag
では、タグつきテキストの形式にします。
ちなみに上のリストは
.Ql Fl ohang
リストタイプで構成されています。
.Ql \&.It
マクロは inset, hang, tag のリストタイプでのみ解析され、
呼び出し不可能です。
以下に inset ラベルの例を示します。
.Bl -inset -offset indent
.It Em tag
tag リスト (tag 段落とも呼ばれる) は、
Berkely マニュアルで使われているリストのうち最も一般的なタイプです。
.It Em diag (診断)
診断リストはセクション 4 の診断リストを生成するもので、
呼び出し可能なマクロが無視されることを除き、inset リストと似ています。
.It Em hang
hang ラベルは好みの問題です。
.It Em ohang
ohang ラベルはスペースに制限がある時に便利です。
.It Em inset
inset ラベルは段落のブロックを制御するのに便利で、
.Nm \-mdoc
マニュアルを他の形式に変換する時に役立ちます。
.El
.Pp
上の例を生成したソーステキストはこうなっています。
.Bd -literal -offset indent
\&.Bl -inset -offset indent
\&.It Em tag
\&tag リスト (tag 段落とも呼ばれる) は、
\&Berkely マニュアルで使われているリストのうち最も一般的なタイプです。
\&.It Em diag (診断)
\&診断リストはセクション 4 の診断リストを生成するもので、
\&呼び出し可能なマクロが無視されることを除き、inset リストと似ています。
\&.It Em hang
\&hang ラベルは好みの問題です。
\&.It Em ohang
\&ohang ラベルはスペースに制限がある時に便利です。
\&.It Em inset
\&inset ラベルは段落のブロックを制御するのに便利で、
\&.Nm \-mdoc
\&マニュアルを他の形式に変換する時に役立ちます。
\&.El
.Ed
.Pp
以下は 2 つの項目を持つ hang リストです。
.Bl -hang -offset indent
.It Em hang
ラベルがラベルの幅より小さいときには、
ラベルは tag リストと同じようになります。
.It Em 長い hang リストラベル
は、tag 段落のラベルとは異なり、
段落の中に埋め込まれます。
.El
.Pp
これを生成している元のテキストは以下の通りです。
.Bd -literal -offset indent
\&.Bl -hang -offset indent
\&.It Em hang
\&ラベルがラベルの幅より小さいときには、
\&ラベルは tag リストと同じようになります。
\&.It Em 長い hang リストラベル
\&は、tag 段落のラベルとは異なり、
\&段落の中に埋め込まれます。
\&.El
.Ed
.Pp
タグ幅を制御するためのオプションの幅指定を使ったタグつきリストは
以下の通りです。
.Pp
.Bl -tag -width "PAGEIN" -compact -offset indent
.It SL
プロセスが sleep している時間 (ブロックされた秒数)
.It PAGEIN
そのプロセスによるコアにロードされていないページへの参照によるディスク
.Tn I/O
の回数
.It UID
プロセスの所有者の数字表記によるユーザID
.It PPID
親プロセスの数字表記によるID、プロセスの優先度
(割り込み不可のウエイトであるときには非正値)
.El
.Pp
元のテキストは以下の通りです。
.Bd -literal -offset indent
\&.Bl -tag -width "PAGEIN" -compact -offset indent
\&.It SL
\&プロセスが sleep している時間 (ブロックされた秒数)
\&.It PAGEIN
\&そのプロセスによるコアにロードされていないページへの参照によるディスク
\&.Tn I/O
\&の回数
\&.It UID
\&プロセスの所有者の数字表記によるユーザID
\&.It PPID
\&親プロセスの数字表記によるID、プロセスの優先度
\&(割り込み不可のウエイトであるときには非正値)
\&.El
.Ed
.Pp
幅指定として以下のものを使うことができます。
.Bl -tag -width Ar -offset indent
.It Fl width Ar "\&Fl"
そのフラグでのデフォルトの幅を指定します。
すべての呼び出し可能なマクロは各々デフォルトの幅の値を持っています。
現在、
.Ql \&.Fl
の値は定幅文字 10 個分、もしくは約 5/6 インチとなっています。
.It Fl width Ar "24n"
定幅文字 24 個分の幅、もしくは約 2 インチの幅をセットします。
これが正しく動作するには
.Ql n
が必ず必要となります。
.It Fl width Ar "ENAMETOOLONG"
指定された文字列の固定長に幅をセットします。
.It Fl width  Ar "\\*qint mkfifo\\*q"
これも、指定された文字列の固定長に幅をセットします。
.El
.Pp
タグつきリストタイプで幅が指定されていないと、
.Ql \&.It
が最初に起動された時に適した幅を決定することが試みられます。
.Ql ".It"
の最初の引数が呼び出し可能なマクロであれば、そのマクロのデフォルトの幅が
そのマクロ名が幅として指定されたように使用されます。
しかしながら、そのリスト中に他の項目が別の呼び出し可能なマクロ名で
与えられていると、新しく入れ子となったリストとして処理されます。
.Sh 定義済みの文字列
以下の文字列はあらかじめ定義されているものであり、
troff の文字列解釈シーケンス
.Ql \&\e*(xx
もしくは
.Ql \&\e*x
を前に伴って使われます。
ここで、
.Em xx
もしくは
.Em x
は定義されている文字列の名称です。
解釈シーケンスはテキストのどこでも使うことができます。
.Pp
.Bl -column "文字列 " "Nroff " "Troff " -offset indent
.It Sy "文字列	Nroff	Troff"
.It Li "<=" Ta \&<\&= Ta \*(<=
.It Li ">=" Ta \&>\&= Ta \*(>=
.It Li "Rq" Ta "''" Ta \*(Rq
.It Li "Lq" Ta "``" Ta \*(Lq
.It Li "ua" Ta ^ Ta \*(ua
.It Li "aa" Ta ' Ta \*(aa
.It Li "ga" Ta \` Ta \*(ga
.\" .It Li "sL" Ta ` Ta \*(sL
.\" .It Li "sR" Ta ' Ta \*(sR
.It Li "q" Ta \&" Ta \*q
.It Li "Pi" Ta pi Ta \*(Pi
.It Li "Ne" Ta != Ta \*(Ne
.It Li "Le" Ta <= Ta \*(Le
.It Li "Ge" Ta >= Ta \*(Ge
.It Li "Lt" Ta < Ta \*(Gt
.It Li "Gt" Ta > Ta \*(Lt
.It Li "Pm" Ta +- Ta \*(Pm
.It Li "If" Ta infinity Ta \*(If
.It Li "Na" Ta \fINaN\fP Ta \*(Na
.It Li "Ba" Ta \fR\&|\fP Ta \*(Ba
.El
.Pp
.Sy 注 :
.Ql q
の名称がつけられている文字列は、1 文字であるため
.Ql \e*q
と書かなければなりません。
.Sh 診断
.Nm \-mdoc
は限られたデバッグ機能しか持っていませんが、
引数名と内部レジスタやマクロ名との衝突のような
潜在的なエラーを検出するのに役立ちます。
(A って何?)
レジスタは
.Xr troff
での演算用記憶クラスであり、1 文字か 2 文字の名称がついています。
.Xr troff
と
.Xr ditroff
での
.Nm \-mdoc
のすべての内部レジスタは
.Ql \&Ar
のように2 文字からなる <大文字><小文字> の形式か、
.Ql \&aR
のように <小文字><大文字> の形式か、
.Ql \&C\&1
のように <大文字もしくは小文字><数字> の形式を取ります。
さらに混乱することに、
.Xr troff
はそれ自身の内部レジスタを持ち、
それらすべては小文字 2 文字か、ドットに文字もしくはメタ文字が続く形式を取ります。
紹介例の 1 つに、
エスケープシーケンス
.Ql \e&
でマクロ名を解釈させない方法がありました。
これは内部レジスタ名にも有効です。
.Pp
.\" Every callable macro name has a corresponding register
.\" of the same name (<upper_case><lower_case>).
.\" There are also specific registers which have
.\" been used for stacks and arrays and are listed in the
.\" .Sx Appendix .
.\" .Bd -ragged -offset 4n
.\" [A-Z][a-z]	registers corresponding to macro names (example ``Ar'')
.\" [a-z][A-Z]	registers corresponding to macro names (example ``aR'')
.\" C[0-9]		argument types (example C1)
.\" O[0-9]		offset stack (displays)
.\" h[0-9]		horizontal spacing stack (lists)
.\" o[0-9]		offset (stack) (lists)
.\" t[0-9]		tag stack (lists)
.\" v[0-9]		vertical spacing stack (lists)
.\" w[0-9]		width tag/label stack
.\" .Ed
.\" .Pp
エスケープされていないレジスタ名が引数リストに指定されると、
予期できない振舞いとなります。
一般的には、テキストのかなり大きな部分が出力されるべきところに
出力されないとか、リストのタグのような小さな文字列が消えてしまうとか、
引数リストの中の引数のタイプが間違って解釈されるとかいうことが、起こり得ます。
きっとあなたのお母さんは、あなたにこんな面倒なことを覚えるようにとは
考えていないでしょう。
そこで、与えられた引数が有効か無効かを判断する方法があります。
そんなときには、
.Ql \&.Db
(デバッグ) マクロによってほとんどのマクロの引数リストがどう解釈されるか
を表示することができます。
.Ql \&.Pp
(段落) マクロのようなマクロはデバッグ情報を含んでいません。
呼び出し可能なマクロはすべてデバッグ情報を含んでおり、
疑いがある場合はいつでも
.Ql \&.Db
マクロをオンにすることを強くお勧めします。
.Pp
.Dl 使い方: \&.Db [on | off]
.Pp
以下の例では、
問題が故意に発生するようにされた部分の上と下で
デバッグマクロが指定されています
(フラグ引数
.Ql \&aC
は正しく動作するためには
.Ql \e&aC
でなければなりません)。
.Bd -literal -offset indent
\&.Db on
\&.Op Fl aC Ar file )
\&.Db off
.Ed
.Pp
この結果の出力は以下の通りです。
.Bd -literal -offset indent
DEBUGGING ON
DEBUG(argv) MACRO: `.Op'  Line #: 2
	Argc: 1  Argv: `Fl'  Length: 2
	Space: `'  Class: Executable
	Argc: 2  Argv: `aC'  Length: 2
	Space: `'  Class: Executable
	Argc: 3  Argv: `Ar'  Length: 2
	Space: `'  Class: Executable
	Argc: 4  Argv: `file'  Length: 4
	Space: ` '  Class: String
	Argc: 5  Argv: `)'  Length: 1
	Space: ` '  Class: Closing Punctuation or suffix
	MACRO REQUEST: .Op Fl aC Ar file )
DEBUGGING OFF
.Ed
.Pp
この情報の最初の行では呼び出されているマクロの名称が出力されています。
ここでは
.Ql \&.Op
とそれが現れた行番号が表示されています。
複数のファイルが処理されている場合
(特にテキストが他のファイルからインクルードされている場合)、
行番号は正しくないでしょう。
ファイルが 1 つだけの場合には正しい行番号が出力されます。
2 番目の行では引数の個数と引数
.Pq Ql \&Fl
とその長さが出力されています。
引数の長さが 2 文字であれば、
その引数が実行可能
(ゼロでない値を含むすべてのレジスタは実行可能なように見えます)
かどうかテストされます。
3 番目の行ではそのクラスで指定されているスペースとクラスタイプが
出力されています。
ここでの問題は引数 aC が実行不可能でなければならないことです。
クラスの 4 つのタイプは文字列、実行可能、閉じる句読点、開く句読点です。
最後の行では引数リスト全体が読み込まれた通りに表示されています。
次の例では問題の原因となっている
.Ql \&aC
がエスケープされています。
.Bd -literal -offset indent
\&.Db on
\&.Em An escaped \e&aC
\&.Db off
.Ed
.Bd -literal -offset indent
DEBUGGING ON
DEBUG(fargv) MACRO: `.Em'  Line #: 2
	Argc: 1  Argv: `An'  Length: 2
	Space: ` '  Class: String
	Argc: 2  Argv: `escaped'  Length: 7
	Space: ` '  Class: String
	Argc: 3  Argv: `aC'  Length: 2
	Space: ` '  Class: String
	MACRO REQUEST: .Em An escaped &aC
DEBUGGING OFF
.Ed
.Pp
.Ql \e&
シーケンスは長さが 0 となるために
引数
.Ql \e&aC
は先の例と同様に長さ 2 と表示されています。
しかし、
.Ql \e&aC
という名称のレジスタが見つからず、タイプは文字列と判断されています。
.Pp
この他の診断は使用方法を報告するものであり、
それ自身が説明を含んでいます。
.Sh GROFF, TROFF, NROFF
.Nm \-mdoc
パッケージは
.Xr groff
との互換モードは必要ではありません。
.Pp
このパッケージでは改ページと、
.Xr nroff
で改ページ時に通常挿入されるヘッダとフッタは禁止されており、
マニュアルをオンラインで効率良く見ることができるようになっています。
現在の所、
.Fl T Ns Ar ascii
が指定された
.Xr groff
はページ内容の無いファイル末の残りの部分まで出力します。
改ページを禁止することによって
.Xr nroff
による出力はハードコピーには適さないものとなっています。
サイト依存のスタイルファイル
.Pa /usr/src/share/tmac/doc-nroff
において 0 にセットすることができる
.Ql \&cR
の名称を持つレジスタが古いスタイルの振る舞いを実現するために用意されています。
.Sh 関連ファイル
.Bl -tag -width /usr/share/man0/template.doc -compact
.It Pa /usr/share/tmac/tmac.doc
マニュアルマクロパッケージ
.It Pa /usr/share/misc/mdoc.template
man ページを書くためのテンプレート
.It Pa /usr/share/examples/mdoc/*
man ページのいくつかの例
.El
.Sh 関連項目
.Xr man 1 ,
.Xr troff 1 ,
.Xr mdoc 7
.Sh バグ
あらかじめ定義されている文字列は文書において宣言されていません。
.Pp
セクション 3f はヘッダルーチンには追加されていません。
.Pp
.Ql \&.Nm
フォントは
.Sx NAME
セクションにおいて変更されるべきです。
.Pp
.Ql \&.Fn
は分割されるのを防止するために、
行の長さが短すぎないかどうかをチェックする必要があります。
ときどき、最後の括弧が分割されることがあり、
行がフィルモードであるときには全くおかしな結果になることがあります。
.Pp
リストマクロとディスプレイマクロはキープを行いませんが、
これはキープを行うべきです。
.\" Note what happens if the parameter list overlaps a newline
.\" boundary.
.\" to make sure a line boundary is crossed:
.\" .Bd -literal
.\" \&.Fn struct\e\ dictionarytable\e\ *dictionarylookup struct\e\ dictionarytable\e\ *tab[]
.\" .Ed
.\" .Pp
.\" produces, nudge nudge,
.\" .Fn struct\ dictionarytable\ *dictionarylookup char\ *h struct\ dictionarytable\ *tab[] ,
.\" .Fn struct\ dictionarytable\ *dictionarylookup char\ *h struct\ dictionarytable\ *tab[] ,
.\" nudge
.\" .Fn struct\ dictionarytable\ *dictionarylookup char\ *h struct\ dictionarytable\ *tab[] .
.\" .Pp
.\" If double quotes are used, for example:
.\" .Bd -literal
.\" \&.Fn \*qstruct dictionarytable *dictionarylookup\*q \*qchar *h\*q \*qstruct dictionarytable *tab[]\*q
.\" .Ed
.\" .Pp
.\" produces, nudge nudge,
.\" .Fn "struct dictionarytable *dictionarylookup" "char *h" "struct dictionarytable *tab[]" ,
.\" nudge
.\" .Fn "struct dictionarytable *dictionarylookup" "char *h" "struct dictionarytable *tab[]" ,
.\" nudge
.\" .Fn "struct dictionarytable *dictionarylookup" "char *h" "struct dictionarytable *tab[]" .
.\" .Pp
.\" Not a pretty sight...
.\" In a paragraph, a long parameter containing unpaddable spaces as
.\" in the former example will cause
.\" .Xr troff
.\" to break the line and spread
.\" the remaining words out.
.\" The latter example will adjust nicely to
.\" justified margins, but may break in between an argument and its
.\" declaration.
.\" In
.\" .Xr nroff
.\" the right margin adjustment is normally ragged and the problem is
.\" not as severe.
