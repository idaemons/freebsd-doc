.\" Copyright (c) 1996-1999 Whistle Communications, Inc.
.\" All rights reserved.
.\" 
.\" Subject to the following obligations and disclaimer of warranty, use and
.\" redistribution of this software, in source or object code forms, with or
.\" without modifications are expressly permitted by Whistle Communications;
.\" provided, however, that:
.\" 1. Any and all reproductions of the source or object code must include the
.\"    copyright notice above and the following disclaimer of warranties; and
.\" 2. No rights are granted, in any manner or form, to use Whistle
.\"    Communications, Inc. trademarks, including the mark "WHISTLE
.\"    COMMUNICATIONS" on advertising, endorsements, or otherwise except as
.\"    such appears in the above copyright notice or in the software.
.\" 
.\" THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND
.\" TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO
.\" REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,
.\" INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
.\" WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY
.\" REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS
.\" SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.
.\" IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES
.\" RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING
.\" WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
.\" PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY
.\" OF SUCH DAMAGE.
.\" 
.\" Author: Archie Cobbs <archie@whistle.com>
.\"
.\" %FreeBSD: src/sys/modules/netgraph/socket/ng_socket.8,v 1.4.2.3 1999/11/21 23:21:13 julian Exp %
.\" $Whistle: ng_socket.8,v 1.5 1999/01/25 23:46:27 archie Exp $
.\"
.Dd January 19, 1999
.\" jpman %Id: ng_socket.8,v 1.3 2000/01/03 03:14:54 horikawa Stab %
.Dt NG_SOCKET 8
.Os FreeBSD 4.0
.Sh 名称
.Nm ng_socket
.Nd netgraph ソケットノードタイプ
.Sh 書式
.Fd #include <netgraph/ng_message.h>
.Fd #include <netgraph/ng_socket.h>
.Sh 解説
.Nm socket
ノードは BSD ソケットであると同時に、netgraph ノードでもあります。
.Nm socket
ノードタイプを使うことで、ユーザモードプロセスが
BSD ソケットインタフェースを用いて、カーネル中の
.Xr netgraph 4
ネットワークサブシステムに関与できます。
netgraph ソケットを作成するには、プロセスは root 権限が必要ですが、
一旦作成されたソケットの場合、これを保持するプロセスならば
使用できます。
.Pp
新しい
.Nm socket
ノードを生成するには、
.Xr socket 2
システムコールを用いて、
プロトコルファミリ
.Dv PF_NETGRAPH
に属する
.Dv NG_CONTROL
型のソケットを新たに生成します。
このノードにより受信され、クッキーの値として
.Dv NGM_SOCKET_COOKIE
を持たない制御メッセージは、そのプロセスが
.Xr recvfrom 2
を用いて受信します。このとき、
ソケットアドレス引数は、送信側の netgraph アドレスを含む構造体
.Dv "struct sockaddr_ng"
です。逆に、
受信側のアドレスを構造体
.Dv "struct sockaddr_ng"
に入れて
.Xr sendto 2
を呼び出すことにより、どのようなノードに対しても制御メッセージを送信
できます。
.Xr bind 2
システムコールを用いて、大域 netgraph 名をノードに割り振る
ことができます。
.Pp
netgraph データパケットを送受信するためには、制御ソケットに加えて、
.Xr socket 2
を用いて
.Dv NG_DATA
ソケットを生成し、
.Nm socket
ノードに関連付ける必要があります。
.Dv NG_DATA
ソケットは、それらに関連するノードを自動的に持つわけではありません。
.Xr connect 2
システムコールを用いてノードを指定して結合します。
アドレス引数は、すでに生成した
.Nm socket
ノードの netgraph アドレスです。
1 回データソケットをノードに関連付けてしまうと、そのノードが
受信したすべてのデータパケットは
.Xr recvfrom 2
により読み込まれます。
そして、そのノードから送出されるすべてのパケットを
.Xr sendto 2
により書き出します。
データソケットの場合、構造体
.Dv "struct sockaddr_ng"
は、データを受信した
.Em フック(hook)
もしくは書き出すべき
.Em フック
の名前を含みます。
.Pp
特別な場合として、単純なプログラムで、netgraph データソケットを
標準入出力として使用できるようにする際には、
NULL の sockaddr ポインタを指定して
.Xr sendto  2
を呼び出すか、
.Xr send 2
か、
.Xr write 2
を呼び出しますが、これが成功するのは、
そのソケットノードにフックがちょうど一つだけ割り付けられて
(パスがあいまいさなく決定できて) いる場合に限ります
.Pp
netgraph ソケットを簡単に利用できるようにするためのユーザライブラリが
あります。
.Xr netgraph 3
を参照して下さい。
.Sh フック
このノードタイプは、(一意性がある限り) 任意の名前を持つフックをサポート
します。また、フックへの接続要求を常に受理します。
.Sh 制御メッセージ
このノードタイプは、汎用の制御メッセージに加えて、次に示す制御メッセージを
サポートします。
.Bl -tag -width foo
.It Dv NGM_SOCK_CMD_NOLINGER
このノードから最後のフックが削除されたときに、
.Dv NGM_SHUTDOWN
を受信したかのようにシャットダウンします。関連するソケットへのアクセスは、
.Er ENOTCONN
を返します。
.It Dv NGM_SOCK_CMD_LINGER
これは、デフォルトのモードです。最後のフックが削除されても、
ノードは存在し続けます。明示的にシャットダウンされない限り、
新しいフックを受理できる状態のままです。
.El
.Pp
.Dv NGM_SOCKET_COOKIE
か
.Dv NGM_GENERIC_COOKIE
以外のすべてのメッセージは、変更されずに
.Dv NG_CONTROL 
ソケットに渡されます。
.Sh シャットダウン
このノードタイプは、関連付けられている
.Dv NG_CONTROL
と
.Dv NG_DATA
ソケットが既にクローズされているか、
.Dv NGM_SHUTDOWN
制御メッセージを受信した場合に、シャットダウンされ、消滅します。
後の場合、オープンされているソケットに書き込もうとすると、
.Er ENOTCONN
が返されます。
既に
.Dv NGM_SOCK_CMD_NOLINGER
メッセージを受信していると、最後のフックをクローズすると同時に
そのノードのシャットダウン処理が開始されます。
.Sh バグ
どのようなデータを受信しても確実に無視できるようにフックを設定することが
できるにもかかわらず、
フックへの接続を拒否することはできません。
.Pp
カーネル内ノードに通知されるイベント (たとえば、新規フック、フック削除
など) のすべてが制御プロセスに通知されません。この目的のためには、
(制御ソケットに送出するために) ノードが発信するメッセージを
いくつか定義する必要があります。
.Sh 関連項目
.Xr socket 2 ,
.Xr netgraph 3 ,
.Xr netgraph 4 ,
.Xr ng_ksocket 8 ,
.Xr ngctl 8
.Sh 作者
Julian Elischer <julian@whistle.com>
