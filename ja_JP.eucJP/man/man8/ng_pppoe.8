.\" Copyright (c) 1996-1999 Whistle Communications, Inc.
.\" All rights reserved.
.\" 
.\" Subject to the following obligations and disclaimer of warranty, use and
.\" redistribution of this software, in source or object code forms, with or
.\" without modifications are expressly permitted by Whistle Communications;
.\" provided, however, that:
.\" 1. Any and all reproductions of the source or object code must include the
.\"    copyright notice above and the following disclaimer of warranties; and
.\" 2. No rights are granted, in any manner or form, to use Whistle
.\"    Communications, Inc. trademarks, including the mark "WHISTLE
.\"    COMMUNICATIONS" on advertising, endorsements, or otherwise except as
.\"    such appears in the above copyright notice or in the software.
.\" 
.\" THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND
.\" TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO
.\" REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,
.\" INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.
.\" WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY
.\" REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS
.\" SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.
.\" IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES
.\" RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING
.\" WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
.\" PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR
.\" SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY
.\" OF SUCH DAMAGE.
.\" 
.\" Author: Archie Cobbs <archie@whistle.com>
.\"
.\" %FreeBSD: src/sys/modules/netgraph/pppoe/ng_pppoe.8,v 1.4.2.3 1999/12/01 19:41:51 julian Exp %
.\" $Whistle: ng_pppoe.8,v 1.1 1999/01/25 23:46:27 archie Exp $
.\"
.\" jpman %Id: ng_pppoe.8,v 1.2 1999/12/19 08:54:57 horikawa Stab %
.Dd October 28, 1999
.Dt NG_PPPOE 8
.Os FreeBSD 4.0
.Sh 名称
.Nm ng_pppoe
.Nd RFC 2516 PPPOE プロトコル netgraph ノードタイプ
.Sh 書式
.Fd #include <net/ethernet.h>
.Fd #include <netgraph/ng_pppoe.h>
.Sh 解説
.Nm 
ノードタイプは PPPoE プロトコルを処理します。
これは、イーサネットフレームワークに対する
.Xr netgraph 4
拡張と共に使用され、
PPP エージェント (これは指定されていません) との間で
イーサネットパケットを転換したり挿入したりします。
.Pp
.Dv NGM_PPPOE_GET_STATUS
制御メッセージを使用して、
いつでも PPPOE モジュールの現在の状態を問い合わせることが可能です。
現在利用可能な統計情報は、入力と出力の全パケット数のみです。
本ノードは
.Dv NGM_TEXT_STATUS
制御メッセージはまだサポートしていません。
.Sh フック
本ノードタイプは次のフックをサポートします:
.Pp
.Bl -tag -width foobarbaz
.It Dv ethernet
通常、イーサネットノードに接続されるべきフックです。
.It Dv debug
現在使用されていません。
.It Dv [unspecified]
他の名前は、
PPP クライアントエージェントまたは ppp サーバエージェントに接続される、
セッションフックであると見倣されます。
.El
.Sh 制御メッセージ
本ノードタイプは、汎用制御メッセージをサポートし、
更に次のものもサポートします:
.Bl -tag -width foo
.It Dv NGM_PPPOE_GET_STATUS
本コマンドは状態情報を
.Dv "struct ngpppoestat"
に入れて返します:
.Bd -literal -offset 4n
struct ngpppoestat {
    u_int   packets_n;      /* ethernet から来たフレーム数 */
    u_int   packets_out;    /* ethernet へ送られたフレーム数*/
};
.Ed
.It Dv NGM_TEXT_STATUS
この汎用メッセージは、人間が読める形式のノード状態を返します。
(未実装です)
.It Dv NGM_PPPOE_CONNECT
指定された新規作成フックに対し、
そのセッションがクライアントとなる方法で状態機械に入るよう通知します。
フックは新規作成である必要があり、
サービス名は引数として指定可能です。
長さ 0 のサービス名の指定も正当です。
これはある種の DSL 設定ではよくあることです。
セッション要求パケットはイーサネット上でブロードキャストされます。
本コマンドは、後述の
.Dv ngpppoe_init_data
構造体を使用します。
.It Dv NGM_PPPOE_LISTEN
指定された新規作成フックに対し、
そのセッションがサーバリスナ (server listener) となる方法で
状態機械に入るよう通知します。
指定される引数は、listen 対象のサービス名です。
サービス長が長さ 0 の場合、すべてのサービス要求にマッチします。
マッチしたサービス要求は、変更されずに、
そのサービス開始に責任があるプロセスに渡されます。
このプロセスは、
この要求を検査して、要求に答えるために開始されるセッションへ渡します。
本コマンドは、後述の
.Dv ngpppoe_init_data
構造体を使用します。
.It Dv NGM_PPPOE_OFFER
指定された新規作成フックに対し、
そのセッションがサーバとなる方法で状態機械に入るよう通知します。
指定される引数は、提供するサービス名です。
長さ 0 のサービスも正当です。
状態機械は、起動サーバから要求パケットが転送されるのを待つ状態へ進みます。
一方、起動サーバは、
このパケットをおそらく LISTEN モードフック (前述) から受け取ったのでしょう。
このようにして、
元のセッション要求パケットに埋め込まれているセッションが必要とする情報は、
最終的にこの要求に対して応答する状態機械が使用可能となります。
セッション要求パケット受信時に、セッションネゴシエーションは進捗します。
本コマンドは、後述の
.Dv ngpppoe_init_data
構造体を使用します。
.Pp
前述の 3 個のコマンドは共通のデータ構造体を使用します:
.Bd -literal -offset 4n
struct ngpppoe_init_data {
    char    hook[NG_HOOKLEN + 1];   /* 監視するフック */
    u_int16_t       data_len;       /* サービス名の長さ */
    char    data[0];                /* 初期データはここです */
};
.Ed
.It Dv NGM_PPPOE_SUCCESS
本コマンドは、
本セッションを上記のいずれか 1 個のメッセージで開始したノードへ送られます。
本メッセージはセッションネゴシエーションの成功を報告します。
本コマンドは後述の構造体を使用し、
成功したセッションに対応するフック名を報告します。
.It Dv NGM_NGM_PPPOE_FAIL
本コマンドは、
本セッションを上記のいずれか 1 個のメッセージで開始したノードへ送られ、
状態変更を報告します。
本メッセージはセッションネゴシエーションの失敗を報告します。
本コマンドは後述の構造体を使用し、
失敗したセッションに対応するフック名を報告します。
本メッセージ送信直後にそのフックが削除されたかもしれません。
.It Dv NGM_NGM_PPPOE_CLOSE
本コマンドは、
本セッションを上記のいずれか 1 個のメッセージで開始したノードへ送られ、
状態変更を報告します。
本メッセージはセッションクローズ要求を報告します。
後述の構造体を使用し、
クローズされたセッションに対応するフックの名前を報告します。
本メッセージ送信直後にそのフックが削除されたかもしれません。
現在、このメッセージはまだ使用されておらず、
代りに「失敗した」というメッセージがクローズ時に受信されます。
.Pp
前述の 3 個のコマンドは共通のデータ構造体を使用します:
.Bd -literal -offset 4n
struct ngpppoe_sts {
    char    hook[NG_HOOKLEN + 1]; /* イベントセッションに
                                     関連するフック */
};

.El
.Sh シャットダウン
本ノードは、
.Dv NGM_SHUTDOWN
制御メッセージの受信時か、全フックが切断されたときか、
.Dv ethernet
フックが切断されたときにシャットダウンします。
.Sh 使用例
次のコードは、
.Dv libnetgraph
を使用して、
.Nm 
ノードを設定し、socket ノードとイーサネットノードへ接続します。
.Nm
ノードが既にイーサネットに接続している場合も扱えます。
その後、クライアントセッションを開始します。
.Bd -literal
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sysexits.h>
#include <errno.h>
#include <err.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <net/ethernet.h>

#include <netgraph.h>
#include <netgraph/ng_ether.h>
#include <netgraph/ng_pppoe.h>
#include <netgraph/ng_socket.h>
static int setup(char *ethername, char *service, char *sessname,
				int *dfd, int *cfd);

int
main()
{
	int  fd1, fd2;
	setup("xl0", NULL, "fred", &fd1, &fd2);
	sleep (30);
}

static int
setup(char *ethername, char *service, char *sessname,
			int *dfd, int *cfd)
{
	struct ngm_connect ngc;	/* connect */
	struct ngm_mkpeer mkp;	/* mkpeer */
	/******** nodeinfo 関連 **********/
	u_char          rbuf[2 * 1024];
	struct ng_mesg *const resp = (struct ng_mesg *) rbuf;
	struct hooklist *const hlist
			= (struct hooklist *) resp->data;
	struct nodeinfo *const ninfo = &hlist->nodeinfo;
	int             ch, no_hooks = 0;
	struct linkinfo *link;
	struct nodeinfo *peer;
	/**** pppoe セッションの接続用メッセージ *****/
	struct {
		struct ngPPPoE_init_data idata;
		char            service[100];
	}               message;
	/******** 小さなグラフのトラッキング用 ********/
	char            path[100];
	char            source_ID[NG_NODELEN + 1];
	char            pppoe_node_name[100];
	int             k;

	/*
	 * データと制御のソケットの作成
	 */
	if (NgMkSockNode(NULL, cfd, dfd) < 0) {
		return (errno);
	}
	/*
         * 問い合わせ情報に名前を尋ねることで、
	 * 要求された名前の ethernet ノードを探します
         */
	if (strlen(ethername) > 16)
		return (EINVAL);
	sprintf(path, "%s:", ethername);
	if (NgSendMsg(*cfd, path, NGM_GENERIC_COOKIE,
		      NGM_LISTHOOKS, NULL, 0) < 0) {
		return (errno);
	}
	/*
	 * コマンドが受け付けられたので、存在します。
         * 応答を待ちます (ほとんどの場合確実に既に待っているでしょう)。
	 */
	if (NgRecvMsg(*cfd, resp, sizeof(rbuf), NULL) < 0) {
		return (errno);
	}
	/**
	 * 次の情報がノードに関して使用可能です:
	 * ninfo->name		(文字列)
	 * ninfo->type		(文字列)
	 * ninfo->id		(u_int32_t)
	 * ninfo->hooks		(u_int32_t) (フック数)
	 * 正しい型であることを確認してください。
         * 後で mkpeer で使用する ID を取得します。
	 */
	if (strncmp(ninfo->type, NG_ETHER_NODE_TYPE,
		    strlen(NG_ETHER_NODE_TYPE)) != 0) {
		return (EPROTOTYPE);
	}
	sprintf(source_ID, "[%08x]:", ninfo->id);

	/*
	 * 既に接続されているフックを探します。
	 */
	for (k = 0; k < ninfo->hooks; k++) {
		/**
		 * 次の情報が各フックに関して使用可能です:
		 * link->ourhook	(文字列)
		 * link->peerhook	(文字列)
		 * peer->name		(文字列)
		 * peer->type		(文字列)
		 * peer->id		(u_int32_t)
		 * peer->hooks		(u_int32_t)
		 */
		link = &hlist->link[k];
		peer = &hlist->link[k].nodeinfo;

		/* debug フックを無視します */
		if (strcmp("debug", link->ourhook) == 0)
			continue;

		/* みなしごのフックが接続された場合、それを使用します */
		if (strcmp(NG_ETHER_HOOK_ORPHAN,
		    link->ourhook) == 0) {
			break;
		}
		/* 他のオプションは 'divert' フックです */
		if (strcmp("NG_ETHER_HOOK_DIVERT",
		    link->ourhook) == 0) {
			break;
		}
	}

	/*
	 * ここでフックを発見したかを確認します。
	 */
	if (k < ninfo->hooks) {
		if (strcmp(peer->type, NG_PPPOE_NODE_TYPE) == 0) {
			/*
			 * タイプ pppoe の場合、自分自身での作成は
			 * スキップし、既存のものを使用して継続します。
			 */
			sprintf(pppoe_node_name, "[%08x]:", peer->id);
		} else {
			/*
			 * 既に誰かがデータを一人占めしているので、
			 * エラーを返します。
			 * いつの日にか、デイジチェーンをサポート
			 * する予定です。
			 */
			return (EBUSY);
		}
	} else {

		/*
		 * ノード "ID" に対し、
		 * フック NG_ETHER_HOOK_ORPHAN 上で、
		 * タイプ pppoe のノード作成を試みます。
		 */
		snprintf(mkp.type, sizeof(mkp.type),
			 "%s", NG_PPPOE_NODE_TYPE);
		snprintf(mkp.ourhook, sizeof(mkp.ourhook),
			 "%s", NG_ETHER_HOOK_ORPHAN);
		snprintf(mkp.peerhook, sizeof(mkp.peerhook),
			 "%s", NG_PPPOE_HOOK_ETHERNET);
		/* メッセージを送信します */
		if (NgSendMsg(*cfd, source_ID, NGM_GENERIC_COOKIE,
			      NGM_MKPEER, &mkp, sizeof(mkp)) < 0) {
			return (errno);
		}
		/*
		 * 新規ノードの名前に関して作業します。
		 */
		sprintf(pppoe_node_name, "%s:%s",
			source_ID, NG_ETHER_HOOK_ORPHAN);
	}
	/*
	 * この時点で、pppoe ノードがイーサネットカードに接続されました。
	 * イーサネットは ethername: でアドレスされます。
	 * これに接続された pppoe ノードは pppoe_node_name: で
	 * アドレスされます。
	 * socket ノードを指定されたノードに接続します。
	 * リンクの両端で同じフック名を使用します。
	 */
	snprintf(ngc.path, sizeof(ngc.path), "%s", pppoe_node_name);
	snprintf(ngc.ourhook, sizeof(ngc.ourhook), "%s", sessname);
	snprintf(ngc.peerhook, sizeof(ngc.peerhook), "%s", sessname);

	if (NgSendMsg(*cfd, ".:", NGM_GENERIC_COOKIE,
		      NGM_CONNECT, &ngc, sizeof(ngc)) < 0) {
		return (errno);
	}
	/*
	 * メッセージを送り、開始するよう通知します。
	 */
	bzero(&message, sizeof(message));
	snprintf(message.idata.hook, sizeof(message.idata.hook),
				"%s", sessname);
	if (service == NULL) {
		message.idata.data_len = 0;
	} else {
		snprintf(message.idata.data,
			 sizeof(message.idata.data), "%s", service);
		message.idata.data_len = strlen(service);
	}
	/* セッション/フックへ、クライアントとして開始するよう通知します。
	if (NgSendMsg(*cfd, ngc.path,
		      NGM_PPPOE_COOKIE, NGM_PPPOE_CONNECT, &message.idata,
		      sizeof(message.idata) + message.idata.data_len) < 0) {
		return (errno);
	}
	return (0);
}
.Ed
.Sh 関連項目
.Xr netgraph 3 ,
.Xr netgraph 4 ,
.Xr ng_socket 8 ,
.Xr ng_ppp 8 ,
.Xr ngctl 8
.Rs
.%A L. Mamakos
.%A K. Lidl
.%A J. Evarts
.%A D. Carrel
.%A D. Simone
.%A R. Wheeler
.%T "A Method for transmitting PPP over Ethernet (PPPoE)"
.%O RFC 2516
.Re
.Sh 作者
Julian Elischer <julian@whistle.com>
