.\"
.\" %FreeBSD: src/sbin/ipfw/ipfw.8,v 1.63.2.26 2002/08/21 18:58:24 trhodes Exp %
.\"
.\" $FreeBSD$
.\"
.de NOIPFW
.br
(\\$1 NOT IN IPFW)
.br
..
.Dd August 13, 2002
.Dt IPFW 8
.Os
.Sh 名称
.Nm ipfw
.Nd IP ファイアウォールとトラフィックシェイパの制御プログラム
.Sh 書式
.Nm
.Op Fl cq
.Cm add
.Ar rule
.Nm
.Op Fl acdeftNS
.Brq Cm list | show
.Op Ar number ...
.Nm
.Op Fl f | q
.Cm flush
.Nm
.Op Fl q
.Brq Cm delete | zero | resetlog
.Op Cm set
.Op Ar number ...
.Pp
.Nm
.Cm set Oo Cm disable Ar number ... Oc Op Cm enable Ar number ...
.Nm
.Cm set move
.Op Cm rule
.Ar number Cm to Ar number
.Nm
.Cm set swap Ar number number
.Nm
.Cm set show
.Pp
.Nm
.Brq Cm pipe | queue
.Ar number
.Cm config
.Ar config-options
.Nm
.Op Fl s Op Ar field
.Brq Cm pipe | queue
.Brq Cm delete | list | show
.Op Ar number ...
.Pp
.Nm
.Op Fl q
.Oo
.Fl p Ar preproc
.Oo Fl D
.Ar macro Ns Op = Ns Ar value
.Oc
.Op Fl U Ar macro
.Oc
.Ar pathname
.Sh 解説
.Nm
とそのユーティリティは
.Fx
の
.Xr ipfw 4
ファイアウォールと
.Xr dummynet 4
トラフィックシェイパを制御するユーザインタフェースです。
.Pp
.Em 注:
このマニュアルページは 2002 年 7 月に導入され
.Nm ipfw2
としても知られている
.Nm
の新バージョンを参照しています。
ここに示すコマンドのリストは旧版のファイアウォールのスーパーセットです。
両者を区別する必要があるときは旧版を
.Nm ipfw1
と呼ぶことにします。
.Pp
.Nm ipfw2
は
.Fx
CURRENT の標準ですが、
.Fx
STABLE では、
.Cm options IPFW2
をつけてカーネルをコンパイルし、
.Cm -DIPFW2
をつけて
.Nm /sbin/ipfw
と
.Nm /usr/lib/libalias
を再コンパイルして再インストール
(
buildworld の前に
.Cm IPFW2=TRUE
を
.Nm /etc/make.conf
に追加すると同様の結果になります
)
しないと、今でも
.Nm ipf1
を使います。
.Pp
.Nm ipfw1
に存在しない機能の一覧は
.Sx IPFW2 拡張
セクションを参照して下さい。
.Pp
.Nm
の設定、もしくは
.Em ルールセット
は、1 から 65535 までの番号をつけられた
.Em ルール
のリストからなります。
パケットは
プロトコルスタックのたくさんの異なる箇所で
.Nm
に渡されます
(パケットの発信元と宛先に依存し、
.Nm
は同じパケットに対して複数回起動させられる可能性があります)。
ファイアウォールに渡されるパケットは
ファイアウォールの
.Em ルールセット
に書かれた各ルールに対して照合されます。
.Pp
一致した場合、一致したルールに対応するアクションが実行されます。
アクションと実際のシステムの設定によっては、
マッチしたルールの後のルールでさらに処理を行うために
パケットがファイアウォールに再注入されることがあります。
.Pp
.Nm
ルールセットには常に
.Em デフォルト
ルール (番号 65535) が含まれます。
このルールは変更できず、
全パケットにマッチします。
.Em デフォルト
ルールに関連付けられるアクションは
.Cm deny
か
.Cm allow
のどちらかになりますが、
これはどのようにカーネルを設定したかに依存します。
.Pp
ルールセットが
.Cm keep-state
または
.Cm limit
のオプション付きのルールを含む場合、
.Nm
は
.Em ステートフル (状態依存型)
で動作します。すなわち、あるマッチの結果、
マッチしたパケットのパラメータにちょうど一致するルールが
動的に生成されます。
.Pp
これらの動的ルールの生存時間は有限で、
.Cm check-state
または
.Cm keep-state
または
.Cm limit
ルールが最初に生じた場所でチェックされます。
動的ルールは、正当なトラフィックをオンデマンドで
ファイアウォールを通過させるために用いることが普通です。
.Nm
のステートフルな動作について更に情報が必要ならば、
以下の
.Sx ステートフルファイアウォール
セクションと
.Sx 使用例
セクションを参照して下さい。
.Pp
全てのルール(動的ルールを含む)は、
関連するカウンタをいくつか持っています:
パケットカウント、バイトカウント、ログカウント、
最後にマッチした時刻を示すタイムスタンプ。
カウンタは、
.Nm
コマンドによって表示することができ、またリセットすることができます。
.Pp
ルールの追加は
.Cm add
コマンドにて可能です。
個別、またはグループでのルールの削除は
.Cm delete
コマンドにて可能であり、すべてのルールの削除は
.Cm flush
コマンドにて可能です。
ルールの表示
(オプションでカウンタ内容を含めることができます)
は、
.Cm show
コマンドおよび
.Cm list
コマンドにて可能です。
最後に、カウンタのリセットは
.Cm zero
コマンドおよび
.Cm resetlog
コマンドにて可能です。
.Pp
また、各ルールは 32 の
異なる
.Em セット
の 1 つに所属し、
セットに対するアトミックな操作、例えば
有効化・無効化・セットの入れ換え・セット内の全ルールを別のセットへ移動・
セット内の全ルールの削除などを行うための
.Nm
コマンドがあります。
これらは一時的な設定をインストールしたり設定のテストを行ったりするときに
便利です。
.Em セット
に関する詳細はセクション
.Sx ルールセット
を参照して下さい。
.Pp
次のオプションが利用可能です:
.Bl -tag -width indent
.It Fl a
ルールのリストを表示する際に、
カウンタ値を示します。
.Cm show
コマンドは、このオプションを暗黙的に指定しただけのものです。
.It Fl c
ルールを入力したり参照したりするときに、
コンパクトな書式でルールを表示します。
つまり、ルールが何の追加情報も持たないときは、
オプショナルな文字列 "ip from any to any" を表示しません。
.It Fl d
ルールのリストを表示する際に、
静的ルールに加えて動的ルールも表示します。
.It Fl e
ルールのリストを表示する際に、
もし
.Fl d
オプションが指定されていれば、
期限切れの動的ルールも表示します。
.It Fl f
誤って使用すると問題を起す可能性のあるコマンド、
.No すなわち Cm flush
に対して、実行の確認を行いません。
プロセスに関連付けられた tty が無い場合、このオプションが
暗黙のうちに指定されたとして処理されます。
.It Fl N
出力に含まれるアドレスとサービス名の名前解決を試みます。
.It Fl q
.Cm add ,
.Cm zero ,
.Cm resetlog ,
.Cm flush
を実行する際、動作について報告しません
(暗黙のうちに
.Fl f
が指定されます)。
スクリプト
(例えば
.Ql sh\ /etc/rc.firewall )
の中で複数の
.Nm
コマンドを実行してルールを変更する場合や、
リモートログインセッション経由で多数の
.Nm
ルールを含むファイルを処理することによりルールを変更する場合に
有用です。
通常 (冗長) モードで (デフォルトカーネル設定で) flush を行った場合、
メッセージを表示します。
すべてのルールが捨てられますので、
メッセージはログインセッションへ渡せません。
つまり、リモートログインセッション経由の場合、セッションはクローズされ、
残りのルールセットは処理されません。
この状態から回復するためにはコンソールへのアクセスが必要になります。
.It Fl S
ルールのリストを表示する際に、
各ルールが属する
.Em セット
を表示します。
このフラグが指定されていなければ、
無効化されているルールは表示されません。
.It Fl s Op Ar field
パイプ経由でリスト出力している際に、4 つのカウンタの 1 つについて
整列させます (現在のパケット数)。
.It Fl t
ルールのリストを表示する際に、
最後にマッチしたタイムスタンプを表示します。
.El
.Pp
冒頭の書式の行で示したように、
設定を簡単にするため、
ルールを
.Nm
に処理させるファイルに記述することができます。
.Ar pathname
には絶対パス名を使用する必要があります。
このファイルからは 1 行ずつ読み込まれ、
.Nm
ユーティリティの引数として受け付けられます。
.Pp
.Fl p Ar preproc
を使用して、
.Ar pathname
がパイプされるプリプロセッサを指定することもできます。
有用なプリプロセッサには、
.Xr cpp 1
と
.Xr m4 1
があります。
.Ar preproc
の最初の文字がスラッシュ
.Pq Ql /
から始まらない場合、
.Ev PATH
を使用した通常の名前検索が行われます。
.Nm
が実行されるときまでに全ファイルシステムが (まだ) マウントされないような環境
(例えば NFS 経由でマウントされる場合) では、このことに注意してください。
ひとたび
.Fl p
が指定されると、オプションとして
.Fl D
と
.Fl U
の指定を続けることが可能となり、これらがプリプロセッサに渡されます。
これにより、(ローカルホスト名により条件付けするなど)
柔軟性のある設定ファイルを作成可能となり、IP アドレスのように
頻繁に必要となる引数を集中管理するためのマクロを使用可能となります。
.Pp
後述の
.Sx トラフィックシェイパ設定
セクションで示すように、
.Nm
.Cm pipe
および
.Cm queue
コマンドを使用して、トラフィックシェイパを構築可能です。
.Sh パケットフロー
システムパラメータの制御により、
.Nm
はプロトコルスタックの中の複数の箇所から実行されます。
適切なルールセットを設計するには、この現象を理解することが重要です。
.Nm
が実行される箇所は、その実行を制御する sysctl 変数とともに
以下に挙げられています。
.Bd -literal -offset indent
      ^	    to upper layers   V
      |                       |
      +----------->-----------+
      ^                       V
 [ip_input]              [ip_output]   net.inet.ip.fw.enable=1
      |                       |
      ^                       V
[ether_demux]    [ether_output_frame]  net.link.ether.ipfw=1
      |                       |
      +-->--[bdg_forward]-->--+        net.link.ether.bridge_ipfw=1
      ^                       V
      |      to devices       |
.Ed
.Pp
上図に示されるように、
同一のパケットがファイアウォールを通過する回数は、
パケットの発信元や宛先、システムの設定により、
0 回から 4 回の範囲で変動します。
これらの各所で、そのレベルに属する全ての(そして唯一の)フィールドと一緒に、
パケットは
.Nm
に渡されます。
つまり、外から入ってくるパケットは
.Cm ether_demux()
から
.Nm
が実行されるときには MAC ヘッダを含んでいるはずですが、
その同じパケットが、
.Cm ip_input()
から
.Nm
が実行されたときには MAC ヘッダは取り除かれているはずです。
.br
.Nm
が実行された場所や、パケットのソースに関わりなく、
完全なルールセットが常に使用されます。
実行された箇所によっては無効となるような
マッチパターンやアクション
(例えば、
.Cm ip_input()
から
.Nm
が呼び出されたときに MAC ヘッダとマッチを試みるようなもの)
をルールが含んでいるなら、そのパターンはマッチしないことになります。
とはいえ、そのようなパターンの前に
.Cm not
オペレータを記述すれば、パターンは
.Em 常に
そのようなパケットにマッチすることになり、望ましくない結果となるでしょう。
したがって、必要ならば、可能性のある箇所の中で識別するように、
適切なルールセットを記述することはプログラマの責任です。
そこで
.Cm skipto
ルールが役に立つことでしょう。
例えば次のようにします:
.Bd -literal -offset indent
# ether_demux または bdg_forward からのパケット
ipfw add 10 skipto 1000 all from any to any layer2 in
# ip_input からのパケット
ipfw add 10 skipto 2000 all from any to any not layer2 in
# ip_output からのパケット
ipfw add 10 skipto 3000 all from any to any not layer2 out
# ether_output_frame からのパケット
ipfw add 10 skipto 4000 all from any to any layer2 out
.Ed
.Pp
(そうです、今のところ ether_demux と bdg_forward とを
区別する方法はありません)。
.Sh ルール書式
.Nm
の書式は次の通りです:
.Bd -ragged -offset indent
.Op Ar rule_number
.Op Cm set Ar set_number
.Op Cm prob Ar match_probability
.br
.Ar "   " action
.Op Cm log Op Cm logamount Ar number
.Ar body
.Ed
.Pp
ここで、ルールのボディは次のように、
パケットをフィルタするのにどの情報を使用するのかを指定します:
.Pp
.Bl -tag -width "Source and dest. addresses and ports" -offset XXX -compact
.It レイヤ 2 ヘッダフィールド
可能ならば
.It IPv4 プロトコル
TCP, UDP, ICMP など
.It 送信元および宛先のアドレスとポート
.It 方向
セクション
.Sx パケットフロー
を参照して下さい
.It 送信および受信インタフェース
名前またはアドレス
.It その他の IP ヘッダフィールド
バージョン、サービスタイプ、データグラム長、識別子、
フラグメントフラグ (0 でない IP オフセット)、
生存時間
.It IP オプション
.It その他の TCP ヘッダフィールド
TCP フラグ (SYN, FIN, ACK, RST など)、
シーケンス番号、確認応答番号、ウィンドウ
.It TCP オプション
.It ICMP タイプ
ICMP パケットの場合
.It ユーザ/グループ ID
パケットをローカルソケットに関連づけることが可能な場合
.El
.Pp
上記の情報、
例えば、送信元 MAC アドレスまたは IP アドレスと TCP/UDP ポート
は容易に詐称が可能であることに注意して下さい。
したがって、これらのフィールドのみでフィルタすることは
必ずしも望ましい結果とはなりません。
.Bl -tag -width indent
.It Ar rule_number
各ルールは、1 から 65535 の範囲の
.Ar rule_number
に関連づけられており、
後者は
.Em デフォルト
ルールのために予約されています。
ルールはルール番号の順にチェックされます。
複数のルールが同一の番号を持つことが可能で、
その場合は追加された順序でチェックされます (表示する場合も同様です) 。
番号の指定なしでルールが入力された場合、
カーネルは、そのルールが
.Em デフォルト
ルールより前にあるルールの中で最後になるように割り当てます。
自動的につけられるルール番号は、
デフォルトを除いた中で最後となるルール番号を、
sysctl 変数
.Ar net.inet.ip.fw.autoinc_step
の値だけ増加させて割り当てられます。
この変数のデフォルトは 100 です。
もし、この操作が
(例えば許可された最大ルール番号を越えるといった理由で)
不可能であれば、
最後のデフォルトでない値と同じ番号が代わりに使用されます。
.It Cm set Ar set_number
各ルールは 0 から 31 の範囲の
.Ar set_number
に関連づけられており、
後者は
.Em デフォルト
ルールのために予約されています。
セットは個別に無効化したり有効化したりすることができます。
したがって、このパラメータはアトミックなルールセット操作を行うために
必要不可欠なものです。
ルールセットを単純に削除することも可能です。
セット番号を指定せずにルールが入力された場合、
セット 0 が使用されます。
.It Cm prob Ar match_probability
指定した確率 (0 から 1 までの浮動小数点数です)
でしかマッチしないマッチを宣言されます。
ランダムにパケットを落とすしたりするような
多くのアプリケーションや、
(
.Xr dummynet 4
と共に使用して)
パケット到達順序の乱れを引き起こす複数経路の効果をシミュレートする際に
有用です。
.It Cm log Op Cm logamount Ar number
パケットが
.Cm log
キーワードを持ったルールにマッチした場合、
メッセージが
.Xr syslogd 8
に
.Dv LOG_SECURITY
ファシリティで記録されます。
sysctl 変数
.Em net.inet.ip.fw.verbose
が 1
(カーネルが
.Dv IPFIREWALL_VERBOSE
でコンパイルされていればこれがデフォルトです)
に設定されており、
そのルールについてこれまで記録されたパケットの数が
その
.Cm logamount
パラメータを越えていなければ、記録が行われます。
.Cm logamount
が指定されていなければ、制限は sysctl 変数
.Em net.inet.ip.fw.verbose_limit
から参照されます。
両者の値が 0 であれば記録の制限は取り除かれます。
.Pp
一度制限に達したなら、
このエントリに対するロギングカウンタかパケットカウンタをクリアすれば
記録を再び有効にすることができます。
.Cm resetlog
コマンドを参照して下さい。
.Pp
.El
.Ss ルールアクション
ルールは次に示すアクションの 1 つと関連づけることができます。
これはパケットがルールのボディにマッチしたときに実行されます。
.Bl -tag -width indent
.It Cm allow | accept | pass | permit
ルールにマッチするパケットを受け付けます。
検索は終了します。
.It Cm check-state
動的ルールセットに対してパケットのチェックを行ないます。
マッチした場合、
その動的ルールを生成したルールに関連づけられたアクションを実行し、
マッチしなかった場合、次のルールに移ります。
.br
.Cm check-state
ルールはボディを持ちません。
.Cm check-state
ルールが見つからないときは、
動的ルールセットは最初の
.Cm keep-state
ルール、もしくは
.Cm limit
ルールの場所でチェックされます。
.It Cm count
ルールにマッチした全てのパケットのカウンタを更新します。
検索は次のルールへ続行します。
.It Cm deny | drop
ルールにマッチした全てのパケットを破棄します。
検索は終了します。
.It Cm divert Ar port
ルールにマッチするパケットを
ポート
.Ar port
にバインドされている
.Xr divert 4
ソケットに送出します。
検索は終了します。
.It Cm fwd | forward Ar ipaddr Ns Op , Ns Ar port
マッチしたパケットの次のホップを
.Ar ipaddr
に変更します。
これには4つの数字をドットで区切った IP アドレス
またはホスト名が使用できます。
このルールにマッチした場合、検索は終了します。
.Pp
.Ar ipaddr
がローカルアドレスの場合、マッチしたパケットはローカルマシンの
.Ar port
(または、ルールで指定されていない場合はそのパケットのポート番号)
に転送されます。
.br
.Ar ipaddr
がローカルアドレスでない場合、
ポート番号は (指定されていても) 無視され、
パケットは
ローカルな経路テーブルに存在するその IP に対する経路を使用して
リモートアドレスに転送されます。
.br
.Ar fwd
ルールはレイヤ 2 パケット
(それらは ether_input, ether_output, bridged で受信されます)
にはマッチしません。
.br
.Cm fwd
アクションはパケットの内容をまったく変更しません。
実際、宛先アドレスが修正されずに残るので、
転送先システムがそのようなパケットを取り込むルールを持たない限り、
当該パケットは通常そのシステムが拒否します。
ローカルで転送されるパケットのために、
ソケットのローカルアドレスはパケットの元の宛先アドレスに設定されます。
このことによって
.Xr netstat 1
エントリはかえって奇妙な見え方になりますが、
これは透過プロキシサーバでの使用を意図しています。
.It Cm pipe Ar pipe_nr
パケットを
.Xr dummynet 4
.Dq パイプ
(バンド幅制限、遅延などに使用されます)
へ渡します。
詳しい情報については
.Sx トラフィックシェイパ設定
セクションを参照してください。
検索は終了します。
しかし、パイプから抜けたときに
.Xr sysctl 8
変数
.Em net.inet.ip.fw.one_pass
がセットされていない場合、
パケットはファイアウォールコードへ再度渡されて次のルールから開始します。
.It Cm queue Ar queue_nr
パケットを
.Xr dummynet 4
.Dq キュー
(WF2Q を使ったバンド幅制限に使用されます)
へ渡します。
.It Cm reject
(価値が低下しています)。
.Cm unreach host
と同義です。
.It Cm rest
このルールにマッチしたパケットを破棄します。
さらに、そのパケットが TCP パケットであれば、
TCP リセット (RST) 通知を送出しようと試みます。
検索は終了します。
.It Cm skipto Ar number
.Ar number
より小さな番号のルールを飛び越して、
.Ar number
以上の番号のルールで最初に存在するものから、検索を継続します。
.It Cm tee Ar port
このルールにマッチしたパケットの複製を、
ポート
.Ar port
にバインドされた
.Xr divert 4
ソケットに送出します。
検索は終了し、元のパケットは受け付けられます
(ただし、以下のセクション
.Sx バグ
を参照して下さい)。
.It Cm unreach Ar code
このルールにマッチしたパケットを破棄し、
コード
.Ar code
の ICMP 到達不可通知を送出しようと試みます。
ここで
.Ar code
は 0 から 255 の数字、または次のエイリアスのいずれかです:
.Cm net , host , protocol , port ,
.Cm needfrag , srcfail , net-unknown , host-unknown ,
.Cm isolated , net-prohib , host-prohib , tosnet ,
.Cm toshost , filter-prohib , host-precedence ,
.Cm precedence-cutoff
。
検索は終了します。
.El
.Ss ルールボディ
ルールのボディは 0 以上のパターン
(送信元と宛先アドレスやポートの指定、
プロトコルオプション、受信または送信インタフェースの指定など)
から成ります。
パケットは解釈される順にマッチしなければなりません。
通常、パターンは (暗黙的に)
.Cm and
オペレータで接続されます -- つまり、ルールがマッチするためには
全てがマッチしなければなりません。
個々のパターンには、マッチの結果を反転させるために
.Cm not
オペレータを前置することができます。
これは次のようになります。
.Pp
.Dl "ipfw add 100 allow ip from not 1.2.3.4 to any"
.Pp
さらに、
次のように
.Cm or
オペレータを使用し、
丸括弧 () や ブレース {} で括られた内部にパターンを列挙することで、
新しいマッチパターンのセット (
.Em 論理和ブロック
) を構築することができます:
.Pp
.Dl "ipfw add 100 allow ip from { x or not y or z } to any"
.Pp
括弧のレベルは 1 つのみが可能です。
ほとんどのシェルが丸括弧やブレースに特別な意味を持たせていることに
注意して下さい。
したがって、そのような解釈が起こらないようにバックスラッシュ \\ を
その前に置くことを勧めます。
.Pp
ルールのボディは、通常は送信元と宛先アドレスの指定を含まなければなりません。
キーワード
.Ar any
は必須フィールドの内容が重要でないことを指定するために
様々な箇所で使用することができます。
.Pp
ルールボディは以下の書式:
.Bd -ragged -offset indent
.Op Ar proto Cm from Ar src Cm to Ar dst
.Op Ar options
.Ed
.Pp
最初の部分 (protocol from src to dst) は
.Nm ipfw1
との後方互換のためにあります。
.Nm ipfw2
では、任意のマッチパターン
(MAC ヘッダ、IPv4 プロトコル、アドレス、ポートを含む)
が
.Ar options
セクションで指定できます。
.Pp
ルールフィールドは以下の意味です:
.Bl -tag -width indent
.It Ar proto : protocol | Cm { Ar protocol Cm or ... }
IPv4 プロトコル (または複数のプロトコルからなる
.Em 論理和ブロック
)
は数字や名前で指定されます
(完全なリストは
.Pa /etc/protocols
を参照して下さい)。
.Cm ip
または
.Cm all
のキーワードを使用すると、すべてのプロトコルがマッチします。
.It Ar src No および Ar dst : ip-address | Cm { Ar ip-address Cm or ... } Op Ar ports
単一の
.Ar ip-address
や、1 つ以上のアドレスを含む
.Em 論理和ブロック
は、後に続けて
.Ar ports
指示子をオプションで置くことができます。
.It Ar ip-address :
次の方法
(オプションで
.Cm not
オペレータを前置することができます)
のいずれかで指定されたアドレス (またはアドレスのセット):
.Bl -tag -width indent
.It Cm any
任意の IP アドレスにマッチします。
.It Cm me
システムのインタフェースに設定された任意の IP アドレスにマッチします。
アドレスのリストはパケットが解析されるときに評価されます。
.It Ar numeric-ip | hostname
ドットで区切った 4 つの数字またはホスト名で指定した、
1 つの IPv4 アドレスにマッチします。
ホスト名はそのルールがファイアウォールのリストに追加されるときに
名前解決が行われます。
.It Ar addr Ns / Ns Ar masklen
ベースとなる
.Ar addr
(ドットで区切った4つの数字またはホスト名で指定されます)
と
.Cm masklen
ビット幅のマスク
に一致する全てのアドレスにマッチします。
例えば、1.2.3.4/25 は 1.2.3.0 から 1.2.3.127 までの
全ての IP アドレスにマッチすることになります。
.It Ar addr Ns / Ns Ar masklen Ns Cm { Ns Ar num,num,... Ns Cm }
ベースアドレスが
.Ar addr
(ドットで区切った4つの数字またはホスト名で指定されます)
であり、最後のバイトがブレース {} の中に列挙されている
全てのアドレスにマッチします。
ブレース、コンマ、数字の間には空白を置いてはいけないことに注意して下さい。
.Ar masklen
フィールドはアドレスのセットのサイズに制限をつけるために使用され、
24 から 32 の間の任意の値をとることができます。
.br
例えば、アドレスが 1.2.3.4/24{128,35,55,89} として指定された場合、
次のアドレスがマッチします:
.br
1.2.3.128 1.2.3.35 1.2.3.55 1.2.3.89
.br
この書式は 1 つのルールでまばらなアドレス群を取り扱うときに
特に便利です。
マッチがビットマスクを使用して行われるので、
かかる時間は一定で、ルールセットの複雑さが劇的に減少します。
.El
.It Ar ports : Oo Cm not Oc Bro Ar port | port Ns \&- Ns Ar port Ns Brc Op , Ns Ar ...
ポート番号をサポートしているプロトコル (TCP や UDP など) のために、
オプションの
.Cm ports
は、1 つ以上のポートまたはポートの範囲を空白なしのコンマ区切りで、
さらにオプションの
.Cm not
オペレータを付加して、
指定することができます。
記号
.Ql \&-
による表現は、ポート範囲 (両端含む) を指定します。
.Pp
ポート番号の代わりに (ファイル
.Pa /etc/services
から取った) サービス名を使用できます。
ポートリストの長さは 30 ポートまたはポート範囲に制限されていますが、
ルールの
.Cm options
セクションで
.Em 論理和ブロック
を使用するとより広い範囲を指定することができます。
バックスラッシュ
.Pq Ql \e
を使用することにより、サービス名中の
.Pq Ql -
文字をエスケープ可能です
(シェルから入力するとき、バックスラッシュは
シェル自身にエスケープ文字として使用されることを防ぐために
2 回タイプしなければなりません)。
.Pp
.Dl "ipfw add count tcp from any ftp\e\e-data-ftp to any"
.Pp
断片化されたパケットでオフセットが非 0 のもの
(すなわち、最初の断片ではないもの) は、
1 つ以上のポート指定を持つルールにはマッチしません。
断片化されたパケットへのマッチングに関する詳細は
.Cm frag
オプションを参照してください。
.El
.Ss ルールオプション (マッチパターン)
ルール内で追加のマッチパターンを使用することができます。
これらはルール内に 0 以上置けるので
.Em オプション
と呼ばれており、オプションで
.Cm not
オペランドを前置することができ、
.Em 論理和ブロック
へとグループ化することが可能です。
.Pp
以下のマッチパターンが使用できます (アルファベット順に並べています):
.Bl -tag -width indent
.It Cm bridged
ブリッジされるパケットにのみマッチします。
.It Cm dst-ip Ar ip address
宛先 IP アドレスが引数で指定したアドレスの 1 つである
IP パケットにマッチします。
.It Cm dst-port Ar source ports
宛先ポートが引数で指定したポートの 1 つである
IP パケットにマッチします。
.It Cm established
RST か ACK ビットがセットされている TCP パケットにマッチします。
.It Cm frag
IP データグラムのフラグメントであり、かつ、最初のフラグメントでない
パケットにマッチします。
これらのパケットは次のプロトコルヘッダ (例えば TCP, UDP) を持たないので、
これらのヘッダを調べるオプションはマッチすることができないことに
注意して下さい。
.It Cm gid Ar group
.Ar group
によって送信された、またはそれに対して受信された
全ての TCP もしくは UDP パケットにマッチします。
.Ar group
は名前か数値で指定することができます。
.It Cm icmptypes Ar types
ICMP タイプが
.Ar types
で指定されたリスト中に存在する ICMP パケットにマッチします。
リストは範囲指定でも、タイプおのおのをコンマで区切ったものでも
どちらの組み合わせでもかまいません。
サポートされている ICMP タイプは次の通りです:
.Pp
エコー応答
.Pq Cm 0 ,
宛先到達不可
.Pq Cm 3 ,
発信元抑制
.Pq Cm 4 ,
リダイレクト
.Pq Cm 5 ,
エコー要求
.Pq Cm 8 ,
ルータ広告
.Pq Cm 9 ,
ルータ要請
.Pq Cm 10 ,
時間超過
.Pq Cm 11 ,
IP ヘッダ異常
.Pq Cm 12 ,
タイムスタンプ要求
.Pq Cm 13 ,
タイムスタンプ応答
.Pq Cm 14 ,
インフォメーション要求
.Pq Cm 15 ,
インフォメーション返答
.Pq Cm 16 ,
アドレスマスク要求
.Pq Cm 17 ,
アドレスマスク応答
.Pq Cm 18
.It Cm in | out
それぞれ到着または送出パケットにマッチします。
.Cm in
と
.Cm out
は互いに排他的です
(実際、
.Cm out
は
.Cm not in Ns
として実装されています)。
.It Cm ipid Ar id
.Cm ip_id
フィールドが値
.Ar id
である IP パケットにマッチします。
.It Cm iplen Ar len
ヘッダとデータを含んだ全体の長さが
.Ar len
バイトである IP パケットにマッチします。
.It Cm ipoptions Ar spec
IP ヘッダが
.Ar spec
で指定されたコンマ区切りのオプションリストを含む
パケットにマッチします。
IP オプションは次のものがサポートされています:
.Pp
.Cm ssrr
(ストリクトソースルーティング),
.Cm lsrr
(ルーズソースルーティング),
.Cm rr
(レコードルート),
.Cm ts
(タイムスタンプ)。
.Ql \&!
を置くことで特定のオプションが存在しないという記述ができます。
.It Cm ipprecedence Ar precedence
先行フィールドが
.Ar precedence
に等しい IP パケットにマッチします。
.It Cm iptos Ar spec
.Cm tos
フィールドが
.Ar spec
で指定されたコンマ区切りのサービスタイプのリストを含む
IP パケットにマッチします。
サポートされているサービスの IP タイプは次の通りです:
.Pp
.Cm lowdelay
.Pq Dv IPTOS_LOWDELAY ,
.Cm throughput
.Pq Dv IPTOS_THROUGHPUT ,
.Cm reliability
.Pq Dv IPTOS_RELIABILITY ,
.Cm mincost
.Pq Dv IPTOS_MINCOST ,
.Cm congestion
.Pq Dv IPTOS_CE
。
.Ql \&!
を置くことで特定のオプションが存在しないという記述ができます。
.It Cm ipttl Ar ttl
生存時間が
.Ar ttl
である IP パケットにマッチします。
.It Cm ipversion Ar ver
IP バージョンフィールドが
.Ar ver
である IP パケットにマッチします。
.It Cm keep-state
マッチする際に、ファイアウォールは動的ルールを作成します。
作成されるルールは、デフォルトでは、同じプロトコルを使用している
発信元と宛先 IP/ポート間での双方向のトラフィックにマッチするような
動作となります。
このルールには制限された生存時間 (
.Xr sysctl 8
変数のセットで制御されます)
があり、
生存時間はマッチするパケットが見つかるたびにリフレッシュされます。
.It Cm layer2
レイヤ 2 のパケットのみにマッチします。
つまり、
ether_demux() と ether_output_frame() から
.Nm
へ渡されるパケットです。
.It Cm limit Bro Cm src-addr | src-port | dst-addr | dst-port Brc Ar N
ファイアウォールは、
ルールで指定した同一のパラメータのセットに対して
.Ar N
個の接続のみを許可します。
1 つ以上の発信元と宛先アドレスおよびポートが指定できます。
.It Cm { MAC | mac } Ar dst-mac src-mac
与えられた
.Ar dst-mac
アドレスと
.Ar src-mac
アドレスを持つパケットにマッチします。
アドレスには
.Cm any
キーワード (任意の MAC アドレスにマッチします) または
コロンで区切った 16 進数 6 個の組み、
次に示すようなオプションでその後に意味のあるビット数を指定するマスク
を指定します。
.Pp
.Dl "MAC 10:20:30:40:50:60/33 any"
.Pp
MAC アドレスの順序 (宛先が最初で 2 番目に発信元) は
物理的な線上のものと同じですが、
IP アドレスで使用されるものとは反対であることに注意して下さい。
.It Cm mac-type Ar mac-type
イーサネットのタイプフィールドが
引数で指定したものの 1 つと一致する
パケットにマッチします。
.Ar mac-type
は
.Cm port numbers
と同じ方法で指定します
(つまり、1 つ以上のコンマ区切りの単一の値または範囲です)。
.Em vlan , ipv4 , ipv6
のような既知の値に対するシンボリックな名称を使用することができます。
値は 10 進数か 16 進数 (0x が頭につく場合) で入力することができ、
常に 16 進数で出力されます (
.Cm -N
オプションが使用されていない場合です。
そのときはシンボリックな名前解決が試みられます)。
.It Cm proto Ar protocol
IPv4 プロトコルに一致するパケットがマッチします。
.It Cm recv | xmit | via Brq Ar ifX | Ar if Ns Cm * | Ar ipno | Ar any
受信したパケット、送信するパケット、通過するパケットが
それぞれマッチします。
インタフェースは正確な名前
.Ns No ( Ar ifX Ns No ) 、
デバイス名
.Ns No ( Ar if Ns Ar * Ns No ) 、
IP アドレスで指定するか、
もしくは何らかのインタフェースを通過することを指定します。
.Pp
.Cm via
キーワードはインタフェースが常にチェックされることになります。
.Cm recv
や
.Cm xmit
が
.Cm via
の代わりに使用された場合、
受信したインタフェース、または送信するインタフェース
(それぞれに対応します) 
のみがチェックされます。
両方とも指定した場合、
送信インタフェースと受信インタフェースの両方に基づく
パケットのマッチが可能になります。
例えば次のようになります:
.Pp
.Dl "ipfw add deny ip from any to any out recv ed0 xmit ed1"
.Pp
.Cm recv
インタフェースは到着または送出パケットのどちらかについて
検査することができますが、
.Cm xmit
インタフェースは送出パケットのみについて検査することができます。
したがって
.Cm xmit
を使用する場合には
.Cm out
は必須です (そして
.Cm in
は無効となります)。
.Pp
パケットが受信インタフェースや送信インタフェースを持たないことがあります:
ローカルホストから発生したパケットは受信インタフェースを持ちませんし、
ローカルホストに到着する予定のパケットは送信インタフェースを持ちません。
.It Cm setup
SYN ビットがセットされているが ACK ビットを持たない
TCP パケットにマッチします。
これは
.Dq Li tcpflags\ syn,!ack
の短縮形です。
.It Cm src-ip Ar ip-address
発信元 IP が引数で指定されたアドレスの 1 つである IP パケットにマッチします。
.It Cm src-port Ar ports
発信元ポートが引数で指定されたポートの 1 つである IP パケットにマッチします。
.It Cm tcpack Ar ack
TCP パケットのみです。
TCP ヘッダの確認応答番号フィールドが
.Ar ack
に設定されていればマッチします。
.It Cm tcpflags Ar spec
TCP パケットのみです。
TCP ヘッダが
.AR spec
で指定したコンマ区切りのフラグのリストを含んでいればマッチします。
サポートされている TCP フラグは次の通りです:
.Pp
.Cm fin ,
.Cm syn ,
.Cm rst ,
.Cm psh ,
.Cm ack ,
.Cm urg
。
.Ql \&!
を置くことで特定のフラグが存在しないという記述ができます。
.Cm tcpflags
の指定を含むルールは 0 でないオフセットを持つフラグメントパケットには
決してマッチすることはできません。
フラグメントパケットのマッチについての詳細は
.Cm frag
オプションを参照して下さい。
.It Cm tcpseq Ar seq
TCP パケットのみです。
TCP ヘッダのシーケンス番号フィールドが
.Ar seq
に設定されていればマッチします。
.It Cm tcpwin Ar win
TCP パケットのみです。
TCP ヘッダのウィンドウフィールドが
.Ar win
に設定されていればマッチします。
.It Cm tcpoptions Ar spec
TCP パケットのみです。
.Ar spec
で指定したコンマ区切りのオプションのリストが
TCP ヘッダに含まれていればマッチします。
サポートされている TCP オプションは次の通りです:
.Pp
.Cm mss
(最大セグメントサイズ),
.Cm window
(TCP ウィンドウ広告),
.Cm sack
(選択的 ACK),
.Cm ts
(RFC1323 タイムスタンプ),
.Cm cc
(RFC1644 T/TCP コネクションカウント)
.Ql \&!
を置くことで特定のオプションが存在しないという記述ができます。
.It Cm uid Ar user
.Ar user
が送信したまたは受信する、
すべての TCP パケットと UDP パケットにマッチします。
.Ar user
は、名前でも ID 番号でもマッチします。
.El
.Sh ルールのセット
各ルールは 0 から 31 まで番号をつけられた 32 の異なる
.Em セット
のいずれかに属しています。
セット 31 はデフォルトルールのために予約されています。
.Pp
デフォルトでは、
新規のルールを入力する際に
.Cm set N
アトリビュートを使用しなければ、
ルールはセット 0 に置かれます。
セットは個別に、かつ、アトミックに有効化したり無効化したりできるので、
この機構によって、ファイアウォールに関する複数の設定を格納し、
それらの設定を素早く (かつアトミックに) 切り替えるための方法が
簡単になります。
セットを有効化/無効化するコマンドは次の通り。
.Pp
.Nm
.Cm set disable Ar number ... Op Cm enable Ar number ...
.Pp
ここでは複数の
.Cm enable
または
.Cm disable
セクションが指定可能です。
コマンドで指定した全てのセットについて、
コマンドはアトミックに実行されます。
デフォルトでは全てのセットは有効化された状態です。
.Pp
セットを無効化する際、ファイアウォールの設定の中にそのルールが
存在しないかのように振る舞います。
ただし例外が 1 つだけあります:
.Bl -bullet
.It
無効化される以前にルールから生成された動的ルールは
期限切れとなるまではまだ活動可能な状態です。
動的ルールを削除するためには、
そのルールを生成した親ルールを明示的に削除しなければなりません。
.El
ルールのセット番号は次のコマンドで変更できます。
.Pp
.Nm
.Cm set move
.Brq Cm rule Ar rule-number | old-set
.Cm to Ar new-set
.Pp
また、次のコマンドを使用して 2 つのルールセットを
アトミックに入れ換えることができます。
.Pp
.Nm
.Cm set swap Ar first-set second-set
.Pp
ルールのセットで使用できる項目は
.Sx 使用例
セクションを参照して下さい。
.Sh ステートフルファイアウォール
ステートフルオペレーションは、
与えられたパターンにマッチするパケットが検出されたときに、
特定のフローについてのルールを動的にファイアウォールに
作成するための方法です。
ステートフルオペレーションに対するサポートは
.Nm ルール
の
.Cm check-state , keep-state
および
.Cm limit
オプションを通じて提供されます。
.Pp
.Em src-ip/src-port dst-ip/dst-port
のアドレスのペアの間に与えられた
.Em protocol
を使用して全てまたはそれのみのパケットにマッチする
.Em 動的
ルールが生成される場合、
動的ルールはパケットが
.Cm keep-state
や
.Cm limit
ルールにマッチしたときに生成されます (
.Em src
と
.Em dst
はここでは初期状態でマッチするアドレスを示すためにのみ
使用されていますが、それらは後で示すものと完全に等価です)。
動的ルールは最初に
.Cm check-state, keep-state
または
.Cm limit
の発生をチェックされ、
マッチした際に実行されるアクションは親ルールと同じものになります。
.Pp
プロトコルと IP アドレス以外に追加される属性はなく、
ポートは動的ルールでチェックされることに注意して下さい。
.Pp
動的ルールの典型的な使い方は、
ファイアウォールの設定を閉じたままにしておくことです。
しかし、
内部ネットワークからの最初の TCP SYN パケットによって、
フローに対する動的ルールがインストールされるので、
そのセッションに所属するパケットはファイアウォールの通過を
許可されることになります。
.Pp
.Dl "ipfw add check-state"
.Dl "ipfw add allow tcp from my-subnet to any setup"
.Dl "ipfw add deny tcp from any to any"
.Pp
同様なアプローチが UDP に対しても使え、
内部からやって来る UDP パケットによって、
その応答はファイアウォールを通過するように
動的ルールがインストールされることになります:
.Pp
.Dl "ipfw add check-state"
.Dl "ipfw add allow udp from my-subnet to any"
.Dl "ipfw add deny udp from any to any"
.Pp
動的ルールはしばらくたった後期限切れとなります。
その時間は、
フローの状態といくつかの
.Cm sysctl
変数の設定に依存します。
詳細はセクション
.Sx sysctl 変数
を参照して下さい。
TCP セッションでは、
期限切れになるころにルールの状態をリフレッシュさせるため、
定期的にキープアライブパケットを送出するよう
動的ルールに通知することができます。
.Pp
動的ルールの使用方法に関する他の例は
セクション
.Sx 使用例
を参照して下さい。
.Sh トラフィックシェイパ設定
.Nm
は、
.Xr dummynet 4
トラフィックシェイパへのユーザインタフェースも提供します。
シェイパは、ユーザが指定したマスクを IP ヘッダの異なったフィールドに
適用することにより、パケットを
.Em フロー
(flow) に分割します。
同じフローに属するパケットは 2 つの異なったオブジェクトへ渡されます。
それは
.Em パイプ
(pipe) または
.Em キュー
(queue) と呼ばれるものです。
.Em パイプ
は、与えられたバンド幅、遅延時間、キューの長さ、パケット損失率を
もつリンクをエミュレートします。
このパラメータに従い、パケットはパイプ中を遷移します。
.Pp
.Em キュー
は、WF2Q+ (Worst-case Fair Weighted Fair Queueing) ポリシを
実装するために使用する抽象化です。
キューは、各フローに対し、重みと参照パイプを関連付けます。
それから、同じパイプに結び付けられたすべてのフローは、
WF2Q+ ポリシに従い、
パイプによって固定されたレートでスケジュールされます。
.Pp
.Nm
パイプ設定の書式は次の通りです:
.Bd -ragged -offset indent
.Cm pipe Ar number Cm config Ar pipe-configuration
.Ed
.Pp
.Nm
キュー設定の書式は次の通りです:
.Bd -ragged -offset indent
.Cm pipe Ar number Cm config Ar pipe-configuration
.Ed
.Pp
次のパラメータをパイプに対して設定可能です:
.Pp
.Bl -tag -width indent -compact
.It Cm bw Ar bandwidth | device
バンド幅で、単位は
.Sm off
.Op Cm K | M
.Brq Cm bit/s | Byte/s
.Sm on
です。
.Pp
値 0 (デフォルト) は無限のバンド幅を意味します。
単位は数値の直後に続けて書く必要があり、次のようにします。
.Pp
.Dl "ipfw pipe 1 config bw 300Kbit/s"
.Pp
数値の代りにデバイス名が指定された場合、
送信クロックは指定したデバイスから与えられます。
現在のところ、
.Xr tun 4
デバイスのみが
.Xr ppp 8
と組み合わせて使用するために、この機能を提供しています。
.Pp
.It Cm delay Ar ms-delay
遅延時間であり、ミリ秒単位で指定します。
値は、クロックティックの倍数
(典型的には 10ms ですが、
カーネルを
.Dq "options HZ=1000"
で動作させて精度を 1ms 以下にすると良い
ことが経験的に知られています) に丸められます。
デフォルト値は 0 であり、遅延無しを意味します。
.El
.Pp
次のパラメータをキューに対して設定可能です:
.Pp
.Bl -tag -width indent -compact
.It Cm pipe Ar pipe_nr
キューを指定したパイプに接続します。
複数のキュー
(大抵は異なる重みを持ちます)
を同一のパイプに接続することができます。
パイプはキューの集合に対する集約されたレートを指定します。
.Pp
.It Cm weight Ar weight
このキューにマッチするフローに適用する重みを指定します。
重みは 1 から 100 の範囲でなければならず、
デフォルトは 1 です。
.El
.Pp
最後に、次のパラメータがパイプやキューに対して設定できます:
.Pp
.Bl -tag -width indent -compact
.Pp
.It Cm buckets Ar hash-table-size
様々なキューを格納するハッシュ表のサイズを指定します。
デフォルトは 64 で、
.Xr sysctl 8
変数
.Em net.inet.ip.dummynet.hash_size
によって
16 から 1024 までの範囲で制御することが可能です。
.Pp
.It Cm mask Ar mask-specifier
.Xr dummynet 4
では、フローごとのキューを生成可能です。
フロー識別子は、パイプ設定において指定される
IP アドレス、ポート、プロトコルタイプでマスクすることで構築されます。
マスク後に同じ識別子を持つパケットは、同じキューに落ちます。
使用可能なマスク指定子は、次を組み合わせたものです:
.Cm dst-ip Ar mask ,
.Cm src-ip Ar mask ,
.Cm dst-port Ar mask ,
.Cm src-port Ar mask ,
.Cm proto Ar mask ,
.Cm all
。
最後の指定子は、
すべてのフィールドのすべてのビットが検査されることを意味しています。
.Ar パイプ
設定の中で使用される場合、
各フローにはパイプのレートに等しいレートが割り当てられます。
.Ar キュー
設定の中で使用される場合、
各フローにはキューの重みに等しい重みが割り当てられ、
同じパイプを構成するキューは重みに比例してバンド幅を共有します。
.Pp
.It Cm noerror
パケットが dummynet のキューやパイプによって落されたとき、
通常は、
デバイスキューが一杯になったときに生じるのと同様な形で、
エラーがカーネル内の呼び出し元ルーチンに報告されます。
このオプションを設定すると、
パケットの配送に成功したかのように報告されます。
これは、
遠隔地にあるルータでの損失や輻輳をシミュレートしたいという
一部の実験的な設定のために必要とされています。
.Pp
.It Cm plr Ar packet-loss-rate
パケットの損失率です。
引数
.Ar packet-loss-rate
は 0 から 1 までの浮動小数点数で、
0 が損失がないことを、1 が 100% 失われることを意味します。
損失率は内部的には 31 ビットで表現されています。
.Pp
.It Cm queue Brq Ar slots | size Ns Cm Kbytes
.Ar slots
または
.Cm KBytes
で表したキューのサイズです。
デフォルトは 50 スロットで、
これはイーサネットデバイスにおける典型的なキューのサイズです。
低速リンクのためにキューのサイズを小さいままにしておくことが推奨されます。
そうしないとトラフィックに対するキューの遅延が著しくなるかもしれません。
例えば、最大サイズのイーサネットパケット (1500 バイト) が 50 個のとき、
600Kbit、 つまり 30Kbit/秒 のパイプで 20 秒ということになります。
それよりもずっと大きな MTU を持ったインタフェース
(例えばループバックインタフェースは 16KB パケットです)
からパケットを受け取るとしても悪い結果となることがあります。
.Pp
.It Cm red | gred Ar w_q Ns / Ns Ar min_th Ns / Ns Ar max_th Ns / Ns Ar max_p
RED (Random Early Detection) キュー管理アルゴリズムを使用します。
.Ar w_q
と
.Ar max_p
は 0 から 1 (0 を含みません) の範囲の浮動小数点数であり、
.Ar min_th
と
.Ar max_th
はキュー管理用の閾値を指定する整数です
(キューがバイト数で指定された場合は閾値はバイトで計算され、
そうでない場合はスロット数で計算されます)。
.Xr dummynet 4
は、gentle RED という変型 (gred) もサポートします。
RED の動作を制御するために、3 個の
.Xr sysctl 8
変数を使用可能です:
.Bl -tag -width indent
.It Em net.inet.ip.dummynet.red_lookup_depth
リンクがアイドルの時の、平均キューの計算精度を指定します
(デフォルトは 256 であり、0 より大きい必要があります)
.It Em net.inet.ip.dummynet.red_avg_pkt_size
パケットサイズの平均の期待値を指定します
(デフォルトは 512 であり、0 より大きい必要があります)
.It Em net.inet.ip.dummynet.red_max_pkt_size
パケットサイズの最大値の期待値を指定します。
キューの閾値がバイトの場合のみ使用されます
(デフォルトは 1500 であり、0 より大きい必要があります)
.El
.El
.Sh チェックリスト
ルールを構成する際に考慮すべき重要な点を述べます。
.Bl -bullet
.It
かならず送信パケットと受信パケットの両方のパケットをフィルタリングします。
ほとんどのネットワークコネクションではパケットが双方向に流れることが必要です。
.It
テストは細心の注意を払って行ないます。テストの際にはコンソールの近くにいる
のがよいでしょう。
コンソールに近寄れない場合、
.Pa /usr/share/examples/ipfw/change_rules.sh
にあるような自動回復スクリプトを使用してください。
.It
ループバックインタフェースのことを忘れてはなりません。
.El
.Sh 細かい事柄
.Bl -bullet
.It
フラグメント化されたデータグラムが無条件で破棄される状況があります。
TCP パケットは、最低 20 バイトの TCP ヘッダを含まない場合、破棄されます。
UDP パケットは、完全な 8 バイトの UDP ヘッダを含まない場合、破棄されます。
ICMP パケットは、4 バイトの ICMP ヘッダ、
すなわち ICMP タイプとコードとチェックサムを含まない場合、破棄されます。
これらのパケットは、単に
.Dq pullup failed
としてログされます。
何故なら、パケット中に有意なログエントリを生成するだけの有用なデータが
含まれないかもしれないためです。
.It
無条件で破棄されるもう 1 種類のパケットは、
フラグメントオフセットが 1 の TCP パケットフラグメントです。
これはパケットとしては有効なものですが、利用目的はファイアウォールを
かいくぐることしかありません。
ログが有効な場合、
これらのパケットはルール -1 により破棄されたと報告されます。
.It
ネットワーク越しにログインしている場合、
.Xr kld 4
バージョンの
.Nm
をロードすることはそれほど単純なことではありません。
以下のコマンドを奨めます。
.Bd -literal -offset indent
kldload /modules/ipfw.ko && \e
ipfw add 32000 allow ip from any to any
.Ed
.Pp
これに引続き、同じような状況で
.Bd -literal -offset indent
ipfw flush
.Ed
.Pp
とするのは良くありません。
.It
システムセキュリティレベルが 3 以上に設定されている場合、
.Nm
フィルタリストを変更できません (システムセキュリティレベルについては
.Xr init 8
を参照してください)。
.El
.Sh パケットの行き先変更
指定されたポートにバインドされた
.Xr divert 4
ソケットは、
そのポートへ行き先変更されたパケットを、
全部受けとります。
宛先ポートにバインドされたソケットがない場合や、
カーネルがパケットの行き先変更ソケットをサポートするようには
コンパイルされていない場合、
パケットは破棄されます。
.Sh SYSCTL 変数
.Xr sysctl 8
変数の集合は、ファイアウォールと
関連するモジュール (
.Nm dummynet, bridge
) の動作を制御します。
デフォルト値 (どの値が実際に使用されるかは
.Nm sysctl
で確認してください) と意味と共に、これらを以下に列挙します。
.Bl -tag -width indent
.It Em net.inet.ip.dummynet.expire : No 1
未決定のトラフィックが一度もなかった動的パイプ/キューを怠惰に削除します。
この変数を 0 に設定することでこの動作を無効にすることができます。
この場合、パイプ/キューは閾値に達した場合にのみ削除されることになります。
.It Em net.inet.ip.dummynet.hash_size : No 64
動的パイプ/キューに使用されるハッシュ表のデフォルトの大きさです。
この値はパイプ/キューを設定するときに
.Cm buckets
オプションが 1 つも指定されなかった場合に使用されます。
.It Em net.inet.ip.dummynet.max_chain_len : No 16
ハッシュバケット (hash bucket) 内のパイプ/キューの最大個数の値です。
.Cm net.inet.ip.dummynet.expire=0
であっても、積
.Cm max_chain_len*hash_size
が空のパイプ/キューが期限切れになったとする閾値を決定するのに使用されます。
.It net.inet.ip.dummynet.red_lookup_depth : No 256
.It net.inet.ip.dummynet.red_avg_pkt_size : No 512
.It net.inet.ip.dummynet.red_max_pkt_size : No 1500
RED アルゴリズムを使って落す確率を計算するのに使用されるパラメータです。
.It Em net.inet.ip.fw.autoinc_step : No 100
ルール番号を自動生成する際のルール番号間の差分です。
この値は 1 から 100 の範囲でなければなりません。
.It Em net.inet.ip.fw.curr_dyn_buckets : Em net.inet.ip.fw.dyn_buckets
動的ルールのハッシュ表内の現在のバケットの個数です (読み出しのみ)。
.It Em net.inet.ip.fw.debug : No 1
.Nm
が生成するデバッグメッセージを制御します。
.It Em net.inet.ip.fw.dyn_buckets : No 256
動的ルールで使用されるハッシュ表に含まれるバケットの個数です。
2 の累乗でなければならず、上限は 65536 です。
全ての動的ルールが期限切れとなったときにのみ効果が現れるので、
確実にハッシュ表のサイズが変更されるようにするには
.Cm flush
コマンドを使用するべきでしょう。
.It Em net.inet.ip.fw.dyn_count : No 3
現在の動的ルールの数です
(読み込み専用)。
.It Em net.inet.ip.fw.dyn_keepalive : No 1
TCP セッションにおいて
.Cm keep-state
ルールのためのキープアライブパケットを生成するようにします。
キープアライブパケットは
ルールの生存時間が残り 20 秒となったときに
接続の両端に向けて 5 秒毎に
生成されます。
.It Em net.inet.ip.fw.dyn_max : No 8192
動的ルールの最大値です。この限界にいきつくと、
古いルールが無効になるまでは、それ以上、動的ルールを
組み込むことはできません。
.It Em net.inet.ip.fw.dyn_ack_lifetime : No 300
.It Em net.inet.ip.fw.dyn_syn_lifetime : No 20
.It Em net.inet.ip.fw.dyn_fin_lifetime : No 1
.It Em net.inet.ip.fw.dyn_rst_lifetime : No 1
.It Em net.inet.ip.fw.dyn_udp_lifetime : No 5
.It Em net.inet.ip.fw.dyn_short_lifetime : No 30
これらの値は、動的ルールの生存時間を秒単位でコントロールします。
最初の SYN 交換の際には生存時間が短期 (short) になり、
その後互いの SYN が検出された後は増加させられ、
最後の FIN 交換の間、
または RST を受信した際に再び減らされます。
.Em dyn_fin_lifetime
および
.Em dyn_rst_lifetime
は厳密に 5 秒 (キープアライブを繰り返す周期) より短くなければなりません。
ファイアウォールではこれが強制されます。
.It Em net.inet.ip.fw.enable : No 1
ファイアウォールを有効にします。
この変数を 0 に設定すると、
マシンがコンパイル時に有効の設定がされている場合であっても、
ファイアウォールがない状態で実行されます。
.It Em net.inet.ip.fw.one_pass : No 1
設定されている場合、
.Xr dummynet 4
パイプから出てくるパケットは
再度ファイアウォールを通過することはありません。
そうでない場合、
パイプアクションの後、
パケットは次のルールでファイアウォールに再注入されます。
.Pp
注: パイプから生じるブリッジされたパケットやレイヤ 2 パケットは、
この変数の値に関わらず、ファイアウォールに決して再注入されません。
.It Em net.inet.ip.fw.verbose : No 1
冗長メッセージを有効にします。
.It Em net.inet.ip.fw.verbose_limit : No 0
冗長出力を行うように設定されたファイアウォールが
生成するメッセージ数を制限します。
.It Em net.link.ether.ipfw : No 0
.Nm
がレイヤ 2 パケットを通すかどうかを制御します。
デフォルトは no です。
.It Em net.link.ether.bridge_ipfw : No 0
.Nm
がブリッジされたパケットを通すかどうかを制御します。
デフォルトは no です。
.El
.Sh IPFW2 拡張
このセクションでは
.Nm ipfw2
で導入され、
.Nm ipfw1
には無い機能の一覧を示します。
ここではルールセットを記述する際に影響が大きいと思われる順に示します。
より効果的なやり方でルールセットを記述するために
これらの機能を使用したいと思うかもしれません。
.Bl -tag -width indent
.It 非 IPv4 のパケットの取り扱い
.Nm ipfw1
は全ての非 IPv4 パケットを黙って受け付けます (
.Nm ipfw1
は
.Em net.link.ether.bridge_ipfw=1 Ns
の場合にのみ参照します)。
.Nm ipfw2
は
全てのパケット (非 IPv4 パケットを含む) を
ルールセットにしたがってフィルタします。
.Nm ipfw1
と同じような動作をさせたい場合は
ルールセットの先頭で次のようにします:
.Pp
.Dl "ipfw add 1 allow layer2 not mac-type ip"
.Pp
.Cm layer2
オプションは冗長であるように見えますが、必要です --
レイヤ 3 からファイアウォールを通るパケットは MAC ヘッダを待たないので、
.Cm mac-type ip
パターンはレイヤ3のパケットに対して常に失敗します。
つまり、
.Cm not
オペレータをおくと全てを通過させるルールになってしまいます。
.It アドレスセット
.Nm ipfw1
はアドレスセット (
.Ar addr/masklen{num,num,...}
という形式のもの)
をサポートしていません。
.Pp
.Nm ipfw1
と
.Nm ipfw2
には、
.Ar ipno:mask
のようなアドレス指定で、
連続するビット列の代わりに任意のビットマスクをマスクに指定することが
できるという小さな違いがあります。
.Nm ipfw2
はもはやこの文法をサポートしていませんが、
カーネルの側でサポートされているので
些細なことですが再び導入しています。
.It ポートの指定
.Nm ipfw1
では TCP と UDP のポートを指定する際に
指定できるポート範囲は 1 つだけでした。
また、
.Nm ipfw2
で可能な 15 エントリに対して 10 エントリに制限されていました。
また、
.Nm ipfw1
では
.Cm tcp
または
.Cm udp
パケットを要求するルールの場合に限って
ポートを指定することが可能です。
.Nm ipfw2
では全てのパケットにマッチさせるルールでポートの指定を行うことが可能で、
マッチはポート識別子を含んだプロトコルを運ぶパケットのみに適用されます。
.Pp
最後に、
.Nm ipfw1
では
最初のポートエントリを
.Ar port:mask
と指定することができます。
ここで
.Ar mask
は任意の 16 ビットマスクが使用可能です。
この文法が有用であるかどうかは疑問なので
.Nm ipfw2
ではもはやサポートされていません。
.It 論理和ブロック
.Nm ipfw1
は論理和ブロックをサポートしていません。
.It キープアライブ
.Nm ipfw1
は状態依存セッションのためのキープアライブを生成しません。
結果として、
休止状態のセッションは
動的ルールの生存時間が期限切れとなるために
落されることがあります。
.It ルールセット
.Nm ipfw1
はルールセットを実装していません。
.It MAC ヘッダによるフィルタとレイヤ 2 のファイアウォール
.Nm ipfw1
は MAC ヘッダフィールドによるフィルタを実装していませんし、
.Cm ether_demux()
と
.Cm ether_output_frame()
からのパケットによっても起動しません。
sysctl 変数
.Em net.link.ether.ipfw
はここでは何の効果もありません。
.It オプション
次のオプションは
.Nm ipfw1
ではサポートされていません。
.Pp
.Cm dst-ip, dst-port, layer2, mac, mac-type, src-ip, src-port
.Pp
さらに、次のオプションは
.Nm ipfw1
(RELENG_4)
のルールではサポートされていません:
.Cm ipid, iplen, ipprecedence, iptos, ipttl,
.Cm ipversion, tcpack, tcpseq, tcpwin
.It dummynet オプション
.Nm dummynet
パイプ/キュー用の次のオプションはサポートされていません:
.Cm noerror
.El
.Sh 使用例
.Nm
はあまりにも多くの使用方法があるので
このセクションでは使用例の一部を示すのみにしておきます。
.Pp
.Ss 基本的なパケットフィルタリング
次のコマンドは
.Em cracker.evil.org
から
.Em wolf.tambov.su
の telnet ポートへ送られるすべての TCP パケットを拒否するルールを追加します。
.Pp
.Dl "ipfw add deny tcp from cracker.evil.org to wolf.tambov.su telnet"
.Pp
次のコマンドはクラッカーのネットワーク全体からホスト my への
すべてのコネクションを拒否します。
.Pp
.Dl "ipfw add deny ip from 123.45.67.0/24 to my.host.org"
.Pp
最初に効率良く (動的ルールを用いずに) アクセスを制限する方法は、
次のルールを用いることです。
.Pp
.Dl "ipfw add allow tcp from any to any established"
.Dl "ipfw add allow tcp from net1 portlist1 to net2 portlist2 setup"
.Dl "ipfw add allow tcp from net3 portlist3 to net3 portlist3 setup"
.Dl "..."
.Dl "ipfw add deny tcp from any to any"
.Pp
最初のルールは通常の TCP パケットにすぐにマッチしますが、
最初の SYN パケットにはマッチしません。
指定した発信元/宛先の組の SYN パケットのみ、次の
.Cm setup
ルールにマッチします。これら以外の SYN パケットは、最後の
.Cm deny
ルールにより却下されます。
.Pp
もし、1 つ以上のサブネットの管理者なら、
以下のように、
アドレスセットと論理和ブロックを指定して
クライアントのブロックにサービスを選択的に利用可能にする
極めてコンパクトなルールセットを記述するという
.Nm ipfw2
の文法の利点を採用することができます。
.Pp
.Dl "goodguys=\*q{ 10.1.2.0/24{20,35,66,18} or 10.2.3.0/28{6,3,11} }\*q"
.Dl "badguys=\*q10.1.2.0/24{8,38,60}\*q"
.Dl ""
.Dl "ipfw add allow ip from ${goodguys} to any"
.Dl "ipfw add deny ip from ${badguys} to any"
.Dl "... normal policies ..."
.Pp
.Nm ipfw1
の文法では、
上の例では各 IP に別々のルールを用意する必要があります。
.Pp
.Ss 動的ルール
にせの TCP パケットを含む怒涛の攻撃 (flood attack) から
サイトを保護するためには、次の動的ルールを用いた方が安全です。
.Pp
.Dl "ipfw add check-state"
.Dl "ipfw add deny tcp from any to any established"
.Dl "ipfw add allow tcp from my-net to any setup keep-state"
.Pp
これらのルールにより、ファイアウォールは、自分たちのネットワークの
内側から到着する通常の SYN パケットで始まるコネクションに対して
のみ動的ルールを組み込みます。動的ルールは、最初の
.Cm check-state
ルール、または、
.Cm keep-state
ルールに遭遇した時点でチェックされます。
ルール集合のスキャン量を最小にするために、
.Cm check-state
ルールは、ルール集合の最初のほうに置くことになるのが普通です。
実際の燃費は変動します。
.Pp
ユーザが開ける接続数を制限するには、次のタイプのルールを使用可能です:
.Pp
.Dl "ipfw add allow tcp from my-net/24 to any setup limit src-addr 10"
.Dl "ipfw add allow tcp from any to me setup limit src-addr 4"
.Pp
前者 (ゲートウェイ上で動作することを仮定) は、/24 ネット上の各ホストが
最大 10 個の TCP 接続を開くことを許します。
後者は、サーバ上に設定可能であり、
単一のクライアントが同時に 4 個を越える接続を使用できないようにします。
.Pp
.Em 注意 :
ステートフルなルールは、怒涛の SYN 攻撃により極めて大量の動的ルールを
作ってしまい、サービス不能攻撃を受けることになる可能性があります。
ファイアウォールの動作をコントロールする
.Xr sysctl 8
変数に従いファイアウォールが動作することによって、
このような攻撃の影響を部分的にでも制限することはできます。
.Pp
次はカウントされている情報とタイムスタンプ情報を見る
.Cm list
コマンドのよい例です。
.Pp
.Dl ipfw -at list
.Pp
これはタイムスタンプを省略して次のように指定できます。
.Pp
.Dl ipfw -a list
.Pp
これは次の指定と等価です。
.Pp
.Dl ipfw show
.Pp
次のルールは 192.168.2.0/24 からのすべての受信パケットを、5000 番のポートに
行き先変更するものです。
.Pp
.Dl ipfw divert 5000 ip from 192.168.2.0/24 to any in
.Pp
.Ss トラフィックシェイパ
次のルールは、
.Nm
と
.Xr dummynet 4
をシミュレーションなどで使う際の使用方法を示しています。
.Pp
このルールは 5% の確率でランダムにパケットを落します。
.Pp
.Dl "ipfw add prob 0.05 deny ip from any to any in"
.Pp
同様の効果は dummynet パイプで実現可能です:
.Pp
.Dl "ipfw add pipe 10 ip from any to any"
.Dl "ipfw pipe 10 config plr 0.05"
.Pp
人工的にバンド幅を制限するためにパイプを使用可能です。
例えばルータとして動作するマシン上で、
192.168.2.0/24 上のローカルクライアントからのトラフィックを制限したい場合、
次のようにします:
.Pp
.Dl "ipfw add pipe 1 ip from 192.168.2.0/24 to any out"
.Dl "ipfw pipe 1 config bw 300Kbit/s queue 50KBytes"
.Pp
.Cm out
指示子を使用しているので、ルールが 2 度使われないことに注意してください。
.Nm
ルールは、実際には、
入力パケットと出力パケットの両方に適用されることを覚えておいてください。
.Pp
バンド幅に制限がある双方向リンクをシミュレートする場合、
正しい方法は次の通りです:
.Pp
.Dl "ipfw add pipe 1 ip from any to any out"
.Dl "ipfw add pipe 2 ip from any to any in"
.Dl "ipfw pipe 1 config bw 64Kbit/s queue 10Kbytes"
.Dl "ipfw pipe 2 config bw 64Kbit/s queue 10Kbytes"
.Pp
上述の方法は非常に有用な場合があり、
例えばあなたの装飾的なウェブページが
低速リンクのみで接続されている在宅ユーザにどう見えているか
知りたい場合に有用です。
半二重メディア (例えば appletalk, Ethernet, IRDA) をシミュレートしたい
場合を除き、単一のパイプを両方の方向に使用すべきではありません。
両方のパイプが同じ設定である必要はないので、
非対称リンクをシミュレート可能です。
.Pp
RED キュー管理アルゴリズムを使用してネットワーク性能を検証するには、
次のようにします:
.Pp
.Dl "ipfw add pipe 1 ip from any to any"
.Dl "ipfw pipe 1 config bw 500Kbit/s queue 100 red 0.002/30/80/0.1"
.Pp
トラフィックシェイパの他の典型的な応用は、
いくばくかの通信遅延を導入することです。
これは、遠隔手続き呼び出しを多用するアプリケーションで、
バンド幅よりも接続のラウンドトリップ時間がしばしば制約条件となる
アプリケーションに、大きな影響を与えます:
.Pp
.Dl "ipfw add pipe 1 ip from any to any out"
.Dl "ipfw add pipe 2 ip from any to any in"
.Dl "ipfw pipe 1 config delay 250ms bw 1Mbit/s"
.Dl "ipfw pipe 2 config delay 250ms bw 1Mbit/s"
.Pp
フローごとのキューはさまざまな用途に有用です。
非常に単純な用途は、トラフィックの集計です:
.Pp
.Dl "ipfw add pipe 1 tcp from any to any"
.Dl "ipfw add pipe 1 udp from any to any"
.Dl "ipfw add pipe 1 ip from any to any"
.Dl "ipfw pipe 1 config mask all"
.Pp
上述のルールセットは、
すべてのトラフィックに対するキューを生成 (して統計情報を収集) します。
パイプには制限をつけていないので、統計情報を集める効果しかありません。
最後のルールだけでなく 3 個のルールが必要なことに注意してください。
.Nm
が IP パケットのマッチを試みるときにポートを考慮しないため、
別々のポート上の接続は我々には同じものに見えます。
.Pp
より洗練された例は、
ネットワークの出力トラフィックを、
ネットワーク毎に制約するのではなく、ホスト毎に制約するものです:
.Pp
.Dl "ipfw add pipe 1 ip from 192.168.2.0/24 to any out"
.Dl "ipfw add pipe 2 ip from any to 192.168.2.0/24 in"
.Dl "ipfw pipe 1 config mask src-ip 0x000000ff bw 200Kbit/s queue 20Kbytes"
.Dl "ipfw pipe 2 config mask dst-ip 0x000000ff bw 200Kbit/s queue 20Kbytes"
.Ss ルールセット
ルールセットを自動的に追加するには、例えばセット 18 なら:
.Pp
.Dl "ipfw disable set 18"
.Dl "ipfw add NN set 18 ...         # 必要に応じて繰り返す"
.Dl "ipfw enable set 18"
.Pp
ルールセットを自動的に削除するにはコマンドは単に:
.Pp
.Dl "ipfw delete set 18"
.Pp
ルールセットのテストを行ったり、
何か間違いがあった場合にルールセットを削除して制御を回復するには:
.Pp
.Dl "ipfw disable set 18"
.Dl "ipfw add NN set 18 ...         # 必要に応じて繰り返す"
.Dl "ipfw enable set 18 ; echo done; sleep 30 && ipfw disable set 18"
.Pp
ここで各設定がうまくいった場合、
\&"sleep" が終了する前に control-C を押すと、
ルールセットは活動状態のままとなります。
そうでない場合、
たとえ箱にアクセスすることができなかったとしても、
ルールセットは端末がスリープした後で無効な状態になるので
以前の状況が復元されます。
.Pp
.Sh 関連項目
.Xr cpp 1 ,
.Xr m4 1 ,
.Xr bridge 4 ,
.Xr divert 4 ,
.Xr dummynet 4 ,
.Xr ip 4 ,
.Xr ipfirewall 4 ,
.Xr protocols 5 ,
.Xr services 5 ,
.Xr init 8 ,
.Xr kldload 8 ,
.Xr reboot 8 ,
.Xr sysctl 8 ,
.Xr syslogd 8
.Rs
.%A "S. Floyd"
.%A "V. Jacobson"
.%T "Random Early Detection gateways for Congestion Avoidance"
.%D "August 1993"
.Re
.Rs
.%A "B. Braden"
.%A "D. Clark"
.%A "J. Crowcroft"
.%A "B. Davie"
.%A "S. Deering"
.%A "D. Estrin"
.%A "S. Floyd"
.%A "V. Jacobson"
.%A "G. Minshall"
.%A "C. Partridge"
.%A "L. Peterson"
.%A "K. Ramakrishnan"
.%A "S. Shenker"
.%A "J. Wroclawski"
.%A "L. Zhang"
.%T "Recommendations on Queue Management and Congestion Avoidance in the Internet"
.%D "April 1998"
.%O "RFC 2309"
.Re
.Sh バグ
年月とともに文法が大きくなり、ときどき混乱することもあるでしょう。
不幸にして、後方互換性のために文法の定義の誤りを訂正できないでいます。
.Pp
.Em !!! 警告 !!!
.Pp
ファイアウォールを誤って設定するとコンピュータが
使用不能な状態になる可能性があります。
ことによると、ネットワークのサービスを停止してしまい、
制御を回復するためにコンソールアクセスが必要となってしまうでしょう。
.Pp
入ってきたパケットの断片 (フラグメント) が
.Cm divert
によって行き先を変更されるか
.Cm tee
されると、ソケットに配送される前にパケットは再構成されます。
これらのパケットで使用されるアクションは
パケットの最初のフラグメントにマッチしたルールの 1 つです。
.Pp
.Cm tee
ルールにマッチするパケットは、
即時に受理されるべきではなく、ルールリストを更に通るべきです。
これは、以降のバージョンで修正されるかもしれません。
.Pp
ユーザランドへ向けられ、
ユーザランドのプロセス (例えば
.Xr natd 8 )
によって再投入されるパケットは、
パケットの発信元インタフェースを含む
パケット属性のいろいろを失っています。
パケットがこの方法で再投入された場合、
後のルールは正しく適用されないかもしれません。
ルールの並びにおける
.Cm divert
ルールの順序は非常に重要なものとなります。
.Sh 作者
.An Ugen J. S. Antsilevich ,
.An Poul-Henning Kamp ,
.An Alex Nash ,
.An Archie Cobbs ,
.An Luigi Rizzo .
.Pp
.An -nosplit
API は
.An Daniel Boulet
が BSDI 用に記述したコードに基づいています。
.Pp
.Xr dummynet 4
トラフィックシェイパは Akamba Corp. がサポートしました。
.Sh 歴史
.Nm
は、
.Fx 2.0
で最初に現れました。
.Xr dummynet 4
は
.Fx 2.2.8
から導入されました。
ステートフル拡張は、
.Fx 4.0
から導入されました。
.Nm ipfw2
は 2002 年夏に導入されました。
