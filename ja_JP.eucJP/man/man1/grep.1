.\" grep man page
.\" %FreeBSD: src/gnu/usr.bin/grep/grep.1,v 1.6.2.1 1999/12/31 09:55:53 ru Exp %
.de Id
.ds Dt \\$4
..
.Id %Id: grep.1,v 1.1 1998/11/22 06:45:20 alainm Exp %
.TH GREP 1 \*(Dt "GNU Project"
.\" jpman %Id: grep.1,v 1.3 1997/07/21 07:22:12 konuma Stab %
.\"
.\" WORD: word-constituent characters	単語構成文字
.SH 名称
grep, egrep, fgrep, zgrep \- パターンにマッチする行を表示する
.SH 書式
.B grep
[-[AB] NUM] [-CEFGVZabchiLlnqrsvwxyUu] [-e PATTERN | -f FILE]
[-d ACTION] [--directories=ACTION]
[--extended-regexp] [--fixed-strings] [--basic-regexp]
[--regexp=PATTERN] [--file=FILE] [--ignore-case] [--word-regexp]
[--line-regexp] [--line-regexp] [--no-messages] [--revert-match]
[--version] [--help] [--byte-offset] [--line-number]
[--with-filename] [--no-filename] [--quiet] [--silent] [--text]
[--files-without-match] [--files-with-matcces] [--count]
[--before-context=NUM] [--after-context=NUM] [--context]
[--binary] [--unix-byte-offsets] [--recursive]
[--decompress]
.I files...
.SH 解説
.PP
.B grep
は、
.I files
で名前を指定された入力ファイル (ファイルが指定されてないか、
.I file
の部分に
.B \-
が指定された場合は標準入力) を読み込み、与えられた
.IR pattern
にマッチする部分を含む行を探します。
デフォルト動作では、
.B grep
はマッチした行を表示します。
.PP
.B grep
は、以下のオプションにより大きく 3 つの動作に分かれます。
.PD 0
.TP
.B \-G, --basic-regexp
.I pattern
として、基本的な正規表現を扱うモードです (下記参照)。デフォルトです。
.TP
.B \-E, --extended-regexp
.I pattern
として、拡張された正規表現を扱うモードです (下記参照)。
.TP
.B \-F, --fixed-strings
.I pattern
として、改行で区切られた固定の文字列パターンのリストを扱うモードです。
その文字列のどれかにマッチするかどうか調べます。
.LP
さらに、2 つのプログラム
.B egrep
と
.B fgrep
を利用可能です。
.B egrep
は、
.B "grep\ \-E" 
と似ています (が等価ではありません) し、歴史的な UNIX の
.B egrep 
と互換性があります。
.B fgrep
は
.BR "grep\ \-F"
と同じです。
.B zgrep
は
.BR "grep\ \-Z"
と同じです。
.PD
.LP
全ての
.B grep
の変種は、以下のようなオプションを理解します:
.PD 0
.TP
.BI \-A " NUM" ", --after-context=" NUM
.I NUM
で指定した行数だけ、パターンにマッチした行の後の行も表示します。
.TP
.BI \-B " NUM" ", --before-context=" NUM
.I NUM
で指定した行数だけ、パターンにマッチした行の前の行も表示します。
.TP
.BI \-C ,\  --context"[=NUM]"
.I NUM
で指定した行数 (デフォルトは 2) だけ、パターンにマッチした行の前後の行も
表示します。
.TP
.BI \- NUM \ 
--context=NUM と同じように指定した行数だけ、
パターンにマッチした行の前後の行も表示します。
ただし、同じ行を 2 度以上表示する事はありません。
.TP
.B \-V, --version
.B grep
のバージョン番号を標準エラー出力に表示します。バグレポート
には、この番号を付記してください (下記参照)。
.TP
.B \-b ", " \-\^\-byte-offset
各出力行の前に、入力ファイルの先頭からのバイト単位のオフセットを表示します。
.TP
.B \-c, --count
通常の出力はせず、各入力ファイルについてマッチした行数を表示します。
.B \-v, --revert-match
オプションと共に指定した場合は、
マッチしなかった行数を表示します (下記参照)。
.TP
.BI \-d " ACTION" ", --directories=" ACTION
入力ファイルがディレクトリの場合に、
.I ACTION
を使ってその処理を行います。デフォルトでは
.I ACTION
は
.BR read
であり、ディレクトリを普通のファイルであるかの様に読み取る事を意味します。
.I ACTION
が
.BR skip
なら、ディレクトリを黙って読み飛ばします。
.I ACTION
が
.BR recurse
なら、
.B
grep は各ディレクトリ下のすべてのファイルを再帰的に読み取ります。
これは
.B \-r
オプションと等価です。
.TP
.BI \-e " PATTERN" ", --regexp=" PATTERN
.I PATTERN
をパターンとして指定します。
.BR \-
で始まるパターンを保護するために有効です。
.TP
.BI \-f " FILE" ", --file=" FILE
パターンを
.IR FILE
から 1 行ごとに読み込みます。
空のファイルはパターンを含まないので、何にもマッチしません。
.TP
.B \-h, --no-filename
複数ファイルを検索した時に、出力の前にファイル名を付けることを抑制します。
.TP
.B \-i, --ignore-case
.I pattern
と入力ファイルの双方で、英大文字と小文字の区別をしないようにします。
.TP
.B \-L, --files-without-match
通常の出力はせず、
このオプションを指定しなかったときに
全く出力されない入力ファイルの名前を表示します。
スキャン動作は最初のマッチで終了します。
.TP
.B \-l, --files-with-matches
通常の出力はせず、
このオプションを指定しなかったときに
出力される入力ファイルの名前を表示します。
スキャン動作は最初のマッチで終了します。
.TP
.B \-n, --line-number
各出力行の前に、入力ファイルにおける行番号を表示します。
.TP
.B \-q, --quiet, --silent
沈黙。通常の出力を抑止します。
スキャン動作は最初のマッチで終了します。
下記の
.B \-s
や
.B --no-messages
オプションも参照。
.TP
.B \-r, --recursive
各ディレクトリ下のすべてのファイルを再帰的に読み取ります。
これは
.B "\-d recurse"
オプションと等価です。
.TP
.B \-s, --no-messages
指定されたファイルが存在しないことや読み込みできないことを示す
エラーメッセージを抑止します。
移植性に関する注: GNU
.BR grep
とは異なり、BSD
.B grep
は \s-1POSIX.2\s0 に適合していませんでした。なぜなら、BSD
.B grep
には
.B \-q
オプションが無く、
.B \-s
オプションは GNU
.BR grep
の
.B \-q
オプションの様に動作したからです。BSD
.B grep
へ移植可能であることを意図したシェルスクリプトは、
.B \-q
と
.B \-s
を両方とも使わずに、出力を /dev/null へリダイレクトすべきです。
.TP
.B \-a, --text
バイナリデータを含む行の表示を抑止しません。
通常、ファイルの最初の数バイトがファイルにバイナリファイルが
含まれていることを示している場合、
.B grep
はファイルがパターンにマッチしたことだけを出力します。
このオプションにより、たとえ別の点ではファイルを
バイナリファイルとして扱うとしても、
.B grep
ファイルをテキストファイルとみなして動作します。
.TP
.B \-v, --revert-match
マッチの意味を逆転します。すなわち、マッチしない行を対象にします。
.TP
.B \-w, --word-regexp
完全な語にマッチする行のみを選択します。
部分文字列が行頭から始まっているか、
語でない文字列が前にあることがテストされます。
同様に、行末か語でない文字列が後に付いいる必要があります。
単語とは、レター・数字・アンダスコアからなる文字列です。
.TP
.B \-x, --line-regexp
行全体がマッチする行のみを選択します。
.TP
.B \-y
同じような意味を持つ
.BR \-i
により置き換えられました。
.TP
.B \-U, --binary
ファイルをバイナリとして扱います。デフォルトでは、MS-DOS と MS-Windows 環境下で
.BR grep
は、ファイルから読み取った最初の 32KB
の内容を見て、ファイルタイプを推測します。
.BR grep
はファイルをテキストファイルと判断した場合、オリジナルのファイル内容から
( 
.B ^
と
.B $
が使われている正規表現を正しく動作させるために )
CR 文字を取り除きます。
.B \-U
を指定すると、この当て推量を抑制し、すべてのファイルを読み取って
マッチ機構へそのまま渡します。もしファイルが
各行の末尾に CR/LF の組みを持つテキストファイルなら、
このオプションは正規表現を役に立たなくさせることがあるでしょう。
このオプションは MS-DOS と MS-Windows でのみサポートされています。
.TP
.B \-u, --unix-byte-offsets
unix 形式のバイト単位オフセットを報告します。このスイッチを指定すると
.B grep
は、ファイルが unix 形式のテキストファイル、
すなわち、 CR 文字が取り除かれたファイルであるかのごとくに
バイト単位オフセットを報告します。
このことは
.B grep
を Unix マシンで動作させたのと同じ結果を生成します。
このオプションは
.B \-b
オプションも使用しない限り効果がありません。
MS-DOS と MS-Windows のみサポートされています。
.PD
.LP
次のオプションは zlib(3) ライブラリと共にコンパイルした場合のみ使用可能です:
.PD 0
.TP
.B \-Z, --decompress
検索を開始する前に入力データを伸長します。
.PD
.SH "正規表現"
.PP
正規表現は、文字列の集合を表現するパターンの事です。数式表現と同様に、
より小さな表現を組み合わせるさまざまな演算子を用いる事で、
正規表現を組み立てます。
.PP
.B grep
は、「基本」正規表現と
「拡張」正規表現の 2 種類の正規表現文法を扱う事ができます。
.RB "GNU\ " grep
では、どちらの正規表現文法も機能的な違いはありません。
他の実装では、基本正規表現は拡張正規表現より能力が低くなっています。
ここでは、拡張正規表現について説明します。
基本正規表現との違いは、その後に説明します。
.PP
正規表現の基本単位は、1 文字にマッチする正規表現です。
レターと数字を含む多くの文字は、それ自身にマッチする正規表現です。
また、特殊な意味を持つメタ文字も、その文字の前にバックスラッシュ
を付けると、その本来の文字にマッチするようになります。
.PP
.B [
と
.B ]
で囲まれた文字のリストは、そのリスト中に含まれるどれか 1 文字にマッチします。
ただし、リストの先頭がキャレット
.B ^
の場合は、そのリストに含まれ
.I ない
文字にマッチします。
例えば、正規表現
.B [0123456789]
は数字 1 文字にマッチします。
アスキー文字の範囲は最初と最後の文字をハイフン (`-') でつなぐことで
指定できます。最後に、特定の名前を持つ文字クラスがあらかじめ定義されています。
名前が内容を示しており、それらは、
.BR [:alnum:] ,
.BR [:alpha:] ,
.BR [:cntrl:] ,
.BR [:digit:] ,
.BR [:graph:] ,
.BR [:lower:] ,
.BR [:print:] ,
.BR [:punct:] ,
.BR [:space:] ,
.BR [:upper:] ,
.BR [:xdigit:]
です。
例えば、
.B [[:alnum:]]
は
.BR [0-9A-Za-z]
と同じですが、後者は ASCII コード順に依存しますので、前者の方が可搬的です。
(クラス名の中の角括弧はシンボル名の一部であり、
リストを区切る角括弧とは別に指定する必要があることに注意)
リストの中では、ほとんどのメタ文字は通常の文字として扱われます。
リテラル
.B ]
を含めるには、この文字をリストの先頭に置いてください。同様に、リテラル
.B ^
を含めるには、この文字をリストの先頭以外に置いてください。リテラル
.B \-
を含めるには、この文字をリストの最後に置いてください。
.PP
ピリオド
.B .
は、任意の 1 文字にマッチします。
シンボル
.B \ew
は
.B [[:alnum:]]
と同じ意味で、
シンボル
.B \eW
は
.BR [^[:alnum:]]
と同じ意味です。
.PP
キャレット
.B ^
と、
ドル記号
.B $
は、それぞれ行頭と行末の空文字列にマッチするメタ文字です。
シンボル
.B \e<
とシンボル
.B \e>
は、それぞれ単語の先頭と末尾の空文字列にマッチするメタ文字です。
シンボル
.B \eb
は単語の端の空文字列にマッチします。
シンボル
.B \eB
は単語の端
.I 以外
の空文字列にマッチします。
.PP
正規表現の後には、繰り返し演算子のどれかが続くことがあります。
.PD 0
.TP
.B ?
直前の項目はオプションであり、最大 1 回マッチします。
.TP
.B *
直前の項目は 0 回以上マッチします。
.TP
.B +
直前の項目は 1 回以上マッチします。
.TP
.BI { n }
直前の項目は厳密に
.I n
回マッチします。
.TP
.BI { n ,}
直前の項目は
.I n
回以上マッチします。
.TP
.BI {, m }
直前の項目はオプションであり、最大
.I m
回マッチします。
.TP
.BI { n , m }
直前の項目は、最低
.I n
回、最大
.I m
回マッチします。
.PD
.PP
2 つの正規表現は結合可能です。
結果としてできあがる正規表現は、
結合された 2 つの部分表現にそれぞれマッチする
2 つの部分文字列を結合した任意の文字列にマッチします。
.PP
2 つの正規表現は中置き型演算子
.BR |
で繋ぐことが可能です。
結果としてできあがる正規表現は、
どちらかの部分表現にマッチする任意の文字列にマッチします。
.PP
繰り返しは結合に優先します。また結合は選択に優先します。
これらの優先規則を無効とするために、
部分表現全体を括弧で囲むことが可能です。
.PP
.I n
が 1 つの数字であるような
後方参照
.BI \e n
は、正規表現中の括弧で囲まれた
.IR n
番目の部分表現がマッチした文字列とマッチします。
.PP
基本正規表現では、メタ文字
.BR ? ,
.BR + ,
.BR { ,
.BR | ,
.BR ( ,
.BR )
は、その特殊な意味を失います。代わりに、バックスラッシュを付けた
.BR \e? ,
.BR \e+ ,
.BR \e{ ,
.BR \e| ,
.BR \e( ,
.BR \e) 
を使用してください。
.PP
.B egrep
では、
.B {
は、特殊な意味を失います; 代わりに、
.B \e{
を使う必要があります。
.SH "環境"
環境変数
.B GREP_OPTIONS
は、
.I grep
に対するデフォルトのオプションを保持する事が可能です。
これらのオプションは最初に解釈され、コマンドラインから
明示的に指定されたパラメータを上書きすることができます。
.SH 診断
.PP
通常、パターンにマッチした行が見つかった場合は 0 を、
見つからなかった場合は 1 を返します。(ただし、
.B \-v
オプションを指定した場合は、逆になります。)
パターンに文法エラーが存在したり、
入力ファイルにアクセスできないなどの
システムエラーが発生した場合は、2 を返します。
.SH バグ
.PP
バグレポートは、
.BR bug-gnu-utils@gnu.org
まで Email してください。
この時、Subject: のどこかに
grep という単語を
忘れずに入れてください。
.PP
.BI { m , n }
の表現で非常に大きな繰り返しを指定すると、非常に多くのメモリを消費します。
さらに、ある種のあいまいな正規表現を指定すると、必要となる時間とメモリ領域は
指数的に増大し、
.B grep
がメモリ不足を起こす可能性があります。
.PP
後方参照は非常に動作が遅く、必要となる時間は指数的に増大します。
