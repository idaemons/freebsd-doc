.\" jpman %Id: awk.1,v 1.3 1997/04/17 13:23:21 horikawa Stab %
.\" WORD: interval exptession	インターバル表現
.ds PX \s-1POSIX\s+1
.ds UX \s-1UNIX\s+1
.ds AN \s-1ANSI\s+1
.TH GAWK 1 "Dec 19 1996" "Free Software Foundation" "Utility Commands"
.SH 名称
gawk \- パターン検索・処理言語
.SH 書式
.B awk
[ POSIX or GNU style options ]
.B \-f
.I program-file
[
.B \-\^\-
] file .\^.\^.
.br
.B gawk
[ POSIX or GNU style options ]
[
.B \-\^\-
]
.I program-text
file .\^.\^.
.SH 解説
.I gawk
は GNU プロジェクトが実装した プログラミング言語 AWK の処理系です。
本処理系は \*(PX 1003.2 コマンド言語とユーティリティ規約に定められた
言語の定義に適合しています。
本バージョンはまた、Aho, Kernighan, Weinberger の著書『
.I The AWK Programming Language
』の記述にもとづいており、
System V Release 4 \*(UX の
.I awk
の付加機能も含んでいます。
.I gawk
はまた、ベル研究所の新機能および GNU 独自の拡張も提供します。
.PP
コマンドラインは、
.I gawk
へのオプション、(もし
.B \-f
または
.B \-\^\-file
オプションにより指定されていなければ)AWK のプログラムテキスト、そして
残りの引数列からなります。
この残りの引数列は、定義済み AWK 変数
.BR ARGC ,
.B ARGV
を用いることで参照できます。
.SH オプションフォーマット
.PP
.I gawk
へのオプションは、伝統的な \*(PX 形式の 1 文字オプションと、GNU 形式の
ロングオプションがあります。
\*(PX 形式のオプションは単一の ``\-'' で始まり、一方 GNU 形式のもの
は ``\-\^\-'' で始まります。ロングオプションは GNU の独自仕様と 
\*(PX の必須仕様の両方について用意されています。
.PP
\*(PX 標準に従い、
.I gawk
独自仕様のオプションは
.B \-W
オプションへの引数で与えます。
複数の
.B \-W
オプションを指定することもできます。
後述の
ように、各
.B \-W
オプションには、それに対応するロングオプション
が存在します。ロングオプションへの引数は、空白を入れずに
.B =
でつないで指定するか、その次のコマンドライン引数として渡すことができます。
ロングオプションは、短縮形が一意である限り、短縮することができます。
.SH オプショオン
.I gawk
は以下のオプションを受け付けます。
.TP
.PD 0
.BI \-F " fs"
.TP
.PD
.BI \-\^\-field-separator " fs"
入力フィールドセパレータ(変数
.B FS
の値)を
.I fs
とします。
.TP
.PD 0
\fB\-v\fI var\fB\^=\^\fIval\fR
.TP
.PD
\fB\-\^\-assign \fIvar\fB\^=\^\fIval\fR
プログラムを実行する前に、変数
.I var
に値
.I val
を設定します。このようにして設定
した変数は、 AWK プログラムの
.B BEGIN
ブロック内でも参照できます。
.TP
.PD 0
.BI \-f " program-file"
.TP
.PD
.BI \-\^\-file " program-file"
.B awk
への第 1 引数を用いるかわりに、AWK プログラムをファイル 
.I program-file
から読み込みます。
.B \-f
(または
.B \-\^\-file
) オプションは複数回使
用することができます。
.TP
.PD 0
.BI \-mf " NNN"
.TP
.PD
.BI \-mr " NNN"
さまざまなメモリの制限値を
.I NNN
に設定します。フラグ
.B f
は最大フィールド数、フラグ
.B r
は最大レコードサイズを設定します。この 2 つのフラグと
.B \-m 
オプションは、ベル研究所バージョンの \*(UX
.I awk
に由来しています。しかし、
.I gawk
にはこのような制限はありませんので、
.I gawk
では本オプションは無視されます。
.TP
.PD 0
.B "-W traditional"
.TP
.PD 0
.B "\-W compat"
.TP
.PD 0
.B \-\^\-traditional
.TP
.PD
.B \-\^\-compat
.I 互換
モードで動作します。互換モードでは、
.I gawk
は \*(UX
.I awk
と等価な動作を行い、GNU 独自拡張は解釈できません。
このオプションの他の形式よりも、
.B \-\^\-traditional
を使用することが好まれます。
詳しくは後述の
.B "GNU 拡張"
を参照してください。
.TP
.PD 0
.B "\-W copyleft"
.TP
.PD 0
.B "\-W copyright"
.TP
.PD 0
.B \-\^\-copyleft
.TP
.PD
.B \-\^\-copyright
GNU の著作権表示の短いバージョンを標準出力へ書き出し、
成功状態で終了します。
.TP
.PD 0
.B "\-W help"
.TP
.PD 0
.B "\-W usage"
.TP
.PD 0
.B \-\^\-help
.TP
.PD
.B \-\^\-usage
短めのオプション一覧を標準出力へ書き出します。
(GNU コーディング規約に
従い、本オプションを指定すると
.I awk
はただちに終了し、成功を意味する終了ステータスを返します。)
.TP
.PD
.B "\-W lint"
.TP
.PD 0
.B \-\^\-lint
他の AWK での処理が疑わしい、あるいは他の AWK との互換性がない構造が
ある場合に警告を行います。
.TP
.PD 0
.B "\-W lint\-old"
.TP
.PD
.B \-\^\-lint\-old
オリジナルの Unix
.I awk
へ移植できない構造に関して警告を行います。
.ig
.\" This option is left undocumented, on purpose.
.TP
.PD 0
.B "\-W nostalgia"
.TP
.PD
.B \-\^\-nostalgia
長い間
.I awk
を使ってきたユーザのために郷愁の瞬間を提供します。
..
.TP
.PD 0
.B "\-W posix"
.TP
.PD
.B \-\^\-posix
.I 互換
モードをオンにし、更に以下の制約が課せられます。
.RS
.TP \w'\(bu'u+1n
\(bu
.B \ex
エスケープシーケンスを解釈しません。
.TP
\(bu
.B FS
が単一の空白に設定された場合、空白とタブのみがフィールドを区切り、
改行はフィールドを区切りません。
.TP
\(bu
キーワード
.B function
に対応する別名
.B func
を解釈しません。
.TP
\(bu
演算子
.B ^
や
.B ^=
のかわりに
.B **
や
.B **=
を用いることができません。
.TP
\(bu
.B fflush()
関数は利用できません。
.RE
.TP
.PD 0
.B "\-W re\-interval"
.TP
.PD
.B \-\^\-re\-interval
正規表現のマッチングで
.I "インターバル表現 (interval expressions)"
を有効にします
(後述の
.BR "正規表現"
を参照してください)。
インターバル表現は伝統的な AWK 言語では利用できませんでした。
.I awk
と
.I egrep
が一貫性を持つように、POSIX 標準がこれらを追加しました。
しかし、これらを使用すると古い AWK プログラムを動かなくしてしまうでしょうから、
このオプションによって要求されたときと、
.B \-\^\-posix
が指定されたときに、
.I gawk
はこれらの機能を提供します。
.TP
.PD 0
.BI "\-W source " program-text
.TP
.PD
.BI \-\^\-source " program-text"
.I program-text
を AWK プログラムとして用います。本オプションにより、ライブラリ化された関数(
.B \-f
または
.B \-\^\-file
オプションを用いて読み込む)とコマンドラインから入力されたプログラムを
簡単に合成することができます。
これは、主にシェルスクリプトで用いられる中規模から大規模な AWK プログラム
のために用意されました。
.TP
.PD 0
.B "\-W version"
.TP
.PD
.B \-\^\-version
実行された
.I gawk
プログラムのバージョン情報を標準出力へ書き出します。これは主に、
あなたが使用している
.I gawk
プログラムが Free Software Foundation が配布してい
るプログラムのうち、最新のものであるかどうかを知る場合に便利です。
またバグレポートのときにも有用です。
(本オプションを指定すると、GNU コーディング規約に従い、
.I awk
はただちに終了し、成功を意味する終了ステータスを返します。)
.TP
.B \-\^\-
オプションの終了を意味します。AWK プログラムに
``\-'' から始まるオプションではない
引数を与える場合に便利です。
これは、主に他の \*(PX プログラムの多くが引数に対して行う解釈と
一貫性を保つためにあります。
.PP
互換モードでは、他のオプションは不正であるとされるか、無視されます。
通常の実行において、プログラムテキストがコマンドラインに指定されていれば、
不明なオプションは、AWK プログラムに
.B ARGV
配列を通して渡されます。これ
は、AWK プログラムを ``#!'' 機構を用いて実行する場合に特に便利です。
.SH AWK プログラムの実行
.PP
AWK プログラムは、パターンとアクションの組の列と、(もし必要なら)関数定義か
らなります。
.RS
.PP
\fIpattern\fB	{ \fIaction statements\fB }\fR
.br
\fBfunction \fIname\fB(\fIparameter list\fB) { \fIstatements\fB }\fR
.RE
.PP
.I gawk
はまず、
.I program-file
(複数可)が指定されていればそれから、
.B \-\^\-source
の引数から、あるいは、最初のオプションではない引数から
プログラムを読み込みます。
.B \-f
と
.B \-\^\-source
オプションは、コマンドラインで複数回指定できます。
.I gawk
は、すべての
.I program-file
とコマンドラインで指定したプログラムを結
合して使用します。新しく作った AWK プログラムひとつひとつに
AWK 関数のライブラリを埋め込む必要が無いので、この機能はライブラリの構築に
便利です。
また、ライブラリ関数とコマンドラインで指定したプログラムとを混合して使
うことも可能にしています。
.PP
環境変数
.B AWKPATH
により、
.B \-f
オプションで指定されたファイルを検索するパスを指定できます。
.B AWKPATH
が設定されていない場合のデフォルトパスは
\fB".:/usr/local/share/awk"\fR です。
(実際のディレクトリは
.I gawk
がどのように構築/インストールされたかに依存して、さまざまなものとなります。)
.B \-f
オプションで指定したファイル名が ``/'' を含んでいる場合は、
パス検索は行われません。
.PP
.I gawk
は、 AWK プログラムを次の順序で実行します。
まず、
.B \-v
オプションで指定された変数への代入をすべて行います。
次に、プログラムを内部形式にコンパイルします。
そして、(もし存在すれば)
.B BEGIN
ブロック(複数存在可)を実行します。
配列
.B ARGV
で指定されたファイルを順に読み、処理を行います(コマンドラインでファイル名が
指定されていなければ、標準入力に対して処理を行います)。
.PP
コマンドラインで指定されたファイル名が
.IB var = val
という形式ならば、それ
は変数への代入であると解釈されます。変数
.I var
は値
.I val
に設定されます
(これは、すべての
.B BEGIN
ブロックを実行したあとに行われます)。コマンドライン
での変数の代入は、AWK が入力をフィールドやレコードに分割するためのセパレータ
を実行時に変更するのに便利です。また、1 つのデータファイルに
対し数回処理を行う必要がある場合、状態をコントロールするのにも便利です。
.PP
配列
.B ARGV
の要素に空(\fB""\fR)がある場合、
.I gawk
はその要素を無視します。
.PP
.I gawk
は、入力された各レコードに対してマッチする
.I パターン
が AWK プログラム内にあるかどうかを
検索します。そのレコードにマッチしたパターンすべてについて、それぞれ対応する
.I アクション
が実行されます。
パターンは、プログラムテキストに出現した順序で検索されます。
.PP
入力が尽きると、
.I gawk
は(もしあれば)
.B END
ブロック(複数存在可)を実行します。
.SH 変数、レコード、フィールド
AWK における変数は動的、すなわち、最初に使用されたときに生成されます。
変数の値は、浮動小数点数か、文字列か、あるいは両方です。変数の用い
られ方により変化します。AWK ではまた、1次元配列を利用することができます。
多次元配列
も、擬似的にではありますが、利用可能です。プログラム実行開始時に、
いくつかの定義済み変数が設定されます。
これらを必要に応じて説明し、以下でまとめます。
.SS レコード
通常、レコードは改行文字により区切られます。
レコードの区切りは、組み込み変数
.B RS
へ値を代入することにより、制御できます。
.B RS
が単一文字の場合、その文字がレコードを区切ります。
そうでない場合は、
.B RS
は正規表現となります。
入力中のテキストで、この正規表現にマッチするものがレコードを区切ります。
しかし互換モードでは、
文字列値の最初の文字だけが、レコードセパレータに使用されます。
.B RS
が空文字列に設定されているときには、レコードは空行で区切られます。
.B RS
が空文字列に設定されたときには、
.B FS
の値にかかわらず、改行文字は常にフィールドセパレータとなります。
.SS フィールド
.PP
入力レコードを読み込むごとに、
.I gawk
はそのレコードを
.I フィールド
に分割しま
す。分割する際には、変数
.B FS
の値がフィールドセパレータとして参照されます。
.B FS
の値が1文字なら、その
文字を境にフィールドが分割されます。
.B FS
が空文字列の場合、個々の文字がフィールドセパレータとなります。
いずれでもない場合、
.B FS
は完全な正規表現である
と解釈されます。特殊な場合として
.B FS
が単一の空白のときには、フィールドは
連続した空白・タブ・改行により分割されます。
(後述の
.BR \-\-posix
の議論を参照してください)。
変数
.B IGNORECASE
(下記参照)の
値は、
.B FS
が正規表現の場合フィールド分割にも影響を与えることと、
.B RS
が正規表現の場合レコード分割にも影響を与えることに注意してください。
.PP
変数
.B FIELDWIDTHS
の値が空白で区切られた数字の列である場合、各フィールドは
固定長であると解釈され、
.I gawk
は指定された幅ごとにフィールドの
分割を行います。この場合、
.B FS
の値は無視されます。
.B FS
に新たに値を設定
することにより、この
.B FIELDWIDTHS
の効果を打ち消し、標準の動作に戻すことができます。
.PP
入力レコード中の各フィールドの値は、左から
.BR $1 ,
.B $2 
等という名前で参照できます。
.B $0
は
レコード全体です。フィールドに値を代入することもできます。フィールドは定数だ
けでなく、変数によって参照することもできます。以下の例では、入力レコードの 5 
番目のフィールドの値を出力します。
.RS
.PP
.ft B
n = 5
.br
print $n
.ft R
.RE
.PP
変数 NF は、自動的に入力レコードのフィールドの数に設定されます。
.PP
存在しないフィールド(すなわち、
.B $NF
より右のフィールド)を参照した結果は
空文字列になります。しかしながら、存在しないフィールドへの代入(たとえ
ば、
.BR $(NF+2) = 5
)は
.B NF
の値を増加させ、間のフィールドには空文字が設定されます。
さらに
.B $0
の値は、フィールドの値を変数
.B OFS
の値でフィールドを区切ったものとして再計算されます。
負のフィールド番号への参照は致命的エラーとなります。
.B NF
を減少させると、新しい値を越えるフィールドの値は失われます。
.B $0
の値は、フィールドの値を変数
.B OFS
の値でフィールドを区切ったものとして再計算されます。
.SS 組み込み変数
.PP
.I gawk
の組み込み変数は以下のとおりです。
.PP
.TP \w'\fBFIELDWIDTHS\fR'u+1n
.B ARGC
コマンドライン引数の個数(
.I gawk
へのオプションと、プログラム指定は含みま
せん)。
.TP
.B ARGIND
現在処理中のファイル名が格納されている配列
.B ARGV
のインデックス。
.TP
.B ARGV
コマンドライン引数の配列。配列は、 0 から
.B ARGC
\- 1 までのインデックスを
持ちます。
.B ARGV
の内容を変更することで、入力に用いるファイル名を変
更することができます。
.TP
.B CONVFMT
数値の変換フォーマット。デフォルト値は \fB"%.6g"\fR です。
.TP
.B ENVIRON
現在の環境変数の値からなる配列。配列は、環境変数名によりインデックスされ
、各要素の値はその環境変数の値です(例えば
\fBENVIRON["HOME"]\fP は
.B /home/arnold
となるでしょう)。本配列に
代入を行っても、
.I gawk
からリダイレクトや
.B system()
関数により実行される
プログラムの環境には影響を与えません(これは、将来の
.I gawk
では変更される可能性があります)。
.\" but don't hold your breath...
.TP
.B ERRNO
.B getline
のリダイレクト、
.B getline
による読み込み、
.B close()
関数の実行時のいずれかにシステムエラーが発生した場合、変数
.B ERRNO
にはエラーの内容を示した文字列が設定されます。
.TP
.B FIELDWIDTHS
空白で区切られたフィールド長のリスト。もしこの値が設定されていれば、
.I gawk
は 
.B FS
の値を用いてフィールド分割するかわりに、固定長のフィールド分割を行
います。固定長のフィールド分割機能はまだ実験的なもので、
.I gawk
が改良されるに従って意味が変化する可能性があります。
.TP
.B FILENAME
現在の入力ファイル名。もし、コマンドラインで入力ファイルが指定されてい
なければ、
.B FILENAME
の値は ``\-'' です。しかしながら、
.B BEGIN
ブロック内では 
.B FILENAME
は未定義です。
.TP
.B FNR
現在の入力ファイルにおける入力レコード番号。
.TP
.B FS
入力フィールドセパレータ。デフォルトでは単一の空白です。
上述の
.B フィールド
を参照してください。
.TP
.B IGNORECASE
すべての正規表現と文字列操作において大文字小文字の区別を制御します。もし、
.B IGNORECASE
が 0 でない値に設定されていれば、文字列比較、ルールのパターンマッチ、
.B FS
によるフィールド分割、
.B RS
によるレコード分割、
.B ~
と
.B !~
による正規表現マッチ、定義済み関数
.BR gensub() ,
.BR gsub() ,
.BR index() ,
.BR match() ,
.BR split() ,
.B sub()
において大文字と小文字の違いは無視されます。このため、
.B IGNORECASE
が 0 以外の値なら、
.B /aB/
は \fB"ab"\fP, \fB"aB"\fP, \fB"Ab"\fP, \fB"AB"\fP
のいずれにもマッチすることになります。
他のAWK 変数と同様に
.B IGNORECASE
の初期値は 0 なので、通常は
正規表現と文字列操作において大文字と小文字は区別されます。
Unix では、大文字小文字を無視する場合、
ISO 8859-1 Latin-1 文字集合全てを使用できます。
.B 注:
3.0 以前の
.I gawk
では
.B IGNORECASE
は正規表現操作のみに影響しました。現在は文字列比較にも影響します。
.TP
.B NF
現在の入力レコードのフィールド数。
.TP
.B NR
現在までに読み込んだ入力レコード数の合計。
.TP
.B OFMT
数字の出力フォーマット。デフォルト値は \fB"%.6g"\fR です。
.TP
.B OFS
出力フィールドセパレータ。デフォルトは空白です。
.TP
.B ORS
出力レコードセパレータ。デフォルトは改行です。
.TP
.B RS
入力レコードセパレータ。デフォルトは改行です。
.TP
.B RT
レコードターミネータ。
.I gawk
は、
.B RS
で指定される文字または正規表現にマッチする入力テキストを、
.B RT
に設定します。
.TP
.B RSTART
.B match()
によりマッチした最初の文字の位置。0 はマッチしなかったことを示します。
.TP
.B RLENGTH
.B match()
によりマッチした文字列の長さ。\-1 はマッチしなかったことを示します。
.TP
.B SUBSEP
多次元配列を実現する際に用いられる、配列のインデックスを結合する文字。
デフォルト値は \fB"\e034"\fR です。
.SS 配列
.PP
配列は、ブラケット
.RB ( [
と
.BR ] )
の間の式によってインデックスを指定します。もし式が式
のリスト(式, 式, ...) なら、式の値を変数
.B SUBSEP
の値を区切りとして
結合した文字列をインデックスとして用います。これにより、多次元配列を
シミュレートしています。例えば、
.PP
.RS
.ft B
i = "A";\^ j = "B";\^ k = "C"
.br
x[i, j, k] = "hello, world\en"
.ft R
.RE
.PP
は、文字列 \fB"hello, world\en"\fR を、文字列 \fB"A\e034B\e034C"\fR で
インデックスした配列 x の要素に代入しています。
AWK の配列はすべて、文字列によりインデックスを行う連想配列です。
.PP
特殊な演算子
.B in
を
.B if
または
.B while
ステートメントで用いることによって、あるインデックス値に
おける配列の値が定義されているかを調べることができます。
.PP
.RS
.ft B
.nf
if (val in array)
	print array[val]
.fi
.ft
.RE
.PP
もし、配列が多次元インデックスを持つなら、
.B "(i, j) in array"
を用います。
.PP
.B in
はまた、
.B for
ループ中で、配列のすべてのインデックス値について繰り返すために
用いることができます。
.PP
配列の要素は、
.B delete
ステートメントを用いて削除することができます。
.B delete
ステートメントはまた、
添字を指定せずに配列名のみを指定することにより、
配列全体を削除するためにも使えます。
.SS 変数の型と変換
.PP
変数とフィールドは、(浮動小数点数の)数値または文字列、あるいは両方として
扱われます。
変数の値がどのように解釈されるかは、変数の使われ方によって変化します。
数式中で用いられれば変数は数値として解釈され、文字列として用いられれ
ば文字列として解釈されます。
.PP
変数の値を強制的に数値であると解釈させたい場合は、変数に 0 を加えます。
文字列と解釈させたい場合は空文字列を結合します。
.PP
文字列を数値に変換する必要がある場合、変換は
.IR atof (3)
によって行われます。
数値を文字列に変換する場合は、変数
.B CONVFMT
の値をフォーマット文字列として用いて、
.IR sprintf (3)
により行われます。AWK ではすべての数値は浮動小数点数ですが、整数値は常に整数
として変換が行われます。
よって、以下の場合、
.PP
.RS
.ft B
.nf
CONVFMT = "%2.2f"
a = 12
b = a ""
.fi
.ft R
.RE
.PP
変数
.B b
は文字列値 \fB"12"\fR となり、\fB"12.00"\fR とはなりません。
.PP
.I gawk
は、以下のようにして比較を行います: 
2 つの変数が数値なら数値として比
較します。もし片方が数値で片方が`数値'文字列なら、数値として比較されます。
片方が数値でない文字列なら、数値のほうが文字列に変換され、文字列として
比較されます。両方とも文字列なら、文字列として比較されます。\*(PX 標準に従う
なら、両方とも数値文字列の場合は数値として比較しますが、これは明ら
かに間違いです。
.I gawk
はそのような動作をしません。
.PP
\fB"57"\fP のような文字列定数は数値文字列では
.I なく
、文字列定数です。「数値文字列」の概念は、フィールド、
.B getline
の入力、
.B FILENAME
、
.B ARGV
の要素、
.B ENVIRON
の要素、数値文字列から
.B split()
によって作成された配列の要素に対してのみ適用されます。
基本的な考え方では、
.I ユーザ入力
、それも数値に見えるユーザ入力のみが数値として扱われます。
.PP
初期化されていない変数は、数値としては 0 を、文字列としては "" (空文字列)を
持ちます。
.SH パターンとアクション
awk は行指向の言語です。まずパターン、次にアクションが続きます。
アクションは
.B {
と
.B }
で囲みます。パターンまたはアクションは省略することもできます。
もちろん、両方とも
省略してしまっては意味がありません。
パターンがない場合、アクションはすべての入力レコードに
対して適用されます。省略されたアクションは以下と等価です。
.RS
.PP
.B "{ print }"
.RE
.PP
これはレコード全体を出力します。
.PP
コメントは文字 ``#'' で始まり、行末まで続きます。空行は、複数ステートメントの
間をあけるのに使うことができます。
通常、ステートメントは改行で終わります。ただし、
次の記号で行が終わる場合にはこの限りではありません: ``,'',
.BR { ,
.BR ? ,
.BR : ,
.BR && ,
.B ||
。
.B do
または
.B else
で終わる行は、ステートメントが自動的に以降
の行へ継続されます。また、改行の直前に ``\e'' を置くことで、
行を継続することができます。この場合、その改行は無視されます。
.PP
``;'' で区切ることにより、1行に複数のステートメントを記述することができます。
(通常のように)
パターン-アクション対中のアクション部におけるステートメントだけではなく、
パターン-アクション対ステートメント自身も、
 ``;'' で区切って複数置くことができます。
.SS パターン
AWK のパターンは、以下のうちのいずれかです。
.PP
.RS
.nf
.B BEGIN
.B END
.BI / "regular expression" /
.I "relational expression"
.IB pattern " && " pattern
.IB pattern " || " pattern
.IB pattern " ? " pattern " : " pattern
.BI ( pattern )
.BI ! " pattern"
.IB pattern1 ", " pattern2
.fi
.RE
.PP
.B BEGIN
と
.B END
は特殊なパターンであり、入力と比較されることはありません。すべての 
.B BEGIN
パターンに対応したアクション部は結合され、
そのようなすべてのアクション部が単一の
.B BEGIN
ブロック中にあるかのように扱われます。
結合されたアクションは、
すべての入力ファイルの読み込みに先立って実行されます。同様にすべての
.B END
ブロックは結合され、すべての入力ファイルの処理後(あるいは、exit ステートメント
が実行されたとき)に実行されます。
.B BEGIN
と
.B END
はパターン式内で他のパターンと混ぜて使うことはできません。また、
.B BEGIN
と
.B END
パターンはアクション部を省略することができません。
.PP
.BI / "regular expression" /
パターンでは、正規表現(regular expression)
にマッチした入力レコードに対してアクション
が実行されます。正規表現は
.IR egrep (1)
と同じものが使えます。あとに要約を示します。
.PP
.I 関係式(relational expression)
では、後述のアクションについての節で示す演算子を用いることが
できます。
これらは概して、特定のフィールドが正規表現にマッチするかどうかを
調べるために用いられます。
.PP
演算子
.BR && ,
.BR || ,
.B !
は、それぞれ C 言語での論理AND、論理OR、論理NOT と等価です。
C 言語と同様に、評価値が確定した時点で以降の評価を打ち切ります。
これらは複数のパターン式を結合するために使用されます。
他のプログラミング言語と同様、括弧によって評価順序を変更することができます。
.PP
.B ?\^:
演算子は C 言語のものと同様です。もし、最初のパターンが真なら、
テストのために 2 番目のパターンが用いられ、そうでなければ 3 番目のパターンが
用いられます。2 番目と 3 番目のパターンのどちらかだけが評価されます。
.PP
.IB pattern1 ", " pattern2
形式は
.I 範囲パターン
と呼ばれます。範囲パターンは、
.I pattern1 
にマッチするレコードから、
.I pattern2
にマッチするレコードまでのすべてにマッチします。
この形式は、他のパターン式と混合して用いることはできません。
.SS 正規表現
awk の正規表現は
.I egrep
のものと同様に、拡張された正規表現です。
以下の構成要素から成り立っています。
.TP \w'\fB[^\fIabc...\fB]\fR'u+2n
.I c
メタ文字ではない
.I c
にマッチする。
.TP
.I \ec
リテラル文字
.I c
にマッチする。
.TP
.B .
改行を
.I 含む
任意の 1 文字にマッチする。
.TP
.B ^
文字列の先頭にマッチする。
.TP
.B $
文字列の終端にマッチする。
.TP
.BI [ abc... ]
文字リストであり、
.I abc...
のいずれか 1 文字にマッチする。
.TP
.BI [^ abc... ]
文字リストの逆であり、
.I abc...
以外の 1 文字にマッチする。
.TP
.IB r1 | r2
選言:
.I r1
または
.I r2
にマッチする。
.TP
.I r1r2
結合:
.I r1
の直後に
.I r2
が続くものにマッチする。
.TP
.IB r +
.I r
の 1 回以上の繰り返しにマッチする。
.TP
.IB r *
.I r
の 0 回以上の繰り返しにマッチする。
.TP
.IB r ?
.I r
の 0 回または 1 回の繰り返しにマッチする。
.TP
.BI ( r )
グループ化:
.I r
にマッチする。
.TP
.PD 0
.IB r { n }
.TP
.PD 0
.IB r { n ,}
.TP
.PD
.IB r { n , m }
ブレース中に 1 つか 2 つの数値を記述することにより、
.I "インターバル表現"
を表します。ブレース中に数値が 1 つある場合、直前の正規表現
.I r
が
.I n
回繰り返されます。2 つの数値がコンマで区切られている場合、
.I r
は
.I n
回から
.I m
回繰り返されます。1 つの数値に続いてコンマがある場合、
.I r
は少なくとも
.I n
回繰り返されます。
.sp .5
インターバル表現は
.B \-\^\-posix
または
.B \-\^\-re\-interval
がコマンドラインにて指定されているときのみ利用可能です。
.TP
.B \ey
語の先頭または末尾の空文字列にマッチします。
.TP
.B \eB
語の中の空文字列にマッチします。
.TP
.B \e<
語の先頭の空文字列にマッチします。
.TP
.B \e>
語の末尾の空文字列にマッチします。
.TP
.B \ew
語を構成する文字 (レター、数値、アンダスコア) にマッチします。
.TP
.B \eW
語を構成する文字以外の文字にマッチします。
.TP
.B \e`
バッファ (文字列) の先頭の空文字列にマッチします。
.TP
.B \e'
バッファの末尾の空文字列にマッチします。
.PP
文字列定数中で用いることができるエスケープシーケンス(後述参照)は、
正規表現中でも使用することができます。
.PP
.I 文字クラス
は POSIX 標準で導入された新機能です。
文字クラスは特定の属性を持つ文字列リストの特殊表現ですが、
実際の文字集合自身は国や文字集合によって様々なものとなります。
例えば、アルファベット文字はアメリカ合州国とフランスとでは異なります。
.PP
文字クラスが有効なのは、
文字リストのブラケットの中の正規表現だけです。
文字クラスは、
.B [:
と、クラスを表現するキーワードと、
.B :]
で構成されます。
以下に POSIX 表現で定義される文字クラスを示します。
.TP
.B [:alnum:]
アルファベットと数値文字。
.TP
.B [:alpha:]
アルファベット文字。
.TP
.B [:blank:]
空白とタブ文字。
.TP
.B [:cntrl:]
制御文字。
.TP
.B [:digit:]
数値文字。
.TP
.B [:graph:]
印字可能で可視な文字。
(空白は印字可能ですが見えません。一方
.B a
は印字可能かつ可視です。)
.TP
.B [:lower:]
アルファベット文字の小文字。
.TP
.B [:print:]
印字可能な文字 (制御文字以外)。
.TP
.B [:punct:]
句読点文字 (レター、数値、制御文字、空白文字のいずれでもない文字)。
.TP
.B [:space:]
空白文字 (空白、タブ、フォームフィード等の少数の文字を指す)。
.TP
.B [:upper:]
アルファベット文字の大文字。
.TP
.B [:xdigit:]
16 進数の数値。
.PP
例えば、POSIX 標準以前では、アルファベットと数値の文字にマッチするためには、
.B /[A\-Za\-z0\-9]/
と書きました。しかし、別のアルファベット文字が文字集合に含まれる場合、
それらにはマッチしません。
POSIX 文字クラスでは、
.BR /[[:alnum:]]/
と記述することができ、文字集合の
.I すべて
のアルファベットと数値にマッチします。
.PP
文字リスト中には、更に 2 つの特殊シーケンスを使用できます。
これらは、
複数の文字によって表現される単一シンボル (
.I 照合文字
と呼ばれます) を持ち、
複数の文字が
.I 参照
やソートにおいては等価であるとされる、非 ASCII 文字集合に適用されます。
(例えば、フランス語では単なる ``e'' とグレーブアクセント付きの e\` とでは
等価です。)
.TP
照合シンボル
参照シンボルは複数文字の参照要素であり、
.B [.
と
.B .]
で括ります。
例えば、
.B ch
が参照要素の場合、
.B [[.ch.]]
は正規表現となり、この参照要素にマッチします。
一方、
.B [ch]
は
.B c
か
.B h
にマッチする正規表現です。
.TP
等価クラス
等価クラスは
等価な文字リストを指すロケール固有の名前です。名前は
.B [=
と
.B =]
で括ります。
例えば、名前
.B e
は ``e,'' ``e\`,'', ``e\`.'' のすべてを表現するために使用されるかもしれません。
この場合、
.B [[=e=]]
は
.BR e ,
.BR e\' ,
.BR e\`
のいずれかにマッチする正規表現となります。
.PP
これらの機能は英語以外のロケールにて非常に有用です。
.I gawk
が正規表現のマッチングに使用するライブラリ関数は、
現在 POSIX 文字クラスのみを理解し、
参照シンボルと等価クラスは理解しません。
.PP
.BR \ey ,
.BR \eB ,
.BR \e< ,
.BR \e> ,
.BR \ew ,
.BR \eW ,
.BR \e` ,
.B \e'
の演算子は
.IR gawk
固有であり、GNU 正規表現ライブラリの機能を元にした拡張です。
.PP
様々なコマンドラインオプションによって、正規表現中の文字を
.I gawk
がどのように解釈するのかを制御できます。
.TP
オプション無し
デフォルトでは、
.I gawk
は上述の POSIX 正規表現および GNU 正規表現のすべての機能を提供します。
しかしながら、インターバル表現はサポートされません。
.TP
.B \-\^\-posix
POSIX 正規表現のみがサポートされ、GNU 演算子はサポートされません
(例えば、
.B \ew
はリテラル
.B w
にマッチします)。
インターバル表現は許されます。
.TP
.B \-\^\-traditional
伝統的な Unix
.I awk
の正規表現がサポートされます。GNU 演算子、インターバル表現、
POSIX 文字クラス (
.B [[:alnum:]]
など) はサポートされません。
8 進または 16 進のエスケープシーケンスで表現される文字は、
正規表現のメタ文字を表現するとしても、
リテラルとして扱われます。
.TP
.B \-\^\-re\-interval
.B \-\^\-traditional
が指定されていたとしても、正規表現中でインターバル表現をサポートします。
.SS アクション
アクションは、ブレース
.B {
と
.B }
で囲みます。アクションは通常の代入、条件文、
ループ文等からなります。演算子、制御文、入出力文は C 言語とほぼ同様です。
.SS 演算子
.PP
AWK での演算子を、優先順位の高いものから順に示します。
.PP
.TP "\w'\fB*= /= %= ^=\fR'u+1n"
.BR ( \&... )
グループ化。
.TP
.B $
フィールド参照。
.TP
.B "++ \-\^\-"
インクリメント、デクリメント。前置も後置も可能。
.TP
.B ^
べき乗(\fB**\fR も同様の意味で使用できる。また \fB**=\fR 代入演算子も存在する)。
.TP
.B "+ \- !"
単項のプラス、マイナス、論理否定。
.TP
.B "* / %"
乗算、除算、剰余。
.TP
.B "+ \-"
加算と減算。
.TP
.I space
文字列結合。
.TP
.PD 0
.B "< >"
.TP
.PD 0
.B "<= >="
.TP
.PD
.B "!= =="
通常の関係演算子。
.TP
.B "~ !~"
正規表現マッチ、否定のマッチ。
.B 注意:
.B ~
と
.B !~
の左辺に正規表現定数
.RB ( /foo/ 等)
を用いてはいけません。正規表現定数は右辺にのみ置くことができます。式
.BI "/foo/ ~ " exp
は
\fB(($0 ~ /foo/) ~ \fIexp\fB)\fR と等価であり、これは通常意図するものとは異なります。
.TP
.B in
配列のメンバ。
.TP
.B &&
論理 AND。
.TP
.B ||
論理 OR。
.TP
.B ?:
C 言語の条件式と同様です。
.IB expr1 " ? " expr2 " : " expr3\c
の形式で使います。もし 
.I expr1
が真なら式の値は
.I expr2
になり、そうでなければ
.I expr3
になります。
.I expr2
か
.I expr3
のうち片方のみが評価されます。
.TP
.PD 0
.B "= += \-="
.TP
.B "*= /= %= ^="
代入。絶対代入
.BI ( var " = " value )
と演算子代入 (他の形式) がサポートされています。
.SS 制御ステートメント
.PP
制御ステートメントは以下のとおりです。
.PP
.RS
.nf
\fBif (\fIcondition\fB) \fIstatement\fR [ \fBelse\fI statement \fR]
\fBwhile (\fIcondition\fB) \fIstatement \fR
\fBdo \fIstatement \fBwhile (\fIcondition\fB)\fR
\fBfor (\fIexpr1\fB; \fIexpr2\fB; \fIexpr3\fB) \fIstatement\fR
\fBfor (\fIvar \fBin\fI array\fB) \fIstatement\fR
\fBbreak\fR
\fBcontinue\fR
\fBdelete \fIarray\^\fB[\^\fIindex\^\fB]\fR
\fBdelete \fIarray\^\fR
\fBexit\fR [ \fIexpression\fR ]
\fB{ \fIstatements \fB}
.fi
.RE
.SS 入出力ステートメント
.PP
入出力ステートメントは以下のとおりです。
.PP
.TP "\w'\fBprintf \fI書式, 式の列\fR'u+1n"
.BI close( file )
ファイル (またはパイプ、下記参照) をクローズします。
.TP
.B getline
次のレコードを
.B $0
に読み込みます。
.BR NF ,
.BR NR ,
.B FNR
が設定されます。
.TP
.BI "getline <" file
ファイル
.I file
から次のレコードを
.B $0
に読み込みます。
.B NF
が設定されます。
.TP
.BI getline " var"
次のレコードを変数
.I var
に読み込みます。
.BR NR ,
.B FNR
が設定されます。
.TP
.BI getline " var" " <" file
ファイル
.I file
から次のレコードを変数
.I var
に読み込みます。
.TP
.B next
現在のレコードに対する処理を終了し、次のレコードを読み込み、AWK プログ
ラムの最初のパターンから処理を開始します。
C 言語の continue と類似した意味を持ちます。
もし、入力データの終端に達した場合、
.B END
ブロックが存在すれば実行されます。
.TP
.B "nextfile"
現在の入力ファイルに対する処理を終了し、次の入力ファイルからレコードを
読み込みます。
.B FILENAME
と
.B ARGIND
が更新され、
.B FNR
が 1 にリセットされ、AWK プログラムの
最初のパターンから処理が開始されます。入力データの終端に達したときは、
もし存在すれば、
.B END
ブロックが実行されます。
.B 注:
以前のバージョンの gawk では
.BR "next file"
と 2 語で使用されていました。この用法はまだ認識されますが、
警告メッセージを生じさせますし、最終的には無くなる表現です。
.TP
.B print
現在のレコードを出力します。
出力レコードは
.B ORS
変数の値にて終端されます。
.TP
.BI print " expr-list"
式を出力します。各式は
.B OFS
の値で区切られます。出力されるレコードの最後に
は
.B ORS
の値が付加されます。
.TP
.BI print " expr-list" " >" file
式をファイル
.I file
に出力します。各式は
.B OFS
の値で区切られます。出力されるレコードの
最後には
.B ORS
の値が付加されます。
.TP
.BI printf " fmt, expr-list"
書式付き出力です。
.TP
.BI printf " fmt, expr-list" " >" file
ファイル
.I file
への書式付き出力です。
.TP
.BI system( cmd-line )
コマンド
.I cmd-line
を実行し、終了ステータスを返します(\*(PX に対応しない
システムでは使用できない場合があります)。
.TP
\&\fBfflush(\fR[\fIfile\^\fR]\fB)\fR
オープンされている出力ファイルまたはパイプ
.I file
に関連づけられているバッファをフラッシュします。
.I file
を指定しないと、標準出力がフラッシュされます。
.I file
が空文字列の場合、オープンされているすべてのファイルとパイプのバッファを
フラッシュします。
.PP
その他の形式のリダイレクトとして以下のものが利用可能です。
.B print
と
.B printf 
に対して、
.BI >> file
を指定すると出力はファイル
.I file
に追加され、
.BI | " command"
は出力をパイプに対して行います。同様に、
.IB command "| getline"
はコマンドの出力から 
.B getline
を行ないます。
.B getline
はファイル終端では 0 を、エラー時には \-1 を返します。
.SS \fIprintf\fP\^ ステートメント
.PP
AWK での
.B printf
ステートメントと
.B sprintf()
関数(後述参照)は、以下の変換指定書式を受け付けます。
.TP
.B %c
1 つの \s-1ASCII\s+1 文字。
.B %c
に対応する引数が数値なら、その値を \s-1ASCII\s+1 コードとみなし
て文字に変換します。そうでなければ、引数は文字列であると解釈され、その1
文字目が出力されます。
.TP
.B %d
.PD 0
.TP
.B %i
10進数(整数部分)。
.TP
.PD 0
.B %e
.TP
.PD
.B %E
.B [-]d.dddddde[+-]dd
という形式の浮動小数点数。
.B %E
形式では
.B e
の代りに
.B E
が使用されます。
.TP
.B %f
.B [-]ddd.dddddd
という形式の浮動小数点数。
.TP
.PD 0
.B %g
.TP
.PD
.B %G
.B %e
と
.B %f
の短い方の形式の浮動小数点数。余計な 0 は省略されます。
.B %G
形式では
.B %e
の代りに
.B %E
を使用します。
.TP
.B %o
符号なしの 8 進数(整数)。
.TP
.B %s
文字列。
.TP
.PD 0
.B %x
.TP
.PD
.B %X
符号なしの 16 進数(整数)。
.B %X
形式では、
.B abcdef
の代りに
.B ABCDEF
を用います。
.TP
.B %%
単一の文字
.B %
。引数は使用しません。
.PP
.B %
と上記の制御文字との間にオプショナルな追加のパラメータを置く
ことができます。以下にそれらを示します。
.TP
.B \-
左寄せ。
.TP
.I 空白
数値変換において、正の値のプレフィックスは空白となり、
負の値のプレフィックスはマイナス記号となります。
.TP
.B +
プラス記号は幅修正子 (後述) の前に使用し、
整形されるデータが正であったとしても、
数値変換に対して常に符号を付けることを指示します。
.B +
は空白修正子に優先します。
.TP
.B #
ある制御レターに対して「別の形式」を使用します。
.BR %o
に対しては先行する 0 を与え、
.BR %x
と
.BR %X
に対しては非 0 の結果に対して先行する
.BR 0x 
と
.BR 0X 
を与えます。
.BR %e ,
.BR %E ,
.B %f
に対しては結果に常に小数点を含めます。
.BR %g ,
.B %G
に対しては結果の後尾から 0 を取り除きません。
.TP
.B 0
先頭の
.B 0
(ゼロ) はフラグとして動作し、
出力を空白ではなく 0 でパディングすることを示します。
これは非数値の出力書式に対しても適用されます。
このフラグが有効なのは、フィールド幅が印字される値の幅より広いときだけです。
.TP
.I width
フィールドが指定した幅
.I width
になるようにパディングされます。フィールドは通常空白でパディングされます。
.B 0
フラグが使用された場合には 0 でパディングされます。
.TP
.BI . prec
印字において使用する精度を数値で指定します。
.BR %e ,
.BR %E ,
.B %f 
の書式に対しては、小数点の右側に印字される数字の数を指定します。
.BR %g ,
.B %G
の書式に対しては、仮数部の最大数を指定します。
.BR %d ,
.BR %o ,
.BR %i ,
.BR %u ,
.BR %x ,
.B %X
の書式に対しては、印字される数字の最小数を指定します。
文字列に対しては、印字される文字列からとりだされる最大の文字数を指定します。
.PP
\*(AN C の
.B printf()
の動的な幅
.I width
と精度
.I prec
の指定機能が使用できます。
.B 幅
または
.B 精度
の指定部分に
.B *
を指定することで、その値を
.B printf
または
.B sprintf()
への引数で指定できます。
.SS 特殊ファイル名
.PP
.B print
や
.B printf
で書き込みときでも、
.B getline
でファイルから読み取るときでも、
入出力リダイレクトを行う場合、
.I gawk
は内部的な特殊なファイル名を解釈します。
これらのファイル名により、親プロセス(通常はシェルです)から受け継いだ
オープン状態のファイルディスクリプタを用いて入出力を行ったり、実行中の
.I gawk
プロセスに関する情報を得ることができます。
特殊ファイル名は以下のとおりです。
.TP \w'\fB/dev/stdout\fR'u+1n
.B /dev/pid
現在のプロセスのプロセスID(10進数で、最後に改行が付きます)を
読み込むことができます。
.TP
.B /dev/ppid
現在のプロセスの親のプロセスのプロセスID(10進数で、最後に改行が付きます)を
読み込むことができます。
.TP
.B /dev/pgrpid
現在のプロセスのプロセスグループ ID(10進数で、最後に改行が付きます)
を読み込むことができます。
.TP
.B /dev/user
このファイルを読むことで、改行で終わる単一のレコードが得られます。
各フィールドは空白で区切られています。
.B $1
は
.IR getuid (2)
システムコールの値、
.B $2
は 
.IR geteuid (2)
システムコールの値、
.B $3
は
.IR getgid (2)
システムコールの値、
.B $4 
は
.IR getegid (2)
システムコールの値です。もし、さらにフィールドがあれば、
それは
.IR getgroups (2)
システムコールが返すグループ ID のリストです。
全てのシステムで複数のグループがサポートされているわけではありません。
.TP
.B /dev/stdin
標準入力。
.TP
.B /dev/stdout
標準出力。
.TP
.B /dev/stderr
標準エラー出力。
.TP
.BI /dev/fd/\^ n
オープンされたファイルディスクリプタ
.I n
に対応しているファイル。
.PP
エラーメッセージを出力するには、以下の方法が便利です。
.PP
.RS
.ft B
print "You blew it!" > "/dev/stderr"
.ft R
.RE
.PP
もしこの機能が無かったら、次のようにするしかないところです。
.PP
.RS
.ft B
print "You blew it!" | "cat 1>&2"
.ft R
.RE
.PP
これらのファイル名は、コマンドラインのデータファイル指定で使うこともできます。
.SS 数値関数
.PP
AWK は以下の定義済み数値関数を持っています。
.PP
.TP \w'\fBsrand(\fR[\fIexpr\^\fR]\fB)\fR'u+1n
.BI atan2( y , " x" )
.I y/x
の逆正接をラジアンで与えます。
.TP
.BI cos( expr )
.I expr
の余弦をラジアンで与えます。
.TP
.BI exp( expr )
指数関数。
.TP
.BI int( expr )
整数への切捨て。
.TP
.BI log( expr )
自然対数。
.TP
.B rand()
0 から 1 の間の乱数を与えます。
.TP
.BI sin( expr )
.I expr
の正弦をラジアンで与えます。
.TP
.BI sqrt( expr )
平方根。
.TP
\&\fBsrand(\fR[\fIexpr\^\fR]\fB)\fR
.I expr
の値を乱数生成関数の種として用います。式が指定されなかった場合は、
時刻が用いられます。直前の種の値を返します。
.SS 文字列関数
.PP
.I gawk
は以下の定義済み文字列関数を持っています。
.PP
.TP "\w'\fBsprintf(\^\fIfmt\fB\^, \fIexpr-list\^\fB)\fR'u+1n"
\fBgensub(\fIr\fB, \fIs\fB, \fIh \fR[\fB, \fIt\fR]\fB)\fR
対象文字列
.I t
から正規表現
.I r
のマッチを探します。
.I h
が
.B g
または
.B G
で開始する文字列の場合、マッチする
.I r
をすべて
.I s
に置き換えます。
そうでない場合、
.I h
は何番目の
.I r
のマッチを置き換えるのかを示します。
.I t
が与えられない場合、代りに
.B $0
が使用されます。
置換テキスト
.I s
では、シーケンス
.BI \e n\fR
ただし
.I n
は 1 から 9 までの数字を使用して、
.I n
番目にマッチした括弧付きサブ式を示すことができます。
シーケンス
.B \e0
は文字
.B &
と同様、マッチしたテキスト全体を表します。
.B sub()
や
.B gsub()
とは異なり、修正された文字列が関数の結果として返され、
元の対象テキストは変更され
.I ません
。
.TP "\w'\fBsprintf(\^\fIfmt\fB\^, \fIexpr-list\^\fB)\fR'u+1n"
\fBgsub(\fIr\fB, \fIs \fR[\fB, \fIt\fR]\fB)\fR
文字列
.I t
中で正規表現
.I r
にマッチした部分をすべて
.I s
に置換します。置換の個数を返します。
.I t
を指定しなかった場合は
.B $0
が用いられます。
置換テキストでは、
.B &
は実際にマッチしたテキストで置き換えられます。
.B \e&
を使用するとリテラルの
.B &
を得ることができます。
.BR sub() ,
.BR gsub() ,
.B gensub()
における
.B &
とバックスラッシュに関する完全な議論は
.I "AWK Language Programming"
を参照してください。
.TP
.BI index( s , " t" )
文字列
.I s
中に含まれる文字列
.I t
の位置を返します。
.I t
が含まれていない場合は 0 を返します。
.TP
\fBlength(\fR[\fIs\fR]\fB)
文字列
.I s
の長さを返します。
.I s を指定しなかった場合には
.B $0
の長さを返します。
.TP
.BI match( s , " r" )
文字列
.I s
中で正規表現
.I r
にマッチする位置を返します。マッチしない場合は 0 を
返します。
.B RSTART
と
.B RLENGTH
の値が設定されます。
.TP
\fBsplit(\fIs\fB, \fIa \fR[\fB, \fIr\fR]\fB)\fR
文字列
.I s
を正規表現
.I r
を用いて分割し、配列
.I a
に格納します。
フィールド数を返します。
.I r
が省略され
た場合は
.B FS
が用いられます。配列
.I a
の内容は、分割前にクリアされます。
分割は、上述のフィールド分割と同じ動作を行います。
.TP
.BI sprintf( fmt , " expr-list" )
書式
.I fmt
に従って
.I exp-list
を整形表示し、結果の文字列を返します。
.TP
\fBsub(\fIr\fB, \fIs \fR[\fB, \fIt\fR]\fB)\fR
.B gsub()
と似てますが、最初にマッチした文字列のみが置換されます。
.TP
\fBsubstr(\fIs\fB, \fIi \fR[\fB, \fIn\fR]\fB)\fR
文字列
.I s
の
.I i
文字目から始まる最大
.I n
文字の部分文字列を返します。
.I n
が省略された場合、
.I i
文字目以降の部分文字列が返されます。
.TP
.BI tolower( str )
文字列
.I str
をコピーし、大文字をすべて小文字に変換したものを返します。
アルファベットでない文字は変化しません。
.TP
.BI toupper( str )
文字列
.I str
をコピーし、小文字をすべて大文字に変換したものを返します。
アルファベットでない文字は変化しません。
.SS 時間関数
.PP
タイムスタンプを含んだログファイルの処理は
AWK プログラムの主な使い道の1つですから、
.I gawk
はタイムスタンプを取り出したり、フォーマット
するための 2 つの関数を提供します。
.PP
.TP "\w'\fBsystime()\fR'u+1n"
.B systime()
基準時点からの経過秒数を返します
(\*(PX システムでは、基準時点は UTC で 1970 年 1 月 1 日 0:00 です)。
.TP
\fBstrftime(\fR[\fIformat \fR[\fB, \fItimestamp\fR]]\fB)\fR
書式
.I format
に従って
.I timestamp
をフォーマットします。
.I timestamp
は 
.B systime()
が返す値と同じ形式でなければなりません。
.I timestamp
が省略された場合、現在の日付が使用されます。
.I format
が省略された場合、
.IR date (1)
が出力に使用するものと同じデフォルトフォーマットが使用されます。
利用可能なフォーマットについては、\*(AN C の
.B strftime()
関数の仕様を参照して下さい。パブリックドメインな
.IR strftime (3)
とそのマニュアルページが
.I gawk
とともに配布されています。もし、
.I gawk
を作成するためにその
.B strftime
を用いた場合は、そのマニュアルに記述されている変換書式が
.I gawk
でも利用可能です。
.SS 文字列定数
.PP
AWK での文字列定数は、ダブルクォート(\fB"\fR)に狭まれた文字の列です。
文字列内では、C 言語のようにいくつかの
.I エスケープシーケンス
が使えます。
.PP
.TP \w'\fB\e\^\fIddd\fR'u+1n
.B \e\e
バックスラッシュそのもの。
.TP
.B \ea
「警告」文字。通常は \s-1ASCII\s+1 \s-1BEL\s+1 文字です。
.TP
.B \eb
バックスペース。
.TP
.B \ef
改ページ(フォームフィード)。
.TP
.B \en
改行。
.TP
.B \er
復帰(キャリッジリターン)。
.TP
.B \et
水平タブ。
.TP
.B \ev
垂直タブ。
.TP
.BI \ex "\^hex digits"
.B \ex
に続く 16 進数で表現された文字。\*(AN C と同様に、
.B \ex
に続くすべての 16 進数字
はエスケープシーケンスの一部であるとみなされます。
(この機能によりコミッティによる言語デザインが分かります。)
例えば、\fB"\ex1B"\fR は 
\s-1ASCII\s+1 \s-1ESC\s+1 (エスケープ) 文字です。
.TP
.BI \e ddd
1桁か2桁か3桁の 8 進数で表現された文字。例えば、 \fB"\e033"\fR は 
\s-1ASCII\s+1 \s-1ESC\s+1 (エスケープ) 文字です。
.TP
.BI \e c
文字 c そのもの。
.PP
エスケープシーケンスは正規表現定数内でも用いることができます(例えば、
.B "/[\ \et\ef\en\er\ev]/"
は空白文字にマッチします)。
.PP
互換モードでは、8 進および 16 進のエスケープシーケンスで表現される文字は、
正規表現定数として使用された場合、リテラルとして扱われます。
それゆえ、
.B /a\e52b/
は
.B /a\e*b/
と等価です。
.SH 関数
AWK では関数を以下のようにして定義します。
.PP
.RS
\fBfunction \fIname\fB(\fIparameter list\fB) { \fIstatements \fB}\fR
.RE
.PP
関数は、パターンまたはアクションの式から呼び出されたときに実行されます。
関数呼び出しにおいて与えられた実引数が、関数宣言における仮引数に
受け渡されます。
このとき配列の場合は参照渡しが行われ、他の変数の場合は値渡しで行われます。
.PP
元々 AWK に関数は備わっていませんでしたので、局所変数の機構はあまり
スマートではありません。
局所変数は引数リストの余分な引数として宣言します。局所変数と関
数引数を区別するため、余分な空白で区切るのが慣習です。例えば、以下のよ
うにします。
.PP
.RS
.ft B
.nf
function  f(p, q,     a, b)	# a & b は局所変数
{
	\&.....
}

/abc/	{ ... ; f(1, 2) ; ... }
.fi
.ft R
.RE
.PP
関数呼び出しにおける左括弧は、空白を狭まずに関数名の直後に
置かなければいけません。
これは、文字列結合演算子との曖昧さを生じさせないために必要です。
この制限は、上述の組み込み関数にはあてはまりません。
.PP
関数は、他の関数を呼び出したり、自分自身を再帰的に呼び出すことができます。
局所変数として用いられる関数引数は、関数起動時に空文字列および 0 
に初期化されます。
.PP
.B \-\^\-lint
が指定されたとき、
.I gawk
は実行時ではなくパーズ時に未定義関数の呼び出しに関して警告します。
実行時の未定義関数の呼び出しは致命的なエラーとなります。
.PP
.B function
のかわりに
.B func
を用いることができます。
.SH 使用例
.nf
``/etc/passwd'' から全ユーザのログイン名を取り出し、ソートして出力する。

.ft B
	BEGIN	{ FS = ":" }
		{ print $1 | "sort" }

.ft R
ファイルの行数を数える。

.ft B
		{ nlines++ }
	END	{ print nlines }

.ft R
行番号をつける。

.ft B
	{ print FNR, $0 }

.ft R
全ファイルを通した行番号をつける。

.ft B
	{ print NR, $0 }
.ft R
.fi
.SH 関連項目
.IR egrep (1),
.IR getpid (2),
.IR getppid (2),
.IR getpgrp (2),
.IR getuid (2),
.IR geteuid (2),
.IR getgid (2),
.IR getegid (2),
.IR getgroups (2)
.PP
.IR "The AWK Programming Language" ,
Alfred V. Aho, Brian W. Kernighan, Peter J. Weinberger,
Addison-Wesley, 1988. ISBN 0-201-07981-X.
.PP
.IR "AWK Language Programming" ,
Edition 1.0, published by the Free Software Foundation, 1995.
.SH POSIX 互換
.I gawk
は最新版の \*(UX
.I awk
との互換性だけでなく、\*(PX 標準との互換性も追求しています。
このため
.I gawk
には以下のような機能が取り入れられています。
これらの機能は AWK 本には述べられていませんが、
ベル研究所および \*(PX 標準の
.I awk
が有している機能です。
.PP
プログラム実行前に変数代入を行なう
.B \-v
オプションは新しい物です。
AWK 本によれば、コマンドラインで指定された変数代入は
.I awk
が引数をファイル名としてオープンする際に行なわれることになります。つまり
これは
.B BEGIN
ブロックの実行後です。しかしながら初期の頃の実装では、引数の中でファイル名に
先立って変数代入が指定されている場合には、代入は
.B BEGIN
ブロック実行の
.I 前に
行われていました。そしてアプリケーションは、この「仕様」に依存する
ようになりました。
.I awk
がそのドキュメントに合うように直された時、昔の動作に依存している
アプリケーションの便宜を図るためにこのオプションが加えられました。
(この仕様は AT&T および GNU の開発者達によって合意されました。)
.PP
独自機能のための
.B \-W
オプションは \*(PX 標準に従ったものです。
.PP
引数の列に特別なオプション ``\fB\-\^\-\fP'' を指定すると、
.I gawk
はそこがオプションの終わりであると解釈します。
互換モードにおいては未定義オプションは警告が出力され、それ以外のものは
無視されます。
通常の実行においては残りの引数は AWK プログラムに引き渡されます。
.PP
AWK 本は
.B srand()
の返り値を定義していません。
\*(PX 標準
では、その関数が使っている種を返し、
乱数シーケンスを追跡できるようにしています。
したがって
.I gawk
における
.B srand()
も現在の種を返すようにしてあります。
.PP
その他にも以下のような新機能があります。
.B \-f
オプションの複数回使用 (MKS
.IR awk に倣いました);
.B ENVIRON
配列;
エスケープシーケンス
.B \ea
と
.B \ev
(
.I gawk
で最初に実装され、AT&T の
.I awk
にフィードバックされました);
組み込み関数
.B tolower()
と
.B toupper()
(AT&T に倣いました);
.B printf
における \*(AN C 変換指定
(AT&T 版で最初に実装されました)。
.SH GNU 拡張
.I gawk
は \*(PX
.I awk
に対して多くの拡張が行なわれています。
この節ではそれらについて解説します。
.B \-\^\-traditional
オプション付きで
.I gawk
を起動することによって、
ここで述べられている拡張機能をすべて禁止することができます。
.PP
.I gawk
が持つ以下の機能は
\*(PX
.I awk
では使用できません。
.RS
.TP \w'\(bu'u+1n
\(bu
エスケープシーケンス
.B \ex
。(
.B \-\^\-posix
で抑止できます。)
.TP \w'\(bu'u+1n
\(bu
.B fflush()
関数。(
.B \-\^\-posix
で抑止できます。)
.TP
\(bu
.BR systime() ,
.BR strftime() ,
.B gensub()
の各関数。
.TP
\(bu
入出力リダイレクトで利用可能な特殊ファイル名は理解されません。
.TP
\(bu
変数
.BR ARGIND ,
.BR ERRNO ,
.B RT
は特殊変数ではありません。
.TP
\(bu
変数
.B IGNORECASE
とその副作用は利用できません。
.TP
\(bu
変数
.B FIELDWIDTHS
と固定長フィールド分割。
.TP
\(bu
.B RS
の正規表現としての使用。
.TP
\(bu
.B FS
に空文字列を設定することにより各文字を切り出す能力と、
.B split()
の 3 番目の引数。
.TP
\(bu
.B \-f
オプションで指定されたファイル名についてパス検索を行わないこと。
よって、環境変数
.B AWKPATH
は特殊な変数ではありません。
.TP
\(bu
現在の入力ファイルに対する処理を終わらせるために使用される
.B "nextfile"
。
.TP
\(bu
配列全体を削除するために使用される
.BI delete " 配列"
。
.RE
.PP
AWK 本は関数
.B close()
の返り値を定義していません。
.I gawk
の
.B close()
は、ファイルやパイプをクローズする際に呼び出す
.IR fclose (3)
や
.IR pclose (3)、
からの返り値を返します。
.PP
オプション
.B \-\^\-traditional
付きで
.I gawk
を起動し
.B \-F
オプションへの引数
.I fs
として ``t'' を与えた場合に、
.B FS
の値はタブ文字に設定されます。
.B "gawk \-F\et \&..."
とタイプしても、シェルが単に ``t'' をクォートするので、``\et'' は
.B \-F
オプションに渡されません。
これは少々見苦しい特殊事例ですので、デフォルトの動作としては
採用されていません。
.B \-\^\-posix
を指定した場合にも、この動作は行なわれません。
タブ文字をフィールドセパレータとして使用したい場合には、
クォートを使用するのが最良です:
.BR "gawk \-F'\et' \&..." .
.ig
.PP
If
.I awk
was compiled for debugging, it will
accept the following additional options:
.TP
.PD 0
.B \-Wparsedebug
.TP
.PD
.B \-\^\-parsedebug
Turn on
.IR yacc (1)
or
.IR bison (1)
debugging output during program parsing.
This option should only be of interest to the
.I gawk
maintainers, and may not even be compiled into
.IR gawk .
..
.SH 歴史的機能
.I gawk
は歴代の AWK の実装にあった 2 つの機能を備えています。
1 つめとして、組み込み関数
.B length()
は引数無しで呼び出せるだけでなく、さらに括弧無しでも呼び出せます!
したがって
.RS
.PP
.ft B
a = length	# Holy Algol 60, Batman!
.ft R
.RE
.PP
は以下の2例と同じです。
.RS
.PP
.ft B
a = length()
.br
a = length($0)
.ft R
.RE
.PP
\*(PX 標準ではこの機能は ``deprecated'' と注意書きされており、
.I gawk
ではコマンドラインで
.B \-\^\-lint
を指定した場合に、この機能の使用に対して警告を出力します。
.PP
もう 1 つは、
.BR while ,
.BR for ,
.B do
ループ本体の外でも
.BR continue ,
.B break
ステートメントを使用できるという機能です。
伝統的な AWK の実装では、このように使用した
.B continue
ステートメントを
.B next
ステートメントと等価なものとして扱ってきました。
.I gawk
では
.B \-\^\-traditional
が指定された場合に、この機能を使うことができます。
.SH 環境変数
環境に
.B POSIXLY_CORRECT
が存在する場合には、
.I gawk
はコマンドラインで
.B \-\^\-posix
が指定されている時と全く同じ動作をします。
このとき
.B \-\^\-lint
が指定されていると
.I gawk
はこの作用についての警告メッセージを出力します。
.PP
.B AWKPATH
環境変数を使用して、
.I gawk
が
.B \-f
および
.B \-\^\-file
オプションで指定されたファイル名を検索するディレクトリを指定できます。
.SH バグ
コマンドラインでの変数代入機能を使用するには、変数への代入を直接
コマンドラインに書けばよく、
.B \-F
オプションをつける必要はありません。
このオプションは昔の
.I awk
との互換性のためだけに残されています。
.PP
ファイル
.B /dev/fd
および
.BR /dev/stdin ,
.BR /dev/stdout ,
.B /dev/stderr
を実際にサポートしているシステムでの
.I gawk
からは、それらがないシステムとは違った出力が得られるかもしれません。
.I gawk
はそれらのファイルを内部で解釈する際に標準出力への出力を
.B /dev/stdout 
への出力と同期させますが、それらのファイルを持つシステムでは
出力はそれぞれ異なるファイルへ向けられます。
利用者の方で気を付けるようにしてください(Caveat Emptor)。
.PP
文法的に誤った単一文字プログラムはパーズスタックを溢れさせる傾向があり、
まったく分からないメッセージを生成する傾向にあります。
このようなプログラムの診断は驚くべきことに一般に難しく、
診断の努力はまったく無意味になります。
.SH バージョン情報
このマニュアルは
.IR gawk
バージョン 3.0.2 について記載しています。
.SH 作者
\*(UX
.I awk
の最初のバージョンは、AT&T ベル研究所の Alfred Aho と
Peter Weinberger および Brian Kernighan によって設計、実装されました。
Brian Kernighan はその保守と改良を続けています。
.PP
Free Software Foundation の Paul Rubin と Jay Fenlason
が、Seventh Edition \*(UX で配布された最初のバージョンの
.I awk
と互換性を持つように
.I gawk 
を書きました。
John Woods は数々のバグ修正を送って下さいました。
David Trueman は、Arnold Robbins が送って下さった内容をもとに、
.I gawk
を新バージョンの \*(UX
.I awk
互換にしました。
.PP
DOS への最初の移植は Conrad Kwok と Scott Garfinkle によって
行なわれました。
現在は Scott Deifik が DOS 版の保守をしています。
Pat Rankin は VMS への移植を行ない、Michal Jaegermann は Atari ST への
移植を行ないました。
OS/2 への移植は Kai Uwe Rommel が Darrel Hankerson の助けを借りて
行ないました。
Fred Fish が Amiga サポートの提供を行いました。
.SH バグレポート
.I gawk
のバグを見付けたら、電子メールを
.B bug-gnu-utils@prep.ai.mit.edu
宛に送るとともに、カーボンコピーを
.B arnold@gnu.ai.mit.edu
宛に送ってください。
電子メールには、オペレーティングシステムとそのリビジョン、
.I gawk
のリビジョン、コンパイルに使用した C コンパイラ、
問題を再現するできるだけ小さなテストプログラムとデータを記述してください。
.PP
バグレポートを送る前に 2 つのことを行ってください。
第 1 に、最新の
.I gawk
を使用されていることを確認してください。
多くの (通常微妙な) バグが各々のリリースで修正されていますので、
ご使用のものが古い場合には問題は既に解決されているかもしれません。
第 2 に、このマニュアルページとリファレンスマニュアルを注意深く読み、
あなたがバグだと思うものが確かにバグであり、
大きく変わった言語仕様ではないことを確認してください。
.PP
バグレポートを
.B comp.lang.awk
に投稿することだけはしないでください。
.I gawk
の開発者達は時々このニュースグループを読みますが、
バグレポートをこのニュースグループに投稿しても
バグレポートとして信頼性がありません。
上記のアドレスへの電子メールでお願いします。
.SH 謝辞
ベル研究所の Brian Kernighan はテストおよびデバッグの間、貴重な助力を
提供して下さいました。
感謝致します。
.SH 複製許諾
Copyright \(co\) 1996 Free Software Foundation, Inc.
.PP
Permission is granted to make and distribute verbatim copies of
this manual page provided the copyright notice and this permission
notice are preserved on all copies.
.ig
Permission is granted to process this file through troff and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual page).
..
.PP
Permission is granted to copy and distribute modified versions of this
manual page under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
.PP
Permission is granted to copy and distribute translations of this
manual page into another language, under the above conditions for
modified versions, except that this permission notice may be stated in
a translation approved by the Foundation.
