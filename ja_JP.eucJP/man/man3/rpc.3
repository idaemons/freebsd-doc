.\" @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\" jpman %Id%
.\"
.TH RPC 3 "16 February 1988"
.SH 名称
rpc \- リモートプロシージャコール用ライブラリルーチン
.SH 書式と解説
このルーチンでは、C プログラムを使用して、
ネットワークを通して別のマシンでプロシージャ呼び出しを実行できます。
まずクライアントがプロシージャを呼び出し、
データパケットをサーバに送信します。
パケットを受け取ったサーバは、ディスパッチルーチンを呼び出し、
要求されたサービスを実行してから応答を送り返します。
最後に、プロシージャ呼び出しがクライアントに戻ります。
.LP
Secure RPC (DES 認証) に使用するルーチンについては、
.BR rpc_secure (3)
で説明します。
Secure RPC は DES 暗号化が使用できる場合にのみ使用できます。
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
.IR auth
に関連する認証情報を破壊するマクロです。
一般的に、破壊にはプライベートデータ構造の解放も含まれます。
.BR auth_destroy(\|)
を呼び出した後で
.I auth
を使用した結果は不定になります。
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
各リモートプロシージャコールで使用できない認証情報を渡す
.SM RPC
認証ハンドルを作成して戻します。
.SM RPC
は、この認証をデフォルトで使用します。
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
認証情報を含む
.SM RPC
.UX
認証ハンドルを作成して戻します。
パラメータ
.I host
は、情報を作成するマシンの名前です。
.I uid
は、ユーザのユーザ
.SM ID
です。
.I gid
は、ユーザの現行グループ
.SM ID
です。
.I len
と
.I aup_gids
は、ユーザが属するグループの配列を表します。
あるユーザになりすますことが容易です。
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
適切なパラメータで
.B authunix_create(\|)
を呼び出します。
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
マシン
.IR host .
で
.IR prognum ,
.IR versnum ,
および
.I procnum
に関連するリモートプロシージャを呼び出します。
パラメータ
.I in
は、プロシージャの引数アドレスで、
.I out
は結果を配置するアドレスです。
.I inproc
は、プロシージャのパラメータをデコードするために使用し、
.I outproc
は、プロシージャの結果をデコードするために使用します。
このルーチンは、問題がなければ 0 を戻し、
問題がある場合は、正数を計算する
.B "enum clnt_stat"
の値を戻します。
エラーステータスをメッセージに変換するには、ルーチン
.B clnt_perrno(\|)
が便利です。
.IP
警告: このルーチンでリモートプロシージャを呼び出す場合は、
.SM UDP/IP
がトランスポート層として使用されます。
制限事項については、
.B clntudp_create(\|)
を参照してください。
このルーチンを使用した場合、タイムアウトや認証は制御できません。
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
ローカルで接続されているすべてのブロードキャストネットに
呼び出しメッセージがブロードキャストされることを除けば、
.BR callrpc(\|) ,
と同じです。
このルーチンは、応答を受け取るたびに、以下の形式の
.BR eachresult(\|)
を呼び出します。
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
.I out
は、リモートプロシージャの出力がデコードされることを除けば、
.BR clnt_broadcast(\|)
に渡される
.I out
と同じです。
.I addr
は、結果を送信するマシンのアドレスを指します。
.B eachresult(\|)
が 0 を戻す場合、
.B clnt_broadcast(\|)
は次の応答を待ちます。
0 を戻さない場合は、適切なステータスで戻ります。
.IP
警告: ブロードキャストソケットのサイズは、
データリンクの最大転送単位に制限されています。
イーサネットの場合、この値は 1500 バイトです。
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
.BR clnt_create(\|)
などの
.SM RPC
クライアント作成ルーチンで入手した、クライアントハンドル
.IR clnt
に関連するリモートプロシージャ
.I procnum
を呼び出すマクロです。
パラメータ
.I in
はプロシージャの引数のアドレスで、
.I out
は結果を配置するアドレスです。
.I inproc
はプロシージャのパラメータのデコードに使用し、
.I outproc
はプロシージャの結果のデコードに使用します。
.I tout
は、結果が戻るまでの時間です。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
クライアントの
.SM RPC
ハンドルを破壊するマクロです。
通常の場合、破壊には、
.I clnt
も含めたプライベートデータ構造の解放も含まれます。
.BR clnt_destroy(\|)
を呼び出した後で
.I clnt
を使用した結果は不定になります。
.SM RPC
ライブラリが関連ソケットを開いた場合はそれも閉じます。
関連ソケットを開いていない場合、ソケットは開いたまま残ります。
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
一般的なクライアント作成ルーチンです。
.I host
は、サーバが配置されているリモートホストの名前を指定します。
.I proto
は、使用する転送プロトコルの種類を指定します。
このフィールドで現在サポートされている値は、
\(lqudp\(rq と \(lqtcp\(rq です。
タイムアウトはデフォルトが設定されていますが、
.BR clnt_control(\|)
を使用して修正できます。
.IP
警告:
.SM UDP
の使用には短所があります。
.SM UDP
ベースの
.SM RPC
メッセージは、
8 キロバイトのエンコード済みデータまでしか維持できないので、
大きな引数を取るプロシージャや、
大きな結果を戻すプロシージャでは使用できません。
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
クライアントオブジェクトのさまざまな情報の変更や取り出しを行うマクロです。
.I req
はオペレーションのタイプを指定し、
.I info
は情報のポインタです。
.SM UDP
と
.SM TCP\s0
の両方でサポートされている
.I req
の値、引数タイプ、実行内容は以下の通りです。
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	総タイムアウトの設定
.SM CLGET_TIMEOUT\s0	struct timeval	総タイムアウトの入手
.fi
.IP
注意: タイムアウトを
.BR clnt_control(\|)
で設定すると、
.B clnt_call(\|)
に渡されるタイムアウトパラメータは、
後のすべての呼び出しで無視されます。
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	サーバのアドレスの入手
.fi
.br
.IP
以下のオペレーションは
.SM UDP
のみで有効です。
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0	struct timeval	再試行タイムアウトの設定
.SM CLGET_RETRY_TIMEOUT\s0	struct timeval	再試行タイムアウトの入手
.fi
.br
.IP
再試行タイムアウトは、サーバが応答してから要求を再送することを
.SM "UDP RPC"
が待機する時間です。
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
.SM RPC/XDR
システムが
.SM RPC
呼び出しの結果をデコードする場合に割り振ったデータを解放するマクロです。
パラメータ
.I out
は結果のアドレスで、
.I outproc
は結果を記述する
.SM XDR
ルーチンです。
このルーチンは、結果が問題なく解放された場合は 1 を戻し、
問題が発生した場合は 0 を戻します。
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
クライアントハンドルのエラー構造を、アドレス
.IR errp
の構造体にコピーするマクロです。
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
クライアント
.SM RPC
ハンドルを作成できない理由を表すメッセージを標準エラーに出力します。
メッセージの最初には、文字列
.I s
とコロンが付きます。
これは、
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
または
.B clntudp_create(\|)
がエラーとなった場合に使用します。
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
.IR stat
が示す条件に対応するメッセージを標準エラーに出力します。
.BR callrpc(\|)
の後で使用してください。
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
.SM RPC
呼び出しがエラーになった理由を示すメッセージを標準エラーに出力します。
.I clnt
は、呼び出しの実行に使用したハンドルです。
メッセージ最初には、文字列
.I s
とコロンが付きます。
.BR clnt_call(\|)
の後で使用してください。
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
標準エラーに出力する代わりに文字列を戻すことを除けば、
.BR clnt_pcreateerror(\|)
と同じです。
.IP
バグ: 各呼び出しで上書きされた静的データのポインタを戻します。
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
.BR clnt_perrno(\|)
と同じ引数を取りますが、
.SM RPC
呼び出しがエラーになった理由を示すメッセージを標準エラーに送信する代わりに、
メッセージを含む文字列のポインタを戻します。
文字列は改行で終わります。
.IP
プログラムに標準エラーがない場合
(サーバとして実行しているプログラムには標準エラーがないことが多い)、
またはメッセージを
.BR printf
で出力する必要がない場合、
あるいは
.B clnt_perrno(\|)
がサポートするもの以外のメッセージフォーマットを使用する場合は、
.B clnt_perrno(\|)
の代わりに
.B clnt_sperrno(\|)
を使用します。
.B clnt_sperror(\|)
と
.BR clnt_spcreaterror(\|)
とは異なり、
.B clnt_sperrno(\|)
は静的データのポインタを戻しますが、
結果は各呼び出しで上書きされないことに注意してください。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
.BR clnt_sperrno(\|)
と同じように、標準エラーに出力せずに文字列を戻すことを除けば、
.BR clnt_perror(\|)
と同じです。
.IP
バグ: 各呼び出しで上書きされた静的データのポインタを戻します。
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
リモートプログラム
.IR prognum ,
バージョン
.IR versnum
のトイ
.SM RPC
クライアントを作成します。
サービスにメッセージを渡す実際のトランスポートは、
プロセスのアドレススペース内にあるバッファなので、
対応する
.SM RPC
サーバは同じアドレススペースに存在する必要があります。
.BR svcraw_create(\|)
を参照してください。
これにより、
.SM RPC
のシミュレーション、およびラウンドトリップタイムなど、
.SM RPC
オーバヘッドの取得をカーネルの干渉なしに実行できます。
このルーチンは、エラーが発生すると
.SM NULL
を戻します。
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
リモートプログラム
.IR prognum ,
バージョン
.IR versnum
の
.SM RPC
クライアントを作成します。
クライアントは、トランスポートとして
.SM TCP/IP
を使用します。
リモートプログラムは、インターネットアドレス
.IR *addr
にあります。
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
が 0 である場合は、
リモートプログラムが注意を向ける実際のポートに設定されます。
(
.B portmap
サービスはこの情報で調べられます)。
パラメータ
.I sockp
はソケットです。このパラメータが
.BR \s-1RPC_ANYSOCK\s0
である場合、このルーチンは新しいソケットを開いて
.IR sockp
を設定します。
.SM TCP\s0
ベースの
.SM RPC
はバッファによる
.SM I/O
を使用するので、ユーザはパラメータ
.I sendsz
と
.IR recvsz
で送信バッファと受信バッファのサイズを指定できます。
値を 0 にすると、適切なデフォルトが選択されます。
このルーチンは、エラーになると
.SM NULL
を戻します。
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
リモートプログラム
.IR prognum ,
バージョン
.IR versnum
の
.SM RPC
クライアントを作成します。
クライアントは、トランスポートとして
.SM UDP/IP
を使用します。
リモートプログラムは、インターネットアドレス
.IR addr
にあります。
\fB\%addr\->sin_port\fR
が 0 である場合は、
リモートプログラムが注意を向ける実際のポートに設定されます
(リモート
.B portmap
サービスは、この情報で調べられます)。
パラメータ
.I sockp
はソケットです。
このパラメータが
.BR \s-1RPC_ANYSOCK\s0
である場合、このルーチンは新しいソケットを開いて
.IR sockp
を設定します。
.SM UDP
トランスポートは、応答を受け取るまで、
または呼び出しがタイムアウトになるまで、
.B wait
時間間隔で呼び出しメッセージを再送信します。
呼び出しがタイムアウトとなる時間は、
.BR clnt_call(\|)
で指定します。
.IP
警告:
.SM UDP
ベースの
.SM RPC
メッセージは、
8 キロバイトのエンコード済みデータまでしか維持できないので、
大きな引数を取るプロシージャや
大きな結果を戻すプロシージャでは使用できません。
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
リモートプログラム
.IR prognum ,
バージョン
.IR versnum
の
.SM RPC
クライアントを作成します。
クライアントは、トランスポートとして
.SM UDP/IP
を使用します。
リモートプログラムは、インターネットアドレス
.IR addr
にあります。
\fB\%addr\->sin_port\fR
が 0 である場合は、
リモートプログラムが注意を向ける実際のポートに設定されます
(リモート
.B portmap
サービスは、この情報で調べられます)。
パラメータ
.I sockp
はソケットです。このパラメータが
.BR \s-1RPC_ANYSOCK\s0
である場合、このルーチンは新しいソケットを開いて
.BR sockp
を設定します。
.SM UDP
トランスポートは、応答を受け取るまで、
または呼び出しがタイムアウトになるまで
.B wait
時間間隔で呼び出しメッセージを再送信します。
呼び出しがタイムアウトになる時間は、
.BR clnt_call(\|)
で指定します。
.IP
ユーザは、
.SM UDP
ベースの
.SM RPC
メッセージの送受信を行う、最大パケットサイズを指定できます。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
int
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
.BR /etc/hosts
を処理するライブラリルーチンを参考にせず、マシンの
.SM IP
アドレスを
.IR *addr
に入れます。ポート番号は、常に
.BR htons(\s-1PMAPPORT\s0)
に設定されます。
問題がない場合は 0 を戻し、問題がある場合は 0 以外を戻します。
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
.B portmap
サービスのユーザインタフェースで、
.SM IP
アドレス
.IR *addr
にあるホストの
.SM RPC
プログラムとポートの現行のマッピングのリストを戻します。
このルーチンは
.SM NULL
を戻すことがあります。
コマンド
.RB ` "rpcinfo \-p" '
はこのルーチンを使用します。
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
.B portmap
サービスのユーザインタフェースで、
プログラム番号
.IR prognum ,
バージョン
.IR versnum
をサポートするサービスを待ち、
.IR protocol
に関連する転送プロトコルを表すポート番号を戻します。
.I protocol
の値は、ほとんどの場合
.B
.SM IPPROTO_UDP
か
.BR \s-1IPPROTO_TCP\s0
です。マッピングが存在しない場合、または
.SM RPC
システムがリモート
.B portmap
サービスと接触できない場合、戻り値は 0 になります。
.SM RPC
システムがリモート
.B portmap
サービスと接触できない場合、グローバル変数
.B rpc_createerr(\|)
には
.SM RPC
ステータスが入ります。
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
.B portmap
サービスのユーザインタフェースで、
.SM IP
アドレス
.I *addr
のホストのプロシージャを
.SM RPC
呼び出しにするように、そのホストの
.B portmap
に命令します。
プロシージャで問題が発生しない場合、パラメータ
.I *portp
はプログラムのポート番号に修正されます。
その他のパラメータについては、
.B callrpc(\|)
と
.BR clnt_call(\|)
を参照してください
このプロシージャは、\(lqping\(rq 以外で使用することはありません。
.BR clnt_broadcast(\|)
も参照してください。
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
.B portmap
サービスのユーザインタフェースで、
.RI [ prognum , versnum , protocol\fR]
の 3 つ、およびマシンの
.B portmap
サービスでの
.I port
の間にマッピングを確立します。
.I protocol
の値は、ほとんどの場合
.B
.SM IPPROTO_UDP
か
.BR \s-1IPPROTO_TCP\s0
です。
このルーチンは問題がないと 1 を戻し、問題がある場合は 0 を戻します。
これは、
.BR svc_register(\|)
で自動的に実行されます。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
.B portmap
サービスのユーザインタフェースで、
.RI [ prognum , versnum , *\fR]
の 3 つ、および
.B portmap
サービスでの
.B port
の間に存在するマッピングをすべて破壊します。
このルーチンは、問題がなければ 1 を戻し、問題がある場合は 0 を戻します。
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
.SM RPC
サービスパッケージでプロシージャ
.I procname
を登録します。
プログラム
.IR prognum ,
バージョン
.IR versnum ,
プロシージャ
.IR procnum
が要求されると、パラメータのポインタで
.I procname
が呼び出されます。
.I progname
は、静的結果のポインタを戻します。
.I inproc
はパラメータのデコードに使用され、
.I outproc
は結果のエンコードに使用されます。
このルーチンは、登録で問題が発生しなければ 0 を戻し、
問題が発生したら \-1 を戻します。
.IP
警告: この形式で登録されたリモートプロシージャは、
.SM UDP/IP
トランスポートでアクセスされます。
制限事項については
.B svcudp_create(\|)
を参照してください。
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
エラーになった
.SM RPC
クライアント作成ルーチンで値が設定されるグローバル変数です。
エラーの原因を出力するには、ルーチン
.B clnt_pcreateerror(\|)
を使用します。
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
.SM RPC
サービス転送ハンドル
.IR xprt
を破壊するマクロです。
一般的に破壊処理には、
.I xprt
も含むプライベートデータ構造の解放も含まれます。
このルーチンを呼び出した後で
.I xprt
を使用した結果は不定となります。
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
.SM RPC
サービスサイドの読み込みファイル記述子ビットマスクを表すグローバル変数です。
.B select
システムコールのテンプレートパラメータとして最適です。
サービスの設計者が
.BR svc_run(\|)
を呼び出さず、非同期のイベント処理を行う場合のみに重要です。
この変数は読み込み専用ですが
(アドレスを
.BR select
に渡しませんが)、
.B svc_getreqset(\|)
か作成ルーチンを呼び出した後で変更できます。
.br
.BR FD_SETSIZE
を越える記述子の制限がプロセスにある場合、この変数は
.BR FD_SETSIZE
記述子でしか使用できないことに注意してください。
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
.BR svc_fedset(\|)
に似ていますが、32 個の記述子に制限されています。
このインターフェースは
.BR svc_fdset(\|)
で置き換えられました。
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
.SM RPC/XDR
システムが
.BR svc_getargs(\|)
を使用して引数をサービスプロシージャにデコードした場合に
割り振ったデータを解放するマクロです。
このルーチンは、結果が問題なく解放されると 1 を戻し、
問題が発生した場合は 0 を戻します。
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
.SM RPC
サービス転送ハンドル
.IR xprt
に関連した
.SM RPC
要求の引数をデコードするマクロです。
パラメータ
.I in
は、引数を配置する場所のアドレスです。
.I inproc
は、引数をデコードする
.SM XDR
ルーチンです。
このルーチンは、デコードで問題が発生しなければ 1 を戻し、
問題が発生した場合は 0 を戻します。
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
.SM RPC
サービス転送ハンドル
.IR xprt
に関連するプロシージャの呼び出し側の
ネットワークアドレスを入手する確実な方法です。
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
このルーチンは、サービスの設計者が
.BR svc_run(\|)
を呼び出さず、独自の非同期イベント処理を実現する場合にのみ重要です。
.SM RPC
要求が
.SM RPC
ソケットに到着したと
.B select
システムコールが判断した場合に呼び出されます。
.I rdfds
は、作成された読み込み記述子ビットマスクです。
このルーチンは、
.I rdfds
の値に関連したすべてのソケットサービスを受けた場合に戻ります。
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
.BR svc_getreqset(\|)
に似ていますが、32 個の記述子に制限されています。
このインタフェースは
.BR svc_getreqset(\|)
で置き換えられました。
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
.I prognum
と
.I versnum
をサービスディスパッチプロシージャ
.IR dispatch
に関連付けます。
.I protocol
が 0 である場合、サービスは
.B portmap
サービスで登録されません。
.I protocol
が 0 以外である場合、
.RI [ prognum , versnum , protocol\fR]
の 3 つと
\fB\%xprt\->xp_port\fR
のマッピングがローカル
.B portmap
サービスで確立されます
(一般的に
.I protocol
は 0 か
.B
.SM IPPROTO_UDP
か
.B
.SM IPPROTO_TCP
です)。
プロシージャ
.I dispatch
の形式は以下の通りです。
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
.B svc_register(\|)
ルーチンは、問題がなければ 1 を戻し、問題がある場合は 0 を戻します。
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
このルーチンは戻りません。
.SM RPC
要求の到着を待ち、到着すると
.B svc_getreq(\|)
を使用して適切なサービスプロシージャを呼び出します。
通常の場合、このプロシージャは、
.B select(\|)
システムコールが戻るのを待ちます。
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
.SM RPC
サービスのディスパッチルーチンで呼び出され、
リモートプロシージャコールの結果を送信します。
パラメータ
.I xprt
は要求の関連転送ハンドルです。
.I outproc
は、結果のエンコードに使用する
.SM XDR
ルーチンです。
.I out
は結果のアドレスです。
このルーチンは、問題がなければ 1 を戻し、問題がある場合は 0 を戻します。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
.RI [ prognum , versnum ]
の 2 つとディスパッチルーチンのマッピング、および
.RI [ prognum , versnum , *\fR]
の 3 つとポート番号のマッチングをすべて削除します。
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
認証エラーのために、リモートプロシージャコールの実行を拒否する
サービスディスパッチルーチンが呼び出します。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
パラメータを問題なくデコードできない
サービスディスパッチルーチンが呼び出します。
.BR svc_getargs(\|)
も参照してください。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
呼び出し側が要求したプロシージャ番号を
実現しないサービスディスパッチルーチンが呼び出します。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
目的のプログラムが
.SM RPC
パッケージで登録されていない場合に呼び出されます。
サービスの設計者には、通常の場合このルーチンは必要ありません。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
プログラムの目的のバージョンが
.SM RPC
パッケージで登録されていない場合に呼び出されます。
サービスの設計者には、通常の場合このルーチンは必要ありません。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
サービスディスパッチルーチンが、
特定プロトコルでカバーされていないシステムエラーを検出した場合に呼び出します。
たとえばサービスが記憶域を割り振れない場合は、
このルーチンが呼び出されます。
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
認証パラメータが足りないために、
リモートプロシージャコールの実行を拒否する
サービスディスパッチルーチンが呼び出します。
このルーチンは、
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)"
を呼び出します。
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
ポインタを戻すためのトイ
.SM RPC
クライアントを作成します。
実際のトランスポートは、
プロセスのアドレススペース内にあるバッファなので、対応する
.SM RPC
クライアントは同じアドレススペースに存在する必要があります。
.BR clntraw_create(\|)
を参照してください。
このルーチンにより、
.SM RPC
のシミュレーション、およびラウンドトリップタイムなど、
.SM RPC
オーバヘッドの取得をカーネルの干渉なしに実行できます。
このルーチンは、エラーが発生すると
.SM NULL
を戻します。
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
ポインタを戻す、
.SM TCP/IP
ベースの
.SM RPC
サービストランスポートを作成します。
トランスポートにはソケット
.IR sock
が関連します。ソケットが
.BR \s-1RPC_ANYSOCK\s0
である場合は、新しいソケットが作成されます。
ソケットがローカル
.SM TCP
ポートに結合していない場合、
このルーチンはソケットを任意のポートに結合します。処理が終わると、
\fB\%xprt\->xp_sock\fR
はトランスポートのソケット記述子になり、
\fB\%xprt\->xp_port\fR
はトランスポートのポート番号になります。
このルーチンは、エラーが発生すると
.SM NULL
を戻します。
.SM TCP
ベースの
.SM RPC
バッファによる
.SM I/O
を使用するので、ユーザはバッファサイズを指定できます。
値を 0 にすると、適切なデフォルトが選択されます。
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
開いている記述子の最上位にサービスを作成します。
一般的にこの記述子は、
.SM TCP\s0
などのストリームプロトコルの接続済みソケットです。
.I sendsize
と
.I recvsize
は、送信バッファと受信バッファのサイズを指定します。
このサイズが 0 である場合は、適切なデフォルトが選択されます。
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
ポインタを戻す
.SM UDP/IP\s0
ベースの
.SM RPC
サービストランスポートを作成します。
トランスポートにはソケット
.IR sock
が関連します。ソケットが
.B \s-1RPC_ANYSOCK\s0
である場合は、新しいソケットが作成されます。
ソケットがローカル
.SM UDP
ポートに結合していない場合、
このルーチンはソケットを任意のポートに結合します。
処理が終わると、
\fB\%xprt\->xp_sock\fR
はトランスポートのソケット記述子になり、
\fB\%xprt\->xp_port\fR
はトランスポートのポート番号になります。
このルーチンは、エラーが発生すると
.SM NULL
を戻します。
.IP
これにより、ユーザは、
.SM UDP\s0
ベースの送信
.SM RPC
メッセージと受信メッセージの最大パケットサイズを指定できます。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
.SM RPC
応答メッセージのエンコードに使用します。
このルーチンでは、
.SM RPC
パッケージを使用せずに、
\s-1RPC\s0
スタイルのメッセージを作成する場合に便利です。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
.SM UNIX
証明書の記述に使用します。
このルーチンは、
.SM RPC
認証パッケージを使用せずに、証明書を作成する場合に便利です。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
.SM RPC
コールヘッダメッセージの記述に使用します。
このルーチンでは、
.SM RPC
パッケージを使用せずに、
.SM RPC\s0
スタイルのメッセージを作成する場合に便利です。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
.SM RPC
コールメッセージの記述に使用します。
このルーチンは、
.SM RPC
パッケージを使用せずに、
.SM RPC\s0
スタイルのメッセージを作成する場合に便利です。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
.SM RPC
認証情報メッセージの記述に使用します。
このルーチンでは、
.SM RPC
パッケージを使用せずに、
.SM RPC\s0
スタイルのメッセージを作成する場合に便利です。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
さまざまな
.B portmap
プロシージャのパラメータの記述に外部的に使用します。
このルーチンは、
.B pmap
インタフェースを使用せずに、このパラメータを作成する場合に便利です。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
ポートマッピングのリストの記述に外部的に使用します。
このルーチンは、
.B pmap
インタフェースを使用せずに、このパラメータを作成する場合に便利です。
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
.SM RPC
応答メッセージの記述に使用します。
このルーチンは
.SM RPC
パッケージを使用せずに、
.SM RPC\s0
スタイルのメッセージを作成する場合に便利です。
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
.SM RPC
応答メッセージの記述に使用します。
このルーチンは
.SM RPC
パッケージを使用せずに、
.SM RPC
スタイルのメッセージを作成する場合に便利です。
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
.SM RPC
サービストランスポートハンドルが作成されたら、
.SM RPC
サービスパッケージで登録する必要があります。
このルーチンは、グローバル変数
.BR svc_fds(\|)
を修正します。サービスの設計者には、
通常の場合このルーチンは必要ありません。
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
.SM RPC
サービストランスポートハンドルを破壊する前には、
.SM RPC
サービスパッケージで登録を解除する必要があります。
このルーチンは、グローバル変数
.BR svc_fds(\|)
を修正します。サービスの設計者には、
通常の場合このルーチンは必要ありません。
.SH SEE ALSO
.BR rpc_secure (3),
.BR xdr (3)
.br
以下のマニュアル:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.
