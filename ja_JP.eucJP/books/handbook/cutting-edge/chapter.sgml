<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.39
     $FreeBSD: doc/ja_JP.eucJP/books/handbook/cutting-edge/chapter.sgml,v 1.9 2000/02/17 13:39:27 kuriyama Exp $
-->

<chapter id="cutting-edge">
  <title>開発の最前線: FreeBSD-current と FreeBSD-stable</title>

  <para>あるリリースから次のリリースまでの期間にも, FreeBSD の開発は
    休みなく続けられています.
    この開発の最前線に興味を持っている人のために,
    手元のシステムを最新の開発ツリーに同期させておくための,
    とても使いやすい仕掛けが何種類も用意されています.  注意:
    開発の最前線は, 誰でもが扱えるという性質のものではありません!
    もしもあなたが, 開発途中のシステムを追いかけようか,
    それともリリース
    バージョンのどれかを使い続けようかと迷っているのなら,
    きっとこの章が参考になるでしょう.</para>

  <sect1 id="current">
    <title>最新のFreeBSDを追いかける</title>

    <para><emphasis>原作: &a.jkh;.</emphasis></para>

    <para><emphasis>訳: &a.hanai; 6 November 1996.</emphasis></para>

    <sect2>
      <title>FreeBSD-current ってなに?</title>

      <para>FreeBSD-current とは，文字通りに，日々変更されている
	FreeBSD のソース
	のスナップショット以外の何ものでもありません．
	中には現在開発途上のソフトウェア, 実験的な変更,
	あるいは過渡的な機能などが含まれています. また,
	この中に入っている機能がすべて次の公式リリースに
	入るとはかぎりません. FreeBSD-current
	をソースからほとんど毎日コンパイルしている人はたくさん
	いますが, 時期によっては FreeBSD-current
	はコンパイルさえできない状態になっていることもあります.
	これらの問題は一般的には可能な限り素早く解決されますが,
	FreeBSD-current のソースが不幸をもたらすか, それとも非常に
	素晴らしい機能をもたらすかというのは文字通り,
	ある与えられた 24 時間の間
	のどの部分であなたがソースを手に入れたか,
	による場合もあります.</para>
    </sect2>

    <sect2>
      <title>誰が FreeBSD-current を必要としてるの?</title>

      <para>FreeBSD-current は,
	主に次の三つの重要なグループを対象としています.</para>

      <orderedlist>
	<listitem>
	  <para>ソースツリーのある部分に関して活発に作業している
	    FreeBSD グループのメンバー. 彼らにとっては
	    &ldquo;最新のもの&rdquo; にしておくのが
	    絶対に必要なことなのです．</para>
	</listitem>

	<listitem>
	  <para>活発にテストをする FreeBSD グループのメンバー. 彼らは,
	    FreeBSD-current を &ldquo;健全である&rdquo;
	    ことを出来るだけ確認するために種々の問題と戦うのに
	    時間を費やすのを厭わない人々です. 彼らはまた,
	    様々な変更に関する提案や FreeBSD
	    の大まかな方向付けを行ないたいと思っている
	    人々でもあります.</para>
	</listitem>

	<listitem>
	  <para>単に, 様々な事に目を向け, 参考のために
	    (例えば，動かすためではなく <emphasis>読むため
	    </emphasis>に) 最新のソースを使いたいと思っている FreeBSD
	    (または他の) グループのまわりにいるメンバー.
	    これらの人々はまた,
	    時々コメントやコードを寄稿してくれます.</para>
	</listitem>
      </orderedlist>
    </sect2>

    <sect2>
      <title>FreeBSD-current
	に期待しては<emphasis>いけない</emphasis>ことは?</title>

      <orderedlist>
	<listitem>
	  <para>なにか新しくカッコイイモノがあると聞き, 自分の周囲では
	    一番にそれを持ちたいがためにリリース前のコードの断片を
	    追いかけること.</para>
	</listitem>

	<listitem>
	  <para>バグを修正するための素早い方法.</para>
	</listitem>

	<listitem>
	  <para>我々によって &ldquo;公式にサポートされている&rdquo;
	    こと. 私たちは 3 つの &ldquo;公式な&rdquo; FreeBSD-current
	    のグループの一つに実際に属する
	    人々を助けるのにベストを尽くしますが,
	    技術的なサポートを行なうには 単に「時間が足りない」のです.
	    これは我々が外の人を助けるの好まない,
	    ケチで意地悪い人間だと いうことではなく (もしそうなら
	    FreeBSD なんかやっていません), 文字通り我々は一日に 400
	    ものメッセージに答え <emphasis>かつ</emphasis> FreeBSD
	    の作業をすることなど出来ない! ということなのです. もし,
	    たくさんの質問に答えるか,  それとも FreeBSD
	    を良くする作業を続けるかという選択が与えられた場合,
	    あなた方のほとんどは後者を支持する,
	    と私は確信しています.</para>
	</listitem>
      </orderedlist>
    </sect2>

    <sect2>
      <title>FreeBSD-current を使う</title>

      <orderedlist>
	<listitem>
	  <para>&a.current;と&a.cvsall;に加わって下さい.
	    これは単に良い考えであるというだけでなく,
	    <emphasis>必須の</emphasis>ことなのです. もし
	    <emphasis>FreeBSD-current</emphasis>
	    メーリングリストに入っていなければ,
	    様々な人がシステムの現在の状態について
	    述べているコメントを決して見ることはありませんし,
	    従って他の人が既に見つけて解決している多くの問題に戸惑っ
	    てあきらめてしまうでしょう. さらに言うと,
	    システムを正常に保つための
	    重要な情報を見逃してしまう可能性もあります.</para>

	  <para>&a.cvsall; メーリングリストでは,
	    それぞれの変更についての commit
	    ログを見ることができますし,
	    それに関して起こり得る副作用の情報を得ることができ,
	    もう一つの加わるに値するメーリングリストです.</para>

	  <para>これらのメーリングリストに入るには, &a.majordomo;
	    へ</para>

	  <programlisting>
subscribe freebsd-current
subscribe cvs-all</programlisting>

	  <para>と書いたメールを送って下さい. オプションとして本文に
	    <literal>help</literal> と書けば, Majordomo
	    はあなたへ我々がサポ ートする様々なメーリングリストに参加
	    / 脱退する方法に関する詳しい ヘルプを送ります.</para>
	</listitem>

	<listitem>
	  <para><hostid role="fqdn">ftp.FreeBSD.org</hostid>
	    からのソースの入手. 以下の3つの方法で行なうこと
	    が出来ます.</para>

	  <orderedlist>
	    <listitem>
	      <para>下に述べられている<application><link
		    linkend="ctm">CTM</link></application>を用いる.
		均一なレートの, 良質の TCP/IP
		接続を持っていない人には,
		これが一番いい方法でしょう.</para>
	    </listitem>

	    <listitem>
	      <para><link linkend="cvsup">cvsup</link> を <ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/src/share/examples/cvsup/standard-supfile"> この supfile</ulink>
		を用いて使用する. これは 2 番目に推薦される方法です.
		なぜなら, cvsup によって一度全体を入手し,
		後は変更されたところだけを入手することが
		出来るからです.
		たくさんの人が自動的にソースを最新のもに保つために
		cvsup を cron から起動しています.
		これを行なうための非常に簡単な方法は, 単に</para>

	      <blockquote><screen>&prompt.root; <userinput>pkg_add -f \
ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CVSup/cvsupit.tgz</userinput></screen></blockquote>

	      <para>とタイプすることです.</para>
	    </listitem>

	    <listitem>
	      <para><command>ftp</command> を使う. FreeBSD-current
		のソースツリーは常に <ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/">
		  ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/</ulink>
		に &ldquo;公開&rdquo; されています.
		我々はまた全体を compress/tar して入手できる
		<command>wu-ftpd</command> を使っています. 例えば,</para>

	      <screen>usr.bin/lex</screen>

	      <para>があったとすると,</para>

	      <screen><prompt>ftp&gt;</prompt> <userinput>cd usr.bin</userinput>
<prompt>ftp&gt;</prompt> <userinput>get lex.tar</userinput></screen>

	      <para>とすることにより, ディレクトリ全体(この場合,
		usr.bin/lex以下全体) を tar
		ファイルとして入手することができます.</para>
	    </listitem>
	  </orderedlist>
	</listitem>

	<listitem>
	  <para>以上のことをまとめると,
	    必要に応じて迅速なアクセスをする必要があり,
	    接続のバンド幅が問題ではなければ <command>cvsup</command>
	    か <command>ftp</command> を使いましょう. そうではなければ
	    <application>CTM</application> を使いましょう.</para>
	</listitem>

	<listitem>
	  <para>もしソースを,
	    眺めるだけでなく走らせるために入手しているのであれば,
	    一部だけ選ぶのではなく, current
	    の<emphasis>全体</emphasis>を手に入れてください. なぜなら,
	    ソースの様々な部分が他の部分の更新に依存しており,
	    一部のみをコンパイルしようとすると,
	    ほぼ間違いなくトラブルを起こすからです.</para>
	</listitem>

	<listitem>
	  <para>current をコンパイルする前に
	    <filename>/usr/src</filename> にある Makefile
	    をよく読んでください. アップグレードの処理の一部として,
	    少なくとも一回は最初に <link linkend="makeworld">make
	      world</link> を行なうべきでしょう. &a.current; を読めば,
	    次のリリースへ向けて, 時々必要になる
	    他のブートストラップの方法に関して
	    常に最新情報を得ることが出来ます.</para>
	</listitem>

	<listitem>
	  <para>アクティブになって下さい! もし FreeBSD-current
	    を走らせているなら我々はそれに関するコメント,
	    特に拡張やバグ潰しに関する提案, を欲しています.
	    コードを伴う提案はもっとも歓迎されるものです!</para>
	</listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1 id="stable">
    <title>FreeBSD の安定状態の持続</title>

    <para><emphasis>原作: &a.jkh;.</emphasis></para>

    <para><emphasis>訳: &a.jp.iwasaki;.</emphasis></para>

    <sect2>
      <title>FreeBSD-stable ってなに?</title>

      <para>FreeBSD-stable は,
	次の本流のリリースを目指した新機能をあまり採り入
	れない保守的な変更のための開発の支流です.
	実験的またはテスト未完の変更はこの支流には取り入れられません
	(<link linkend="current">最新の FreeBSD を追いかける</link>
	参照).</para>
    </sect2>

    <sect2>
      <title>誰が FreeBSD-stable を必要としているの?</title>

      <para>もしあなたが仕事で使用しているとか, なによりも FreeBSD
	システムの安定性を最重要視するなら,
	<emphasis>stable</emphasis> を追いかけることを考えるべきで
	しょう. <emphasis>stable</emphasis>
	の支流は前のリリースに関して効果的にバグフィックスされた
        流れであるため, 最新のリリース (<ulink
	  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/&rel.current;-RELEASE/">
	  &rel.current;-RELEASE</ulink> 執筆時点)
	をインストールしているのであれば, 特にそうです.</para>

      <warning>
	<para><emphasis>stable</emphasis>
	  ツリーが常に完全に互換性があり安定するように努力し
	  ていますが, たまに間違いがあることに注意してください (結局,
	  内容が吟味
	  されずに素早く送られた変更を含むソースがまだあるのです).
	  また,  <emphasis>current</emphasis> を
	  <emphasis>stable</emphasis>
	  へ移行する前に完璧なテストフィックスに最善を尽くしますが,
	  私たちのテストはすべてのケースを十分に網羅して
	  いるとは限りません. もし何か <emphasis>stable</emphasis>
	  で不具合があるようでしたら,
	  私たちに<emphasis>すぐに</emphasis>教えてください
	  (次の節参照).</para>
      </warning>
    </sect2>

    <sect2>
      <title>FreeBSD-stable を使う</title>

      <orderedlist>
	<listitem>
	  <para>&a.stable; へ加わってください. このメーリングリスト
	    では, <emphasis>stable</emphasis> の構築に関連する事柄や,
	    その他の注意すべき点 に関する情報が流れています.
	    また開発者は議論の余地がある修正や変更を考えている場合に,
	    このメーリングリストで公表し, 提案された変更に
	    関して問題が生じるかどうかを返答する機会を
	    ユーザに与えます. </para>

	  <para>また, &a.cvsall; メーリングリストでは,
	    それぞれの変更がなされると
	    起こりうる副作用に関するすべての適切な情報と一緒に commit
	    log を読むことができます. subscribe
	    しておきたいもう一つのメーリングリストです. </para>

	  <para>メーリングリストに参加するには, &a.majordomo
	    へメッセージの本文に
	    次のように書いたメールを送ってください:</para>

	  <programlisting>
subscribe freebsd-stable
subscribe cvs-all</programlisting>

	  <para>オプションとして本文に `help' と書けば, Majordomo
	    は私たちがサポートする様々なメーリングリストに参加 /
	    脱退する方法に関する詳しいヘルプを送付します.</para>
	</listitem>

	<listitem>
	  <para>もし, あなたが新しいシステムを可能な限り -stable
	    に近いものにインストールしようとする場合には,
	    最新のブランチの snapshot を <ulink
	      url="ftp://releng3.freebsd.org/pub/FreeBSD">
	      ftp://releng3.freebsd.org/pub/FreeBSD</ulink>
	    から取得し, これを一般のリリースのものと同様に
	    インストールしてください.</para>

	  <para>もし, 既に FreeBSD の以前のリリースが動いている場合で,
	    これをソースからアップグレードしようとするならば, <hostid
	      role="fqdn">ftp.FreeBSD.org</hostid> より簡単に
	    これを行う事が出来ます. これには次の 3 つの方法があります.
	  </para>

	  <orderedlist>
	    <listitem>
	      <para><application><link
		    linkend="ctm">CTM</link></application>
		機能を使用する. 転送レートが安定している TCP/IP
		接続でない場合は, この方法が適しています.</para>
	    </listitem>

	    <listitem>
	      <para><link linkend="cvsup">cvsup</link> を <ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/src/share/examples/cvsup/stable-supfile">
		  この supfile</ulink> を用いて使用する.
		一度コレクション全体を入手してしまえば,
		前回からの変更部分だけですむので, 2
		番目に推奨される方法です.
		多くの人が cron から cvsup を実行し,
		自動的にソースコードを最新の状態に保っています.
		これを簡単に扱うには次のようにタイプしてください.</para>

	      <blockquote><screen>&prompt.root; <userinput>pkg_add -f \
ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CVSup/cvsupit.tgz</userinput></screen></blockquote>
	    </listitem>

	    <listitem>
	      <para><command>ftp</command> を使用する. FreeBSD-stable
		用のソースツリーは
		常に次のところで&ldquo;公開&rdquo;されています:
		<ulink
		  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-stable/">ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-stable/</ulink></para>

	      <para>私たちはまた, tar/compress
		でツリー全体を入手できる <command>wu-ftpd</command>
		を使用しています. 例えば :</para>

	      <screen>usr.bin/lex</screen>

	      <para>に対して:</para>

	      <screen><prompt>ftp&gt;</prompt> <userinput>cd usr.bin</userinput>
<prompt>ftp&gt;</prompt> <userinput>get lex.tar</userinput></screen>

	      <para>とすることにより, ディレクトリ全体を tar
		ファイルとして入手することができます.</para>
	    </listitem>
	  </orderedlist>
	</listitem>

	<listitem>
	  <para>基本的には,
	    ソースに迅速でオンデマンドなアクセスが必要で,
	    接続のバンド幅が問題でなければ, <command>cvsup</command>
	    か <command>ftp</command> を使いましょう. そうで
	    ない場合は <application>CTM</application>
	    を使いましょう.</para>
	</listitem>

	<listitem>
	  <para>stable をコンパイルする前に,
	    <filename>/usr/src</filename> にある Makefile をよ
	    く読んでください.
	    少なくとも一回はアップグレードの処理の一部として最初に
	    <link linkend="makeworld">make world</link>
	    を実行するべきでしょう. &a.stable; を読めば,
	    次のリリースに移行する
	    に当たって時々必要となる既存システムからの
	    新システムの構築手順に
	    ついての最新情報が得られるでしょう.</para>
	</listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>インターネットを通じたソースツリーの同期</title>

    <para><emphasis>原作: &a.jkh;.</emphasis></para>

    <para><emphasis>訳: &a.jp.iwasaki;. 13 September 1997.</emphasis></para>

    <para>インターネット接続 (または電子メール) を使用して,
      あなたの興味の対象によって FreeBSD
      プロジェクトのソースのある一部分または全体の最新を
      追いかける方法は色々あります.
      私たちが提供している基本的なサービスは  <link
	linkend="anoncvs">Anonymous CVS</link>, <link
	linkend="cvsup">CVSup</link> と <link linkend="ctm">CTM</link>
      です:</para>

    <para><application>Anonymous CVS</application> と
      <application>CVSup</application> は <emphasis>pull</emphasis>
      同期モデルを採用しています.
      <application>CVSup</application> の場合, ユーザ
      (または cron スクリプト) が <command>cvsup</command>
      起動し, どこかにある <command>cvsupd</command>
      サーバとやりとりしてファイルを
      最新状態にします.
      届けられる更新情報はその時点の最新のものであり,
      また必要な時にだけ取り寄せられます.
      興味のある特定のファイルやディレクトリに
      限定して更新することも簡単にできます.
      クライアント側のソースツリーの状態・
      設定ファイルの指定に従い, サーバによって更新情報が
      素早く生成されます.
      <application>Anonymous CVS</application> は,
      このプログラムがリモートの CVS リポジトリから直接変更点を
      pull できるようにした &man.cvs.1; への拡張であるという点で,
      <application>CVSup</application> よりもずっと単純です.
      <application>CVSup</application>
      は効率の点ではるかにまさっていますが,
      <application>Anonymous CVS</application> の方が簡単に利用できます.
    </para>

    <para>一方, <application>CTM</application>
      はあなたが持っているソースとマスタアーカイブ上に
      あるそれとの対話的な比較をおこないませんし,
      あるいは向こう側から変更点を pull したりもしません.
      そのかわりに, 前回の実行時からの変更を認識するスクリプトが
      マスタ CTM マシン上で一日に数回実行され,
      すべての変更を compress して通し番号を振り,
      さらに電子メールで転送できるようにエンコードします
      (印字可能な ASCII
      キャラクタのみです). 受信した後は,
      これらの &ldquo;CTM のデルタ&rdquo; は自動
      的にデコード, 検査してユーザのソースのコピーに変更を適用する
	&man.ctm.rmail.1; によって処理可能となります.
      この処理は <application>CVSup</application> や
      <application>Anonymous CVS</application> よりずっと効率
      的であり, <emphasis>pull</emphasis> モデルというよりむしろ
      <emphasis>push</emphasis> モデルで
      あるため, 私たちのサーバ資源の負荷は軽くなります.</para>

    <para>もちろん他のトレードオフもあります. うっかりアーカイブ
      の一部を消してしまっても, <application>CVSup</application>
      は壊れた部分を検出して再構築してくれます.
      <application>CTM</application> はこれをやってくれませんし,
      <application>Anonymous CVS</application>
      はおそらく他の何よりも深く混乱してしまうことが多いでしょう.
      もしソースツリーの一部を消してしまったら, (最新の CVS
      &ldquo;ベースデルタ&rdquo;から) 一からやり直し, CTM か anoncvs
      を使って悪い部分を消去し, 再同期させることによって
      すべてを再構築しなければなりません.</para>

    <para><application>Anonymous CVS</application>,
      <application>CTM</application>, <application>CVSup</application>
      についての 詳しい情報については,
      以下の節を参照してください:</para>

    <sect2 id="anoncvs">
      <title>Anonymous CVS</title>

      <para><emphasis>原作: &a.jkh;</emphasis></para>
      <para><emphasis>訳: &a.jp.sugimura;</emphasis>. 19 July 1998.</para>

      <sect3>
	<title><anchor id="anoncvs-intro">導入</title>

	<para>Anonymous CVS (もしくは, <emphasis>anoncvs</emphasis>
	  として知られています) は離れたところにある CVS
	  リポジトリと同期を取るために FreeBSD に付属している CVS
	  ユーティリティに含まれている機能です. 他にもありますが,
	  それは FreeBSD のユーザが, 特別な権限なしに FreeBSD
	  プロジェクトの公式な anoncvs サーバに読み取り専用で CVS
	  の操作をすることができるようにするためのものです.
	  それを使うには, 単に <envar>CVSROOT</envar>
	  環境変数を設定して適切な anoncvs サーバを指定し,
          <command>cvs login</command> を使って
          パスワード <quote>anoncvs</quote> を入力して下さい.
          そして次に, &man.cvs.1; コマンドを使うことで, 
          手元にあるリポジトリと同じようにアクセスでるようになります.</para>

	<para><link linkend="cvsup">CVSup</link> と
	  <emphasis>anoncvs</emphasis>
	  のサービスは本質的に同じ機能ではないか
	  ということも言われていますが,
	  ユーザが同期を取る方法を選ぶときに影響を与えるような
	  さまざまなトレードオフが存在します. 要約して言えば,
	  <application>CVSup</application>
	  はネットワーク資源の使い方においては非常に効率がよく,
	  またはるかに技術的に洗練されたものですが,
	  相当な手間がかかります. <application>CVSup</application>
	  を使うには,
	  特別なクライアントをまずインストールして設定しなくては 1bit
	  も取ってくることができず, またそのとき
	  <application>CVSup</application> では
	  <emphasis>collections</emphasis>
	  と呼んでいるかなり大きなかたまりだけからしか
	  取ってこれません.</para>

	<para>それに対して <application>anoncvs</application> では,
	  CVS モジュールの名前を指定することで特定のプログラムの
	  (<command>ls</command> や <command>grep</command> のような)
	  個々のファイルから調べることができます.  もちろん,
	  <application>anoncvs</application> は CVS
	  リポジトリの読み取り専用の操作に対してのみ適しているので,
	  もしあなたが FreeBSD プロジェクトのものと共有されたなにか
	  ローカルなリポジトリを作ってそこでの開発を
	  行おうというときには, <application>CVSup</application>
	  だけが唯一の手段となってしまいます.</para>
      </sect3>

      <sect3>
	<title><anchor id="anoncvs-usage">Anonymous CVS を使う</title>

	<para>&man.cvs.1; を設定して Anonymous CVS
	  リポジトリを使うには単に <envar>CVSROOT</envar>
	  環境変数を設定して FreeBSD プロジェクトの
	  <emphasis>anoncvs</emphasis> サーバを指定するだけのことです.
	  この文書を書いているときには,
	  次のサーバが利用できるようになっています.</para>

	<itemizedlist>
	  <listitem>
	    <para><emphasis>USA</emphasis>:
	      :pserver:anoncvs@anoncvs.freebsd.org:/ncvs
	      (<command>cvs login</command> コマンドを使い, 
               プロンプトが表示されたらパスワード
	      <quote>anoncvs</quote> を入力してください)</para>
	  </listitem>
	</itemizedlist>

	<para>CVS はかつて存在した (もしくは,
	  時にはこれから存在するものも <!-- smiley -->:)
	  ほとんどどんなバージョンの FreeBSD のソースを &ldquo;check
	  out&rdquo; することができますが, あなたは &man.cvs.1; の
	  リビジョン (<option>-r</option>) のオプションや FreeBSD
	  プロジェクトのリポジトリの中で
	  それをどのように指定したらいいものかということを
	  よく知っておく必要があります.</para>

	<para>タグには 2 種類あって,
	  リビジョンタグとブランチタグがあります.
	  リビジョンタグは特定の改訂版を指しており,
	  それはいつも同じものを意味しています. 一方ブランチタグは,
	  指定されたときの指定された開発の流れにおける
	  最も新しい改訂版を示しています.
	  ブランチタグは特定の改訂版を指していないために,
	  その意味はきょうと明日では違うものになっているでしょう.
	</para>

	<para>ユーザが興味を持つと思われるブランチタグの一覧です.</para>

	<variablelist>
	  <varlistentry>
	    <term>HEAD</term>
	    <listitem>
	      <para>主要部をなす流れ, すなわち FreeBSD-current
		のための名前です. また,
		どのリビジョンも
		指定されなかったときにはこれになります.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_3</term>
	    <listitem>
	      <para>FreeBSD-3.x の開発のための流れです.
		FreeBSD-stable としても知られています.
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_2_2</term>
	    <listitem>
	      <para>FreeBSD-2.2.x の開発のための流れです. 2.2-stable
		としても知られています. このブランチは大部分が
		すたれています.
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>ユーザが興味を持つであろうリビジョンタグの一覧です.</para>

	<variablelist>

	  <varlistentry>
	    <term>RELENG_3_4_0_RELEASE</term>
	    <listitem>
	      <para>FreeBSD-3.4 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_3_3_0_RELEASE</term>
 
	    <listitem>
	      <para>FreeBSD-3.3 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>

            <term>RELENG_3_2_0_RELEASE</term>
                  
            <listitem>
              <para>FreeBSD-3.2 です.    
                このタグは ports コレクションには無効です.</para>
            </listitem>
          </varlistentry>
        
	  <varlistentry>
	    <term>RELENG_3_1_0_RELEASE</term>
	    <listitem>
	      <para>FreeBSD-3.1 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_3_0_0_RELEASE</term>
	    <listitem>
	      <para>FreeBSD-3.0 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_2_2_8_RELEASE</term>
	    <listitem>
	      <para>FreeBSD-2.2.8 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_2_2_7_RELEASE</term>
	    <listitem>
	      <para>FreeBSD-2.2.7 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_2_2_6_RELEASE</term>
	    <listitem>
	      <para>FreeBSD-2.2.6 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_2_2_5_RELEASE</term>
	    <listitem>
	      <para>FreeBSD-2.2.5 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_2_2_2_RELEASE</term>
	    <listitem>
	      <para>FreeBSD-2.2.2 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_2_2_1_RELEASE</term>
	    <listitem>
	      <para>FreeBSD-2.2.1 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>RELENG_2_2_0_RELEASE</term>
	    <listitem>
	      <para>FreeBSD-2.2.0 です.  
                このタグは ports コレクションには無効です.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>ブランチタグを指定したときには,
	  普通はその開発の流れにおける
	  最も新しいバージョンのファイルを受け取ることができます.
	  もし以前のバージョンのものが欲しいときには, 日付を
	  <option>-D date</option>
	  オプションを使って指定すればよいです.</para>
      </sect3>

      <sect3>
	<title>例</title>

	<para>本当はなにかする前には &man.cvs.1;
	  のマニュアルページの全体を
	  ちゃんと読んでからのほうがいいのですが, Anonymous CVS
	  の使い方の本質的なところを簡単に例を挙げて説明します.</para>

	<example>
	  <title>-current (&man.ls.1;)
	    をちょっと確認してから消してみます.</title>

	  <screen>&prompt.user; <userinput>setenv CVSROOT :pserver:anoncvs@anoncvs.freebsd.org:/ncvs</userinput>
&prompt.user; <userinput>cvs login</userinput>
<emphasis>プロンプトが表示されたら, パスワード <quote>anoncvs</quote> を入力します.</emphasis>
&prompt.user; <userinput>cvs co ls</userinput>
&prompt.user; <userinput>cvs release -d ls</userinput>
&prompt.user; <userinput>cvs logout</userinput></screen>
	</example>

	<example>
	  <title>&man.ls.1; のバージョンを 2.2-stable
	    ブランチから調べてみます.</title>

	  <screen>&prompt.user; <userinput>setenv CVSROOT :pserver:anoncvs@anoncvs.freebsd.org:/ncvs</userinput>
&prompt.user; <userinput>cvs login</userinput>
<emphasis>プロンプトが表示されたら, パスワード <quote>anoncvs</quote> を入力します.</emphasis>
&prompt.user; <userinput>cvs co -rRELENG_2_2 ls</userinput>
&prompt.user; <userinput>cvs release -d ls</userinput>
&prompt.user; <userinput>cvs logout</userinput></screen>
	</example>

	<example>
	  <title>&man.ls.1; の変更点のリストを
           (unidiff で) 作ってみます.</title>

	  <screen>&prompt.user; <userinput>setenv CVSROOT :pserver:anoncvs@anoncvs.freebsd.org:/ncvs</userinput>
&prompt.user; <userinput>cvs login</userinput>
<emphasis>プロンプトが表示されたら, パスワード <quote>anoncvs</quote> を入力します.</emphasis>
&prompt.user; <userinput>cvs rdiff -u -rRELENG_2_2_2_RELEASE -rRELENG_2_2_6_RELEASE ls</userinput>
&prompt.user; <userinput>cvs logout</userinput></screen>
	</example>

	<example>
	  <title>他のどんなモジュールの名前が
	    使われているか検索してみます.</title>

	  <screen>&prompt.user; <userinput>setenv CVSROOT :pserver:anoncvs@anoncvs.freebsd.org:/ncvs</userinput>
&prompt.user; <userinput>cvs login</userinput>
<emphasis>プロンプトが表示されたら, パスワード <quote>anoncvs</quote> を入力します.</emphasis>
&prompt.user; <userinput>more modules/modules</userinput>
&prompt.user; <userinput>cvs release -d modules</userinput>
&prompt.user; <userinput>cvs logout</userinput></screen>
	</example>
      </sect3>

      <sect3>
	<title>他の資料</title>

	<para>次の資料は CVS を学ぶのに役に立つでしょう.</para>

	<itemizedlist>
	  <listitem>
	    <para><ulink
		url="http://www.csc.calpoly.edu/~dbutler/tutorials/winter96/cvs/">CVS チュートリアル</ulink>. Cal Poly によります.</para>
	  </listitem>

	  <listitem>
	    <para><ulink url="http://www.cyclic.com/">Cyclic
		Software</ulink>, 商用として CVS を維持しています.</para>
	  </listitem>

	  <listitem>
	    <para><ulink
		url="http://www.freebsd.org/cgi/cvsweb.cgi">CVSWeb</ulink>
	      は FreeBSD Project の CVS のための web
	      インターフェースです.</para>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>

    <sect2 id="ctm">
      <title><application>CTM</application></title>

      <para><emphasis>原作: &a.phk;, 1997 年 10 月 19 日更新.</emphasis></para>

      <para><emphasis>訳: &a.hanai;, 1997 年 9 月 13 日.</emphasis></para>

      <para><application>CTM</application>
	はリモートのディレクトリツリーを中央のツリーに同期させるための
	手段です.
	これはFreeBSDのソースツリーの配布を行なうために開発されまし
	たが, 時が経つにつれて別の目的にも有用であることがわかるかも
	しれません.
	デルタを作り出す処理に関するドキュメントは現在ほとんど
	ありません. 従って, もしあなたが<application>CTM</application>
	を他のことに使いたいなら
	&a.phk;にさらなる情報を問い合わせてください.</para>

      <sect3>
	<title>なぜ<application>CTM</application>を使うの?</title>

	<para><application>CTM</application> を使うことにより FreeBSD
	  ソースツリーのローカルコピーを手にいれることができます.
	  ソースツリーが使えることの魅力は数多くあります. 完全な cvs
	  ツリーを追いかけるにしても, ひとつのブランチを追いかける
	  にしても <application>CTM</application>
	  は必要な情報を与えてくれます.
	  もしあなたがFreeBSDのアクティブな開発者であるにもかかわらず
	  お粗末なTCP/IP接続しか持っていなかったり, またはTCP/IP接続が
	  行なえないとしたら, あるいは単に変更が自動的に送られてきて
	  ほしいというのであれば <application>CTM</application>
	  はそんなあなたのために 作られたのです.
	  アクティブなブランチでは 1
	  日に最大三つまでのデルタを受け取る必要があります.
	  これが自動的に e-mail で送られてくるという方法を
	  ぜひ検討してみてください.
	  デルタのサイズは常にできるだけ小さく保たれています.
	  大抵の場合5KBよりも小さく,
	  たまに(10回に1回程度)10-50KBになり,
	  ときおり100KBかもっと大きくなるでしょう.</para>

	<para>開発ソースから直接に得られたものを使うことについては,
	  あらかじめパッケージにされたリリースとは違い,
	  いろいろと注意することが あります. これは特に
	  &ldquo;current&rdquo; のソースを選んでいるときは重要です.
	  <link linkend="current">最新の FreeBSD
	    を追いかける</link>を読むことをお勧めします.</para>
      </sect3>

      <sect3>
	<title><application>CTM</application>を使うには何が必要?</title>

	<para>二つのものが必要でしょう: <application>CTM</application>
	  プログラムとそれに与える (&ldquo;current&rdquo;
	  レベルを得るための)最初のデルタです.</para>

	<para><application>CTM</application>
	  プログラムはバージョン2.0のリリース以来FreeBSDの一部にな
	  りました. もしソースのコピーを持っているなら
	  <filename>/usr/src/usr.sbin/CTM</filename>にあります.</para>

	<para>もしFreeBSDの2.0以前のバージョンなら,
	  最新の<application>CTM</application>のソースを直接</para>

	<para><ulink url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/src/usr.sbin/ctm/">ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/src/usr.sbin/ctm/</ulink></para>

	<para>から入手できます. <application>CTM</application>
	  に与える &ldquo;デルタ&rdquo; は二つの方法, FTPまたはe-mail,
	  で得ること ができます.
	  もしインターネットにFTPアクセスできるなら,
	  次のFTPサイト:</para>

	<para><ulink url="ftp://ftp.FreeBSD.org/pub/FreeBSD/CTM/">ftp://ftp.FreeBSD.org/pub/FreeBSD/CTM/</ulink></para>

	<para>または, その <link
	    linkend="mirrors-ctm">ミラーサイト</link> が
	  <application>CTM</application> へのアクセスをサポートします.
	  適切なディレクトリに FTP して <filename>README</filename>
	  ファイルを入手し, そこからスタートしてください.</para>

	<para>e-mail によってデルタを得たいという場合は:</para>

	<para><application>CTM</application>
	  配布メーリングリストのいずれかに参加するために &a.majordomo;
	  へ subscribe のメールを送ってください.
	  &ldquo;ctm-cvs-cur&rdquo; は完全な cvs ツリー
	  をサポートします. &ldquo;ctm-src-cur&rdquo;
	  は開発先端ブランチをサポートします &ldquo;ctm-src-2_2&rdquo;
	  は 2.2 リリースのブランチのサポートです.
	  (もし majordomo を使って参加する方法を知らないのであれば,
	  最初に <literal>help</literal>
	  という語を含むメッセージを送ってください. &mdash;
	  使い方の説明が送られてくるでしょう.)</para>

	<para>メールで <application>CTM</application>
	  による更新ファイルを受け取り始めると, 中身を取り出して使用
	  するために <command>ctm_rmail</command>
	  プログラムを使うかもしれません. それを完全
	  に自動で行ないたいなら, <filename>/etc/aliases</filename>
	  から <command>ctm_rmail</command>プロ
	  グラムを直接使うこともできます.
	  さらに詳しいことは<command>ctm_rmail</command>
	  manページを御覧ください.</para>

	<note>
	  <para><application>CTM</application>
	    デルタを得るためにどの方法を使うのであっても,
	    <email>ctm-announce@FreeBSD.org</email>
	    メーリングリストに参加するべきです.
	    このメーリングリストは将来的には
	    <application>CTM</application>システムの操作に関する
	    アナウンスがポストされる唯一の場になるでしょう.
	    メーリングリストに加わるためには<literal>subscribe
	      ctm-announce</literal> と書いた一行だけのメールを
	      &a.majordomo; へ送ってください.</para>
	</note>
      </sect3>

      <sect3>
	<title>はじめて<application>CTM</application>を使い始める</title>

	<para><application>CTM</application>
	  デルタを使い始めるためには, これは以降作られる全ての
	  デルタの出発点を手にいれる必要があります.
	  最初にあなたが何をすでに持っているかをはっきりさせましょう.
	  すべての人は
	  &ldquo;空&rdquo;のディレクトリから始めなければなりません.
	  ツリーをサポートしてるあなたの
	  <application>CTM</application> を稼働するためには
	  指定した&ldquo;空&rdquo;
	  のデルタを使う必要があります. いくつかの分岐点
	  では, あなたの都合により CD
	  内に分配されている&ldquo;スタータ&rdquo;
	  デルタを使用できるようになっています. しかしながら, これは
	  頻繁に行われることではありません.
	</para>

	<para>適切な出発点が決まれば, その出発点を
	  <application>CTM</application> が
	  維持するツリーへ変換するための &ldquo;スタータ&rdquo;
	  初期デルタを使う必要が あります.</para>

	<para>移行デルタは番号の後ろに <literal>X</literal>
	  をつけたものがそうです
	  (たとえば<filename>src-cur.3210XEmpty.gz</filename>).
	  <filename>X</filename>
	  の後ろは最初の開始ポイントに対応します.
	  <filename>Empty</filename> は 空のディレクトリです.
	  ルールとして <filename>Empty</filename> からの移行デルタは
	  100 デルタごとに 作られます. ところで,
	  これらは非常に大きいです!
	  <filename>XEmpty</filename>のデルタは 数十MBの
	  <command>gzip</command>
	  で圧縮されたデータというのが普通です.</para>

	<para>一度スタートするためのベースデルタを得ると,
	  それに続く多数の全てのデルタも必要になるでしょう.</para>
      </sect3>

      <sect3>
	<title><application>CTM</application>を日常で使う</title>

	<para>デルタを適用するためには, 単に</para>

	<screen>&prompt.root; <userinput>cd /where/ever/you/want/the/stuff</userinput>
&prompt.root; <userinput>ctm -v -v /where/you/store/your/deltas/src-xxx.*</userinput></screen>

	<para>とします.</para>

	<para><application>CTM</application>
	  はどれが<command>gzip</command>されているか理解します.
	  従って最初に gunzipしておく必要はありません.
	  ディスクの節約にもなります.</para>

	<para>全体の処理に関して確信するまでは
	  <application>CTM</application> は(ソース)ツリーに対して
	  何もしません. また, デルタを確かめるためには
	  <option>-c</option> フラグを使うことができます.
	  このフラグがあると <application>CTM</application>
	  はツリーに対して実際には何も行ないません.
	  単にデルタの完全性を確認し,
	  現在のツリーに問題なく使用できるかを確認
	  するだけです.</para>

	<para><application>CTM</application>
	  には他にもオプションがあります. 詳細に関しては
	  マニュアルページを参照するかソースを見てください.</para>

	<para>もし誰かが &ldquo;ユーザ インターフェース&rdquo;
	  の部分に関して助けてくれるなら私はとても嬉しいです.
	  なぜならどういうオプションが何を, どのように,
	  いつ行なうようにするべきか決めかねているからです.</para>

	<para>以上でやることは本当に全部です.
	  新しいデルタを入手した時には,
	  ソースを最新のものにするためにそれを
	  <application>CTM</application>に通すだけです.</para>

	<para>もしデルタを再ダウンロードするのが
	  骨の折れる作業であれば, デルタを 消さないでおいてください.
	  なにかおかしなことが起こった場合には置いておけば良かった
	  と思うかもしれません.
	  もしフロッピーディスクしか持っていない状況
	  であってもコピーを取るのに
	  <command>fdwrite</command>を使うことを考えてください.</para>
      </sect3>

      <sect3>
	<title>ローカルの変更を保存する</title>

	<para>開発者としてはソースツリー中のファイルを
	  使って実験したり変更したく なるものです.
	  <application>CTM</application>
	  はローカルの変更を制限つきでサポートします: ファイル
	  <filename>foo</filename> の存在をチェックする前に,
	  <filename>foo.ctm</filename> を参照しにいきます.
	  このファイルが存在する場合, CTM は <filename>foo</filename>
	  の代りにこれを処理します.</para>

	<para>この動作はローカルの変更を保持する簡単な手段を
	  提供します: 単に変更したいファイルを拡張子
	  <filename>.ctm</filename> 付きのファイル名で
	  コピーするだけです. あとは自由にコードをハックでき,
	  <filename>.ctm</filename>  ファイルの方は CTM
	  が最新状態に保ってくれます.</para>
      </sect3>

      <sect3>
	<title><application>CTM</application>
	  のその他の面白いオプション</title>

	<sect4>
	  <title>更新で変更されるファイルを正確に知る</title>

	  <para><application>CTM</application>
	    のソースリポジトリに対する変更のリストを
	    <option>-l</option>
	    オプションを使って決定することができます.</para>

	  <para>これは, 変更のログを保存したい,
	    変更されたファイルをなんらかの方法で 前・後処理したい,
	    または単にこだわりたい<!-- smiley --> :-) 場合には,
	    役に立つでしょう.</para>
	</sect4>

	<sect4>
	  <title>更新前にバックアップを取る</title>

	  <para><application>CTM</application>
	    の更新によって変更されるファイルすべてのバックアップを
	    取りたくなることがあります.</para>

	  <para><option>-B backup-file</option> オプションを指定すると
	    <application>CTM</application> は
	    デルタで変更されるファイルすべてを
	    <filename>backup-file</filename>
	    としてバックアップするようになります.</para>
	</sect4>

	<sect4>
	  <title>更新で変更されるファイルを制限する</title>

	  <para><application>CTM</application>
	    の更新の範囲を制限したり一連のデルタのから
	    ほんの数ファイルを抽出したくなることがあります.</para>

	  <para><option>-e</option> と <option>-x</option>
	    オプションを用い正規表現を指定することで,
	    <application>CTM</application>
	    が処理するファイルのリストを制御することが
	    できます.</para>

	  <para>例えば, <filename>lib/libc/Makefile</filename>
	    の最新のコピーを保存してある CTM
	    デルタのコレクションから抽出するには,
	    以下のコマンドを実行します. </para>

	  <screen>&prompt.root; <userinput>cd /where/ever/you/want/to/extract/it/</userinput>
&prompt.root; <userinput>ctm -e '^lib/libc/Makefile' ~ctm/src-xxx.*</userinput></screen>

	  <para><application>CTM</application>
	    デルタで指定されたファイルごとに, <option>-e</option>
	    そして <option>-x</option>
	    オプションがコマンドラインで指定された順序で適用されます.
	    すべての<option>-e</option> そして <option>-x</option>
	    オプションが適用された後に更新対象と選択された場合に限り,
	    <application>CTM</application>
	    はそのファイルを処理します.</para>
	</sect4>
      </sect3>

      <sect3>
	<title><application>CTM</application>の将来計画</title>

	<para>重要なもの</para>

	<itemizedlist>
	  <listitem>
	    <para>なんらかの CTM システムへの認証機構を用い, 不正な
	      CTM の更新の検出を可能とする.</para>
	  </listitem>

	  <listitem>
	    <para><application>CTM</application>
	      へのオプションを整理する. さもないと混乱し,
	      直観に反したものになります.</para>
	  </listitem>
	</itemizedlist>

	<para>残念なことに私は非常に忙しいです.
	  従ってこれを行なうどんな手助けでも歓迎します. その際,
	  自分が何をやりたいかを私に言うのを忘れずに.</para>
      </sect3>

      <sect3>
	<title>その他</title>

	<para>&ldquo;DESに染まった&rdquo; (例えば,
	  国外への持ち出しが規制された)ソースはまったく含まれません.
	  手に入るのは&ldquo;国際&rdquo;バージョンだけです.
	  もし興味のある人が多いようであれば,
	  我々は<literal>sec-cur</literal>シーケンスも
	  セットアップするつもりです. <literal>ports</literal>
	  コレクションに対するデルタのシーケンスもあります. しかし,
	  まだあまり興味は持たれていないようです.
	  もしこれに対するメーリング
	  リストが欲しい時も私に言ってください.
	  我々はセットアップすることを考えます.</para>
      </sect3>

      <sect3>
	<title>ありがとう!</title>

	<variablelist>
	  <varlistentry><term>&a.bde;</term>
	    <listitem>
	      <para>鋭い記述とすばらしいコメントに対して.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>&a.sos;</term>
	    <listitem>
	      <para>よく辛抱してくれました.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>Stephen McKay</term>
	    <listitem>
	      <para><command>ctm_[rs]mail</command>を書いてくれました.
		とても感謝して います.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>&a.jkh;</term>
	    <listitem>
	      <para>彼が頑固として譲らなかったため, 私もこの
		<acronym>CTM</acronym> をもっと良いものに
		しないわけにはいきませんでした.
		彼の頑固さに感謝します.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>ユーザの人みんな</term>
	    <listitem>
	      <para>気に入ってくれることを願っています...</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>
    </sect2>

    <sect2 id="cvsup">
      <title><application>CVSup</application></title>

      <para><emphasis>原作: &a.jdp;</emphasis>.</para>

      <para><emphasis>訳: &a.jp.iwasaki;, 1997 年 2 月 27 日.</emphasis></para>

      <sect3 id="cvsup-intro">
	<title><application>CVSup</application> の紹介</title>

	<para><application>CVSup</application> は,
	  リモートのサーバホストにあるマスタ CVS リポジトリから
	  ソースツリーを配布し更新するための
	  ソフトウェアパッケージです. FreeBSD のソースは,
	  カリフォルニアにある中心的な開発マシンの CVS リポジトリの
	  中でメンテナンスしています. <application>CVSup</application>
	  を使用することで, FreeBSD ユーザは
	  簡単に自分のソースツリーを最新の状態に
	  しておくことができます.</para>

	<para><application>CVSup</application> は
	  <emphasis>pull</emphasis>
	  モデルとよばれる更新のモデルを採用しています.  pull
	  モデルでは,
	  各クライアントが更新したい場合に更新したい時点で,
	  サーバに更新の問い合わせをおこないます.
	  サーバはクライアントからの
	  更新の要求を受け身の状態で待ちます. したがって,
	  すべての更新はクライアント主導でおこなわれます.
	  サーバは頼まれもしない更新情報を送るようなことはしません.
	  ユーザは <application>CVSup</application>
	  クライアントを手動で実行して更新をおこなうか,
	  <command>cron</command>
	  ジョブを設定して定期的に自動実行する必要があります.</para>

	<para>用語 <application>CVSup</application>
	  のように大文字で表記しているものは, ソフトウェアパッケージ
	  全体を指します. 主な構成物は,
	  各ユーザマシンで実行するクライアントである
	  <command>cvsup</command>, FreeBSD
	  の各ミラーサイトで実行するサーバ <command>cvsupd</command>
	  です.</para>

	<para>FreeBSD の文書やメーリングリストを読んだ際に,
	  <application>sup</application> についての言及を
	  見かけたかもしれません. <application>sup</application> は
	  <application>CVSup</application> の前に存在していたもので,
	  同様の目的で使われていました.
	  <application>CVSup</application> は sup
	  と同じように使用されており, 実際, <command>sup</command>
	  と互換性のあるコンフィグレーションファイルを使用します.
	  <application>CVSup</application>
	  の方がより高速で柔軟性もあるので, もはや
	  <application>sup</application> は FreeBSD
	  プロジェクトでは使用されていません.</para>
      </sect3>

      <sect3 id="cvsup-install">
	<title><application>CVSup</application> のインストール</title>

	<para><application>CVSup</application> をインストールする
          最も簡単な方法は, FreeBSD
          <link linkend="ports">ports コレクション</link> の
          <filename>net/cvsup-bin</filename> をインストールすることです.  
          もしくは, <filename>net/cvsup</filename> でも構いません.  
          ただし, <filename>net/cvsup</filename> は
          Modula-3 システムに依存していて, 構築にかかる時間, 
          メモリ, ディスクスペースは比較的大きくなります.  

          もし, あなたに cvsup に関して全く知識がなく, 
          自動で設定ファイルをセットアップして, 
          クリックするだけで転送を行なえるインターフェイスを提供してくれるような, 
          単一のパッケージをインストールしたいと考えているなら, 
          <ulink url="ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CVSup/cvsupit.tgz">
            cvsupit</ulink> パッケージを利用して下さい.  
          これは pkg_add(1) するだけで良く, 
          設定は, その際にメニュー形式で行なうことができるようになっています.  
          <!-- hrs:2000/02/15
               pkg_add(1) should be treated as "command" (or &man.pkg_add.1;)? -->
        </para>
      </sect3>

      <sect3 id="cvsup-config">
	<title>CVSup のコンフィグレーション</title>

	<para><application>CVSup</application> の動作は, <filename>supfile</filename>
	  と呼ばれるコンフィグレーションファイルで 制御します.
	  <filename>supfile</filename> のサンプルは, ディレクトリ <ulink
	    url="file:/usr/share/examples/cvsup/">/usr/share/examples/cvsup/
	  </ulink> の下にあります. 
        </para>

	<para><filename>supfile</filename> には以下の cvsup
	  に関する質問への答えを記述します:</para>

	<itemizedlist>
	  <listitem>
	    <para><link linkend="cvsup-config-files">
		どのファイルを受け取りたいのか?</link></para>
	  </listitem>

	  <listitem>
	    <para><link linkend="cvsup-config-vers">
		どのバージョンのものが欲しいのか?</link></para>
	  </listitem>

	  <listitem>
	    <para><link linkend="cvsup-config-where">
		どこから入手したいのか?</link></para>
	  </listitem>

	  <listitem>
	    <para><link linkend="cvsup-config-dest">
		自分のマシンのどこに置きたいのか?</link></para>
	  </listitem>

	  <listitem>
	    <para><link linkend="cvsup-config-status">
		どこに status ファイルを置きたいのか?</link></para>
	  </listitem>
	</itemizedlist>

	<para>次のセクションで, これらの質問に順番に答えながら典型的な
	  <filename>supfile</filename> を組み立てていきます. 最初に
	  <filename>supfile</filename> の全体構造を説明します.</para>

	<para><filename>supfile</filename> はテキストファイルです.
	  コメントは <literal>#</literal> から行末までです.
	  空行とコメントだけの行は無視します.</para>

	<para>残りの各行には,
	  ユーザが受け取りたいファイル群について記述します.
	  行の始めは,
	  サーバ側で定義した論理的なファイルのグループである
	  &ldquo;コレクション&rdquo;の名称です.
	  コレクションの名称を指定して, 欲しいファイル群を
	  サーバに伝えます. コレクション名の後には,
	  ホワイトスペースで区切られた 0 個以上のフィールドが続きます.
	  これらのフィールドが上記の質問に対する答えになります.
	  フィールドには 2 種類あります: flag フィールドと value
	  フィールドです. flag フィールドは <literal>delete</literal>
	  や <literal>compress</literal> のような
	  単独のキーワードから成ります. また, value
	  フィールドもキーワードで始まりますが,
	  キーワードの後にはホワイトスペースは入らず,
	  <literal>=</literal> と二つめの単語が続きます. 例えば,
	  <literal>release=cvs</literal> は value
	  フィールドです.</para>

	<para>通常, <filename>supfile</filename>
	  には受け取りたいコレクションを一つ以上指定します.
	  <filename>supfile</filename> を組み立てる一つの方法として,
	  コレクション毎にすべての関係の
	  あるフィールドを明示的に指定する方法があります. しかし,
	  これでは <filename>supfile</filename>
	  のすべてのコレクションに対して
	  ほとんどのフィールドが同じになるため,
	  行が非常に長くなってしまい不便になります.
	  これらの問題を避けるため,  <application>CVSup</application>
	  ではデフォルトを指定することのできる
	  メカニズムが提供されています. 特殊な擬似コレクション名
	  <literal>*default</literal> で始まる行は,
	  <filename>supfile</filename> 中の後続の
	  コレクションに対して使用する flag フィールドと value
	  フィールドのデフォルトを設定するために利用できます.
	  個々のコレクションで固有の値を指定すると,
	  デフォルト値を無効にできます. また <option>*default</option>
	  行を追加すると, <filename>supfile</filename>
	  の途中からデフォルト値の変更や追加が可能になります.</para>

	<para>これまでの予備知識を基に,
          <link linkend="current">FreeBSD-current</link>
	  のメインのソースツリーを受け取って更新するための
	  <filename>supfile</filename> を組み立ててみましょう.</para>

	<itemizedlist>
	  <listitem>
	    <para>どのファイルを受け取りたいのか?
              <anchor id="cvsup-config-files"></para>

	    <para><application>CVSup</application>
	      を通して入手できるファイルは &ldquo;コレクション&rdquo;
	      と呼ばれる名前の付けられたグループにまとめられています.
	      利用可能なコレクションについては
              <link linkend="cvsup-collec">ここ</link> で説明しています.
	      ここでは, FreeBSD システムのメインのソースツリー全体
	      を受け取るための設定例を紹介します.
	      輸出規制されている暗号化サポートの
	      コード以外のすべてを含む <literal>src-all</literal>
	      という単一の大きなコレクションがあります.
	      この例では私たちがアメリカ合衆国か
	      カナダにいるものと仮定します. その場合,
	      <literal>cvs-crypto</literal> という一つの付化的な
	      コレクションで暗号化コードを入手することができます.
	      <filename>supfile</filename>
	      を組み立てる最初のステップとして,
	      これらのコレクションを一行に一つづつ記述します:</para>

	    <programlisting>
src-all
cvs-crypto</programlisting>
	  </listitem>

	  <listitem>
	    <para>どのバージョンのものが欲しいのか?
              <anchor id="cvsup-config-vers"></para>

	    <para><application>CVSup</application> を使用すると,
	      かつて存在していたことのある, 事実上どのバージョンの
	      ソースでも受け取ることができます. これは cvsupd
	      サーバがすべてのバージョンを含む  CVS
	      リポジトリに基づいて動作することにより,
	      実現されています.
              <literal>tag=</literal> および
	      <option>date=</option> の value フィールドを使用して,
	      欲しいバージョンの 一つを指定します.</para>

	    <warning>
	      <para><literal>tag=</literal>
		のフィールドの指定は正確に行うように十分注意
		してください. いくつかのタグは特定のコレクションに
		対してのみ有効です.
		タグの綴りが違っていたり不適切なタグを指定すると,
		CVSupはユーザが消し
		たくないファイルまで削除してしまいます. 特に
		<literal>ports-*</literal> のコレクション に対しては
		<literal>tag=.</literal> <emphasis>だけ</emphasis>
		を指定するようにしてください.</para>
	    </warning>

	    <para><literal>tag=</literal>
	      フィールドはリポジトリ中のシンボリックタグを指定します.
	      tag には revision tag と branch tag の二種類があります.
	      revision tag は特定のリビジョンを指します. これは,
	      毎日同じ状態に保つことになります.  一方 branch tag は,
	      ある時点での開発分流の最新のリビジョンを指します.
	      branch tag
	      は特定のリビジョンを指定している訳ではないので,
	      今日と明日では
	      異なるリビジョンを参照することになるかもしれません.</para>

	    <para>以下はユーザが興味を持っていると思われる branch tag
	      です:</para>

	    <variablelist>
	      <varlistentry><term>tag=.</term>
		<listitem>
		  <para>メインの開発分流であり, FreeBSD-current
		    として知られています.</para>
		  <note>
		    <para>
		      注意: <literal>.</literal>
		      は句読点ではありません. tag の名称です.
		      このタグの指定は総ての
		      コレクションに対して有効です.</para>
		  </note>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_3</term>
		<listitem>
		  <para>FreeBSD-3.x 用の開発分流であり, FreeBSD-stable
		    として知られています.  このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_2</term>
		<listitem>
		  <para>FreeBSD-2.2.x 用の開発分流であり, 2.2-stable
		    として知られています.  このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_1_0</term>
		<listitem>
		  <para>FreeBSD-2.1.x 用の開発分流です.
		    この分流はほとんど利用されていません.
		    このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <para>以下はユーザが興味を持っていると思われる revision
	      tag です:</para>

	    <variablelist>
	      <varlistentry>

		<term>tag=RELENG_3_3_0_RELEASE</term>

		<listitem>
		  <para>FreeBSD-3.3.  このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>

              <term>tag=RELENG_3_2_0_RELEASE</term>
                      
                <listitem>
                  <para>FreeBSD-3.2. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
                </listitem>
              </varlistentry>
        
	      <varlistentry><term>tag=RELENG_3_1_0_RELEASE</term>
		<listitem>
		  <para>FreeBSD-3.1. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_3_0_0_RELEASE</term>
		<listitem>
		  <para>FreeBSD-3.0. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_2_8_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.2.8. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_2_7_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.2.7. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_2_6_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.2.6. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_2_5_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.2.5. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_2_2_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.2.2. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_2_1_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.2.1. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_2_0_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.2.0. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_1_7_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.1.7. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_1_6_1_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.1.6.1. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_1_6_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.1.6. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_1_5_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.1.5. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>

	      <varlistentry><term>tag=RELENG_2_1_0_RELEASE</term>
		<listitem>
		  <para>FreeBSD-2.1.0. このタグの指定は ports-*
		    のコレクションに対しては無効です.</para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <warning>
	      <para> tag
		名を示した通りにタイプされているか十分注意してく
		ださい. <application>CVSup</application> は tag
		名が正しいかどうかを見分けることはできません. tag
		が間違っていた場合,
		たまたまファイルがまったく存在しない正しい tag が
		指定されたものとして<application>CVSup</application>
		は動作します. その場合は, 現在あるソースが削
		除されるでしょう.</para>
	    </warning>

	    <para>branch tag を指定した際には,
	      通常はその開発分流の最新バージョンの
	      ファイルを受け取ります.
	      いくらか前のバージョンを受け取りたい場合は,
	      <option>date=</option> の value
	      フィールドを使って日付を指定することで,
	      これを実現することが できます. &man.cvsup.1;
	      のマニュアルページで,
	      その方法を説明しています.</para>

	    <para>例として, FreeBSD-current を受け取りたいとします.
	      次の行を <filename>supfile</filename>
	      の始めに追加します:</para>

	    <programlisting>
*default tag=.</programlisting>

	    <para><literal>tag=</literal> フィールドも
	      <literal>date=</literal>
	      フィールドも指定しなかった場合に
	      動き出す重要な特殊なケースがあります. そのケースでは,
	      特定のバージョンの ファイルを受け取るのではなく,
	      サーバの CVS リポジトリから実際の RCS
	      ファイルを直接受け取ります.
	      一般的に開発者はこの処理のモードが 好きなようです.
	      彼らのシステム上にリポジトリそのものの
	      コピーを維持することで,
	      リビジョン履歴を閲覧し過去のバージョンの
	      ファイルを検査できるようになります.  しかし,
	      これには大きなディスクスペースが必要になります.</para>
	  </listitem>

	  <listitem>
	    <para>どこから入手したいのか?
              <anchor id="cvsup-config-where"></para>

	    <para>更新情報をどこから入手するかを
	      <command>cvsup</command> に伝えるために
	      <literal>host=</literal>  フィールドを使用します.
              <link linkend="mirrors-cvsup">CVSup ミラーサイト</link>
	      のどこからでも入手できますが,
	      ネット上での最寄りのサイトを選ぶべきでしょう.
	      この例では, 仮想上の FreeBSD 配布サイト
              <hostid role="fqdn">cvsup666.FreeBSD.org</hostid>
	      を使用します:</para>

	    <programlisting>
*default host=cvsup666.FreeBSD.org</programlisting>

	    <para>CVSup を実行する前にホスト名を
	      実在のものに変更する必要があります. どのように
	      <command>cvsup</command> を実行しても, この設定は
	      <option>-h <replaceable> hostname</replaceable></option>
	      を
	      使用してコマンドラインで変更することができます.</para>
	  </listitem>

	  <listitem>
	    <para>自分のマシンのどこに置きたいのか?
              <anchor id="cvsup-config-dest"></para>

	    <para><literal>prefix=</literal> フィールドは,
	      <command>cvsup</command>
	      に受け取ったファイルをどこに置くかを 伝えます.
	      この例では, ソースファイルを直接メインのソースツリー
	      <filename>/usr/src</filename> に置きます.
	      <filename>src</filename>
	      ディレクトリはすでにファイルを受け取るために
	      選択したコレクションで暗黙に指定しているので,
	      これは正しい仕様となります:</para>

	    <programlisting>
*default prefix=/usr</programlisting>
	  </listitem>

	  <listitem>
	    <para>どこに status ファイルを置きたいのか?
              <anchor id="cvsup-config-status"></para>

	    <para>cvsup クライアントは &ldquo;base&rdquo;
	      ディレクトリと呼ばれる場所に, ある status
	      ファイルを維持しています.
	      すでに受け取った更新情報を追従し続けることで,
	      これらのファイルは <application>CVSup</application>
	      がより効果的に動作することを支援します. 標準の base
	      ディレクトリ <filename>/usr/local/etc/cvsup</filename>
	      を使用します:</para>

	    <programlisting>
*default base=/usr/local/etc/cvsup</programlisting>

	    <para><filename>supfile</filename> に指定がない場合は,
	      この設定をデフォルトで使用しますので,
	      実際には上の行は必要ありません.</para>

	    <para>base
	      ディレクトリが存在しない場合は作成しておきましょう. base
	      ディレクトリが存在しない場合, <command>cvsup</command>
	      クライアントは実行を拒否します.</para>
	  </listitem>

	  <listitem>
	    <para>その他もろもろの <filename>supfile</filename>
	      の設定:</para>

	    <para>通常 <filename>supfile</filename>
	      に入れておくべき行がもう一つあります:</para>

	    <programlisting>
*default release=cvs delete use-rel-suffix compress</programlisting>

	    <para><literal>release=cvs</literal> は, サーバがメインの
	      FreeBSD CVS リポジトリから
	      その情報を取得するように指示します.
	      ほとんどの場合はこのようにしておきますが,
	      ここでの説明の範疇をこえるような
	      状況では他の指定をすることも可能です.</para>

	    <para><literal>delete</literal> は
	      <application>CVSup</application>
	      にファイルを削除することを許可します.
	      <application>CVSup</application> が
	      ソースツリーを完全に最新の状態に
	      保てるようにするためには, これは常に
	      指定しておくべきでしょう.
	      <application>CVSup</application> は,
	      これらの責任範囲のファイルだけを 慎重に削除します.
	      たまたま存在する他の余分なファイルについては,
	      まったく手をつけずに残しておきます.</para>

	    <para><literal>use-rel-suffix</literal> は ...
	      神秘的なものです. これについて本当に知りたい人は,
		&man.cvsup.1; のマニュアルページをご覧ください.
	      でなければ, 何も考えずに指定してみてください.</para>

	    <para><literal>compress</literal> は通信チャネルで gzip
	      形式の圧縮の使用を有効にします.
	      ご使用のネットワーク接続が T1 speed 以上である場合,
	      この圧縮を使用しない方がよいかもしれません.
	      そうでない場合は十分に役に立ちます.</para>
	  </listitem>

	  <listitem>
	    <para><filename>supfile</filename> の例のまとめ:</para>

	    <para>以下は <filename>supfile</filename> の例の全体です:</para>

	    <programlisting>
*default tag=.
*default host=cvsup666.FreeBSD.org
*default prefix=/usr
*default base=/usr/local/etc/cvsup
*default release=cvs delete use-rel-suffix compress

src-all
cvs-crypto</programlisting>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3>
	<title><application>CVSup</application> の実行</title>

	<para>さて, 更新の準備ができました.
	  これを実行するコマンドラインは実に簡単です:</para>

	<screen>&prompt.root; <userinput>cvsup <replaceable>supfile</replaceable></userinput></screen>

	<para>もちろん, ここでの
	  <filename><replaceable>supfile</replaceable></filename>
	  は作成したばかりの supfile のファイル名です. X11
	  環境で実行するものと仮定して, <command>cvsup</command> は
	  通常の操作に必要なボタンを持つ GUI ウィンドウを表示します.
	  &ldquo;go&rdquo; ボタンを押して,
	  実行を監視してください.</para>

	<para>この例では実際の <filename>/usr/src</filename>
	  ツリーを更新しているので, <command>cvsup</command>
	  にファイルを更新するのに必要なパーミッションを与えるために,
	  ユーザ <username>root</username> で実行する必要があります.
	  コンフィグレーションファイルを作ったばかりで,
	  しかも以前にこのプログラムを実行したことがないので,
	  神経質になるのは無理もない話だと思います.
	  大切なファイルに触らずに試しに実行する簡単な方法があります.
	  どこか適当な場所に空のディレクトリを作成して,
	  コマンドラインの引数で指定するだけです:</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/dest</userinput>
&prompt.root; <userinput>cvsup supfile /var/tmp/dest</userinput></screen>

	<para>指定したディレクトリは, すべての更新されるファイルの
	  更新先ディレクトリとして使用します.
	  <application>CVSup</application> は
	  <filename>/usr/src</filename> の下のファイルを検査しますが,
	  変更や削除はまったくおこないません. かわりに
	  <filename>/var/tmp/dest/usr/src</filename>
	  に更新されたすべてのファイルが置かれるようになります.
	  この方法で実行した場合は, <application>CVSup</application>
	  は base ディレクトリの status
	  ファイルを更新せずにそのままにします.
	  これらのファイルの新しいバージョンは指定されたディレクトリ
	  に書き込まれます. <filename>/usr/src</filename>
	  の読み取り許可がある限り, このような試し実行のためにユーザ
	  root になる必要はありません.</para>

	<para>X11 を利用していないとか単に GUI が気に入らない場合は,
	  cvsup 起動時にコマンドラインに
	  二つほどオプションを追加する必要があります:</para>

	<screen>&prompt.root; <userinput>cvsup -g -L 2 supfile</userinput></screen>

	<para><option>-g</option> オプションは cvsup に GUI
	  を使用しないように伝えます. X11
	  を利用していない場合には自動的に指定されますが,
	  そうでない場合は 明示的に指定します.</para>

	<para><option>-L 2</option> オプションは cvsup
	  にファイル更新中の詳細情報をプリントアウト
	  するように伝えます. 冗長性には <option>-L 0</option> から
	  <option>-L 2</option> までの三つのレベル があります.
	  デフォルトは 0 であり, エラーメッセージ以外はまったく出力
	  しません.</para>

	<para>たくさんの他のオプション変数があります.
	  それらの簡単な一覧は <command>cvsup -H</command>
	  で表示されます.
	  より詳しい説明はマニュアルページをご覧ください.</para>

	<para>動作している更新の方法に満足したら, &man.cron.8;
	  を使って cvsup を定期的に
	  実行させる準備をすることができます. cron から起動する際には,
	  明示的に cvsup が GUI
	  を使わないようにする必要があります.</para>
      </sect3>

      <sect3 id="cvsup-collec">
	<title><application>CVSup</application> ファイルコレクション</title>

	<para><application>CVSup</application>
	  経由で入手できるファイルコレクションは
	  階層的に組織化されています.
	  いくつか大きなコレクションがあり,
	  それらは小さなサブコレクションに 分割されています.
	  大きなコレクションは, そのサブコレクション毎に
	  受信することと同じことになります.
	  下の一覧ではコレクション間の階層関係を
	  字下げして表現します.</para>

	<para>最も一般的に使用するコレクションは
	  <literal>src-all</literal>, <literal>cvs-crypto</literal>,
	  そして <literal>ports-all</literal> です.
	  他のコレクションは特別な目的を持つ人達だけが使用しており,
	  ミラーサイトはそれらのすべてを
	  持っていないかもしれません.</para>

	<variablelist>
	  <varlistentry><term><literal>cvs-all release=cvs</literal></term>
	    <listitem>
	      <para>メインの FreeBSD CVS リポジトリであり,
		輸出規制された暗号化コードは含まれていません.</para>

	      <variablelist>
		<varlistentry>
		  <term><literal>distrib release=cvs</literal></term>
		  <listitem>
		    <para>FreeBSD
		      の配布とミラーに関連するファイルです.</para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term><literal>doc-all release=cvs</literal></term>
		  <listitem>
		    <para>FreeBSD
		      ハンドブックおよびその他のドキュメントの
		      ソースです.</para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term><literal>ports-all release=cvs</literal></term>
		  <listitem>
		    <para>FreeBSD の ports コレクションです.</para>

		    <variablelist>
		      <varlistentry>
			<term><literal>ports-archivers release=cvs
			  </literal></term>
			<listitem>
			  <para>アーカイビングのツール.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-astro release=cvs</literal></term>
			<listitem>
			  <para>天文学関連の ports.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-audio release=cvs</literal></term>
			<listitem>
			  <para>サウンドサポート.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-base release=cvs</literal></term>
			<listitem>
			  <para><filename>/usr/ports</filename>
			    のトップにあるその他のファイル.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-benchmarks release=cvs
			  </literal></term>
			<listitem>
			  <para>ベンチマークプログラム.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-biology release=cvs
			  </literal></term>
			<listitem>
			  <para>植物学関連のプログラム.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-cad release=cvs</literal></term>
			<listitem>
			  <para>CAD ツール.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-chinese release=cvs
			  </literal></term>
			<listitem>
			  <para>中国語サポート.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-comms release=cvs</literal></term>
			<listitem>
			  <para>通信ソフトウェア.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-converters release=cvs
			  </literal></term>
			<listitem>
			  <para>文字コードコンバータ.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-databases release=cvs
			  </literal></term>
			<listitem>
			  <para>データベース.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-deskutils release=cvs
			  </literal></term>
			<listitem>
			  <para>コンピュータが発明される前に
			    卓上で使われていたものたち.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-devel release=cvs</literal></term>
			<listitem>
			  <para>開発ユーティリティ.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-editors release=cvs
			  </literal></term>
			<listitem>
			  <para>エディタ.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-emulators release=cvs
			  </literal></term>
			<listitem>
			  <para>他の OS のエミュレータ.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-ftp release=cvs
			  </literal></term>
			<listitem>
			  <para>FTP クライアントとサーバ.</para>
			</listitem>
		      </varlistentry>
		      
		      <varlistentry>
			<term><literal>ports-games release=cvs</literal></term>
			<listitem>
			  <para>ゲーム.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-german release=cvs
			  </literal></term>
			<listitem>
			  <para>ドイツ語サポート.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-graphics release=cvs
			  </literal></term>
			<listitem>
			  <para>グラフィックユーティリティ.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-irc
			    release=cvs</literal></term>
			
			<listitem>
			  <para>インターネットリレーチャット(IRC)用のユーティリティ</para>
			</listitem>
		      </varlistentry>
		      
		      <varlistentry>
			<term><literal>ports-japanese release=cvs
			  </literal></term>
			<listitem>
			  <para>日本語サポート.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-java
			    release=cvs</literal></term>
			
			<listitem>
			  <para>Java ユーティリティ</para>
			</listitem>
		      </varlistentry>
		      
		      <varlistentry>
			<term><literal>ports-korean release=cvs
			  </literal></term>
			<listitem>
			  <para>韓国語サポート.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-lang release=cvs</literal></term>
			<listitem>
			  <para>プログラミング言語.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-mail release=cvs</literal></term>
			<listitem>
			  <para>メールソフトウェア.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-math release=cvs</literal></term>
			<listitem>
			  <para>数値計算ソフトウェア.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-mbone release=cvs</literal></term>
			<listitem>
			  <para>MBone アプリケーション.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-misc release=cvs</literal></term>
			<listitem>
			  <para>色々なユーティリティ.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-net release=cvs</literal></term>
			<listitem>
			  <para>ネットワーキングソフトウェア.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-news release=cvs</literal></term>
			<listitem>
			  <para>USENET ニュースのソフトウェア.</para>
			</listitem>
		      </varlistentry>

                      <varlistentry>
                        <term><literal>ports-palm
                          release=cvs</literal></term>
                              
                        <listitem>
                          <para>3Com Palm(tm) シリーズ用ソフトウェア.</para>
                        </listitem>
                      </varlistentry>

		      <varlistentry>
			<term><literal>ports-print release=cvs</literal></term>
			<listitem>
			  <para>印刷ソフトウェア.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-russian release=cvs
			  </literal></term>
			<listitem>
			  <para>ロシア語サポート.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-security release=cvs
			  </literal></term>
			<listitem>
			  <para>セキュリティユーティリティ.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-shells release=cvs
			  </literal></term>
			<listitem>
			  <para>コマンドラインシェル.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-sysutils release=cvs
			  </literal></term>
			<listitem>
			  <para>システムユーティリティ.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-textproc release=cvs
			  </literal></term>
			<listitem>
			  <para>文書処理ユーティリティ
			    (デスクトップパブリッシングは含まない).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-vietnamese release=cvs
			  </literal></term>
			<listitem>
			  <para>ベトナム語サポート.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-www release=cvs</literal></term>
			<listitem>
			  <para>World Wide Web 関連のソフトウェア.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-x11 release=cvs</literal></term>
			<listitem>
			  <para>X window システムをサポートする ports.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-x11-clocks release=cvs
			  </literal></term>
			<listitem>
			  <para>X11 上で動作する時計の数々.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-x11-fm release=cvs
			  </literal></term>
			<listitem>
			  <para>X11 上で動作するファイラ.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-x11-fonts release=cvs
			  </literal></term>
			<listitem>
			  <para>X11 のフォントとフォントユーティリティ.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-x11-toolkits release=cvs
			  </literal></term>
			<listitem>
			  <para>X11 のツールキット.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>ports-x11-servers</literal></term>
			
			<listitem>
			  <para>各種 X11 サーバ</para>
			</listitem>
		      </varlistentry>
		      
		      <varlistentry>
			<term><literal>ports-x11-wm release=cvs
			  </literal></term>
			<listitem>
			  <para>X11 のウィンドウマネージャ.</para>
			</listitem>
		      </varlistentry>
		    </variablelist>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term><literal>src-all release=cvs</literal></term>
		  <listitem>
		    <para>メインの FreeBSD ソース群であり,
		      輸出規制された暗号化コードは
		      含まれていません.</para>

		    <variablelist>
		      <varlistentry>
			<term><literal>src-base release=cvs</literal></term>
			<listitem>
			  <para><filename>/usr/src</filename>
			    のトップにあるその他のファイル.</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-bin release=cvs</literal></term>
			<listitem>
			  <para>シングルユーザモードで必要な
			    ユーザユーティリティ
			    (<filename>/usr/src/bin</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-contrib release=cvs</literal></term>
			<listitem>
			  <para>FreeBSD プロジェクト外部からの
			    ユーティリティおよびライブラリ,
			    比較的無修正
			    (<filename>/usr/src/contrib</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-etc release=cvs</literal></term>
			<listitem>
			  <para>システムコンフィグレーションファイル
			    (<filename>/usr/src/etc</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-games release=cvs</literal></term>
			<listitem>
			  <para>ゲーム
			    (<filename>/usr/src/games</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-gnu release=cvs</literal></term>
			<listitem>
			  <para>GNU Public License
			    下にあるユーティリティ
			    (<filename>/usr/src/gnu</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-include release=cvs</literal></term>
			<listitem>
			  <para>ヘッダファイル
			    (<filename>/usr/src/include</filename>).</para>
			</listitem>
		      </varlistentry>
		      
		      <varlistentry>
			<term><literal>src-kerberos5
			    release=cvs</literal></term>
				  
			<listitem>
			  <para>Kerberos5 セキュリティパッケージ
			    (<filename>/usr/src/kerberos5</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-kerberosIV release=cvs
			  </literal></term>
			<listitem>
			  <para>KerberosIV セキュリティパッケージ
			    (<filename>/usr/src/kerberosIV</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-lib release=cvs</literal></term>
			<listitem>
			  <para>ライブラリ
			    (<filename>/usr/src/lib</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-libexec release=cvs</literal></term>
			<listitem>
			  <para>システムプログラムであり,
			    通常は他のプログラムから実行される
			    (<filename>/usr/src/libexec</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-release release=cvs</literal></term>
			<listitem>
			  <para>FreeBSD の release
			    を構築するために必要なファイル
			    (<filename>/usr/src/release</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-sbin release=cvs</literal></term>
			<listitem>
			  <para>シングルユーザモード用の
			    システムユーティリティ
			    (<filename>/usr/src/sbin</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-share release=cvs</literal></term>
			<listitem>
			  <para>多様なシステム間で共有可能なファイル
			    (<filename>/usr/src/share</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-sys release=cvs</literal></term>
			<listitem>
			  <para>カーネル
			    (<filename>/usr/src/sys</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-tools release=cvs</literal></term>
			<listitem>
			  <para>FreeBSD の保守用の色々なツール
			    (<filename>/usr/src/tools</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-usrbin release=cvs</literal></term>
			<listitem>
			  <para>ユーザユーティリティ
			    (<filename>/usr/src/usr.bin</filename>).</para>
			</listitem>
		      </varlistentry>

		      <varlistentry>
			<term><literal>src-usrsbin release=cvs</literal></term>
			<listitem>
			  <para>システムユーティリティ
			    (<filename>/usr/src/usr.sbin</filename>).</para>
			</listitem>
		      </varlistentry>
		    </variablelist>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term><literal>www release=cvs</literal></term>
		  <listitem>
		    <para>World Wide Web のデータ用のソースです.</para>
		  </listitem>
		</varlistentry>
	      </variablelist>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term><literal>cvs-crypto release=cvs</literal></term>
	    <listitem>
	      <para>輸出規制された暗号化コードです.</para>

	      <variablelist>
		<varlistentry>
		  <term><literal>src-crypto release=cvs</literal></term>
		  <listitem>
		    <para>輸出規制された FreeBSD
		      プロジェクト外部からのユーティリティおよび
		      ライブラリ, 比較的無修正
		      (<filename>/usr/src/crypto</filename>).</para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term><literal>src-eBones release=cvs</literal></term>
		  <listitem>
		    <para>Kerberos および DES
		      (<filename>/usr/src/eBones</filename>).
                      FreeBSD の現在のリリースでは使われていません.</para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term><literal>src-secure release=cvs</literal></term>
		  <listitem>
		    <para>DES (<filename>/usr/src/secure</filename>).</para>
		  </listitem>
		</varlistentry>
		
		<varlistentry>
		  <term><literal>src-sys-crypto release=cvs</literal></term>
			  
		  <listitem>
		    <para>カーネルの暗号化コード
		    (<filename>/usr/src/sys/crypto</filename>).</para>
		  </listitem>
		</varlistentry>
	      </variablelist>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term><literal>distrib release=self</literal></term>
	    <listitem>
	      <para>CVSup
		サーバ自身のコンフィグレーションファイルです. CVSup
		ミラーサイトが使用します.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>gnats release=current</literal></term>
	    <listitem>
	      <para>GNATS バグトラッキングデータベースです.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>mail-archive release=current</literal></term>
	    <listitem>
	      <para>FreeBSD 関連メーリングリストのアーカイブ.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term><literal>www release=current</literal></term>
	    <listitem>
	      <para>インストールされた World Wide Web のデータです.
		WWW ミラーサイトが使用します.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>詳細について</title>

	<para>CVSup の FAQ や CVSup に関するその他の情報については
	  <ulink url="http://www.polstra.com/projects/freeware/CVSup/">
	    The CVSup Home Page</ulink> をご覧ください.</para>

	<para><application>CVSup</application> のほとんどの FreeBSD
	  関連の議論は &a.hackers; でおこなわれています.
	  ソフトウェアの新しいバージョンは &a.announce; で
	  アナウンスされます.</para>

	<para>質問とバグ報告はプログラムの作者,
	  <email>cvsup-bugs@polstra.com</email> へ
	  送ってください.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="makeworld">
    <title><command>make world</command> によるシステムの再構築</title>

    <para><emphasis>寄稿: &a.nik;.</emphasis></para>

    <para>FreeBSD のどれか特定のバージョン (<literal>stable</literal>,
      <literal>current</literal> など)
      について, ローカルのソースツリーを同期させたら,
      そのソースツリーを使ってシステムを
      再構築しなければなりません.</para>

    <warning>
      <title>バックアップを作成する</title>
      
      <para>システムを再構築する<emphasis>前に</emphasis>バックアップを
        作成することの重要性は, いくら強調してもし過ぎると言うことはありません.
        システム全体の再構築とは
        (以降に書かれた手順に従っている限り)難しい作業ではありませんが,
        どんなに注意していたとしても, <!-- hrs:2000/01/12 inevitably -->
        あなた自身, あるいはソースツリーで作業している他の人達に手違いがあった時には,
        システムが起動しなくなってしまう状態になることがあるのです.
      </para>

      <para>まず, バックアップがきちんと作成されていることを確認して下さい.
        そして, fixit フロッピーを用意して下さい. 私は今までに,
        一度もバックアップや fixit フロッピーのお世話になったことはありませんし,
        これからもそうなるようなことはないと思っていますが,
        どういう場合であっても用意しておいて損はないでしょう.
      </para>
    </warning>

    <warning>
      <title>メーリングリストに参加する</title>
      
      <para>もともと, -STABLE と -CURRENT のコードブランチは,
        <emphasis>開発中のもの</emphasis>です.
        FreeBSD の作業に貢献してくださっている人達も人間ですから,
        時にはミスをすることだってあるでしょう.  
      </para>

      <para>そのような間違いは, 単に警告を示す見慣れない
        診断メッセージをシステムが,表示するような,
        全く害のないものであることもあれば, システムを起動できなくしたり,
        ファイルシステムを破壊してしまうような,
        恐ろしい結果を招くものかも知れません.
      </para>

      <para>万が一, このような問題が生じた場合,
        問題の詳細と, どのようなシステムが影響を受けるかについて書かれた
        <quote>注意(heads up)</quote>の記事が
        適切なメーリングリストに投稿され, そして, その問題が解決されると, 
        <quote>問題解決(all clear)</quote>のアナウンス記事が同様に
        投稿されます.
      </para>

      <para>-STABLE や -CURRENT ブランチを試したり, それらに
        追随していくときに
        <email>FreeBSD-stable@FreeBSD.ORG</email> や
	<email>FreeBSD-current@FreeBSD.ORG</email>
        を読まないというのは, 自ら災難を招くことになるでしょう.
      </para>

      <para><emphasis>訳注:</emphasis>
      これらのメーリングリストは英語でやりとりされているため,
      日本語での投稿は歓迎されません. 英語でのやりとりができない人は,
      <ulink url="http://www.jp.FreeBSD.org">FreeBSD 友の会</ulink>
      の運営しているメーリングリストをあたってみるのがいいでしょう.
      </para>

    </warning>

    <sect2>
      <title><filename>/etc/make.conf</filename> の確認</title>
      
      <para>まず, <filename>/etc/make.conf</filename> を調べて下さい.
        ここには, ソースを再構築する際に使用される <command/make/
        コマンドのデフォルト定義が書かれています.
        それらは <command/make/ を使う場合, 常に利用されるものですので,
        あなたのシステムに合うようにセットされていかどうか, ここで
        確認しておくと良いでしょう.
      </para>
    
      <para>最初の状態では, すべてがコメントアウトされています.
        必要だと思う項目のコメントをはずして下さい.
        (開発者でない)標準的なユーザならおそらく,
        CFLAGS と NOPROFILE のコメントをはずすことを考えると思います.
      </para>

      <note>
	<title/FreeBSD 2.1.7 以前の場合/
	
	<para>もし, 浮動小数点演算ユニット(386DX, 486DX, Pentium と,
          それより上のクラスのマシン)がある場合には, HAVE_FPU
          の行のコメントをはずすことができます.
        </para>
        <!-- hrs:2000/01/13 386DX doesn't have FPU. -->
        
	<para>この定義は, FreeBSD 2.2.2 以降で廃止されました.
        </para>
      </note>
      
      <para>他の定義 (COPTFLAGS, NOPORTDOCS など) の定義行についても,
        コメントを外す必要があるかどうか調べておきましょう.
      </para>
    </sect2>
    
  <sect2>
      <title><filename>/etc/group</filename> の更新</title>
      
      <para>
        <filename>/etc</filename> ディレクトリには,
        システム起動時に実行されるスクリプトだけでなく,
        あなたのシステムの設定に関連する情報の大部分が
        含まれています. そのディレクトリに含まれる
        スクリプトは, FreeBSD のバージョンによって多少異なります.  
      </para>

      <para>
        また, 設定ファイルのなかには, 稼働中のシステムが日々利用している
        ものもあります. 実際には, <filename>/etc/group</filename>
        などがそれに該当します.
      </para>

      <para>
        <quote>make world</quote> のインストールの段階では,
        特定のユーザ名, あるいはグループが存在していることを
        要求する場面があります. システムのアップグレードを行なう際には,
        それらのグループが削除, あるいは変更されて存在していない可能性が
        考えられますが, そういった場合, システムのアップグレードを
        行なっている間に, 問題が発生する原因になります.
      </para>

      <para>この種の例でもっとも記憶に新しいのは,
        <quote/ppp/ グループ(後に <quote/network/ に変更されました)が
        追加された時です. 
        <filename>ppp</filename> サブシステムがインストールされる時,
        そのサブシステムが利用する <quote/ppp/ グループが存在しなかったために,
        それらのインストールに失敗してしまったのです.
      </para>

      <para>解決方法は, <filename>/usr/src/etc/group</filename> を調べ,
        自分のシステムのグループ名リストと比較することです.
        最新のファイルに含まれていて, あなたのファイルに含まれていない
        グループ名があれば, あなたのファイルにそのグループ名をコピーして下さい.
        同様に, 名前が異なるにも関わらず, 
        <filename>/etc/group</filename> と
        <filename>/usr/src/etc/group</filename> で同じ GID を持っているグループ名があれば,
        <filename>/etc/group</filename> に含まれる,
        該当するすべてのグループ名を変更しておかなければなりません.
      </para>

      <tip>
	<para>もし, あなたがもっと神経質な人なら, あなたが名前を変更したり,
          削除してしまったグループが所有しているファイルを,
          次のようにして調べることもできます.
        </para>
	
	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>
	
	<para>これは <replaceable>GID</replaceable>(グループ名もしくは数字で示されたグループ ID)で
          指定されたグループが所有するすべてのファイルを表示します.
        </para>
      </tip>
    </sect2>
    
    <sect2>
      <title/シングルユーザモードへの移行/
      
      <para>コンパイルは, シングルユーザモードで行なった方が良いでしょう.
        そうすることで多少速度が向上する, というちょっとした利点が
        あるだけでなく, システムの再インストールは重要なシステムファイル,
        標準コマンド, ライブラリ, インクルードファイルなどを操作します.
        稼働中のシステムに(特に他のユーザがログインしている時に)そのような
        変更を加えることは, トラブルを引き起こす原因となります.
      </para>

      <para>自信家の方は, このステップを省略しても構いません.</para>
      
      <note>
	<title>FreeBSD 2.2.5-RELEASE 以降の場合</title>
	
	<para>以下に詳しく述べられているように, 2.2.5-RELEASE 以降,
          ビルド(システムの構築)とインストールの行程を分離して行なうことが可能になりました.
          そのため, マルチユーザモードで新しいシステムの<emphasis>ビルド</emphasis>を行ない,
          その後, シングルユーザモードに移行してから
          インストールを行なうことができます.
        </para>
      </note>
      
      <para>稼働中のシステムでシングルユーザモードに移行するには,
        スーパユーザ(root)権限で次のコマンドを実行します.

	<screen>&prompt.root; <userinput/shutdown now/</screen>

      </para>
      
      <para>あるいはシステムを再起動し, ブートプロンプトから
	<option>-s</option> フラグを設定することで, シングルユーザモードで
        システムを起動させることができます. 起動後, シェルプロンプトから
        次のように実行して下さい.
      </para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>これはファイルシステムをチェックした後,
        <filename>/</filename> を読み書き可能にして再マウント,
        <filename>/etc/fstab</filename> に指定されている,
        それ以外の UFS ファイルシステムをすべてマウントしてから
        スワップを有効にします.
      </para>
    </sect2>
    
    <sect2>
      <title><filename>/usr/obj</filename> の削除</title>
      
      <para>システムが再構築される時, 構築されたものは(デフォルトで)
        <filename>/usr/obj</filename> 以下のディレクトリに格納され,
        そのディレクトリの下は <filename>/usr/src</filename> と同じ構造となります.
      </para>
      
      <para>このディレクトリをあらかじめ削除しておくことにより,
        <quote>make world</quote> の行程にかかる時間を短縮させ,
        依存問題に悩まされるようなトラブルを回避することができます.
      </para>

      <para><filename>/usr/obj</filename> 以下のファイルには,
        変更不可(immutable)フラグ(詳細は
        <command>chflags(1)</command> 参照)がセットされているものがあります.
        そのため, まず最初にそのフラグを変更しなければなりません.
      </para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2>
      <title/ソースの再構築と新しいシステムのインストール/
      
      <sect3>
	<title>全バージョンに共通すること</title>
	
	<para>まず, カレントディレクトリを <filename>/usr/src</filename> に
          変更しなければなりません. 次のように実行して下さい.
	
	  <screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

          (もちろん, ソースコードが他のディレクトリにある場合には,
          <filename>/usr/src</filename> ではなく,
           ソースコードのあるディレクトリに移動して下さい).
        </para>
      
	<para>
          make world を行なうには, &man.make.1; コマンドを使用します.  
          このコマンドは, <filename>Makefile</filename> というファイルから, 
          FreeBSD を構成するプログラムの再構築方法や, 
          どういう順番でそれらを構築すべきかといったような
          指示を読み込みます.  
        </para>
	
	<para>
          コマンドラインの一般的な書式は, 次のとおりです.  
        </para>

	<screen>&prompt.root; <userinput>make <option>-<replaceable/x/</option> <option>-D<replaceable>VARIABLE</replaceable></option> <replaceable>target</replaceable></userinput></screen>

	<para>
          この例では, <option>-<replaceable>x</replaceable></option> が
          &man.make.1; に渡されるオプションになります.  
          どのようなオプションが利用できるかについては, マニュアルページを
          参照して下さい.  
        </para>

	<para>
          <option>-D<replaceable>VARIABLE</replaceable></option> は, 
          <filename>Makefile</filename> に渡される変数であり, 
          この変数は <filename>Makefile</filename> の動作をコントロールします.  
          また, <filename>/etc/make.conf</filename> で設定される変数も
          同様です.  これは変数を設定するもう一つの方法として用意されています.  
        </para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE=true <replaceable>target</replaceable></userinput></screen>
      
	<para>
          は, プロファイル版のライブラリを構築しないことを指定する
          もう一つの記法で, <filename>/etc/make.conf</filename> 中の
	
	  <programlisting>NOPROFILE=    true
#    Avoid compiling profiled libraries</programlisting>

          の行に対応します.  
        </para>

	<para>
          <replaceable>target</replaceable> は, &man.make.1; に
          どのように動作するのかを指示するためのものです.  
          各々の <filename>Makefile</filename> には, 数多くの異なる
          <quote>ターゲット(target)</quote> が定義されていて, 
          指定されたターゲットによって, 動作が決まります.  
        </para>

	<para>
          <filename>Makefile</filename> に書かれているターゲットには, 
          あなたが指定しても意味を持たないものも含まれます.  
          これらは, システムの再構築に必要な段階を, 多くの
          さらに細かい段階に分割するため, 構築の過程で利用されるものです.  
        </para>

	<para>
          大抵の場合, &man.make.1; にパラメータを指定する必要はないでしょうから, 
          コマンドラインは次のようなものになるでしょう.  
        </para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>
      </sect3>

      <sect3>
	<title>出力の保存</title>
	
	<para>
          実行される &man.make.1; からの出力は, ファイルに保存すると良いでしょう.  
          もし, 何か障害が発生した場合, エラーメッセージのコピーに加え, 
          どの時点でそれが起こったのか, 完全なリストが手元に残ります.  
          <!-- hrs:2000/02/14 (for ja-translators)
               had got to == reach, but translated "where the problem happened" -->
          何が悪かったのか, あなた自身がそれから理解することはできないかも
          知れません.  しかし, FreeBSD メーリングリストに投稿して, 
          誰か他の人からの助言を得るために利用することができます.  
        </para>

	<para>
          ファイルに保存する最も簡単な方法は, &man.script.1; コマンドを
          使い, 引数に出力を保存したいファイル名を指定することです.  
          これを make world の直前に行ない, 再構築が終了してから
          <userinput>exit</userinput> と入力すると, 出力を保存することができます.            
        </para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out	 
&prompt.root; <userinput>make world</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>	  
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>
          出力を保存する場合, <filename>/tmp</filename> ディレクトリの中に
          保存しては<emphasis>いけません</emphasis>.  
          このディレクトリは, 次の再起動で削除されてしまう可能性があります.  
          出力の保存には, (上の例のように)<filename>/var/tmp</filename>や
          <username>root</username> のホームディレクトリが適しています.  
        </para>
      </sect3>
      
      <sect3>
	<title>FreeBSD-2.2.2 と, それ以前のバージョン</title>
	
	<para>
          <filename>/usr/src/Makefile</filename> には, 
          システム全体を再構築しインストールを行なう
          <maketarget>world</maketarget> ターゲットが含まれています.  
        </para>
	
	<para>
          それを, 次のように使って下さい.  
        </para>
      
	<screen>&prompt.root; <userinput>make world</userinput></screen>
      </sect3>
      
      <sect3>
	<title>FreeBSD-2.2.5 と, それ以降のバージョン</title>
	
	<para>
          FreeBSD-2.2.5 から(実際には, -CURRENT ブランチで最初に作成され, 
          2.2.2 と 2.2.5 の間の時点で -STABLE に導入されたのですが), 
          <maketarget>world</maketarget> ターゲットは
          <maketarget>buildworld</maketarget> と
	  <maketarget>installworld</maketarget> の二つに分割されました.  
        </para>

	<para>
          その名前が示すように, <maketarget>buildworld</maketarget> は
          <filename>/usr/obj</filename> 以下に新しい完全な
          ディレクトリツリーを構築し, 
          <maketarget>installworld</maketarget> は, そのツリーを
          現在のマシンにインストールします.  
        </para>

	<para>
          これは, 二つの理由から非常に有用です.  
          まず第一に, 稼働中のシステムに全く影響を与えることなく, 
          安全にシステムの構築作業を行えることです.  
          構築作業は<quote>何にも依存せず独立して行なわれる</quote>ため, 
          <!-- hrs:2000/02/14: needs good phrase that means "self hosted" -->
          マルチユーザモードで稼働中のシステムでも, 何一つ
          悪影響を与えずに <maketarget>buildworld</maketarget> を
          実行することができます.  
          ただし, <maketarget>installworld</maketarget> は
          シングルユーザモードで行なうことをおすすめします.  
        </para>

	<para>
          第二に, NFS マウントを利用することで, 
          ネットワーク上の複数のマシンをアップグレードすることが
          可能な点があげられます.  例えば三台のマシン, マシン A, マシン B, 
          マシン C をアップグレードしたい場合には, まず
          マシン A で <command>make buildworld</command> と
          <command>make installworld</command> を実行します.  
          それから, マシン B とマシン C で <filename>/usr/src</filename> を
          NFS マウントし, <command>make installworld</command> とすることで
          構築済みのシステムを各マシンにインストールすることができるのです.  
        </para>

	<para>
          一方, <maketarget>world</maketarget> ターゲットも残されていますので, 
          FreeBSD-2.2.2 の場合として示されている方法と同じように, 
          このターゲットを利用することもできます.  
          <command>make world</command> は, 
          <command>make buildworld</command> に続けて
          <command>make installworld</command> を実行します.  
        </para>

	<note>
	  <para>
            <command>make buildworld</command> と
            <command>make installworld</command> のコマンドを分けて実行する場合には, 
            それぞれ同じ引数を &man.make.1; に渡さなければなりません.  
          </para>

	  <para>
            次のように実行したとすると, 

	    <screen>&prompt.root; <userinput>make -DNOPROFILE=true buildworld</userinput></screen>

            構築されたシステムは次のようにしてインストールする必要があります.  

	    <screen>&prompt.root; <userinput>make -DNOPROFILE=true installworld</userinput></screen>

            そうしないと, <command>make buildworld</command> の段階で
            構築されていない, プロファイル版ライブラリのインストールを
            試みることになります.  
            (訳注: もちろん, それには失敗するのでエラーが発生します.  )
          </para>
	</note>
      </sect3>
      
      <sect3>
	<title>-CURRENT と, それ以降</title>
	
	<para>
          もし, -CURRENT を追跡しているなら, <command>make</command> コマンドに
          <option>-j</option> オプションを渡すことができます.  
          このオプションにより, <command>make</command> は
          同時に複数のプロセスを生成するようになります.  
        </para>

	<para>
          これは, 実際に複数の CPU を備えているマシンに対して
          非常に有効に働きます.  また, コンパイルプロセスの大部分は
          CPU の処理ではなく入出力の処理に費やされるため, 
          単一の CPU を持つマシンでも同じように有効です.  
        </para>

	<para>単一の CPU を持つ典型的なマシンでは, 次のように実行します.  </para>
	  
	  <screen>&prompt.root; <userinput>make -j4 <replaceable>target</replaceable></userinput></screen>

	<para>
          この時 &man.make.1; は, 最大 4 個までのプロセスを同時に実行します.  
          メーリングリストに投稿された経験的な報告によると, 
          4 個という指定が最も良いパフォーマンスを示すようです.  
        </para>

	<para>
          もし, 複数の CPU を備えたマシンで SMP 設定が行なわれたカーネルを
          利用しているなら, 6 から 10 の間の値を設定し, 速度がどれくらい
          向上するか確認してみて下さい.  
        </para>
	
	<para>
          注意して欲しいのですが, (この原稿を書いている時点では)この機能はまだ
          実験段階です.  そのため, ソースツリーへ変更が加えられたときに
          これが正常に機能しなくなる可能性があります.  
          もし, このオプションを用いてシステムの構築に失敗した場合には, 
          障害を報告する前に, もう一度オプションを付けずに試してみて下さい.  
        </para>
      </sect3>
      
      <sect3
	<title>システムの構築にかかる時間</title>

	<para>
          すべてが順調に進んでいたとしても, 
          一時間半から丸一日程度の時間がかかります.  
        </para>
	
	<para>
          一般的に言って, 200MHz の P6(訳注: Intel PentiumPro のこと) で
          32MB 以上のメモリを搭載し, 標準的な SCSI ディスクドライブを利用していた
          とすると, <command>make world</command> の完了までに
          およそ一時間半の時間がかかります.  この構成よりも性能が低ければ, 
          それよりもさらに時間がかかるでしょう.  
        </para>

      </sect3>
    </sect2>
    
    <sect2>
      <title><filename>/etc</filename> の更新</title>
      
      <para>
        システムの再構築は, いくつかのディレクトリ (
	特に, <filename>/etc</filename>, や <filename>/var</filename> や
	<filename>/usr</filename>) において,
        新規に導入されたり, 変更された設定ファイルによる
        ファイルの更新は行なわれません.  
        これは, あなた自身の手や目, そして適切な
        &man.diff.1; の使用をによって行なわなければなりません.  
      </para>
    
      <para>
        単にファイルを
	<filename>/usr/src/etc</filename> から <filename>/etc</filename> に
	コピーしただけでは正常に動作させることはできません.  
        これらのファイルには, <quote>インストールという
          手順を踏まなければならないもの</quote>が含まれています.  
        <filename>/usr/src/etc</filename> ディレクトリは
        <filename>/etc</filename>
        ディレクトリにそのまま置き換えられるような
        コピーでは<emphasis>ない</emphasis>からです.  
        また, <filename>/etc</filename> にあるべきファイルのうちで
	<filename>/usr/src/etc</filename> にないものもあります.  
      </para>
    
      <para>
        一番簡単な方法は, ファイルを新しいディレクトリにインストールしてから, 
        以前のものと異なっている部分を調べて更新作業を行なうことです.  
      </para>
    
      <warning>
	<title>既存の <filename>/etc</filename> をバックアップする</title>
	
	<para>
          理論的に考えて, このディレクトリが自動的に
          処理されることはありませんが, 念には念を入れておいて
          損はありません.  たとえば以下のようにして, 
          既存の <filename>/etc</filename> ディレクトリを
          どこか安全な場所にコピーしておきましょう.
        </para>
	
	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>
	
	<para>
          <option>-R</option> は再帰的なコピーを行ない, 
          <option>-p</option> はファイルの更新時間や所有者などを保存します.
        </para>
      </warning>
      
      <para>
        また, 新しい <filename>/etc</filename> やその他のファイルを
        インストールするための, 仮のディレクトリを作っておく必要があります.
	私はいつもこの仮のディレクトリを
	<filename>/var/tmp/root</filename> に置くことにしています.  
        同様に, 必要なサブディレクトリもこの下に置きます.</para>
	
      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>
	
      <para>
        上の例は, 必要なディレクトリ構造をつくり, ファイルをインストールします.
	<filename>/var/tmp/root</filename> 以下に作られる, 
        たくさんの空のディレクトリは削除する必要があります.  
	一番簡単なやり方は, 次のとおりです.  </para>
      
      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d .  -type d | /usr/bin/perl -lne \
    'opendir(D,$_);@f=readdir(D);rmdir if $#f == 1;closedir(D);'</userinput></screen>
      
      <para>
        これは深さ優先探索で各ディレクトリを走査し, 
        含まれるファイルの数が 2 個(スクリプト中の <quote/1/ は
        typo ではありません), すなわち <quote/<filename/.// と
	<quote/<filename/..// ならば, そのディレクトリを削除します.  
      </para>
    
      <para>
        この段階の <filename>/var/tmp/root</filename> には, 
        本来 <filename>/</filename> 以下にあるべきファイルが
        すべて含まれています.
        各ファイルを順に見て, 既存のファイルと異なる部分を
        調べて下さい.  
      </para>
    
      <para>
        <filename>/var/tmp/root</filename> 以下に
        インストールされているファイルの中には, 
        <quote/./ から始まっているものがあります. 
        これを書いている時点で, それに該当するファイルは
	<filename>/var/tmp/root/</filename> と 
	<filename>/var/tmp/root/root/</filename> の中にある
        シェルスタートアップ ファイルだけですが, 
        他のものがあるかも知れません.  
        (これは, あなたがこれをどの時点で読んでいるかに依存するので, 
        <command/ls -a/ を使って確かめてください)</para>
    
      <para>
        もっとも簡単な方法は, 二つのファイルを比較するコマンド
	&man.diff.1; を使うことです.
      </para>
    
      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>
      
      <para>
        これは, あなたの
        <filename>/etc/shells</filename> ファイルと
	新しい <filename>/etc/shells</filename> ファイルの
        異なる部分を表示します.  
        これらを, あなたが書き換えたものに変更点をマージするか,
        それとも既存のファイルを新しいもので上書きするかを
        判断する材料にして下さい.  
      </para>
    
      <tip>
	<title>新しい root ディレクトリ
	  (<filename>/var/tmp/root</filename>) の名前に
          タイムスタンプを付けておくと, 
          異なるバージョン間の比較を楽に行なうことができます.  </title>
	
	<para>
          頻繁にシステムの再構築を行なうということは, 
          <filename>/etc</filename> の更新もまた, 頻繁に行う必要がある
          ということです.  これはちょっと手間のかかる作業です.
        </para>
	
	<para>
          この作業は, あなたが <filename>/etc</filename> にマージした, 
          新しく変更されたファイルの最新のセットのコピーを保存しておくことで
          素早く行なうことができます.  
          下の手順は, それを実現するための一つの方法です.  </para>
	
	<procedure>
	  <step>
	    <para>
              普通に make world します.  <filename>/etc</filename> や
	      他のディレクトリを更新したくなったときは, ターゲット
	      ディレクトリに, そのときの日付に基づく名前をつけてください.  
	      たとえば 1998 年 2 月 14 日 だとすれば, 以下のようにします.  
            </para>
	  
	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>
	  
	  <step>
	    <para>
              上に説明されているように, 
              このディレクトリから変更点をマージします.
            </para>
	    
	    <para>
              その作業が終了しても, 
              <filename>/var/tmp/root-19980214</filename> を
              削除しては<emphasis>いけません</emphasis>.  </para>
	  </step>
	  
	  <step>
	    <para>
              最新版のソースをダウンロードして再構築したら, 
              ステップ 1 にしたがって下さい.  今度は, 
              <filename>/var/tmp/root-19980221</filename>
              (更新作業が一週間おきだった場合)
              のような名前の, 新しいディレクトリをつくることになるでしょう.  
            </para>
	  </step>
	  
	  <step>
	    <para>
              この段階で &man.diff.1; を使用し, 
              二つのディレクトリを比較する再帰的 diff を作成することで, 
              一週間の間に行なわれたソースへの変更による相違点を調べます.  
            </para>

	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>
	  
	    <para>
              これによって報告される相違点は, 大抵の場合, 
              <filename>/var/tmp/root-19980221/etc</filename> と
              <filename>/etc</filename> との場合に比べて
              非常に少ないものになります.  
              相違点が少ないため, 変更点を既存の <filename>/etc</filename>
              ディレクトリにマージすることは, 比較的容易になります.  
            </para>
	  </step>
	  
	  <step>
	    <para>
              ここまで終了したら, <filename>/var/tmp/root-*</filename> の
              二つのうち, 古い方のディレクトリは削除して構いません.  
            </para>
	      
	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>
	  
	  <step>
	    <para>
              この工程を, <filename>/etc</filename> へ変更点をマージする
              必要があるたび, 毎回繰り返します.  
            </para>
	  </step>
	</procedure>
	
	<para>
          ディレクトリ名の生成を自動化するには, &man.date.1;
          を利用することができます.  
        </para>
	  
	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
    </sect2>
  
    <sect2>
      <title><filename>/dev</filename> の更新</title>
      
      <note>
	<title>DEVFS</title>
	
	<para>
          もし, DEVFS を利用しているなら, この作業はおそらく必要ないでしょう.  
        </para>
      </note>
      
      <para>
        安全のため, これはいくつかの段階に分けて行ないます.  
      </para>

      <procedure>
	<step>
	  <para>
            <filename>/var/tmp/root/dev/MAKEDEV</filename> を
	    <filename>/dev</filename> にコピーします.  
          </para>
	
	  <screen>&prompt.root; <userinput>cp /var/tmp/root/dev/MAKEDEV /dev</userinput></screen>
	</step>

	<step>
	  <para>
            ここで, <filename>/dev</filename> のファイル一覧を記録しておきます.  
            この一覧は, 各ファイルの許可属性, 所有者, メジャー番号, マイナー番号が
            含まれている必要がありますが, タイムスタンプは含まれていてはいけません.  
            これを行なう簡単な方法は, &man.awk.1; を使って, 
            いくつかの情報を取り除くことです.  
          </para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>ls -l | awk '{print $1, $2, $3, $4, $5, $6, $NF}' > /var/tmp/dev.out</userinput></screen>
	</step>

	<step>
	  <para>デバイスファイルをつくり直します.  </para>
	    
	    <screen>&prompt.root; <userinput/sh MAKEDEV all/</screen>
	</step>

	<step>
	  <para>
            もう一度, ディレクトリのファイル一覧を記録します.  
            今回は <filename>/var/tmp/dev2.out</filename> です.  
            この段階で, この二つのファイル一覧を調べて
            作成に失敗したデバイスを探して下さい.  
            違いは一つもないはずなのですが, 安全のために一応チェックして下さい.  
          </para>

	  <screen>&prompt.root; <userinput>diff /var/tmp/dev.out /var/tmp/dev2.out</userinput></screen>

	  <para>
            次のようなコマンドを使用し, ディスクスライスエントリを
            再作成することで, ディスクスライスの矛盾を検出することができます.  
	  
	    <screen>&prompt.root; <userinput>sh MAKEDEV sd0s1</userinput></screen>

            適当な組み合わせは, 環境によって異なります.  
          </para>
	</step>
      </procedure>
    </sect2>
    
    <sect2>
      <title><filename>/stand</filename> の更新</title>
      
      <note>
	<para>
          この段階は, 完全な更新を行なう場合にだけ必要な内容を含んでいます.  
          悪影響はありませんので, 省略しても構いません.  
        </para>
      </note>
      
      <para>
        完全な更新を行なうために, 
        <filename>/stand</filename> にあるファイルも同じように
        更新したいと考えるかも知れません.  
        これらのファイルは, <filename>/stand/sysinstall</filename> という
        バイナリファイルへのハードリンクです.  このバイナリファイルは, 
        他のファイルシステム(特に <filename>/usr</filename>)が
        マウントされていない場合にも動作できるよう, 
        静的にリンクされていなければなりません.  
      </para>

      <screen>&prompt.root; <userinput>cd /usr/src/release/sysinstall</userinput>
&prompt.root; <userinput>make all install</userinput></screen>

      <note>
	<title>1998 年 4 月 2 日以前のソースの場合</title>
	
	<para>
          もし, 1998 年 4 月 2 日より古いソースコードを使っているか, 
          <filename>Makefile</filename> のバージョンが 1.68
          以降(FreeBSD-CURRENT および FreeBSD-3.X の場合), 
          1.48.2.21 以降(FreeBSD-2.2.X の場合)でなければ, 
          次のように <userinput>NOSHARED=yes</userinput>
          オプションを追加する必要があります.  
        </para>

	<screen>&prompt.root; <userinput>make NOSHARED=yes all install</userinput></screen>
      </note>
    </sect2>
    
    <sect2>
      <title>新しいカーネルのコンパイルとインストール</title>

      <para>
        新しいシステムにおけるアドバンテージを完全に得るために, 
	カーネルの再コンパイルをすべきです.  
        再コンパイルは, ある種のメモリ構造が変更された時には必須です.  
        その場合, &man.ps.1; や &man.top.1; のようなプログラムは, 
        カーネルとソースコードのバージョンが一致しないと
        正常に動作しないでしょう.  
      </para>

      <para>
        新しい kernel をコンパイルするには, 
        FreeBSD ハンドブックの指示にしたがってください.  
	過去に自分で設定したカーネルを構築している場合には, 
        <filename>LINT</filename> コンフィグレーションファイルを注意深く調べて, 
        利用できる新しいオプションがあるかどうか確かめて下さい.  
      </para>

      <para>
        この文書の以前の版では, 
        カーネルの再構築の前に再起動することを推奨していました.  
        これは以下の点で誤りです.  
      </para>

      <itemizedlist>
	<listitem>
	  <para>&man.ps.1;, や &man.ifconfig.8;, 
            &man.sysctl.8; といったコマンドが動作しなくなる恐れがあります.  
            そうなると, マシンがネットワークに接続できなくなってしまいます.  
          </para>
	</listitem>
      
	<listitem>
	  <para>&man.mount.8; のような基本的なユーティリティが機能しなくなり, 
	    <filename>/</filename> や <filename>/usr</filename> 等を
	    マウントできなくなってしまうかも知れません.  
            これは, -STABLE の候補を追いかけている場合には
            あまり発生することはありませんが, 
            -CURRENT を追いかけていて, 
            大規模なマージが行なわれている間には良く起こります.  
          </para>
	</listitem>

	<listitem>
	  <para>
            ローダブルカーネルモジュール (FreeBSD-3.X 以前は
            LKM と呼ばれていましたが, FreeBSD-3.X 以降は KLD
            と呼んでいます)は <quote>world</quote> の一部として
            構築されるため, 古いカーネルがクラッシュする可能性があります.  
          </para>
	</listitem>
      </itemizedlist>

      <para>
        これらの理由から, どんな場合においても, 
        再起動する前に新しいカーネルを再構築し, インストールすることが
        最も良い手順になります.  
      </para>

      <para>
        新しいカーネルは, <userinput>make world</userinput>
        (あるいは <userinput>make installworld</userinput>) が完了した後で
        構築しなければなりません.  もし, そうしない場合には
        (おそらく, あなたはシステムを更新する前にカーネルが構築されることを
        確認したいのでしょう) 問題が起こるかも知れません.  それは, 
        カーネルソースに対して &man.config.8; コマンドが古いことが原因です.  
      </para>

      <para>
        その場合には, 新しいバージョンの &man.config.8;
        でカーネルを構築することができます.
      </para>
      
      <screen>&prompt.root; <userinput>/usr/obj/usr/src/usr.sbin/config/config <replaceable>KERNELNAME</replaceable></userinput></screen>

      <para>
        これは, いつもうまく行くとは限りませんので, 
        新しいをカーネルをコンパイルする前に
        <userinput>make world</userinput> (あるいは <userinput>make
	  installworld</userinput>)を完了させることが推奨されています.  </para>
    </sect2>
    
    <sect2>
      <title/再起動/
      
      <para>
        これで, 作業はおしまいです.  
        すべてがあるべき正しい場所に存在することをチェックしたら, 
        システムを再起動します.  これは, 単に
        &man.fastboot.8; を実行するだけです.  
      </para>

      <screen>&prompt.root; <userinput>fastboot</userinput></screen>
    </sect2>

    <sect2>
      <title>作業の完了</title>
      
      <para>
        ここまで来れば, FreeBSD システムのアップグレードは成功です.  
	おめでとうございます.  
      </para>
      
      <para>
        さて, この時点で, 今までの間違った操作による小さな問題に
        気付くことがあるかも知れません.  
	たとえば, 私はかつて <filename>/etc/magic</filename>
        をアップグレードの途中で削除し, そのまま
        <filename>/etc</filename>
        にマージしてしまったことがあります.  
        その結果, <command>file</command>
        コマンドは動作しなくなってしまったのです.  
        すぐに思いついたのは, これを修復するには

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput/make all install/</screen>

	だけで十分ではないか, ということでした.  </para>
    </sect2>    
    
    <sect2>
      <title/質問ですか?/

      <qandaset>
	<qandaentry>
	  <question>
	    <para>変更が行なわれたら, その度にシステムの再構築が必要になるのでしょうか?</para>
	  </question>

	  <answer>
            <para>
              それは変更の性質によるので, なんとも言えません.
	      例えば, CVSup を実行したとき, 最後に実行したときから比べて
	      次にあげるようなファイルが更新されていたとします.</para>
      
	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>
              このときには, 改めてシステムを再構築する必要はありません.
	      わたしなら, 適切なサブディレクトリに移って
	      <command>make all install</command> を行うと思います.  
	      しかし, もし何らかの大きな変更が行なわれているとき, 例えば
	      <filename>src/lib/libc/stdlib</filename> が変更されている場合には,
	      システムを再構築するか, もしくはそのうち, 
              少なくとも静的にリンクされているもの(と, わたしが追加した
              他のプログラムのうち, 静的にリンクされたもの)を
              作り直すことでしょう.  
            </para>
      
	    <para>結局のところ, どの時点で現在のシステムをアップグレードするかは
              あなたが決めることです.  
	      2 週間ごとにシステムを再構築し, その 2 週間の変更を取り込めば
              幸せかもしれませんし, 
              変更のあった部分だけ再構築し, 依存関係を確かめたいと考えるかも知れません.  
              <!-- hrs:2000/02/15
                   What's "every fortnight say"? s/say/day/? -->
            </para>
      
	    <para>
              もちろん, それらはどのくらいの頻度でアップグレードしたいか,
	      そして -STABLE か -CURRENT のどちらを追いかけているのかによります.
            </para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>signal 12(もしくは他のシグナル番号)のエラーがたくさん出て
	      コンパイルが失敗します. 何が起こっているんでしょうか?</para>
	  </question>

	  <answer>
	    <para>
              これは通常, ハードウェアに問題があることを示しています.
              システムの再構築は, ハードウェアに対する負荷耐久試験を行なうための
              有効な手段の一つで, メモリに関係する問題がよく報告されます.  
              その大部分は, コンパイラが奇妙なシグナルを受け取り, 
              不可解な異常終了となることで発見されます.  
            </para>
      
	    <para>
              本当にこの問題によるものかどうかは, 再構築をもう一度実行し, 
              異なる段階で異常終了が発生するか, ということから確認できます.  
            </para>
      
	    <para>
              この場合には, マシンの部品を交換して, どの部分が悪いのかを
              調べてみることくらいしかできることはありません.  
            </para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>終了したら <filename>/usr/obj</filename> を削除しても
	      かまいませんか?</para>
	  </question>
	  
	  <answer>
	    <para>
              それはあなたが次の機会に, 
              システムの再構築をどう行なうつもりなのかによります.  
            </para>
      
	    <para><filename>/usr/obj</filename> には, 
              コンパイルの段階で生成された
              すべてのオブジェクトファイルが含まれています.
              通常 <quote/make world/ の最初の段階では, 
              このディレクトリを削除して新しくつくり直すようになっています.  
              その場合には, 構築終了後の <filename>/usr/obj</filename>
              を保存しておいても, あまり意味はありません.  
              削除すれば, 大きなディスクスペースを
	      (現在はだいたい 150MB あります) 解放することができます.  </para>
      
	    <para>
              しかし, もしあなたが何を行なおうとしているのか理解しているなら, 
	      この段階を省略して <quote/make world/ を行なうことができます.  
	      こうすると, ほとんどのソースは再コンパイルされないため, 
              構築はかなり高速化されます.  
	      これは裏をかえせば, デリケートな依存関係の問題によって, 
              システムの構築が奇妙な失敗に終わる可能性があるということです.  
              FreeBSD メーリングリストではしばしば, 構築の失敗が, 
              この段階の省略によるものだということを理解せずに
              不満の声をあげる人がいます.  
            </para>
      
	    <para>
              もし, このような危険を承知した上でシステムの再構築を行なう場合には, 
	      次のように変数 <makevar>NOCLEAN</makevar> を定義して構築します.  
            </para>

	    <screen>&prompt.root; <userinput>make -DNOCLEAN world</userinput></screen>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>構築を中断した場合, その構築を途中から再開することはできますか?</para>
	  </question>

	  <answer>
	    <para>
              それは, あなたが問題に気付く前に, 
              どれだけの作業を終えているかによって変わります.  
            </para>

	    <para><emphasis>一般的に</emphasis> (そしてこれは確実でしっかりした
	      規則ではありませんが), 
              <quote>make world</quote> の過程では, 
              基本的なツール ( &man.gcc.1;, や &man.make.1; のようなもの)
	      や, システムライブラリの新しいコピーが作成されます.  
              その後まず, これらのツールやライブラリはインストールされてから
              自分自身の再構築に使われ, もう一度, インストールされます.  
	      全体のシステム (ここでは &man.ls.1; や &man.grep.1; といった
	      標準的なユーザプログラムを含みます) は, 
              その新しいシステムファイルを用いて作り直されることになります.  
            </para>

	    <para>
              もし, 再構築が最終段階に入っていること
              が(記録しておいた出力を見たりすることで)わかっていたら, 
              (全く悪影響を与えることなく)次のようにすることができます, 
            </para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNOCLEAN all</userinput></screen>

	    <para>
              これは, 前回の <quote>make world</quote>
              の作業をやり直しません.  
            </para>

	    <para>次のメッセージ

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	      が <quote>make world</quote> の出力にある場合には, 
              上のようにしてもほとんど悪影響が現れることはありません.  
            </para>
	    
	    <para>
              もしこのメッセージがないとか, よく分からないという場合には, 
	      安全を確保し, 後悔するようなことがないよう, 
              システムの再構築を最初からやり直しましょう.  </para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>あるマシンを <emphasis/マスタ/ として, 
              他の多くのマシンを (NFSで) アップグレードできますか?</para>
	  </question>

	  <answer>
	    <para>すべてのコンパイル作業をあるマシンで行ない, 
	      構築されたものを他のマシンにネットワークを経由で 
              <command>make install</command>
	      することができるかどうかは, 
              よく FreeBSD メーリングリストで尋ねられます.  </para>
      
	    <para>これはわたしが行った作業ではありませんので, 
              下に書かれている提案は, 他の人々から頂いたか, 
	      Makefile から推論したものです.</para>
	    
	    <para>取るべき適切な方法については, 
              利用している FreeBSD のバージョンに依存します.</para>
	    
	    <para>
              アップグレードしたマシンでは, この作業を行った後に
	      <filename>/etc</filename> や <filename>/dev</filename> の
	      更新を行わなくてはなりません.</para>
	    
	    <para>2.1.7 とそれより古いものについて, Antonio Bemfica は
	      次に示すような方法を教えてくれました.  </para>

	    <screen>Date: Thu, 20 Feb 1997 14:05:01 -0400 (AST)
From: Antonio Bemfica &lt;bemfica@militzer.me.tuns.ca&gt;
To: freebsd-questions@freebsd.org
Message-ID: &lt;Pine.BSI.3.94.970220135725.245C-100000@militzer.me.tuns.ca&gt;

Josef Karthauser は質問しました:

&gt; どなたかネットワークを通してマシンをアップグレードするよい方法は知りませんか

まず, メインとなるマシンで make world などをします.
そして次のように, リモートのマシンから / や /usr をマウントします:

main_machine% mount remote_machine:/   /mnt
main_machine% mount remote_machine:/usr /mnt/usr

そして, /mnt をインストール先に指定して 'make install' とします:

main_machine% make install DESTDIR=/mnt

これをネットワーク上の他のマシンについても繰り返してください.  
わたしの場合には, これでうまくいきました.
     
Antonio</screen>

	    <para>この仕組みは (わたしの知る限り) NFS サーバ上の
	      <filename>/usr/src</filename> が書き込み可能である場合にのみ
              きちんと動作します.  FreeBSD-2.1.7 とそれ以前では, 
              この作業に <maketarget>install</maketarget> ターゲットを使います.  
            </para>
	    
	    <para>FreeBSD-2.1.7 と FreeBSD-2.2.0 の間で
              <quote>reinstall</quote> ターゲットが導入されました.
              上にあげた FreeBSD-2.1.7 向けの方法に加え, 
	      <quote>install</quote> の代わりに <quote>reinstall</quote> を
	      使うことができます.  </para>

	    <para>この方法では, NFS サーバ上の <filename>/usr/src</filename> 
	      ディレクトリへの書き込み権限は必要 
	      <emphasis>ありません</emphasis>.</para>

	    <para>Makefile の 1.68 から 1.107 の間のバージョンには, 
              このターゲットに関するバグがありました.  
              それは NFS サーバへの書き込み権限が
              <emphasis>必要になる</emphasis> というもので, 
              このバグは FreeBSD-2.2.0 がリリースされる前に修正されました.  
	      この時期の -STABLE が動いている古いサーバでは, 
              問題になるかも知れません.  </para>

	    <para>FreeBSD-2.2.5 以降のバージョンでは,
              <quote>buildworld</quote> と
	      <quote>installworld</quote> ターゲットが利用できます.  
	      これらを使ってソースツリーを一つのマシンで構築し,
	      <filename>/usr/src</filename> と
	      <filename>/usr/obj</filename> をリモートマシンで
              NFS マウントして, そこからインストールすることができます.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>どのようにすれば make world を高速化できますか?</para>

	    <itemizedlist>
	      <listitem>
		<para>シングルユーザモードで動かしてください.</para>
	      </listitem>
	      
	      <listitem>
		<para><filename>/usr/src</filename> と
		  <filename>/usr/obj</filename> ディレクトリを, 
                  異なるディスク上の別のファイルシステムに置いてください.
		  また可能ならば, 異なるディスクコントローラに接続された
                  ディスクを使って下さい.  </para>
	      </listitem>
	      
	      <listitem>
		<para>さらに高速化するには, これらのファイルシステムを
		  <quote>ccd</quote> (連結ディスクドライバ) デバイスを
		  使って, 別々なディスク上に置いてください.</para>
	      </listitem>
	      
	      <listitem>
		<para>プロファイル版の作成を無効化して下さい.  
		  (<filename>/etc/make.conf</filename> で
		  <quote>NOPROFILE=true</quote> をセットします)
		  普通, それが必要になることはありません.  </para>
	      </listitem>
	      
	      <listitem>
		<para>また, <filename>/etc/make.conf</filename> の中の
		  <quote>CFLAGS</quote> を, 
                  <quote>-O -pipe</quote> のように指定しましょう.
                  <quote>-O2</quote> の最適化はさらに多くの時間を必要とし, 
		  しかも <quote>-O</quote> と <quote>-O2</quote> の
		  最適化には, ほtんど差はありません.
                  <quote>-pipe</quote> を指定することで, 
                  コンパイラはテンポラリファイルの代わりにパイプを利用します.  
                  その結果, (メモリの利用は増えますが)ディスクアクセスが減ります.  
                </para>
	      </listitem>
	      
	      <listitem>
		<para>(もしあなたが十分に最近のバージョンの FreeBSD を使っているなら)
		  複数のプロセスを並列に実行させるため, 
                  make に <option>-j&lt;n&gt;</option> オプションを指定してください.  
                  これはプロセッサが単一か複数かによらず, 
                  どちらも同様に恩恵を得ることができます.</para>
	      </listitem>
	      
	      <listitem><para><filename>/usr/src</filename> のある
                  ファイルシステムを, <quote>noatime</quote>
                  オプションを付けてマウント(もしくは再マウント)してください.  
                  これは, そのファイルシステムにおいて, 
                  最後にアクセスされた時刻の書き込みを抑制します.  
		  おそらく, この情報が必要になることはないでしょう.</para>
                
                <note>
                  <para><quote>noatime</quote> が利用可能なのは, 
                    FreeBSD-2.2.0 以降です.</para>
                </note>
		  
                <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>
		  
                <warning>
                  <para>上の例は, 
                    <filename>/usr/src</filename> 自身が独立したファイルシステムで
                    あることを想定しています.
                    もしそうでないときには (例えば <filename>/usr</filename> の
                    一部である場合には), 
                    <filename>/usr/src</filename> ではなく
                    適切なマウントポイントを指定する必要があります.
                  </para>
                </warning>
              </listitem>
	      
	      <listitem>
		<para><filename>/usr/obj</filename> のあるファイルシステムを, 
		  <quote>async</quote> オプションをつけてマウント (もしくは
		  再マウント) してください.  これによって, 
                  ディスクへの書き込みが非同期になります. 
                  つまり, 書き込み命令はすぐに完了するのに対し, 
                  実際にデータがディスクに書き込まれるのは, その数秒後になります.
                  これによって, 書き込み処理の一括化が可能になるため, 
		  劇的なパフォーマンスの向上が期待できます.  
                  <!-- hrs:2000/02/15 (for ja-translators)
                       "be clusterd togather" is translated into "clusterization" -->
                </para>

		<warning>
		  <para>
                    このオプションを指定すると, ファイルシステムは
		    壊れやすくなってしまうことに注意してください.
                    このオプションを付けていて, 突然電源が落ちた場合には, 
                    再起動後にファイルシステムが復旧不能になる可能性が
                    非常に高くなります.  </para>
	   
		  <para>もし, <filename>/usr/obj</filename> 自身が独立した
		    ファイルシステムであるならば, これは問題になりません.  
                    しかし, 同じファイルシステムに, 他の貴重なデータを置いているときには,
		    このオプションを有効にする前に, 
                    バックアップをきちんと取っておきましょう.</para>
		</warning>
		
		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>
		
		<warning>
		  <para>もし <filename>/usr/obj</filename> 自身が
                    ファイルシステムでない場合には, 適切なマウントポイントを指すように, 
                    上の例の名前を置き換えて下さい.  </para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </question>
	</qandaentry>
      </qandaset>
    </sect2>

    <sect2>
      <title>貢献してくれた人々</title>
      
      <para>
        次にあげられているのは, 何らかの形でこの文書に貢献された方々です.
	それは, 変更点や改良点, 間違いの指摘を直接教えてくださったり,
        わたしがそのまま参考資料とさせていただいた, FreeBSD メーリングリストに
        投稿されたメッセージなどによるものです.  ここに, みなさんへの感謝の意を表します.  
      </para>

      <itemizedlist>
	<listitem>
	  <para>Antonio Bemfica,
	    <email>bemfica@militzer.me.tuns.ca</email></para>
	</listitem>

	<listitem>
	  <para>Sue Blake, <email>sue@welearn.com.au</email></para>
	</listitem>
	
	<listitem>
	  <para>Brian Haskin, <email>haskin@ptway.com</email></para>
	</listitem>
	
	<listitem>
	  <para>Kees Jan Koster, <email>kjk1@ukc.ac.uk</email></para>
	</listitem>
	
	<listitem>
	  <para>A Joseph Kosy, <email>koshy@india.hp.com</email></para>
	</listitem>
	
	<listitem>
	  <para>Greg Lehey, <email>grog@lemis.com</email></para>
	</listitem>
	
	<listitem>
	  <para>Wes Peters, <email>softweyr@xmission.com</email></para>
	</listitem>
	
	<listitem>
	  <para>Joseph Stein, <email>joes@wstein.com</email></para>
	</listitem>

	<listitem>
	  <para>Studded, <email>studded@dal.net</email></para>
	</listitem>
	
	<listitem>
	  <para>Axel Thimm,
	    <email>Axel.Thimm@physik.fu-berlin.de</email></para>
	</listitem>
	
	<listitem>
	  <para>Matthew Thyer,
	    <email>Matthew.Thyer@dsto.defence.gov.au</email></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
