<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.26
     $FreeBSD: doc/ja_JP.eucJP/books/handbook/disks/chapter.sgml,v 1.8 2000/12/25 15:48:39 hrs Exp $
-->

<chapter id="disks">
  <title>ディスク</title>

  <sect1 id="disks-synopsis">
    <title>この章では</title>

    <para>
      この章では, FreeBSD 上でどのようにして物理的なディスクやメモリディスク,
      もしくはネットワークに接続されたディスクを使うのか, ということを解説します.
    </para>
  </sect1>

  <sect1 id="disks-bios-numbering">
    <title>BIOS ドライブの番号付け</title>

    <para>
      FreeBSD をインストールして設定する前に,
      特に複数のハードディスクを持っているならば気をつけておかなければならない重要なことがあります.
    </para>    

    <para>
      DOS が動いている PC や WINxxx のような BIOS 依存のオペレーティングシステムでは,
      BIOS がディスクドライブの順序を構成し, OS はその変化に追従します. これにより,
      ユーザはいわゆる <quote>プライマリーマスター</quote> 以外のディスクから起動することができます.
      この仕組みを用いればシステムのバックアップを取る最も簡単で安価な方法を構築できます.
      もう一つ同じディスクを買い,
      Ghost や XCOPY を用いて一つ目のディスクから二つめのディスクへのコピーを定期的に取ればいいのです.
      そして, 一つ目のディスクに障害が起きた時には,
      BIOS に対してドライブを論理的に交換するように指示することで簡単に復旧できるのです.
      この方法はドライブのケーブルを交換するのと同じようなことなのですが, ケースを開ける必要がありません.
    </para>

    <para>
      SCSI コントローラを備えたもっと高価なシステムでは, しばしば BIOS に拡張が施されており同じように
      7 台までのドライブの順番を組み換えることができるようになっています.
    </para>

    <para>
      以上のような機能を便利に使っているユーザは, FreeBSD では同じような結果にならないことに驚くかもしれません.
      FreeBSD は BIOS を利用しないため, <quote>論理 BIOS ドライブマッピング</quote>については知らないのです.
      このため, 特にいくつかのドライブが同じジオメトリを持っている時に,
      そしてまたあるものをもう一つのクローンとして使っている時に非常にややこしい状況になり得ます.
    </para>

    <para>
      FreeBSD を使う時は, インストール前にドライブの番号付けが自然なものになるように,
      BIOS の設定を忘れずに戻しておきましょう. もしドライブの番号付けを変更する必要がある場合には,
      そうすればいいのですが, ハードウェア的にケースを開けジャンパーやケーブルを移動しましょう.
    </para>

    <sidebar>
      <title>Bill と Fred のイケイケ冒険記</title>
      
      <para>
        Bill は Fred のためにもう一つ FreeBSD 箱を作ろうと古い Wintel 箱を潰しました.
	Bill は ユニット番号 0 の SCSI ドライブを一つ追加し, そこに FreeBSD を入れました.
      </para>

      <para>
        Fred はこのシステムを使い始めましたが,
	数日後その古い SCSI ドライブがたくさんのソフトエラーを吐いているのに気付き,
	Bill に報告しました.
      </para>

      <para>
        さらに数日後, Bill はその問題に対処しようと決意し, 倉庫のディスクドライブアーカイブから同じ
	SCSI ドライブを取ってきました. まずドライブのサーフィススキャンを行なってみましたが特に問題なかったため,
	Bill はこのドライブをユニット番号 4 として付け, ドライブ 0 からドライブ 4 へのイメージコピーを行ないました.
	新しいドライブがインストールされ, しかもうまく動いているため,
	Bill はそれを使い始めてもいいだろうと思いました.
	そこで彼は SCSI BIOS の機能を使ってシステムがユニット 4
	から起動するようにディスクドライブの順序を入れ換えました.
	FreeBSD が起動し, 調子良く動き始めました.
      </para>

      <para>
        Fred は数日作業を続けましたが,
	すぐに Bill と Fred は新しい冒険に挑戦することにしました.
	新しいバージョンの FreeBSD にアップグレードするのです.
	Bill は SCSI ユニット 0 のディスクは当てにならないので取りはずし,
	アーカイブから持ってきた別の新しいドライブと交換しました.
	そして, 新しいバージョンの FreeBSD を,
	Fred の持っていた魔法のインターネット FTP フロッピーを用いて新しい
	SCSI ユニット 0 にインストールしたのです.
	インストールはうまくいきました.
      </para>

      <para>
        Fred は新しいバージョンの FreeBSD を数日使ってみて,
	技術部門でも使えるくらい十分に良いものだと確認しました.
	古いバージョンから全ての作業をコピーする時が来たのです.
	そこで Fred は SCSI ユニット 4 (古い FreeBSD
	で行なっていた作業の最新のものを置いてあるドライブです)
	をマウントしました.
	ところが, Fred は SCSI ユニット 4
	には自分の貴重な作業がなにも残っていないことを発見して慌てふためきました.
      </para>

      <para>データはどこへ行ったのでしょう?</para>

      <para>
        Bill がオリジナルの SCSI ユニット 0 のイメージをユニット 4
	にコピーした時, ユニット 4 は「新クローン」になりました.
	Bill がユニット 4 から起動するように SCSI BIOS で順序の入れ換えを行なった時,
	実はおバカなことにそう変更したと思い込んでいただけなのです.
	FreeBSD は依然として SCSI ユニット 0 上で動いていたのです.
	BIOS にこのような変更を行なっても Boot と Loader のコードの一部もしくは全部は選択された BIOS
	ドライブから取得されるものの, 処理が FreeBSD のカーネルドライバーに引き渡された時から
	BIOS ドライブの順序は無視され, FreeBSD は通常のドライブ番号順に移行するのです.
	さきほどの例では,
	システムはオリジナルの SCSI ユニット 0 で動き続けており,
	Fred のデータは全て SCSI ユニット 4 ではなくそのディスクに残っていたのです.
	システムが SCSI ユニット 4 で動いているように見えたのは単に人の期待からくる妄想だったのです.
      </para>

      <para>
        こういった現象の発見のどの時点においてもデータは全く失なわれても損なわれてもいないことを喜びをもって伝えておきます.
	古い SCSI ユニット 0 はガラクタの山から見つけ出され, Fred の作業は全て彼のもとへ返ってきたのです
	(そして Bill は自分が 0 までは数えられることを学んだのでした).
      </para>

      <para>
        この例では SCSI ドライブが用いられましたが, その概念は IDE ドライブにも同じように当てはまります.
      </para>
    </sidebar>
  </sect1>

  <sect1 id="disks-naming">
    <title>ディスクの名前付け</title>

    <para>
      物理ディスクには主に二つの種類, <acronym>IDE</acronym> と <acronym>SCSI</acronym> がありますが,
      他にも RAID コントローラによって提供されるものやフラッシュメモリなどがあります.
      これらのディスクの振舞いはかなり異なるため, それぞれにドライバーとデバイスがあります.
    </para>

    <table id="disk-naming-physical-table">
      <title>物理ディスクへの名前付け</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>ドライブの種類</entry>
	    <entry>ドライブのデバイス名</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>IDE ハードドライブ</entry>
	    <entry>4.0-RELEASE では <literal>ad</literal>,
	      4.0-RELEASE より前のものでは <literal>wd</literal>.</entry>
	  </row>
	  <row>
	    <entry>IDE CD-ROM ドライブ</entry>
	    <entry>3.1-RELEASE 以降は <literal>acd</literal>,
	      4.0-RELEASE より前のものでは <literal>wcd</literal>.</entry>
	  </row>
	  <row>
	    <entry>SCSI ハードドライブ</entry>
	    <entry>3.0-RELEASE 以降は <literal>da</literal>,
	      3.0-RELEASE より前は <literal>sd</literal>.</entry>
	  </row>
	  <row>
	    <entry>SCSI CD-ROM ドライブ</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry>その他の非標準的 CD-ROM ドライブ</entry>
	    <entry>ミツミ CD-ROM は <literal>mcd</literal>,
	      Sony CD-ROM は <literal>scd</literal>,
	      松下/パナソニック CD-ROM は <literal>matcd</literal>
	    </entry>
	  </row>
	  <row>
	    <entry>フロッピードライブ</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI テープドライブ</entry>
	    <entry>3.0-RELEASE 以降は <literal>sa</literal>,
	      3.0-RELEASE よりも前では <literal>st</literal>.</entry>
	  </row>
	  <row>
	    <entry>IDE テープドライブ</entry>
	    <entry>4.0-RELEASE 以降では <literal>ast</literal>,
	      それよりも前のものでは <literal>wst</literal>.</entry>
	  </row>
	  <row>
	    <entry>フラッシュドライブ</entry>
	    <entry>3.3-RELEASE 以降の DiskOnChip フラッシュデバイスは <literal>fla</literal>.</entry>
	  </row>
	  <row>
	    <entry>RAID ドライブ</entry>
	    <entry><literal>myxd</literal> は Mylex 用,
	      <literal>amrd</literal> は AMI MegaRAID 用,
	      <literal>idad</literal> は Compaq Smart RAID 用.
	      これらは全て 4.0-RELEASE 以降. 3.2-RELEASE から 4.0-RELEASE までは <literal>id</literal>.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <sect2>
      <title>スライスとパーティション</title>

      <para>
        物理ディスクは<quote>危険な専用(原文はdangerously dedicated)ディスク</quote>でない限り,
	通常はスライスを含んでいます. スライス番号はデバイス名の後に続き, <literal>s</literal>
	という接頭文字が付きます. <quote>da0<emphasis>s1</emphasis></quote> といった感じです.
      </para>

      <para>
        スライスや<quote>危険な専用 (原文はdangerously dedicated) ディスク</quote>や他のディスクは<firstterm>パーティション</firstterm>を含んでおり,
	パーティションは <literal>a</literal> から <literal>h</literal> までの文字で表現されます.
	<literal>b</literal> はスワップパーティション用に予約されており, <literal>c</literal>
	はスライスもしくはドライブの全体を表わす未使用パーティションです.
	このあたりのことは <xref linkend="disks-adding" /> で解説します.
      </para>
    </sect2>
  </sect1>

  <sect1 id="disks-mounting">
    <title>ファイルシステムのマウントとアンマウント</title>

    <para>
      ファイルシステムは <filename>/</filename> を根とする木構造として最もうまく視覚化できます.
      <filename>/dev</filename> や <filename>/usr</filename>,
      ルートディレクトリにあるその他のディレクトリは枝であり,
      <filename>/usr/local</filename> のようにそれぞれが自身の枝を持つことができます.
    </para>

    <para>
      様々な理由がありますが, これらのディレクトリのいくつかは異なるファイルシステム上に構築するのが良いでしょう.
      <filename>/var</filename> はログやスプール,
      そして様々な種類の一時ファイルなどを含むため溢れてしまう可能性があります.
      ルートファイルシステムが溢れるのは良くないため, たいての場合は <filename>/var</filename> を
      <filename>/</filename> と切り離すのです.
    </para>

    <para>
      あるディレクトリツリーを他のファイルシステムに含まれるようにするもう一つのよくある理由は,
      それらが別の物理ディスクや, <link linkend="nfs">ネットワークファイルシステム</link>や
      CD-ROM といった仮想ディスクに置かれる場合です.
    </para>

    <sect2 id="disks-fstab">
      <title>fstab ファイル</title>

      <para>
        <link linkend="boot">起動プロセス</link>において, <filename>/etc/fstab</filename>
	にリストされているファイルシステムは自動的にマウントされます
	(ただし <option>noauto</option> オプションがない場合).
      </para>

      <para>
        <filename>/etc/fstab</filename> ファイルは以下のようなフォーマットの行からなります.
      </para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <para>
        <literal>device</literal> は上の <link linkend="disks-naming">ディスクの名前付け</link>のセクションで解説したデバイス名 (存在している必要があります) です.
      </para>

      <para>
        <literal>mount-point</literal> はそのファイルシステムをマウントするディレクトリです
	(存在していなければなりません).
      </para>

      <para>
        <literal>fstype</literal> は &man.mount.8; に渡されるファイルシステムタイプです.
	デフォルトの FreeBSD ファイルシステムは <literal>ufs</literal> です.
      </para>

      <para>
        <literal>options</literal> では読み書き可能なファイルシステム用の <option>rw</option>,
	か読み込み専用ファイルシステム用の <option>ro</option> のどちらかと,
	他に必要なものをそれに続けます. よくあるのは <option>noauto</option> で,
	これは起動中にはマウントしたくないファイルシステムに用います.
	他のオプションはマニュアル &man.mount.8; を参照してください.
      </para>

      <para>
        <literal>dumpfreq</literal> はファイスシステムを dump すべき日数で,
	<literal>passno</literal> は起動中でファイルシステムがマウントされる時のパスナンバーです.
      </para>
    </sect2>

    <sect2 id="disks-mount">
      <title>マウントコマンド</title>

      <para>
        &man.mount.8; コマンドはファイルシステムをマウントする時に使われるコマンドです.
      </para>

      <para>最も基本的な形は以下の通りです.</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>
        マニュアル &man.mount.8; にあるように非常にたくさんのオプションがありますが,
        最も頻繁に使われるものは次のようなものです.
      </para>

      <variablelist>
	<title>マウントオプション</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>
	      <filename>/etc/fstab</filename> にあるファイルシステムを全てマウントします.
	      もし <option>-t</option> があればそれが効きます.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>実際のファイルシステムのマウント以外の全てを行ないます.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>強制的にファイルシステムをマウントします.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>ファイルシステムを読み込み専用でマウントします.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>
	      与えられたファイルシステムを与えられたファイルシステムタイプでマウントします.
	      もしくは <option>-a</option> オプションも与えられている場合は与えられたタイプのファイルシステムのみマウントします.
	    </para>

	    <para><quote>ufs</quote> がデフォルトのファイルシステムタイプです.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>(既にマウントされている) ファイルシステムのマウントオプションを更新します.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>冗長になります.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>ファイルシステムを読み書き可能でマウントします.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>
        <option>-o</option> は次のようなオプションを複数カンマで区切って指定します.
      </para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	  <listitem>
	    <para>
	      ファイルシステム上のデバイススペシャルファイルを解釈しません.
	      便利なセキュリティオプションです.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	    <para>このファイルシステム上のバイナリの実行を許可しません.
	    セキュリティに便利なオプションです.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>
	      setuid や setgid といったオプションを解釈しません.
	      セキュリティに便利なオプションです.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>umount コマンド</title>

      <para>
        umount コマンドは, パラメータとしてマウントポイントの一つ,
	デバイス名, もしくは <option>-a</option> や <option>-A</option>
	といったオプションを取ります.
      </para>

      <para>
        全ての形式において, <option>-f</option> は強制アンマウント,
	<option>-v</option> は冗長性を高めるために用いることができます.
      </para>

      <para>
        <option>-a</option> と <option>-A</option>
	はマウントされている全てのファイルシステムをアンマウントするために用いられますが,
	<option>-t</option> の後にファイルシステムタイプがリストされていればそれだけがアンマウントされます.
	<option>-A</option> はルートファイルシステムはアンマウントしません.
      </para>
    </sect2>
  </sect1>
  
  <sect1 id="disks-adding">
    <title>ディスクの追加</title>

    <para><emphasis>オリジナルは &a.obrien; によって 1998 年 4 月 26 日に寄贈されました.</emphasis></para>
      
    <para>
      現在一つしかドライブがない計算機に新しく SCSI ディスクを追加したいとしましょう.
      まずコンピュータの電源を切り, コンピュータやコントローラ,
      ドライブの製造元の指示に従ってドライブを取り付けます.
      このあたりの手順は非常にバラエティに富んでいるため, 細かいことはこのドキュメントの範囲外です.
    </para>

    <para>
      <username>root</username> ユーザでログインします. ドライブの取り付け後は
      <filename>/var/run/dmesg.boot</filename> を調べて新しいディスクが見つかっていることを確認しておきます.
      この例では, 新しく付けたドライブは <filename>da1</filename> で,
      我々はそれを <filename>/1</filename> にマウントしたいとしましょう
      (もし IDE ドライブを付けようとしているのなら, 4.0 以前のシステムでは
      <filename>wd1</filename>, ほとんどの 4.x システムでは <filename>ad1</filename> になるでしょう).
    </para>

    <para>
      FreeBSD は IBM-PC 互換のコンピュータで動くため,
      PC BIOS のパーティションを考慮に入れる必要があります.
      これは従来の BSD パーティションとは異なります. PC ディスクは 4 つまでの
      BIOS パーティションエントリを持つことができます.
      もしそのディスクを本当に FreeBSD 専用にしたい場合には<emphasis>専用</emphasis>モードで用いることもできます.
      そうでない場合には, FreeBSD は PC BIOS パーティションのどれか一つの中に入れることになります.
      FreeBSD では, 従来の BSD パーティションと混乱しないように
      PC BIOS パーティションのことを<emphasis>スライス</emphasis>と呼びます. 
      また, 別の OS がインストールされていたコンピュータで使われていたが
      FreeBSD 専用にするディスク上でもスライスを用いることができます.
      これは, 他の OS の <command>fdisk</command> ユーティリティを混乱させないためです.
    </para>

    <para>
      スライスの場合, ドライブは <filename>/dev/da1s1e</filename> として加えられるでしょう.
      これは, SCSI ディスクでユニット番号は 1 (二つめの SCSI ディスク),
      スライスは 1 (PC BIOS のパーティションが 1) で BSD パーティション <filename>e</filename>, と読みます.
      専用ディスクの場合だと単純に <filename>/dev/da1e</filename> として加えられるでしょう.
    </para>

    <sect2>
      <title>sysinstall を利用</title>
      
      <para>
       	<command>/stand/sysinstall</command>
	の使い易いメニューを利用して新しいディスクのパーティション分けやラベル付けを行なうことができます. 
	<username>root</username> ユーザでログインするか <command>su</command>
	コマンドを用いるかして root 権限を取得します.
	<command>/stand/sysinstall</command> を実行し, <literal>Configure</literal> メニューに入ります.
	<literal>FreeBSD Configuration Menu</literal> の中でスクロールダウンして
	<literal>Partition</literal> の項目を選びます.
	するとシステムに付けられているハードディスクのリストが表示されるはずです. もし <literal>da1</literal>
	がリストされていない場合には物理的な取り付け及び,
	<filename>/var/run/dmesg.boot</filename> ファイルへの <command>dmesg</command>
	出力をチェックし直してください.
      </para>
      
      <para>
        <literal>da1</literal> を選んで <literal>FDISK Partition Editor</literal>
	に入ります. ディスク全体を FreeBSD で使うために <literal>A</literal>
	を選びます. <quote>remain cooperative with any future possible operating systems</quote>
	と聞かれたら <literal>YES</literal> と答えます.
	<command>W</command> で変更をディスクに書き込みます. ここで
	<command>q</command> と入力して FDISK エディタを抜けます.
	マスターブートレコードについて聞かれますが,
	ここでは既に動いているシステムにディスクを追加しようとしているのですから
	<literal>None</literal> を選びます.
      </para>

      <para>
        次に <literal>Disk Label Editor</literal> に入ります.
	ここでは従来の BSD パーティションを作成します. 一つのディスクは
	a から h までのラベルがついた最大 8 つのパーティションを持つことができます.
	いくつかのパーティションラベルは特殊な用途に用いられます.
	<literal>a</literal> パーティションはルートパーティション (<filename>/</filename>) です.
	従って, システムディスク (つまり起動ディスク) のみが <literal>a</literal>
	を持ちます. <literal>b</literal> パーティションはスワップパーティションに用いられ,
	複数のディスクにスワップパーティションを作ることができます.
	<literal>c</literal> は専用モードにおけるディスク全体,
	もしくはスライスモードにおけるスライス全体を指します. 他のパーティションは汎用的に用いられます.
      </para>

      <para>
        sysinstall の Label Editor は非ルートで非スワップなパーティションには <literal>e</literal>
	を好んで付けます.
	ラベルエディタでは <command>C</command> を用いて一つのファイルシステムを作成します.
	FS (ファイルシステム) かスワップかを聞かれたら <literal>FS</literal>
	を選びマウントポイント (例えば <filename>/mnt</filename>) を入力します.
	インストール後のモードでディスクを追加する場合, sysinstall は
	<filename>/etc/fstab</filename> にエントリを追加しないため,
	ここで指定するマウントポイントはそれほど重要ではありません.
      </para>

      <para>
        さて, ディスクに新しいラベルを書き込み, そこにファイルシステムを作る準備が整いました.
	早速 <command>W</command> を叩いて実行しましょう.
	sysinstall からの, 新しいパーティションをマウントできない, というエラーは無視してください.
	Label Editor から抜け, sysinstall を終了します.
      </para>

      <para>
        最後に <filename>/etc/fstab</filename> を編集し, 新しいディスクを追加します.
      </para>
    </sect2>

    <sect2>
      <title>コマンドラインユーティリティの利用</title>

      <sect3>
	<title>スライスの利用</title>

        <para>このセットアップ方法では,
          すでにコンピュータに他のオペレーティングシステムがインストールされていても
          正しく協調動作することが可能で, 他のオペレーティングシステムの
          fdisk ユーティリティを混乱させることもありません.
          新しいディスクにインストールする場合は,
          この方法を用いることが推奨されています.
          後述する<literal>専用モード</literal>は,
          そうしなければならない理由がある時にのみ,
          利用するようにしてください.</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> # 新しいディスクの初期化
&prompt.root; <userinput>disklabel -B -w -r da1s1 auto</userinput> # ディスクにラベルを付ける
&prompt.root; <userinput>disklabel -e da1s1</userinput> # 作成したディスクラベルを編集し, パーティションを追加する
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> # 作成したすべてのパーティションに対してこれを繰り返す
&prompt.root; <userinput>mount -t ufs /dev/da1s1e /1</userinput> # パーティションをマウントする
&prompt.root; <userinput>vi /etc/fstab</userinput> # マウントに成功したら, <filename>/etc/fstab</filename> に適切なエントリを追加する</screen>

        <para>IDE ディスクを使う場合は
          <filename>da</filename> の部分を
          <filename>ad</filename> とします.
          4.x より前のシステムでは,
          (訳注: <filename>ad</filename> ではなく)
          <filename>wd</filename> としてください.</para>
      </sect3>
      
      <sect3>
	<title>専用モード</title>

	<para>
	  新しいドライブを他の OS と共有しない場合には<literal>専用</literal>モードを用いることもできます.
	  このモードはマイクロソフトの OS を混乱させることを憶えておいてください
	  (しかし, それらによって壊されることはありません).
	  一方, IBM の OS/2 はどんなパーティションでも見つけたら理解できなくても<quote>専有</quote>します.
	</para>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 bs=1k count=1</userinput>
&prompt.root; <userinput>disklabel -Brw da1 auto</userinput>
&prompt.root; <userinput>disklabel -e da1</userinput>				# create the `e' partition
&prompt.root; <userinput>newfs -d0 /dev/rda1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>				# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>
      
	<para>もう一つの方法は次の通り.</para>
      
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda1 count=2</userinput>
&prompt.root; <userinput>disklabel /dev/rda1 | disklabel -BrR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/rda1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>					# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="disks-virtual">
    <title>仮想ディスク: ネットワーク, メモリ, そしてファイルベースのファイルシステム</title>

    <para>
      FreeBSD にはフロッピーや CD, ハードディスクなどの手元の計算機に取り付けたディスクの他に,
      別の形態のディスク, <firstterm>仮想ディスク</firstterm>, もあります.
    </para>

    <para>
      これには, <link linkend="nfs">Network Filesystem</link> のようなネットワークファイルシステムや
      Coda, <link linkend="disks-md">md</link> のようなメモリベースのファイルシステム,
      <link linkend="disks-vnconfig">vnconfig</link>
      によって作られるようなファイル中に構築されるファイルシステムがあります.
    </para>

    <sect2 id="disks-vnconfig">
      <title>vnconfig: ファイル中に構築されるファイルシステム</title>

      <para>
        &man.vnconfig.8; を使えば擬似ディスクデバイスを設定し, 有効にすることができます.
	<firstterm>vnode</firstterm> とはファイルの内部的な表現方法であり,
	ファイルに関する操作の中心となるものです. つまり, &man.vnconfig.8;
	はファイルシステムを生成したり操作したりするためにファイルを用いるのです.
	一つ例を挙げると,
	ファイルに収められたフロッピーや CD-ROM のイメージをマウントするために用いることができます.
      </para>

      <para>既にあるファイルシステムイメージのマウント</para>

      <example>
	<title>vnconfig を用いた既存のファイルシステムイメージのマウント</title>

	<screen>&prompt.root; <userinput>vnconfig vn<replaceable>0</replaceable> <replaceable>diskimage</replaceable></userinput>
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>vnconfig を用いたファイルシステムイメージの新規作成</para>

      <example>
	<title>vnconfig を用いたファイルベースディスクの新規作成</title>
	
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>vnconfig -s labels -c vn<replaceable>0</replaceable> <replaceable>newimage</replaceable></userinput>
&prompt.root; <userinput>disklabel -r -w vn<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs vn<replaceable>0</replaceable>c</userinput>
Warning: 2048 sector(s) in last cylinder unallocated
/dev/rvn0c:     10240 sectors in 3 cylinders of 1 tracks, 4096 sectors
        5.0MB in 1 cyl groups (16 c/g, 32.00MB/g, 1280 i/g)
super-block backups (for fsck -b #) at:
 32
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2 id="disks-md">
      <title>md: メモリファイルシステム</title>

      <para>md はメモリファイルシステムを実現するためにシンプルで効率的な手段です.</para>

      <para>単に, 例えば &man.vnconfig.8; を用いて作成したファイルシステムを取り, 以下のようにします.</para>

      <example>
	<title>md メモリディスク</title>

	<screen>&prompt.root; <userinput>dd if=<replaceable>newimage</replaceable> of=/dev/md<replaceable>0</replaceable></userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mount /dev/md<replaceable>0c</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>
  </sect1>
  
  <sect1 id="quotas">
    <title>ディスククォータ</title>

    <para>
      クォータは OS の持っているオプショナルな機能であり,
      ファイルシステム毎にユーザやグループのメンバが使用するディスク容量やファイルの数を制限することができます.
      この機能は, あるユーザやグループに割り当てられるリソースの量を制限することが望ましいようなタイムシェアリングシステムにおいてよく用いられます.
      この機能を用いることによって使用可能なディスク容量の全てを一人のユーザが使ってしまうことを防ぐことができます.
    </para>

    <sect2>
      <title>ディスククォータを使うためのシステム設定</title>

      <para>
        ディスククォータの設定を始める前に, まずはカーネルにクォータが組み込まれていることを確認しましょう.
	カーネルのコンフィグレーションファイルに次の行を入れます.
      </para>

      <programlisting>options QUOTA</programlisting>

      <para>
        標準の <filename>GENERIC</filename> カーネルでは,
	この機能は有効になっていませんので,
	ディスククォータを利用するためには上記を設定後カーネルを構築しなおし,
	作成されたカスタムカーネルをインストールしなければいけません.
	カーネルのコンフィグレーションに関しては
	<link linkend="kernelconfig">FreeBSD カーネルのコンフィグレーション</link>のセクションをご覧ください.
      </para>

      <para>
        次に <filename>/etc/rc.conf</filename>
	でディスククォータを有効にする必要があります.
	次の行を加えましょう.
      </para>

      <programlisting>enable_quotas=<quote>YES</quote></programlisting>

      <para>
        起動時の動作をさらに細かくコントロールするためにもう一つ設定用の変数があります.
	通常, 起動時には <command>quotacheck</command>
	によりそれぞれのファイルシステムのクォータの整合性がチェックされます.
	<command>quotacheck</command> の役割は,
	クォータデータベースのデータが正しくファイルシステム上のデータを反映しているか確認することです.
	これはかなり時間を食う処理であり, 起動にかかる時間に大きな影響を及ぼします.
	このステップをとばしたい人のために次の変数が用意されています.
      </para>

      <programlisting>check_quotas=<quote>NO</quote></programlisting>

      <para>
        もし 3.2-RELEASE よりも前の FreeBSD を使っているならば設定はもっと単純で, 一つの変数のみです.
	次の行を <filename>/etc/rc.conf</filename> で設定してください.
      </para>

      <programlisting>check_quotas=<quote>YES</quote></programlisting>

      <para>
        最後に, ファイルシステム毎にディスククォータを有効にするために
	<filename>/etc/fstab</filename> を編集する必要があります.
	ここでユーザもしくはグループ, あるいはその両方にクォータを設定することができるのです.
      </para>

      <para>
        あるファイルシステム上にユーザ毎のクォータを有効にする場合には,
	<filename>/etc/fstab</filename> 中でクォータを有効にしたいファイルシステムエントリのオプション部に
	<literal>userquota</literal> を加えます. 例えば次のようになります.
      </para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>
        同様に, グループクォータを有効にするには <literal>userquota</literal>
	キーワードの代わりに <literal>groupquota</literal> を用います.
	ユーザとグループの両方のクォータを有効にするには次のようにします.
      </para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>
        デフォルトでは, クォータファイルはそのファイルシステムのルートディレクトリに
	ユーザ用, グループ用それぞれ <filename>quota.user</filename>, <filename>quota.group</filename>
	という名前で置かれます. さらに詳しい情報は <command>man fstab</command>
	をご覧ください. マニュアルには別の場所を指定することができると書いてはありますが,
	あまり勧められません. なぜなら, 様々なクォータ関係のユーティリティがそれにうまく対処できるようにないためです.
      </para>

      <para>
        この時点で, 一度システムを再起動して新しいカーネルで立ち上げましょう.
	<filename>/etc/rc</filename> が自動的に適当なコマンドを実行し,
	<filename>/etc/fstab</filename> で有効にした全てのクォータ用に初期ファイルを作ってくれます.
	従って, 空のクォータファイルを手で作る必要は一切ありません.
      </para>

      <para>
        通常の運用では <command>quotacheck</command> や <command>quotaon</command>,
	<command>quotaoff</command> といったコマンドを手で動かす必要はないのですが,
	慣れるためにもこれらのマニュアルは読んでおきましょう.
      </para>
    </sect2>

    <sect2>
      <title>クォータリミットの設定</title>

      <para>
        一旦クォータを有効にしたら本当に有効になっているのか確認しておきましょう.
	簡単な方法は次のコマンドを実行することです.
      </para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>
	  
      <para>
        ディスクの使用状況と, クォータが有効になっているファイルシステムのクォータリミットが一行にまとめて出力されるでしょう.
      </para>

      <para>
        さあ、<command>edquota</command> でクォータリミットを設定する準備ができました.
      </para>

      <para>
        ユーザやグループが使用できるディスク容量や作成できるファイルの数に制限をかけるにはいくつかのオプションがあります.
	割り当てディスク容量を制限 (ブロッククォータ) することもファイル数を制限 (inode クォータ)
	することも, 両者を組み合わせることもできるのです. これらの制限はそれぞれさらに二つのカテゴリ,
	ハードリミットとソフトリミット, に分けることができます.
      </para>

      <para>
        ハードリミットを越えることはできません. あるユーザが一旦ハードリミットにたっした場合,
	そのファイルシステムではそれ以上の割り当ては望めません. 例えばあるファイルシステム上に
	500 ブロックのハードリミットが設定されており現在 490 ブロックを使用している場合,
	さらに 10 ブロックしか使えないのです. 11 ブロックを使おうとすると失敗します.
      </para>

      <para>
        一方, ソフトリミットはある限られた時間内であれば越えることができます.
	この時間は猶予期間として知られており, デフォルトでは 1 週間です.
	あるユーザが自分のソフトリミットを猶予期間よりも長い間越えているとソフトリミットはハードリミットに変わり,
	それ以上使用することはできなくなります. ユーザがソフトリミットよりも減らせば猶予期間はリセットされます.
      </para>

      <para>
        以下は <command>edquota</command> コマンドを実行した時に見ることになるであろう例です.
	<command>edquota</command> コマンドが起動されると環境変数 <envar>EDITOR</envar>
	で指定されるエディタに入ります. <envar>EDITOR</envar> が設定されていない場合には
	<command>vi</command> が起動されます. ここでクォータリミットを編集します.
      </para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: blocks in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: blocks in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>
        通常, クォータが有効になっているファイルシステム毎に 2 行あります.
	一つはブロックリミット用でもう一つは inode リミット用です.
	クォータリミットを変更したいところを書き変えるだけでかまいません.
	例えばこのユーザのブロックリミットを, 「ソフトリミットは 50 で ハードリミットは 75」から「ソフトリミットは
	500 で ハードリミットは 600」に変更する場合,
      </para>

      <programlisting>/usr: blocks in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>から</para>

      <programlisting> /usr: blocks in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>へ書き換えます. 新しいクォータリミットはエディタを終了すれば設定されます.</para>

      <para>
        ある範囲の uid に対してクォータリミットを設定したい場合がありますが,
	このような時には <command>edquota</command> コマンドの <option>-p</option> オプションを使うといいでしょう.
	まず, あるユーザに割り当てたいクォータリミットを設定し, 次に
	<command>edquota -p protouser startuid-enduid</command>
	を実行するのです. 例えばユーザ <username>test</username> にお望みのクォータリミットが付いているとしましょう.
	次のコマンドにより 10,000 から 19,999 の間の uid に対して同じクォータリミットを付けることができるのです.
      </para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>
	  
      <para>
        さらに詳しいことは <command>man edquota</command> をご覧ください.
      </para>
    </sect2>

    <sect2>
      <title>クォータリミットとディスク使用状況のチェック</title>

      <para>
        <command>quota</command> や <command>repquota</command> といったコマンドを使ってクォータリミットやディスクの利用状況をチェックすることができます.
	<command>quota</command> コマンドは個々のユーザやグループのクォータやディスク利用状況をチェックするのに使えます.
	スーパーユーザのみが他のユーザや所属していないグループのクォータと利用状況を見ることができます.
	<command>repquota</command> コマンドはクォータが有効になっているファイルシステム用の全てのクォータやディスク容量のサマリを得るのに使えます.
      </para>

      <para>
        以下は二つのファイルシステムにクォータ制限がかけられているユーザに対する
	<command>quota -v</command> コマンドの出力例です.
      </para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <para>
        上の例で, <filename>/usr</filename> ファイルシステム上ではこのユーザは現在
	50 ブロックというソフトリミットを 15 ブロックオーバーし 5 日間の猶予期間が残っています.
	アスタリスク <literal>*</literal> はクォータリミットを越えているユーザを示していることに注意してください.
      </para>

      <para>
        通常, そのユーザが全く使っていないファイルシステムは, クォータリミットが付けられているとしても
	 <command>quota</command> コマンドの出力には現われません.
	 <option>-v</option> オプションを用いればそのようなファイルシステム, 上の例では <filename>/usr/var</filename>,
	 を表示することができます.
      </para>
    </sect2>

    <sect2>
      <title>NFS 上の クォータ</title>

      <para>
        クォータは NFS サーバ上のクォータサブシステムにより実行されます.
	&man.rpc.rquotad.8; デーモンにより, NFS クライアント上の &man.quota.1;
	コマンドは情報を得ることができ, クライアントマシン上のユーザが自分のクォータの統計を見ることができます.
      </para>

      <para>
        <filename>/etc/inetd.conf</filename> において以下のように
        <command>rpc.rquotad</command> を有効にしましょう.
      </para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>そして以下のように <command>inetd</command> を再起動します.</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
    </sect2>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
