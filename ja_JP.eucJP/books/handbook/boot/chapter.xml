<?xml version="1.0" encoding="euc-jp"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: r42014
     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="boot">
  <title>&os; の起動のプロセス</title>

  <sect1 xml:id="boot-synopsis">
    <title>この章では</title>

    <indexterm><primary>起動</primary></indexterm>
    <indexterm><primary>ブートストラップ (bootstrap)</primary></indexterm>

    <para>計算機を起動しオペレーティングシステムをロードするプロセスは、
      <quote>ブートストラッププロセス</quote>、
      もしくは単に <quote>起動</quote> と呼ばれます。
      &os; の起動プロセスを使えば、
      システムをスタートするときに起きることをかなり柔軟にカスタマイズすることができます。
      同じ計算機にインストールされた別のオペレーティングシステムを選択することもできますし、
      同じオペレーティングシステムの違うバージョンを選択することも、
      インストールされた別のカーネルを選択することさえできます。</para>

    <para>この章では、指定できる設定オプションついて詳しく説明します。
      &os; カーネルがスタートし、デバイスを検出し、
      &man.init.8; を起動するまでに起きることすべてを含む
      &os; の起動プロセスのカスタマイズ方法について説明します。
      これは、起動メッセージのテキストの色が、
      明るい白から灰色に変わるまでに起きています。</para>

    <para>この章を読むと、以下のことが分かります。</para>

    <itemizedlist>
      <listitem>
	<para>&os;
	  のブートストラップシステムの構成およびそれらが互いにどう関係しているのか</para>
      </listitem>

      <listitem>
	<para>起動プロセスを制御するために &os;
	  のブートストラップの各要素に付加できるオプション</para>
      </listitem>

      <listitem>
	<para>&man.device.hints.5; の基本的な記述方法</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>この章では Intel x86 システム上で動作する &os;
	の起動プロセスだけを扱います。</para>
    </note>
  </sect1>

  <sect1 xml:id="boot-introduction">
    <title>起動時の問題</title>

    <para>計算機の電源を入れ、オペレーティングシステムをスタートさせるのには、
      おもしろいジレンマがあります。定義により、
      計算機は、オペレーティングシステムが起動するまでは、
      ディスクからプログラムを動かすことも含めて、
      何をどうすればよいかまったく知りません。
      計算機はオペレーティングシステムなしにディスクからプログラムを実行することができず、
      オペレーティングシステムのプログラムがディスク上にあるのなら、
      どうやってオペレーティングシステムを起動するのでしょうか?</para>

    <para>この問題は<citetitle>ほらふき男爵の冒険</citetitle>
      という本の中に書かれている問題ととてもよく似ています。
      登場人物がマンホールの下に半分落っこちて、
      靴紐 (ブートストラップ) をつかんで自分を引っぱり、持ち上げるのです。
      計算機の黎明期には、<firstterm>ブートストラップ</firstterm>
      という用語でオペレーティングシステムをロードする機構のことを指していたのですが、
      いまはこれを縮めて <quote>ブート (起動)</quote> と言います。</para>

    <indexterm><primary><acronym>BIOS</acronym></primary></indexterm>

    <indexterm>
      <primary>基本入出力システム (Basic Input/Output System)</primary>
      <see><acronym>BIOS</acronym></see>
    </indexterm>

    <para>x86 ハードウェアでは、基本入出力システム
      (Basic Input/Output System: <acronym>BIOS</acronym>)
      にオペレーティングシステムをロードする責任があります。
      オペレーティングシステムをロードするために、
      <acronym>BIOS</acronym> がハードディスク上のマスターブートレコード
      (Master Boot Record: <acronym>MBR</acronym>) を探します。
      <acronym>MBR</acronym>
      はハードディスク上の特定の場所になければなりません。
      <acronym>BIOS</acronym> には <acronym>MBR</acronym>
      をロードし起動するのに十分な知識があり、
      オペレーティングシステムをロードするために必要な作業の残りは、
      場合によっては <acronym>BIOS</acronym> の助けを得た上で
      <acronym>MBR</acronym> が実行できることを仮定しています。</para>

    <indexterm><primary>マスターブートレコード (Master Boot Record:
	<acronym>MBR</acronym>)</primary></indexterm>

    <indexterm><primary>ブートマネージャ
      (Boot Manager)</primary></indexterm>

    <indexterm><primary>ブートローダ
      (Boot Loader)</primary></indexterm>

    <para><acronym>MBR</acronym> 内部のコードは、
      通常<emphasis>ブートマネージャ</emphasis>と呼ばれます。
      とりわけユーザとの対話がある場合にそう呼ばれます。
      その場合は、通常もっと多くのブートマネージャのコードが、
      ディスクの最初の<emphasis>トラック</emphasis>
      またはオペレーティングシステムのファイルシステム上におかれます
      ブートマネージャは<emphasis>ブートローダ</emphasis>
      と呼ばれることもありますが、
      &os; はこの言葉を起動のもっと後の段階に対して使います。
      よく使われるブートマネージャには、<application>Boot Easy</application>
      とも呼ばれる &os; 標準のブートマネージャの
      <application>boot0</application>,
      <application>Grub</application>, <application>GAG</application> や
      <application>LILO</application> 等があります。
      <acronym>MBR</acronym> 内に収まるのは
      <application>boot0</application> だけです。</para>

    <para>ディスク上にインストールされているオペレーティングシステムが
      1 つであれば、標準の PC <acronym>MBR</acronym> で十分です。
      この <acronym>MBR</acronym> はディスク上の最初の起動可能な
      (アクティブな) スライスを探し、
      そのスライスにあるコードを起動してオペレーティングシステムの残りをロードします。
      デフォルトで &man.fdisk.8; がインストールする <acronym>MBR</acronym>
      は、このような <acronym>MBR</acronym> で、<filename>/boot/mbr</filename>
      を基にしています。</para>

    <para>ディスク上に複数のオペレーティングシステムが存在しているのなら、
      複数のオペレーティングシステムの一覧を表示できて、
      起動するオペレーティングシステムを選択できるような、
      別のブートマネージャをインストールすることもできます。
      次の節では 2 つのブートマネージャについて説明します。</para>

    <para>&os; のブートストラップシステムの残りは 3 段階に分かれます。
      第 1 ステージは <acronym>MBR</acronym> によって起動されるもので、
      MBR は計算機を特定の状態にするために必要なことだけ知っていて、
      第 2 ステージを起動します。
      第 2 ステージでは、第 3 ステージを起動する前に、
      もうちょっとやることができます。
      第 3 ステージでオペレーティングシステムのロード作業を完了します。
      起動作業が 3 段階に分かれているのは、
      PC の規格がステージ 1 とステージ 2
      で実行できるプログラムのサイズに制限を課しているからです。
      これらの作業をつなぎ合わせることによって、
      &os; はより柔軟なローダ (loader) を提供しているのです。</para>

    <indexterm><primary>カーネル (kernel)</primary></indexterm>
    <indexterm><primary>&man.init.8;</primary></indexterm>

    <para>その後カーネルが起動し、デバイスの検出と初期化を開始します。
      そしてカーネルの起動が終わると、制御はユーザープロセスの
      &man.init.8; へ移されます。&man.init.8;
      はまずディスクが利用可能であることを確かめ、
      ファイルシステムのマウント、
      ネットワークで利用するネットワークカードのセットアップ、
      そして起動時に &os; システムで起動されるように設定されたプロセスの起動、
      といったユーザーレベルでのリソース (資源) 設定を行ないます。</para>
  </sect1>

  <sect1 xml:id="boot-blocks">
    <title>ブートマネージャと起動ステージ</title>

    <indexterm><primary>ブートマネージャ</primary></indexterm>

    <sect2 xml:id="boot-boot0">
      <title>ブートマネージャ</title>

      <indexterm><primary>マスターブートレコード
	  (<acronym>MBR</acronym>)</primary></indexterm>

      <para><acronym>MBR</acronym>
	やブートマネージャのコードは起動プロセスの<emphasis>第
	0 ステージ</emphasis>と呼ばれることがあります。
	この節では 2 つのブートマネージャ、
	<application>boot0</application> と <application>LILO</application>
	について説明します。</para>

      <formalpara><title><application>boot0</application>
	ブートマネージャ</title>

	<para>&os; のインストーラや &man.boot0cfg.8;
	  がインストールする <acronym>MBR</acronym> は、
	  <filename>/boot/boot0</filename> を基にしています。
	  <application>boot0</application> のサイズと機能は、
	  スライステーブルおよび <acronym>MBR</acronym>
	  末尾の識別子 <literal>0x55AA</literal>
	  のため、446 バイトの大きさに制限されます。もし、
	  <application>boot0</application>
	  と複数のオペレーティングシステムをインストールした場合、
	  起動時に以下のようなメッセージが表示されます。</para>
      </formalpara>

      <example xml:id="boot-boot0-example">
	<title><filename>boot0</filename> のスクリーンショット</title>

	<screen>F1 Win
F2 FreeBSD

Default: F2</screen>
      </example>

      <para>他のオペレーティングシステム、特に &windows; は、
	&os; の後にインストールを行うと、既存の <acronym>MBR</acronym>
	を上書きしてしまいます。
	もしそうなってしまったら、
	もしくは既存の <acronym>MBR</acronym> を &os; の
	<acronym>MBR</acronym> で置き換えるには、
	次のコマンドを使ってください。</para>

      <screen>&prompt.root; <userinput>fdisk -B -b /boot/boot0 device</userinput></screen>

      <para><replaceable>device</replaceable> は起動するデバイス名で、
	たとえば 1 番目の <acronym>IDE</acronym> ディスクは
	<filename>ad0</filename>、2 番目の <acronym>IDE</acronym>
	コントローラに接続されている 1 番目の <acronym>IDE</acronym>
	ディスクは <filename>ad2</filename>、
	1 番目の <acronym>SCSI</acronym> ディスクは
	<filename>da0</filename>
	などとなります。
	<acronym>MBR</acronym> の設定をカスタマイズしたい場合は、
	&man.boot0cfg.8; を参照してください。</para>

      <formalpara>
	<title>LILO ブートマネージャ</title>

	<para>このブートマネージャをインストールして &os;
	  を起動するようにするには、Linux を起動して
	  <filename>/etc/lilo.conf</filename>
	  コンフィグレーションに以下を追加してください。</para>
      </formalpara>

      <programlisting>other=/dev/hdXY
table=/dev/hdX
loader=/boot/chain.b
label=FreeBSD</programlisting>

      <para>&os; のプライマリパーティションとドライブを
	Linux の識別子を使って指定してください。
	<replaceable>X</replaceable> を Linux のドライブ文字に、また
	<replaceable>Y</replaceable> を Linux
	のプライマリパーティション番号に置き換えてください。
	<acronym>SCSI</acronym> ドライブに対しては、
	<replaceable>/dev/hd</replaceable> を
	<replaceable>/dev/sd</replaceable> に変えてください。
	同じドライブ上に両方のオペレーティングシステムが置いてあるなら、
	<option>loader=/boot/chain.b</option> 行は不要です。
	次に <command>/sbin/lilo&nbsp;-v</command>
	を実行して、新しい変更を反映してください。
	画面のメッセージを見て変更を確認してください。</para>
    </sect2>

    <sect2 xml:id="boot-boot1">
      <title>起動ステージ 1 <filename>/boot/boot1</filename>
	と起動ステージ 2 <filename>/boot/boot2</filename></title>

      <para>概念上、第 1 ステージと第 2
	ステージはハードディスクの同じ領域上の同一のプログラムの部分部分です。
	スペースの制約のため 2 つに分割されていますが、
	いつも一緒にインストールされます。
	インストーラまたは &man.bsdlabel.8; は、両者を 1 つにまとめた
	<filename>/boot/boot</filename> をコピーします。</para>

      <para>第 1 ステージと第 2 ステージは、ファイルシステムの外部、
	起動スライスの最初のトラックに置かれ、
	先頭が最初のセクタにきます。
	boot0 (<xref linkend="boot-boot0"/>)
	またはその他のブートマネージャは、
	起動プロセスを続けるために必要なプログラムがそこにあると想定しています。
	使用されるセクタの数は、<filename>/boot/boot</filename>
	の大きさから簡単に分かります。</para>

      <para><filename>boot1</filename> は
	512 バイトの大きさでなければならないという制限があるので、
	非常に単純なプログラムです。
	このプログラムは <filename>boot2</filename> を検索し、
	実行するため、そのスライスの情報を保持する &os;
	の <firstterm>BSD ラベル</firstterm>
	に関する最低限の情報だけを持っています。</para>

      <para><filename>boot2</filename> はもう少し高機能です。
	これは &os; のファイルシステム上でファイルを見つける機能を持ち、
 	実行するカーネルやローダを指定するための簡単なインタフェースを提供します。</para>

      <para>しかしながら <filename>boot2</filename> により起動される
	&man.loader.8;
	はさらに高機能で、起動設定が行なえる手段を提供します。</para>

      <example xml:id="boot-boot2-example">
	<title><filename>boot2</filename> のスクリーンショット</title>

	<screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>
      </example>

      <para>&man.bsdlabel.8; を用いて、
	インストールされた <filename>boot1</filename> と
	<filename>boot2</filename> を変更できます。</para>

      <screen>&prompt.root; <userinput>bsdlabel -B diskslice</userinput></screen>

      <para><replaceable>diskslice</replaceable>
	は起動するディスクとスライスで、
	たとえば最初の <acronym>IDE</acronym> ディスクの 1 番目のスライスは
	<filename>ad0s1</filename> となります。</para>

      <warning>
	<title>Dangerously Dedicated Mode</title>

	<para><filename>ad0</filename> のようにディスク名だけを指定すると、
	  &man.bsdlabel.8; は、スライスを持たない
	  <quote>危険な専用ディスク</quote>を作成してしまいます。
	  これはおそらく、あなたが望んでいることではないでしょうから、
	  <keycap>Return</keycap> キーを押す前に、
	  &man.bsdlabel.8; に与える <replaceable>diskslice</replaceable>
	  の部分を二重にチェックしてください。</para>
      </warning>
    </sect2>

    <sect2 xml:id="boot-loader">
      <title>起動ステージ 3 <filename>/boot/loader</filename></title>

      <indexterm><primary>ブートローダ (boot-loader)</primary></indexterm>

      <para>ローダは三段階の起動プロセスの最終段階です。
	ローダは通常、ファイルシステム上の
	<filename>/boot/loader</filename>
	として存在しています。</para>

      <para>ローダは、
	よりさまざまなコマンド群をサポートした強力なインタプリタによって提供される組み込みコマンド群を利用することで、
	インタラクティブな設定手段となるように設計されています。</para>

      <sect3 xml:id="boot-loader-flow">
	<title>ローダプログラムの処理の流れ</title>

	<para>ローダは初期化の際にコンソールとディスクの検出を行ない、
	  どのディスクから起動しているかを調べます。
	  そして必要な変数を設定してからインタプリタを起動し、
	  スクリプトからコマンドを送ったり手でコマンドを入力したりできます。</para>

	<indexterm><primary>ローダ</primary></indexterm>
	<indexterm><primary>ローダの設定</primary></indexterm>

	<para>ローダは次に <filename>/boot/loader.rc</filename>
	  を読み込み、通常、変数の標準値を定義した
	  <filename>/boot/defaults/loader.conf</filename>
	  と、そのマシンにローカルな変数を定義した
	  <filename>/boot/loader.conf</filename>
	  を読み込みます。
	  <filename>loader.rc</filename> はそれらの変数にもとづき、
	  選択されたモジュールとカーネルをロードします。</para>

	<para>ローダは最後に、標準設定で 10 秒のキー入力待ち時間を用意し、
	  入力がなければカーネルを起動します。
	  入力があった場合、コマンド群が使えるプロンプトが表示され、
	  ユーザは変数を調整したり、
	  すべてのモジュールをアンロードしたり、
	  モジュールをロードしたりすることができます。
	  その後、最終的な起動や再起動へ移行します。</para>
      </sect3>

      <sect3 xml:id="boot-loader-commands">
	<title>ローダの組み込みコマンド</title>

	<para>もっともよく使われるローダのコマンドを以下に示します。
	  利用可能なコマンドをすべて知りたい場合には、
	  &man.loader.8; を参照してください。</para>

	<variablelist>
	  <varlistentry>
	    <term>autoboot <replaceable>seconds</replaceable></term>

	    <listitem>
	      <para><replaceable>seconds</replaceable>
	        で与えられた時間内に入力がなければ、
	        カーネルの起動へと進みます。
	        カウントダウンを表示し、標準設定では 10 秒間です。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>boot
	      <optional>-options</optional>
	      <optional>kernelname</optional></term>

	    <listitem>
	      <para>すぐにカーネルの起動へ進みます。
		オプション、カーネル名が指定されている場合は、
		それらが使われます。
		<emphasis>unload</emphasis> コマンドを実行後、
		カーネル名をコマンドラインから指定することができます。
		<emphasis>unload</emphasis> を実行しないと、
		一度読み込まれたカーネルが使われます。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>boot-conf</term>

	    <listitem>
	      <para>すべてのモジュールの設定を、
		起動時と同じように指定された変数
		(最も多いのは <envar>kernel</envar>)
		にもとづいて自動的に行ないます。
		このコマンドは、変数を変更する前に、
		最初に <command>unload</command>
		を行なった場合にのみ有効に働きます。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>help
	      <optional>topic</optional></term>

	    <listitem>
	      <para><filename>/boot/loader.help</filename>
		を読み込み、ヘルプメッセージを表示します。
		topic に <literal>index</literal> が指定された場合、
		利用可能な topic の一覧を表示します。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>include <replaceable>filename</replaceable>
	      &hellip;</term>

	    <listitem>
	      <para>指定されたファイル名のファイルを処理します。
		ローダはファイルを読み込み、行単位で解釈します。
		エラーが発生した場合、
		include コマンドの実行はその時点で停止します。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>load <optional>-t type</optional>
	      <replaceable>filename</replaceable></term>

	    <listitem>
	      <para>指定されたファイル名のカーネル、
		カーネルモジュール、あるいは
		type に指定された種類のファイルをロードします。
		<replaceable>filename</replaceable>
		以降に指定された引数はファイルへと渡されます。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>ls <optional>-l</optional>
	      <optional>path</optional></term>

	    <listitem>
	      <para>指定された <replaceable>path</replaceable>
		にあるファイルを表示します。
		<replaceable>path</replaceable>
		が指定されていなければ、ルートディレクトリを表示します。
		<option>-l</option>
		が指定されていればファイルサイズも表示されます。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>lsdev
	      <optional>-v</optional></term>

	    <listitem>
	      <para>モジュールがロード可能なすべてのデバイスを表示します。
		もし <option>-v</option> が指定されていれば、
		より詳細な出力がされます。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>lsmod
	      <optional>-v</optional></term>

	    <listitem>
	      <para>ロード済みのモジュールを表示します。
		<option>-v</option> が指定されていれば、
		より詳細な内容が出力されます。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>more <replaceable>filename</replaceable></term>

	    <listitem>
	      <para><varname>LINES</varname>
		行を表示するごとに停止しながら指定されたファイルを表示します。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>reboot</term>

	    <listitem>
	      <para>すぐにシステムを再起動します。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>set <replaceable>variable</replaceable></term>
	    <term>set
	      <replaceable>variable</replaceable>=<replaceable>value</replaceable></term>

	    <listitem>
	      <para>ローダの環境変数を設定します。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>unload</term>

	    <listitem>
	      <para>すべてのロード済みモジュールを削除します。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3 xml:id="boot-loader-examples">
	<title>ローダの使用例</title>

	<para>次にあげるのは、ローダの実践的な使用例です。</para>

	<indexterm><primary>シングルユーザモード</primary></indexterm>

	<itemizedlist>
	  <listitem>
	    <para>普段使っているカーネルをシングルユーザモードで起動します。</para>

	    <screen><userinput>boot -s</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>普段使っているカーネルとモジュールをアンロードし、
	      古い (もしくは別の) カーネルをロードします。</para>

	    <screen><userinput>unload</userinput>
<userinput>load kernel.old</userinput></screen>

	    <para><filename>kernel.GENERIC</filename> とすると、
	      インストール時のデフォルトカーネルを指定できます。
	      また、システムをアップグレードしたり、
	      もしくはカスタムカーネルを設定した場合に、
	      直前にインストールされていたカーネルは、
	      <filename>kernel.old</filename><indexterm><primary><filename>kernel.old</filename></primary></indexterm> で指定できます。</para>

	    <note>
	      <para>普段のカーネルで使っているモジュールを指定したカーネルでロードする場合は、
		次のようにします。</para>

	      <screen><userinput>unload</userinput>
<userinput>set kernel="kernel.old"</userinput>
<userinput>boot-conf</userinput></screen></note>
	  </listitem>

	  <listitem>
	    <para>カーネルの自動設定スクリプトをロードします。</para>

	    <screen><userinput>load -t userconfig_script /boot/kernel.conf</userinput></screen>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3 xml:id="boot-splash">
	<info><title>起動時のスプラッシュスクリーン</title>
	  <authorgroup>
	    <author>
	      <personname>
		<firstname>Joseph J.</firstname>
		<surname>Barbish</surname>
	      </personname>
	      <contrib>寄稿: </contrib>
	    </author>
	  </authorgroup>
	</info>

	<para>スプラッシュスクリーンは、
	  これまでとは別の起動画面を表示します。
	  スプラッシュスクリーンは、
	  コマンドラインまたはグラフィカルなログインプロンプトが表示されるまで、
	  起動時の検出メッセージやサービスのスタートアップメッセージを隠します。</para>

	<para>&os; には、2 つの基本環境があります。
	  ひとつは、レガシーなバーチャルコンソールコマンドライン環境です。
	  システムの起動が終わったら、
	  コンソールにログインプロンプトが表示されます。
	  2 つ目の環境は、<xref linkend="x11"/>
	  で説明されているグラフィカル環境です。
	  <xref linkend="x11"/> では、
	  グラフィカルディスプレイマネージャやグラフィカルログインマネージャのインストールおよび設定方法について説明しています。</para>

	<sect4 xml:id="boot-splash-function">
	  <title>スプラッシュスクリーン機能</title>

	  <para>スプラッシュスクリーン機能は、
	    256 色のビットマップ (<filename>.bmp</filename>),
	    ZSoft <acronym>PCX</acronym> (<filename>.pcx</filename>) または
	    TheDraw (<filename>.bin</filename>) 形式に対応しています。
	    標準の VGA アダプタで動かすには、
	    スプラッシュイメージファイルは 320x200
	    ピクセル以下の解像度である必要があります。</para>

	  <para>(最大解像度 1024x768 ピクセルまでの)
	    もう少し大きなイメージを使いたい場合には、
	    システムの起動時に
	    <acronym>VESA</acronym> モジュールをロードしてください。
	    <xref linkend="kernelconfig"/>
	    で説明されるカスタムカーネルに対しては、<acronym>VESA</acronym>
	    カーネルコンフィグレーションオプションを追加してください。
	    <acronym>VESA</acronym> のサポートをロードすることで、
	    フルスクリーンでスプラッシュスクリーンを表示できるようになります。</para>

	  <para>スプラッシュスクリーンは、起動プロセスの間、
	    画面に表示されますが、
	    キーボードから何かのキーを押すことで、
	    いつでもやめることができます。</para>

	  <para>スプラッシュスクリーンは、
	    スクリーンセーバのデフォルトでもあります。
	    一定期間使われないと、
	    スプラッシュスクリーンが表示され、
	    イメージの輝度が、明るくから暗くなるように変化し、
	    そのサイクルが繰り返されます。
	    スプラッシュスクリーンセーバの設定は、
	    <filename>/etc/rc.conf</filename> に
	    <literal>saver=</literal> 行を追加することで変更できます。
	    いくつかのビルトインのスクリーンセーバが用意されており、
	    &man.splash.4; で説明されています。
	    <literal>saver=</literal> オプションは、
	    仮想コンソールにのみ適用され、
	    グラフィカルディスプレイマネージャには影響しません。</para>

	  <para>スプラッシュスクリーンを有効に設定していても、起動時には、
	    ブートオプションメニューや、
	    タイムウェイトカウントダウンプロンプトなどのブートローダメッセージは表示されます。</para>

	  <para><link
	      xlink:href="http://artwork.freebsdgr.org/node/3/">http://artwork.freebsdgr.org</link>
	    のギャラリから、
	    サンプルのスプラッシュスクリーンファイルをダウンロードできます。
	    <filename
	      role="package">sysutils/bsd-splash-changer</filename>
	    port をインストールすると、
	    起動時にスプラッシュイメージのコレクションからランダムに一枚が選択されます。</para>
	</sect4>

	<sect4 xml:id="boot-splash-enable">
	  <title>スプラッシュスクリーン機能を有効にする</title>

	  <para>スプラッシュスクリーン <filename>.bmp</filename>,
	    <filename>.pcx</filename> または <filename>.bin</filename>
	    イメージは、ルートパーティション、たとえば
	    <filename class="directory">/boot</filename>
	    に置く必要があります。</para>

	  <para>デフォルトのブートディスプレイの解像度
	    256 色、320x200 ピクセル以下の場合には、
	    以下を含むように
	    <filename>/boot/loader.conf</filename> を編集してください。</para>

	  <programlisting>splash_bmp_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bmp</replaceable>"</programlisting>

	  <para>1024x768 ピクセルまでの、より大きなビデオ解像度の場合には、
	    以下を含むように <filename>/boot/loader.conf</filename>
	    を編集してください。</para>

	  <programlisting>vesa_load="YES"
splash_bmp_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bmp</replaceable>"</programlisting>

	  <para>上の例では、スプラッシュスクリーンに
	    <filename><replaceable>/boot/splash.bmp</replaceable></filename>
	    を使うことを想定しています。
	    <acronym>PCX</acronym> ファイルを使う場合は、
	    以下を使ってください。
	    また、解像度によっては
	    <literal>vesa_load="YES"</literal> 行を追加してください。</para>

	  <programlisting>splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.pcx</replaceable>"</programlisting>

	  <para>&os;&nbsp;8.3 からは、<link
	      xlink:href="https://en.wikipedia.org/wiki/TheDraw">TheDraw</link>
	    形式によるアスキーアートを使うことができるようになりました。</para>

	  <programlisting>splash_txt="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bin</replaceable>"</programlisting>

	  <para>ファイル名は上記のような
	    <quote>splash</quote> に限られているわけではありません。
	    対応している形式であれば、
	    <filename><replaceable>splash_640x400</replaceable>.bmp</filename>
	    や <filename><replaceable>bluewave</replaceable>.pcx</filename>
	    といった、どのような名前でも構いません。</para>

	  <para>他に興味を持ちそうな <filename>loader.conf</filename>
	    のオプションを以下で紹介します。</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>beastie_disable="YES"</literal></term>

	      <listitem>
		<para>カウントダウンのプロンプトを除き、
		  ブートオプションメニューを表示しません。
		  ブートオプションメニューの画面は利用できませんが、
		  タイムウェイトカウントダウンプロンプトが表示されている時に、
		  オプションを選択することで対応するブートオプションを設定できます。</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>loader_logo="beastie"</literal></term>

	      <listitem>
		<para>このオプションは、カラーの beastie
		  ロゴと共にブートオプションメニューの右側に表示されている単語
		  (デフォルトでは <quote>&os;</quote>) を置き換えます。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>より詳細な情報については、&man.splash.4;,
	    &man.loader.conf.5; および &man.vga.4; をご覧ください。</para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="boot-kernel">
    <title>カーネル起動時の応答</title>

    <indexterm>
      <primary>カーネル (kernel)</primary>
      <secondary>起動時の応答</secondary>
    </indexterm>

    <para>カーネルがデフォルトのローダ (<xref linkend="boot-loader"/>)
      もしくはローダを迂回して boot2 (<xref
	linkend="boot-boot1"/>) によって読み込まれると、
      起動フラグが調べられ、それに応じて動作が調整されます。</para>

    <sect2 xml:id="boot-kernel-bootflags">
      <title>カーネル起動フラグ</title>
      <indexterm>
	<primary>カーネル (kernel)</primary>
	<secondary>起動フラグ</secondary>
      </indexterm>

      <para>良く使われる起動フラグは次のとおりです。</para>

      <variablelist xml:id="boot-kernel-bootflags-list">
	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>カーネル初期化中に、
	      ルートファイルシステムとしてマウントするデバイスを尋ねます。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-C</option></term>

	  <listitem>
	    <para>CDROM から起動します。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-c</option></term>

	  <listitem>
	    <para>起動時にカーネルコンフィグレーションを行なう
	      UserConfig を実行します。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-s</option></term>

	  <listitem>
	    <para>シングルユーザモードで起動します。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>カーネル起動時により詳細な情報を表示します。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note>
	<para>上記以外の起動フラグの詳細については、
	  &man.boot.8; を参照してください。
	</para>
      </note>
    </sect2>

<!--    <sect2 id="boot-kernel-userconfig">
      <title>UserConfig: The Boot-time Kernel Configurator</title>

      <para> </para>
    </sect2> -->
  </sect1>

  <sect1 xml:id="device-hints">
    <info><title>Device Hints</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>寄稿: </contrib></author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>device.hints</primary>
    </indexterm>

    <para>システムの最初のスタートアップ時に、&man.loader.8; は
      &man.device.hints.5; を読み込みます。
      このファイルにはカーネル起動の環境変数が格納されており、
      これらの環境変数は <quote>device hints</quote>
      と呼ばれることがあります。<quote>device hints</quote>
      はデバイスを設定するためにデバイスドライバが使用します。</para>

    <para><xref linkend="boot-loader"/> で説明されているように
      device hints はステージ 3 ブートローダプロンプトでも設定できます。
      変数は <command>set</command> を用いて追加したり、
      <command>unset</command> を用いて削除できます。
      <command>show</command> を用いて一覧を見ることもできます。
      <filename>/boot/device.hints</filename> に設定されている変数は、
      上書きすることもできます。
      ブートローダで設定した device hints の効果は一時的なものであるため、
      次回起動するときには無効になります。</para>

    <para>システムが起動すると、&man.kenv.1;
      コマンドですべてのカーネル環境変数をダンプすることができます。</para>

    <para><filename>/boot/device.hints</filename>
      は 1 行につき一つの変数を設定でき、行頭の <quote>#</quote>
      はその行がコメントであることを示しています。
      書式は次の通りです。</para>

    <screen><userinput>hint.driver.unit.keyword="value"</userinput></screen>

    <para>ステージ 3 ブートローダ で設定するときの書式は次の通りです。</para>

    <screen><userinput>set hint.driver.unit.keyword=value</userinput></screen>

    <para>ここで、<literal>driver</literal> はデバイスドライバの名前、
      <literal>unit</literal> はデバイスドライバのユニット番号、
      <literal>keyword</literal> はヒントキーワードです。
      キーワードは次の設定を指定します:</para>

    <itemizedlist>
      <listitem>
	<para><literal>at</literal>:
	  デバイスがどのバスに接続されているか指定します。</para>
      </listitem>

      <listitem>
	<para><literal>port</literal>: 使用する <acronym>I/O</acronym>
	  ポートの開始アドレスを指定します。</para>
      </listitem>

      <listitem>
	<para><literal>irq</literal>: 使用する IRQ を指定します。</para>
      </listitem>

      <listitem>
	<para><literal>drq</literal>: 使用する
	  DMA チャネルを指定します。</para>
      </listitem>

      <listitem>
	<para><literal>maddr</literal>:
	  使用する物理メモリアドレスを指定します。</para>
      </listitem>

      <listitem>
	<para><literal>flags</literal>:
	  デバイスに対してさまざまなフラグを設定します。</para>
      </listitem>

      <listitem>
	<para><literal>disabled</literal>:
	  <literal>1</literal>
	  が設定されていると、そのデバイスは無効になります。</para>
      </listitem>
    </itemizedlist>

    <para>デバイスドライバはこのリスト以外の変数を設定できるかもしれませんし、
      このリスト以外の変数を必要とするかもしれないので、
      ドライバのマニュアルを読むことをおすすめします。
      より多くの情報を知りたければ、&man.device.hints.5;,
      &man.kenv.1;, &man.loader.conf.5; および &man.loader.8;
      を参照してください。</para>
  </sect1>

  <sect1 xml:id="boot-init">
    <title>init: プロセス制御の初期化</title>

    <indexterm>
      <primary>&man.init.8;</primary>
    </indexterm>

    <para>カーネルの起動が完了すると、&man.init.8;
      というユーザプロセスに制御が移されます。
      これは <filename>/sbin/init</filename>、
      もしくは <command>loader</command> の
      <envar>init_path</envar> 変数で指定される場所にあります。</para>

    <sect2 xml:id="boot-autoreboot">
      <title>自動再起動 (automatic reboot)の動作</title>

      <para>自動再起動では、
	システム上で利用できるファイルシステムの一慣性を確認します。
	もしそれに問題があって &man.fsck.8;
	が UFS ファイルシステムの不一致を修復できなければ、
	管理者が問題を直接解決できるように、
	&man.init.8; はシステムをシングルユーザモード
	(<xref linkend="boot-singleuser"/>) へと移行させます。</para>
    </sect2>

    <sect2 xml:id="boot-singleuser">
      <title>シングルユーザモード</title>

      <indexterm><primary>シングルユーザモード</primary></indexterm>
      <indexterm><primary>コンソール (console)</primary></indexterm>

      <para>このモードには、自動再起動の処理中 (<xref
	  linkend="boot-autoreboot"/>) か、
	ユーザが起動時に <option>-s</option> を指定した場合、
	あるいは &man.loader.8; で <envar>boot_single</envar>
	変数を設定することによって移行します。</para>

      <para>マルチユーザモード (<xref linkend="boot-multiuser"/>)
	から <option>-r</option> または <option>-h</option> なしで
	&man.shutdown.8; を呼び出すことでもこのモードに移行できます。</para>

      <para><filename>/etc/ttys</filename>
	でシステムコンソール <literal>console</literal>
	が <literal>insecure</literal> に設定されている場合、
	システムはシングルユーザモードに移行する前に
	<systemitem class="username">root</systemitem>
	のパスワードを入力するように求めます。</para>

      <example xml:id="boot-insecure-console">
	<title><filename>/etc/ttys</filename> の
	  insecure コンソール</title>

	<programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
#
# 訳) console に "insecure" という印をつけると、シングルユーザモードへ移行する
# 際に init が root のパスワードを要求するようになります。
#
console none                            unknown off insecure</programlisting>
      </example>

      <note>
	<para><literal>insecure</literal> コンソールとは、
	  コンソールが物理的に安全でないと考えられるため、
	  <systemitem class="username">root</systemitem>
	  のパスワードを知る人だけがシングルユーザモードを使えるという意味です。
	  そのため、この安全性を求めるならば、
	  デフォルトの <literal>secure</literal> でなく
	  <literal>insecure</literal> を選んでください。</para>
      </note>
    </sect2>

    <sect2 xml:id="boot-multiuser">
      <title>マルチユーザモード</title>

      <indexterm><primary>マルチユーザモード</primary></indexterm>

      <para>&man.init.8; がファイルシステムが正常であると判断するか、
	ユーザがシングルユーザモード (<xref linkend="boot-singleuser"/>)
	でのコマンドを終了すると、
	システムはマルチユーザモードへ移行し、
	リソースの設定を始めます。</para>

      <sect3 xml:id="boot-rc">
	<title>リソース設定</title>
	<indexterm><primary>rc ファイル群</primary></indexterm>

	<para>リソース設定システムはデフォルト設定を
	  <filename>/etc/defaults/rc.conf</filename> から、
	  そのシステム独自の細かな設定を
	  <filename>/etc/rc.conf</filename> から読み込みます。
	  そして <filename>/etc/fstab</filename>
	  に記述されるシステムファイルシステムをマウントします。
	  その後、ネットワークサービス、
	  さまざまなシステムデーモン、
	  そして最後に、ローカルにインストールされた package
	  の起動スクリプトを実行します。</para>

	<para>リソース設定システムについてもっと知りたい場合には、
	  &man.rc.8; を参照してください。また、
	  スクリプトそのものを実行してみてください。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="boot-shutdown">
    <title>シャットダウン動作</title>

    <indexterm>
      <primary>&man.shutdown.8;</primary>
    </indexterm>

    <para>&man.shutdown.8;
      を用いてシステムを意図的にシャットダウンした場合、
      &man.init.8; は
      <filename>/etc/rc.shutdown</filename>
      というスクリプトの実行を試みます。
      そして、すべてのプロセスへ <literal>TERM</literal>
      シグナルを送り、続いてうまく終了できなかったプロセスへ
      <literal>KILL</literal> シグナルを送ります。</para>

    <para>電源管理機能を持ったシステムで稼働している &os;
      では <command>shutdown -p now</command> によって、
      直ちに電源を落とすことができます。&os; システムを再起動するには、
      <command>shutdown -r now</command> を実行してください。
      &man.shutdown.8; を実行するには、
      <systemitem class="username">root</systemitem>
      であるか、<systemitem class="groupname">operator</systemitem>
      のメンバでなければなりません。&man.halt.8; や
      &man.reboot.8; を利用することもできます。
      より多くの情報を知るために、それらのマニュアルページや
      &man.shutdown.8; を参照してください。</para>

    <note>
      <para>電源管理機能には &man.acpi.4;
	がモジュールとして読み込まれるか、
	カスタムカーネルにコンパイルされて静的に組み込まれている必要があります。</para>
    </note>
  </sect1>
</chapter>
