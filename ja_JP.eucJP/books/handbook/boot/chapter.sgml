<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.5
     $FreeBSD$
-->

<chapter id="boot">
  <title>FreeBSD の起動のプロセス</title>

  <sect1 id="boot-synopsis">
    <title>概要</title>

    <para>FreeBSD は通常, 起動(bootstrap)を三段階に分けて行ないます. 
      これには基本的に, 互いに順番に呼び出される三つのプログラム(二つの
      <link linkend="boot-blocks">起動ブロック(boot block)</link>と
      <link linkend="boot-loader">ローダ(loader)</link>)が使われています.
      これらのプログラムはそれぞれ,
      その前に呼び出されるプログラムの情報に基づいて動作し,
      より洗練された機能を提供します.</para>

    <para>デバイスの検出と初期化が終わると, カーネルが起動されます.
      そしてカーネルの起動が終わると, 制御はユーザープロセスの
      &man.init.8; へ移されます.  &man.init.8; はまず
      ディスクが利用可能であることを確かめ,
      ファイルシステムのマウント,
      ネットワークで利用するネットワークカードのセットアップ,
      そして通常 FreeBSD システムで初期時に起動されるすべてのプロセスの起動,
      といったユーザーレベルでのリソース(資源)設定を行ないます.</para>
  </sect1>

  <sect1 id="boot-blocks">
    <title>起動ブロック: 起動ステージ 1 および 2</title>

    <para><firstterm>起動(bootstrap)</firstterm>とは,
      コンピュータが接続されたデバイスを検出, 初期化し,
      必要となるプログラムを動作させることを指します.</para>

    <para>起動には起動の際の動作が記録された,
      特殊な読み出し専用メモリチップを利用します.
      その動作は通常,
      メモリテストやデバイスの設定を行なう他のチップに制御を渡し,
      そして設定された内容をプログラムに提供するというものです.</para>

    <para>標準的な個人向けコンピュータでは,
      BIOS と呼ばれる起動を行なう部分と,
      CMOS と呼ばれる, 設定を記録する部分によって起動が実現されています.
      これらはディスクが存在すること,
      そしてオペレーティングシステムをロードするためのプログラムが
      ディスク上のどこにあるのかを認識しています.</para>

    <para>この章では上に述べたような起動の初期の過程については扱いません.
      焦点を合わせるのは,
      ディスク上のプログラムに制御が移された後の内容についてです.</para>

    <para>起動ブロックは(通常), ローダを見つけて実行する役割を持っています.
      したがって, ファイルシステム上のプログラムを見つけること,
      実行できること,
      そしてその動作に関して最低限の設定が可能である必要があります.</para>

    <sect2 id="boot-boot0">
      <title>boot0</title>

      <para>まず実際に最初にあるのは boot0 と呼ばれる起動ブロックです.
        これは <firstterm>マスターブートレコード(MBR; Master Boot
          Record)</firstterm> という,
        システムが起動時にプログラムを検索するディスク上の特殊な部分に存在します.
        この部分は, 単に起動可能なスライスのリストが格納されています.</para>

      <para>boot0 は非常に単純なプログラムです.
        これは, <abbrev>MBR</abbrev> にあるプログラムは
        512 バイトの大きさでなければならないという制限があるためです.</para>

      <para>boot0 は, 下のような出力をします.</para>

      <example id="boot-boot0-example">
        <title>boot0 のスクリーンショット</title>

	<screen>
F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</screen>
      </example>
    </sect2>
  
    <sect2 id="boot-boot1">
      <title>boot1</title>

      <para>boot1 は起動スライス(slice)の起動セクタにあります.
        起動セクタは <link linkend="boot-boot0">boot0</link> が存在し,
        <abbrev>MBR</abbrev> にある他のプログラムが
        起動のプロセスを続けるために必要なプログラムを探す部分です.</para>

      <para>boot1 も非常に単純なプログラムです.
        これは boot0 同様に,
        512 バイトの大きさでなければならないという制限があるためです.
        boot1 は <link linkend="boot-boot2">boot2</link> を検索し,
        実行するため, そのスライスの情報を保持する FreeBSD
        の<firstterm>ディスクラベル(disklabel)</firstterm>
        に関する最低限の情報を持っています.</para>
    </sect2>
  
    <sect2 id="boot-boot2">
      <title>boot2</title>

      <para>boot2 はもう少し高機能です.
        これは FreeBSDのファイルシステム上でファイルを見つける能力を持ち,
        実行するカーネルやローダを指定するための簡単なインターフェイスを提供する事ができます.</para>

      <para><link linkend="boot-loader">ローダ(loader)</link>はさらに高機能なもので,
        使いやすく簡単な起動設定が行なえる手段を提供します.
        boot2 は通常それを起動します.  以前の boot2 は,
        カーネルを直接起動する機能しかありませんでした.</para>

      <example id="boot-boot2-example">
        <title>boot2 のスクリーンショット</title>

	<screen>>> FreeBSD/i386 BOOT
Default: 0:wd(0,a)/kernel
boot:</screen>
      </example>
    </sect2>
  </sect1>

  <sect1 id="boot-loader">
    <title>ローダ(loader): 起動ステージ 3</title>

    <para>ローダは三段階の起動プロセスの最終段階です.
      ローダは通常, ファイルシステム上の
      <filename>/boot/loader</filename>
      として存在しています.</para>
      
    <note>
      <para><filename>/boot/boot0</filename>,
        <filename>/boot/boot1</filename>, 
        <filename>/boot/boot2</filename> というファイルがありますが,
        これらは <abbrev>MBR</abbrev>,
        起動セクタ, ディスクラベルの実際のコピーではありません.</para>
    </note>

    <para>ローダは, よりさまざまなコマンド群をサポートした
      強力なインタープリタによって提供される簡易組み込みコマンド群を利用することで,
      ユーザが利用しやすい設定手段となるように設計されています.</para>
    
    <sect2 id="boot-loader-flow">
      <title>ローダプログラムの処理の流れ</title>
      
      <para>ローダは初期化の際にコンソールとディスクの検出を行ない,
        どのディスクから起動しているかを調べます.
        そして必要な変数を設定してからインタープリタを起動し,
        簡易コマンドを解釈します.</para>

      <para>ローダは次に
        <filename>/boot/loader.rc</filename>
        を読み込み, 通常, 変数の標準値を定義した
        <filename>/boot/defaults/loader.conf</filename>
        と, そのマシンにローカルな変数を定義した
        <filename>/boot/loader.conf</filename>
        を読み込みます.
        <filename>loader.rc</filename>
        はそれらの変数にもとづき,
        選択されたモジュールとカーネルをロードします.</para>

      <para>ローダは最後に, 標準設定で 10 秒のキー入力待ち時間を用意し,
        入力がなければカーネルを起動します.
        入力があった場合, 簡易コマンド群が使えるプロンプトが表示され,
        ユーザは変数を調整したり,
        すべてのモジュールをアンロードしたり,
        モジュールをロードしたりすることができます.
        その後, 最終的な起動や再起動へ移行します.</para>

      <para>この処理に関するより技術的な説明は
          &man.loader.8; にあります.</para>
    </sect2>
    
    <sect2 id="boot-loader-commands">
      <title>ローダの組み込みコマンド</title>
      
      <para>簡易コマンド群は, 次のようなもので構成されています.</para>

      <variablelist>
	<varlistentry>
	  <term>autoboot <replaceable>seconds</replaceable></term>

	  <listitem>
            <para><replaceable>seconds</replaceable>
              で与えられた時間内に入力がなければ,
              カーネルの起動へと進みます.
              カウントダウンを表示し, 標準設定では 10 秒間です.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot
	    <optional><replaceable>-options</replaceable></optional>
	    <optional><replaceable>kernelname</replaceable></optional></term>

	  <listitem>
            <para>すぐにカーネルの起動へ進みます.
              オプション, カーネル名が指定されている場合は,
              それらが使われます.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot-conf</term>

	  <listitem>
	    <para>すべてのモジュールの設定を,
              起動時と同じように変数にもとづいて自動的に行ないます.
              このコマンドは, まず <command>unload</command> を行なって,
              変数&mdash;普通 <envar>kernel</envar>
              など&mdash;を変更した場合にのみ有効に働きます. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>help
	    <optional><replaceable>topic</replaceable></optional></term>

	  <listitem>
            <para><filename>/boot/loader.help</filename>
              を読み込み, ヘルプメッセージを表示します.
              <replaceable>topic</replaceable> に
              <literal>index</literal> 指定された場合,
              利用可能な <replaceable>topic</replaceable> を表示します.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>include <replaceable>filename</replaceable>
	    &hellip;</term>

	  <listitem>
            <para>指定されたファイル名のファイルを処理します.
              ローダはファイルを読み込み, 行単位で解釈します.
              エラーが発生した場合,
              include コマンドの実行はその時点で停止します.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>load <optional><option>-t</option>
	    <replaceable>type</replaceable></optional>
	    <replaceable>filename</replaceable></term>

	  <listitem>
            <para>指定されたファイル名のカーネル,
              カーネルモジュール, あるいは
              type に指定された種類のファイルをロードします.
              ファイル名以降に指定された引数はファイルへと渡されます.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>ls <optional><option>-l</option></optional>
	    <optional><replaceable>path</replaceable></optional></term>

	  <listitem>
            <para>指定された <replaceable>path</replaceable>
              にあるファイルを表示します.
              <replaceable>path</replaceable>
              が指定されていなければ, ルートディレクトリを表示します.
              <option>-l</option>
              が指定されていればファイルサイズも表示されます.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>lsdev <optional><option>-v</option></optional></term>

	  <listitem>
            <para>モジュールがロード可能なすべてのデバイスを表示します.
              もし <option>-v</option> が指定されていれば,
              より詳細な出力がされます.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>lsmod <optional><option>-v</option></optional></term>

	  <listitem>
            <para>ロード済みのモジュールを表示します.
              <option>-v</option> が指定されていれば,
              より詳細な内容が出力されます.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>more <replaceable>filename</replaceable></term>

	  <listitem>
            <para><varname>LINES</varname>
              単位でスクロールを停止しながら指定されたファイルを表示します.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>reboot</term>

	  <listitem>
            <para>すぐにシステムを再起動します. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>set <replaceable>variable</replaceable></term>
	  <term>set
	    <replaceable>variable</replaceable>=<replaceable>value</replaceable></term>

	  <listitem>
            <para>ローダの環境変数を設定します. </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>unload</term>

	  <listitem>
	    <para>すべてのロード済みモジュールを削除します.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="boot-loader-examples">
      <title>ローダの使用例</title>

      <para>次にあげるのは, ローダの実践的な使用例です.</para>

      <itemizedlist>
	<listitem>
          <para>普段使っているカーネルをシングルユーザモードで起動します.</para>

	  <screen><userinput>boot -s</userinput></screen>
	</listitem>

	<listitem>
          <para>普段使っているカーネルとモジュールをアンロードし,
            古い(もしくは別の)カーネルをロードします.</para>

	  <screen><userinput>unload</userinput>
  <userinput>load <replaceable>kernel.old</replaceable></userinput></screen>

          <para><filename>kernel.GENERIC</filename> とすると,
            インストールディスクに入っていた
            generic カーネルを指定することができます.
            また, 直前にインストールされていたカーネル(たとえば,
            カーネルを自分で設定したり,
            アップグレードしたりした場合)を指定するには
            <filename>kernel.old</filename> とします.</para>

	  <note>
	    <para>普段のカーネルで使っているモジュールを
              指定したカーネルでロードする場合は, 下のようにします.</para>

	    <screen><userinput>unload</userinput>
<userinput>set kernel="<replaceable>kernel.old</replaceable>"</userinput>
<userinput>boot-conf</userinput></screen>
	  </note>
	</listitem>

	<listitem>
          <para>カーネルの設定スクリプト(通常,
            カーネル起動時に設定される内容を自動化するスクリプト)をロードします.</para>

	  <screen><userinput>load -t userconfig_script
	    <replaceable>/boot/kernel.conf</replaceable></userinput></screen>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="boot-kernel">
    <title>カーネル起動時の応答</title>
    
    <para>カーネルが<link linkend="boot-loader">ローダ</link>(通常は)
      か<link linkend="boot-boot2">boot2</link>
      (ローダを迂回して)によってロードされると,
      起動フラグを調べます.
      もし起動フラグがあれば, それに応じて動作を調整します.</para>

    <sect2 id="boot-kernel-bootflags">
      <title>カーネル起動フラグ</title>

      <para>良く使われる起動フラグは次のとおりです.</para>
      
      <variablelist id="boot-kernel-bootflags-list">
	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
            <para>カーネル初期化中に,
              ルートファイルシステムとしてマウントするデバイスを尋ねます.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-C</option></term>

	  <listitem>
            <para>CDROM から起動します.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-c</option></term>

	  <listitem>
            <para>起動時にカーネルコンフィグレーションを行なう
              UserConfig を実行します.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-s</option></term>

	  <listitem>
            <para>シングルユーザモードで起動します.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
            <para>カーネル起動時により詳細な情報を表示します.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note>
        <para>起動フラグはこの他にもあります.
          それらについては &man.boot.8; を参照してください.
        </para>
      </note>
    </sect2>

<!--    <sect2 id="boot-kernel-userconfig">
      <title>UserConfig: The boot-time kernel configurator</title>
      
      <para> </para>
    </sect2> -->
  </sect1>

  <sect1 id="boot-init">
    <title>Init: プロセス制御の初期化</title>
	
    <para>カーネルの起動が完了すると, <command>init</command>
      というユーザプロセスに制御が移されます.
      これは <filename>/sbin/init</filename>,
      もしくは <command>loader</command> の
      <envar>init_path</envar> 変数で指定される場所にあります.</para>

    <sect2 id="boot-autoreboot">
      <title>自動再起動(automatic reboot)の動作</title>

      <para>自動再起動では, 
        システム上で利用できるファイルシステムの一慣性を確認します.
        もしそれに問題があって <command>fsck</command> がその不一致を修復できなければ,
        管理者に直接に処置させるため <command>init</command>
        はシステムを<link linkend="boot-singleuser">シングルユーザモード</link>へと移行させます.</para>
    </sect2>

    <sect2 id="boot-singleuser">
      <title>シングルユーザモード</title>

      <para>このモードには,
        <link linkend="boot-autoreboot">自動再起動</link>の処理中か,
        ユーザが起動時に <option>-s</option> を指定た場合,
        あるいは <command>loader</command> で
        <envar>boot_single</envar> 変数を設定することによって移行します.</para>

      <para>また,
        <link linkend="boot-multiuser">マルチユーザモード</link>から
        再起動オプション(<option>-r</option>)
        や停止(halt)オプション(<option>-h</option>)なしで
        <command>shutdown</command> を呼び出すとこのモードに移行します.</para>

      <para><filename>/etc/ttys</filename>
        でシステムコンソール <literal>console</literal>
        が <literal>insecure</literal> に設定されている場合,
        システムはシングルユーザモードに移行する前に
        root のパスワードを入力するように求めます.</para>

      <example id="boot-insecure-console">
        <title>/etc/ttys の insecure コンソール</title>

	<programlisting># name  getty                           type    status          comments
#
# This entry needed for asking password when init goes to single-user mode
# If you want to be asked for password, change "secure" to "insecure" here
#
# 訳) このエントリは init がシングルユーザモードへ移行する際にパスワードを要
# 求させるために必要です. もし, パスワードの要求を望む場合, ここの "secure" を
# "insecure" へ変更してください. 
#
console none                            unknown off insecure</programlisting>
      </example>

      <note>
        <para><literal>insecure</literal> コンソールとは,
          あなた自身, コンソールが物理的に安全でないと考えていて,
          root パスワードを知る人だけがシングルユーザモードを使えるようにしたいという意味であり,
          コンソールを安全でない状態で使いたいという意味ではありません. 
          そのため, 安全性を求めるならば
          <literal>secure</literal> でなく
          <literal>insecure</literal> を選んでください.</para>
      </note>
    </sect2>
    
    <sect2 id="boot-multiuser">
      <title>マルチユーザモード</title>
      
      <para><command>init</command> がファイルシステムが正常であると判断するか,
        ユーザが<link linkend="boot-singleuser">シングルユーザモード</link>を終了すると,
        システムはマルチユーザモードへ移行し,
        リソースの設定を始めます.</para>

      <sect3 id="boot-rc">
        <title>リソース設定(rc)</title>

        <para>リソース設定システムはデフォルト設定を
          <filename>/etc/defaults/rc.conf</filename> から,
          そのシステム独自の細かな設定を
          <filename>/etc/rc.conf</filename> から読み込みます.
          そして <filename>/etc/fstab</filename>
          に記述されるシステムファイルシステムをマウントし,
          ネットワークサービスの開始,
          さまざまなシステムデーモンの開始,
          そして最後に, ローカルにインストールされた package
          の起動スクリプトの実行へと進みます.</para>
        
        <para>リソース設定システムのに関する参考資料は, &man.rc.8; にあります.
          これはスクリプトそのものを調べることと同じくらい優れたものです.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-shutdown">
    <title>シャットダウン動作</title>

    <para><command>shutdown</command>
      を用いてシステムを意図的にシャットダウンした場合,
      <command>init</command> は
      <filename>/etc/rc.shutdown</filename>
      というスクリプトの実行を試みます.
      そして, すべてのプロセスへ終了(terminate)シグナルを送り,
      続いてうまく終了できなかったプロセスへ
      強制終了(kill)シグナルを送ります.
    </para>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
