<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.19
     $FreeBSD: doc/ja_JP.eucJP/books/handbook/advanced-networking/chapter.sgml,v 1.7 2000/01/11 08:41:57 motoyuki Exp $
-->

<chapter id="advanced-networking">
  <title>高度なネットワーク</title>

  <sect1 id="routing">
    <title>ゲートウェイとルート</title>

    <para><emphasis>原作: &a.gryphon;.
	6 October 1995. </emphasis></para>

    <para><emphasis>訳: &a.jp.yuki;.
	6 September 1996.</emphasis></para>

    <para>ある計算機が他の計算機をみつけることができるようにするには,
      ある計算機から他の計算機へ,
      どのようにたどり着くかを適切に記述するための仕組みが必要です.
      この仕組みをルーティングと呼びます. &ldquo;ルート(経路)&rdquo;は
      &ldquo;destination (目的地) &rdquo;と &ldquo;gateway
      (ゲートウェイ) &rdquo;の 2つのアドレスの組で定義します. あなたが
      <emphasis>destination</emphasis> へアクセスしようとした場合,
      <emphasis>gateway</emphasis>
      を通って送られることをこのペアは示しています.  destination
      には個々のホスト, サブネット, &ldquo;デフォルト&rdquo;の 3つの
      タイプがあります.
      &ldquo;デフォルトルート&rdquo;は他への経路が適用できない
      場合に使われます. のちほどデフォルトルートについて少し述べること
      するとして, ここでは, 個々のホスト, インタフェース
      (&ldquo;リンク&rdquo;と も呼ばれます),
      イーサネットハードウェアアドレスという 3つのタイ
      プのゲートウェイについて説明します.</para>

    <sect2>
      <title>例</title>

      <para>以下に示す <command>netstat -r</command>
	の出力の例を使って, ルーティン
	グがいろいろと異なっている様子を説明することにします.</para>

      <screen>Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     link#1             UHLW        1     2421
foobar.com       link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =&gt;
host2.foobar.com link#1             UC          0        0
224              link#1	            UC          0        0</screen>

      <para>最初の2行はデフォルトルート(次の節で詳しく説明します)と,
	<hostid>localhost</hostid>への経路を示しています.</para>

      <para><literal>localhost</literal>のためのインタフェース
	(<literal>Netif</literal>の欄)
	は<devicename>lo0</devicename>で,
	これはループバックデバイスとして知られています.
	結局のところ戻るだけなので, この
	destinationへのすべてのトラフィックが
	内部的に処理されるのであって, LAN
	を経由して送られるのではありません.</para>

      <para>次の行では
	<hostid role="mac">0:e0:...</hostid>
	というアドレスに注目しましょう.
	これはイーサネットハードウェアアドレスです. FreeBSDは自動的に
	ローカルなイーサネット上の任意のホスト
	(この例では<hostid>test0</hostid>) を見つけ,
	イーサネットインタフェース <devicename>ed0</devicename>
	の所にそのホストへの経路を直接つけ加えます. タイムアウト時間
	(<literal>Expire</literal>の 欄)
	も経路のタイプと結びついており, 指定された時間が経過しても応
	答がないときに使用します. この場合,
	経路情報は自動的に削除されま す. これらのホストは, RIP(Routing
	Information Protocol) という,
	最短パスの判定に基づいてローカルホストへの経路を
	決定する仕組みを利用することで認識されます.</para>

      <para>更に, FreeBSDではローカルサブネット
	(<hostid role="ipaddr">10.20.30.255</hostid> は
	<hostid role="ipaddr">10.20.30</hostid>
	というサブネットに対するブロードキャストアドレスで,
	<hostid role="domainname">foobar.com</hostid>
	はこのサブネットに結びつけられているドメイン名)
	への経路情報も加えることができます.
	<literal>link#1</literal>というのは,
	この計算機の最初のイーサネットカードのことをさします. これら
	については,
	何も追加インタフェースが指定されていないことに気づく
	でしょう.</para>

      <para>これらの2つのグループ(ローカルネットワークホストと
	ローカルサブネット) の両方とも, <command>routed</command>
	と呼ばれるデーモンによって自動的に経路が設定されます.
	<command>routed</command> を動かさなければ,
	静的に定義した (つまり具体的に設定した)
	経路のみ存在することになります.</para>

      <para><literal>host1</literal> の行は私たちのホストのことで,
	イーサネットアドレスで示されています.  送信側のホストの場合,
	FreeBSDはイーサネットインタフェースへ送るのではなく,
	ループバックインタフェース
	(<devicename>lo0</devicename>)を使います.</para>

      <para>2つある<literal>host2</literal>の行は,
	ifconfigのエイリアス (このようなことをする理由については
	ethernetの章を参照してください) を使ったとき
	にどのようになるかを示す例です.
	<devicename>lo0</devicename>の後にある<literal>=&gt;</literal>
	は, インタフェースが
	(このアドレスがローカルなホストを参照しているので)
	ループバックを使っているというだけでなく,
	エイリアスになっていることも示しています.
	このような経路はエイリアスをサポートしている
	ホストにのみ現れます.
	ローカルネットワーク上の他のすべてのホストでは
	単に<literal>link#1</literal>となります.</para>

      <para>最後の行 (destinationが<literal>224</literal>のサブネット)
	はマルチキャストで扱うものですが,
	これは他の章で説明します.</para>

      <para>他の欄については <literal>Flags</literal>
	について説明する必要があります.
	それぞれの経路は欄に示されているように違った属性を
	もっています.
	以下にいくつかのフラグとこれらが何を意味しているかを示します.
      </para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>U</entry>
	      <entry>Up: この経路はアクティブです.</entry>
	    </row>

	    <row>
	      <entry>H</entry>
	      <entry>Host: 経路の destinationが単一のホストです.</entry>
	    </row>

	    <row>
	      <entry>G</entry>
	      <entry>Gateway: この destinationへ送られると, どこへ送れ
		ばよいかを明らかにして,
		そのリモートシステムへ送られます.</entry>
	    </row>

	    <row>
	      <entry>S</entry>
	      <entry>Static: この経路はシステムによって自動的に生成
		されたのではなく, 手動で作成されました.</entry>
	    </row>

	    <row>
	      <entry>C</entry>
	      <entry>Clone: マシンに接続したときにこの経路に基づく
		新しい経路が作られます.  このタイプの経路は通常は
		ローカルネットワークで使われます.</entry>
	    </row>

	    <row>
	      <entry>W</entry>
	      <entry>WasCloned: ローカルエリアネットワーク(Clone)
		の経路に基づいて
		自動的に生成された経路であることを示します.</entry>
	    </row>

	    <row>
	      <entry>L</entry>
	      <entry>Link: イーサネットハードウェアへの参照を含む
		経路です.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>デフォルトルート</title>

      <para>ローカルシステムからリモートホストにコネクションを張る
	必要がある場合, 既知のパスが存在するかどうかを確認するためにル
	ーティングテーブルをチェックします.
	到達するためのパスを知っているサブネットの内部に
	リモートホストがある場合 (Cloned routes), システムはインタフェース
	から接続できるかどうかをチェックします.</para>

      <para>知っているパスがすべて駄目だった場合でも, システムには
	最後の切り札の &ldquo;デフォルト&rdquo;ルートがあります.
	このルートは ゲートウェイルート (普通はシステムに
	1つしかありません) の特別なものです. そして,
	フラグフィールドは必ず <literal>c</literal>
	がマークされています. このゲートウェイは, LAN 内のホストにとっ
	て, 外部 (PPPのリンクを経由する場合や,
	データラインに接続するハードウェアデバイスなど)
	へ直接接続するマシンすべてのためのものです.</para>

      <para>外部に対するゲートウェイとして機能するマシンで
	デフォルトルートを設定する場合,
	デフォルトルートはインターネットサービスプロバイダ (ISP)
	のサイトのゲートウェイマシンになるでしょう.</para>

      <para>それではデフォルトルートの一例を見てみましょう.
	一般的な構成を示します. </para>

<literallayout>
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt;  [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
	    </literallayout>

      <para>ホスト <hostid>Local1</hostid> とホスト <hostid>Local2</hostid>
	を PPP で ISP のターミナルサーバと接続されているあなたの
	サイトだとします.
	ISP はサイト内にロー カルなネットワークを持っていて,
	そこにはまざまなものがあり,
	あなたの接続するサーバや ISP のインターネットへの
	接続点であるハードウェアデバイス (T1-GW) などがあります.</para>

      <para>あなたのマシンのデフォルトルートは
	それぞれ次のようになります.</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>host</entry>
	      <entry>default gateway</entry>
	      <entry>interface</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>
	      <entry>Local1</entry>
	      <entry>ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>
	      <entry>T1-GW</entry>
	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>&ldquo;なぜ (あるいは, どうやって) Local1 の
	デフォルトゲートウェイをISPのサーバでなく
	T1-GWにセットするのか&rdquo;という質問がよくあります.</para>

      <para>コネクションのローカルの側については,
	PPPのインタフェースは
	ISPのローカルネットワーク上のアドレスを用いているため,
	ISPのローカルネットワーク上のすべてのマシンへの経路は
	自動的に生成されています. つまり, あなたのマシンは,
	どのようにT1-GW
	まで届くかという経路を既に知っていることになりますから,
	ISPサーバに媒介的なトラフィックをかける必要はありません.</para>

      <para>最後になりましたが, 一般的にローカルネットワークでは
	<hostid role="ipaddr">...1</hostid>
	というアドレスをゲートウェイアドレスとして使います.  ですから
	(同じ例を用います), あなたのclass-Cのアドレス空間が
	<hostid role="ipaddr">10.20.30</hostid>で ISPが
	<hostid role="ipaddr">10.9.9</hostid>を用いている場合,
	デフォルトルートは次のようになります.</para>

      <literallayout>
Local2 (10.20.30.2)             --&gt;  Local1 (10.20.30.1)
Local1 (10.20.30.1, 10.9.9.30)  --&gt;  T1-GW (10.9.9.1)
      </literallayout>
    </sect2>

    <sect2>
      <title>マルチホームホスト</title>

      <para>ここで扱うべき他のタイプの設定があります.
	それは2つの異なるネットワークにまたがるホストです.
	技術的にはゲートウェイとして機能するマシン (上 の例では
	PPPコネクションを用いています) はマルチホームホストで す.
	しかし実際にはこの言葉は,
	2つのローカルエリアネットワーク上のサ
	イトであるマシンを指す言葉としてのみ使われます.</para>

      <para>2枚のイーサネットカードを持つマシンが, 別のサブネット
	上にそれぞれアドレスを持っている場合があります.  あるいは,
	イーサネットカードを1枚持っているマシンで,
	ifconfigのエイリアスを使っているかもしれません.
	物理的に分かれている2つのイーサネットのネットワークが使われて
	いるならば前者が用いられます. 後者は, 物理的には1つのネットワ
	ークセグメントで, 論理的には分かれている 2つのサブネットとする
	場合に用いられます.</para>

      <para>どちらにしても,
	このマシンがお互いのサブネットへのゲートウェイ  (inbound
	route) として定義されていることが分かるように, おのお
	ののサブネットでルーティングテーブルを設定します. このマシンが
	2 つのサブネットの間のブリッジとして動作するという構成は, パケ
	ットのフィルタリングを実装する必要がある場合や, 一方向または双
	方向のファイアウォールを利用したセキュリティを構築する場合によ
	く用いられます.</para>
    </sect2>

    <sect2>
      <title>ルーティングの伝播</title>

      <para>すでに外部との経路をどのように定義したらよいかは
	説明しました.
	しかし外部から私たちのマシンをどのようにして
	見つけるのかについては説明していません.</para>

      <para>ある特定のアドレス空間 (この例では class-C のサブネット)
	におけるすべてのトラフィックが,
	到着したパケットを内部で転送するネ
	ットワーク上の特定のホストに送られるようにルーティングテーブル
	を設定することができるのは分かっています.</para>

      <para>あなたのサイトにアドレス空間を割り当てる場合,
	あなたのサブネットへのすべてのトラフィックがすべて
	PPPリンクを通じてサイトに送
	ってくるようにサービスプロバイダはルーティングテーブルを設定し
	ます. しかし, 国境の向こう側のサイトはどのようにしてあなたの
	ISPへ送ることを知るのでしょうか?</para>

      <para>割り当てられているすべてのアドレス空間の経路を維持する
	(分散している DNS 情報とよく似た) システムがあり,
	そのインターネット バックボーンへの接続点を定義しています.
	&ldquo;バックボーン&rdquo; とは国を越え,
	世界中のインターネットのトラフィックを運ぶ主要
	な信用できる幹線のことです. どのバックボーンマシンも,
	あるネットワークから特定のバックボーンのマシンへ
	向かうトラフィックと,
	そのバックボーンのマシンからあなたのネットワークに届くサービス
	プロバイダまでのチェーンのマスタテーブルのコピーを持っていま
	す.</para>

      <para>あなたのサイトが接続(プロバイダからみて内側にある
	ことになります) したということを, プロバイダからバックボー
	ンサイトへ通知することはプロバイダの仕事です. これが経
	路の伝搬です.</para>
    </sect2>

    <sect2>
      <title>トラブルシューティング</title>

      <para>ルーティングの伝搬に問題が生じて, いくつかのサイトが
	接続をおこなうことができなくなることがあります.
	ルーティングがどこでおかしくなっているかを明らかにするのに
	最も有効なコマンドはおそらく &man.traceroute.8; コマンドでしょ
	う. このコマンドは,
	あなたがリモートマシンに対して接続をおこなう
	ことができない(例えば &man.ping.8; に失敗するような場合)
	場合も, 同じように有効です.</para>

      <para> &man.traceroute.8; コマンドは,
	接続を試みているリモートホストを引数にして実行します.
	試みているパスの経由するゲートウェイホストを表示し,
	最終的には目的のホストにたどり着くか,
	コネクションの欠如によって終ってしまうかのどちら
	かになります.</para>

      <para>より詳しい情報は, &man.traceroute.8;
	のマニュアルページをみてください.</para>
    </sect2>
  </sect1>

  <sect1 id="nfs">
    <title>NFS</title>

    <para><emphasis>原作: &a.jlind;.</emphasis></para>

    <para><emphasis>訳: &a.jp.tomo;.
	6 September 1996.</emphasis></para>

    <para>ISA用のイーサネットアダプタの中には性能が悪いため,
      ネットワーク,  特に NFS で深刻な問題がおきるものがあります.
      これは FreeBSD に限ったことではありませんが, FreeBSD
      でも起こり得ます.</para>

    <para>この問題は,
      (FreeBSDを使用した) PC がシリコン・グラフィックス社や
      サン・マイクロシステムズ社などの高性能な WS
      にネットワーク接続されている場合に頻繁に起こります.
      NFS マウントはうまく行きます. また,
      いくつかの操作もうまく働きますが, 他のシステム (WS)
      に対する要求や応答は続いていても, 突然サーバが
      クライアントの要求に対して反応しなくなります.
      これは, クライアントが FreeBSD か上記の WS であるとき,
      にクライアント側に起きる現象です.
      多くのシステムでは, いったんこの問題が現われると,
      行儀良くクライアントを終了する手段はありません.
      NFS がこの状態に陥ってしまうと, 正常に戻すことはできないため,
      多くの場合, クライアントを強制終了し,
      再び実行することが唯一の解決法となります.
    </para>

    <para>&ldquo;正しい&rdquo;解決法は,
      より高性能のイーサネットアダプタをFreeBSDシステムに
      インストールすることですが,
      満足な操作ができるような簡単な方法があります.  もし,
      FreeBSDシステムが<emphasis>サーバ</emphasis>になるのなら,
      クライアントからのマウント時に
      <option>-w=1024</option>オプションをつけて下さい.
      もしFreeBSDシステムが<emphasis>クライアント</emphasis>になる
      のなら, NFSファイルシステムを <option>-r=1024</option>
      オプションつきでマウントして下さい.
      これらのオプションは自動的にマウントをおこなう場合には
      クライアントの <filename>fstab</filename>
      エントリの4番目のフィールドに指定してもよいですし,
      手動マウントの場合は mount コマンドの <option>-o</option>
      パラメータで指定してもよいでしょう.</para>

    <para>NFSサーバとクライアントが別々のネットワーク上にあるような
      場合,  これと間違えやすい他の問題が起きることに注意して下さい.
      そのような場合は,  ルータが必要な UDP 情報をきちんと
      ルーティングしているかを確かめて下さい.
      そうでなければ, たとえあなたが何をしようと解決できないでしょう.
    </para>

    <para>次の例では, <hostid>fastws</hostid>は高性能のWSのホスト
      (インタフェース)名で,
      <hostid>freebox</hostid>は低性能のイーサネットアダプタを備えた
      FreeBSDシステムのホスト(インタフェース)名です.</para>

    <para>また, <filename>/sharedfs</filename> はエクスポートされる
      NFS ファイルシステムであり (<command>man exports</command>
      を見て下さい), <filename>/project</filename>
      はエクスポートされたファイルシステムの
      クライアント上のマウントポイントとなります.
      全ての場合において, <option>hard</option> や <option>soft</option>,
      <option>bg</option> といった追加オプションが
      アプリケーションにより要求されるかもしれないことに
      注意して下さい.</para>

    <para>クライアント側 FreeBSD システム (<hostid>freebox</hostid>)
      の例は:
      freebox の <filename>/etc/fstab</filename>
      に次のように書いて下さい:</para>

    <programlisting>
fastws:/sharedfs /project nfs rw,-r=1024 0 0</programlisting>

    <para><hostid>freebox</hostid> 上で手動で mount
      コマンドを実行する場合は次のようにして下さい:</para>

    <screen>&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sharedfs /project</userinput></screen>

    <para>サーバ側FreeBSDシステムの例は: <hostid>fastws</hostid> の
      <filename>/etc/fstab</filename> に次のように書いて下さい:</para>

    <programlisting>
freebox:/sharedfs /project nfs rw,-w=1024 0 0</programlisting>

    <para><hostid>fastws</hostid> 上で手動で mount
      コマンドで実行する場合は次のようにして下さい:</para>

    <screen>&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sharedfs /project</userinput></screen>

    <para>近いうちにどのような 16 ビットのイーサネットアダプタでも
      上記の読み出し,
      書き込みサイズの制限なしの操作ができるようになるでしょう.</para>

    <para>失敗が発生したとき何が起きているか関心のある人に,
      なぜ回復不可能なのかも含めて説明します.  NFSは通常
      (より小さいサイズへ分割されるかもしれませんが)
      8Kの&ldquo;ブロック&rdquo; サイズで働きます.
      イーサネットのパケットサイズは最大1500バイト程度なので,
      上位階層のコードにとっては1つのユニットのままなのですが,
      NFS&ldquo;ブロック&rdquo;は
      複数のイーサネットパケットに分割されます. そして受信され,
      組み立て直されてから<emphasis>肯定応答</emphasis>
      されなければなりません.
      高性能のWSは次々に NFSユニットを構成するパケットを,
      基準の範囲内で間隔を詰めて次々に送り出すことができます. 小さく,
      容量の低いカードでは, 同じユニットの
      前のパケットがホストに転送される前に, 後のパケットがそれを
      <emphasis>踏みつぶし</emphasis>てしまいます.
      このため全体としてのユニットは再構成もされないし,
      肯定応答もされません. その結果,
      WSはタイムアウトして再送を試みますが,
      8Kのユニット全体を再送しようとするので, このプロセスは
      際限無く繰り返されてしまいます.</para>

    <para>ユニットサイズをイーサネットのパケットサイズの
      制限以下に抑えることにより, 受信された完全な
      イーサネットパケットは個々に肯定応答を受けられることが
      保証されるので,
      デッドロック状態を避けることができるようになります.</para>

    <para>高性能のカードを使っている場合でも, 高性能な WS
      が力任せに次々と PC システムにデータを送ったときには
      <emphasis>踏みつぶし</emphasis> が起きるかもしれません.
      そのような<emphasis>踏みつぶし</emphasis>
      は NFS &ldquo;ユニット&rdquo;
      では保証されていません.
      <emphasis>踏みつぶし</emphasis>が起こったとき,
      影響を受けたユニットは再送されます. そして受信され,
      組み立てられ,
      肯定応答される公平な機会が与えられるでしょう.</para>
  </sect1>

  <sect1 id="diskless">
    <title>Diskless operation</title>

    <para><emphasis>原作: &a.martin;</emphasis></para>

    <para><emphasis>訳: &a.jp.yasu;</emphasis></para>

    <para><filename>netboot.com</filename>/<filename>netboot.rom</filename>
      によって, ディスクのないクライアントでネットワーク経由で
      FreeBSD マシンのブートを行い FreeBSD を走らせることができます.
      2.0 ではローカルなスワップを持つことができます.
      NFS 経由のスワッピングもサポートされています. </para>

    <para>サポートされているイーサネットカード:
      Western Digital/SMC 8003, 8013, 8216 とその互換ボード,
      NE1000/NE2000 とその互換カード (再コンパイルが必要)</para>

    <sect2>
      <title>セットアップの手順</title>

      <procedure>
	<step>
	  <para>サーバにするマシンを見つけます.
	    このマシンには, FreeBSD 2.0のバイナリとbootpを
	    記憶するだけの十分なディスクスペースが必要です.
	    tftp と NFS も使えます.

	    テストしたマシン:</para>

	  <itemizedlist>
	    <listitem>
	      <para>HP9000/8xx / HP-UX 9.04以降
		(9.04以前では動きません)</para>
	    </listitem>

	    <listitem>
	      <para>Sun/Solaris 2.3. (bootpが必要)</para>
	    </listitem>
	  </itemizedlist>
	</step>

	<step>
	  <para>クライアントにIP,gateway,netmaskを提供する
	    bootpサーバをセットアップします.</para>

	  <programlisting>
diskless:\
        :ht=ether:\
        :ha=0000c01f848a:\
        :sm=255.255.255.0:\
        :hn:\
        :ds=192.1.2.3:\
        :ip=192.1.2.4:\
        :gw=192.1.2.5:\
        :vm=rfc1048:</programlisting>
	</step>

	<step>
	  <para>クライアントにブート情報を提供する TFTP サーバを
	    (bootp サーバと同じマシンに) セットアップします.
	    このファイルの名前は,
	    <filename>cfg.<replaceable>X.X.X.X</replaceable></filename>
	    (もしくは
	    <filename>/tftpboot/cfg.<replaceable>X.X.X.X</replaceable>
	    </filename>)で,
	    ここで <replaceable>X.X.X.X</replaceable> はクライアントの
	    IP アドレスです.
	    このファイルの内容は netboot コマンドで有効です.
	    2.0では, netboot は以下のようなコマンドを持ちます:</para>

	  <informaltable frame="none">
	    <tgroup cols="2">
	      <tbody>
		<row>
		  <entry>help</entry>
		  <entry>helpリストの表示</entry>
		</row>

		<row>
		  <entry>ip
		    <option><replaceable>X.X.X.X</replaceable></option></entry>
		  <entry>クライアントのIPアドレスの表示/セット</entry>
		</row>

		<row>
		  <entry>server
		    <option><replaceable>X.X.X.X</replaceable></option></entry>
		  <entry>bootp/tftp サーバのアドレスの表示/セット</entry>
		</row>

		<row>
		  <entry>netmask
		    <option><replaceable>X.X.X.X</replaceable></option></entry>
		  <entry>netmaskの表示/セット</entry>
		</row>

		<row>
		  <entry>hostname <replaceable>name</replaceable></entry>
		  <entry>hostnameの表示/セット</entry>
		</row>

		<row>
		  <entry>kernel
		    <option><replaceable>name</replaceable></option></entry>
		  <entry>カーネル名の表示/セット</entry>
		</row>

		<row>
		  <entry>rootfs
		    <option><replaceable>ip:/fs</replaceable></option></entry>
		  <entry>root ファイルシステムの表示/セット</entry>
		</row>

		<row>
		  <entry>swapfs
		    <option><replaceable>ip:/fs</replaceable></option></entry>
		  <entry>swap ファイルシステムの表示/セット</entry>
		</row>

		<row>
		  <entry>swapsize
		    <option><replaceable>size</replaceable></option></entry>
		  <entry>diskless swapsize を Kbytes単位でセット</entry>
		</row>

		<row>
		  <entry>diskboot</entry>
		  <entry>ディスクからのブート</entry>
		</row>

		<row>
		  <entry>autoboot</entry>
		  <entry>ブートプロセスの続行</entry>
		</row>

		<row>
		  <entry>trans
		    <option>on</option>|<option>off</option></entry>
		  <entry>トランシーバのオン|オフ</entry>
		</row>

		<row>
		  <entry>flags
		    <option>b</option><option>c</option>
		    <option>d</option><option>h</option>
		    <option>s</option><option>v</option></entry>
		  <entry>ブートフラグの設定</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>完全にディスクレスな場合の一般的な cfg
	    ファイルは以下のようになります:</para>

	  <programlisting>
rootfs 192.1.2.3:/rootfs/myclient
swapfs 192.1.2.3:/swapfs
swapsize 20000
hostname myclient.mydomain</programlisting>

	  <para>ローカルに swap
	    を持つマシンについては以下のようになります:</para>

	  <programlisting>
rootfs 192.1.2.3:/rootfs/myclient
hostname myclient.mydomain</programlisting>

	</step>

	<step>
	  <para>NFS サーバがクライアントにroot(必要ならswapも)
	    ファイルシステムをexportしているか, また,
	    クライアントがこれらのファイルシステムに
	    ルートアクセスできるか確認します. FreeBSDにおける一般的な
	    <filename>/etc/exports</filename> ファイルは
	    以下のようになります:</para>

	  <programlisting>
/rootfs/myclient -maproot=0:0 myclient.mydomain
/swapfs -maproot=0:0 myclient.mydomain</programlisting>

	  <para>そして, HP-UX側では以下のようになります:</para>

	  <programlisting>
/rootfs/myclient -root=myclient.mydomain
/swapfs -root=myclient.mydomain</programlisting>
	</step>

	<step>
	  <para>NFS経由でスワッピングを行う場合
	    (完全にディスクレスな場合の設定), クライアントが使用する
	    swap ファイルを <command>dd</command> で作成します.
	    もし, <command>swapfs</command> コマンドが上記の例のように
	    引数 <filename>/swapfs</filename>を持ちそのサイズが 20000
	    である場合, myclientに対するスワップファイルは
	    <filename>/swapfs/swap.<replaceable>X.X.X.X</replaceable>
	    </filename> で呼び出されます. ここで
	    <replaceable>X.X.X.X</replaceable> はクライアントの IP
	    アドレスです. 例:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/swapfs/swap.192.1.2.4 bs=1k count=20000</userinput></screen>

	  <para>また, スワッピングが開始されるとクライアントの
	    スワップスペースはセンシティブな情報を含むようになるので,
	    不正なアクセスを防止するため, このファイルへの
	    読み書きのアクセス制限がなされていることを確認して下さい:
	  </para>

	  <screen>&prompt.root; <userinput>chmod 0600 /swapfs/swap.192.1.2.4</userinput></screen>
	</step>

	<step>
	  <para>クライアントがそれぞれのrootファイルシステムとして使う
	    ディレクトリにrootファイルシステムを展開します.
	    (上記の例では<filename>/rootfs/myclient</filename>).</para>

	  <itemizedlist>
	    <listitem>
	      <para>HP-UX システム: サーバはHP9000/800
		シリーズのマシンで, HP-UX 9.04 以降が必要です.
		これ以前のバージョンでは NFS
		を経由するデバイスファイルが作成ができません.</para>
	    </listitem>

	    <listitem>
	      <para><filename>/rootfs/myclient</filename> に
		<filename>/dev</filename> を
		展開する際に, いくつかのシステム (HPUX) では
		FreeBSD に合った デバイスファイルが作成されないので
		注意してください.
		その際には最初の起動時にシングルユーザモードに
		移行して (ブートの段階でCtrl-Cを押す),
		<filename>/dev</filename> に移って
		<command>sh ./MAKEDEV all</command> として,
		クライアントからこれを 修正してください.</para>
	    </listitem>
	  </itemizedlist>
	</step>

	<step>
	  <para>クライアントで <command>netboot.com</command>
	    を実行するか, <filename>netboot.rom</filename>
	    ファイルから EPROMを作成します.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title><filename>/</filename> および <filename>/usr</filename>
	ファイルシステムを共有して使用する</title>

      <para>今のところ, これを行う公式に認められた方法はありませんが,
	私はそれぞれのクライアントで <filename>/usr</filename>
	ファイルシステムと個々の <filename>/</filename>
	ファイルシステムを共有して使っています.
	どなたかこれをきちんと行うやり方の提案がありましたら,
	私に, もしくは &a.core; グループに知らせてください.</para>
    </sect2>

    <sect2>
      <title>特定の設定についてnetbootをコンパイルする</title>

      <para><filename>/sys/i386/boot/netboot/Makefile</filename>
	の中の設定を変更して
	コンパイルすることで, netbootでNE1000/2000
	カードをサポートします.
	このファイルの先頭にあるコメントを見てください.</para>
    </sect2>
  </sect1>

  <sect1 id="isdn">
    <title>ISDN</title>

    <para><emphasis>最終更新: &a.wlloyd;</emphasis>.</para>

    <para><emphasis>訳: &a.jp.kiroh;.
	11 December 1996.</emphasis></para>

    <para>ISDN 技術とハードウェアに関しては,
      <ulink url="http://alumni.caltech.edu/~dank/isdn/">
	Dan Kegel's ISDN Page</ulink> がよい参考になるでしょう.</para>

    <para>ISDN の導入手順は, 簡単にいって以下のようになります. </para>

    <itemizedlist>
      <listitem>
	<para>ヨーロッパ在住の方は, ISDN
	  カードの節に進んでください.</para>
      </listitem>

      <listitem>
	<para>ISDN を使って,
	  インターネットプロバイダに(専用線は使用せず), ダ
	  イアルアップ接続しようとしている場合は,
	  ターミナルアダプタの使用を考えてみてください.
	  この方法はもっとも柔軟性があり, プロバイダを変更した場
	  合の問題も少ないでしょう.</para>
      </listitem>

      <listitem>
	<para>2つの LAN の間を接続しようする場合や, ISDN
	  専用線を使用する場合 には,
	  スタンドアローンルータ/ブリッジの使用を勧めます.</para>
      </listitem>
    </itemizedlist>

    <para>どの方法を用いるかを決定するには,
      費用が重要な要素になってきます.  以下に, 最も安価な方法から,
      高価な方法まで順に説明していきます.</para>

    <sect2>
      <title>ISDN カード</title>

      <para><emphasis>著者:&a.hm;.</emphasis></para>

      <para>このセクションの記述は, DSS1/Q.931 ISDN
	標準がサポートされている国のユーザにのみ有効です.</para>

      <para>最近増えてきている PC ISDN カードのうちいくつかは, FreeBSD
	2.2.x 以降で isdn4bsd
	ドライバパッケージによりサポートされています.
	依然として開発中ではありますが,
	ヨーロッパ中でうまく動作しているという報告があります.</para>

      <para>最新の isdn4bsd は,
	<ulink url="ftp://isdn4bsd@ftp.consol.de/pub/">
	  ftp://isdn4bsd@ftp.consol.de/pub/</ulink> から入手できます.
	この ftp サイトでは, ユーザ名として <username>isdn4bsd</username>
	を使い, パスワードにメールアドレスを使ってログインする
	必要があります. ログインできたら <filename>pub</filename>
	ディレクトリに移動してください. ユーザー名
	<username>ftp</username> や <username>anonymous</username>
	によるログインでは, 必要なファイルにたどりつけません.</para>

      <para>isdn4bsd は, IP over raw HDLC もしくは同期 PPP
	を利用して他の ISDN ルータと接続できます.
	留守番電話アプリケーションも使えます.</para>

      <para>Siemens ISDN チップセット (ISAC/HSCX)
	を使用したものを主に多くのカードがサポートされています.
	他のチップセット (Motorola, Cologn ChipDesigns)
	のサポートは現在開発中です.
	サポートされるカードの最新のリストは,
	<ulink url="ftp://isdn4bsd@ftp.consol.de/pub/README">README</ulink>
	を参照してください.</para>

      <para>他の ISDN プロトコルを追加したい場合や,
	サポートされていない ISDN PC カード サポートしたい場合など
	isdn4bsd を拡張したい場合は, <email>hm@kts.org</email>
	までご連絡ください.</para>

      <para>majordomoによるメーリングリストが利用できます.
	参加するには, 本文に</para>

      <programlisting>
subscribe freebsd-isdn</programlisting>

      <para>と記入したメールを
	&a.majordomo; 宛てに送ってください.</para>
    </sect2>

    <sect2>
      <title>ISDN ターミナルアダプタ</title>

      <para>ターミナルアダプタ (TA) はISDN に対して,
	通常の電話線に対するモデムに相当するものです.</para>

      <para>ほとんどの TA は, 標準のヘイズ AT
	コマンドセットを使用しているので,
	単にモデムと置き換えて使うことができます.</para>

      <para>TA は, 基本的にはモデムと同じように動作しますが,
	接続方法は異なり, 通信速度も古いモデムよりはるかに速くなります.
	<link linkend="ppp">PPP</link> の設定を,
	モデムの場合と同じように行ってください. とくにシリアル速度を
	使用できる最高速度に設定するのを忘れないでください.</para>

      <para>プロバイダへの接続に TA を使用する最大のメリットは, 動的
	PPP を行えることです. 最近 IP アドレスが不足してきているため,
	ほとんどのプロバイダは, 専用の IP
	アドレスを割り当てないようになっています.
	ほとんどのスタンドアローンルータは, 動的 IP
	アドレスに対応していません.</para>

      <para>訳注: 最近の ISDN ルータでは, IP
	アドレスの動的割り当てに対応しているものも多いようです.
	ただし制限がある場合もありますので, 詳しくはメーカ
	に問い合わせてください.</para>

      <para>TA を使用した場合の機能や接続の安定性は, 使用している PPP
	デーモンに完全に依存します. そのため, FreeBSD で PPP
	の設定が完了していれば, 使用している既存のモデムを ISDN の TA
	に簡単にアップグレードすることができます. ただし, それまでの
	PPP のプログラムに問題があった場合, その問題は TA
	に置き換えてもそのまま残ります.</para>

      <para>最高の安定性を求めるのであれば, ユーザープロセス
	<link linkend="userppp">iijPPP</link> ではなく, カーネル
	<link linkend="ppp">PPP</link>を使用してください.</para>

      <para>以下の TA は, FreeBSD で動作確認ずみです.</para>

      <itemizedlist>
	<listitem>
	  <para>Motorola BitSurfer および Bitsurfer Pro</para>
	</listitem>

	<listitem>
	  <para>Adtran</para>
	</listitem>
      </itemizedlist>

      <para>他の TA もほとんどの場合うまく動作するでしょう. TA
	のメーカーでは, TA  がほとんどの標準モデム AT
	コマンドセットを受け付けるようにするよう,
	努力しているようです.</para>

      <para>外部 TA を使う際の最大の問題点は,
	モデムの場合と同じく良いシリアルカー
	ドが必要であるということです.</para>

      <para>シリアルデバイスの詳細,
	そして非同期シリアルポートと同期シリアルポートの差については,
	ハンドブックの<link linkend="uart">シリアルポート</link> の
	節を参照してください.</para>

      <para>標準の PC シリアルポート(非同期)に接続された TA は, 128Kbs
	の接続を行っていても, 最大通信速度が 115.2Kbs
	に制限されてしまいます. 128Kbs の  ISDN
	の性能を最大限に生かすためには, TA
	を同期シリアルカードに接続しなければなりません.</para>

      <para>内蔵 TA を購入して,
	同期／非同期問題を片付けてしまおうとは思わないでく ださい.
	内蔵 TA には, 単に標準 PC シリアルポートのチップが内蔵されてい
	るだけです. 内蔵 TA の利点といえば,
	シリアルケーブルを買わなくていいと いうことと,
	電源コンセントが一つ少なくて済むということくらいでしょう.
      </para>

      <para>同期カードと TA の組合せは 386 の FreeBSD
	マシンの場合でも, スタンドア
	ローンのルータと同程度の速度は確保できます.
	またこの組合せでは, ルータより柔軟な設定が可能です.</para>

      <para>同期カード/TA を選ぶか, スタンドアローンルータを選ぶかは,
	多分に宗教的な問題です.
	メーリングリストでもいくつか議論がありました. 議論の内容に
	ついては, <ulink url="../search/search.html">archives</ulink>
	を参照してください.</para>
    </sect2>

    <sect2>
      <title>スタンドアローン ISDN ブリッジ/ルータ</title>

      <para>ISDN ブリッジやルータは, OS 特有のものではありません.
	もちろん FreeBSD 特有のものでもありません.
	ルーティングやブリッジング技術に関する詳細は,
	ネットワークの参考書をご覧ください.</para>

      <para>このページでは,
	ルータとブリッジにどちらでもあてはまるように記述します.</para>

      <para>ISDN ルータ/ブリッジは,
	ローエンドの製品のコストが下がってきていることもあり,
	より一般的に使用されるようになるでしょう. ISDN ルータは,
	外見は小さな箱で,
	ローカルのイーサネットネットワーク(もしくはカード)と直接,
	接続します. また,
	自身で他のブリッジ/ルータとの接続を制御します. PPP
	や他のプロトコルを使用するためのソフトウェアは,
	すべて組み込まれています.</para>

      <para>ルータは, 完全な同期 ISDN 接続を使用するため, 通常の TA
	と比較してスループットが大幅に向上します.</para>

      <para>ISDN ルータ/ブリッジを使用する場合の最大の問題点は,
	各メーカーの製品間に相性の問題がまだ存在することです.
	インターネットプロバイダとの接続を考えている場合には,
	プロバイダと相談することをお勧めします.</para>

      <para>事務所の LAN と家庭の LAN の間など, 二つの LAN
	セグメントの間を接続しようとしている場合は,
	ブリッジ/ルータの使用がもっともメンテナンスが 簡単で,
	努力が少なくてすむ方法です. 両側の機材を購入するのであれば,
	メーカー間の接続性の問題もないでしょう.</para>

      <para>たとえば家庭の LAN や出張所の LAN
	を本社のネットワークに接続するためには,
	以下のような設定が使用できます.</para>

      <example>
	<title>出張所 LAN または 家庭 LAN</title>

	<para>ネットワークは, 10 Base T イーサネットです.
	  ルータとネットワークの間は, 必要に応じて AUI/10BT
	  トランシーバを使って接続します.</para>

	<!-- This should be a graphic -->
	<programlisting>
---Sun ワークステーション
|
---FreeBSD マシン
|
---Windows 95 (別に勧めているわけじゃありません)
|
スタンドアローンルータ
   |
ISDN BRI ライン</programlisting>

	<para>
	  家庭/出張所 LAN で,
	  一台しかコンピュータを接続しないのであれば, クロス
	  のツイストペアケーブルを使用して,
	  スタンドアローンルータと直結も可能です.</para>
      </example>

      <example>
	<title>本社 LAN や他の LAN</title>

	<para>ネットワークは, ツイストペアイーサネットです. </para>

	<!-- This should be a graphic -->
	<programlisting>
    -------Novell サーバ
    | 	|
    |ハ	---Sun
    |	|
    | 	---FreeBSD
    |	|
    |ブ	---Windows 95
    | 	|
    |___---スタンドアローンルータ
		|
       	ISDN BRI ライン</programlisting>

      </example>

      <para>ほとんどのルータ/ブリッジでは, 別々の二つのサイトに対して,
	<emphasis>同時</emphasis>にそれ
	ぞれ<emphasis>独立した</emphasis>二つの PPP 接続が可能です.
	これは, 通常の TA ではサポートされない機能で,
	ルータ/ブリッジ接続の大きな利点です (シリアルポートを
	二つもつ特殊(そして高価な) TA では可能です).
	チャンネル割り当てや MPP などと混同しないでください.</para>

      <para>これは, 大変便利な機能です.
	たとえば事務所で専用線インターネット ISDN  接続を使用していて,
	別の ISDN ラインを購入したくないとします. この場合,
	事務所のルータは, 一つの専用線 B
	チャンネル接続(64Kbs)を維持しつつ, 別 の B
	チャンネルを他の用途に使用することができます. たとえば,
	他の場所 とのダイアルイン, ダイアルアウトに使用したり,
	バンド幅を増やすために,
	インターネットとの接続への動的に割り当て(MPP
	など)に使用したりすることが可能です.</para>

      <para>またイーサネットブリッジは, IP パケットだけでなく IPX/SPX
	などすべての
	プロトコルのパケットを中継することが可能です.</para>

    </sect2>
  </sect1>

  <sect1 id="nis">
    <title>NIS/YP</title>

    <para><emphasis>原作: &a.unfurl;, 2000 年 1 月 21 日.</emphasis></para>

    <sect2>
      <title>NIS/YP とは?</title>
  
      <para>NIS は RPC を使ったクライアント/サーバシステムです. これを
	使うことで. NISドメイン内のマシン間で共通の設定ファイルを共有すること
	ができます. また, NIS を使うことでシステム管理者は最小限の設定データ
	で NIS クライアントを立ち上げることができ, 1 ヶ所から設定データの
	追加, 削除, 変更が可能です. </para>
    </sect2>
  
    <sect2>
      <title>動作のしくみ</title>
        
      <para>NIS 環境にあるホストは, 次の 3 種類に分類されます. それは,
        マスターサーバ, スレーブサーバ, クライアントです.
        サーバは, ホストの設定情報の中心的な情報格納庫の役割をします.
        マスターサーバは元となる信頼できる情報を保持し,
        スレーブサーバは, 冗長性を確保するため, この情報をミラーします.
        そしてクライアントは, サーバから情報の提供を受けて動作します.</para>

      <para>この方法を用いることで, 数多くのファイルにある情報が共有できます.
        よく NIS で共有されるのは,
        <filename>master.passwd</filename> や <filename>group</filename>,
	<filename>hosts</filename> といったファイルです.
        クライアント上のプロセスで, 通常ローカルのファイルにある情報が必要
	となったとき,
        クライアントは接続しているサーバに問い合わせを行い, その情報を得ます. 
      </para>
    </sect2>
    
    <sect2>
      <title>NIS/YP を使う</title>
  
      <sect3>
        <title>計画を立てる</title>
  
	 <para>もし NIS によるシステム管理の設定を行なうのが初めてなら,
          どのようにしたいのか, ひととおり最後まで考えてみることをお勧めします.
          ネットワークの規模によらず, いくつか決めるべきことがあるためです.</para>
  
        <sect4>
          <title>NIS ドメイン名を決める</title>
  
          <para>ここでいうドメイン名は, 今まであなたが使っていた,
            いわゆる&ldquo;ドメイン名&rdquo;
            と呼んでいたものとは違います.
	    正確には&ldquo;NIS ドメイン名&rdquo;と呼ばれます.
            クライアントがサーバに情報を要求するとき,
            その要求には自分が属する NIS ドメインの名前が含まれています.
	    これは, 1 つのネットワークに複数のサーバがある場合に,
            どのサーバが要求を処理すれば良いかを決めるために使われます.
	    NIS ドメイン名とは, 関連のあるホストをグループ化するための名前である,
            と考えると良いでしょう. </para>
	
	  <para>組織によってはインターネットのドメイン名を
            NIS ドメイン名に使っているところがありますが,
            これはネットワークのトラブルをデバッグするときに混乱の原因となるため,
            お勧めできません.
            NIS ドメイン名はネットワーク内で一意なければならないので,
            ドメイン名がドメインに含まれるマシンを表すようなものであれば,
            分かりやすくなります. たとえば
            Acme 社のアート(Art)部門であれば,
            NIS ドメイン名を"acme-art"とすれば良いでしょう. </para>
        </sect4>

        <sect4>
          <title>サーバマシンの物理的な条件とは</title>
            
	  <para>NIS サーバとして使うマシンを選ぶ際には,
            いくつかの注意点があります.
            NIS における困ったことの一つに,
            クライアントのサーバへの依存度があります.
            クライアントが自分の NIS ドメインのサーバに接続できない場合,
            マシンが使用不能になることがよくあります.
            もし, ユーザやグループに関する情報が得られなければ,
            ほとんどのシステムは一時的にですが停止してしまいます.
            こういったことを念頭に置いて,
            しょっちゅうリブートされるマシンや,
            開発に使われそうなマシンを選ばないようにしなければなりません.
            理想的には, NIS サーバはスタンドアロンで
            NIS サーバ専用となるマシンにするべきです.
            ネットワークの負荷が重くなければ,
            他のサービスを走らせているマシンを NIS
            サーバにしてもかまいません. ただし NIS
            サーバが使えなくなると,
            <emphasis>すべての</emphasis>クライアントに影響をおよぼす,
            という点には注意しなければなりません.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>NIS サーバ</title>

	<para>元となるすべての NIS 情報は,
          NIS マスターサーバと呼ばれる 1 台のマシンに置かれます.
          この情報が格納されるデータベースを NIS マップと呼びます.
          FreeBSDでは, このマップは
	  <filename>/var/yp/[domainname]</filename> に置かれます.
	  <filename>[domainname]</filename> は,
          サーバがサービスする NIS ドメインです.
          1 台の NIS サーバが複数のドメインをサポートすることも可能です.
          つまり, このディレクトリを各々のドメインごとに作ることができ,
          各ドメインごと, 独立したマップの集合を持つことになります.</para>

	<para>NIS のマスターサーバとスレーブサーバ上では,
	  <command>ypserv</command> デーモンがすべての NIS 要求を処理します.
          <command>ypserv</command> は NIS クライアントからの要求を受け付け,
          ドメイン名とマップ名を対応するデータベースファイルへのパスに変換し,
          データをクライアントに返送します.</para>

        <sect4>
	  <title>NIS マスターサーバの設定</title>

	  <para>やりたいことにもよりますが,
            NIS マスターサーバの設定は比較的単純です.
            FreeBSD には <command>ypinit</command>
            という便利なスクリプトがあり, これを使うと初期設定を
            非常に簡単に行なうことができます.
            この設定を順調に進めるためには,
            いくつか事前にやらなければならないことがあります.</para>

	  <itemizedlist>
	    <listitem>
	      <para>NIS ドメイン名が設定されていることを, 
		<command>domainname</command> コマンドで確認してください.
		ホストが属していないドメインに対しても
		<command>ypinit</command> を実行することはできますが,
		<literal>domainname</literal> が設定されていなければ
		この段階で設定すると良いでしょう.</para>
	    </listitem>

	    <listitem>
	      <para><filename>master.passwd</filename> ファイルが
		<filename>/var/yp</filename>
                に置かれていることを確認してください.
                NIS は, クライアントと共有するパスワードを
                このファイルから取得します.
		このファイルがない場合, <command>ypinit</command>
                はエラー終了します. これは, 新しい
                <filename>master.passwd</filename> でも,
                すでに存在する <filename>/etc/master.passwd</filename> を
		コピーしたものでもかまいません.  
		コピーする場合には,
                ユーザ全体やグループに対する読み出し許可属性が
                設定されていないことを確認してください.
		</para>
	    </listitem>

	    <listitem>
	      <para><command>ypserv</command> デーモンを起動してください.
                <command>ypinit</command> が動作するには,
		<command>ypserv</command> が RPC(Remote Procedure Call)
                の呼び出しに反応することが必要になります.
		通常の設定では,  
		<command>ypserv</command>
                にオプションフラグを指定する必要はありません.</para>
	    </listitem>
	  </itemizedlist>

	  <para>以上の手順が終了したら,
	    <option>-m</option> フラグを付けて <command>ypinit</command> を
            実行してください.
            立てようとしているマスターサーバのドメイン名が
            <literal>domainname</literal> に設定したものと異なっているなら,
            そのドメインを指定することができます.
	    下の例では, NIS のドメイン名を
            <filename>test-domain</filename> としています.
	    </para>

	  <screen>
# ypinit -m test-domain
Server Type: MASTER Domain: test-domain

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work. 

At this point, we have to construct a list of this domains YP servers.
master.example.com is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;Control D&gt;.
        master server   :  master.example.com
        next host to add:  <userinput>^D</userinput>
The current list of NIS servers looks like this:

master.example.com

Is this correct?  [y/n: y]  <userinput>y</userinput>
Building /var/yp/test-domain/ypservers...
Running /var/yp/Makefile...
NIS Map update started on Fri Dec  3 16:54:12 PST 1999 for domain test-domain
Updating hosts.byname...
Creating new /var/yp/passwd file from /var/yp/master.passwd...
Updating netid.byname...
Updating hosts.byaddr...
Updating networks.byaddr...
Updating networks.byname...
Updating protocols.bynumber...
Updating protocols.byname...
Updating rpc.byname...
Updating rpc.bynumber...
Updating services.byname...
Updating group.byname...
Updating group.bygid...
Updating passwd.byname...
Updating passwd.byuid...
Updating master.passwd.byname...
Updating master.passwd.byuid...
NIS Map update completed.

master.example.com has been setup as an YP master server without any errors.</screen>

	  <para>
            NIS サーバをきちんと動作させるためには, 
            <filename>/etc/rc.conf</filename> に数行, 追加する必要があります.
            次のような行があることを確認して下さい.
          </para>

	  <programlisting>
nis_server_enable="YES"
nis_server_flags=""
nis_yppasswdd_enable="YES"
nis_yppasswdd_flags=""</programlisting>

	  <para>
            ほとんどの場合, NIS サーバで <command>yppasswd</command> を
            実行させることを考えるでしょう.
            こうすると, クライアントマシンにいるユーザが,
            パスワードなどのユーザ情報をリモートから変更することが可能になります.
          </para>
	</sect4>

        <sect4>
	  <title>NIS スレーブサーバの設定</title>

	  <para>
            NIS スレーブサーバの設定は, マスターサーバの設定よりも簡単で,
            <command>ypinit</command> コマンドを使うだけでほとんど終わりです.
            前述の例と同じように, NIS ドメイン名として &ldquo;test-domain&rdquo;
            を使っています.  
          </para>

	  <screen>
# ypinit -s master.example.com test-domain

Server Type: SLAVE Domain: test-domain Master: master.example.com

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  <userinput>n</userinput>

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work. 
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from master.example.com.
Transfering netgroup...
ypxfr: Exiting: Map successfully transfered
Transfering netgroup.byuser...
ypxfr: Exiting: Map successfully transfered
Transfering netgroup.byhost...
ypxfr: Exiting: Map successfully transfered
Transfering master.passwd.byuid...
ypxfr: Exiting: Map successfully transfered
Transfering passwd.byuid...
ypxfr: Exiting: Map successfully transfered
Transfering passwd.byname...
ypxfr: Exiting: Map successfully transfered
Transfering group.bygid...
ypxfr: Exiting: Map successfully transfered
Transfering group.byname...
ypxfr: Exiting: Map successfully transfered
Transfering services.byname...
ypxfr: Exiting: Map successfully transfered
Transfering rpc.bynumber...
ypxfr: Exiting: Map successfully transfered
Transfering rpc.byname...
ypxfr: Exiting: Map successfully transfered
Transfering protocols.byname...
ypxfr: Exiting: Map successfully transfered
Transfering master.passwd.byname...
ypxfr: Exiting: Map successfully transfered
Transfering networks.byname...
ypxfr: Exiting: Map successfully transfered
Transfering networks.byaddr...
ypxfr: Exiting: Map successfully transfered
Transfering netid.byname...
ypxfr: Exiting: Map successfully transfered
Transfering hosts.byaddr...
ypxfr: Exiting: Map successfully transfered
Transfering protocols.bynumber...
ypxfr: Exiting: Map successfully transfered
Transfering ypservers...
ypxfr: Exiting: Map successfully transfered
Transfering hosts.byname...
ypxfr: Exiting: Map successfully transfered

slave.example.com has been setup as an YP slave server without any errors. 
Don't forget to update map ypservers on master.example.com.</screen>
        
	  <para>
            この例の場合, <filename>/var/yp/test-domain</filename>
            というディレクトリが必要になります.  
            NIS マスターサーバのマップファイルのコピーは, 
            このディレクトリに置かれ,
            最新のものに維持されていなければなりません.
            次のエントリをスレーブサーバの <filename>/etc/crontab</filename>
            に追加することで, 最新のものに保つことができます.
          </para>
        
	  <programlisting>
20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</programlisting>

	  <para>
            この二行は, スレーブサーバにあるマップファイルを, 
            マスターサーバのマップファイルと同期させるものですが, 
            必須というわけではありません. なぜなら,
            マスターサーバは, NIS マップに対する変更を
            スレーブサーバに伝えようとするからです.
            しかし, サーバが管理するシステムにとってパスワード情報はとても重要なものですので,
            強制的に更新してしまう方が良いでしょう.
            特に, マップファイルの更新がきちんと行なわれるかどうか
            わからないくらい混雑するネットワークでは, 重要なポイントになります.
          </para>
	</sect4>
      </sect3>

      <sect3>
        <title>NIS クライアント</title>
	
	<para>NIS クライアントは <application>ypbind</application>
          デーモンを使って, 特定の NIS
          サーバとの間に結合(binding)と呼ばれる関係を成立させます. 
	  <application>ypbind</application> は,
          システムのデフォルトのドメイン(<command>domainname</command>
          コマンドで設定されます)をチェックし, RPC 要求を
          ブロードキャストパケットとしてローカルネットワークに送信します.
          この RPC 要求により, <command>ypbind</command>
          が結合を成立させようとしているドメイン名が指定されます.
	  要求されているドメイン名に対してサービスするよう設定されたサーバが
          ブロードキャストパケットを受信すると, サーバは
          <command>ypbind</command> に応答し,
          <command>ypbind</command> は応答のあったサーバのアドレスを記録します. 
	  複数のサーバがある(たとえば一つのマスターサーバと,
          複数のスレーブサーバがある)場合,
          <command>ypbind</command> は,
          最初に応答したサーバのアドレスを使用します.
          これ以降, クライアントのシステムは,
          すべての NIS の要求をそのサーバに向けて送信します. 
	  <application>ypbind</application> は,
          サーバが順調に動作していることを確認するため,
          時々 &ldquo;ping&rdquo; をサーバに送ります.
          反応が戻ってくるべき時間内に ping に対する応答が来なければ,
	  <command>ypbind</command> は,
          そのドメインを結合不能(unbound)として記録し,
          別のサーバを見つけるべく, 再びブロードキャストパケットの送信を行います. 
        </para>

	<sect4>
	  <title>NIS クライアントの設定</title>
	  
	  <para>FreeBSD マシンにおける NIS クライアントの設定,
            非常に簡単です.</para>
	
	  <itemizedlist>
	    <listitem>
	      <para>まず, ホストの NIS ドメイン名を設定します.
                これは, <command>domainname</command>
                コマンドで設定するか,
                以下のエントリを
                <filename>/etc/rc.conf</filename>
                に追加して, ブート時に設定されるようにしてください.
              </para>

	      <programlisting>nisdomainname="test-domain"</programlisting>
	    </listitem>

	    <listitem>
	      <para>NIS サーバにある,
                すべてのパスワードエントリを取り込むため, 
                <command>vipw</command>コマンドで以下の行を
                <filename>/etc/master.passwd</filename>
                に追加します. </para>

	      <programlisting>+:::::::::</programlisting>

	      <note>
		<para>この行によって,
                  NIS サーバのパスワードマップにアカウントがある人全員に,
                  アカウントが与えられます.
                  この行を変更すると, さまざまな NIS
                  クライアントの設定を行なうことが可能です.
		  これ以上詳しく知りたい方は,
                  O'Reilly の
                  <literal>Managing NFS and NIS</literal>
                  をお読みください.</para>
	      </note>
	    </listitem>

	    <listitem>
	      <para>
                NIS サーバにある,
                すべてのグループエントリを取り込むため, 
	        以下の行を
                <filename>/etc/group</filename>
                に追加します.
	　　　</para>
	        
	      <programlisting>+:*::</programlisting>
	    </listitem>
	  </itemizedlist>

	  <para>上記の手順がすべて完了すれば,
	    <command>ypcat passwd</command> によって
            NIS サーバの passwd マップが参照できるようになっているはずです.
          </para>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>NIS セキュリティ</title>

      <para>一般に, ドメイン名さえ知っていれば,
        どこにいるリモートユーザでも ypserv に RPC を発行し,
        NIS マップの内容を引き出すことができます.
        こういった不正なやりとりを防ぐため,
        ypserv には securenets と呼ばれる機能があります.
        これはアクセスを決められたホストだけに制限する機能です.
        ypserv は起動時に,
        <filename>/var/yp/securenets</filename> ファイルから
        securenets に関する情報を読み込みます.</para>
	
      <note>
	<para>上記のパス名は, <option>-p</option>
          オプションで指定されたパス名によって変わります.
          このファイルは, 空白で区切られた
          ネットワーク指定とネットマスクのエントリからなっていて,
          &ldquo;#&rdquo; で始まる行はコメントとみなされます.
          簡単な securenets ファイルの例を以下に示します.</para>
      </note>

      <programlisting>
# allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
10.0.0.0      255.255.240.0</programlisting>

      <para>ypserv が上記のルールの一つと合致するアドレスからの要求を受け取った場合,
        処理は通常に行なわれます.
        もしアドレスがルールに合致しなければ,
        その要求は無視されて警告メッセージがログに記録されます.
	また, <filename>/var/yp/securenets</filename>
        が存在しない場合, ypserv は, すべてのホストからの接続を受け入れます.
      </para>

      <para>ypserv は,
        Wietse Venema 氏による
	<application>tcpwrapper</application>
        パッケージもサポートしています.
        そのため, <filename>/var/yp/securenets</filename> の代わりに
        tcpwrapper の設定ファイルを使ってアクセス制御を行なうことも可能です.
      </para>

      <note>
	<para>これらのアクセス制御機能は一定のセキュリティを提供しますが,
          どちらも特権ポートのテストのような &ldquo;IP spoofing&rdquo;
          攻撃に対して脆弱です.</para>
      </note>
    </sect2>

    <sect2>
      <title>NIS v1 との互換性</title>

      <para>FreeBSD の
        <application>ypserv</application> は,
        NIS v1 クライアントを部分的にサポートします.
        FreeBSD の NIS 実装は NIS v2 プロトコルのみを使用していますが,
        ほかの実装では, 古いシステムとの下位互換性を持たせるため
        v1 プロトコルをサポートしているものもあります.
        そのようなシステムに付いている
        <application>ypbind</application> デーモンは,
        必要がないにもかかわらず NIS v1
        のサーバとの結合を成立させようとします(しかも
	v2 サーバからの応答を受信した後でも,
        ブロードキャストをし続けるかも知れません).
        FreeBSD の ypserv は,
        クライアントからの通常のリクエストはサポートしていますが,
        v1 のマップ転送リクエストはサポートしていないことに注意してください.
        つまり FreeBSD の ypserv を,
        v1 だけをサポートするような古い NIS サーバと組み合わせて
        マスターやスレーブサーバとして使うことはできません.
        幸いなことに, 現在, そのようなサーバが使われていることは
        ほとんどないでしょう.</para>
    </sect2>

    <sect2>
      <title>NIS クライアントとしても動作している NIS サーバ</title>

      <para>複数のサーバが存在し, サーバ自身が NIS
        クライアントでもあるようなドメインで  ypserv が実行される場合には,
        注意が必要です.
        一般的に良いとされているのは,
        他のサーバと結合をつくるようにブロードキャストパケットの送信をさせるのではなく,
        サーバをそれ自身に結合させることです.
        もし, サーバ同士が依存関係を持っていて, 一つのサーバが停止すると,
        奇妙なサービス不能状態に陥ることがあります.
        その結果, すべてのクライアントはタイムアウトを起こして
        他のサーバに結合しようと試みますが,
        これにかかる時間はかなり大きく,
        サーバ同士がまた互いに結合してしまったりすると,
        サービス不能状態はさらに継続することになります.</para>

      <para>
        <command>ypbind</command> に
        <option>-S</option> オプションフラグを指定して実行することで, 
        ホストを特定のサーバに結合することが可能です.
      </para>
    </sect2>

    <sect2>
      <title>libscrypt 対 libdescrypt</title>

      <para>
        NIS を実装しようする人の誰もがぶつかる問題の一つに,
        暗号ライブラリの互換性があります.
        NIS サーバが DES 暗号ライブラリを使っている場合には,
        同様に DES を使用しているクライアントしかサポートできません. 
	サーバとクライアントがどのライブラリを使用しているかは,
        <filename>/usr/lib</filename>
        のシンボリックリンクを見ればわかります.
        あるマシンが DES ライブラリを使うように設定されている場合,
        リンクは以下のようになっています. </para>

      <screen>
&prompt.user; <userinput>ls -l /usr/lib/*crypt*</userinput>
lrwxrwxrwx  1 root  wheel     13 Jul 15 08:55 /usr/lib/libcrypt.a@ -> libdescrypt.a
lrwxrwxrwx  1 root  wheel     14 Jul 15 08:55 /usr/lib/libcrypt.so@ -> libdescrypt.so
lrwxrwxrwx  1 root  wheel     16 Jul 15 08:55 /usr/lib/libcrypt.so.2@ -> libdescrypt.so.2
lrwxrwxrwx  1 root  wheel     15 Jul 15 08:55 /usr/lib/libcrypt_p.a@ -> libdescrypt_p.a
-r--r--r--  1 root  wheel  13018 Nov  8 14:27 /usr/lib/libdescrypt.a
lrwxr-xr-x  1 root  wheel     16 Nov  8 14:27 /usr/lib/libdescrypt.so@ -> libdescrypt.so.2
-r--r--r--  1 root  wheel  12965 Nov  8 14:27 /usr/lib/libdescrypt.so.2
-r--r--r--  1 root  wheel  14750 Nov  8 14:27 /usr/lib/libdescrypt_p.a</screen>

      <para>マシンが FreeBSD の標準の MD5 暗号ライブラリを使うように
	設定されている場合には, 以下のようになります. </para>

      <screen>
&prompt.user; <userinput>ls -l /usr/lib/*crypt*</userinput>
lrwxrwxrwx  1 root  wheel     13 Jul 15 08:55 /usr/lib/libcrypt.a@ -> libscrypt.a
lrwxrwxrwx  1 root  wheel     14 Jul 15 08:55 /usr/lib/libcrypt.so@ -> libscrypt.so
lrwxrwxrwx  1 root  wheel     16 Jul 15 08:55 /usr/lib/libcrypt.so.2@ -> libscrypt.so.2
lrwxrwxrwx  1 root  wheel     15 Jul 15 08:55 /usr/lib/libcrypt_p.a@ -> libscrypt_p.a
-r--r--r--  1 root  wheel   6194 Nov  8 14:27 /usr/lib/libscrypt.a
lrwxr-xr-x  1 root  wheel     14 Nov  8 14:27 /usr/lib/libscrypt.so@ -> libscrypt.so.2
-r--r--r--  1 root  wheel   7579 Nov  8 14:27 /usr/lib/libscrypt.so.2
-r--r--r--  1 root  wheel   6684 Nov  8 14:27 /usr/lib/libscrypt_p.a</screen>
	
      <para>NIS クライアントの認証でトラブルが発生した場合には,
        ここから問題となりそうな部分を探すと良いでしょう.
      </para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
