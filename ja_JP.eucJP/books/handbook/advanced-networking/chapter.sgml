<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.36
     $FreeBSD$
-->

<chapter id="advanced-networking">
  <title>高度なネットワーク</title>

  <sect1>
    <title>この章では</title>

    <para>以下の章では, UNIX
       システム上で良く利用されるネットワークサービスについて書かれています.
      これはもちろん, あなたの FreeBSD
      システムでの, そのようなサービスの設定に関する内容です.</para>
  </sect1>

  <sect1 id="routing">
    <title>ゲートウェイとルート</title>

    <para><emphasis>原作: &a.gryphon;.
	1995 年 10 月 6 日.</emphasis></para>

    <para><emphasis>訳: &a.jp.yuki;.
        1996 年 9 月 6 日.</emphasis></para>

    <para>あるマシンが他のマシンをみつけることができるようにするには,
      あるマシンから他のマシンへ,
      どのようにたどり着くかを適切に記述するための仕組みが必要です.
      この仕組みをルーティングと呼びます. <quote>ルート(経路)</quote>は
      <quote>destination (目的地)</quote> と <quote>gateway
      (ゲートウェイ)</quote> の 2 つのアドレスの組で定義します. あなたが
      <emphasis>destination</emphasis> へアクセスしようとした場合,
      <emphasis>gateway</emphasis>
      を通って送られることをこのペアは示しています.  destination
      には個々のホスト, サブネット, <quote>デフォルト</quote> の 3つの
      タイプがあります.
      <quote>デフォルトルート</quote> は他への経路が適用できない
      場合に使われます. のちほどデフォルトルートについて少し述べること
      するとして, ここでは, 個々のホスト, インタフェース
      (<quote>リンク</quote> とも呼ばれます),
      イーサネットハードウェアアドレスという 3つのタイ
      プのゲートウェイについて説明します.</para>

    <sect2>
      <title>例</title>

      <para>以下に示す <command>netstat -r</command>
	の出力の例を使って, ルーティン
	グがいろいろと異なっている様子を説明することにします.</para>

      <screen>Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     link#1             UHLW        1     2421
foobar.com       link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =&gt;
host2.foobar.com link#1             UC          0        0
224              link#1	            UC          0        0</screen>

      <para>最初の2行はデフォルトルート(次の節で詳しく説明します)と,
	<hostid>localhost</hostid>への経路を示しています.</para>

      <para><literal>localhost</literal>のためのインタフェース
	(<literal>Netif</literal>の欄)
	は<devicename>lo0</devicename>で,
	これはループバックデバイスとして知られています.
	結局のところ戻るだけなので, この
	destinationへのすべてのトラフィックが
	内部的に処理されるのであって, LAN
	を経由して送られるのではありません.</para>

      <para>次の行では
	<hostid role="mac">0:e0:...</hostid>
	というアドレスに注目しましょう.
	これはイーサネットハードウェアアドレスです. FreeBSDは自動的に
	ローカルなイーサネット上の任意のホスト
	(この例では<hostid>test0</hostid>) を見つけ,
	イーサネットインタフェース <devicename>ed0</devicename>
	の所にそのホストへの経路を直接つけ加えます. タイムアウト時間
	(<literal>Expire</literal>の 欄)
	も経路のタイプと結びついており, 指定された時間が経過しても応
	答がないときに使用します. この場合,
	経路情報は自動的に削除されま す. これらのホストは, RIP(Routing
	Information Protocol) という,
	最短パスの判定に基づいてローカルホストへの経路を
	決定する仕組みを利用することで認識されます.</para>

      <para>更に, FreeBSDではローカルサブネット
	(<hostid role="ipaddr">10.20.30.255</hostid> は
	<hostid role="ipaddr">10.20.30</hostid>
	というサブネットに対するブロードキャストアドレスで,
	<hostid role="domainname">foobar.com</hostid>
	はこのサブネットに結びつけられているドメイン名)
	への経路情報も加えることができます.
	<literal>link#1</literal>というのは,
	このマシンの最初のイーサネットカードのことをさします. これら
	については,
	何も追加インタフェースが指定されていないことに気づく
	でしょう.</para>

      <para>これらの2つのグループ(ローカルネットワークホストと
	ローカルサブネット) の両方とも, <command>routed</command>
	と呼ばれるデーモンによって自動的に経路が設定されます.
	<command>routed</command> を動かさなければ,
	静的に定義した (つまり具体的に設定した)
	経路のみ存在することになります.</para>

      <para><literal>host1</literal> の行は私たちのホストのことで,
	イーサネットアドレスで示されています.  送信側のホストの場合,
	FreeBSDはイーサネットインタフェースへ送るのではなく,
	ループバックインタフェース
	(<devicename>lo0</devicename>)を使います.</para>

      <para>2つある<literal>host2</literal>の行は,
	ifconfigのエイリアス (このようなことをする理由については
	ethernetの章を参照してください) を使ったとき
	にどのようになるかを示す例です.
	<devicename>lo0</devicename>の後にある<literal>=&gt;</literal>
	は, インタフェースが
	(このアドレスがローカルなホストを参照しているので)
	ループバックを使っているというだけでなく,
	エイリアスになっていることも示しています.
	このような経路はエイリアスをサポートしている
	ホストにのみ現れます.
	ローカルネットワーク上の他のすべてのホストでは
	単に<literal>link#1</literal>となります.</para>

      <para>最後の行 (destinationが<literal>224</literal>のサブネット)
	はマルチキャストで扱うものですが,
	これは他の章で説明します.</para>

      <para>他の欄については <literal>Flags</literal>
	について説明する必要があります.
	それぞれの経路は欄に示されているように違った属性を
	もっています.
	以下にいくつかのフラグとこれらが何を意味しているかを示します.
      </para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry>U</entry>
	      <entry>Up: この経路はアクティブです.</entry>
	    </row>

	    <row>
	      <entry>H</entry>
	      <entry>Host: 経路の destinationが単一のホストです.</entry>
	    </row>

	    <row>
	      <entry>G</entry>
	      <entry>Gateway: この destinationへ送られると, どこへ送れ
		ばよいかを明らかにして,
		そのリモートシステムへ送られます.</entry>
	    </row>

	    <row>
	      <entry>S</entry>
	      <entry>Static: この経路はシステムによって自動的に生成
		されたのではなく, 手動で作成されました.</entry>
	    </row>

	    <row>
	      <entry>C</entry>
	      <entry>Clone: マシンに接続したときにこの経路に基づく
		新しい経路が作られます.  このタイプの経路は通常は
		ローカルネットワークで使われます.</entry>
	    </row>

	    <row>
	      <entry>W</entry>
	      <entry>WasCloned: ローカルエリアネットワーク(Clone)
		の経路に基づいて
		自動的に生成された経路であることを示します.</entry>
	    </row>

	    <row>
	      <entry>L</entry>
	      <entry>Link: イーサネットハードウェアへの参照を含む
		経路です.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>デフォルトルート</title>

      <para>ローカルシステムからリモートホストにコネクションを張る
	必要がある場合, 既知のパスが存在するかどうかを確認するためにル
	ーティングテーブルをチェックします.
	到達するためのパスを知っているサブネットの内部に
	リモートホストがある場合 (Cloned routes), システムはインタフェース
	から接続できるかどうかをチェックします.</para>

      <para>知っているパスがすべて駄目だった場合でも, システムには
	最後の切り札の <quote>デフォルト</quote> ルートがあります.
	このルートは ゲートウェイルート (普通はシステムに
	1つしかありません) の特別なものです. そして,
	フラグフィールドは必ず <literal>c</literal>
	がマークされています. このゲートウェイは, LAN 内のホストにとっ
	て, 外部 (PPPのリンクを経由する場合や,
	データラインに接続するハードウェアデバイスなど)
	へ直接接続するマシンすべてのためのものです.</para>

      <para>外部に対するゲートウェイとして機能するマシンで
	デフォルトルートを設定する場合,
	デフォルトルートはインターネットサービスプロバイダ (ISP)
	のサイトのゲートウェイマシンになるでしょう.</para>

      <para>それではデフォルトルートの一例を見てみましょう.
	一般的な構成を示します. </para>

<literallayout>
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt;  [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
	    </literallayout>

      <para>ホスト <hostid>Local1</hostid> とホスト <hostid>Local2</hostid>
	を PPP で ISP のターミナルサーバと接続されているあなたの
	サイトだとします.
	ISP はサイト内にロー カルなネットワークを持っていて,
	そこにはまざまなものがあり,
	あなたの接続するサーバや ISP のインターネットへの
	接続点であるハードウェアデバイス (T1-GW) などがあります.</para>

      <para>あなたのマシンのデフォルトルートは
	それぞれ次のようになります.</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>host</entry>
	      <entry>default gateway</entry>
	      <entry>interface</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>
	      <entry>Local1</entry>
	      <entry>ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>
	      <entry>T1-GW</entry>
	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para><quote>なぜ (あるいは, どうやって) Local1 の
	デフォルトゲートウェイをISPのサーバでなく
	T1-GWにセットするのか</quote> という質問がよくあります.</para>

      <para>コネクションのローカルの側については,
	PPPのインタフェースは
	ISPのローカルネットワーク上のアドレスを用いているため,
	ISPのローカルネットワーク上のすべてのマシンへの経路は
	自動的に生成されています. つまり, あなたのマシンは,
	どのようにT1-GW
	まで届くかという経路を既に知っていることになりますから,
	ISPサーバに媒介的なトラフィックをかける必要はありません.</para>

      <para>最後になりましたが, 一般的にローカルネットワークでは
	<hostid role="ipaddr">...1</hostid>
	というアドレスをゲートウェイアドレスとして使います.  ですから
	(同じ例を用います), あなたのclass-Cのアドレス空間が
	<hostid role="ipaddr">10.20.30</hostid>で ISPが
	<hostid role="ipaddr">10.9.9</hostid>を用いている場合,
	デフォルトルートは次のようになります.</para>

      <literallayout>
Local2 (10.20.30.2)             --&gt;  Local1 (10.20.30.1)
Local1 (10.20.30.1, 10.9.9.30)  --&gt;  T1-GW (10.9.9.1)
      </literallayout>
    </sect2>

    <sect2>
      <title>マルチホームホスト</title>

      <para>ここで扱うべき他のタイプの設定があります.
	それは2つの異なるネットワークにまたがるホストです.
	技術的にはゲートウェイとして機能するマシン (上 の例では
	PPPコネクションを用いています) はマルチホームホストで す.
	しかし実際にはこの言葉は,
	2つのローカルエリアネットワーク上のサ
	イトであるマシンを指す言葉としてのみ使われます.</para>

      <para>2枚のイーサネットカードを持つマシンが, 別のサブネット
	上にそれぞれアドレスを持っている場合があります.  あるいは,
	イーサネットカードを1枚持っているマシンで,
	ifconfigのエイリアスを使っているかもしれません.
	物理的に分かれている2つのイーサネットのネットワークが使われて
	いるならば前者が用いられます. 後者は, 物理的には1つのネットワ
	ークセグメントで, 論理的には分かれている 2つのサブネットとする
	場合に用いられます.</para>

      <para>どちらにしても,
	このマシンがお互いのサブネットへのゲートウェイ  (inbound
	route) として定義されていることが分かるように, おのお
	ののサブネットでルーティングテーブルを設定します. このマシンが
	2 つのサブネットの間のブリッジとして動作するという構成は, パケ
	ットのフィルタリングを実装する必要がある場合や, 一方向または双
	方向のファイアウォールを利用したセキュリティを構築する場合によ
	く用いられます.</para>
    </sect2>

    <sect2>
      <title>ルーティングの伝播</title>

      <para>すでに外部との経路をどのように定義したらよいかは
	説明しました.
	しかし外部から私たちのマシンをどのようにして
	見つけるのかについては説明していません.</para>

      <para>ある特定のアドレス空間 (この例では class-C のサブネット)
	におけるすべてのトラフィックが,
	到着したパケットを内部で転送するネ
	ットワーク上の特定のホストに送られるようにルーティングテーブル
	を設定することができるのは分かっています.</para>

      <para>あなたのサイトにアドレス空間を割り当てる場合,
	あなたのサブネットへのすべてのトラフィックがすべて
	PPPリンクを通じてサイトに送
	ってくるようにサービスプロバイダはルーティングテーブルを設定し
	ます. しかし, 国境の向こう側のサイトはどのようにしてあなたの
	ISPへ送ることを知るのでしょうか?</para>

      <para>割り当てられているすべてのアドレス空間の経路を維持する
	(分散している DNS 情報とよく似た) システムがあり,
	そのインターネット バックボーンへの接続点を定義しています.
	<quote>バックボーン</quote> とは国を越え,
	世界中のインターネットのトラフィックを運ぶ主要
	な信用できる幹線のことです. どのバックボーンマシンも,
	あるネットワークから特定のバックボーンのマシンへ
	向かうトラフィックと,
	そのバックボーンのマシンからあなたのネットワークに届くサービス
	プロバイダまでのチェーンのマスタテーブルのコピーを持っていま
	す.</para>

      <para>あなたのサイトが接続(プロバイダからみて内側にある
	ことになります) したということを, プロバイダからバックボー
	ンサイトへ通知することはプロバイダの仕事です. これが経
	路の伝搬です.</para>
    </sect2>

    <sect2>
      <title>トラブルシューティング</title>

      <para>ルーティングの伝搬に問題が生じて, いくつかのサイトが
	接続をおこなうことができなくなることがあります.
	ルーティングがどこでおかしくなっているかを明らかにするのに
	最も有効なコマンドはおそらく &man.traceroute.8; コマンドでしょ
	う. このコマンドは,
	あなたがリモートマシンに対して接続をおこなう
	ことができない(例えば &man.ping.8; に失敗するような場合)
	場合も, 同じように有効です.</para>

      <para> &man.traceroute.8; コマンドは,
	接続を試みているリモートホストを引数にして実行します.
	試みているパスの経由するゲートウェイホストを表示し,
	最終的には目的のホストにたどり着くか,
	コネクションの欠如によって終ってしまうかのどちら
	かになります.</para>

      <para>より詳しい情報は, &man.traceroute.8;
	のマニュアルページをみてください.</para>
    </sect2>
  </sect1>

  <sect1 id="bridging">
    <title>Bridging</title>

    <para><emphasis>Written by Steve Peterson
	<email>steve@zpfe.com</email></emphasis>.</para>

    <sect2>
      <title>はじめに</title>

      <para>IP サブネットを作成し, それらのセグメントをルータを
	使って接続したりせずに, (Ethernet セグメントのような)
	物理ネットワークを二つのネットワークセグメントに分割することは
	とても有効な場合があります.
	このような二つのネットワークを繋ぐデバイスはブリッジと呼ばれます.
	そして, 二つのネットワークインタフェイスカードを持つ FreeBSD
	システムは, ブリッジとして動作することができます.</para>

      <para>ブリッジは, 各ネットワークインタフェイスに繋がる
	デバイスの MAC 層のアドレス (例えば Ethernet アドレス)
	を記憶します.
	ブリッジはトラフィックの送信元と受信先が異なったネットワーク上に
	ある場合にのみ, トラフィックを転送します.</para>

      <para>すなわち, ブリッジはポート数の少ない Ethernet スイッチ
	だ, ということができます.</para>
    </sect2>

    <sect2>
      <title>ブリッジがふさわしい状況とは</title>

      <para>今日ブリッジが活躍する場面は大きく分けて二つあります.</para>
      
      <sect3>
	<title>トラフィックの激しいセグメント</title>

	<para>ひとつは, 物理ネットワークセグメントがトラフィック
	  過剰になっているが, なんらかの理由によりネットワークを
	  サブネットに分け, ルータで接続することができない場合です.</para>

	<para>編集部門と製作部門がおなじサブネットに同居している
	  新聞社を例に考えてみましょう.
	  編集部門のユーザはファイルサーバとして全員サーバ A を利用し,
	  製作部門のユーザはサーバ B を利用します.
	  すべてのユーザを接続するのには Ethernet が使われており,
	  高負荷となったネットワークは遅くなってしまいます.</para>

	<para>もし編集部門のユーザを一つのネットワークセグメントに
	  分離することができ, 製作部門もユーザも同様にできるのなら,
	  二つのネットワークセグメントをブリッジで繋ぐことができます.
	  ブリッジの "反対" 側へ向かうネットワークトラフィックだけが
	  転送され, 各ネットワークセグメントの混雑は緩和されます.</para>
      </sect3>

      <sect3>
	<title>パケットフィルタ/帯域制御用ファイアウォール</title>

	<para>もうひとつは, IP Masquerading (NAT) を使わずに
	  ファイアウォール機能を利用したい場合です.</para>

	<para>ここでは DSL もしくは ISDN で ISP に接続している
	  小さな会社を例にとってみましょう.
	  この会社は ISP から 13 個のグローバル IP アドレスの割り当て
	  を受けており, ネットワーク内には 10 台の PC が存在します.
	  このような状況では, サブネット化にまつわる問題から
	  ルータを用いたファイアウォールを利用することは困難です.</para>

	<para>ブリッジを用いたファイアウォールなら,
	  IP アドレスの問題を気にすること無く, DSL/ISDN ルータの
	  下流側に置くように設定できます.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>ブリッジを設定する</title>

      <sect3>
	<title>ネットワークインタフェイスカードの選択</title>

	<para>ブリッジを利用するには少なくとも二つのネットワークカードが
	  必要です.
	  残念なことに, FreeBSD 4.0 ではすべてのネットワークインタフェイス
	  カードがブリッジ機能をサポートしているわけではありません.
	  カードがサポートされているかどうかについては &man.bridge.4;
	  を参照してください.</para>

	<para>以下に進む前に, 二つのネットワークカードをインストールして
	  テストしてください.</para>
      </sect3>

      <sect3>
	<title>カーネルコンフィグレーションの変更</title>

	<para>カーネルでブリッジ機能を有効にするには</para>

	<programlisting>options BRIDGE</programlisting>

	<para>という行をカーネルコンフィグレーションファイルに追加して
	  カーネルを再構築してください.</para>
      </sect3>

      <sect3>
	<title>ファイアウォール機能</title>

	<para>ブリッジと同時にファイアウォール機能も利用しようとしている
	  場合には, IPFIREWALL オプションも指定する必要があります.
	  ブリッジをファイアウォールとして設定する際の一般的な
	  情報に関しては, <xref linkend="firewalls">
	  を参照してください.</para>

	<para>IP 以外のパケット (ARP など) がブリッジを通過するように
	  するためには, ドキュメント化されていないファイアウォール用
	  オプションを設定する必要があります.  このオプションは
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal> です.
	  この変更により, デフォルトではファイアウォールがすべての
	  パケットを accept するようになることに注意してください.
	  この設定を行う前に, この変更が自分のルールセットにどのような
	  影響をおよぼすかを把握しておかなければなりません.</para>
      </sect3>

      <sect3>
	<title>帯域制御機能</title>

	<para>ブリッジで帯域制御機能を利用したい場合,
	  カーネルコンフィグレーションで <literal>DUMMYNET</literal>
	  オプションを加える必要があります.
	  詳しい情報に関しては &man.dummynet.4; を参照
	  してください.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>ブリッジを有効にする</title>

      <para>ブリッジを有効にするには,
	<filename>/etc/sysctl.conf</filename> に以下の行を加えてください:
      </para>

      <programlisting>net.link.ether.bridge=1</programlisting>

      <para>ブリッジを経由したパケットを ipfw でフィルタしたい場合には,
      </para>

      <programlisting>net.link.ether.bridge_ipfw=1</programlisting>

      <para>という行も付け加える必要があります.</para>
    </sect2>

    <sect2>
      <title>パフォーマンス</title>

      <para>私のブリッジ/ファイアウォールは Pentium 90 で,
	3Com 3C900B と 3c905B を使っています.
	防護される側のネットワークは 10Mbps の half duplex で,
	ブリッジとルータ (Cisco 675) の間は 100Mbps full duplex で
	動作しています.
	パケットフィルタを利用しない場合, 防護されている 10Mbps
	ネットワークから Cisco 675 への ping では,
	ブリッジにより 0.4 ミリ秒の遅延が発生しています.</para>
    </sect2>

    <sect2>
      <title>その他の情報</title>

      <para>ネットワークからブリッジに telnet したい場合,
	ネットワークカードの一つに IP アドレスを割り当てれば OK です.
	一般的に, 両方のカードに IP アドレスを割り当てるのは
	よいアイデアではないとされています.</para>

      <para>ネットワーク内に複数のブリッジを設置する場合,
	任意のワークステーション間で一つ以上の経路を持つことは
	できません.  技術的には, これは spanning tree link management
	はサポートされていない, ということを意味します.</para>
    </sect2>
  </sect1>

  <sect1 id="nfs">
    <title>NFS</title>

    <para><emphasis>Written by &a.unfurl;, 4 March 2000.</emphasis></para>

    <para>FreeBSD がサポートしている多くのファイルシステムの中でも,
      NFS, すなわち Network File System は極めてユニークな存在です.
      NFS はあるマシンから他のマシンへと, ネットワークを通じて
      ディレクトリとファイルを共有することを可能にします.
      NFS を使うことで, ユーザやプログラムはリモートシステムのファイルを,
      それがローカルファイルであるかのようにアクセスすることができます.
    </para>

    <para>NFS には以下の利点があります:</para>

    <itemizedlist>
      <listitem>
	<para>一般的に使われるデータを単一のマシンに納める
	  ことができ, ネットワーク上のユーザはデータにアクセスできる
	  ため, ローカルワークステーションは多くのディクスを
	  必要としません.</para>
      </listitem>

      <listitem>
	<para>ネットワーク上のすべてのマシンに,
	  ユーザが独自のホームディレクトリを持つ必要がありません.
	  一旦 NFS 経由でアクセスできるディレクトリができれば,
	  どこからでもアクセス可能です.</para>
      </listitem>

      <listitem>
	<para>フロッピーや CD-ROM ドライブなどのストレージデバイスを,
	  追加のハードウェアなしにネットワーク上の他のマシンに
	  使ってもらうことができます.</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>どのようにして動作するのか</title>

      <para>NFS はクライアント, サーバの二つの部分から
	構成されます.
	これは 需要(want)/供給(have) の関係として考えることができます.
	クライアントはサーバが <emphasis>供給</emphasis> している
	データに対する <emphasis>需要</emphasis> があります.
	サーバはそのデータをクライアントと共有します.
	このシステムが適切に機能するために, いくつかのプロセスが
	設定され正しく動作していなければなりません.</para>

      <para>サーバは以下のデーモンを動作させなければなりません:</para>

      <itemizedlist>
        <listitem>
	  <para><command>nfsd</command> - NFS クライアントからの
	    リクエストを処理する NFS デーモン.</para>
	</listitem>

        <listitem>
	  <para><command>mountd</command> - nfsd から渡された
	    リクエストを実際に実行する NFS マウントデーモン.</para>
	</listitem>

	<listitem>
	  <para><command>portmap</command> - NFS サーバの利用しているポートを
            NFS クライアントから取得できるようにするためのポートマッパデーモン.</para>
	</listitem>
      </itemizedlist>

      <para>クライアント側ではデーモンを一つ実行する必要があります:</para>

      <itemizedlist>
        <listitem>
	  <para><command>nfsiod</command> - NFS サーバからのリクエストを
	    処理する NFS 非同期 I/O デーモン.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>NFS を設定する</title>

      <para>幸運なことに, FreeBSD システムで設定を行うのは簡単です.
	実行させなければならないプロセスは, <filename>/etc/rc.conf</filename>
	ファイルをちょっと編集することでブート時から実行させる
	ことができます.</para>

      <para>NFS サーバでは, 以下の設定が必要です:</para>

      <programlisting>portmap_enable="YES"
nfs_server_enable="YES"
nfs_server_flags="-u -t -n 4"
mountd_flags="-r"</programlisting>

      <para><command>mountd</command> は NFS サーバが有効になっている
	場合, 自動的に実行されます.
	<command>nfsd</command> への
	<option>-u</option>, <option>-t</option> フラグは
	クライアントに UDP と TCP のサービスを提供することを指示します.
	<option>-n 4</option> フラグは <command>nfsd</command>
	が 4 つのコピーを立ち上げることを指示します.</para>

      <para>クライアント側では, 以下のようにします:</para>

      <programlisting>nfs_client_enable="YES"
nfs_client_flags="-n 4"</programlisting>

      <para><command>nfsd</command> と同様に,
	<option>-n 4</option> は <command>nfsiod</command>
	が 4 つのコピーを立ち上げることを指示します.</para>

      <para>最後に <filename>/etc/exports</filename> という
	設定ファイルを作成します.
	exports ファイルはサーバのどのファイルシステムが
	共有されるのか (<quote>exported</quote> といいます),
	またどのクライアントが共有できるのかを指定します.
	<!-- kuriyama: exports should be filename? -->
	ファイル中の各行は, 共有されるファイルシステムを
	指定します.
	ファイル中で指定できるオプションはたくさんありますが,
	そのうちの少ししか使うことはないでしょう.
	より細かいことに関しては &man.exports.5;
	マニュアルページをお読み下さい.
      </para>

      <para>いくつか <filename>/etc/exports</filename> の設定例
	を示します:</para>

      <para>以下の設定は,
	サーバと同じドメイン名(ドメイン名が無いので)か,
	<filename>/etc/hosts</filename> に記述のある三つのマシン
	に対して, <filename>/cdrom</filename> を export します.
	<option>-ro</option> オプションは共有されるファイルシステムを
	読み込み専用にします.
	このフラグにより, リモートシステムは共有されたファイルシステム
	にたいして何の変更も行えなくなります.</para>

      <programlisting>/cdrom -ro moe larry curly</programlisting>

      <para>以下の設定は, IP アドレスによる三つのホストに対して
	<filename>/home</filename> を export します.
	この設定はプライベートネットワークで DNS が走っていない
	場合に便利な設定でしょう.
	<option>-alldirs</option> フラグは指定されたファイルシステム
	以下のディレクトリに対しても同様に export します.</para>

      <programlisting>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

      <para>以下の設定は, サーバとは異なるドメイン名の二つの
	マシンに対して <filename>/a</filename> を export します.
	<option>-maproot=0</option> フラグは, リモートマシンの
	root ユーザが共有されたファイルシステムに root として書き込むことを
	許可します.
	-maproot=0 フラグが無ければ, リモートマシンの root 権限を
	持っていても共有されたファイルシステム上のファイルを変更する
	ことはできません.
	<!-- kuriyama: shoud be option.  Correct description? -->
      </para>

      <programlisting>/a  -maproot=0  host.domain.com box.example.com</programlisting>

      <para>クライアントが export されたファイルシステムを共有
	する際には, そのような権限が与えられていなければなりません.
	<filename>/etc/exports</filename> ファイルに
	クライアントが含まれているかどうか確認してください.
	<!-- kuriyama: your exports is correct? -->
      </para>

      <para>必要な変更はすべて行ったので,
	FreeBSD を再起動してブート時からすべてが起動するようにするか,
	root で以下のコマンドを実行します:</para>

      <para>NFS サーバでは:</para>

      <screen>&prompt.root; <userinput>portmap</userinput>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput></screen>

      <para>NFS クライアントでは:</para>

      <screen>&prompt.root; <userinput>nfsiod -n 4</userinput></screen>

      <para>これでリモートのファイルシステムを実際にマウントする
	準備ができました.
	やり方は二通りあります.
	この例では, サーバの名前は <literal>server</literal> で,
	クライアントの名前は <literal>client</literal> とします.
	リモートファイルシステムを一時的にマウントするだけ,
	もしくは設定をテストするだけなら, クライアント上で root
	として以下のコマンドを実行してください:</para>

      <screen>&prompt.root; <userinput>mount server:/home /mnt</userinput></screen>

      <para>これにより, クライアントの <filename>/mnt</filename>
	ディレクトリにサーバの <filename>/home</filename> が
	マウントされます.
	もしすべてが正しく設定されていれば, クライアントの /mnt
	に, サーバにあるファイルすべてが見えるようになっているはずです.
      </para>

      <para>リモートファイルシステムを今後も (リブートする度に)
	マウントしたいなら, <filename>/etc/fstab</filename>
	ファイルに設定を追加する必要があります.
	例としてはこのようになります:</para>

      <programlisting>server:/home	/mnt	nfs	rw	0	0</programlisting>

      <para>ほかのオプションに関しては &man.fstab.5; マニュアル
	ページをお読み下さい.</para>
    </sect2>

    <sect2>
      <title>典型的な使い方</title>

      <para>NFS にはいくつかすてきな使い方があります.
	私は自分が管理している LAN でそれらを利用しています.
	そのうちにいくつかをここで紹介しましょう.</para>

      <para>ネットワークには幾つかのマシンがありますが,
	CD-ROM ドライブを持っているのは一台だけです.
	なぜかって?  それは一台の CD-ROM ドライブをほかのマシンと
	NFS 経由で共有しているからです.
	フロッピードライブについても同じことがいえます.</para>

      <para>ネットワーク内に多くのマシンがあると, 様々な場所に
	ちらばる個人的なファイルは日に日に古くなってしまいます.
	私はすべてのユーザのホームディレクトリを格納する,
	中心となる NFS サーバを用意し, LAN 上の残りのマシンと
	共有しています.  そうすることで, どこにログインしても,
	同じホームディレクトリを使うことができるのです.</para>

      <para>マシンのひとつに FreeBSD を再インストールするなら,
	NFS こそその方法です.  ディストリビューション CD をファイル
	サーバに入れ, 再インストールを実行するだけです.</para>

      <para>共用の <filename>/usr/ports/distfiles</filename>
	ディレクトリを用意して, すべてのマシンで共有しています.
	この方法だと, 別のマシンで既にインストールしたことのある
	port をインストールする場合, 再びすべてのソースをダウンロードする
	必要がなくなります.</para>
    </sect2>

    <sect2>
      <title>Problems integrating with other systems</title>

    <para><emphasis>原作: John Lind <email>john@starfire.MN.ORG</email>.</emphasis></para>

    <para><emphasis>訳: &a.jp.tomo;.
	6 September 1996.</emphasis></para>

    <para>ISA用のイーサネットアダプタの中には性能が悪いため,
      ネットワーク,  特に NFS で深刻な問題がおきるものがあります.
      これは FreeBSD に限ったことではありませんが, FreeBSD
      でも起こり得ます.</para>

    <para>この問題は,
      (FreeBSDを使用した) PC がシリコン・グラフィックス社や
      サン・マイクロシステムズ社などの高性能な WS
      にネットワーク接続されている場合に頻繁に起こります.
      NFS マウントはうまく行きます. また,
      いくつかの操作もうまく働きますが, 他のシステム (WS)
      に対する要求や応答は続いていても, 突然サーバが
      クライアントの要求に対して反応しなくなります.
      これは, クライアントが FreeBSD か上記の WS であるとき,
      にクライアント側に起きる現象です.
      多くのシステムでは, いったんこの問題が現われると,
      行儀良くクライアントを終了する手段はありません.
      NFS がこの状態に陥ってしまうと, 正常に戻すことはできないため,
      多くの場合, クライアントを強制終了し,
      再び実行することが唯一の解決法となります.
    </para>

    <para><quote>正しい</quote>解決法は,
      より高性能のイーサネットアダプタをFreeBSDシステムに
      インストールすることですが,
      満足な操作ができるような簡単な方法があります.  もし,
      FreeBSDシステムが<emphasis>サーバ</emphasis>になるのなら,
      クライアントからのマウント時に
      <option>-w=1024</option>オプションをつけて下さい.
      もしFreeBSDシステムが<emphasis>クライアント</emphasis>になる
      のなら, NFSファイルシステムを <option>-r=1024</option>
      オプションつきでマウントして下さい.
      これらのオプションは自動的にマウントをおこなう場合には
      クライアントの <filename>fstab</filename>
      エントリの4番目のフィールドに指定してもよいですし,
      手動マウントの場合は mount コマンドの <option>-o</option>
      パラメータで指定してもよいでしょう.</para>

    <para>NFSサーバとクライアントが別々のネットワーク上にあるような
      場合,  これと間違えやすい他の問題が起きることに注意して下さい.
      そのような場合は,  ルータが必要な UDP 情報をきちんと
      ルーティングしているかを確かめて下さい.
      そうでなければ, たとえあなたが何をしようと解決できないでしょう.
    </para>

    <para>次の例では, <hostid>fastws</hostid>は高性能のWSのホスト
      (インタフェース)名で,
      <hostid>freebox</hostid>は低性能のイーサネットアダプタを備えた
      FreeBSDシステムのホスト(インタフェース)名です.</para>

    <para>また, <filename>/sharedfs</filename> はエクスポートされる
      NFS ファイルシステムであり (<command>man exports</command>
      を見て下さい), <filename>/project</filename>
      はエクスポートされたファイルシステムの
      クライアント上のマウントポイントとなります.
      全ての場合において, <option>hard</option> や <option>soft</option>,
      <option>bg</option> といった追加オプションが
      アプリケーションにより要求されるかもしれないことに
      注意して下さい.</para>

    <para>クライアント側 FreeBSD システム (<hostid>freebox</hostid>)
      の例は:
      freebox の <filename>/etc/fstab</filename>
      に次のように書いて下さい:</para>

    <programlisting>fastws:/sharedfs /project nfs rw,-r=1024 0 0</programlisting>

    <para><hostid>freebox</hostid> 上で手動で mount
      コマンドを実行する場合は次のようにして下さい:</para>

    <screen>&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sharedfs /project</userinput></screen>

    <para>サーバ側FreeBSDシステムの例は: <hostid>fastws</hostid> の
      <filename>/etc/fstab</filename> に次のように書いて下さい:</para>

    <programlisting>freebox:/sharedfs /project nfs rw,-w=1024 0 0</programlisting>

    <para><hostid>fastws</hostid> 上で手動で mount
      コマンドで実行する場合は次のようにして下さい:</para>

    <screen>&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sharedfs /project</userinput></screen>

    <para>近いうちにどのような 16 ビットのイーサネットアダプタでも
      上記の読み出し,
      書き込みサイズの制限なしの操作ができるようになるでしょう.</para>

    <para>失敗が発生したとき何が起きているか関心のある人に,
      なぜ回復不可能なのかも含めて説明します.  NFSは通常
      (より小さいサイズへ分割されるかもしれませんが)
      8Kの<quote>ブロック</quote> サイズで働きます.
      イーサネットのパケットサイズは最大1500バイト程度なので,
      上位階層のコードにとっては1つのユニットのままなのですが,
      NFS <quote>ブロック</quote>は
      複数のイーサネットパケットに分割されます. そして受信され,
      組み立て直されてから<emphasis>肯定応答</emphasis>
      されなければなりません.
      高性能のWSは次々に NFSユニットを構成するパケットを,
      基準の範囲内で間隔を詰めて次々に送り出すことができます. 小さく,
      容量の低いカードでは, 同じユニットの
      前のパケットがホストに転送される前に, 後のパケットがそれを
      <emphasis>踏みつぶし</emphasis>てしまいます.
      このため全体としてのユニットは再構成もされないし,
      肯定応答もされません. その結果,
      WSはタイムアウトして再送を試みますが,
      8Kのユニット全体を再送しようとするので, このプロセスは
      際限無く繰り返されてしまいます.</para>

    <para>ユニットサイズをイーサネットのパケットサイズの
      制限以下に抑えることにより, 受信された完全な
      イーサネットパケットは個々に肯定応答を受けられることが
      保証されるので,
      デッドロック状態を避けることができるようになります.</para>

    <para>高性能のカードを使っている場合でも, 高性能な WS
      が力任せに次々と PC システムにデータを送ったときには
      <emphasis>踏みつぶし</emphasis> が起きるかもしれません.
      そのような<emphasis>踏みつぶし</emphasis>
      は NFS <quote>ユニット</quote>
      では保証されていません.
      <emphasis>踏みつぶし</emphasis>が起こったとき,
      影響を受けたユニットは再送されます. そして受信され,
      組み立てられ,
      肯定応答される公平な機会が与えられるでしょう.</para>
    </sect2>
  </sect1>

  <sect1 id="diskless">
    <title>Diskless operation</title>

    <para><emphasis>原作: &a.martin;</emphasis></para>

    <para><emphasis>訳: &a.jp.yasu;</emphasis></para>

    <para><filename>netboot.com</filename>/<filename>netboot.rom</filename>
      によって, ディスクのないクライアントでネットワーク経由で
      FreeBSD マシンのブートを行い FreeBSD を走らせることができます.
      2.0 ではローカルなスワップを持つことができます.
      NFS 経由のスワッピングもサポートされています. </para>

    <para>サポートされているイーサネットカード:
      Western Digital/SMC 8003, 8013, 8216 とその互換ボード,
      NE1000/NE2000 とその互換カード (再コンパイルが必要)</para>

    <sect2>
      <title>セットアップの手順</title>

      <procedure>
	<step>
	  <para>サーバにするマシンを見つけます.
	    このマシンには, FreeBSD 2.0のバイナリとbootpを
	    記憶するだけの十分なディスクスペースが必要です.
	    tftp と NFS も使えます.

	    テストしたマシン:</para>

	  <itemizedlist>
	    <listitem>
	      <para>HP9000/8xx / HP-UX 9.04以降
		(9.04以前では動きません)</para>
	    </listitem>

	    <listitem>
	      <para>Sun/Solaris 2.3. (bootpが必要)</para>
	    </listitem>
	  </itemizedlist>
	</step>

	<step>
	  <para>クライアントにIP,gateway,netmaskを提供する
	    bootpサーバをセットアップします.</para>

	  <programlisting>diskless:\
        :ht=ether:\
        :ha=0000c01f848a:\
        :sm=255.255.255.0:\
        :hn:\
        :ds=192.1.2.3:\
        :ip=192.1.2.4:\
        :gw=192.1.2.5:\
        :vm=rfc1048:</programlisting>
	</step>

	<step>
	  <para>クライアントにブート情報を提供する TFTP サーバを
	    (bootp サーバと同じマシンに) セットアップします.
	    このファイルの名前は,
	    <filename>cfg.<replaceable>X.X.X.X</replaceable></filename>
	    (もしくは
	    <filename>/tftpboot/cfg.<replaceable>X.X.X.X</replaceable>
	    </filename>)で,
	    ここで <replaceable>X.X.X.X</replaceable> はクライアントの
	    IP アドレスです.
	    このファイルの内容は netboot コマンドで有効です.
	    2.0では, netboot は以下のようなコマンドを持ちます:</para>

	  <informaltable frame="none">
	    <tgroup cols="2">
	      <tbody>
		<row>
		  <entry>help</entry>
		  <entry>helpリストの表示</entry>
		</row>

		<row>
		  <entry>ip
		    <option><replaceable>X.X.X.X</replaceable></option></entry>
		  <entry>クライアントのIPアドレスの表示/セット</entry>
		</row>

		<row>
		  <entry>server
		    <option><replaceable>X.X.X.X</replaceable></option></entry>
		  <entry>bootp/tftp サーバのアドレスの表示/セット</entry>
		</row>

		<row>
		  <entry>netmask
		    <option><replaceable>X.X.X.X</replaceable></option></entry>
		  <entry>netmaskの表示/セット</entry>
		</row>

		<row>
		  <entry>hostname <replaceable>name</replaceable></entry>
		  <entry>hostnameの表示/セット</entry>
		</row>

		<row>
		  <entry>kernel
		    <option><replaceable>name</replaceable></option></entry>
		  <entry>カーネル名の表示/セット</entry>
		</row>

		<row>
		  <entry>rootfs
		    <option><replaceable>ip:/fs</replaceable></option></entry>
		  <entry>root ファイルシステムの表示/セット</entry>
		</row>

		<row>
		  <entry>swapfs
		    <option><replaceable>ip:/fs</replaceable></option></entry>
		  <entry>swap ファイルシステムの表示/セット</entry>
		</row>

		<row>
		  <entry>swapsize
		    <option><replaceable>size</replaceable></option></entry>
		  <entry>diskless swapsize を KBytes単位でセット</entry>
		</row>

		<row>
		  <entry>diskboot</entry>
		  <entry>ディスクからのブート</entry>
		</row>

		<row>
		  <entry>autoboot</entry>
		  <entry>ブートプロセスの続行</entry>
		</row>

		<row>
		  <entry>trans
		    <option>on</option>|<option>off</option></entry>
		  <entry>トランシーバのオン|オフ</entry>
		</row>

		<row>
		  <entry>flags
		    <option>b</option><option>c</option>
		    <option>d</option><option>h</option>
		    <option>s</option><option>v</option></entry>
		  <entry>ブートフラグの設定</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>完全にディスクレスな場合の一般的な cfg
	    ファイルは以下のようになります:</para>

	  <programlisting>rootfs 192.1.2.3:/rootfs/myclient
swapfs 192.1.2.3:/swapfs
swapsize 20000
hostname myclient.mydomain</programlisting>

	  <para>ローカルに swap
	    を持つマシンについては以下のようになります:</para>

	  <programlisting>rootfs 192.1.2.3:/rootfs/myclient
hostname myclient.mydomain</programlisting>

	</step>

	<step>
	  <para>NFS サーバがクライアントにroot(必要ならswapも)
	    ファイルシステムをexportしているか, また,
	    クライアントがこれらのファイルシステムに
	    ルートアクセスできるか確認します. FreeBSDにおける一般的な
	    <filename>/etc/exports</filename> ファイルは
	    以下のようになります:</para>

	  <programlisting>/rootfs/myclient -maproot=0:0 myclient.mydomain
/swapfs -maproot=0:0 myclient.mydomain</programlisting>

	  <para>そして, HP-UX側では以下のようになります:</para>

	  <programlisting>/rootfs/myclient -root=myclient.mydomain
/swapfs -root=myclient.mydomain</programlisting>
	</step>

	<step>
	  <para>NFS経由でスワッピングを行う場合
	    (完全にディスクレスな場合の設定), クライアントが使用する
	    swap ファイルを <command>dd</command> で作成します.
	    もし, <command>swapfs</command> コマンドが上記の例のように
	    引数 <filename>/swapfs</filename>を持ちそのサイズが 20000
	    である場合, myclientに対するスワップファイルは
	    <filename>/swapfs/swap.<replaceable>X.X.X.X</replaceable>
	    </filename> で呼び出されます. ここで
	    <replaceable>X.X.X.X</replaceable> はクライアントの IP
	    アドレスです. 例:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/swapfs/swap.192.1.2.4 bs=1k count=20000</userinput></screen>

	  <para>また, スワッピングが開始されるとクライアントの
	    スワップスペースはセンシティブな情報を含むようになるので,
	    不正なアクセスを防止するため, このファイルへの
	    読み書きのアクセス制限がなされていることを確認して下さい:
	  </para>

	  <screen>&prompt.root; <userinput>chmod 0600 /swapfs/swap.192.1.2.4</userinput></screen>
	</step>

	<step>
	  <para>クライアントがそれぞれのrootファイルシステムとして使う
	    ディレクトリにrootファイルシステムを展開します.
	    (上記の例では<filename>/rootfs/myclient</filename>).</para>

	  <itemizedlist>
	    <listitem>
	      <para>HP-UX システム: サーバはHP9000/800
		シリーズのマシンで, HP-UX 9.04 以降が必要です.
		これ以前のバージョンでは NFS
		を経由するデバイスファイルが作成ができません.</para>
	    </listitem>

	    <listitem>
	      <para><filename>/rootfs/myclient</filename> に
		<filename>/dev</filename> を
		展開する際に, いくつかのシステム (HPUX) では
		FreeBSD に合った デバイスファイルが作成されないので
		注意してください.
		その際には最初の起動時にシングルユーザモードに
		移行して (ブートの段階でCtrl-Cを押す),
		<filename>/dev</filename> に移って
		<command>sh ./MAKEDEV all</command> として,
		クライアントからこれを 修正してください.</para>
	    </listitem>
	  </itemizedlist>
	</step>

	<step>
	  <para>クライアントで <command>netboot.com</command>
	    を実行するか, <filename>netboot.rom</filename>
	    ファイルから EPROMを作成します.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title><filename>/</filename> および <filename>/usr</filename>
	ファイルシステムを共有して使用する</title>

      <para>今のところ, これを行う公式に認められた方法はありませんが,
	私はそれぞれのクライアントで <filename>/usr</filename>
	ファイルシステムと個々の <filename>/</filename>
	ファイルシステムを共有して使っています.
	どなたかこれをきちんと行うやり方の提案がありましたら,
	私に, もしくは &a.core; グループに知らせてください.</para>
    </sect2>

    <sect2>
      <title>特定の設定についてnetbootをコンパイルする</title>

      <para><filename>/sys/i386/boot/netboot/Makefile</filename>
	の中の設定を変更して
	コンパイルすることで, netbootでNE1000/2000
	カードをサポートします.
	このファイルの先頭にあるコメントを見てください.</para>
    </sect2>
  </sect1>

  <sect1 id="isdn">
    <title>ISDN</title>

    <para><emphasis>最終更新: Bill Lloyd <email>wlloyd@mpd.ca</email></emphasis>.</para>

    <para><emphasis>訳: &a.jp.kiroh;.
	11 December 1996.</emphasis></para>

    <para>ISDN 技術とハードウェアに関しては,
      <ulink url="http://alumni.caltech.edu/~dank/isdn/">
	Dan Kegel's ISDN Page</ulink> がよい参考になるでしょう.</para>

    <para>ISDN の導入手順は, 簡単にいって以下のようになります. </para>

    <itemizedlist>
      <listitem>
	<para>ヨーロッパ在住の方は, ISDN
	  カードの節に進んでください.</para>
      </listitem>

      <listitem>
	<para>ISDN を使って,
	  インターネットプロバイダに(専用線は使用せず), ダ
	  イアルアップ接続しようとしている場合は,
	  ターミナルアダプタの使用を考えてみてください.
	  この方法はもっとも柔軟性があり, プロバイダを変更した場
	  合の問題も少ないでしょう.</para>
      </listitem>

      <listitem>
	<para>2つの LAN の間を接続しようする場合や, ISDN
	  専用線を使用する場合 には,
	  スタンドアローンルータ/ブリッジの使用を勧めます.</para>
      </listitem>
    </itemizedlist>

    <para>どの方法を用いるかを決定するには,
      費用が重要な要素になってきます.  以下に, 最も安価な方法から,
      高価な方法まで順に説明していきます.</para>

    <sect2>
      <title>ISDN カード</title>

      <para><emphasis>著者:&a.hm;.</emphasis></para>

      <para>このセクションの記述は, DSS1/Q.931 ISDN
	標準がサポートされている国のユーザにのみ有効です.</para>

      <para>最近増えてきている PC ISDN カードのうちいくつかは, FreeBSD
	2.2.x 以降で isdn4bsd
	ドライバパッケージによりサポートされています.
	依然として開発中ではありますが,
	ヨーロッパ中でうまく動作しているという報告があります.</para>

      <para>最新の isdn4bsd は,
	<ulink url="ftp://isdn4bsd@ftp.consol.de/pub/">
	  ftp://isdn4bsd@ftp.consol.de/pub/</ulink> から入手できます.
	この ftp サイトでは, ユーザ名として <username>isdn4bsd</username>
	を使い, パスワードにメールアドレスを使ってログインする
	必要があります. ログインできたら <filename>pub</filename>
	ディレクトリに移動してください. ユーザー名
	<username>ftp</username> や <username>anonymous</username>
	によるログインでは, 必要なファイルにたどりつけません.</para>

      <para>isdn4bsd は, IP over raw HDLC もしくは同期 PPP
	を利用して他の ISDN ルータと接続できます.
	留守番電話アプリケーションも使えます.</para>

      <para>Siemens ISDN チップセット (ISAC/HSCX)
	を使用したものを主に多くのカードがサポートされています.
	他のチップセット (Motorola, Cologn ChipDesigns)
	のサポートは現在開発中です.
	サポートされるカードの最新のリストは,
	<ulink url="ftp://isdn4bsd@ftp.consol.de/pub/README">README</ulink>
	を参照してください.</para>

      <para>他の ISDN プロトコルを追加したい場合や,
	サポートされていない ISDN PC カード サポートしたい場合など
	isdn4bsd を拡張したい場合は, <email>hm@kts.org</email>
	までご連絡ください.</para>

      <para>majordomoによるメーリングリストが利用できます.
	参加するには, 本文に</para>

      <programlisting>subscribe freebsd-isdn</programlisting>

      <para>と記入したメールを
	&a.majordomo; 宛てに送ってください.</para>
    </sect2>

    <sect2>
      <title>ISDN ターミナルアダプタ</title>

      <para>ターミナルアダプタ (TA) はISDN に対して,
	通常の電話線に対するモデムに相当するものです.</para>

      <para>ほとんどの TA は, 標準のヘイズ AT
	コマンドセットを使用しているので,
	単にモデムと置き換えて使うことができます.</para>

      <para>TA は, 基本的にはモデムと同じように動作しますが,
	接続方法は異なり, 通信速度も古いモデムよりはるかに速くなります.
	<link linkend="ppp">PPP</link> の設定を,
	モデムの場合と同じように行ってください. とくにシリアル速度を
	使用できる最高速度に設定するのを忘れないでください.</para>

      <para>プロバイダへの接続に TA を使用する最大のメリットは, 動的
	PPP を行えることです. 最近 IP アドレスが不足してきているため,
	ほとんどのプロバイダは, 専用の IP
	アドレスを割り当てないようになっています.
	ほとんどのスタンドアローンルータは, 動的 IP
	アドレスに対応していません.</para>

      <para>訳注: 最近の ISDN ルータでは, IP
	アドレスの動的割り当てに対応しているものも多いようです.
	ただし制限がある場合もありますので, 詳しくはメーカ
	に問い合わせてください.</para>

      <para>TA を使用した場合の機能や接続の安定性は, 使用している PPP
	デーモンに完全に依存します. そのため, FreeBSD で PPP
	の設定が完了していれば, 使用している既存のモデムを ISDN の TA
	に簡単にアップグレードすることができます. ただし, それまでの
	PPP のプログラムに問題があった場合, その問題は TA
	に置き換えてもそのまま残ります.</para>

      <para>最高の安定性を求めるのであれば, ユーザープロセス
	<link linkend="userppp">iijPPP</link> ではなく, カーネル
	<link linkend="ppp">PPP</link>を使用してください.</para>

      <para>以下の TA は, FreeBSD で動作確認ずみです.</para>

      <itemizedlist>
	<listitem>
	  <para>Motorola BitSurfer および Bitsurfer Pro</para>
	</listitem>

	<listitem>
	  <para>Adtran</para>
	</listitem>
      </itemizedlist>

      <para>他の TA もほとんどの場合うまく動作するでしょう. TA
	のメーカーでは, TA  がほとんどの標準モデム AT
	コマンドセットを受け付けるようにするよう,
	努力しているようです.</para>

      <para>外部 TA を使う際の最大の問題点は,
	モデムの場合と同じく良いシリアルカー
	ドが必要であるということです.</para>

      <para>シリアルデバイスの詳細,
	そして非同期シリアルポートと同期シリアルポートの差については,
	同期・非同期の違いやシリアルデバイスについて説明したチュートリアル <ulink
	url="http://www.freebsd.org/tutorials">FreeBSD Serial
	Hardware</ulink> を参照してください.</para>

      <para>標準の PC シリアルポート(非同期)に接続された TA は, 128Kbs
	の接続を行っていても, 最大通信速度が 115.2Kbs
	に制限されてしまいます. 128Kbs の  ISDN
	の性能を最大限に生かすためには, TA
	を同期シリアルカードに接続しなければなりません.</para>

      <para>内蔵 TA を購入して,
	同期／非同期問題を片付けてしまおうとは思わないでく ださい.
	内蔵 TA には, 単に標準 PC シリアルポートのチップが内蔵されてい
	るだけです. 内蔵 TA の利点といえば,
	シリアルケーブルを買わなくていいと いうことと,
	電源コンセントが一つ少なくて済むということくらいでしょう.
      </para>

      <para>同期カードと TA の組合せは 386 の FreeBSD
	マシンの場合でも, スタンドア
	ローンのルータと同程度の速度は確保できます.
	またこの組合せでは, ルータより柔軟な設定が可能です.</para>

      <para>同期カード/TA を選ぶか, スタンドアローンルータを選ぶかは,
	多分に宗教的な問題です.
	メーリングリストでもいくつか議論がありました. 議論の内容に
	ついては, <ulink url="../search/search.html">archives</ulink>
	を参照してください.</para>
    </sect2>

    <sect2>
      <title>スタンドアローン ISDN ブリッジ/ルータ</title>

      <para>ISDN ブリッジやルータは, OS 特有のものではありません.
	もちろん FreeBSD 特有のものでもありません.
	ルーティングやブリッジング技術に関する詳細は,
	ネットワークの参考書をご覧ください.</para>

      <para>このページでは,
	ルータとブリッジにどちらでもあてはまるように記述します.</para>

      <para>ISDN ルータ/ブリッジは,
	ローエンドの製品のコストが下がってきていることもあり,
	より一般的に使用されるようになるでしょう. ISDN ルータは,
	外見は小さな箱で,
	ローカルのイーサネットネットワーク(もしくはカード)と直接,
	接続します. また,
	自身で他のブリッジ/ルータとの接続を制御します. PPP
	や他のプロトコルを使用するためのソフトウェアは,
	すべて組み込まれています.</para>

      <para>ルータは, 完全な同期 ISDN 接続を使用するため, 通常の TA
	と比較してスループットが大幅に向上します.</para>

      <para>ISDN ルータ/ブリッジを使用する場合の最大の問題点は,
	各メーカーの製品間に相性の問題がまだ存在することです.
	インターネットプロバイダとの接続を考えている場合には,
	プロバイダと相談することをお勧めします.</para>

      <para>事務所の LAN と家庭の LAN の間など, 二つの LAN
	セグメントの間を接続しようとしている場合は,
	ブリッジ/ルータの使用がもっともメンテナンスが 簡単で,
	努力が少なくてすむ方法です. 両側の機材を購入するのであれば,
	メーカー間の接続性の問題もないでしょう.</para>

      <para>たとえば家庭の LAN や出張所の LAN
	を本社のネットワークに接続するためには,
	以下のような設定が使用できます.</para>

      <example>
	<title>出張所 LAN または 家庭 LAN</title>

	<para>ネットワークは, 10 Base T イーサネットです.
	  ルータとネットワークの間は, 必要に応じて AUI/10BT
	  トランシーバを使って接続します.</para>

	<!-- This should be a graphic -->
	<programlisting>---Sun ワークステーション
|
---FreeBSD マシン
|
---Windows 95 (別に勧めているわけじゃありません)
|
スタンドアローンルータ
   |
ISDN BRI ライン</programlisting>

	<para>
	  家庭/出張所 LAN で,
	  一台しかコンピュータを接続しないのであれば, クロス
	  のツイストペアケーブルを使用して,
	  スタンドアローンルータと直結も可能です.</para>
      </example>

      <example>
	<title>本社 LAN や他の LAN</title>

	<para>ネットワークは, ツイストペアイーサネットです. </para>

	<!-- This should be a graphic -->
	<programlisting>-------Novell サーバ
|  |
|ハ ---Sun
|  |
|   ---FreeBSD
|  |
|ブ ---Windows 95
|  |
|___---スタンドアローンルータ
    	|
    ISDN BRI ライン</programlisting>

      </example>

      <para>ほとんどのルータ/ブリッジでは, 別々の二つのサイトに対して,
	<emphasis>同時</emphasis>にそれ
	ぞれ<emphasis>独立した</emphasis>二つの PPP 接続が可能です.
	これは, 通常の TA ではサポートされない機能で,
	ルータ/ブリッジ接続の大きな利点です (シリアルポートを
	二つもつ特殊(そして高価な) TA では可能です).
	チャンネル割り当てや MPP などと混同しないでください.</para>

      <para>これは, 大変便利な機能です.
	たとえば事務所で専用線 ISDN 接続を使用していて,
	別の ISDN ラインを購入したくないとします. この場合,
	事務所のルータは, 一つの専用線 B
	チャンネル接続(64Kbs)を維持しつつ, 別 の B
	チャンネルを他の用途に使用することができます. たとえば,
	他の場所 とのダイアルイン, ダイアルアウトに使用したり,
	バンド幅を増やすために,
	インターネットとの接続への動的に割り当て(MPP
	など)に使用したりすることが可能です.</para>

      <para>またイーサネットブリッジは, IP パケットだけでなく IPX/SPX
	などすべての
	プロトコルのパケットを中継することが可能です.</para>

    </sect2>
  </sect1>

  <sect1 id="nis">
    <title>NIS/YP</title>

    <para><emphasis>原作: &a.unfurl;,
      2000 年 1 月 21 日,
      監修: Eric Ogren <email>eogren@earthlink.net</email>,
      Udo Erdelhoff <email>ue@nathan.ruhr.de</email>,
      2000 年 6 月.</emphasis></para>

    <sect2>
      <title>NIS/YP とは?</title>
  
      <para>NIS とは Network Information Services の略で
        Sun Microsystems によって Unix の (もともとは SunOS の)
	集中管理のために開発されました.  現在では事実上の業界標準になっており,
	主要な Unix は (Solaris, HP-UX, AIX, Linux, NetBSD, OpenBSD,
	FreeBSD, 等々) すべてこれをサポートしています.</para>

      <para>NIS は元々, イエローページ (または yp) として知られていましたが,
        著作権を侵害しているとして Sun はその名を変えさせられました.</para>

      <para>NIS は RPC を使ったクライアント/サーバシステムです.
        これを使うと NISドメイン内のマシン間で,
        共通の設定ファイルを共有することができます.
        また, NIS を使うことでシステム管理者は最小限の設定データで
        NIS クライアントを立ち上げることができ,
        1 ヶ所から設定データの追加, 削除, 変更が可能です. </para>
  
      <para>NIS は Windows NT のドメインシステムに似ています.
        内部の実装は似ても似つかないものですが, 基本的な機能を
        対比することはできます.</para>
    </sect2>
  
    <sect2>
      <title>知っておくべき用語 / プロセス</title>

      <para>NIS サーバの立ち上げや NIS クライアントの設定など,
        NIS を FreeBSD に導入するにあたって,
        目にするであろう用語や重要なユーザプロセスがいくつかあります.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>NIS ドメイン名</emphasis>. NIS マスターサーバ一つと
            そのクライアント (スレーブサーバを含む) は一つの NIS ドメイン名を
            持ちます.  NT のドメイン名同様,
            NIS ドメイン名は DNS とは何の関係もありません.</para>
        </listitem>
        <listitem>
          <para><emphasis>portmap</emphasis>. <command>portmap</command>
            は RPC (Remote Procedure Call, NIS
            で使われるネットワークプロトコル)
            を利用するために実行しておかなければなりません.
            <command>portmap</command> が動いていなければ,
            NIS サーバの起動もクライアントとしての機能も得られません.</para>
        </listitem>
        <listitem>
          <para><emphasis>ypbind</emphasis>. <command>ypbind</command>
            は NIS クライアントを NIS サーバに<quote>結び付け</quote>ます.
            これは NIS ドメイン名をシステムから受け, RPC
            を用いてサーバに接続します. <command>ypbind</command>
            はクライアントとサーバのコミュニケーションの中枢であり,
            もしクライアントマシンの <command>ypbind</command>
            が機能を停止した場合は
            NIS サーバへアクセスできなくなります.</para>
        </listitem>
        <listitem>
          <para><emphasis>ypserv</emphasis>. <command>ypserv</command>
            は NIS サーバでのみ実行されるもので, NIS
            のサーバプロセスそのものです. ypserv が機能を停止したときは,
            サーバは NIS リクエストに答えられなくなります
            (運が良ければ, スレーブサーバがいて代わりを努めるでしょう).</para>

          <note>
            <para>今まで使っていたサーバが機能を停止したとき,
              別のサーバに再接続しに行かない NIS の実装もいくつかあります
              (FreeBSD のものは違います).
              そのような場合に復帰するための唯一の方法は,
              サーバプロセス (あるいはサーバ全体), もしくはクライアントの
              <command>ypbind</command>
              プロセスを再スタートすることです.</para>
          </note>
        </listitem>
        <listitem>
          <para><emphasis>rpc.yppasswdd</emphasis>.
            <command>rpc.yppasswdd</command> は NIS
            マスターサーバで動かされるべきもう一つのプロセスで,
            NIS クライアントから
            NIS パスワードを変更させるデーモンです.
            このデーモンが動いていないときは, ユーザは NIS マスターサーバに
            login し, そこでパスワードを変更することになります.</para>
        </listitem>

        <!-- XXX Missing: rpc.ypxfrd (not important, though) May only run
             on the master -->
      </itemizedlist>
    </sect2>

    <sect2>
      <title>動作のしくみ</title>
        
      <para>NIS 環境にあるホストは, 次の 3 種類に分類されます. それは,
        マスターサーバ, スレーブサーバ, クライアントです.
        サーバは, ホストの設定情報の中心的な情報格納庫の役割をします.
        マスターサーバは元となる信頼できる情報を保持し,
        スレーブサーバは, 冗長性を確保するため, この情報をミラーします.
        そしてクライアントは, サーバから情報の提供を受けて動作します.</para>

      <para>この方法を用いることで, 数多くのファイルにある情報が共有できます.
        よく NIS で共有されるのは,
        <filename>master.passwd</filename> や <filename>group</filename>,
	<filename>hosts</filename> といったファイルです.
        クライアント上のプロセスで, 通常ローカルのファイルにある情報が必要
	となったとき,
        クライアントは接続しているサーバに問い合わせを行い, その情報を得ます. 
      </para>

      <sect3>
        <title>マシンの分類</title>

        <itemizedlist>
          <listitem>
            <para><emphasis>NIS マスターサーバ</emphasis>.
              このサーバは Windows NT で言うところのプライマリ
              ドメインコントローラにあたります.
              すべての NIS クライアントで利用されるファイルを保守し,
              <filename>passwd</filename> や
              <filename>group</filename>, その他 NIS
              クライアントが参照するファイルは,
              マスターサーバにあります.</para>
       
            <note>
              <para>一つのマシンが一つ以上の NIS
                ドメインのマスターサーバになることは可能です.
                しかし, ここでは比較的小規模の NIS 環境を対象としているため,
                そのような場合については扱いません.</para>
            </note>
          </listitem>
          <listitem>
            <para><emphasis>NIS スレーブサーバ</emphasis>.
              NT で言うところのバックアップドメインコントローラに似たもので,
              NIS スレーブサーバは NIS
              マスターサーバのデータファイルのコピーを保持します.
              NIS スレーブサーバは重要な環境で必要とされる冗長性を提供し,
              マスターサーバの負荷のバランスをとります.
              NIS クライアントは常に最初にレスポンスを返したサーバを
              NIS サーバとして接続しますが,
              これにはスレーブサーバも含まれます.</para>
          </listitem>
          <listitem>
            <para><emphasis>NIS クライアント</emphasis>.
              NIS クライアントは大部分の NT ワークステーションのように,
              logon に際して
              NIS サーバに対して (NT ワークステーションの場合では NT
              ドメインコントローラに) 認証します.</para>
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>
    
    <sect2>
      <title>NIS/YP を使う</title>
  
      <para>この節では NIS 環境の立ち上げ例を取り上げます.</para>

      <note>
        <para>この節ではあなたが FreeBSD 3.3 以降を使っているものとします.
          ここで与えられる指示は<emphasis>おそらく</emphasis> FreeBSD の
          3.0 以降の, どのバージョンでも機能するでしょうが,
          それを保証するものではありません.</para>
      </note>

      <sect3>
        <title>計画を立てる</title>
  
        <para>あなたが大学の小さな研究室の管理人であるとしましょう.
          この研究室は 15 台の FreeBSD マシンからなっていて,
          現在はまだ集中管理されていません.
	  すなわち, 各マシンは <filename>/etc/passwd</filename> と
          <filename>/etc/master.passwd</filename> を各々が持っています.
	  これらのファイルは手動でお互いに同期させています.
          つまり現時点では, 新しいユーザをあなたが追加するとき,
          <command>adduser</command> を 15 ヶ所すべてで実行しなければなりません.
          これは明らかに変える必要があるため,
	  あなたはこのうち 2 台をサーバにして NIS を導入することを決めました.</para>

        <para>その結果, 研究室の設定はこのようなものになります:</para>

        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>マシンの名前</entry>
                <entry>IP address</entry>
                <entry>役割</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><hostid>ellington</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.2</hostid></entry>
                <entry>NIS マスタ</entry>
              </row>
              <row>
                <entry><hostid>coltrane</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.3</hostid></entry>
                <entry>NIS スレーブ</entry>
              </row>
              <row>
                <entry><hostid>basie</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.4</hostid></entry>
                <entry>教員用のワークステーション</entry>
              </row>
              <row>
                <entry><hostid>bird</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.5</hostid></entry>
                <entry>クライアントマシン</entry>
              </row>
              <row>
                <entry><hostid>cli[1-11]</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.[6-17]</hostid></entry>
                <entry>その他のクライアントマシン</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

	 <para>もし NIS によるシステム管理の設定を行なうのが初めてなら,
          どのようにしたいのか, ひととおり最後まで考えてみることをお勧めします.
          ネットワークの規模によらず, いくつか決めるべきことがあるからです.</para>
  
        <sect4>
          <title>NIS ドメイン名を決める</title>
  
          <para>ここでいうドメイン名は, 今まであなたが使っていた,
            いわゆる <quote>ドメイン名</quote>
            と呼んでいたものとは違います.
	    正確には <quote>NIS ドメイン名</quote> と呼ばれます.
            クライアントがサーバに情報を要求するとき,
            その要求には自分が属する NIS ドメインの名前が含まれています.
	    これは, 1 つのネットワークに複数のサーバがある場合に,
            どのサーバが要求を処理すれば良いかを決めるために使われます.
	    NIS ドメイン名とは, 関連のあるホストをグループ化するための名前である,
            と考えると良いでしょう. </para>
	
	  <para>組織によってはインターネットのドメイン名を
            NIS ドメイン名に使っているところがありますが,
            これはネットワークのトラブルをデバッグするときに混乱の原因となるため,
            お勧めできません.
            NIS ドメイン名はネットワーク内で一意なければならないので,
            ドメイン名がドメインに含まれるマシンを表すようなものであれば,
            分かりやすくなります. たとえば
            Acme 社のアート(Art)部門であれば,
            NIS ドメイン名を"acme-art"とすれば良いでしょう. </para>

          <para>しかしながら, オペレーティングシステムによっては,
            そのネットワークドメイン名を NIS
            のドメイン名として使うものもあります (特に SunOS).
            あなたのネットワークにそのような制限のあるマシンが 1 台でもあるときは, NIS
            のドメイン名としてインターネットのネットワークドメイン名を使わなければ<emphasis>いけません</emphasis>.</para>
        </sect4>

        <sect4>
          <title>サーバマシンの物理的な条件とは</title>
            
	  <para>NIS サーバとして使うマシンを選ぶ際には,
            いくつかの注意点があります.
            NIS における困ったことの一つに,
            クライアントのサーバへの依存度があります.
            クライアントが自分の NIS ドメインのサーバに接続できない場合,
            マシンが使用不能になることがよくあります.
            もし, ユーザやグループに関する情報が得られなければ,
            ほとんどのシステムは一時的にですが停止してしまいます.
            こういったことを念頭に置いて,
            しょっちゅうリブートされるマシンや,
            開発に使われそうなマシンを選ばないようにしなければなりません.
            理想的には, NIS サーバはスタンドアロンで
            NIS サーバ専用となるマシンにするべきです.
            ネットワークの負荷が重くなければ,
            他のサービスを走らせているマシンを NIS
            サーバにしてもかまいません. ただし NIS
            サーバが使えなくなると,
            <emphasis>すべての</emphasis>クライアントに影響をおよぼす,
            という点には注意しなければなりません.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>NIS サーバ</title>

	<para>元となるすべての NIS 情報は,
          NIS マスターサーバと呼ばれる 1 台のマシンに置かれます.
          この情報が格納されるデータベースを NIS マップと呼びます.
          FreeBSDでは, このマップは
	  <filename>/var/yp/[domainname]</filename> に置かれます.
	  <filename>[domainname]</filename> は,
          サーバがサービスする NIS ドメインです.
          1 台の NIS サーバが複数のドメインをサポートすることも可能です.
          つまり, このディレクトリを各々のドメインごとに作ることができ,
          各ドメインごと, 独立したマップの集合を持つことになります.</para>

	<para>NIS のマスターサーバとスレーブサーバ上では,
	  <command>ypserv</command> デーモンがすべての NIS 要求を処理します.
          <command>ypserv</command> は NIS クライアントからの要求を受け付け,
          ドメイン名とマップ名を対応するデータベースファイルへのパスに変換し,
          データをクライアントに返送します.</para>

        <sect4>
	  <title>NIS マスターサーバの設定</title>

	  <para>やりたいことにもよりますが,
            NIS マスターサーバの設定は比較的単純です.
	    FreeBSD は初期状態で NIS に対応しています.
            必要なことは以下の行を <filename>/etc/rc.conf</filename> に追加し,
	    FreeBSD をリスタートすることだけです.</para>

          <itemizedlist>
            <listitem>
              <para>
                <programlisting>nisdomainname="test-domain"</programlisting>

                この行はネットワークのセットアップ時に
                (すなわち再起動したときに) NIS のドメイン名を
                <emphasis>test-domain</emphasis>
                にセットします.</para>
            </listitem>
            <listitem>
              <para>
                <programlisting>nis_server_enable="YES"</programlisting>
                
                これは FreeBSD に, 次にネットワークが立ち上がったとき NIS
                のサーバプロセスを起動させます.</para>
            </listitem>
            <listitem>
              <para>
                <programlisting>nis_yppasswdd_enable="YES"</programlisting>
                
                これは <command>rpc.yppasswdd</command> デーモンを有効にします.
                上述したようにこれはユーザが NIS
                のパスワードをクライアントのマシンから変更することを可能にします.</para>
            </listitem>
          </itemizedlist>

          <para>あと, あなたがしなければいけないことはスーパユーザ権限でコマンド
            <command>/etc/netstart</command> を実行することです.
	    これにより <filename>/etc/rc.conf</filename>
            で定義された値を使ってすべての設定が行なわれます.</para>
	</sect4>

        <sect4>
          <title>NIS マップの初期化</title>

          <para><emphasis>NIS マップ</emphasis> とは
            <filename>/var/yp</filename> ディレクトリにあるデータベースファイルです.
            これらは NIS マスタの <filename>/etc</filename>
            ディレクトリの設定ファイルから作られます.
            唯一の例外は
	    <filename>/etc/master.passwd</filename> ファイルです.
	    これは, root や他の管理用アカウントのパスワードまでその
            NIS ドメインのすべてのサーバに伝えたくないという,
            もっともな理由によるものです.  このため NIS
            マップの初期化の前に以下を行う必要があります.</para>

          <screen>&prompt.root; <userinput>cp /etc/master.passwd /var/yp/master.passwd</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>vi master.passwd</userinput></screen>

          <para>あなたはシステムに関するアカウント (bin, tty, kmem, games, etc)
            をすべて削除しなければなりません.
            またあなたが NIS クライアントに伝えたくないと思うアカウント
            (たとえば root や他の UID が 0 (スーパユーザ) のアカウント)
            についても削除する必要があります.</para>

          <note>
            <para><filename>/var/yp/master.passwd</filename> が
              グループや全世界から読めるようになっていないようにしてください
              (モード 600)! 必要なら <command>chmod</command> コマンドを
              使ってください.</para>
          </note>

          <para>すべてが終わったらマップを初期化します!
            FreeBSD には, これを行うために <command>ypinit</command>
            という名のスクリプトが含まれています
            (詳細はそのマニュアルページをご覧ください).
            このスクリプトはほとんどの UNIX OS で存在しますが,
            すべてとは限らないことを覚えておいてください.
	    Digital Unix/Compaq Tru64 Unix では
            <command>ypsetup</command> と呼ばれています.
	    NIS マスタのためのマップを作るためには
	    <option>-m</option> オプションを <command>ypinit</command>
            に与えます.  上述のステップを完了しているなら,
            以下を実行して NIS マップを生成します.</para>

          <screen>ellington&prompt.root; <userinput>ypinit -m test-domain</userinput>
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] <userinput>n</userinput>
Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server   :  ellington
next host to add:  <userinput>coltrane</userinput>
next host to add:  <userinput>^D</userinput>
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] <userinput>y</userinput>

[..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</screen>

          <para><command>ypinit</command> は
            <filename>/var/yp/Makefile</filename> を
            <filename>/var/yp/Makefile.dist</filename> から作成します.
	    作成されていれば,
            そのファイルはあなたが扱っているのが FreeBSD
            のみからなる,
            サーバが一つだけの NIS 環境であるという前提に立っています.
	    <emphasis>test-domain</emphasis>
            はスレーブサーバを一つ持っていますので,
            <filename>/var/yp/Makefile</filename>
            を編集する必要があります.</para>

          <screen>ellington&prompt.root; <userinput>vi /var/yp/Makefile</userinput></screen>

          <para>`NOPUSH = "True"'
            としている行を (もし既にコメントアウトされていないならば)
            コメントアウトしなければなりません.</para>
        </sect4>

        <sect4>
	  <title>NIS スレーブサーバの設定</title>

	  <para>NIS スレーブサーバの設定はマスターサーバの設定以上に簡単です.
	    スレーブサーバにログオンし <filename>/etc/rc.conf</filename> 
	    ファイルを前回と同様に編集します.  唯一の違うところは
	    <command>ypinit</command> の実行に <option>-s</option>
            オプションを使わなければいけないことです.
            <option>-s</option> オプションは NIS
            マスターサーバの名前を要求し, コマンドラインは以下のようになります.</para>

  <screen>coltrane&prompt.root; <userinput>ypinit -s ellington test-domain</userinput>

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  <userinput>n</userinput>

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work. 
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors. 
Don't forget to update map ypservers on ellington.</screen>
        
	  <para>この例の場合, <filename>/var/yp/test-domain</filename>
            というディレクトリが必要になります.  
            NIS マスターサーバのマップファイルのコピーはこのディレクトリに置かれますが,
            あなたは, これらが確実に最新のものに維持されるようにする必要があります.
            次のエントリをスレーブサーバの <filename>/etc/crontab</filename>
            に追加することで, 最新のものに保つことができます.
          </para>
        
	  <programlisting>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</programlisting>

	  <para>この二行は,
            スレーブサーバにあるマップファイルをマスターサーバのマップファイルと同期させるものですが, 
            必須というわけではありません. なぜなら,
            マスターサーバは, NIS マップに対する変更をスレーブサーバに伝えようとするからです.
            しかし, サーバが管理するシステムにとってパスワード情報はとても重要なものですので,
            強制的に更新してしまう方が良いでしょう.
            特に,
            マップファイルの更新がきちんと行なわれるかどうかわからないくらい混雑するネットワークでは,
            重要なポイントになります.</para>
          
          <para>コマンド <command>/etc/netstart</command>
            をスレーブサーバでも実行してください.
            NIS サーバを起動します.</para>
	</sect4>
      </sect3>

      <sect3>
        <title>NIS クライアント</title>
	
	<para>NIS クライアントは <command>ypbind</command>
          デーモンを使って, 特定の NIS
          サーバとの間に結合 (binding) と呼ばれる関係を成立させます. 
	  <command>ypbind</command> はシステムのデフォルトのドメイン
          (<command>domainname</command> コマンドで設定されます)
          をチェックし, RPC 要求をブロードキャストパケットとしてローカルネットワークに送信します.
          この RPC 要求により, <command>ypbind</command>
          が結合を成立させようとしているドメイン名が指定されます.
	  要求されているドメイン名に対してサービスするよう設定されたサーバが
          ブロードキャストパケットを受信すると,
          サーバは <command>ypbind</command> に応答し,
          <command>ypbind</command> は応答のあったサーバのアドレスを記録します. 
	  複数のサーバがある(たとえば一つのマスターサーバと,
          複数のスレーブサーバがある)場合,
          <command>ypbind</command> は,
          最初に応答したサーバのアドレスを使用します.
          これ以降, クライアントのシステムは,
          すべての NIS の要求をそのサーバに向けて送信します. 
	  <command>ypbind</command> は,
          サーバが順調に動作していることを確認するため,
          時々 <quote>ping</quote> をサーバに送ります.
          反応が戻ってくるべき時間内に ping に対する応答が来なければ,
	  <command>ypbind</command> は,
          そのドメインを結合不能(unbound)として記録し,
          別のサーバを見つけるべく, 再びブロードキャストパケットの送信を行います. </para>

	<sect4>
	  <title>NIS クライアントの設定</title>
	  
	  <para>FreeBSD マシンにおける NIS クライアントの設定は非常に単純です.</para>
	
	  <itemizedlist>
	    <listitem>
	      <para><filename>/etc/rc.conf</filename>
                ファイルを編集して以下の行を追加し,
                ネットワークのセットアップ時に
                NIS ドメイン名をセットして
                <command>ypbind</command> を起動させます.</para>

	      <programlisting>nisdomainname="test-domain"
nis_client_enable="YES"</programlisting>
	    </listitem>

	    <listitem>
	      <para>NIS サーバにあるすべてのパスワードエントリを取り込むため, 
                <command>vipw</command> コマンドで以下の行を
                <filename>/etc/master.passwd</filename> に追加します. </para>

	      <programlisting>+:::::::::</programlisting>

	      <note>
		<para>この行によって NIS
                  サーバのパスワードマップにアカウントがある人全員にアカウントが与えられます.
                  この行を変更すると, さまざまな NIS クライアントの設定を行なうことが可能です.
		  詳細は <link linkend="netgroups">netgroups</link> の部分を,
		  さらに詳しい情報については, O'Reilly の
                  <literal>Managing NFS and NIS</literal> をお読みください.</para>
	      </note>
	    </listitem>

	    <listitem>
	      <para>NIS サーバにあるすべてのグループエントリを取り込むため, 
	        以下の行を <filename>/etc/group</filename> に追加します.</para>
	        
	      <programlisting>+:*::</programlisting>
	    </listitem>
	  </itemizedlist>

	  <para>上記の手順がすべて完了すれば,
            <command>ypcat passwd</command> によって
            NIS サーバの passwd マップが参照できるようになっているはずです.
          </para>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>NIS セキュリティ</title>

      <para>一般にドメイン名さえ知っていれば,
        どこにいるリモートユーザでも ypserv に RPC を発行して
        NIS マップの内容を引き出すことができます.
        こういった不正なやりとりを防ぐため,
        ypserv には securenets と呼ばれる機能があります.
        これはアクセスを決められたホストだけに制限する機能です.
        ypserv は起動時に <filename>/var/yp/securenets</filename> ファイルから
        securenets に関する情報を読み込みます.</para>
	
      <note>
	<para>上記のパス名は, <option>-p</option>
          オプションで指定されたパス名によって変わります.
          このファイルは, 空白で区切られたネットワーク指定とネットマスクのエントリからなっていて,
          <quote>#</quote> で始まる行はコメントとみなされます.
          簡単な securenets ファイルの例を以下に示します.</para>
      </note>

      <programlisting># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
10.0.0.0      255.255.240.0</programlisting>

      <para>ypserv が上記のルールの一つと合致するアドレスからの要求を受け取った場合,
        処理は通常に行なわれます.
        もしアドレスがルールに合致しなければ,
        その要求は無視されて警告メッセージがログに記録されます.
	また, <filename>/var/yp/securenets</filename> が存在しない場合,
        ypserv はすべてのホストからの接続を受け入れます.
      </para>

      <para>ypserv は Wietse Venema 氏による
	<application>tcpwrapper</application> パッケージもサポートしています.
        そのため, <filename>/var/yp/securenets</filename> の代わりに
        tcpwrapper の設定ファイルを使ってアクセス制御を行なうことも可能です.
      </para>

      <note>
	<para>これらのアクセス制御機能は一定のセキュリティを提供しますが,
          どちらも特権ポートのテストのような <quote>IP spoofing</quote>
          攻撃に対して脆弱です.
          すべての NIS 関連のトラフィックはファイアウォールでブロックされるべきです.</para>

        <para><filename>/var/yp/securenets</filename>
          を使っているサーバは,
          古風な TCP/IP 実装を持つ正しいクライアントへのサービスに失敗することがあります.
          これらの実装の中にはブロードキャストのホストビットをすべて 0 でセットしてしまったり
	  ブロードキャストアドレスの計算でサブネットマスクを見落としてしまったりするものがあります.
          これらの問題はクライアントの設定を正しく行なうことで修正できますが,
          他の問題は問題となっているクライアントシステムの撤去か
	  <filename>/var/yp/securenets</filename> の放棄が必要です.</para>

        <para>このような古風な TCP/IP の実装を持つサーバで
          <filename>/var/yp/securenets</filename>
          を使うことは非常に悪い考えであり,
          あなたのネットワークの大部分において
	  NIS の機能を失うことになるでしょう.</para>

        <para><application>tcpwrapper</application>
          パッケージの使用はあなたの NIS サーバのレイテンシ (遅延) を増加させます.
          追加された遅延は, 特に混雑したネットワークや遅い
          NIS サーバでクライアントプログラムのタイムアウトを引き起こすに十分なだけ長いでしょう.
          一つ以上のクライアントシステムがこれらの兆候を示したなら,
          あなたは問題となっているクライアントシステムを
          NIS スレーブサーバにして自分自身に結び付くように強制すべきです.</para>
      </note>
    </sect2>

    <sect2>
      <title>何人かのユーザのログオンを遮断する</title>
      
      <para>わたしたちの研究室には <hostid>basie</hostid> という,
        教員専用のマシンがあります.  わたしたちはこのマシンを
        NIS ドメインの外に出したくないのですが,
        マスタ NIS サーバの <filename>passwd</filename>
        ファイルには教員と学生の両方が載っています.
        どうしたらいいでしょう?</para>

      <para>当該人物が NIS のデータベースに載っていても,
        そのユーザがマシンにログオンできないようにする方法があります.
        そうするには, <emphasis>-<replaceable>username</replaceable></emphasis> を
	クライアントマシンの <filename>/etc/master.passwd</filename>
        ファイルの末尾に付け足します.
        <replaceable>username</replaceable>
        はあなたがログインさせたくないと思っているユーザのユーザ名です.
        これは <command>vipw</command> で行うべきです.
        <command>vipw</command> は <filename>/etc/master.passwd</filename>
        への変更をチェックし, 編集終了後パスワードデータベースを再構築します.
        たとえば, ユーザ <emphasis>bill</emphasis> が <hostid>basie</hostid>
        にログオンするのを防ぎたいなら, 以下のようにします.</para>

        <screen>basie&prompt.root; <userinput>vipw</userinput>
<userinput>[add -bill to the end, exit]</userinput>
vipw: rebuilding the database...
vipw: done

basie&prompt.root; <userinput>cat /etc/master.passwd</userinput>

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/share/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
-bill

basie&prompt.root;</screen>
    </sect2>

    <sect2 id="netgroups">
      <title>netgroups の利用</title>

      <para><emphasis>netgroups の部分の原作:
	Udo Erdelhoff <email>ue@nathan.ruhr.de</email>.
	2000 年 7 月.</emphasis></para>

      <para>前節までに見てきた手法は,
        極めて少ないユーザ/マシン向けに個別のルールを必要としている場合にはうまく機能します.
        しかし大きなネットワークでは,
        ユーザに触られたくないマシンへログオンを防ぐのを<emphasis>忘れるでしょう</emphasis>し,
        そうでなくとも各マシンを個別に設定して回らなければならず,
	<emphasis>集中</emphasis>管理という NIS の恩恵を失ってしまいます.</para>

      <para>NIS の開発者はこの問題を <emphasis>netgroups</emphasis>
        と呼ばれる方法で解決しました.
        彼らの目的とその意味合いは UNIX
        のファイルシステムで使われている一般的なグループと比較できます.
	主たる相違は数字による id を欠いていることと,
        ネットグループを定義するのにユーザアカウントと別のネットグループの,
        両方を含められる機能です.</para>

      <para>ネットグループは百人/台以上のユーザとマシンを含む,
        大きく複雑なネットワークを扱うために開発されました.
        もし, あなたがこのような状況を扱わなければならないなら便利なものなのですが,
        この複雑さは単純な例でネットグループの説明をすることをほとんど不可能にしています.
        この部の残りで使われている例は, この問題を実演しています.</para>

      <para>あなたの行なった, 研究室への NIS
        の導入の成功が上司の目に止ったとしましょう.
        あなたの次の仕事は,
        あなたの NIS
        ドメインをキャンパスの他のいくつものマシンを覆うものへ拡張することです.
        二つの表は新しいユーザと新しいマシンの名前とその説明を含んでいます.</para>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>ユーザの名前</entry>
              <entry>説明</entry>
            </row>
          </thead>
   
          <tbody>
            <row>
              <entry>alpha, beta</entry>
              <entry>IT 学科の通常の職員</entry>
            </row>
            
            <row>
              <entry>charlie, delta</entry>
              <entry>IT 学科の新しい見習い</entry>
            </row>
            
            <row>
              <entry>echo, foxtrott, golf, ...</entry>
              <entry>一般の職員</entry>
            </row>
            
            <row>
              <entry>able, baker, ...</entry>
              <entry>まだインターン</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>マシンの名前</entry>
              <entry>説明</entry>
            </row>
          </thead>
   
          <tbody>
            <row>
              <!--  Names taken from "Good Omens" by Neil Gaiman and Terry
                    Pratchett.  Many thanks for a brilliant book.  --> 
              <entry>war, death, famine, polution</entry>
              <entry>最も重要なサーバ.  IT 職員だけがログオンを許されます.</entry>
            </row>
            <row>
              <!-- gluttony was omitted because it was too fat ;-) -->
              <entry>pride, greed, envy, wraith, lust, sloth</entry>
              <entry>あまり重要でないサーバ.  IT 学科の全員がログオンを許されます.</entry>
            </row>
            
            <row>
              <entry>one, two, three, four, ...</entry>
              <entry>通常のワークステーション.
                <emphasis>本当の</emphasis> 職員だけがログオンを許されます.</entry>
            </row>
            
            <row>
              <entry>trashcan</entry>
              <entry>重要なデータの入っていないひどく古いマシン.
                インターンでもこのマシンの使用を許されます.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>もしあなたがこの手の制限を各ユーザを個別にブロックする形で実装するなら,
        あなたはそのシステムにログオンすることが許されていない各ユーザについて
        -<replaceable>user</replaceable> という 1 行を,
        各システムのパスワードに追加しなければならなくなるでしょう.
        もしあなたが 1 エントリでも忘れればトラブルに巻き込まれてしまいます.
	最初のセットアップの時にこれを正しく行えるのはありえることかも知れませんが,
        遂には連日の業務の間に例の行を追加し<emphasis>忘れてしまうでしょう</emphasis>.
        結局マーフィーは楽観主義者だったのです.</para>

      <para>この状況をネットグループで扱うといくつかの有利な点があります.
        各ユーザを別個に扱う必要はなく,
        ユーザを一つ以上のネットグループに割り当て,
        ネットグループの全メンバのログインを許可したり禁止したりすることができます.
        新しいマシンを追加するときはネットグループへログインの制限を定義するだけ,
	新しいユーザを追加するときはそのユーザを一つ以上のネットグループへ追加するだけで,
        それぞれ行なうことができます.
        これらの変更は互いに独立なので,
        <quote>ユーザとマシンの組合わせをどうするか</quote>
	は存在しなくなります. 
        あなたの NIS のセットアップが注意深く計画されていれば,
        マシンへのアクセスを認めるにも拒否するにも中心の設定をたった一カ所変更するだけです.</para>
        
      <para>最初のステップは NIS マップ netgroup の初期化です.
        FreeBSD の ypinit はこのマップをデフォルトで作りませんが,
        その NIS の実装はそれが作られさえすればそれをサポートするものです.
        空のマップを作るには, 単に</para>

      <screen>ellington&prompt.root; <userinput>vi /var/yp/netgroup</userinput></screen>

      <para>とタイプして内容を追加していきます.
        わたしたちの例では, すくなくとも
        IT 職員, IT 見習い, 一般職員, インターンの
        4 つのネットグループが必要です.</para>

      <programlisting>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
        (,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</programlisting>

      <para><literal>IT_EMP</literal>, <literal>IT_APP</literal>
        等はネットグループの名前です.
        それぞれの括弧で囲まれたグループが一人以上のユーザアカウントをそれに登録しています.
        グループの 3 つのフィールドは</para>
        
      <orderedlist> 
        <listitem>
          <para>その記述が有効なホスト(群)の名称.
            ホスト名を特記しなければそのエントリはすべてのホストで有効です.
	    もしあなたがホスト名を特記するなら,
            あなたは闇と恐怖と全き混乱の領域となるでしょう.</para>
        </listitem>

        <listitem>
          <para>このネットグループに所属するアカウントの名称.</para>
        </listitem>

        <listitem>
          <para>そのアカウントの NIS ドメイン.
            もしあなたが一つ以上の NIS ドメインの不幸な仲間なら,
            あなたは他の NIS
            ドメインからあなたのネットグループにアカウントを導入できます.</para>
        </listitem>
      </orderedlist>

      <para>各フィールドには, ワイルドカードが使えます.
        詳細は &man.netgroup.5; をご覧ください.</para>
        
      <note>
        <para>8 文字以上のネットグループ名は,
          特にあなたの NIS
          ドメインで他のオペレーティングシステムを走らせているときは使うべきではありません.
          名前には大文字小文字の区別があります.
	  そのためネットグループ名に大文字を使う事は,
          ユーザやマシン名とネットグループ名を区別する簡単な方法です.</para>

        <para>NIS クライアントの中には (FreeBSD 以外で)
          多数のエントリを扱えないものもあります.
          たとえば SunOS の古い版では 15
          以上の<emphasis>エントリ</emphasis>を含むネットグループはトラブルを起こします.
          この制限は 15 ユーザ以下のサブ・ネットグループをいくつも作り,
	  本当のネットグループはこのサブ・ネットグループからなるようにすることで回避できます.</para>

        <programlisting>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe32,domain)  (,joe33,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</programlisting>

        <para>単一のネットグループに 225 人以上のユーザをいれたいときは,
          このやり方を繰り返すことができます.</para>
      </note>

      <para>新しい NIS マップの有効化と配布は簡単です.</para>

      <screen>ellington&prompt.root; <userinput>cd /var/yp</userinput>
ellington&prompt.root; <userinput>make</userinput></screen>
      
      <para>これで新しい 3 つの NIS マップ
        <filename>netgroup</filename>,
        <filename>netgroup.byhost</filename> 
        <filename>netgroup.byuser</filename> ができるはずです.
	新しい NIS マップが利用できるか確かめるには
        &man.ypcat.1; を使います.</para>

      <screen>ellington&prompt.user; <userinput>ypcat -k netgroup</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byhost</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byuser</userinput></screen>

      <para>最初のコマンドの出力は <filename>/var/yp/netgroup</filename>
        の内容に似ているはずです.
        2 番目のコマンドはホスト別のネットグループを作っていなければ出力されません.
        3 番目のコマンドはユーザに対するネットグループのリストを得るのに使えます.</para>

      <para>クライアント側の設定は非常に簡単です.
        サーバ <replaceable>war</replaceable> を設定するには, 
        &man.vipw.8; を実行して以下の行</para>
        
      <programlisting>+:::::::::</programlisting>
      
      <para>を</para>

      <programlisting>+@IT_EMP:::::::::</programlisting>

      <para>に入れ替えるだけです.</para>
      
      <para>今, ネットグループ <replaceable>IT_EMP</replaceable>
        で定義されたユーザのデータだけが <replaceable>war</replaceable>
        のパスワードデータベースに読み込まれ,
        そのユーザだけがログインを許されています.</para>

      <para>残念ながらこの制限はシェルの ~ の機能や,
        ユーザ名やユーザの数値  id の変換ルーチンにも影響します.
        言い換えれば, 
        cd ~<replaceable>user</replaceable> はうまく動かず,
	<command>ls -l</command> はユーザ名のかわりに数値の id を表示し
        <command>find . -user joe -print</command> は
        <quote>No such user</quote> で失敗します.
        これを避けるためには,
        すべてのユーザのエントリを<emphasis>サーバにログインすることを許さずに</emphasis>読み込むことが必要です.</para>

      <para>これはもう一行を <filename>/etc/master.passwd</filename>
        に追加することで実現できます.  その行は
        <literal>+:::::::::/sbin/nologin</literal> を含んでおり,
        <quote>すべてのエントリを読み込むが, 読み込まれたエントリのシェルは
          <filename>/sbin/nologin</filename> で置き換えられる</quote>
	ということを意味します.  passwd エントリの他のフィールドを
	<filename>/etc/master.passwd</filename>
        の既定値から置き換えることも可能です.</para>

      <!-- Been there, done that, got the scars to prove it - ue -->
      <warning>
        <para><literal>+:::::::::/sbin/nologin</literal> の行が
          <literal>+@IT_EMP:::::::::</literal>
          の行より後ろに位置することに注意してください.
          さもないと NIS から読み込まれた全ユーザが /sbin/nologin
          をログインシェルとして持つことになります.</para>
      </warning>

      <para>この変更の後では, 新しい職員が IT 学科に参加しても
        NIS マップを一つ書き換えるだけで済みます.
        同様にして, あまり重要でないサーバのローカルの
        <filename>/etc/master.passwd</filename>
        のかつての
	<literal>+:::::::::</literal>
        行を以下のように置き換えます.</para>

      <programlisting>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>この行は, 一般のワークステーションでは以下のようになります.</para>

      <programlisting>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>これでしばらく順調に運用していましたが,
        数週間後, ポリシに変更がありました.
        IT 学科はインターンを雇い始め, IT
        インターンは一般のワークステーションと余り重要ではないサーバを使うことが許され,
	IT 見習いはメインサーバへのログインが許されました.
        あなたは新たなネットグループ IT_INTERN を追加して新しい IT
        インターンたちをそのグループに登録し,
        すべてのマシンの設定を変えて回ることにしました.
	古い諺にこうあります.
        <quote>集中管理における過ちは, 大規模な混乱を導く</quote>.</para>

      <para>いくつかのネットグループから新たなネットグループを作るという
        NIS の機能は, このような状況に対処するために利用できます.
	その方法の一つは, 役割別のネットグループを作ることです.
	たとえば, 重要なサーバへのログイン制限を定義するために
        <replaceable>BIGSRV</replaceable> というネットグループを作り
	あまり重要ではないサーバへは <replaceable>SMALLSRV</replaceable>
	というネットグループを, そして一般のワークステーション用に
        <replaceable>USERBOX</replaceable> という第 3 のネットグループを
	作ることができます.  これらのネットグループの各々は,
        各マシンにログインすることを許されたネットグループを含みます.
	あなたの NIS マップネットグループの新しいエントリは,
        以下のようになるはずです.</para>

      <programlisting>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</programlisting>

      <para>このログイン制限の定義法は,
        同一の制限を持つマシンのグループを定義できるときには便利なものです.
        残念ながらこのようなケースは例外的なものです.
        ほとんどの場合, 各マシンに基づくログイン制限の定義機能が必要となるでしょう.</para>

      <para>マシンごとのネットグループの定義は,
        上述したようなポリシの変更を扱うことができるもうひとつの方法です.
        このシナリオでは, 各マシンの <filename>/etc/master.passwd</filename> は
	``+'' で始まる２つの行を含みます.
        最初のものはそのマシンへのログインを許されたアカウントを追加するもので,
	2 番目はその他のアカウントを<filename>/sbin/nologin</filename>
	をシェルとして追加するものです.
        マシン名をすべて大文字で記述したものをネットグループの名前として使うのは良いやり方です.
	言い換えれば, 件の行は次のようになるはずです.</para>

      <programlisting>+@<replaceable>BOXNAME</replaceable>:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>一度, 各マシンに対してこの作業を済ませてしまえば,
        二度とローカルの <filename>/etc/master.passwd</filename>
        を編集する必要がなくなります.
        以降のすべての変更は NIS マップの編集で扱うことができます.
        以下はこのシナリオに対応するネットグループマップに,
        いくつかの便利な定義を追加した例です.</para>
      
      <programlisting># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION  BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]</programlisting>

      <para>もしユーザアカウントを管理するデータベースの類を使っているなら,
        あなたはデータベースのレポートツールからマップの最初の部分を作れるようにしてあるべきです.
        この方法なら, 新しいユーザは自動的にマシンにアクセスできるでしょう.</para>

      <para>最後に使用上の注意を:
        マシン別のネットグループを使うことが常に賢明というわけではありません.
        あなたが数ダースから数百の同一の環境のマシンを学生の研究室に配置しているのならば,
        NIS マップのサイズを手頃な範囲に押さえるために,
        マシン別のネットグループのかわりに役割別のネットグループを使うべきです.</para>
    </sect2>

    <sect2>
      <title>忘れてはいけないこと</title>

      <para>NIS 環境にある今, 今までとは違ったやり方が必要なことが
         2,3 あります.</para>

      <itemizedlist>
        <listitem>
          <para>研究室にユーザを追加するときは,
            それをマスター NIS サーバに<emphasis>だけ</emphasis>追加しなければならず,
            さらに<emphasis>NIS マップを再構築することを忘れてはいけません</emphasis>.
            これを忘れると新しいユーザは NIS マスタ以外のどこにもログインできなくなります.
            たとえば, 新しくユーザ <quote>jsmith</quote>
            をラボに登録したいときは以下のようにします.</para>

          <screen>&prompt.root; <userinput>pw useradd jsmith</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>make test-domain</userinput></screen>

          <para><command>pw useradd jsmith</command> のかわりに
            <command>adduser jsmith</command> を使うこともできます.</para>
        </listitem>
        <listitem>
          <para><emphasis>管理用アカウントを NIS マップから削除してください</emphasis>.
            管理用アカウントやパスワードを,
            それらのアカウントへアクセスされるべきでないユーザが居るかも知れないマシンにまで伝えて回りたいとは思わないでしょう.</para>
        </listitem>
        <listitem>
          <para><emphasis>NIS のマスタとスレーブをセキュアに,
              そして機能停止時間を最短に保ってください</emphasis>.
	    もし誰かがこれらのマシンをクラックしたり,
            あるいは単に電源を落としたりすると,
            彼らは実質的に多くの人を研究室へログインできなくしてしまえます.</para>

          <para>これはどの集中管理システムにとっても第一の弱点で,
            そして最も重要な弱点でしょう.
            あなたの NIS サーバを守らなければ怒れるユーザと対面することになるでしょう!</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>NIS v1 との互換性</title>

      <para>FreeBSD の
        <application>ypserv</application> は,
        NIS v1 クライアントを部分的にサポートします.
        FreeBSD の NIS 実装は NIS v2 プロトコルのみを使用していますが,
        ほかの実装では, 古いシステムとの下位互換性を持たせるため
        v1 プロトコルをサポートしているものもあります.
        そのようなシステムに付いている
        <application>ypbind</application> デーモンは,
        必要がないにもかかわらず NIS v1
        のサーバとの結合を成立させようとします(しかも
	v2 サーバからの応答を受信した後でも,
        ブロードキャストをし続けるかも知れません).
        FreeBSD の ypserv は,
        クライアントからの通常のリクエストはサポートしていますが,
        v1 のマップ転送リクエストはサポートしていないことに注意してください.
        つまり FreeBSD の ypserv を,
        v1 だけをサポートするような古い NIS サーバと組み合わせて
        マスターやスレーブサーバとして使うことはできません.
        幸いなことに, 現在, そのようなサーバが使われていることは
        ほとんどないでしょう.</para>
    </sect2>

    <sect2>
      <title>NIS クライアントとしても動作している NIS サーバ</title>

      <para>複数のサーバが存在し, サーバ自身が NIS
        クライアントでもあるようなドメインで  ypserv が実行される場合には,
        注意が必要です.
        一般的に良いとされているのは,
        他のサーバと結合をつくるようにブロードキャストパケットの送信をさせるのではなく,
        サーバをそれ自身に結合させることです.
        もし, サーバ同士が依存関係を持っていて, 一つのサーバが停止すると,
        奇妙なサービス不能状態に陥ることがあります.
        その結果, すべてのクライアントはタイムアウトを起こして
        他のサーバに結合しようと試みますが,
        これにかかる時間はかなり大きく,
        サーバ同士がまた互いに結合してしまったりすると,
        サービス不能状態はさらに継続することになります.</para>

      <para>
        <command>ypbind</command> に
        <option>-S</option> オプションフラグを指定して実行することで, 
        ホストを特定のサーバに結合することが可能です.
      </para>
    </sect2>

    <sect2>
      <title>libscrypt 対 libdescrypt</title>

      <para>
        NIS を実装しようする人の誰もがぶつかる問題の一つに,
        暗号ライブラリの互換性があります.
        NIS サーバが DES 暗号ライブラリを使っている場合には,
        同様に DES を使用しているクライアントしかサポートできません. 
	サーバとクライアントがどのライブラリを使用しているかは,
        <filename>/usr/lib</filename>
        のシンボリックリンクを見ればわかります.
        あるマシンが DES ライブラリを使うように設定されている場合,
        リンクは以下のようになっています. </para>

      <screen>
&prompt.user; <userinput>ls -l /usr/lib/*crypt*</userinput>
lrwxrwxrwx  1 root  wheel     13 Jul 15 08:55 /usr/lib/libcrypt.a@ -> libdescrypt.a
lrwxrwxrwx  1 root  wheel     14 Jul 15 08:55 /usr/lib/libcrypt.so@ -> libdescrypt.so
lrwxrwxrwx  1 root  wheel     16 Jul 15 08:55 /usr/lib/libcrypt.so.2@ -> libdescrypt.so.2
lrwxrwxrwx  1 root  wheel     15 Jul 15 08:55 /usr/lib/libcrypt_p.a@ -> libdescrypt_p.a
-r--r--r--  1 root  wheel  13018 Nov  8 14:27 /usr/lib/libdescrypt.a
lrwxr-xr-x  1 root  wheel     16 Nov  8 14:27 /usr/lib/libdescrypt.so@ -> libdescrypt.so.2
-r--r--r--  1 root  wheel  12965 Nov  8 14:27 /usr/lib/libdescrypt.so.2
-r--r--r--  1 root  wheel  14750 Nov  8 14:27 /usr/lib/libdescrypt_p.a</screen>

      <para>マシンが FreeBSD の標準の MD5 暗号ライブラリを使うように
	設定されている場合には, 以下のようになります. </para>

      <screen>
&prompt.user; <userinput>ls -l /usr/lib/*crypt*</userinput>
lrwxrwxrwx  1 root  wheel     13 Jul 15 08:55 /usr/lib/libcrypt.a@ -> libscrypt.a
lrwxrwxrwx  1 root  wheel     14 Jul 15 08:55 /usr/lib/libcrypt.so@ -> libscrypt.so
lrwxrwxrwx  1 root  wheel     16 Jul 15 08:55 /usr/lib/libcrypt.so.2@ -> libscrypt.so.2
lrwxrwxrwx  1 root  wheel     15 Jul 15 08:55 /usr/lib/libcrypt_p.a@ -> libscrypt_p.a
-r--r--r--  1 root  wheel   6194 Nov  8 14:27 /usr/lib/libscrypt.a
lrwxr-xr-x  1 root  wheel     14 Nov  8 14:27 /usr/lib/libscrypt.so@ -> libscrypt.so.2
-r--r--r--  1 root  wheel   7579 Nov  8 14:27 /usr/lib/libscrypt.so.2
-r--r--r--  1 root  wheel   6684 Nov  8 14:27 /usr/lib/libscrypt_p.a</screen>
	
      <para>NIS クライアントの認証でトラブルが発生した場合には,
        ここから問題となりそうな部分を探すと良いでしょう.
	NIS サーバを異種混在ネットワークに配置したいときは
        DES が最大公約数となるでしょうから,
        すべてのシステムで DES を使わなければいけなくなるでしょう.</para>
    </sect2>
  </sect1>

  <sect1 id="dhcp">
    <title>DHCP</title>

    <para><emphasis>原作: &a.gsutter;, 2000 年 3 月.</emphasis></para>

    <sect2>
      <title>DHCPとは何でしょう?</title>

      <para>
	DHCP (Dynamic Host Configuration Protocol) は, システムをネットワー
	クに接続するだけで, ネットワークでの通信に必要な情報を入手するこ
	とができる仕組みです. FreeBSD では, ISC (Internet Software
	Consortium) による DHCP の実装を使用しています. したがって, ここで
	の説明のうち, 実装によって異なる部分は ISC のもの用になっています.
      </para>
    </sect2>

    <sect2>
      <title>この節で説明していること</title>

      <para>
        ハンドブックのこの節では DHCP システムの, FreeBSD に組み込まれてい
        る部分についてだけ説明しています. ですから, サーバについては説明
        していません. 後の節で紹介するリファレンスに加えて,
	DHCP のマニュアルページも有力な参考になることでしょう.</para>
    </sect2>

    <sect2>
      <title>DHCP の動作</title>

      <para>
        クライアントとなるマシン上で DHCP のクライアントである dhclient を実
        行すると, まず設定情報の要求をブロードキャストします. デフォルト
        では, このリクエストには UDP のポート 68 を使用します. サーバは UDP の
        ポート 67 で応答し, クライアントの IP アドレスと, ネットマスクやルー
        タ, DNS サーバなどの関連する情報を提供します. これらの情報の
        すべては DHCP の「リース」の形で送られ, DHCP サーバ管理者によって決
        められたある一定の時間内でのみ有効になります. これによって, ネッ
        トワークに存在しなくなったホストの IP アドレスは自動的に回収される
        ことになります. 
      </para>

      <para>
        DHCP クライアントはサーバから非常に多くの情報を取得することができます.
	  &man.dhcp-options.5; に, その非常に大きなリストが載っています.</para>
    </sect2>

    <sect2>
      <title>FreeBSD への組み込み</title>

      <para>
	FreeBSD は ISC の DHCP クライアントである
	<command>dhclient</command> を完全に組み込んでいます. DHCP クラ
	イアントはインストーラと基本システムの両方で提供されています. 
	ですから DHCP サーバを走らせているネットワーク上ではネットワー
	ク関係の設定についての詳細な知識は必要になりません. 
	<command>dhclient</command> は, 3.2 以降の FreeBSD のすべての配布
	に含まれています.</para>

      <para>
	DHCP は <application>sysinstall</application> でサポートされてお
	り, sysinstall でのネットワークインタフェイス設定の際は, 「こ
	のインタフェイスの設定として DHCP を試してみますか?」という質問
	が最初になされます. これに同意することで dhclient が実行さ
	れ, それが成功すればネットワークの設定情報は自動的に取得されま
	す. </para>

      <para>システム起動時に, DHCP を使ってネットワーク情報を取得するように
	するには, 次の 2 つのステップを行なう必要があります.</para>

      <itemizedlist>
        <listitem>
          <para><devicename>bpf</devicename>
            デバイスがカーネルに組み込まれていることを確認します.
            これを組み込むには, カーネルコンフィグレーションファイルに
            <literal>pseudo-device bpf</literal>
            という行を追加し, カーネルを再構築します.
            カーネルの構築に関する詳細は,
            <xref linkend="kernelconfig"> を参照してください.</para>

          <para><devicename>bpf</devicename> デバイスは,
            FreeBSD の出荷時に用意されている
            <filename>GENERIC</filename> カーネルに組み込まれていますので,
            自分で設定を変えたカスタムカーネルを使っているのでなければ,
            DHCP を動作させるためにカーネルを再構築する必要はありません.</para>
          
          <note>
            <para>セキュリティに関心のある方向けに注意しておきます.
              <devicename>bpf</devicename>
              デバイスは, パケットスニファ (盗聴プログラム)
              を動作させることができる (ただし root 権限が必要)
              デバイスです.
              <devicename>bpf</devicename> は DHCP を動作させるために
              <emphasis>かならず</emphasis>必要ですが,
              セキュリティが非常に重要な場面では
              DHCP を本当に使う時まで <devicename>bpf</devicename>
              デバイスをカーネルに追加すべきではないでしょう.</para>
          </note>
        </listitem>

        <listitem>
          <para><filename>/etc/rc.conf</filename> を編集して,
            次の行を追加してください.</para>

          <programlisting>ifconfig_fxp0="DHCP"</programlisting>

          <note>
            <para><literal>fxp0</literal> の部分を, 動的に設定したいインター
              フェースの名前で置き換えることを忘れないようにしてください. 
            </para>
          </note>
          
          <para>
            もし, 使っている<command>dhclient</command> の場所を変更してい
            たり, <command>dhclient</command> にフラグを渡したい場合は, 同
            様に下のように書き加えてください.</para>
          
          <programlisting>dhcp_program="/sbin/dhclient"
dhcp_flags=""</programlisting>
        </listitem>
      </itemizedlist>

      <para>
	DHCP サーバである <command>dhcpd</command> は, ports
	collectionに <literal>isc-dhcp2</literal> として収録されていま
	す. この port はクライアント, サーバ, リレーエージェントから成
	る ISC の DHCP 配布物をすべて含んでいます. 
      </para>
    </sect2>

    <sect2>
      <title>関連ファイル</title>

      <itemizedlist>
        <listitem><para><filename>/etc/dhclient.conf</filename></para>
          <para><command>dhclient</command> は設定ファイル
            <filename>/etc/dhclient.conf</filename> を必要とします. 
            大抵の場合, このファイルはコメントだけであり, デフォルトが
            通常使いやすい設定になっています. この設定ファイルは
            マニュアルページ &man.dhclient.conf.5; で説明しています.
          </para>
        </listitem>

        <listitem><para><filename>/sbin/dhclient</filename></para>
	  <para>
	    <command>dhclient</command> は静的にリンクされており, 
	    <filename>/sbin</filename> に置かれています. マニュアルページ 
	      &man.dhclient.8; で <command>dhclient</command> コマンドについて
	    より詳しく説明しています.</para>
        </listitem>

        <listitem><para><filename>/sbin/dhclient-script</filename></para>
          <para>
            <command>dhclient-script</command> は FreeBSD 特有の, DHCP クラ
            イアント設定スクリプトです. これについてはマニュアルページ
	      &man.dhclient-script.8; で説明されていますが, これを編集する
            必要はほとんど発生しないでしょう.</para>
	</listitem>

        <listitem><para><filename>/var/db/dhclient.leases</filename></para>
          <para>
            DHCP クライアントはこのファイルに有効なリースのデータベースを
            ログとして記録します. &man.dhclient.leases.5; にもうすこし詳
            しい解説があります. 
          </para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>参考になる文献</title>

      <para>DHCP のプロトコルは
        <ulink url="http://www.freesoft.org/CIE/RFC/2131/">RFC 2131</ulink>
         に完全に記述されています. また, 
        <ulink url="http://www.dhcp.org/">dhcp.org</ulink>
	にも有用な
        情報源が用意されています. </para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
