<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.16
     $FreeBSD: doc/ja_JP.eucJP/books/handbook/internals/chapter.sgml,v 1.7 2000/01/11 08:41:59 motoyuki Exp $
-->

<chapter id="internals">
  <title>FreeBSD の内部</title>
  
  <sect1 id="booting">
    <title>FreeBSDのブート処理の流れ</title>

    <sect2 id="boot-intro">
      <title>はじめに</title>
  
      <para>
        <firstterm>ブートストラップ(bootstrap)</firstterm> とは,
        コンピュータがデバイスのプローブと初期化および,
        どのプログラムを実行させるべきであるかを判断する一連の処理のことです.
      </para>

      <para>
        これはシステムの動作を決定する特殊な ROM チップを利用して実現され,
        通常, システムの一慣性とメモリの検査, デバイスの設定,
        どのような設定がなされたかをプログラムに伝える機構の提供などをを行なう
        他のチップに処理が渡されます.
      </para>

      <para>
        通常のパーソナルコンピュータの場合,
        ブートストラップの監視をする
        BIOS と, 設定を保持する CMOS が利用されます.
        これらはディスクを扱う事ができ,
        オペレーティングシステムを起動するプログラムが,
        ディスクのどこにあるかを認識しています.
      </para>

      <para>
        この章はブートストラップの第一段階については触れず,
        ディスク上のプログラムへ制御が移された後に何が起こるのかについて注目します.
      </para>
    </sect2>

    <sect2 id="boot-overview">
      <title>ブートプロセスの概要</title>

      <para>
        FreeBSD はデフォルトで三段階のブートストラップを行ないます. 
        基本的に順に互いを呼び出す三つのプログラム(二つの
        <link linkend="boot-blocks">ブートブロック</link>と
        <link linkend="boot-loader">ローダ</link>)を必要とします.
        これらは前のプログラムを土台にしており,
        より高い洗練性を提供します.
      </para>

      <para>
        そして, 利用するデバイスの検出され,
        初期化の間にカーネルが起動されます.
        カーネルのブートプロセスが終ると,
        制御はユーザープロセスの init へ移されます.
        ディスクが利用可能であることを確かめると,
        ファイルシステムのマウント,
        ネットワークで利用するネットワークカードのセットアップ,
        そして一般的な FreeBSD
        システムで初期時に起動される,
        すべてのプロセスの起動といったユーザーレベルでのリソース設定を行ないます.
      </para>
    </sect2>

    <sect2 id="boot-blocks">
      <title>ブートブロック: ブートストラップステージ 1 と 2</title>

      <para>
        ブートブロックは(通常)ローダを見つけ,
        実行する役割を持っています.
        したがって, ファイルシステム上のプログラムを見つけ, 実行し, 
        その動作に関して多少の設定が可能である必要があります.
      </para>

      <sect3 id="boot-boot0">
	<title>boot0</title>
	
	<para>
          実際には boot0 と呼ばれるブートブロックが先行しており,
          <firstterm>マスターブートレコード(MBR; Master Boot
            Record)</firstterm>にあります. これは, 
          システムのブートストラップが起動時に探して実行するディスクの特殊な部分で,
          単にブートできる可能性のあるスライスのリストを表示します.
        </para>

	<para>
          <abbrev>MBR</abbrev>
          に置くプログラムは 512 バイト以上にできないことから
          boot0 はとても単純です.
        </para>

	<para>
          こんな感じの出力をします.
        </para>

	<example id="boot-boot0-example">
	  <title>boot0のスクリーンショット</title>
          
	  <screen>
F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</screen>
	</example>
      </sect3>

      <sect3 id="boot-boot1">
	<title>boot1</title>

	<para>
          boot1 はブートスライスのブートセクタにあります.
          ブートセクタには <link linkend="boot-boot0">boot0</link> があり,
          <abbrev>MBR</abbrev> にある他のすべてのプログラムが,
          ブートプロセスを続けるために必要なプログラムを探し,
          実行するための部分となっています.
        </para>

	<para>
          boot1 も同様に 512 バイト以上にできないことから,
          とても単純で,
          <link linkend="boot-boot2">boot2</link> を見つけ,
          実行するための情報を保持する FreeBSD の
          <firstterm>disklabel</firstterm>
          について最低限のことを認識しているに過ぎません.
        </para>
      </sect3>
    
      <sect3 id="boot-boot2">
	<title>boot2</title>

	<para>
          boot2 はもう少し精巧で,
          FreeBSDのファイルシステム上でファイルを見つけるのに十分な能力を持ち,
          カーネルかローダを指定するための簡単なインターフェイスを提供する事ができます.
        </para>

	<para>
          <link linkend="boot-loader">ローダ</link>ははるかに高機能あり,
          簡易的なブート設定の手段を提供するため,
          boot2 は通常それを起動します.
          しかし, 以前はカーネルを直接起動することを要求されていました.
        </para>

	<example id="boot-boot2-example">
	  <title>boot2のスクリーンショット</title>

	  <screen>>> FreeBSD/i386 BOOT
Default: 0:wd(0,a)/kernel
boot:</screen>
	</example>
      </sect3>
    </sect2>
 
    <sect2 id="boot-loader">
      <title>ローダ: ブートストラップステージ 3</title>

      <para>
        ローダは三段階ブートストラップの最終段階で,
        通常, ファイルシステム上に <filename>/boot/loader</filename>
        として存在します.
      </para>
	
      <note>
	<para>
          <filename>/boot/boot0</filename>,
	  <filename>/boot/boot1</filename>, 
	  <filename>/boot/boot2</filename> とがありますが,
          これらは実際に <abbrev>MBR</abbrev>,
          ブートセクタ,
          あるいはディスクラベルにあるものとは異なります.
        </para>
      </note>

      <para>
        ローダは,
        より複雑なコマンド群を持つ強力なインタープリタを使った
        簡易組み込みコマンド群を利用することで,
        ユーザフレンドリな設定の手段となるように設計されています.
      </para>

      <sect3 id="boot-loader-flow">
	<title>ローダプログラムの流れ</title>
	
	<para>
          初期化の際,
          ローダはコンソールとディスクの検出を行ない,
          どのディスクからブートしているかを調べます.
          そしてしかるべき変数を設定してからインタープリタを起動し,
          簡易コマンドを解釈します.
        </para>

	<para>
          ローダは次に
          <filename>/boot/loader.rc</filename>
          を読み込みます. デフォルトで
          <filename>/boot/defaults/loader.conf</filename>
          を読み込むことで適当な初期値を変数に与え,
          ローカルな変数値設定のために
          <filename>/boot/loader.conf</filename>
          を読み込みます.
          <filename>loader.rc</filename>
          はそれらの変数に従い適当なモジュールをロードしカーネルを選択します.
        </para>

	<para>
          最後に, デフォルトではローダは 10 秒のキー入力待ち時間を用意し,
          入力がなければカーネルを起動します.
          入力があった場合,
          ユーザには先に述べた簡易コマンドが使えるプロンプトが出されます.
          そこでユーザは変数を調整したり,
          すべてのモジュールをアンロードしたり,
          モジュールをロードしたりすることができ,
          それから最終的にブートやリブートへ移ります.
        </para>

	<para>
          この処理に関するより技術的な説明は
          &man.loader.8; にあります.
        </para>
      </sect3>

      <sect3 id="boot-loader-commands">
	<title>ローダの組み込みコマンド</title>
	
	<para>簡易コマンドセットの構成は, 次のようになっています.</para>

	<variablelist>
	  <varlistentry>
	    <term>autoboot <replaceable>seconds</replaceable></term>

	    <listitem>
	      <para>
                <replaceable>seconds</replaceable>
                で与えられた時間内に入力がなければ,
                カーネルのブートへと進みます.
                カウントダウンを表示し, デフォルトは 10 秒間です.
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>boot
	      <optional><replaceable>-options</replaceable></optional>
	      <optional><replaceable>kernelname</replaceable></optional></term>

	    <listitem>
	      <para>
                即座にカーネルのブートへと進みます.
                もし指定されていれば,
                与えられたオプションとカーネルの名前を使います.
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>help
	      <optional><replaceable>topic</replaceable></optional></term>

	    <listitem>
	      <para>
                <filename>/boot/loader.help</filename>
                から読み込まれたヘルプメセッジを表示します.
                与えられた <replaceable>topic</replaceable> が
                <literal>index</literal> ならば,
                有効な
                <replaceable>topic</replaceable>
                を表示します.
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>include <replaceable>filename</replaceable>
	      &hellip;</term>

	    <listitem>
	      <para>
                与えられたファイル名のファイルを処理します.
                ファイルは読み込まれ, 行単位で解釈されます.
                エラーは即座に include コマンドの実行を停止します.
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>load <optional><option>-t</option>
	      <replaceable>type</replaceable></optional>
	      <replaceable>filename</replaceable></term>

	    <listitem>
	      <para>
                与えられたファイル名のカーネル, カーネルモジュール, 
                あるいは指定されたtypeのファイルをロードします.
                ファイル名以降の引数はファイルへと渡されます.
              </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>ls <optional><option>-l</option></optional>
	      <optional><replaceable>path</replaceable></optional></term>

	    <listitem>
	      <para>
                与えられた <replaceable>path</replaceable> にあるファイル,
                あるいは <replaceable>path</replaceable>
                が指定されていなければルートディレクトリを表示します.
                <option>-l</option>
                が指定されていればファイルサイズも表示されます.
              </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>lsdev <optional><option>-v</option></optional></term>

	    <listitem>
	      <para>
                モジュールをロード可能なデバイスをすべて表示します.
                もし <option>-v</option> が指定されていれば,
                より詳細な出力がされます.
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>lsmod <optional><option>-v</option></optional></term>

	    <listitem>
	      <para>
                ロードされたモジュールを表示します. もし
                <option>-v</option> が指定されていれば,
                より詳細な内容が出力されます.
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>more <replaceable>filename</replaceable></term>

	    <listitem>
	      <para>
                <varname>LINES</varname>
                毎に停止しながら指定されたファイルを表示します.
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>reboot</term>

	    <listitem>
	      <para>即座にシステムをリブートします. </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>set <replaceable>variable</replaceable></term>
	    <term>set
	      <replaceable>variable</replaceable>=<replaceable>value</replaceable></term>

	    <listitem>
	      <para>ローダの環境変数を設定します. </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3 id="boot-loader-examples">
	<title>ローダの例</title>
        
	<para>
          ローダのいくつかの実践的な使用例です.
        </para>
        
	<itemizedlist>
	  <listitem>
	    <para>
              通常のカーネルをシングルユーザモードでブートします.
            </para>

	    <screen><userinput>boot -s</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>
              通常のカーネルとモジュールをアンロードし,
              古い(もしくは別の)カーネルをロードします.
            </para>

	    <screen><userinput>unload</userinput>
<userinput>load kernel.old</userinput></screen>
            
	    <para>
              インストールディスクに入っていた
              generic カーネルを参照するためには
              <filename>kernel.GENERIC</filename>,
              あるいは直前にインストールされていたカーネル(例えば,
              カーネルを自分で設定したり,
              アップグレードしたりして)を参照するには
              <filename>kernel.old</filename>
              が使えます.
            </para>
	  </listitem>

	  <listitem>
	    <para>
              カーネルの設定スクリプト(通常,
              カーネルブート時に設定される内容を自動化するスクリプト)をロードします.
	    </para>

	    <screen><userinput>load -t userconfig_script
                <replaceable>/boot/kernel.conf</replaceable></userinput></screen>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>

    <sect2 id="boot-kernel">
      <title>ブート時のカーネルとの応答</title>
      
      <para>
        カーネルは<link linkend="boot-loader">ローダ</link>(通常は)
        か<link linkend="boot-boot2">boot2</link>
        (ローダを迂回して)によってロードされるとブートフラグを調べ,
        もしあればそれに応じて動作を調整します.
      </para>

      <sect3 id="boot-kernel-bootflags">
	<title>カーネルブートフラグ</title>

	<para>良く使われるブートフラグです.</para>

	<variablelist id="boot-kernel-bootflags-list">
	  <varlistentry>
	    <term><option>-a</option></term>

	    <listitem>
	      <para>
                カーネル初期化中,
                ルートファイルシステムとしてマウントするデバイスを尋ねます.
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><option>-C</option></term>

	    <listitem>
	      <para>CDROM からブートします. </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><option>-c</option></term>

	    <listitem>
	      <para>
                ブート時のカーネルコンフィグレーションを行なう
                UserConfig を実行します.
              </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><option>-s</option></term>

	    <listitem>
	      <para>シングルユーザモードでブートします. </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><option>-v</option></term>

	    <listitem>
	      <para>カーネル起動時に, より詳細な情報を表示します.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<note>
	  <para>ブートフラグはこの他にもあり, それらについては 
            &man.boot.8;をお読みください.
          </para>
	</note>
      </sect3>

  <!--    <sect3 id="boot-kernel-userconfig">
	<title>UserConfig: ブート時のカーネルコンフィギュレータ</title>
	
	<para> </para>
      </sect3> -->
    </sect2>
  
    <sect2 id="boot-init">
      <title>Init: プロセスコントロールの初期化</title>
	  
      <para>
        カーネルがブートされると, 制御はユーザプロセスである
        <command>init</command>へ移されます. これは,
        <filename>/sbin/init</filename>, もしくは
        <command>loader</command> の
        <envar>init_path</envar> 変数で指定される場所にあります.
      </para>

      <sect3 id="boot-autoreboot">
	<title>自動リブート動作の流れ</title>
	
	<para>
          自動リブート動作では,
          システム上で利用できるファイルシステムの一慣性を確認します.
          もし問題があり,
          <command>fsck</command> がその不一致を修復できなければ,
          <command>init</command>
          は管理者に直接に処置させるため,
          システムを<link linkend="boot-singleuser">シングルユーザモード</link>へと移行させます.
        </para>
      </sect3>
      
      <sect3 id="boot-singleuser">
	<title>シングルユーザモード</title>
	
	<para>
          このモードには<link linkend="boot-autoreboot">一連の自動リブート動作</link>,
          もしくはユーザが
          <option>-s</option>
          を指定してブートするか
          <command>loader</command> で
          <envar>boot_single</envar> 変数を設定することによって移行できます.
        </para>

	<para>
          <link linkend="boot-multiuser">マルチユーザモード</link>から
          <command>shutdown</command>をリブートオプション
          (<option>-r</option>) や halt
          オプション(<option>-h</option>)なしで呼び出すことでも移行できます.
        </para>

	<para>
          <filename>/etc/ttys</filename>
          でシステムコンソール
          <literal>console</literal>
          が
          <literal>insecure</literal>
          に設定されていれば,
          システムはシングルユーザモードを始める前に
          root
          パスワードの入力を求めます.
        </para>

	<example id="boot-insecure-console">
	  <title>/etc/ttys の insecure コンソール</title>

	  <programlisting># name  getty                           type    status          comments
#
# This entry needed for asking password when init goes to single-user mode
# If you want to be asked for password, change "secure" to "insecure" here
#
# 訳)
# このエントリはinitがシングルユーザモードへ移行する際にパスワードを要
# 求させるために必要です. もし, パスワードの要求を望むならば"secure"を
# "insecure"へとここで変更してください. 
console none                            unknown off insecure</programlisting>
	</example>

	<note>
	  <para>
            <literal>insecure</literal> コンソールとは,
            コンソールが物理的に安全でないと見なされ,
            root パスワードを知る人だけがシングルユーザモードを使えるようにするという意味であり, 
            コンソールを安全でない状態で使いたいという意味ではありません. 
            よって, 安全性を求めるならば
            <literal>secure</literal> でなく
            <literal>insecure</literal> を選んでください.
          </para>
	</note>
      </sect3>
      
      <sect3 id="boot-multiuser">
	<title>マルチユーザモード</title>
	
	<para>
          <command>init</command>
          がファイルシステムが正常であると判断するか,
          ユーザが<link linkend="boot-singleuser">シングルユーザモード</link>を終了したならば,
          システムはマルチユーザモードへ移行し,
          リソースの設定を始めます.
        </para>

	<sect4 id="boot-rc">
	  <title>リソース設定(rc)</title>
          
	  <para>
            リソース設定システムはデフォルト設定を
            <filename>/etc/defaults/rc.conf</filename> から,
            システム独自の詳細を
            <filename>/etc/rc.conf</filename> から読み込み,
            <filename>/etc/fstab</filename>
            に記述されるシステムファイルシステムのマウント,
            ネットワークサービスの開始,
            さまざまなシステムデーモンの開始,
            そして最後にローカルにインストールされたパッケージの起動スクリプトの実行へと進みます.
          </para>

	  <para>
            &man.rc.8; は,
            スクリプトそのものについて調べることと同様に,
            リソース設定システムの優れた参考資料です.
          </para>
	</sect4>
      </sect3>
    </sect2>

    <sect2 id="boot-shutdown">
      <title>シャットダウン動作の流れ</title>

      <para>
        <command>shutdown</command> からのシャットダウンでは,
        <command>init</command> がスクリプト
        <filename>/etc/rc.shutdown</filename> の実行を試みます.
        そして, 全てのプロセスへ terminate シグナルを送り,
        続いてうまく終了できなかったプロセスへ
        kill シグナルを送ります.
      </para>
    </sect2>
  </sect1>
  
  <sect1 id="memoryuse">
    <title>PC におけるメモリの利用</title>

    <para><emphasis>原作: &a.joerg;.<!-- <br> -->
	16 Apr 1995.</emphasis></para>

    <para><emphasis>訳: &a.jp.tomo;. <!-- <br> -->
	29 Oct 1996.</emphasis></para>

    <para><emphasis>FreeBSD が i386
	プラットフォーム上でどのようにメモリを使うかに
	ついての説明です. </emphasis></para>

    <para>ブート部分は<literal>0:0x7c00</literal>にロードされ,
      すぐに自分自身を <literal>0x7c0:0</literal>に移します.
      (これは手品ではなく, 単なる<literal>%cs</literal>
      セレクタのための調節であり,
      <literal>ljmp</literal>により行われます. )</para>

    <para>それから最初の 15 セクタを <literal>0x10000</literal>
      (biosboot の Makefile のなかの
      <makevar>BOOTSEG</makevar>部分)にロードし, 作業領域のスタックを
      <literal>0x1fff0</literal>以下に セットします. このあと, boot2
      に飛びます. つまり, boot1 自身と (ダミーの) DOS
      パーティションテーブルを飛び越えて, %csセレクタを 調節します
      &mdash; この時点ではまだ16ビットモードです.</para>

    <para>boot2 はブートファイルを要求し,
      <filename>a.out</filename>ヘッダを調べます.
      <literal>0x00ffffff</literal>によってファイルエントリポイントを
      (通常は<literal>0xf0100000</literal>に)マスクし, ロードします.
      このため, 通常のロードポイントは 1MB
      (<literal>0x00100000</literal>) になります.  ロードしている間,
      リアルモードでBIOSを使うため, ブートコードは,
      リアルモードとプロテクトモードの間を行ったり来たりします (訳注:
      これは, BIOSがリアルモード用に書かれていて,
      ロードすべき領域がリアルモードではアクセスできない1MBより上位の
      アドレスであることから, ブートコードがリアルモードと
      プロテクトモードを切り替えながら動作するためです).</para>

    <para>ブートコード自身はプロテクトモードで
      <literal>%cs</literal>と<literal>%ds/%es</literal> 用に
      セグメントセレクタ <literal>0x18</literal> と
      <literal>0x20</literal> を使い,
      リアルモードに戻るのに<literal>0x28</literal>を使います.
      最終的にカーネルはアドレス空間全体をカバーできるようなダミーの
      ディスクリプタを参照して<literal>%cs</literal>
      <literal>0x08</literal>と <literal>%ds/%es/%ss</literal>
      <literal>0x10</literal>でスタートします.</para>

    <para>カーネルはそのロードポイントで起動されます.
      別の(高位)アドレスにリンクされるので,
      ページテーブルやページディレクトリなどが適切に設定され,
      ページングが有効になり, カーネルがリンクされたアドレスで
      動作するようになるまでは, カーネルはロードアドレスからの
      相対アドレス (PIC: position independent code) を用いて
      実行されなければなりません.</para>

    <para><emphasis>寄贈: &a.dg;.<!-- <br> -->
	16 Apr 1995.</emphasis></para>

    <para>カーネルの BSS セグメントの直後の物理ページ (実メモリ) に
      proc0 (訳注: プロセス番号 0, swapper) のページディレクトリや
      ページテーブル, Uページが配置されます.
      仮想記憶機構が初期化された少しあと,
      <literal>0x1000-0x9ffff</literal>の実メモリとカーネル  (text +
      data + bss + 上記の proc0 に関わるもの + その他)
      の後ろの実メモリは, 通常の仮想記憶ページの形で利用可能となり,
      グローバルな空きページリストに追加されます.</para>
  </sect1>

  <sect1 id="dma">
    <title>DMAとはどういったものでどういう働きをするのか</title>

    <para><emphasis>原作: &a.uhclem;<!-- <br> --><!-- <br> -->
	訳: &a.jp.yasu;<!-- <br> -->
	10 December 1996. 最終更新日 8 October 1997.</emphasis></para>

    <para>Direct Memory Access (DMA)は, 中央演算処理装置
      (CPU)からの干渉なく
      データを計算機中である場所から別の場所に動かすための手法です.
    </para>

    <para>DMA 機能の実装の方法はそれぞれの
      計算機アーキテクチャ間で異なるもので あるため,
      ここでの議論はIBMパーソナルコンピュータ(PC), PC/AT
      とその互換機における DMA
      サブシステムの実装と働きに限定します.</para>

    <para>PCの DMAサブシステムは, Intelの 8237
      DMAコントローラをベースにして います.
      8237はそれぞれ独立にプログラムできる4つのDMAチャネルを持ち,
      それぞれどのチャネルもいつでもアクティブにできます.
      これらのチャネルは順に 0, 1, 2, 3となっています.  PC/ATからは,
      セカンド 8237 チップが追加され,それらは 4, 5, 6, 7と
      なっています.</para>

    <para>オリジナルの DMAコントローラ(0, 1, 2, 3)は,
      1回の転送で1バイト 転送します. セカンドDMAコントローラ(4, 5, 6,
      7)は1回で 隣接する2つのメモリ番地から 16ビット転送します.
      ここで, 最初のバイトは通常偶数のアドレスになります.
      2つのコントローラは全く同じものであり, 転送量が異なるのは
      セカンドコントローラがシステムに直結しているためです.</para>

    <para>8237 は個々のチャネルについて,
      DRQと-DACKという2つの電気信号を 持っています. その他に, HRQ
      (Hold Request), HLDA (Hold Acknowledge),  -EOP (End of
      Process)があり, バス制御信号として -MEMR (Memory Read),  -MEMW
      (Memory Write), -IOR (I/O Read), and -IOW (I/O
      Write)があります.</para>

    <para>8237 DMACは, いわゆる&ldquo;fly-by&rdquo;
      DMAコントローラです.  これは, データの移動を行う際に, データは
      DMACチップを通過せず,  DMACチップに格納されないことを意味します.
      また, DMACはI/Oポートとメモリアドレス間でのみデータを
      転送することができますが,
      2つのI/Oポートもしくは2つのメモリアドレス
      間ではできません.</para>

    <note>
      <para>8237 は, 非 &ldquo;fly-by&rdquo;モードでは,
	互いに接続された
	2つのチャネルでのメモリ-メモリ間でのDMA操作を許可します.
	しかし, PC メーカは,
	ただでさえ乏しいこのリソースをこんなふうに 使ったりしません.
	なぜなら,
	CPUを使用してメモリ間のデータを動かす方が早いからです.</para>
    </note>

    <para>PC アーキテクチャでは, それぞれのDMAチャネルは, 通常
      与えられた DMA
      チャネルを使用するハードウェアがそのチャネルについて
      DRQ線を使って転送を要求した時のみ動作します.</para>

    <sect2>
      <title>DMA転送の例</title>

      <para>DMA転送の発生と処理の手順の例をあげてみましょう.
	この例では, フロッピーディスクコントローラ (FDC)が
	ディスケットから1バイト読み込んで,
	DMAを使って,メモリの0x00123456番地に 格納したいとします.
	処理は, FDCが, DRQ2信号(DMAチャンネル2に
	対するDRQ線)を有効にして
	DMAコントローラに要求を伝えることで開始されます.</para>

      <para>DMAコントローラは DRQ2
	シグナルが有効になったことを記録します.
	するとDMAコントローラはDMAチャネル2がプログラムされ, マスクが
	かかっていない(有効になっている)ことを確認します.  同様に,
	DMAコントローラは, 他のDMAチャネルがアクティブまたは
	アクティブになろうとしていないこと,
	そしてより高い優先度を持って いないことを確認します.
	一旦これらのチェックが完了すると, DMACはDMACがバスを使うために
	バスを開放するようにCPUに要求します.
	DMACはCPUにHRQ信号を送ってバスを要求します.</para>

      <para>CPUはHRQ信号を検出し, 現在の指示の実行を完了します.
	一旦プロセッサがバスを開放することができる状態になると, 解放を
	行います.  通常は CPU により駆動される信号 (-MEMR, -MEMW,
	-IOR, -IOW, その他)を すべてハイインピーダンス
	(ハイともローとも指定しない)状態にした後,  CPUは
	HLDA信号を有効にして DMAコントローラにバスを明け渡したことを
	伝えます.</para>

      <para>プロセッサによっては, CPUはバスを使用しないいくつかの
	命令を追加して実行することもできますが,
	しかし,プロセッサの内部キャッシュや
	パイプライン以外のメモリから
	何か読み出すといった指示に到達したら結局 CPU
	は待たなくてはなりません.</para>

      <para>ここで,DMACが バスを&ldquo;託される&rdquo;と, DMACはその
	-MEMR, -MEMW, -IOR, -IOW 出力信号をアクティブにし,
	DMACから出力されるアドレスは 0x3456にセットされます.これは
	転送しようとする特定のメモリ番地をバイトで
	指示するのに使われます.</para>

      <para>すると DMAC は DMA
	転送をリクエストしたデバイスに転送が始まることを
	知らせます.これは -DACK
	信号をアクティブにすることで行われます.
	フロッピーディスクコントローラの場合は, -DACK2を
	アクティブにすることで行われます.</para>

      <para>バスのデータ線に転送されるバイトにを出力することについては
	フロッピーディスクコントローラが責任をもつことになります.
	もし,フロッピーディスクコントローラがバス上にバイトデータを
	出力するのに余計な時間を必要としなければ
	(もし周辺装置がもっと時間を必要とする場合には, READY信号を
	経由してDMACに通知します), DMAは 1 DMAクロック待ち,
	メモリにバス上のバイトデータを格納するために -MEMW および -IOR
	信号を解除します. そして
	FDCはバイトデータが転送されたことを認識します.</para>

      <para>DMAサイクルは1度に1バイトしか転送しないので,
	FDCはDRQ2信号を止めて, DMACに転送が終了したことを知らせます.
	DMACは-DACK2信号を解除して, FDCはバス上へのデータ出力を
	停止しなくてはならないことを知らせます.</para>

      <para>次にDMACは他のDMAチャネルのいずれかに要求がきていないか
	チェックを行います.
	もしどのチャネルのDRQも有効になっていなければ,
	DMAコントローラは処理を完了して, -MEMR, -MEMW, -IOR, -IOW
	および アドレス信号をハイインピーダンス状態にします.</para>

      <para>最後に, DMAはHRQ信号を解除します.
	CPUはこれを見ると,HOLDA信号を 解除します. そしてCPUは自らの
	-MEMR, -MEMW, -IOR, -IOW 信号および アドレス線を有効にし,
	命令の実行やメインメモリや周辺機器へのアクセスを
	再開します.</para>

      <para>典型的なフロッピーディスクの1セクタについては,
	上記のプロセスが それぞれのバイトについて1回行われ,
	全部で512回繰り返されます. 1 バイト転送される毎に, DMAC
	内のアドレスレジスタはインクリメントされ, 同じくDMAC内にある,
	何バイト転送すればよいかを示すカウンタが
	デクリメントされます.</para>

      <para>カウンタが0になると, DMAはEOP信号を送ります. この信号は
	カウンタが0であり, DMAコントローラがCPUによって再び
	プログラムされるまで, これ以上データは転送されないことを
	示すものです.</para>

      <para>このイベントはターミナルカウント(TC)とも呼ばれます.
	EOP信号は1本しかありません. そして, 一度にアクティブにできる
	DMAチャネルは一本だけなので,
	現在アクティブであるDMAチャネルこそが,
	たった今処理を終了したDMAチャネルだと言うことができます.</para>

      <para>もし,
	バッファの転送が完了した時に周辺機器から割り込みを発生させたい
	とき, 周辺機器は
	-DACKn信号およびEOP信号の両方が同時に発信されたか
	どうかをテストします. その場合, DMACはCPUの介在がなければ
	これ以上はその周辺機器についての情報を転送しません.  その後で,
	周辺機器はプロセッサに割り込みを生じさせるために,
	何らかの割り込み信号を発生させることができます.
	PCアーキテクチャ においては,
	DMAチップ自身が割り込みを生じさせることはできません.
	周辺機器とそれに関連するハードウェアが割り込みを生成する責任を
	持ちます. また, DMAを使用する周辺機器が割り込みを使用しない
	可能性もあります.</para>

      <para>DMAC が要求を出したときには CPU は常にバスを DMAC
	に開放しますが,  この動作は, DMAC
	がアクティブになった時にプロセッサが命令を実行するのに
	かかる時間がわずかに変化することを除いては, アプリケーション,
	オペレーティングシステムの両方からはわからないということを
	理解することが重要です.  そのため,
	プロセッサが確かにDMA転送が完了したことを知るためには,
	周辺装置や DMA
	チップ中のレジスタを調べたり,周辺装置からの割り込みを
	受け取る必要があります.</para>
    </sect2>

    <sect2>
      <title>DMA ページレジスタ および 16メガ アドレス空間制限</title>

      <para>これまで述べたのとは異なり, DMACはアドレス線を 0x0123456
	にセットする 代わりに 0x3456
	だけをセットすることにあなたは気づいたかも しれません.
	この理由について少し説明します.</para>

      <para>オリジナルのIBM PCがデザインされた時, IBMは,
	DMACと割込み制御チップの 両方を, 8085(8ビットプロセッサで,
	16ビットのアドレス空間(64k)を持つ)と
	組み合わせて使うように設計されたチップを使うことを選びました.
	IBM PCが64k以上のメモリをサポートしていたため,
	DMACが64kを越えるメモリ番地に読み込み又は書き込みを行うために
	変更を行う必要が生じました.
	この問題を解決するためにIBMが行ったのは,
	それぞれのDMAチャネルに,
	読み込み元または書き込み先のアドレスの
	上位ビットを保持するための 外部的なラッチを追加することでした.
	DMAチャネルがアクティブな時はいつでも,
	このラッチの内容はアドレスバスに書かれて,
	そのチャネルのDMA操作が 終了するまでそこに保持されます. IBM
	はこれらのラッチを &ldquo;ページレジスタ&rdquo;
	と呼んでいます.</para>

      <para>そのため上記に示した例では,
	DMACはアドレスの0x3456の部分をバス上に 置き,
	DMAチャネル2に対するページレジスタは, 0x0012xxxxをバス上に
	置きます.
	これらの2つの値が組み合わされてアクセスされるメモリ中の完全な
	アドレスを形成します.</para>

      <para>ページレジスタのラッチはDMAチップとは独立であるので,
	読み込まれる又は書き込まれるメモリ領域は, 64kの物理的境界を
	またいではなりません. 例えば, もし
	DMACがメモリの0xffff番地をアクセスした場合, データの転送後,
	DMACはアドレスレジスタをインクリメントし,
	0x0000番地にある次のバイトを アクセスします.
	0x10000番地ではありません.
	これはおそらく意図されたものとは異なっているでしょう.</para>

      <note>
	<para>&ldquo;物理的な&rdquo; 64Kの境界を 8086モードの
	  64k&ldquo;セグメント&rdquo;と混同してはいけません.
	  セグメントは, セグメント
	  レジスタに数学的にオフセットレジスタを
	  加算して作られるものです.
	  ページレジスタにはアドレスのオーバーラップも無く, 数学的に
	  OR を取られることもありません.</para>
      </note>

      <para>さらに複雑なことには, PC/ATでは外部のDMAアドレスのラッチは
	8ビットしか保持しません. よって8+16で24ビットになり, これは
	DMAが0から16メガの間のメモリ番地しか指し示せないことを
	意味します.
	16メガ以上のメモリを持ったより新しいマシンにおいても,
	標準的なPCコンパチブルなDMAでは16メガ以上のメモリ番地には
	アクセスできません.</para>

      <para>この制限を避けるために, オペレーティングシステムは 16
	メガ以下にある物理的な 64k の境界をまたがない領域に RAM
	バッファを 予約します. そして,
	DMACはデータを周辺機器からそのバッファに
	転送するようにプログラムされます. 一旦DMACがこのバッファに
	データを動かすと, オペレーティングシステムは本当にデータを
	格納したいアドレスにバッファからデータをコピーします.</para>

      <para>16メガを越えるアドレスからDMAベースの周辺機器にデータを
	書き込む際には, データは16メガ以下に位置したバッファから最初に
	コピーされなくてはならず, その後,
	DMACはバッファからハードウェアに
	データをコピーすることができます. FreeBSDでは,
	これらの予約バッファは
	&ldquo;バウンスバッファ&rdquo;と呼ばれます. MS-DOSの世界では,
	これらは&ldquo;スマートバッファ&rdquo;などと呼ばれます.</para>

      <note>
	<para>82374と呼ばれる8237の新しい実装においては,
	  ページレジスタを16ビットで指定して,
	  バウンスバッファを使用しなくても, 32
	  ビットのアドレス空間全体にアクセスすることが可能です.</para>
      </note>
    </sect2>

    <sect2>
      <title>DMA操作モードとその設定</title>

      <para>8237 DMA はいくつかのモードで動作します. 主なモードは,
	以下のとおりです.</para>

      <variablelist>
	<varlistentry><term>シングル転送モード</term>
	  <listitem>
	    <para>シングルバイト(もしくはワード)が転送されます.
	      DMAは1バイト毎にバスを開放し,
	      再び要求しなくてはなくてはなりません. これは一般に,
	      すぐにはデータのブロック全てを転送できないデバイスに
	      よって使用されます.
	      周辺装置は次の転送の準備ができる毎にDMAを要求します.
	    </para>

	    <para>標準的な PC
	      コンパチブルなフロッピーディスクコントローラ(NEC 765)は
	      1バイトのバッファしか持たないので,
	      このモードを使用します.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term>ブロック/デマンド転送モード</term>
	  <listitem>
	    <para>一旦 DMAC がシステムバスを取得すると,
	      最大64kまでのデータブロック 全体が転送されます.
	      もし周辺装置が余分に時間を必要とするときは,
	      転送を一時中断するためにREADY信号を有効にします.
	      READY信号は過度に使われるべきではなく,
	      遅い周辺装置の転送の場合は
	      シングル転送モードを代わりに使うべきです.</para>

	    <para>ブロック転送モードとデマンド転送モードの違いは,
	      一旦ブロック転送が 始まると, 転送カウンタか 0
	      になるまでそれが行われるところです. DRQ は -DACK
	      が有効になるまでの間は有効でなければなりません.
	      デマンドモードは DRQ が有効な間転送が続けられます.
	      DRQが有効でなくなった場合, DMA はその時点で転送を中断し,
	      バスを解放して CPU に返します.
	      その後, DRQが有効になると,
	      転送は中断したところから再開されます.</para>

	    <para>データの転送,
	      特に転送に使われるメモリ番地が16Mを越える場合に, CPU
	      を使った方が効率がよくなるまで CPU
	      の速度が向上する以前の
	      古いハードディスクコントローラはデマンドモードを
	      使っていました.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term>カスケード転送モード</term>
	  <listitem>
	    <para>このメカニズムは DMA
	      チャネルがバスを要求することを許可する ものですが,
	      接続されたデバイスはバス上のアドレス情報の配置に
	      ついてDMACに代わって責任を持ちます.
	      これは&ldquo;バスマスタ&rdquo;
	      と呼ばれる技術の実装に利用されます.</para>

	    <para>カスケードモードの DMA
	      チャネルがバスのコントロールを受け取ると, DMA
	      は通常行われるようなバス上のアドレスと I/O
	      コントロール信号の 出力を行いません. 代わりに,
	      DMAはアクティブなチャネルの -DACK信号を
	      有効にします.</para>

	    <para>この時点で, アドレスとバスコントロール信号の供給は
	      DMAチャネルに接続された周辺機器が担当します.
	      周辺機器はシステムバスの完全なコントロールを行い, 16
	      メガ以下の任意のアドレスの読み込みおよび書き込みを
	      行うことが できます. 周辺機器はバスの使用を終えると DRQ
	      線を無効にするので, DMA コントローラは CPU
	      もしくは他のDMAチャネルに制御を返すことが
	      できます.</para>

	    <para>カスケードモードは複数の DMA
	      コントローラを相互接続するのに 使われます.
	      PC内ではDMAチャネル4がまさにこの用途に使われています.
	      周辺機器がDMAチャネル0, 1, 2, 3でバスを要求すると,
	      スレーブDMAコントローラは HLDREQ を有効にしますが,
	      この線はCPUではなく,
	      実際にはプライマリDMAコントローラのDRQ4に
	      接続されています.  その後,
	      チャンネル4になにか仕事があるものと見なしたプライマリの
	      DMAコントローラは HLDREQ を使ってCPUにバスを 要求します.
	      バスが与えられると, -DACK4が有効になりますが,
	      この線は実際にはスレーブDMAコントローラの HLDA信号に
	      接続されています.
	      スレーブDMAコントローラはその後要求したDMAチャネル  (0,
	      1, 2, 3) に対してデータを転送するか,
	      SCSIコントローラのような
	      バスマスタリングを要求する周辺機器にバスを許可します.
	    </para>

	    <para>このような配線がおこなわれているため,
	      PC/ATシステムの 周辺機器ではDMAチャネルは 0, 1, 2, 3, 5,
	      6, 7のみが使用できます.</para>

	    <note>
	      <para>初期のIBM PCコンピュータでは, DMAチャネル0は操作の
		リフレッシュのために予約されていますが,
		最近のシステムでは通常,
		周辺機器によって使用することができます.</para>
	    </note>

	    <para>周辺機器がバスマスタリングを行っている時は,
	      システムバスを保持している間絶えずメモリに
	      もしくはメモリから データを転送することが重要です.もし,
	      周辺機器がこのように できないときは,
	      システムがメインメモリのリフレッシュを
	      行なえるようにしばしばバスを開放しなくては
	      なりません.</para>

	    <para>全ての PC でメインメモリとして使われるダイナミック
	      RAM は, 中身が &ldquo;満たされている&rdquo;
	      ビットを保持するため
	      頻繁にアクセスされなくてはなりません. ダイナミック RAM
	      は, それぞれが 1 ビットのデータを記憶するコンデンサが
	      たくさん集まって構成されています.
	      これらのコンデンサは充電された 状態で
	      <literal>1</literal>, 充電されていない状態で
	      <literal>0</literal> を表します.
	      全てのコンデンサは放電するため, <literal>1</literal>
	      の値を保持するために,
	      一定の間隔で電力を加える必要があります. 実際に RAM
	      チップは RAM の適切な場所に電力を送る作業を行ないますが,
	      メモリのリフレッシュ作業が RAM を普通にアクセスする時と
	      衝突しないように, それをいつ行なうかを
	      コンピュータが休止状態の時に知らせなくてはなりません.
	      もしコンピュータがメモリのリフレッシュを
	      行なえない場合は,
	      メモリの中身はわずか数ミリ秒で壊れてしまいます.</para>

	    <para>メモリの読み込みと書き込みのサイクルは
	      リフレッシュサイクルとして カウントされる(ダイナミック
	      RAM のリフレッシュサイクルは
	      実際には不完全なメモリ読み込みサイクルになります)ので,
	      周辺機器のコントローラが連続するメモリ番地から
	      データの読み込み または書き込みを行う間は,
	      メモリの全てがリフレッシュされます.</para>

	    <para>バスマスタリングはいくつかの SCSI
	      ホストインターフェースやその他の
	      ハイパフォーマンスな周辺機器コントローラに
	      見られます.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term>自動初期化転送モード</term>
	  <listitem>
	    <para>このモードにおいてDMAはバイト, ブロック,
	      デマンド転送を行いますが,  DMA転送カウンタが0になると,
	      カウンタとアドレスはDMAチャネルが
	      もともとプログラムされた時のものに戻されます.  これは,
	      周辺機器が転送を要求している間は転送が続けられることを
	      意味します.
	      転送領域としてDMACにプログラムされた固定バッファの中で,
	      出力操作でDMACがデータを読み出す前もって新しいデータを
	      書き込んだり入力操作でDMACが書き込んだあとに,
	      そこから新しいデータを読み出す作業は CPU
	      が受け持ちます.</para>

	    <para>このテクニックは, &ldquo;サンプリング&rdquo;
	      用のバッファが小さいもしくは
	      それを持たないオーディオデバイスによく使われます.
	      この&ldquo;環状&rdquo; バッファの管理は更なる CPU
	      オーバーヘッドになりますが,  DMAカウンタが0になり,
	      再プログラムされるまでDMAが停止してしまう
	      ことによって起きる遅延は,
	      この方法でしかなくす事ができない 場合もあります.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>DMAのプログラミング</title>

      <para>プログラムされるDMAチャネルは, 通常, 設定を行う前に
	&ldquo;マスクする&rdquo;べきです.
	これはハードウェアが予期せずそのチャンネルに対してDRQを有効に
	した場合, たとえ全てのパラメータが
	満たされてない場合や更新されていない場合でも, DMACは
	それに応答してしまう可能性があるからです.</para>

      <para>マスクを行ってから,ホストは転送の方向(メモリからI/O,
	もしくはI/Oからメモリ)と, 転送に使用するDMA操作のモード
	(シングル, ブロック, デマンド, カスケードなど)を設定し, 最後に
	アドレスや転送の長さを設定します.
	設定される長さはDMACに転送させたい量よりも1少なくなります.
	アドレスや転送長のLSBとMSBは同じ8ビットI/O
	ポートに書き込まれます. そのためDMACが最初のバイトをLSBとして,
	2番目のバイトをMSBとして 受け取ることを保証するために,
	最初に別のポートに書き込みを行なって LSBとMSB
	の判別を行なうフリップフロップをクリアしておく必要があります.
      </para>

      <para>そして,DMAのページレジスタを更新します.
	これはDMACの外部にあり I/O
	ポートの別のセットを通してアクセスされます.</para>

      <para>すべての設定ができると,
	DMAチャネルはマスクを解除することができます.
	そのDMAチャネルは&ldquo;準備ができた&rdquo;とみなされ,
	そのチャンネルのDRQが 有効になると応答します.</para>

      <para>8237のプログラミングの正確な詳細については,
	ハードウェアデータブックを参照してください. PCシステムにおける
	I/O マップについても参照する必要があるでしょう. このマップには
	DMA およびページレジスタのポートがどこに位置するのかを
	書いてあります.
	以下に完全なポートのマップテーブルを示します.</para>
    </sect2>

    <sect2>
      <title>DMAポートのマップ</title>

      <para>IBM-PCとPC/ATに基づくすべてのシステムでは,
	同じI/Oポートに配置された DMAハードウェアを持っています.
	その完全なリストを以下に示します.
	DMAコントローラ2に割り当てられたポートは, AT以外のデザインでは
	未定義になっています.</para>

      <sect3>
	<title>0x00 &ndash; 0x1f DMA コントローラ #1 (Channels 0, 1, 2
	  and 3)</title>

	<para>DMA アドレス および カウントレジスタ</para>

	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x00</entry>
		<entry>write</entry>
		<entry>Channel 0 starting address</entry>
	      </row>

	      <row>
		<entry>0x00</entry>
		<entry>read</entry>
		<entry>Channel 0 current address</entry>
	      </row>

	      <row>
		<entry>0x01</entry>
		<entry>write</entry>
		<entry>Channel 0 starting word count</entry>
	      </row>

	      <row>
		<entry>0x01</entry>
		<entry>read</entry>
		<entry>Channel 0 remaining word count</entry>
	      </row>

	      <row>
		<entry>0x02</entry>
		<entry>write</entry>
		<entry>Channel 1 starting address</entry>
	      </row>

	      <row>
		<entry>0x02</entry>
		<entry>read</entry>
		<entry>Channel 1 current address</entry>
	      </row>

	      <row>
		<entry>0x03</entry>
		<entry>write</entry>
		<entry>Channel 1 starting word count</entry>
	      </row>

	      <row>
		<entry>0x03</entry>
		<entry>read</entry>
		<entry>Channel 1 remaining word count</entry>
	      </row>

	      <row>
		<entry>0x04</entry>
		<entry>write</entry>
		<entry>Channel 2 starting address</entry>
	      </row>

	      <row>
		<entry>0x04</entry>
		<entry>read</entry>
		<entry>Channel 2 current address</entry>
	      </row>

	      <row>
		<entry>0x05</entry>
		<entry>write</entry>
		<entry>Channel 2 starting word count</entry>
	      </row>

	      <row>
		<entry>0x05</entry>
		<entry>read</entry>
		<entry>Channel 2 remaining word count</entry>
	      </row>

	      <row>
		<entry>0x06</entry>
		<entry>write</entry>
		<entry>Channel 3 starting address</entry>
	      </row>

	      <row>
		<entry>0x06</entry>
		<entry>read</entry>
		<entry>Channel 3 current address</entry>
	      </row>

	      <row>
		<entry>0x07</entry>
		<entry>write</entry>
		<entry>Channel 3 starting word count</entry>
	      </row>

	      <row>
		<entry>0x07</entry>
		<entry>read</entry>
		<entry>Channel 3 remaining word count</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>DMA コマンドレジスタ</para>

	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x08</entry>
		<entry>write</entry>
		<entry>Command Register</entry>
	      </row>

	      <row>
		<entry>0x08</entry>
		<entry>read</entry>
		<entry>Status Register</entry>
	      </row>

	      <row>
		<entry>0x09</entry>
		<entry>write</entry>
		<entry>Request Register</entry>
	      </row>

	      <row>
		<entry>0x09</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0x0a</entry>
		<entry>write</entry>
		<entry>Single Mask Register Bit</entry>
	      </row>

	      <row>
		<entry>0x0a</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0x0b</entry>
		<entry>write</entry>
		<entry>Mode Register</entry>
	      </row>

	      <row>
		<entry>0x0b</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0x0c</entry>
		<entry>write</entry>
		<entry>Clear LSB/MSB Flip-Flop</entry>
	      </row>

	      <row>
		<entry>0x0c</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0x0d</entry>
		<entry>write</entry>
		<entry>Master Clear/Reset</entry>
	      </row>

	      <row>
		<entry>0x0d</entry>
		<entry>read</entry>
		<entry>Temporary Register
		  (新しいバージョンでは利用不可)</entry>
	      </row>

	      <row>
		<entry>0x0e</entry>
		<entry>write</entry>
		<entry>Clear Mask Register</entry>
	      </row>

	      <row>
		<entry>0x0e</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0x0f</entry>
		<entry>write</entry>
		<entry>Write All Mask Register Bits</entry>
	      </row>

	      <row>
		<entry>0x0f</entry>
		<entry>read</entry>
		<entry>Read All Mask Register Bits (Intel
		  82374にのみ存在する)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>0xc0 &ndash; 0xdf DMA コントローラ #2 (Channels 4, 5, 6
	  and 7)</title>

	<para>DMA アドレス および カウントレジスタ</para>

	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0xc0</entry>
		<entry>write</entry>
		<entry>Channel 4 starting address</entry>
	      </row>

	      <row>
		<entry>0xc0</entry>
		<entry>read</entry>
		<entry>Channel 4 current address</entry>
	      </row>

	      <row>
		<entry>0xc2</entry>
		<entry>write</entry>
		<entry>Channel 4 starting word count</entry>
	      </row>

	      <row>
		<entry>0xc2</entry>
		<entry>read</entry>
		<entry>Channel 4 remaining word count</entry>
	      </row>

	      <row>
		<entry>0xc4</entry>
		<entry>write</entry>
		<entry>Channel 5 starting address</entry>
	      </row>

	      <row>
		<entry>0xc4</entry>
		<entry>read</entry>
		<entry>Channel 5 current address</entry>
	      </row>

	      <row>
		<entry>0xc6</entry>
		<entry>write</entry>
		<entry>Channel 5 starting word count</entry>
	      </row>

	      <row>
		<entry>0xc6</entry>
		<entry>read</entry>
		<entry>Channel 5 remaining word count</entry>
	      </row>

	      <row>
		<entry>0xc8</entry>
		<entry>write</entry>
		<entry>Channel 6 starting address</entry>
	      </row>

	      <row>
		<entry>0xc8</entry>
		<entry>read</entry>
		<entry>Channel 6 current address</entry>
	      </row>

	      <row>
		<entry>0xca</entry>
		<entry>write</entry>
		<entry>Channel 6 starting word count</entry>
	      </row>

	      <row>
		<entry>0xca</entry>
		<entry>read</entry>
		<entry>Channel 6 remaining word count</entry>
	      </row>

	      <row>
		<entry>0xcc</entry>
		<entry>write</entry>
		<entry>Channel 7 starting address</entry>
	      </row>

	      <row>
		<entry>0xcc</entry>
		<entry>read</entry>
		<entry>Channel 7 current address</entry>
	      </row>

	      <row>
		<entry>0xce</entry>
		<entry>write</entry>
		<entry>Channel 7 starting word count</entry>
	      </row>

	      <row>
		<entry>0xce</entry>
		<entry>read</entry>
		<entry>Channel 7 remaining word count</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>DMA コマンドレジスタ</para>

	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0xd0</entry>
		<entry>write</entry>
		<entry>Command Register</entry>
	      </row>

	      <row>
		<entry>0xd0</entry>
		<entry>read</entry>
		<entry>Status Register</entry>
	      </row>

	      <row>
		<entry>0xd2</entry>
		<entry>write</entry>
		<entry>Request Register</entry>
	      </row>

	      <row>
		<entry>0xd2</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0xd4</entry>
		<entry>write</entry>
		<entry>Single Mask Register Bit</entry>
	      </row>

	      <row>
		<entry>0xd4</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0xd6</entry>
		<entry>write</entry>
		<entry>Mode Register</entry>
	      </row>

	      <row>
		<entry>0xd6</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0xd8</entry>
		<entry>write</entry>
		<entry>Clear LSB/MSB Flip-Flop</entry>
	      </row>

	      <row>
		<entry>0xd8</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0xda</entry>
		<entry>write</entry>
		<entry>Master Clear/Reset</entry>
	      </row>

	      <row>
		<entry>0xda</entry>
		<entry>read</entry>
		<entry>Temporary Register (Intel 82374には存在しない)</entry>
	      </row>

	      <row>
		<entry>0xdc</entry>
		<entry>write</entry>
		<entry>Clear Mask Register</entry>
	      </row>

	      <row>
		<entry>0xdc</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0xde</entry>
		<entry>write</entry>
		<entry>Write All Mask Register Bits</entry>
	      </row>

	      <row>
		<entry>0xdf</entry>
		<entry>read</entry>
		<entry>Read All Mask Register Bits (Intel
		  82374にのみ存在する)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>0x80 &ndash; 0x9f DMA ページレジスタ</title>

	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x87</entry>
		<entry>r/w</entry>
		<entry>Channel 0 Low byte (23-16) page Register</entry>
	      </row>

	      <row>
		<entry>0x83</entry>
		<entry>r/w</entry>
		<entry>Channel 1 Low byte (23-16) page Register</entry>
	      </row>

	      <row>
		<entry>0x81</entry>
		<entry>r/w</entry>
		<entry>Channel 2 Low byte (23-16) page Register</entry>
	      </row>

	      <row>
		<entry>0x82</entry>
		<entry>r/w</entry>
		<entry>Channel 3 Low byte (23-16) page Register</entry>
	      </row>

	      <row>
		<entry>0x8b</entry>
		<entry>r/w</entry>
		<entry>Channel 5 Low byte (23-16) page Register</entry>
	      </row>

	      <row>
		<entry>0x89</entry>
		<entry>r/w</entry>
		<entry>Channel 6 Low byte (23-16) page Register</entry>
	      </row>

	      <row>
		<entry>0x8a</entry>
		<entry>r/w</entry>
		<entry>Channel 7 Low byte (23-16) page Register</entry>
	      </row>

	      <row>
		<entry>0x8f</entry>
		<entry>r/w</entry>
		<entry>Low byte page Refresh</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>0x400 &ndash; 0x4ff 82374 Enhanced DMA Registers</title>

	<para>Intel 82374 EISA System Component
	  (ESC)は1996年の初めに発表されました. この中
	  には機能的には8237のスーパーセットであり,
	  1つのパッケージの中にその他の PC
	  互換機のコアとなる周辺コンポーネントをも含んだ DMA
	  コントローラも含まれています. このチップはEISAとPCI
	  両方のプラットホームをターゲットにしたものであり,
	  scatter-gather I/O やリングバッファを始めとして,
	  システムDMAをして32ビットの
	  アドレス空間全体に直接アクセスする能力も提供しています.
	</para>

	<para>これらの機能を使用する場合でも,
	  過去16年間のPC互換機で利用されてきた
	  同等機能を提供するコードも含めておく必要があります.
	  互換性の問題から, 82374の レジスタの一部は,
	  従来の8237のレジスタをプログラムした <emphasis>後</emphasis>
	  に,  転送の度にプログラムされる必要があります.
	  8237のレジスタに書き込みを行うとき,
	  ソフトウェアの下位互換性のために,
	  82374で追加された一部のレジスタの内容が
	  強制的に0にクリアされるからです.</para>

	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x401</entry>
		<entry>r/w</entry>
		<entry>Channel 0 High byte (bits 23-16) word count</entry>
	      </row>

	      <row>
		<entry>0x403</entry>
		<entry>r/w</entry>
		<entry>Channel 1 High byte (bits 23-16) word count</entry>
	      </row>

	      <row>
		<entry>0x405</entry>
		<entry>r/w</entry>
		<entry>Channel 2 High byte (bits 23-16) word count</entry>
	      </row>

	      <row>
		<entry>0x407</entry>
		<entry>r/w</entry>
		<entry>Channel 3 High byte (bits 23-16) word count</entry>
	      </row>

	      <row>
		<entry>0x4c6</entry>
		<entry>r/w</entry>
		<entry>Channel 5 High byte (bits 23-16) word count</entry>
	      </row>

	      <row>
		<entry>0x4ca</entry>
		<entry>r/w</entry>
		<entry>Channel 6 High byte (bits 23-16) word count</entry>
	      </row>

	      <row>
		<entry>0x4ce</entry>
		<entry>r/w</entry>
		<entry>Channel 7 High byte (bits 23-16) word count</entry>
	      </row>

	      <row>
		<entry>0x487</entry>
		<entry>r/w</entry>
		<entry>Channel 0 High byte (bits 31-24) page
		  Register</entry>
	      </row>

	      <row>
		<entry>0x483</entry>
		<entry>r/w</entry>
		<entry>Channel 1 High byte (bits 31-24) page
		  Register</entry>
	      </row>

	      <row>
		<entry>0x481</entry>
		<entry>r/w</entry>
		<entry>Channel 2 High byte (bits 31-24) page
		  Register</entry>
	      </row>

	      <row>
		<entry>0x482</entry>
		<entry>r/w</entry>
		<entry>Channel 3 High byte (bits 31-24) page
		  Register</entry>
	      </row>

	      <row>
		<entry>0x48b</entry>
		<entry>r/w</entry>
		<entry>Channel 5 High byte (bits 31-24) page
		  Register</entry>
	      </row>

	      <row>
		<entry>0x489</entry>
		<entry>r/w</entry>
		<entry>Channel 6 High byte (bits 31-24) page
		  Register</entry>
	      </row>

	      <row>
		<entry>0x48a</entry>
		<entry>r/w</entry>
		<entry>Channel 6 High byte (bits 31-24) page
		  Register</entry>
	      </row>

	      <row>
		<entry>0x48f</entry>
		<entry>r/w</entry>
		<entry>High byte page Refresh</entry>
	      </row>

	      <row>
		<entry>0x4e0</entry>
		<entry>r/w</entry>
		<entry>Channel 0 Stop Register (bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4e1</entry>
		<entry>r/w</entry>
		<entry>Channel 0 Stop Register (bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4e2</entry>
		<entry>r/w</entry>
		<entry>Channel 0 Stop Register (bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4e4</entry>
		<entry>r/w</entry>
		<entry>Channel 1 Stop Register (bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4e5</entry>
		<entry>r/w</entry>
		<entry>Channel 1 Stop Register (bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4e6</entry>
		<entry>r/w</entry>
		<entry>Channel 1 Stop Register (bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4e8</entry>
		<entry>r/w</entry>
		<entry>Channel 2 Stop Register (bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4e9</entry>
		<entry>r/w</entry>
		<entry>Channel 2 Stop Register (bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4ea</entry>
		<entry>r/w</entry>
		<entry>Channel 2 Stop Register (bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4ec</entry>
		<entry>r/w</entry>
		<entry>Channel 3 Stop Register (bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4ed</entry>
		<entry>r/w</entry>
		<entry>Channel 3 Stop Register (bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4ee</entry>
		<entry>r/w</entry>
		<entry>Channel 3 Stop Register (bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4f4</entry>
		<entry>r/w</entry>
		<entry>Channel 5 Stop Register (bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4f5</entry>
		<entry>r/w</entry>
		<entry>Channel 5 Stop Register (bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4f6</entry>
		<entry>r/w</entry>
		<entry>Channel 5 Stop Register (bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4f8</entry>
		<entry>r/w</entry>
		<entry>Channel 6 Stop Register (bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4f9</entry>
		<entry>r/w</entry>
		<entry>Channel 6 Stop Register (bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4fa</entry>
		<entry>r/w</entry>
		<entry>Channel 6 Stop Register (bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4fc</entry>
		<entry>r/w</entry>
		<entry>Channel 7 Stop Register (bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4fd</entry>
		<entry>r/w</entry>
		<entry>Channel 7 Stop Register (bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4fe</entry>
		<entry>r/w</entry>
		<entry>Channel 7 Stop Register (bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x40a</entry>
		<entry>write</entry>
		<entry>Channels 0-3 Chaining Mode Register</entry>
	      </row>

	      <row>
		<entry>0x40a</entry>
		<entry>read</entry>
		<entry>Channel Interrupt Status Register</entry>
	      </row>

	      <row>
		<entry>0x4d4</entry>
		<entry>write</entry>
		<entry>Channels 4-7 Chaining Mode Register</entry>
	      </row>

	      <row>
		<entry>0x4d4</entry>
		<entry>read</entry>
		<entry>Chaining Mode Status</entry>
	      </row>

	      <row>
		<entry>0x40c</entry>
		<entry>read</entry>
		<entry>Chain Buffer Expiration Control Register</entry>
	      </row>

	      <row>
		<entry>0x410</entry>
		<entry>write</entry>
		<entry>Channel 0 Scatter-Gather Command Register</entry>
	      </row>

	      <row>
		<entry>0x411</entry>
		<entry>write</entry>
		<entry>Channel 1 Scatter-Gather Command Register</entry>
	      </row>

	      <row>
		<entry>0x412</entry>
		<entry>write</entry>
		<entry>Channel 2 Scatter-Gather Command Register</entry>
	      </row>

	      <row>
		<entry>0x413</entry>
		<entry>write</entry>
		<entry>Channel 3 Scatter-Gather Command Register</entry>
	      </row>

	      <row>
		<entry>0x415</entry>
		<entry>write</entry>
		<entry>Channel 5 Scatter-Gather Command Register</entry>
	      </row>

	      <row>
		<entry>0x416</entry>
		<entry>write</entry>
		<entry>Channel 6 Scatter-Gather Command Register</entry>
	      </row>

	      <row>
		<entry>0x417</entry>
		<entry>write</entry>
		<entry>Channel 7 Scatter-Gather Command Register</entry>
	      </row>

	      <row>
		<entry>0x418</entry>
		<entry>read</entry>
		<entry>Channel 0 Scatter-Gather Status Register</entry>
	      </row>

	      <row>
		<entry>0x419</entry>
		<entry>read</entry>
		<entry>Channel 1 Scatter-Gather Status Register</entry>
	      </row>

	      <row>
		<entry>0x41a</entry>
		<entry>read</entry>
		<entry>Channel 2 Scatter-Gather Status Register</entry>
	      </row>

	      <row>
		<entry>0x41b</entry>
		<entry>read</entry>
		<entry>Channel 3 Scatter-Gather Status Register</entry>
	      </row>

	      <row>
		<entry>0x41d</entry>
		<entry>read</entry>
		<entry>Channel 5 Scatter-Gather Status Register</entry>
	      </row>

	      <row>
		<entry>0x41e</entry>
		<entry>read</entry>
		<entry>Channel 5 Scatter-Gather Status Register</entry>
	      </row>

	      <row>
		<entry>0x41f</entry>
		<entry>read</entry>
		<entry>Channel 7 Scatter-Gather Status Register</entry>
	      </row>

	      <row>
		<entry>0x420-0x423</entry>
		<entry>r/w</entry>
		<entry>Channel 0 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x424-0x427</entry>
		<entry>r/w</entry>
		<entry>Channel 1 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x428-0x42b</entry>
		<entry>r/w</entry>
		<entry>Channel 2 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x42c-0x42f</entry>
		<entry>r/w</entry>
		<entry>Channel 3 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x434-0x437</entry>
		<entry>r/w</entry>
		<entry>Channel 5 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x438-0x43b</entry>
		<entry>r/w</entry>
		<entry>Channel 6 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x43c-0x43f</entry>
		<entry>r/w</entry>
		<entry>Channel 7 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="internals-vm">
    <title>FreeBSD VM システム</title>

    <para><emphasis>原作: &a.dillon;.  6 Feb 1999</emphasis></para>

    <sect2>
      <title>物理メモリ管理 &mdash; <literal>vm_page_t</literal></title>

      <para>物理メモリはページ単位に,
	<literal>vm_page_t</literal>構造体を用いて管理されます.
	物理メモリのページは, ページキューの一つに存在する,
	それぞれの <literal>vm_page_t</literal>
	構造体の配置によって分類されます.</para>

      <para>ページは, wired(ワイヤード), active(活性状態),
	inactive(非活性状態), cache(キャッシュ状態),
	free(使われていない状態)の 各状態をとります. wired
	状態を除いて, ページは通常
	その状態を示す二重連結リストのキューに置かれます.  wired
	状態のページがキューに置かれることはありません.</para>

      <para>FreeBSD は, ページカラーリング(page
	coloring)を実装するため, cache 状態, free
	状態にあるページ用に,
	さらに複雑なページキューを実装しています. その各々の状態は,
	プロセッサの L1, L2 キャッシュサイズに応じて最適化された
	多重キューを利用します.  FreeBSD は,
	新たなページを確保(allocate)することが
	必要になった場合に確保される VM オブジェクトのために,  L1, L2
	キャッシュに対して合理的にアライン(align)されたページを
	得ようと試みます.</para>

      <para>加えて, ページは参照カウントとともに保持され,
	ビジーカウントとともにロックされます.  VM システムは,
	ページフラグとして PG_BUSY を使う &ldquo;完全ロック状態&rdquo;
	も実装しています.
      </para>

      <para>一般的には, 各々のページキューは最長不使用 (LRU)
	方式で動作します.  ページは普通, 最初に wired, もしくは active
	状態に置かれます.  wired 状態の場合,
	そのページはどこかにあるページテーブルに 関連づけられています.
	VM システムはアクティブなキュー内のページをスキャンし,  wired
	状態のページにエイジング (訳注:
	ページ参照頻度を量る手法の一つ; aging) を施します. そして,
	そのページはあまりアクティブでないキューへ
	移動することになります.  cache キューに移動させられたページは,
	再利用の候補になっている VM
	オブジェクトに割り付けられています.  free
	キューにあるページは, 完全に自由の状態にあります.  FreeBSD は,
	free キューにあるページ数を最小限にとどめようと 試みますが,
	割り込み発生時のページ確保を融通するため,
	完全に自由なページをいくつか持っていなければなりません.
      </para>

      <para>プロセスがページテーブルに存在しない,
	ページキューの一つ(例えば, inactive, cache キュー等)に
	存在するページをアクセスしようとしたとき,
	比較的負荷の小さなページ再活性化フォールトが起こります.
	システムメモリに全く存在していないページの場合は,
	ディスクからページを読み出す間,
	そのプロセスはブロック(block)されます.</para>

      <para>FreeBSD は, ページキューを動的に調節し,
	同期済(clean)のページ, 同期していない(dirty)ページの分類を
	合理的に保つのと同様に, それぞれのキューにあるページが合理的な
	比率に保つように試みます.  再バランス化処理が起こる量は,
	システムのメモリ負荷に依存します.  この再バランス化処理は
	ページアウトデーモンによって実装されていて,
	(補助記憶とページを同期して)同期していないページの
	クリーニングすることや, (LRU
	キュー内でのページ位置を再配置したり,
	ページをキューの間を移動することで)ページが頻繁に
	参照状態にあることに注目すること, キューを均等にするための
	キュー間ページ移動等を伴います.
	ページが実際にどれだけ使われているかを決定するために,  FreeBSD
	の VM システムは, ページの再活性化フォールトを 自発的に,
	合理的な数だけ発生します.  これは,
	ページをスワップアウトしたり, クリーニングする時期を
	より良く決めることに繋がります.</para>
    </sect2>

    <sect2>
      <title>統合バッファキャッシュ &mdash;
	<literal>vm_object_t</literal></title>

      <para>FreeBSD は, 一般化した &ldquo;VM オブジェクト&rdquo;
	という考え方を実装しています. VM オブジェクトは,
	様々な種類の補助記憶(backing store) &mdash; 補助記憶なし,
	スワップ, 物理デバイス, ファイル, に割り付けられます.
	ファイルシステムは
	ファイルと関連するインコアデータを管理するのに,  同じ VM
	オブジェクトを利用するため,
	統合バッファキャッシュと呼ばれます.</para>

      <para>VM オブジェクトは, <emphasis>シャドウ化</emphasis>
	することができます.  シャドウ化とは,
	オブジェクトがそれぞれ互いの上に
	スタック(stack)されるということです. 例えば, MAP_PRIVATE
	mmap() の 動作を実装するために,  ファイルに割り付けられた VM
	オブジェクトの上にスタックされた,  スワップに割り付けられた VM
	オブジェクトが存在しているでしょう.  このスタッキングは, fork
	されたアドレス空間のための 様々な共有属性,
	コピーオンライト(訳注: ページ共有のための 手法の一つ;
	cow,copy-on-write) を実装するのにも利用されています.</para>

      <para><literal>vm_page_t</literal> は, 同時に一つの VM
	オブジェクトしか割り付けられることが
	できないことに注意しなければなりません.  VM
	オブジェクトのシャドウ化は, 複数のインスタンスが同じページに
	共有できるように実装されています.</para>
    </sect2>

    <sect2>
      <title>ファイルシステム I/O &mdash; <literal>struct
	  buf</literal>
      </title>

      <para>補助記憶にファイルを使う VM オブジェクトのように,  v
	ノードを使う VM オブジェクトは通常,
	処理されているかどうかという情報を,
	VMシステムが管理する処理情報から独立して
	管理される必要があります.  例えば, VM
	システムが物理ページと補助記憶を同期させようとしたとき,  VM
	システムは, 実際に書き戻す前に,
	ページがクリーニング済であるという
	マークを付ける必要があるわけです.  さらに, ファイルシステムは,
	KVM 内で操作できるように,  ファイルや,
	ファイルメタデータの一部分を KVM にマッピングすることが
	できなくてはなりません.</para>

      <para>これを管理するために使われる実体は,
	ファイルシステムバッファ,  <literal>struct buf</literal>,
	<literal>bp</literal> として知られています.
	ファイルシステムに VM オブジェクトの一部を操作することが
	必要となるときは通常, オブジェクトの部分が struct buf に
	マッピングされ, KVM に struct buf
	内のページがマッピングされます.  同じ方法で, ディスク I/O
	はオブジェクトの部分を バッファ構造体内にマッピングし,
	その時バッファ構造体上の I/O を 発行することで発行されます.
	基礎となっている vm_page_t は, I/O 処理の間
	ビジー(busy)状態になります. ファイルシステムにも
	独立したビジー状態があり, それはハードウェア上の VM
	ページの代わりに ファイルシステムバッファで動作する
	ファイルシステムドライバのコードに とって有用です.</para>

      <para>FreeBSD は, マッピングを保持するためにある量に制限された
	KVM を 予約していますが, KVM
	がマッピングを保持するためだけに使われ,
	キャッシュデータの能力を制限しないということは
	明確にされるべきでしょう.
	物理データキャッシュを行うことは厳密に
	<literal>vm_page_t</literal> の機能になっており,
	ファイルシステムバッファの機能ではありません.  しかし,
	ファイルシステムバッファは placehold I/O に使われるため,
	それは実質的に同時処理可能な I/O 処理量を制限します.
	通常は二, 三千のファイルバッファが利用可能ですから,
	このことは問題にならないでしょう.</para>
    </sect2>

    <sect2>
      <title>マッピングページテーブル &mdash;
	<literal>vm_map_t</literal>,
	<literal>vm_entry_t</literal></title>
      <!-- kuriyama - Eng should use literal and mdash -->

      <para>FreeBSD は, 物理ページテーブルの形態を VM
	システムと分離しています.
	ハードウェア上にある全てのプロセス毎のページテーブルは,
	その場その場で再構成され, 通常, 使い捨てだとみなされています.
	KVM を管理するような特殊なページテーブルは,
	最初に永続的な確保が 行われ,
	これらのページテーブルが破棄されることはありません.
      </para>

      <para>FreeBSD は, vm_objects の部分を,
	仮想メモリのアドレス範囲に <literal>vm_map_t</literal> と
	<literal>vm_entry_t</literal> 構造体を通して割り付けます.
	ページテーブルは, <literal>vm_map_t</literal>
	/<literal>vm_entry_t</literal>/<literal>vm_object_t</literal>
	という階層から 直接つくられます. &ldquo;物理ページは,
	直接一つの <literal>vm_object</literal> に
	割り付けられる&rdquo; と私が述べたことを思い出して下さい.
	ええと, そうですね, しかしそれはいつでも完全に当てはまる,
	というわけでもないのです.  <literal>vm_page_t</literal> のは,
	実際に割り付けられた ページテーブルにもリンクされています.
	一つの <literal>vm_page_t</literal> は
	ページテーブルが呼ばれた時, いくつかの
	<emphasis>pmaps</emphasis> と リンクされることがあります.
	しかし, そのような階層的な割り付けは,  同じ
	<literal>vm_page_t</literal> を参照するオブジェクト内の,
	同じページへの参照全てを保持しているため,  その結果,
	常にバッファキャッシュの統合を得ることができるわけです.
      </para>
    </sect2>

    <sect2>
      <title>KVM メモリマッピング</title>

      <para>FreeBSD は, 様々なカーネル構造体を保持するため, KVM
	を利用します.  ファイルシステムバッファキャッシュは, KVM
	内で最も大きなものです.  それはつまり, <literal>struct
	  buf</literal> の実体に対するマッピングに他なりません.</para>

      <para>Linux と異なり, FreeBSD は全ての物理メモリを KVM
	にマッピングしません.  これは, FreeBSD が 32
	ビットプラットフォームで 4G バイトまでの メモリを扱える,
	ということを意味します.  実際, MMU
	がそれを可能にしているならば,  理論上, FreeBSD は 32
	ビットプラットフォームで 8TB
	までのメモリを扱うことができることになります.  しかし,
	大部分の 32 ビットプラットフォームは 4G バイトの RAM しか
	マッピングできないようになっている,
	ということには議論の余地があるでしょう.
      </para>
      <!-- kuriyama - This translate is difficult to understand -->

      <para>KVM は, いくつかのメカニズムによって管理されています.
	中心となっているのは, <emphasis>ゾーンアロケータ(zone
	  allocator)</emphasis>です.  ゾーンアロケータは,
	特定の構造体型を確保するために KVM の部分(chunk)を得て,
	一定の大きさのメモリブロックに分割します.  <command>vmstat
	  -m</command> コマンドで, ゾーンによって 分割された, 現在の
	KVM 利用状況一覧を得ることができます.
      </para>
    </sect2>

    <sect2>
      <title>FreeBSD VM システムのチューニング</title>

      <para>FreeBSD カーネルでは,
	動的に自分自身をチューニングするために,
	協調的な努力が行なわれています.  普通は,
	<literal>maxusers</literal> と <literal>NMBCLUSTERS</literal>
	という カーネルオプション, つまり,
	<filename>/usr/src/sys/i386/conf/<replaceable>CONFIG_FILE</replaceable></filename> で 指定されるもの以外, 変更する必要はありません. 可能なカーネルオプションの一覧は, <filename>/usr/src/sys/i386/conf/LINT</filename> に 記載されています.</para>

      <para>大きなシステムに対しては, <literal>maxusers</literal>
	を増やしたいと思うかも知れませんね.  この値は普通, 10 から 128
	の間の値にします.
	<literal>maxusers</literal> を増やしすぎるとシステムの利用可能な
	KVM がオーバフローしてしまい,
	予測できない動作に陥ってしまうことに注意して下さい.
	<literal>maxusers</literal> はある適度な値にとどめておいて,
	特定のリソースを制御する <literal>NMBCLUSTERS</literal>
	のような, 他のオプションを増加させる方が良いでしょう.
      </para>

      <para>もし, システムが負荷の高いネットワーク用途に使われるなら,
	<literal>NMBCLUSTERS</literal> を増やしたいと望むことでしょう.
	この値は普通, 1024 から 4096 の間です.
      </para>

      <para><literal>NBUF</literal> パラメータも,
	伝統的にシステムの規模を決めるのに使われます.  これは,
	システムがファイルシステムバッファを I/O のために
	マッピングするのに使われる, KVA
	の大きさを決めるのに使われます. 	 このパラメータは,
	統合バッファキャッシュには何の影響も与えません.  これは
	3.0-RELEASE 以降のカーネルでは動的にチューニングされるため,
	普通は手作業で調整されるべきものではありません.
	<literal>NBUF</literal> パラメータは,
	指定しようとしないことを推奨します.
	システムに選択させれば良いのです.
	小さすぎる値は極端に非効率的なファイルシステム動作を招き,
	一方で, 大きすぎる値は wired 状態のページを数多くつくりだし,
	ページキューを枯渇させてしまうでしょう.</para>

      <para>デフォルトでは, FreeBSD カーネルは最適化されていません.
	カーネルコンフィグにある <literal>makeoption</literal>
	ディレクティブを使って
	最適化とデバッグフラグをセットすることができます.  ただし,
	それによって得られる大きな (7MB
	超の)カーネルを相手にするのが嫌なら,  <option>-g</option>
	オプションは使ってはいけません.</para>

      <programlisting>makeoptions    DEBUG="-g"
makeoptions     COPTFLAGS="-O2 -pipe"</programlisting>

      <para>sysctl は, 実行時にカーネルパラメータをチューニングする
	手段を提供しています.  しかし, 普通は sysctl 変数, 特に VM
	に関連したものを変更する必要が
	生じるようなことはありません.</para>

	<para>実行時の VM とシステムのチューニングは, 比較的単純です.
	まず, 可能ならば UFS/FFS ファイルシステムで softupdates
	を使いましょう.
	<filename>/usr/src/contrib/sys/softupdates/README</filename>
	のファイルに,
	設定方法に関する手順(と制限)について書かれています.
      </para>

      <para>次に, 十分なスワップを設定します. &ldquo;作業&rdquo;
	ディスクを含む 各物理ディスク装置毎に一つずつ
	(最大四つまで)のスワップパーティションを 設定すべきです.
	少なくとも, メインメモリの 2 倍の スワップ空間が望ましく,
	メモリがあまりない場合には,
	おそらくそれより多く必要になります.  また,
	スワップパーティションのサイズは,
	後でパーティションをつくり直しする必要がないように
	マシンに設定したいメモリ設定の最大値を基準に
	決めるべきでしょう. 	 もし, クラッシュダンプをとりたい場合,
	スワップパーティションは最低限メインメモリと同じの大きさで,
	<filename>/var/crash</filename> にはダンプを保持するのに十分な
	空きがなければなければなりません.</para>

      <para>NFS 経由のスワップは, -4.x
	以降のシステムで完全に動作しますが,  NFS サーバ側では,
	ページングがその負荷の主な原因になることに
	注意しなければなりません.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
