<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: 1.47
     $FreeBSD$
-->

<chapter id="security">
  <title>セキュリティ</title>

  <para><emphasis>この章の多くの部分は&a.dillon;によって書かれた
    &man.security.7; マニュアルページからの引用です.</emphasis></para>

  <para><emphasis>訳: &a.jp.hino;, (jpman プロジェクトの成果を利用させ
    ていただきました).</emphasis></para>

  <sect1>
    <title>この章では</title>

    <para>この章では, 基本的なシステムセキュリティの考え方,
      覚えておくべき一般的なルールを紹介し,
      そして S/Key, OpenSSL, Kerberos
      などの高度な話題について簡単に説明します.</para>
  </sect1>

  <sect1 id="security-intro">
    <title>はじめに</title>

    <para>セキュリティとは, システム管理者をいつも悩ませる仕事の一つです.
      すべての BSD UNIX マルチユーザシステムは,
      従来からいくつかのセキュリティ機構を備えていますが,
      ユーザを疑心暗鬼に陥らせないように追加のセキュリティ機構を構築し
      保守する仕事はおそらく, システム管理者としてもっとも大きな責務の一つでしょう.
      マシンの安全性に反映されるのは, 管理者が作業したことだけです.
      またセキュリティ問題は, 快適な環境に必要なものと競合します.
      一般に UNIX システムは膨大な数のプロセスを同時に動作させることができ,
      そのプロセスの大部分は, サーバ &ndash;
      外部から接続し, 通信するものとして動作します.
      かつてのミニコンとメインフレームがデスクトップにとってかわり,
      さらにコンピュータが相互に接続されたネットワークを形成するようになった今日,
      セキュリティは非常に大きな関心事になってきています.</para>

    <para>セキュリティを実装するには,
      タマネギのように階層化する手法
      (a layered <quote>onion</quote> approach)
      が最適です.
      どうすれば良いのか簡単に説明すると,
      便利な機能と同じ数だけセキュリティの階層を作り,
      システムへの侵入を注意深く監視するのです.
      あなたはセキュリティを過度に厳重にしたり,
      侵入の監視に時間をとられたいとは思わないでしょう.
      この侵入の発見という部分は,
      あらゆるセキュリティ機構において最も重要な部分の一つなのです.
      たとえば, システムの各バイナリに schg フラグ<!-- (&man.chflags.1; 参照) -->
      を設定するのは, 大して意味がありません.
      フラグを設定すると一時的にバイナリが保護され,
      侵入してきたクラッカーによってシステムに加えられる変更のうち,
      容易に検出可能な変更は行なえなくなります.
      しかしその結果として, セキュリティ機構がその侵入者を検出することも
      まったくできなくなってしまうでしょう.</para>

    <para>また, システムセキュリティには,
      さまざまな形での攻撃に対処することとも関係しています.
      この攻撃には root 権限を奪おうとするものだけでなく,
      クラッシュやシステムの不安定状態を引き起こそうとするものを含まれます.
      このセキュリティ問題は, いくつかに分類することが可能です.</para>
    
    <orderedlist>
      <listitem>
	<para>サービス妨害攻撃 (denial of service attack)</para>
      </listitem>

      <listitem>
	<para>ユーザアカウントの不正利用 (user account compromise)</para>
      </listitem>

      <listitem>
	<para>アクセス可能なサーバを使った root 権限の不正利用</para>
      </listitem>

      <listitem>
	<para>ユーザアカウントを経由した root 権限の不正使用</para>
      </listitem>

      <listitem>
	<para>バックドアの設置</para>
      </listitem>
    </orderedlist>

    <para>サービス妨害攻撃 (DoS 攻撃) とは,
      マシンから必要な資源を奪う行為です.
      通常, サービス妨害攻撃はそのマシンで実行されるサーバや
      ネットワークスタックを過負荷状態にしてマシンをクラッシュさせたり,
      マシンを使えなくしたりするような力任せの方法です.
      サービス妨害攻撃の中には,
      ネットワークスタックのバグを利用して,
      パケット一つでマシンをクラッシュさせようとするものもあります.
      後者には, カーネルにバグ修正を施すことによってのみ対応することができます.
      サーバプロセスに対する攻撃は, オプションを適切に指定することによって,
      攻撃されている状況でサーバプロセスの負荷上昇に限界を設定することで
      対応できる場合が多いです. これらに比べると, 
      ネットワークへの力任せの攻撃への対応はずっと難しくなります. 
      たとえば, 偽造パケットによる攻撃 (spoof-packet attack) は,
      インターネットからシステムを切り離す以外の方法で
      防ぐことはほとんど不可能です.
      この攻撃によって, マシンを落としてしまうことはできないかもしれませんが,
      接続しているインターネット回線を混雑させていっぱいにしてしまうことはできます.</para>

    <para>ユーザアカウントの不正利用は, サービス妨害攻撃
      よりもずっとよくある問題です. このご時勢でも, 自分たちのマシンで
      標準の telnetd, rlogind, rshd, ftpd サーバを実行させているシステ
      ム管理者は多いのです. これらのサーバは, デフォルトでは, 暗号化さ
      れたコネクション上で動作していません. その結果, 抱えているユーザ
      数が標準くらいであれば, リモートログイン (そのシステムにログイン
      するには最も普通で便利な方法です) しているユーザのうち一人以上は, 
      パスワードを覗き見られてしまうでしょう. システム管理者が注意深い
      人ならば, たとえログインが成功していたとしても, リモートアクセス
      ログを解析して, 疑わしい送信元アドレスを探すものです.</para>

    <para>ひとたび攻撃者がユーザアカウントへのアクセス権を入手すると, 
      攻撃者が root の権限を破る可能性があることを仮定するべきです. し
      かし, セキュリティを十分維持し, 手入れの行き届いたシステムにおい
      ては, あるユーザアカウントへのアクセスが可能となっても, 攻撃者に
      必ずしも root へのアクセス権を与えるとは限りません. こ
      の違いは重要です. というのは, 一般的に root へのアクセス権がなければ,
      攻撃者は自分の侵入の痕跡を隠蔽することができませんし, そ
      のユーザのファイルを引っかき回したり, マシンをクラッシュさせたり
      できるのがせいぜいです. ユーザアカウントの不正利用は
      めずらしいことではありません. それは一般ユーザに, システム管
      理者ほど注意を払わない傾向があるからです.</para>

    <!-- 2001/04/04:hrs mistranslation? -->
    <para>システム管理者は「あるマシン上で root の権限を破る方法は, 潜
      在的に何通りもあるのだ」ということを心しておかねばなりません. 攻撃
      者が root のパスワードを知ってしまうかもしれませんし, 攻撃者が 
      root の権限で実行されるサーバのバグを見つけ, ネットワークからそ
      のサーバへ接続して root の権限を破ることができるかもしれません. 
      ひとたびユーザアカウントを破ると, ユーザアカウントから root の権
      限を破ることを可能にするような suid-root プログラムに存在するバグを
      攻撃者は知っているかもしれません. あるマシン上で攻撃者
      が root の権限を破る方法を知ったとすると, 攻撃者は, 裏口を作る必
      要はありません. これまでに発見され, ふさがれた root の
      穴の多くには, クラッカーが侵入した跡を消そうとしてたくさん仕事し
      た結果が含まれています. そのためにこそ, 多くのクラッカーは裏口を
      作るのです. 攻撃者は裏口を使ってシステムへの root アクセスを再び
      簡単に得ることができます. しかしこの裏口は, クラッカーの検出をす
      るのに便利なものでもあります. クラッカーに裏口を作らせないように
      するということは, セキュリティにとっては実際には良くないことかも
      しれません. なぜなら, そうすることで, クラッカーが最初に侵入して
      くるために発見したセキュリティホールがふさがるわけではないからで
      す.</para>

    <para>セキュリティを改善する方法は, 常に, タマネギの皮
      のように階層化する手法 (a multi-layered <quote>onion peel</quote> approach) で実装されるべきです. これら
      は次のように分類できます.</para>

    <orderedlist>
      <listitem>
	<para>root とスタッフのアカウントの安全性を高める.</para>
      </listitem>

      <listitem>
	<para>root の安全性を高める &ndash; root 権限で動作するサーバ
	と suid/sgid バイナリ.</para>
      </listitem>

      <listitem>
	<para>ユーザアカウントの安全性を高める.</para>
      </listitem>

      <listitem>
	<para>パスワードファイルの安全性を高める.</para>
      </listitem>

      <listitem>
	<para>カーネルのコア, raw デバイス, ファイルシステムの安全性を
	高める.</para>
      </listitem>

      <listitem>
	<para>システムに対して行なわれた, 不適切な変更をすばやく検出す
	る.</para>
      </listitem>

      <listitem>
	<para>必要と思われる以上の対応をとる (paranoia).</para>
      </listitem>
    </orderedlist>

    <para>本章の次の節では, 上記の各項目についてより深く掘り下げていき
      ます.</para>
  </sect1>

  <sect1 id="securing-freebsd">
    <title>FreeBSDの安全性を高める</title>

    <para>以下の節では, 本章の<link linkend="security-intro">前節
      </link>でとりあげた FreeBSD システムの安全性を高める方法について
      述べます.</para>

    <sect2 id="securing-root-and-staff">
      <title>root アカウントとスタッフアカウントの安全性を高める</title>

      <para>root のアカウントの安全性を確保しないうちからスタッフのア
        カウントの安全性をうんぬんしてもしかたがありません. ほとんどの
        システムでは, root アカウントに割り当てたパスワードが 1 つあり
        ます. まず最初にすべきことは, このパスワードは<emphasis>いつで
        も</emphasis>不正利用の危険に晒されていると仮定することです. これは
        root のパスワードを消すべきだと言っているのではありません.
        root のパスワードは, マシンにコンソールからアクセスするのには, 
        ほとんどいつでも必要なものです. ここで言いたいのは, コンソール
        以外からは, そして可能なら &man.su.1; コマンドを実行する場合も
        root のパスワードを使えないようにするべきである, ということで
        す. たとえば, あなたが使っている pty が,
        <filename>/etc/ttys</filename> ファイルで unsecure と指定
        されているか確認してください. そうすると,
        <command>telnet</command> や <command>rlogin</command> 経由では 
        root で直接ログインできないようになります.
        <application>sshd</application> のような, 別のログインサービス
        を使っている場合でも同様に, 直接 root へログインすることを許し
        ていないかどうか確認してください. すべてのアクセス手段 &ndash; 
        たとえば ftp のようなサービスが, 良くクラックの対象となることを
        考えましょう. root への直接ログインは, シス
        テムコンソール経由でのみ可能であるべきなのです.</para>

      <para>また当然, システム管理者として自分が root になれるようにしておく必要が
        ありますから, そのための穴をいくつか開けておきます. し
        かし, それらの穴を動作させるには, さらに追加のパスワード認証が
        必要であるようにしておくことが重要です. root でアクセス可能と
        する方法の一つとして, 適切なスタッフアカウントを
        (<filename>/etc/group</filename> 中の)
        <literal>wheel</literal> グループに加えることがありま
        す. <literal>wheel</literal> グループに入っているスタッフメン
        バは <literal>su</literal> を使って root になることが許されま
        す. パスワードエントリにおいて, スタッフメンバを 
        <literal>wheel</literal> グループに置くことによって直接 wheel 
        権限を与えてはいけません. スタッフメンバのアカウントは 
        <literal>staff</literal> グループに所属させるべきで, そして 
        <filename>/etc/group</filename> ファイルを通して 
        <literal>wheel</literal> グループに加えるべきです. 実際に root 
        アクセスの必要なスタッフメンバのみ <literal>wheel</literal> グ
        ループに置くようにすべきです. 他の認証方法の場合, たとえば 
        kerberos を使用する場合には, root アカウントの 
        <filename>.k5login</filename> ファイルを使って, 誰も 
        <literal>wheel</literal> グループに置く必要なく &man.ksu.1; を
        使って root になることを許すようにすることもできます. このやり
        方はよりよい解決策なのかもしれません. なぜなら,
        <literal>wheel</literal> のメカニズムでは, 侵入者がパスワード
        ファイルを手に入れ, スタッフアカウントのいずれか 1 つを破るこ
        とができると, root を破ることがまだできてしまうからです.
        <literal>wheel</literal> のメカニズムを用いる方が, 何もしない
        よりは良いのですが, 必ずしも最も安全な選択肢とは限りません.
        </para>

      <para>root アカウントの安全性を高める間接的な方法として, 別のロ
        グインアクセスの方法を用いてスタッフのアカウントの安全性を高め, 
        その上でそのスタッフのアカウントの暗号化パスワードを 
        <literal>*</literal> にしておく方法があります. この方法だと, 
        侵入者がパスワードファイルを盗むことができた場合でも, スタッフ
        アカウントを破ることはできなくなります (また, たとえ root が暗
        号化パスワードをパスワードファイルに付けていたとしても, 間接的
        に root アカウントを破ることはできません). スタッフメン
        バがスタッフアカウントでログインする際には, &man.kerberos.1; 
        や &man.ssh.1; のような, 公開鍵 / 秘密鍵の鍵の組を使う安全性の
        高いログイン機構を使います. kerberos のようなログイン機構を使う
        場合は一般に, kerberos サーバを実行するマシンと自分のデスクトッ
        プワークステーションとの安全性を確保しなければなりません.
        また <application>ssh</application> で公開鍵 / 秘密鍵の組を使う場合, 
        一般に, <emphasis>ログイン元</emphasis>マシン (通常は自分のワー
        クステーション) の安全性を確保しなければなりません. ここで,
        <&man.ssh-keygen.1; で公開鍵 / 秘密鍵の組を生成する際, 鍵の組
        をパスワードで防御することにより, 鍵の組への防御層を追加するこ
        ともできます. スタッフアカウントのパスワードを 
        <literal>*</literal> でつぶすことができると, 管理者自身が設定
        した安全性の高い方法でしかスタッフメンバがログインできないこと
        も保証できます. こうして, 多くの侵入者が使う重大なセキュリティ
        の穴, すなわち, 安全性の低い無関係なマシンからネットワークを覗
        き見る方法, を塞ぐようなセッションを提供する, 安全性の高い暗号
        化されたコネクションを使うことを, スタッフメンバ全員に強制する
        ことができるのです.</para>

      <para>より間接的なセキュリティの仕組みでは, 制限の強いサーバから
        制限の弱いサーバへログインすることを前提としています. たとえば, 
        メインマシンで, 様々な種類のサーバを実行させている場合, ワーク
        ステーションではそれらのサーバを実行させてはなりません. ワーク
        ステーションを十分に安全にしておくためには, 実行するサーバの数
        を, 一つもサーバが実行されていないというくらいにまでできる限り
        減らすべきです. また, パスワードで保護されたスクリーンセーバを
        走らせておくべきです. ワークステーションへの物理的アクセスが与
        えられたとすると, もちろん言うまでもなく, 攻撃者は管理者が設定
        したいかなる種類のセキュリティをもうち破ることができるのです. 
        このことは, 管理者として必ず考えておかねばならない問題ですが, 
        システム破りの大多数は, ネットワーク経由でリモートから, ワーク
        ステーションやサーバへの物理的アクセス手段を持たない人々によっ
        て行われるという事実もまた, 念頭に置いておく必要があります.
        </para>

      <para>kerberos のような方法を使うことで, スタッフアカウントのパ
        スワードの変更もしくは停止を一箇所で行なうことと, スタッフメン
        バがアカウントを持つすべてのマシンに即時にその効果を及ぼすこと
        が可能となります. スタッフメンバのアカウントが危険に晒されたと
        きに, すべてのマシンでスタッフメンバのパスワードを即座に変更す
        る能力を過小評価してはいけません. パスワードが分散されている状
        況では, N 台のマシンでパスワードを変更すると, てんやわんやの事
        態を招く可能性があります. kerberos を使用すると, パスワードの
        再発行に制限 (re-passwording restriction) を課することもできま
        す. この機能を使うことにより, ある kerberos チケットをしばらく
        経つとタイムアウトにすることができるだけでなく, 一定期間 ( 例
        えば, 1 ヶ月に 1 回) 経つと, ユーザに新しいパスワードを選ぶよ
        うに要求することもできます.</para>
    </sect2>

    <sect2>
      <title>root 権限で実行されているサーバと SUID/SGID バイナリの安全性を高める</title>

      <para>用心深いシステム管理者は, 自分に必要なサーバプロセスだけを
        過不足なく実行させるものです. サードパーティ製のサーバは, よくバグを持っ
        ていがちだということに注意して下さい. たとえば, 古いバージョンの 
        imapd や popper を実行させておくのは, 全世界に万能の root の切
        符を与えているようなものです. 自分で注意深くチェックしていない
        サーバは, 決して実行してはいけません. root で実行させる必要の
        あるサーバはほとんどありません. たとえば,
        <application>ntalk</application>,
        <application>comsat</application>,
        <application>finger</application> デーモンを, 専用ユーザの
        <literal>砂場 (sandbox)</literal> で実行させることができます. 
        管理者が膨大な数の問題に直面していないのなら, この「砂場」は完
        璧ではありませんが, セキュリティに関するタマネギ的アプローチは
        ここでも成り立ちます. 砂場で実行されているサーバプロセスを経由
        して侵入を果たすことができたとしても, 攻撃者はさらに砂場から外
        に脱出しなければなりません. 攻撃者が通過せねばならない層の数が
        増えれば増えるほど, それだけ攻撃者が侵入に成功する確率が減りま
        す. root の抜け穴は歴史的に, 基本システムサーバも含め, root 権
        限で実行されるほとんどすべてのサーバプロセスで発見されています. 
        ユーザが <application>sshd</application> 経由でのみログインし,
        <application>telnetd</application>,
        <application>rshd</application>,
        <application>rlogind</application> 経由でログインすることが決
        してないマシンを稼働させているのであれば, それらのサービスを停
        止させて下さい!</para>

      <para>FreeBSD では, 今では <application>ntalkd</application>,
        <application>comsat</application>,
        <application>finger</application> は砂場で実行させることがデフォ
        ルトになっています. 次に砂場で実行させるべきプログラムの候補と
        して, &man.named.8; があります.
        <filename>/etc/defaults/rc.conf</filename> ファイルには,
        <application>named</application> を砂場で実行するために必要な
        引数がコメントアウトされた形式で含まれています. 新しいシステム
        をインストールしているか, それとも既存のシステムをアップグレー
        ドして使っているかに依存しますが, 砂場として使用する特別のユー
        ザアカウントがインストールされていないかもしれません. 用心深い
        システム管理者であれば, できるだけいつでも研究を怠らず, サーバ
        に砂場を仕込むものでしょう.</para>

      <para>通常, 砂場で実行しないサーバが他にいくつかあります.
        <application>sendmail</application>,
        <application>popper</application>,
        <application>imapd</application>,
        <application>ftpd</application> などです. これらのうちいくつか
        のサーバには代わりとなるものがありますが, 代わりのものをインス
        トールするには, あなたが思うより多くの仕事が必要になるかもしれ
        ません (便利さという要素がまたも勝利を収めるわけです). これら
        のサーバは, root 権限で実行せねばならいかもしれません. また, 
        これらのサーバ経由で生じる侵入を検出するためには, 他の仕組みに
        頼らなくてはならないかもしれません.</para>

      <para>システムの root 権限の潜在的な穴で他に大きなものとして, シ
        ステムにインストールされた suid-root/sgid バイナリがあります. 
        これらのバイナリは, <application>rlogin</application> のように,
        <filename>/bin</filename>, <filename>/sbin</filename>,
        <filename>/usr/bin</filename>, <filename>/usr/sbin</filename> 
        に存在するものがほとんどです. 100% 安全なものは存在しないとは
        いえ, システムデフォルトの siud/sgid バイナリは比較的安全とい
        えます. それでもなお, root の穴がこれらのバイナリにときおり発
        見されています. 1998 年に <literal>Xlib</literal> で見つかった 
        root の穴は, <application>xterm</application> (普通, suid 設定
        されています)を脆弱にしてしまいました. 安全である方がよいので, 
        用心深いシステム管理者は残念に思いながらも, スタッフのみが実行
        する必要がある suid バイナリは, スタッフのみがアクセス可能な特
        別なグループに含めるように制限を加え, 誰も使わない suid バイナ
        リは (<command>chmod 000</command> を実行して) 片付けてしまう
        でしょう. ディスプレイを持たないサーバは, 一般的に 
        <application>xterm</application> のバイナリを必要としません.
        sgid バイナリもほとんど同様の危険な存在になり得ます. 侵入者が 
        kmem に sgid されたバイナリを破ることができた場合, その侵入者
        は <filename>/dev/kmem</filename> を読み出すことができるように
        なるでしょう. つまり, 暗号化されたパスワードファイルを読み出す
        ことができるようになるので, パスワードを持つどのアカウントをも, 
        潜在的な危険に晒すことになります. 他にも,
        <literal>kmem</literal> グループを破った侵入者が pty を通して
        送られたキーストロークを監視できるという危険があります. キース
        トロークには, 安全な方法でログインするユーザが使っている pty 
        も含まれます. tty グループを破った侵入者は, ほぼ任意のユーザの 
        tty へ書き込みができます. ユーザが端末プログラムやキーボードを
        シミュレーションする機能を持ったエミュレータを使っている場合, 
        侵入者は潜在的に, 結局そのユーザとして実行されるコマンドをユー
        ザの端末にエコーさせるデータストリームを生成できる可能性があり
        ます.</para>
    </sect2>

    <sect2 id="secure-users">
      <title>ユーザアカウントの安全性を高める</title>

      <para>ユーザアカウントは, 普通, 安全性を高めることが最も困難です. 
        スタッフに対しては, とても厳格なアクセス制限を強制しパスワード
        を <literal>*</literal> で外すことができるでしょうが, 管理者が
        持ちうる一般ユーザすべてのアカウントに対して同じことはできない
        かもしれません. 管理者が十分に統率をとることができるなら, 管理
        者は勝利し, ユーザのアカウントの安全を適切に確保できるかもしれ
        ません. それができないならば, よりいっそう気を配って一般ユーザ
        のアカウントを監視するよりほかありません. 一般ユーザアカウント
        に対し <application>ssh</application> や kerberos を利用するこ
        とには, システム管理がさらに増えたりテクニカルサポートが必要に
        なるなどの問題があります. それでも, 暗号化パスワードファイルと
        比較するとはるかに良い解です.</para>
    </sect2>

    <sect2>
      <title>パスワードファイルの安全性を高める</title>

      <para>できるだけ多くのパスワードを <literal>*</literal> で外し, 
        それらのアカウントのアクセスには 
        <application>ssh</application> や kerberos を使うようにするこ
        とが, 唯一の確実な方法です. 暗号化パスワードファイル 
        (<filename>/etc/spwd.db</filename>) は root でのみ読み出し可能
        だといっても, 侵入者が root の書き込み権限は得られなくとも, 読
        み出しアクセス権限を得ることは可能かもしれません.</para>

      <para>セキュリティスクリプトで常にパスワードファイルの変更をチェッ
        クし, 報告するようにすべきです (<link
        linkend="security-integrity">ファイルの完全性のチェック</link> 
        参照).</para>
    </sect2>

    <sect2>
      <title>カーネルのコア, raw デバイス, ファイルシステムの安全性を
      高める</title>

      <para>root の権限を破ると, 攻撃者は何でもできますが, 特に重宝さ
        れる特定の事柄もいくつかあります. たとえば, 最近のカーネルは, 組
        み込みのパケット覗き見デバイス (packet sniffing device) ドライ
        バを備えているものがほとんどです. FreeBSD では 
        <devicename>bpf</devicename> デバイスと呼ばれています. 侵入者
        は普通, 侵入済みのマシンでパケット覗き見プログラムを実行させよ
        うと試みます. 侵入者にわざわざそういう機能を提供する必要はない
        ので, ほとんどのシステムで bpf デバイスを組み込むべきではあり
        ません.</para>

      <para>bpf デバイスを外しても, <filename>/dev/mem</filename> と 
        <filename>/dev/kmem</filename> という悩みの種がまだ残っていま
        す.  この問題に関しては, 侵入者は raw ディスクデバイスに書き込
        むこともできます. また, モジュールローダ, &man.kldload.8; とい
        う, 別のカーネル機能があります. やる気まんまんの侵入者は, KLD 
        モジュールを使って自分独自の bpf もしくはその他覗き見デバイス
        を動作中のカーネルにインストールすることができます. この問題を
        避けるため, システム管理者はカーネルをより高い安全レベル (
        securelevel) , 少なくとも安全レベル 1 で実行させる必要がありま
        す. <command>sysctl</command> を使って 
        <literal>kern.securelevel</literal> 変数に安全レベルを設定する
        ことができます. ひとたび安全レベルに 1 を設定すると, raw デバ
        イスに対する書き込みアクセスは拒否され, たとえば 
        <literal>schg</literal> のような特別な chflags フラグの機能が
        強制されます. システム起動に関わる重要なバイナリやディレクトリ, 
        スクリプトファイルなど, 安全レベルが設定されるまでの間に実行さ
        れるすべてのものに対しても <literal>schg</literal> フラグを on 
        にしておくことも確実に実行してください. この設定をやり過ぎても
        構いませんが, より高い安全レベルで動作している場合, システムの
        アップグレードがはるかに困難になります. システムをより高い安全
        レベルで実行させるようにするが, すべてのシステムファイルとディ
        レクトリに <literal>schg</literal> フラグを設定しないという妥
        協をする方法もあります. もう一つの可能性としては, 単純に 
        <filename>/</filename> および <filename>/usr</filename> を読み
        込み専用でマウントすることです. ここで特筆すべきことは, システ
        ムを守ろうとして厳しくしすぎると, 侵入を検出するという非常に重
        要なことができなくなってしまうということです.</para>
    </sect2>

    <sect2 id="security-integrity">
      <title>ファイルの完全性のチェック: バイナリ, 設定ファイルなど
      </title>

      <para>ことこの問題に至ると, システム管理者にできることは, 便利さ
        という要素がその醜い頭を上げない程度に, コアシステムの設定と制
        御ファイルを防御することだけです. たとえば,
        <filename>/</filename> および <filename>/usr</filename> にある
        大部分のファイルに <literal>schg</literal> ビットを設定するた
        めに <command>chflags</command> を使用するのは, おそらく逆効果
        でしょう. なぜなら, そうすることでファイルは保護できますが, 侵
        入を検出する窓を閉ざしてしまうことにもなるからです. セキュリティ
        のタマネギの最後の層はおそらく最も重要なもの &ndash; 検出で
        す. セキュリティの残りのものは, 突然の侵入を検出できなければ, 
        まったく有用ではありません (あるいは, もっと悪ければ, 安全性に
        対する間違った感覚を植え付けてしまいます). タマネギの仕事の半
        分は, もう半分の検出側が攻撃者を攻撃の最中に捕えるようにするた
        めに, 攻撃者を食い止めるのではなく侵入を遅らせることなのです.
        </para>

      <para>侵入を検出する最も良い方法は, 変更されていたり, 消えていた
        り, 入れた覚えがないのに入っているファイルを探すことです. 変更
        されたファイルを探すのに最も良い方法は, もう一つの (しばしば中
        央に集められた), アクセスが制限されたシステムから行なうもので
        す. さらに安全でアクセス制限されたシステム上でセキュリティ用ス
        クリプトを書けば, スクリプトは潜在的なクラッカー達からはほぼ見
        えなくなります. これは重要なことです. この有効性を最大限に活用
        するためには, 一般的に, アクセスの制限されたマシンから実際に使っ
        ている他のマシンへのかなりのアクセスを許す必要があります.  普
        通は, 他のマシンからアクセス制限されたマシンへ読み込み専用の 
        NFS エクスポートをしたり, アクセス制限されたマシンから他のマシ
        ンへ <application>ssh</application> を行なうために,
        <application>ssh</application> 鍵のペアを作ったりすることで行
        います. ネットワークのトラフィックを別にして, NFS は最も可視性
        のない方法です &ndash; 各クライアント上のファイルシステムを, 
        事実上検出されずに監視できるようになります. アクセス制限された
        サーバがスイッチを通してクライアントに接続されている場合, たい
        てい NFS がより良い選択肢です. アクセス制限されたサーバがハブ
        を通したり, いくつかのルーティング層を通したりしてクライアント
        に接続する場合, NFS はあまりにも危険な方法かもしれず (ネットワー
        クの面で) , <application>ssh</application> の方が認証の道筋は
        跡となって残りますが, それでもより良い方法かもしれません.
        </para>

      <para>アクセス制限されたマシンに, 監視しようとするクライアントシ
        ステムへの少なくとも読み込みのアクセス権を与えたら, 次に実際に
        監視するためのスクリプトを書かなくてはいけません. NFS マウント
        をすれば, &man.find.1; や &man.md5.1; などの単純なシステムユー
        ティリティでスクリプトを書くことができます. 少なくとも 1 日 1 
        回, クライアントのファイルを直接 md5 にかけ, さらにもっと頻繁
        に <filename>/etc</filename> および 
        <filename>/usr/local/etc</filename> にあるようなコントロール用
        ファイルを試験するのが一番です. アクセス制限されたマシンが正し
        いと知っている, 基となる md5 情報と比べて違いが見つかった場合, 
        システム管理者に調べて欲しいと悲鳴を上げるようにすべきです. 優
        れたセキュリティ用スクリプトは, <filename>/</filename> および
        <filename>/usr</filename> などのシステムパーティション上で不適
        当に suid されたバイナリや, 新たに作成されたファイルや削除され
        たファイルもチェックするでしょう.</para>

      <para>NFS ではなく, <application>ssh</application> を使用する場
        合は, セキュリティ用スクリプトを書くのはずっと難しいことで
        す. スクリプトを動かすためには, クライアントに対してスクリプト
        を <command>scp</command> しなくてはいけませんし, それは目に見
        えてしまいます. そして, 安全のためには, スクリプトが使うバイナ
        リ (find など) を <command>scp</command> する必要もあります. 
        クライアントの <application>ssh</application> デーモンはすでに
        攻撃されてしまっているかもしれません. 結局のところ, 安全でない
        リンク上の場合は <application>ssh</application> は必要かもしれ
        ませんが, <application>ssh</application> を扱うのはとても大変
        なことです.</para>

      <para>優れたセキュリティ用スクリプトは, ユーザやスタッフメンバの
        アクセス設定ファイルの変更もチェックするものです.
        <filename>.rhosts</filename>, <filename>.shosts</filename>,
        <filename>.ssh/authorized_keys</filename> など &hellip;
        <literal>MD5</literal> チェックの範囲外になってしまうであろう
        ファイル群です.</para>

      <para>ユーザ用のディスク容量が非常に大きい場合は, パーティション
        上の各ファイルを見て回るのに大変な時間がかかるかもしれません. 
        この場合は, マウントフラグを設定して, このパーティションに 
        suid されたバイナリやデバイスを置けないようにするのが良い考え
        です.<literal>nodev</literal> および <literal>nosuid</literal> 
        オプション (&man.mount.8; 参照) が知るべきものでしょう.
        とにかく少なくとも週に 1 度はファイルシステムをスキャンするべきです.
        なぜなら, この層の目的は, 侵入が成功したかどうかに関わらず, 侵
        入があったことの検出をすることだからです.</para>

      <para>プロセスアカウンティング (&man.accton.8; 参照) は,
        マシンへの侵入を検出するためのメカニズムとして推奨できる,
        比較的オーバヘッドの少ないオペレーティングシステムの機能です.
        侵入を受けた後でも当該ファイルが無傷である場合に, 侵入者が
        実際にどのようにしてシステムに侵入したかを追跡するのに特に役立ちます.</para>

      <para>最後に, セキュリティスクリプトはログファイルを処理するよう
        にし, ログファイル自体もできるだけ安全性の高い方法で生成するよ
        うにすべきです &ndash; リモート syslog は極めて有益になり得ま
        す. 侵入者は自分の侵入の痕跡を覆い隠そうとしますし, また, ログ
        ファイルはシステム管理者が最初の侵入の時刻と方法を追跡してゆく
        ために極めて重要です. ログファイルを永久に残しておくための 1 
        つの方法は, システムコンソールをシリアルポートにつないで走らせ, 
        コンソールを監視している安全なマシンを通して絶えず情報を集める
        ことです.</para>
    </sect2>

    <sect2>
      <title>偏執狂的方法</title>

      <para>多少偏執狂的になっても決して悪いことにはなりません. 原則的
        に, システム管理者は, 便利さに影響を与えない範囲でいくつでもセ
        キュリティ機能を追加することができます. また, いくらか考慮した
        結果, 便利さに影響を与えるセキュリティ機能を追加することもでき
        ます. もっと重要なことには, セキュリティ管理者とは少し喧嘩にな
        るはずなのですが &ndash; もしあなたが, 本文書に書かれている勧
        告をそのまま使用した場合は, 予想されるクラッカーはやはり本文書
        を読んでいるわけですから, あなたの防御策を教えてしまうことにな
        ります.</para>
    </sect2>

    <sect2>
      <title>サービス妨害攻撃</title>

      <para>このセクションではサービス妨害攻撃 (DOS 攻撃) を扱います. 
        サービス妨害攻撃は, 普通は, パケット攻撃です. ネットワークを飽
        和させる最先端の偽造パケット (spoofed packet) 攻撃に対してシス
        テム管理者が打てる手はそれほど多くありませんが, 一般的に, その
        種の攻撃によってサーバがダウンしないことを確実にすることで, 被
        害をある限度に食い止めることはできます.</para>

      <orderedlist>
	<listitem>
	  <para>サーバの fork の制限.</para>
	</listitem>

	<listitem>
	  <para>踏み台攻撃の制限 (ICMP 応答攻撃, ping broadcast など).
	  </para>
	</listitem>

	<listitem>
	  <para>カーネルの経路情報のキャッシュ.</para>
	</listitem>
      </orderedlist>

      <para>よくあるサービス妨害攻撃は, fork するサーバプロセスに対す
        るものです. これは, サーバにプロセス, ファイル記述子, メモリを
        マシンが死ぬまで食い尽くさせようとするものです. inetd
        (&man.inetd.8; 参照) には, この種の攻撃を制限するオプションが
        いくつかあります. マシンがダウンすることを防止することは可能で
        すが, この種の攻撃によりサービスが中断することを防止することは
        一般的に言ってできないことに注意する必要があります. inetd のマ
        ニュアルページを注意深く読んで下さい. 特に,
        <option>-c</option>, <option>-C</option>, <option>-R</option> 
        オプションに注意して下さい. IP 偽造攻撃 (spoofed-IP attack) は 
        inetd の <option>-C</option> オプションの裏をかけるので, 一般
        にオプションを組み合わせて使用するべきであることに注意して下さ
        い. スタンドアロンサーバの中には, 自分自身で fork を制限するパ
        ラメータを持っているものがあります.</para>

      <para><application>Sendmail</application> には,
        <option>-OMaxDaemonChildren</option> オプションがあります. シ
        ステム負荷の値変化には遅れがあるので, sendmail の負荷限界指定
        オプションを使うよりも, このオプションを使う方がまともに動作す
        る可能性ははるかに高いです.
        <application>sendmail</application> の実行を開始する際に,
        <literal>MaxDaemonChildren</literal> パラメータを設定するべき
        です. その値は, 通常見込まれる負荷を扱える程度に十分高いが, そ
        れだけの数の <application>sendmail</application> を操作しよう
        とするとマシンが卒倒してしまうほどには高くないような値に設定す
        るべきです. sendmail をキュー処理モード 
        (<option>-ODeliveryMode=queued</option>) で実行することや,
        sendmail デーモン (<command>sendmail -bd</command>) をキュー処
        理用プロセス (<command>sendmail -q15m</command>) と別に実行す
        ることも, 用心深いことと言えます. それでもなおリアルタイムでの
        配送を望むのであれば, <option>-q1m</option> のようにすることで, 
        キュー処理をはるかに短い時間間隔で行うことができます. いずれに
        しても, <literal>MaxDaemonChildren</literal> オプションに合理
        的な値を確実に指定して, sendmail がなだれをうって失敗すること
        がないようにして下さい.</para>

      <para><application>syslogd</application> は直接攻撃される可能性
        があるので, 可能ならばいつでも <option>-s</option> オプション
        を用いることを強く推奨します. これができないなら,
        <option>-a</option> オプションを使って下さい.</para>

      <para><application>tcpwrapper</application> の逆 identd などの接
        続返し (connect-back) を行うサービスについては十分注意を払うよ
        うにするべきです. これらは直接攻撃を受ける可能性があります. こ
        ういう事情があるので, <application>tcpwrapper</application> の
        逆 ident 機能を使おうとは思わないのが一般的です.</para>

      <para>境界ルータのところでファイアウォールを設けて, 外部からのア
        クセスに対して内部サービスを防御するという考えは実によいもので
        す. この考えは, LAN の外部からの飽和攻撃を防ぐことにあり, 内部
        サービスをネットワークベースの root 権限への攻撃から防御するこ
        とにはあまり考慮を払っていません. ファイアウォールは常に排他的
        に設定して下さい. つまり, <quote>ポート A, B, C, D と M から Z 
        まで<emphasis>以外</emphasis> のすべてにファイアウォールを設ける</quote> 
        というふうにです. このようにすることで,
        <application>named</application> (ゾーンのプライマリである場合),
        <application>ntalkd</application>,
        <application>sendmail</application> などのインターネットからア
        クセスできるサービスとして特に指定するもの以外の, 小さい番号の
        ポートすべてをファイアウォールで防御することができます. ファイ
        アウォールをこの他のやり方 &ndash; つまり包含的もしくは受容的
        なファイアウォールとして設定しようとする場合,
        <quote>close</quote> することを忘れてしまうサービスがいくつか
        出てきたり, 新しい内部サービスを追加したのにファイアウォールの
        更新を忘れたりする可能性がよく出てきます. ファイアウォール上の
        大きい番号のポートを開けておくことにより, 小さい番号のポートを
        危険に晒すことなく受容的な動作を許すことができます. FreeBSD で
        は, <literal>net.inet.ip.portrange</literal> への
        <command>sysctl</command> (<command>sysctl -a | fgrep
        portrange</command>) をいろいろ使用することで, 動的バインドに使用される
        ポート番号の範囲を制御できることを記憶にとどめておいてください. 
        これによりファイアウォールの設定を簡略化することもできます.
        たとえば, 通常の first/last 範囲として 4000 から 5000 を,
        高位ポートの範囲として, 49152 から 65535 を指定し,
        (いくつかのインターネットアクセス可能
        なポートをブロックから除外するのはもちろんですが) 4000 より下
        のすべてをブロックするという設定が考えられるでしょう.</para>

      <para>また別のよくあるサービス妨害攻撃として, 踏み台攻撃 
        (springboard attack) と呼ばれるものがあります &ndash; これは, 
        あるサーバを攻撃し, そこ結果として生成される応答が自分自身, ロー
        カルネットワーク, そして他のマシンを過負荷に追い込むようにする
        攻撃です. この種の攻撃の中で最もありふれたものに,
        <emphasis>ICMP ping broadcast 攻撃</emphasis>があります. 攻撃
        者は, 実際に攻撃したいマシンのアドレスを送信元アドレスに設定し
        た ping パケットを偽造して, 対象の LAN のブロードキャストアド
        レスに向けてパケットを送信します. 境界にあるルータがブロードキャ
        ストアドレスに対する ping パケットを握り潰すように設定されてい
        ない場合, LAN は, 詐称された送信元アドレスに向けて応答パケット
        を生成するはめになり, 犠牲となるマシンが飽和するところまで行っ
        てしまいます. 攻撃者が同じトリックを異なるネットワーク上のいく
        つものブロードキャストアドレスに対して同時に使用した場合, とく
        にひどいことになります. これまでに, 120 メガビット以上のブロー
        ドキャスト攻撃が観測されています. 2 番目の踏み台攻撃は, ICMP 
        エラー報告の仕掛けを狙うものです. 攻撃者は ICMP エラー応答を生
        成するパケットを生成し, サーバの受信ネットワークを飽和させ, そ
        の結果としてサーバが送信ネットワークを ICMP 応答で飽和させてし
        まうようにすることができます. mbuf を消費し尽くさせることによ
        り, この種の攻撃でサーバをクラッシュさせることも可能です. サー
        バが生成した ICMP 応答を十分速く送信できない場合, とくにひどい
        ことになります. FreeBSD カーネルには, この種の攻撃の効果を抑制
        する ICMP_BANDLIM と呼ばれる新しいカーネルコンパイルオプション
        があります. 踏み台攻撃の 3 つめの主要なクラスに属する攻撃は,
        udp echo サービスのような, 特定の inetd 内部サービスに関連する
        ものです. 攻撃者は, 単に送信元アドレスがサーバ A の echo ポー
        トであり, 送信先アドレスがサーバ B の echo ポートであるように 
        UDP パケットを偽造します. ここでサーバ A, B はともにあなたの 
        LAN に接続されています. この 2 つのサーバは, この一つのパケッ
        トを両者の間で互いに相手に対して打ち返しあいます. このようにし
        てパケットをほんのいくつか注入するだけで, 攻撃者は両方のサーバ
        と LAN を過負荷状態にすることができます. 同様の問題が内部 
        chargen ポートにも存在します. 有能なシステム管理者はこの手の 
        inetd 内部テストサービスのすべてを無効にしておくものです.
        </para>

      <para>偽造パケット攻撃は, カーネルの経路情報キャッシュに過負荷を
        生じさせるために用いられることもあります.
        <literal>net.inet.ip.rtexpire</literal>,
        <literal>rtminexpire</literal>, <literal>rtmaxcache</literal> 
        の <command>sysctl</command> パラメータを参照して下さい. でた
        らめな送信元 IP アドレスを用いた偽造パケット攻撃により, カーネ
        ルは, 一時的なキャッシュ経路を経路情報テーブルに生成します. こ
        れは <command>netstat -rna | fgrep W3</command> で見ることがで
        きます. これらの経路は, 普通は 1600 秒程度でタイムアウトになり
        ます. カーネルがキャッシュ経路テーブルが大きくなり過ぎたことを
        検知すると, カーネルは動的に rtexpire を減らしますが,
        rtminexpire より小さくなるようには決して減らしません. ここに問
        題が 2 つあります:</para>

      <orderedlist>
	<listitem>
	  <para>負荷の軽いサーバが突然攻撃された場合, カーネルが十分素
	    早く反応できないこと.</para>
	</listitem>
	
	<listitem>
	  <para>カーネルが持続的攻撃に耐えられるほど十分 
	    <literal>rtminexpire</literal> が低く設定されていないこと.
	    </para>
	</listitem>
      </orderedlist>

      <para>自分のサーバが T3 もしくはそれより高速の回線でインターネッ
        トに接続されている場合, &man.sysctl.8; を用いて 
        <literal>rtexpire</literal> と <literal>rtminexpire</literal> 
        とを手動で上書きしておくことが思慮深いことといえます. どちらか
        一方でも 0 には決してしないで下さい (自分のマシンをクラッシュ
        させたくないのであれば <!-- smiley -->:-). 両パラメータを 2 秒
        に設定すれば, 攻撃から経路情報テーブルを守るには十分でしょう.
        </para>
    </sect2>

    <sect2>
      <title>Kerberos および SSH を用いたアクセスの問題</title>

      <para>もしあなたが, kerberos および 
        <application>ssh</application> を使用したいのだとしたら, 両者
        に関して言っておく必要のある問題がいくつかあります. kerberos V 
        は大変優れた認証プロトコルですが, kerberos 化された 
        <application>telnet</application> や 
        <application>rlogin</application> は, バイナリストリームを扱う
        のに不向きになってしまうようなバグがあります. さらに, デフォル
        トでは, kerberos は <option>-x</option> オプションを使わない限
        りセッションを暗号化してくれません.
        <application>ssh</application> では, デフォルトですべてを暗号
        化してくれます.</para>

      <para><application>ssh</application> はあらゆる場面でとても良く
        働いてくれます. ただし, デフォルトで暗号鍵を転送してしまうこと
        を除けばです. これはつまり, 暗号鍵を持った安全なワークステーショ
        ンがあって, この暗号鍵で残りのシステムとアクセスできるようになっ
        ている場合に, 安全でないマシンへ 
        <application>ssh</application> を行なう時に暗号鍵が見えてしま
        うということです. 実際の鍵そのものが見えてしまうわけではありま
        せんが, <application>ssh</application> は, あなたが login して
        いる間, 転送用ポートを作ります. クラッカーが安全でないマシンの 
        root を破ると, クラッカーは, このポートを使って暗号鍵を取得し, 
        この暗号鍵でロックの外れる他のマシンへのアクセスを得ます.
        </para>

      <para>スタッフのログインには, kerberos を組み合せた 
        <application>ssh</application> を使用することを勧めます.
        <application>ssh</application> は, kerberos サポート機能と一緒
        にコンパイルできます. こうすると, 見えてしまうかもしれない
        <application>ssh</application> 鍵をあまりあてにしないで良いよ
        うになります. また, それと同時に, kerberos 経由でパスワードを
        保護することもできます. <application>ssh</application> 鍵は, 
        安全なマシンからの自動化されたタスク (kerberos はこの用途には
        不向きです) のみに使用するべきです. また,
        <application>ssh</application> の設定で鍵転送をしないようにす
        るか, あるいは, <application>ssh</application> が
        <filename>authorized_keys</filename> ファイル中に書くことを許
        している <literal>from=IP/DOMAIN</literal> オプションを使用し
        て, 特定のマシンからログインしてきたときのみ鍵が有効であるよう
        にすることも勧めます.</para>
    </sect2>
  </sect1>

  <sect1 id="crypt">
    <title>DES, MD5, と Crypt</title>

    <para><emphasis>改訂: &a.unfurl;, 21 March　
      2000.</emphasis></para>

    <para><emphasis>訳: &a.hanai;,
	12 September 1996.</emphasis></para>
    <para><emphasis>訳改訂: &a.jp.hino;,
	12 March 2001.</emphasis></para>

    <para>UNIX システムにおけるすべてのユーザは, そのアカウントに対応し
      た一つのパスワードを持っています. それらのパスワードはユーザ本人
      と本当のオペレーティングシステムのみが知っているべきであるという
      ことは明らかでしょう. それらのパスワードを秘密に保っておくために, 
      パスワードは<quote>一方向ハッシュ</quote>として知られる方式で暗
      号化されます. 一方向ハッシュとは, 簡単に暗号化はできるが解読は難
      しいという方法です. 言葉を換えると, 先ほど明らかであると書いたの
      は実は正しくないのです: オペレーティングシステム自身は<emphasis>
      本当は</emphasis>パスワードを知らないのです. その代わりに
      <emphasis>暗号化された</emphasis>形でのみパスワードを知っていま
      す.<quote>素のテキスト</quote>としてパスワードを得る唯一の方法は, 
      可能な限りのパスワード空間を検索するという力任せの方法です.
      </para>

    <para>不幸なことに, UNIX が生まれようとしているときにパスワードを
      安全な形で暗号化できる方式は DES(Data Encryption Standard) に基
      づいたものだけでした.  このことは米国に住んでいるユーザにとって
      は大して問題ではありませんでしたが, DES のソースコードを米国外に
      輸出することはできないという問題がありました. そのために,
      FreeBSD は, 米国の法律を守ることと, 未だに DES を使っている他の 
      UNIX 一族との互換性を保つこととを両立する方法を探し出す必要があ
      りました.</para>

    <para>その解決方法は, 米国のユーザは DES のライブラリをインストー
      ルして DES を使用できるが, 米国外のユーザは国外に輸出可能な他の
      ひとつの暗号化方式を使用することができる, というように暗号化ライ
      ブラリを分割することでした. これが FreeBSD がデフォルトの暗号化
      方式として MD5 を使うようになったいきさつです. MD5 は DES よりも
      より安全であると考えられているため, DES をインストールする一番の
      理由は互換性を保つためといえます.</para>

    <sect2>
      <title>暗号化機構を理解する</title>

      <para>FreeBSD がどの暗号化方式を使うようにセットアップされている
        かを判断するのは簡単です.
        <filename>/etc/master.passwd</filename> ファイルの中の暗号化さ
        れたパスワードを調べてみるのが一つの方法です. MD5 ハッシュで暗
        号化されたパスワードは, DES ハッシュで暗号化されたパスワードよ
        りも長いですし, その上 <literal>&dollar;1&dollar;</literal> と
        いう文字で始まるという特徴も持っています. DES のパスワードはこ
        れといって識別可能な特徴は持っていませんが, MD5 のパスワードよ
        りは短く, そして <literal>&dollar;</literal> という文字を含ま
        ない 64 文字のアルファベットを使って表現されているので, 比較的
        短い文字列でドル記号で始まっていないものはおそらく DES のパス
        ワードでしょう.</para>

      <para>同様の方法で, ライブラリはパスワードを識別します. 結果とし
        て, DES のライブラリは MD5 パスワードを識別でき, そして MD5 を
        使って MD5 で暗号化されたパスワードをチェックし, その他のパス
        ワードには DES を使ってチェックします. DES のライブラリは MD5 
        も含んでいるのでこのようなことが可能なのです. 残念なことに, 反
        対は真ではありません. MD5 のライブラリは DES で暗号化されたパ
        スワードを認証することができません.</para>

      <para>あなたのシステムでプログラムがどちらのライブラリを使ってい
	るかを調べるのは非常に簡単です.  crypt を使うプログラムは 
	libcrypt をリンクしています.  そしてそれぞれのライブラリに対す
	る適切な実装へのシンボリックリンクとなってい ます. たとえば, DES 
	版を使っているようなシステムにおいては次のようになっています:
	</para>

      <screen>&prompt.user; <userinput>ls -l /usr/lib/libcrypt*</userinput>
lrwxr-xr-x  1 root  wheel  13 Mar 19 06:56 libcrypt.a -&gt; libdescrypt.a
lrwxr-xr-x  1 root  wheel  18 Mar 19 06:56 libcrypt.so.2.0 -&gt; libdescrypt.so.2.0
lrwxr-xr-x  1 root  wheel  15 Mar 19 06:56 libcrypt_p.a -&gt; libdescrypt_p.a</screen>

      <para>MD5 に基づいたライブラリを使っているシステムにおいては, 同
	じようなリンクが 見られるでしょうが, そのターゲットは 
	<filename>libdescrypt</filename> ではなく
	<filename>libscrypt</filename> になっているでしょう.</para>

      <para>もし DES 機能を持った crypt ライブラリ
        <filename>libdescrypt</filename> をインストールしたのなら (つ
        まり "crypt" ディストリビューションをインストールした場合), 新
        規パスワードがどちらのパスワード形式になるかは,
        <filename>/etc/login.conf</filename> の中の 
        <quote>passwd_format</quote> ログインケーパビリティによって制
        御されます. その値としては, <quote>des</quote> または
        <quote>md5</quote> を設定することができます. ログインケーパビ
        リティに関するより詳細な情報は, &man.login.conf.5; マニュアルページ
        をご覧ください.</para>

    </sect2>
  </sect1>

  <sect1 id="skey">
    <title>S/Key</title>

    <para>S/Key は一方向ハッシュ関数を基にしたワンタイムパスワード方式
      です. FreeBSD では, 互換性のために MD4 ハッシュを用いていますが
      他のシステムでは MD5 や DES-MAC を用いてます. S/Key は, バージョ
      ン1.1.5 以降のすべての FreeBSD に含まれていますし, FreeBSD 以外
      の数多くのシステムの上でも利用されています. S/Key ば Bell
      Communications Research, Inc. の登録商標です.</para>

    <para>以下の説明では, 三種類の異なる「パスワード」が使われます. 
      まず一つ目は, あなたが普段使っている普通の UNIX スタイルの, もし
      くは Kerberos でのパスワードです. ここではこれを <quote>UNIX パ
      スワード</quote>と呼ぶことにし ます. 二つ目は, S/Key の 
      <command>key</command> プログラムによって生成され,
      <command>keyinit</command> プログラムとログインプロンプトが受け
      付けるパスワードです. ここではこれを<quote>ワンタイムパスワード
      </quote>と呼ぶことにします.  三つ目のパスワードは,
      <command>key</command> (と場合により <command>keyinit</command>) 
      プログラムに対してユーザが入力する秘密のパスワードで, ワンタイム
      パスワードを生成するのに使われます. ここではこれを<quote>秘密の
      パスフレーズ</quote>もしくは単に &ldquo;パスフレーズ&rdquo; と呼
      ぶことにします. (訳注: ユーザが頭の中だけにしまっておくべきもの
      が, この秘密のパスフレーズです. なお, 原文ではこれをパスワードと
      表記していますが, 混乱を避けるために訳文ではすべて<quote> 秘密の
      パスフレーズ</quote>に統一しています.)</para>

    <para>秘密のパスフレーズは, UNIX パスワードと何の関連性もありませ
      ん: 両者を同一に設定することは可能ですが, お奨めしません.  UNIX 
      パスワードは長さが 8 文字に制限されています (訳注: FreeBSD で 
      DES を導入していない場合はもっと長いパスワードも認識されます). 
      これに対し, S/Key では秘密のパスフレーズを好きなだけ長くすること
      ができます (訳注: 実装上, <command>key</command> コマンドなどの
      バッファ長で制限されてしまう可能性があります.  200 文字程度に押
      えておいた方がよいでしょう :-). 6 語から 7 語からなるパスフレー
      ズがふつうです. ほとんどの部分で, S/Key システムは UNIX のパスワー
      ドシステムと完全に独立して動作するようになっています.</para>

    <para>パスフレーズに加え, S/Key システムにとって重要な二種類のデー
      タがあります. 一つは<quote>シード (seed: 種)</quote>または
      <quote>キー (key: 鍵)</quote>と呼ばれるもので, 二つの文字と五つ
      の数字で構成されます. もう一つは<quote>シーケンス番号 (iteration
      count)</quote> で, 1 から 100 までの整数です.  S/Key はここまで
      に述べたデータを利用してワンタイムパスワードを生成します. その方
      法は, まずシードと秘密のパスフレーズを連結し, それに対してシーケ
      ンス番号の回数だけ MD4 ハッシュを繰り返し計算します. そしてその
      結果を 六つの短い英単語に変換します. <command>login</command> プ
      ログラムと <command>su</command> プログラムは, 前回最後に受け付
      けられたワンタイムパスワードを記録しています.  そして, その前回
      のワンタイムパスワードと, ユーザが入力したワンタイムパスワードを
      一回ハッシュ関数にかけた結果とが一致した場合に, このユーザは認証
      されます. 一方向ハッシュ関数を使っているので, もし正しく認証され
      たワンタイムパスワードが一回盗聴されたとしても, 次回以降に使われ
      る複数のワンタイムパスワードを生成することは不可能です.  シーケ
      ンス番号はログインが成功するたびに一つずつ減らされて, ユーザとロ
      グインプログラムの間で同期が取られます. シーケンス番号が 1 まで
      減ったら, S/Key を再度初期化する必要があります.</para>

    <para>次に, S/Key 関連の四つのプログラムについて説明します.
      <command>key</command> プログラムは, シーケンス番号一つと, シー
      ド一つと, 秘密のパスフレーズ一つとを受け付けて, ワンタイムパスワー
      ドを一つ生成します. <command>keyinit</command> プログラムは,
      S/Key を初期化するのに使用され, また秘密のパスフレーズやシーケン
      ス番号やシードを変更するためにも使用されます. このプログラムを実
      行するには, 秘密のパスフレーズか, または, シーケンス番号とシード
      とワンタイムパスワードの一組かの, どちらかが必要になります.
      <command>keyinfo</command> プログラムは,
      <filename>/etc/skeykeys</filename> というファイルを調べて, この
      プログラムを起動したユーザの現在のシーケンス番号とシードを表示し
      ます. 最後に, <command>login</command> と <command>su</command> 
      プログラムについてですが, これらは S/Key のワンタイムパスワード
      を, (訳注:システムが) ユーザを認証するものとして受理するのに必要
      な処理をおこないます.  <command>login</command> プログラムは, 指
      定された特定のアドレスからの接続に対して, UNIX パスワードの使用
      を認めなくする機能, 逆に言えば S/Key の利用を強制する機能も持っ
      ています.</para>

    <para>この文書では, 四種類の異なる操作について説明します. 
      一つ目は, <command>keyinit</command> プログラムを信頼できる通信
      路上で利用する場合で, 一番始めに S/Key を設定する操作や, 使い始
      めたあとで秘密のパスフレーズやシードを変更する操作です. 二つ目は,
      <command>keyinit</command> プログラムを信頼できない通信路上で利
      用する場合で, 操作の目的は一つ目と同じです. この場合には 
      <command>key</command> プログラムを併用する必要があります.  三つ
      目は, <command>key</command> プログラムを使い, 信頼できない通信
      路を通じてログインする操作です. 四番目は, <command>key</command> 
      プログラムを使って, 複数のワンタイムパスワードを一気に生成する操
      作です.  ここで生成した複数のワンタイムパスワードは, メモしたり
      印刷したりして携帯し, 信頼できる通信路が一切ないところで利用する
      ことができます. (訳注: ワンタイムパスワードを記録した紙をなくさ
      ないこと!  電話番号やIPアドレス, ユーザ名を一緒にメモしていたら
      最悪です!!)</para>

    <sect2>
      <title>信頼できる通信路での初期化</title>

      <para>信頼できる通信路 (たとえばあるマシンのコンソール画面や, ssh 
	を使っている時など) を利用しているときに, S/Key を初めて初期化
	すること, S/Key の秘密のパスフレーズを変更すること, またはシー
	ドを変更すること, をおこなうことができます. そのためには, まず
	あなた自身がログインし, <command>keyinit</command> コマンドを
	以下のようにパラメタなしで実行します:</para>

      <screen>&prompt.user; <userinput>keyinit</userinput>
Adding unfurl:
Reminder - Only use this method if you are directly connected.
If you are using telnet or rlogin exit with no password and use keyinit -s.
        ) `keyinit' コマンドが出力する注意です. 訳すと,
        ) 注意 - この動作モードはマシンに直接入力しているときのみ利用
        ) すること. もし今 telnet や rlogin を使っているなら, 秘密のパ
        ) スフレーズを入力せずにこのままコマンドを終了し, かわりに
        ) keyinit -s を実行すること.
Enter secret password: 
Again secret password: 

ID unfurl s/key is 99 to17757
DEFY CLUB PRO NASH LACE SOFT</screen>

      <para><prompt>Enter secret password:</prompt> というプロンプトに
	対してあなたが考えた秘密のパスフレーズを入力します. このパスフ
	レーズはログインするときに使うものではなく, ログインするときに
	使うワンタイムパスワードを生成するために使うものであることを覚
	えておいてください. <quote>ID</quote> から始まる行は, S/Key に
	おける一回分のパラメタであり, あなたのログイン名とシーケンス番
	号とシードです. (訳注: `<command>keyinit</command>' コマンドは
	次回にログインするときに使えるパラメタを参考のためにここで表示
	します.)  S/Key を使ってログインするときには, システム側が自動
	的にこれらのパラメタを表示してくれますから, これらのパラメタを
	覚えておく必要はありません. 最後の行が, 今述べたパラメタと入力
	された秘密のパスフレーズから計算されたワンタイムパスワードです. 
	この例を実行した後, 次にログインするときに打ち込むべきワンタイ
	ムパスワードがこれです.</para>
    </sect2>

    <sect2>
      <title>信頼できない通信路での初期化</title>

      <para>信頼できない通信路を使って S/Key を初期化, または秘密のパ
	スフレーズを変更するためには, 信頼できる通信路として, その信頼
	できない通信路とは別のものを用意する必要があります. その信頼で
	きる通信路は <command>key</command> プログラムを実行するために
	必要となるもので, たとえばそれは, あなたが信頼できる Macintosh 
	のデスクアクセサリや信頼できるマシンのシェルプロンプトだったり
	するでしょう. (訳注: ここでの通信路とはマシンそのものになりま
	す. 信頼できるマシンとは, 信頼できる人がしっかり管理しているマ
	シンということです.)  他に準備しておくものとして, シーケンス番
	号 (100 は適切な値といえるでしょう) と, 場合によっては自分で考
	えた, またはランダムに生成されたシードがあります.  (あなたが 
	S/Key を初期化しようとしているマシンへの) 信頼できない通信路を
	使うときには, <command>keyinit -s</command> コマンドを以下のよ
	うに使用します:</para>

      <screen>&prompt.user; <userinput>keyinit -s</userinput>
Updating unfurl:
Old key: to17758
Reminder you need the 6 English words from the key command.
	) `keyinit' コマンドが出力する注意です. 訳すと,
	) 注意 - skey コマンドの出力する 6 英単語が必要になります.
Enter sequence count from 1 to 9999: <userinput>100</userinput>
Enter new key [default to17759]: 
s/key 100 to 17759
s/key access password:</screen>

      <para>デフォルトのシード (<command>keyinit</command> プログラム
	は困ったことにこれを <literal>key</literal> と読んでいるのです
	が, 混乱しないよう注意してください) で構わなければ, リターンキー
	を押してください. 次に, アクセスパスワードを入れる前に, あらか
	じめ用意しておいた信頼できる通信路(信頼できるマシンや信頼でき
	る S/Key デスクアクセサリなど) へ移って, 先ほどと同じパラメタ
	を入力します:</para>

      <screen>&prompt.user; <userinput>key 100 to17759</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;秘密のパスフレーズ&gt;</userinput>
CURE MIKE BANE HIM RACY GORE</screen>

      <para>ここで信頼できない通信路の方に戻って,
	<command>key</command> コマンドが出力したワンタイムパスワード
	をコピーして <command>keyinit</command> プログラムに入力します.
	</para>

      <screen>s/key access password:<userinput>CURE MIKE BANE HIM RACY GORE</userinput>
ID unfurl s/key is 100 to17759
CURE MIKE BANE HIM RACY GORE</screen>

      <para>後は, 前章で説明したことと同様です.</para>
    </sect2>

    <sect2>
      <title>ワンタイムパスワードを一つ生成する</title>

      <para>S/Key の初期化ができたら, ログインするときには以下のような
        プロンプトが出てくるでしょう:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;ユーザ名&gt;</userinput>
s/key 97 fw13894
Password: </screen>

      <para>ここでは表示していませんが, 便利な機能がログインプログラム
	に備わっています: パスワードプロンプトに対して, 何も入力せずに
	リターンを押すとエコーモードに切り替わります.  つまりタイプし
	た文字がそのまま見えるようになるのです. これはS/Key のワンタイ
	ムパスワードを紙に印刷していた場合など, ワンタイムパスワードを
	手で入力しなければならない場合に特に役立つ機能です. また, この
	ログインしようとしてるマシンが, 接続元のマシンから 
	UNIX パスワードを使ってログインすることができないように設定さ
	れている場合には, ログインプロンプトには S/Key のワンタイムパ
	スワードのみが受け付けられることを示す <literal>(s/key
	required)</literal> という注釈が表示されます.</para>

      <para>次に, このログインプロンプトに対して入力するためのワンタイ
	ムパスワードを生成しましょう. そのために,
	<command>key</command> プログラムを使える信頼できるマシンを用
	意します. (<command>key</command> プログラムには DOS や 
	Windows の上で動くもの, MacOS の上で動くものなどもあります.)
	<command>key</command> プログラムを使うときには, シーケンス番
	号とシードを指定します. ログインしようとしているマシンのログ
	インプロンプトの右側をカットアンドペーストすると楽でしょう.
	</para>

      <para>信頼できるシステムで:</para>

      <screen>&prompt.user; <userinput>key 97 fw13894</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: 
WELD LIP ACTS ENDS ME HAAG</screen>

      <para>ここでワンタイムパスワードが得られました. ログインを続けま
        しょう:</para>

      <screen>login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: <userinput>&lt;return to enable echo&gt;</userinput>
s/key 97 fw13894
Password [echo on]: WELD LIP ACTS ENDS ME HAAG
Last login: Tue Mar 21 11:56:41 from 10.0.0.2 ...</screen>

      <para>以上の手順は, 信頼できるマシンが利用できる場合<emphasis>の
	みに</emphasis>使えるもっとも簡単な方法です.  Java による 
	S/Key の <command>key</command> applet もあり, <ulink
	url="http://www.cs.umd.edu/~harry/jotp/src.html">The Java OTP
	Calculator</ulink> からダウンロードして Java をサポートするブ
	ラウザ上でローカルに実行することができます.</para>
    </sect2>

    <sect2>
      <title>複数のワンタイムパスワードを生成する</title>

      <para>都合によっては, 信頼できるマシンや信頼できる通信路が一切確
	保できないようなところで S/Key を使う必要があるでしょう.  この
	ような場合には, <command>key</command> コマンドを使って複数の
	ワンタイムパスワードをあらかじめ一気に生成し, 紙に印刷して携帯
	していくことができます. たとえば:</para>

      <screen>&prompt.user; <userinput>key -n 5 30 zz99999</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;秘密のパスフレーズ&gt;</userinput>
26: SODA RUDE LEA LIND BUDD SILT 
27: JILT SPY DUTY GLOW COWL ROT  
28: THEM OW COLA RUNT BONG SCOT  
29: COT MASH BARR BRIM NAN FLAG  
30: CAN KNEE CAST NAME FOLK BILK</screen>

      <para><option>-n 5</option> という引数によって 5 個のワンタイム
	パスワードを順に生成します. ここで <option>30</option> は, 最
	後のシーケンス番号となるべき数字です. 出力は普通に使う順番とは 
	<emphasis>逆</emphasis>に出力されていることに注意してください 
	(訳注: 一番最初に使うワンタイムパスワードは一番最後に出力され
	たものです). この結果をカットアンドペーストして 
	<command>lpr</command> コマンドを使って印刷すると よいでしょう. 
	もしあなたがセキュリティに偏執するなら, この結果を紙と鉛筆を使っ
	て手で書き移した方がよいかもしれません. ここで, 出力の各行はシー
	ケンス番号とそれに対応する一回分のワンタイムパスワードです. 
	消費済みの ワンタイムパスワードの行をペンで消していくと便利で
	しょう.</para>
    </sect2>

    <sect2>
      <title>UNIX パスワードの利用を制限する</title>

      <para>設定ファイル <filename>/etc/skey.access</filename> を使っ
	て UNIX パスワードの利用を制限することができます. この場合の判
	断基準として, ログインを受け付ける際のホスト名, ユーザ名, 端末
	のポート, IP アドレスなどが利用できます. この設定ファイルの詳
	細に関してはマニュアル &man.skey.access.5; をご覧ください. マ
	ニュアルにはこの機能に関わるセキュリティについて, いくつかの警
	告が記述してあります. この機能を使ってセキュリティを高めようと
	するのならば絶対にこのマニュアルを読んでください.</para>

      <para>もし <filename>/etc/skey.access</filename> ファイルが存在
	しないならば (FreeBSD のデフォルト状態ではそうです), すべての
	ユーザが UNIX パスワードを利用することができます.  逆に, もし
	ファイルが存在するならば, <filename>skey.access</filename> ファ
	イルに明示的に記述されていない限り, すべてのユーザは S/Key の
	利用を要求されます. どちらの場合においても, そのマシンのコンソー
	ルからはいつでも UNIX パスワードを使ってログインすることが可能
	です.</para>

      <para>以下によく使われるであろう三種類の設定を含む設定ファイルの
	例を示します:</para>

      <programlisting>permit internet 192.168.0.0 255.255.0.0
permit user fnord
permit port ttyd0</programlisting>

      <para>はじめの行 (<literal>permit internet</literal>) で, telnet 
	などで接続するときの IP のソースアドレス (注意: これは偽造され
	るおそれがあります) が特定の値とマスクに一致している場合に,
	UNIX パスワードの利用を許可することを指定しています.  この設定
	自体はセキュリティを高めるための機能ではありません.  そうでは
	なく, ログインの権利を持つ許可されたユーザに対して, 現在そのユー
	ザが使っているネットワークが信頼できないと考えられるので S/Key 
	を使うべきである, ということを気づかせるための機能であると考え
	てください.</para>

      <para>二行目 (<literal>permit user</literal>) によって, ある特定
	のユーザ, この場合は <literal>fnord</literal>, に対して, いつ
	でも UNIX パスワードの利用を許可するように指定しています. 一般
	的にはこの設定をおこなうべきではありません.
	<command>key</command> プログラムがどうしても使えない環境にい
	る人や, ダム端末しかない環境にいる人, または何度教えても聞く耳
	を持たないような人をサポートする必要がある場合にのみ設定をおこ
	なってください.</para>

      <para>三行目 (<literal>permit port</literal>) によって, ある特定
	の端末ポートからログインしようとするすべてのユーザに対して 
	UNIX パスワードの利用を許可するように指定しています. この設定
	はダイヤルアップ回線に対する設定として利用できるでしょう.
	</para>
    </sect2>
  </sect1>

  <sect1 id="kerberos">
    <title>Kerberos</title>

    <para><emphasis>原作: &a.markm;
	(Mark Dapoz <email>md@bsc.no</email>
	からの寄稿に基づいています).</emphasis></para>

    <para><emphasis>訳: &a.jp.arimura;.</emphasis></para>

    <para>Kerberosは,
      サーバのサービスによってユーザが安全に認証を受けられる
      ようにするための, ネットワークの付加システム及びプロトコルです.
      リモートログイン, リモートコピー,
      システム間での安全なファイルのコピ
      ーやその他のリスクの高い仕事がかなり安全に,
      そしてこれまでより制御 できるようになります.</para>

    <para>以下の文章は,
      FreeBSD用として配布されているKerberosをセットアップ
      する際のガイドとして読むことができます.  しかし,
      完全な説明が必要な場合には, マニュアルページを読んだ方がよい
      でしょう.</para>

    <para>FreeBSDのKerberosは,
      オリジナルの4.4BSD-Liteの配布に含まれているものではなく,
      FreeBSD 1.1.5.1のときに移植されたeBonesです.
      これはアメリカ/カナダの外で作成されており, そのため, アメリカか
      らの暗号技術の輸出制限があった時代でも, 
      これら以外の国の人々が手に入れられるものでした.</para>

    <sect2>
      <title>初期データベースの作成</title>

      <para>この作業はKerberosサーバだけでおこないます. まず,
	古いKerberosの データベースが存在しないことを確認してください.
	ディレクトリ<filename>/etc/kerberosIV</filename>に移って,
	次のファイルだけが 存在することをチェックします:</para>

      <screen>&prompt.root; <userinput>cd /etc/kerberosIV</userinput>
&prompt.root; <userinput>ls</userinput>
README          krb.conf        krb.realms</screen>

      <para>もし他のファイル (<filename>principal.*</filename> や
	<filename>master_key</filename>) が 存在する場合には,
	<command>kdb_destroy</command>というコマンドで古い
	Kerberosデータベースを消してください.
	Kerberosが走っていなければ,
	単に余計なファイルを消せばよいです.</para>

      <para>まず, <filename>krb.conf</filename> と
	<filename>krb.realms</filename>を編集してKerberosの 管理領域
	(realm) を定義してください.
	ここでは管理領域が<filename>GRONDAR.ZA</filename> で,
	サーバ名が<filename>grunt.grondar.za</filename>であるとします.
	<filename>krb.conf</filename>
	というファイルを次のように編集してください:</para>

      <screen>&prompt.root; <userinput>cat krb.conf</userinput>
GRONDAR.ZA
GRONDAR.ZA grunt.grondar.za admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</screen>

      <para>この例にあるような他の管理領域は, 実際には必要ありません.
	この例は複数の管理領域を認識する方法を示したものですので,
	これらの行は含めなくても結構です.</para>

      <para>1行目はこのシステムが動いている管理領域の名前です.
	他の行は管理領域とホスト名のエントリです.
	行の1つめの単語が管理領域で, 2つめがその管理領域の中で
	<quote>鍵配布センター</quote>(Key Distribution Center)
	として働くホスト名です.  ホスト名の次に <literal>admin
	  server</literal> と書いてある場合には, そのホストが
	``管理データベースサーバ''(Administrative Database Server)
	も提供 することを意味します.
	これらの単語について詳しく知りたい場合にはKerberosのマニュアル
	ページをご覧ください.</para>

      <para>ここで,
	<filename>GRONDAR.ZA</filename>という管理領域に<hostid
	  role="fqdn">grunt.grondar.za</hostid> およびその他の<hostid
	  role="domainname">.grondar.za</hostid>
	ドメインのすべてのホストを追加し なければなりません.
	<filename>krb.realms</filename>は次のようになります:</para>

      <screen>&prompt.root; <userinput>cat krb.realms</userinput>
grunt.grondar.za GRONDAR.ZA
.grondar.za GRONDAR.ZA
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</screen>

      <para>もう一度注意しますが, 他の管理領域を書く必要はありません.
	これらは複数の管理領域を認識できるようにマシンを設定する方法を
	示した例ですので, これらの行は消して構いません.</para>

      <para>1行目は名前をつけた管理領域に <emphasis>特定の</emphasis>
	システムを含めるための ものです.
	残りの行は名前をつけた管理領域にサブドメインのデフォルトの
	システムを含めるためのものです.</para>

      <para>これでデータベースを作成する準備ができました.
	この操作はKerberos サーバ (鍵配布センター) を起動するだけです.
	<command>kdb_init</command>コ
	マンドを次のように実行してください:</para>

      <screen>&prompt.root; <userinput>kdb_init</userinput>
<prompt>Realm name [default  ATHENA.MIT.EDU ]: </prompt> <userinput>GRONDAR.ZA</userinput>
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.

<prompt>Enter Kerberos master key:</prompt> </screen>

      <para>ここで鍵を保存して,
	ローカルのマシンにあるサーバが取り出せるように します.
	それには<command>kstash</command>コマンドを使用します.</para>

      <screen>&prompt.root; <userinput>kstash</userinput>

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>これで暗号化されたマスタパスワードが
	<filename>/etc/kerberosIV/master_key</filename>
	に保存されました.</para>
    </sect2>

    <sect2>
      <title>すべてが動くようにするための設定</title>

      <para>Kerberosを導入する <emphasis>それぞれの</emphasis>
	システムのデータベースに, 2つ のprincipal (主体名)
	を追加する必要があります. その名前は
	<literal>kpasswd</literal>と<literal>rcmd</literal>です.
	これら2つのprincipalは, 個々 のシステムにおいて,
	システム名と同じ名前のインスタンスと組にして作成
	されます.</para>

      <para>これらの <command>kpasswd</command> と
	<command>rcmd</command> というデーモンによって, 他の
	システムからKerberosのパスワードを変更したり,
	<command>rcp</command>や <command>rlogin</command>,
	<command>rsh</command>といったコマンドを実行したりできるよ
	うになります.</para>

      <para>それでは実際にこれらのエントリを追加しましょう:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>passwd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: passwd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください
Verifying password

<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください

<prompt>Random password [y] ?</prompt> <userinput>y</userinput>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ? </prompt>
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt> <userinput>rcmd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt>

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください
Verifying password

<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください

<prompt>Random password [y] ? </prompt>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ? </prompt>
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt>                  &lt;---- 何も入力しないと終了します</screen>
    </sect2>

    <sect2>
      <title>サーバファイルの作成</title>

      <para>次に, 各マシンにおけるサービスを定義している,
	すべてのインスタンス を展開します.
	これには<command>ext_srvtab</command>というコマンドを使用しま
	す. このコマンドで作成されるファイルは, Kerberosの各クライアン
	トの/etc/kerberosIVディレクトリに
	<emphasis>安全な方法で</emphasis>コピーまたは
	移動する必要があります. このファイルはそれぞれのサーバとクラ
	イアントに存在しなければならず,
	またKerberosの運用において重要なも のです.</para>

      <screen>&prompt.root; <userinput>ext_srvtab grunt</userinput>

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Generating 'grunt-new-srvtab'....</screen>

      <para>このコマンドは一時的なファイルを作成するだけです.
	ファイル名をすべ てのサーバが読めるような
	<filename>srvtab</filename> という名前に変更しな
	ければなりません.
	<command>mv</command>コマンドを用いてシステムの場所に移動
	してください.</para>

      <screen>&prompt.root; mv grunt-new-srvtab srvtab</screen>

      <para>そのファイルがクライアントに配るためのもので,
	ネットワークが安全で はないと思われる場合には, <filename>
	  <replaceable>client</replaceable>-new-srvtab</filename>
	を移動
	可能なメディアにコピーして物理的に安全な方法で運んでください.
	クラ
	イアントの<filename>/etc/kerberosIV</filename>ディレクトリで,
	名前を <filename>srvtab</filename>に変更し,
	modeを600にするのを忘れないでください:</para>

      <screen>&prompt.root; <userinput>mv grumble-new-srvtab srvtab</userinput>
&prompt.root; <userinput>chmod 600 srvtab</userinput></screen>
    </sect2>

    <sect2>
      <title>データベースへのユーザの追加</title>

      <para>ここで,
	ユーザのエントリをデータベースに追加する必要があります.
	始めに,
	ユーザ<username>jane</username>のエントリを作成してみましょう.
	<command>kdb_edit</command>
	を用いて次のように作成してください:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: jane, Instance: , kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- 安全なパスワードを入れてください
Verifying password

<prompt>New Password:</prompt>                    &lt;---- もう一度パスワードを入れてください

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ? </prompt>
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt>                  &lt;---- 何も入力しないと終了します</screen>
    </sect2>

    <sect2>
      <title>すべてのテスト</title>

      <para>まず始めにKerberosデーモンを起動する必要があります.
	<filename>/etc/rc.conf</filename>
	ファイルを正しく編集してあれば, マシンを再
	起動することでに自動的にデーモンが起動します.
	これはKerberosサー バでのみ必要です.
	Kerberosクライアントは<filename>/etc/kerberosIV</filename>か
	ら必要なものを自動的に入手します.</para>

      <screen>&prompt.root; <userinput>kerberos &amp;</userinput>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered.  BEWARE!

Current Kerberos master key version is 1
Local realm: GRONDAR.ZA
&prompt.root; <userinput>kadmind -n &amp;</userinput>
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>さあ, これで上で作成した <username>jane</username>
	というIDのチケットを
	<command>kinit</command>コマンドで得ることができます:</para>

      <screen>&prompt.user; <userinput>kinit jane</userinput>
MIT Project Athena (grunt.grondar.za)
Kerberos Initialization for "jane"
<prompt>Password:</prompt> </screen>

      <para><command>klist</command> コマンドを用いてトークンを見て,
	きちんとチケットを持って いるかどうか確認してください:</para>

      <screen>&prompt.user; <userinput>klist</userinput>
Ticket file:    /tmp/tkt245
Principal:    jane@GRONDAR.ZA

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.GRONDAR.ZA@GRONDAR.ZA</screen>

      <para><command>passwd</command>
	コマンドを用いてパスワードを変更して, kpasswdデーモ
	ンがKerberos
	データベースに対して認証されるかどうかチェックして
	ください:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
realm GRONDAR.ZA
<prompt>Old password for jane:</prompt>
<prompt>New Password for jane:</prompt>
Verifying password
<prompt>New Password for jane:</prompt>
Password changed.</screen>
    </sect2>

    <sect2>
      <title><command>su</command>特権の追加</title>

      <para>root権限が必要なユーザは<emphasis>誰でも</emphasis>,
	<command>su</command>コマンドのパス
	ワードをユーザ毎に<emphasis>別のもの</emphasis>
	として持つことができます.
	<username>root</username>に<command>su</command>
	できる権利を与えられたidを追加します.  これは,
	principalに付いている<username>root</username>
	というインスタンスに よって制御されています.
	<command>kdb_edit</command>を用いて
	<literal>jane.root</literal>というエントリを
	Kerberosデータベースに作成します:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt> <userinput>root</userinput>

&lt;Not found&gt;, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- 安全なパスワードを入れます
Verifying password

<prompt>New Password:</prompt>                    &lt;---- もう一回パスワードを入れます

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt> <userinput>12</userinput> &lt;--- ここは短くしてください
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt>                  &lt;---- 何も入力しないと終了します</screen>

      <para>実際にトークンをもらって,
	ちゃんと働いているかどうか確認しましょう:</para>

      <screen>&prompt.root; <userinput>kinit jane.root</userinput>
MIT Project Athena (grunt.grondar.za)
Kerberos Initialization for "jane.root"
<prompt>Password: </prompt></screen>

      <para>ここでrootユーザの <filename>.klogin</filename>
	ファイルにユーザを追加する必要が あります.</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@GRONDAR.ZA</screen>

      <para><command>su</command>してみましょう:</para>

      <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password: </prompt></screen>

      <para>どのトークンを持っているか見てみましょう:</para>

      <screen>&prompt.root; klist
Ticket file:	/tmp/tkt_root_245
Principal:	jane.root@GRONDAR.ZA

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.GRONDAR.ZA@GRONDAR.ZA</screen>
    </sect2>

    <sect2>
      <title>他のコマンドの使用</title>

      <para>ここまでの例では, <literal>jane</literal> という principal
	を <literal>root</literal> とい
	うインスタンス付きで作成しました.
	これはユーザと同じ名前をprincipalと しており,
	Kerberosのデフォルトの値です;
	<literal>&lt;username&gt;.</literal><literal>root</literal>
	という形式の
	<literal>&lt;principal&gt;.&lt;instance&gt;</literal>で,
	必要なエント
	リが<username>root</username>のホームディレクトリの
	<filename>.klogin</filename>ファイルに あれば,
	<literal>&lt;username&gt;</literal>がrootに
	<command>su</command>することができま す.</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@GRONDAR.ZA</screen>

      <para>同様に, ユーザのホームディレクトリの
	<filename>.klogin</filename>ファイルに次の
	ような行がある場合には:</para>

      <screen>&prompt.user; <userinput>cat ~/.klogin</userinput>
jane@GRONDAR.ZA
jack@GRONDAR.ZA</screen>

      <para><username>jane</username> または <username>jack</username>
	という名前で (前述の<command>kinit</command> によって)
	認証されている <filename>GRONDAR.ZA</filename>
	という管理領域のユーザ なら誰でも<command>rlogin</command> や
	<command>rsh</command>, <command>rcp</command>等によってこ
	のシステム (<hostid>grunt</hostid>)
	の<username>jane</username>のアカウントまたはファ
	イルにアクセスできます.</para>

      <para>たとえば, Janeが他のシステムにKerberos
	を用いてloginします:</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
MIT Project Athena (grunt.grondar.za)
<prompt>Password: </prompt>
&prompt.user; <userinput>rlogin grunt</userinput>
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
	The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>

      <para>次の例では, Jackが同じマシンの Jane
	のアカウントにloginします. Janeは <filename>.klogin</filename>
	ファイルを前述のように設定しており,
	Kerberosでは<emphasis>jack</emphasis>というprincipal
	をインスタンスなしで設定してあ ります.</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
&prompt.user; <userinput>rlogin grunt -l jane</userinput>
MIT Project Athena (grunt.grondar.za)
<prompt>Password: </prompt>
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
	The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
    </sect2>
  </sect1>

  <sect1 id="firewalls">
    <title>ファイアウォール</title>

    <para><emphasis>原作: &a.gpalmer;, Alex Nash;.</emphasis></para>

    <para><emphasis>訳: &a.jp.saeki;.<!-- <br> -->
	11 November 1996.</emphasis></para>

    <para>ファイアウォールは,
      インターネットに参加している人はもちろんのこと,
      プライベートネットワークのセキュリティ向上のための
      アプリケーションを 探している人にとっても,
      ますます興味深くなりつつある分野です.
      このセクションではファイアウォールとは何か,
      ファイアウォールの使用法,
      そしてファイアウォールを構築するために FreeBSD のカーネルで
      提供されているファシリティ (機能)
      の使用法について説明したいと思います.</para>

    <note>
      <para>社内のネットワークと <quote>巨大かつ信頼のおけない
	インターネット</quote>との間にファイアウォールを構築することで
	セキュリティ上のすべての問題が解決できると考える人がいます.
	ファイアウォールはセキュリティ上の問題を
	解決する助けになる場合もありますが,
	充分な設定がなされていないファイアウォールは,
	まったくファイアウォールを
	持たない場合よりもセキュリティ上の危険を増大させてしまいます.
	ファイアウォールにできることは,
	あなたのシステムにもう一つのセキュリティ層を
	追加することだけで,
	本気でアタックをしかけてくるクラッカーが内部ネットワークに
	侵入するのを妨げることはできません.
	ファイアウォールを侵入不可能と過信して
	内部のセキュリティをおろそかにすることは,
	単にクラッカーの仕事を少し簡単にするだけでしか
	ありません.</para>
    </note>

    <sect2>
      <title>ファイアウォールとは何か ?</title>

      <para>現在インターネットで普通に使用されている
	ファイアウォールには 二つの異なるタイプがあります.  一つは,
	厳密には <emphasis> パケットフィルタリングルータ </emphasis>
	と 呼ばれるタイプのものです. これはマルチホームのホストマシン
	(複数の ネットワークに接続されているマシン) のカーネルが,
	ある規則にしたがって
	パケットを転送したりブロックしたりするものです.  もう一つは,
	<emphasis> proxy (代理) サーバ </emphasis>
	として知られているタイプのものです.  これは,
	おそらくはマルチホームのホストマシン上で,
	カーネルによるパケット転送を 禁止して,
	デーモンにより認証の提供とパケットの転送とを
	おこなうものです.</para>

      <para>二つのタイプのファイアウォールを組み合わせて使用して,
	特定のマシン (<emphasis> 要塞ホスト </emphasis> と呼ばれる)
	だけが パケットフィルタリングルータを通して内部ネットワークへ
	パケットを送ることができるよう設定している
	サイトがしばしば存在します.  proxy (代理)
	サービスは通常の認証機構よりもセキュリティを
	強化してある 要塞ホストで動作させます.</para>

      <para>FreeBSD は (<application>IPFW</application>
	として知られる) カーネルパケットフィルタ込みで
	提供されています. このセクションの後の方では,
	このフィルタについての 説明を集中しておこないます.
	サードパーティから提供されるソフトウェアを使用することにより,
	Proxy サーバを FreeBSD 上に構築することができます. しかし,
	現在入手可能な proxy サーバは
	たいへんバラエティに富んでいるので,
	このドキュメントでそれらすべてを
	カバーすることは不可能です.</para>

      <sect3 id="firewalls-packet-filters">
	<title>パケットフィルタリングルータ</title>

	<para>ルータとは, 二つまたはそれ以上のネットワークの間で
	  パケットの転送をおこなう マシンのことです.
	  パケットフィルタリングルータは, そのカーネルの内部に,
	  一つ一つのパケットをルールリストと比較して
	  転送するかしないかを決める 特別なコードを持っています.
	  最近の IP ルーティングソフトウェアのほとんどは, 内部に
	  パケットのフィルタリングをおこなうためのコードを持っていて,
	  デフォルトでは すべてのパケットを転送するようになっています.
	  このフィルタを有効にするためには,
	  パケットの通過を許すべきかどうかを決める
	  ルールを自分で定義する必要があります.</para>

	<para>パケットを通すべきか通すべきでないかを決めるために,
	  パケットヘッダの内容にマッチするものが
	  ルールリストから探されます.  マッチするルールが見つかると,
	  ルールアクションが実行されます.  ルールアクションには,
	  パケットを捨てる, パケットを転送する,
	  またはパケットの発信元に ICMP
	  メッセージを送り返すというものがあります.
	  ルールの検索は先頭から順番におこなわれ,
	  通常は最初にマッチしたものだけが 適用されます.  そのため,
	  このルールリストは<quote>ルールチェーン</quote>
	  と呼ばれることもあります.</para>

	<para>パケットマッチングの基準は使用するソフトウェアに
	  よって異なりますが,  通常はパケットの発信元 IP アドレス,
	  宛先 IP アドレス, 発信元ポート番号,  宛先ポート番号
	  (ポート番号はポートをサポートするプロトコルの場合のみ),
	  パケットタイプ (UDP, TCP, ICMP など)
	  に基づくルールを指定することができます.</para>
      </sect3>

      <sect3 id="firewalls-proxy-servers">
	<title>Proxy サーバ</title>

	<para>Proxy サーバとは通常のシステムデーモン (telnetd, ftpd
	  など) を 特別なサーバで置き換えたマシンのことです.
	  これらのサーバは,
	  通常は中継をおこなって特定方向への接続だけを許すため,
	  <emphasis>proxy サーバ </emphasis> と呼ばれます.  (たとえば)
	  proxy telnet
	  サーバをファイアウォールホストで走らせておきます.
	  外部からユーザがファイアウォールに対して telnet
	  を実行すると,  proxy telnet サーバが応答して,
	  何らかの認証機構を実行します.  これを通過した後で,
	  内部ネットワークへのアクセスがおこなえるように なるのです.
	  (内部ネットワークからの信号は proxy
	  サーバがかわりに受け取り,  外へ向けて送り出します.)</para>

	<para>Proxy サーバは通常,
	  普通のサーバより堅固に構築されていて,  しばしば
	  <quote>使い捨て</quote>パスワードシステムなどを含む,
	  多様な認証機構を持っています.
	  <quote>使い捨て</quote>パスワードシステムとは,
	  どういうものなのでしょうか.  仮に誰かが何らかの方法で,
	  あなたが使用したパスワードを手に入れたとします.  しかし,
	  一度使用したことで,
	  そのパスワードは既に無効になっているのです.  ですから,
	  そのパスワードをもう一度使用したとしても, あなたのシステムへ
	  アクセスすることはできないというわけです.
	  これらのサーバは中継をおこなうだけで,
	  実際のところサーバホスト自身への
	  アクセスをユーザに許してはいません. そのため,
	  何者かがセキュリティシステムに
	  侵入用の裏口を取り付けることは,
	  より困難になっています.</para>

	<para>proxy サーバはアクセス制限の方法をいくつも持っていて,
	  特定のホスト
	  だけがサーバへのアクセス権を得ることができるように
	  なっていることがあり ます.
	  そして目的のマシンと通信できるユーザを制限するように
	  設定することもできます.  もう一度言いますが,
	  どんなファシリティ (機能) が使えるかは,  どんな proxy
	  サービスをおこなうソフトウェアを選ぶかに大きく
	  依存します.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>IPFW で何ができるか</title>

      <para>FreeBSD とともに配布されている
	<application>IPFW</application> は, カーネル内部にあって
	パケットのフィルタリングとアカウンティングを
	おこなうシステムであり,
	ユーザ側のコントロールユーティリティである &man.ipfw.8; を
	含んでいます. ルーティングの決定をおこなう際に,
	これらは互いに協力して,
	カーネルで使用されるルールを定義したり,
	現在使用されているルールを
	問い合わせたりすることができます.</para>

      <para><application>IPFW</application>
	は互いに関連する二つの部分からなっています.
	ファイアウォールセクションは
	パケットフィルタリングをおこないます.  また, IP
	アカウンティングセクションはファイアウォールセクションのものと
	似たルールに基づいてルータの使用を追跡します.  これにより,
	(たとえば) 特定のマシンからルータへのトラフィックがどのくらい
	発生しているか調べたり, どれだけの WWW (World Wide Web)
	トラフィックが
	フォワードされているかを知ることができます.</para>

      <para><application>IPFW</application> は,
	ルータではないマシンにおいても入出力コネクションの
	パケットフィルタリングのために
	使用することができるように設計されています.  これは一般的な
	<application>IPFW</application>
	の使用法とは異なる特別な使い方ですが,
	こういった状況でも同じコマンドと
	テクニックが使用されます.</para>
    </sect2>

    <sect2>
      <title>FreeBSD で IPFW を有効にする</title>

      <para><application>IPFW</application>
	システムの中心となる部分はカーネル内部にあります.  そのため,
	どのファシリティ (機能) を必要とするかによって, 一つまたは
	それ以上のオプションをカーネルコンフィグレーション
	ファイルに追加し,
	カーネルを再コンパイルする必要があるでしょう.
	カーネルの再コンパイル方法の詳細については,  <link
	  linkend="kernelconfig">カーネルコンフィグレーション</link>
	を参照してください.</para>

      <para>現在, IPFW
	に関係するカーネルコンフィグレーションオプションは
	三つあります:</para>

      <variablelist>
	<varlistentry><term><literal>options IPFIREWALL</literal></term>
	  <listitem>
	    <para>パケットフィルタリングのためのコードを
	      カーネルに組み込みます.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><literal>
	      options IPFIREWALL_VERBOSE</literal></term>
	  <listitem>
	    <para>&man.syslogd.8; を通じて
	      パケットのログを取るためのコードを有効にします.
	      フィルタルールでパケットのログを取るように指定しても,
	      このオプションが指定されていなければ,
	      ログを取ることはできません.</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><literal>
	      options IPFIREWALL_VERBOSE_LIMIT=10</literal></term>
	  <listitem>
	    <para>&man.syslogd.8; を通じて
	      ログを取るパケットの数をエントリ毎に制限します.
	      敵対的な環境においてファイアウォールの
	      動作のログを取りたいけれど,
	      syslog の洪水によるサービス拒絶攻撃に対し
	      無防備でありたくないという場合に,
	      このオプションを使用したいと思うことが
	      あるかもしれません.</para>

	    <para>チェーンエントリのログが指定された制限数に達すると,
	      そのエントリに関するログ取りは停止されます.
	      ログ取りを再開するには, &man.ipfw.8;
	      ユーティリティを使用して
	      関連するカウンタをリセットする必要があります:</para>

	    <screen>&prompt.root; <userinput>ipfw zero 4500</userinput></screen>

	    <para>4500 とは,
	      ログ取りを続行したいチェーンエントリの番号です.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>以前のバージョンの FreeBSD は
	<literal>IPFIREWALL_ACCT</literal> というオプションを
	持っていました.  しかし,
	ファイアウォールコードがアカウンティングファシリティ (機能) を
	自動的に含むようになったため,
	現在では使用されることはなくなっています.</para>
    </sect2>

    <sect2>
      <title>IPFW の設定</title>

      <para><application>IPFW</application> ソフトウェアの設定は
	&man.ipfw.8; ユーティリティを
	通じておこないます. このコマンドの構文は非常に
	複雑に見えますが,
	一旦その構造を理解すれば比較的単純です.</para>

      <para>このユーティリティでは今のところ四つの異なる
	コマンドカテゴリが 使用されています: それは追加 / 削除, 表示,
	フラッシュ, およびクリアです.  追加 /
	削除はパケットの受け入れ, 拒絶, ログ取りをどのようにおこなうか
	というルールを構築するのに使用します.  表示はルールリスト
	(またはチェーン) と (アカウンティング用) パケットカウンタの
	内容を調べるのに使用します.
	フラッシュはチェーンからすべてのエントリを
	取り除くのに使用します.
	クリアは一つまたはそれ以上のアカウンティングエントリを
	ゼロにするのに 使用します.</para>

      <sect3>
	<title>IPFW ルールの変更</title>

	<para>この形式での使用法は:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg>-N</arg>
	    <arg choice="plain">コマンド</arg>
	    <arg>index</arg>
	    <arg choice="plain">アクション</arg>
	    <arg>log</arg>
	    <arg choice="plain">プロトコル</arg>
	    <arg choice="plain">アドレス</arg>
	    <arg>オプション</arg>
	  </cmdsynopsis>
	</para>

	<para>この形式で使用する際に有効なフラグは一つだけです:</para>

	<variablelist>
	  <varlistentry><term>-N</term>
	    <listitem>
	      <para>アドレスやサービス名を
		文字列に変換して表示します.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para><emphasis> コマンド </emphasis>
	  は一意である限り短縮可能です.  有効な <emphasis> コマンド
	  </emphasis> は:</para>

	<variablelist>
	  <varlistentry><term>add</term>
	    <listitem>
	      <para>ファイアウォール / アカウンティングルールリストに
		エントリを追加します.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>delete</term>
	    <listitem>
	      <para>ファイアウォール /
		アカウンティングルールリストから
		エントリを削除します.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>以前のバージョンの <application>IPFW</application> では,
	  ファイアウォールエントリと
	  パケットアカウンティングエントリが別々に利用されていました.
	  現在のバージョンでは, それぞれのファイアウォールエントリ毎に
	  パケットアカウンティングエントリが備えられています.</para>

	<para><emphasis>index</emphasis> が指定されていると,
	  エントリはチェーン中の <emphasis remap=tt>index</emphasis>
	  で示される位置に置かれます. <emphasis
	    remap=tt>index</emphasis> が指定されて いなければ,
	  エントリは (65535 番のデフォルトルールである
	  パケット拒絶を別にして) 最後のチェーンエントリの index に
	  100 を足した 位置 (チェーンの最後) に置かれます.</para>

	<para>カーネルが <literal>IPFIREWALL_VERBOSE</literal>
	  つきでコンパイルされている場合,  <literal>log</literal>
	  オプションはマッチしたルールを
	  システムコンソールに出力させます.</para>

	<para>有効な <emphasis> アクション </emphasis> は:</para>

	<variablelist>
	  <varlistentry><term>reject</term>
	    <listitem>
	      <para>パケットを捨てます, ICMP ホスト /
		ポート到達不能パケットを (適切な方を)
		発信元へ送ります.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>allow</term>
	    <listitem>
	      <para>通常通りパケットを通過させます. (別名:
		<literal>pass</literal> および
		<literal>accept</literal>)</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>deny</term>
	    <listitem>
	      <para>パケットを捨てます. 発信元は ICMP メッセージによる
		通知を受けません (そのためパケットが
		宛先に到達しなかったように見えます).</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>count</term>
	    <listitem>
	      <para>このルールはパケットカウンタを更新するだけで,
		パケットを 通過させたり拒絶したりしません.
		検索は次のチェーンエントリから続けられます.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>それぞれの <emphasis> アクション </emphasis>
	  は一意な先頭部分だけでも認識されます.</para>

	<para>指定可能な <emphasis> プロトコル </emphasis>
	  は以下の通り:</para>

	<variablelist>
	  <varlistentry><term>all</term>
	    <listitem>
	      <para>任意の IP パケットにマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>icmp</term>
	    <listitem>
	      <para>ICMP パケットにマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>tcp</term>
	    <listitem>
	      <para>TCP パケットにマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>udp</term>
	    <listitem>
	      <para>UDP パケットにマッチします.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para><emphasis> アドレス </emphasis> の指定は:</para>
	<cmdsynopsis>
	  <arg choice="plain">from</arg>
	  <arg choice="plain"><replaceable>address/mask</replaceable></arg>
	  <arg><replaceable>port</replaceable></arg>
	  <arg choice="plain">to</arg>
	  <arg choice="plain"><replaceable>address/mask</replaceable></arg>
	  <arg><replaceable>port</replaceable></arg>
	  <arg>via <replaceable>interface</replaceable></arg>
	</cmdsynopsis>

	<para><replaceable>port</replaceable> はポートをサポートする
	  <emphasis> プロトコル </emphasis> (UDP と TCP) の
	  場合にだけ指定可能です.</para>

	<para><option>via</option> は必須ではなく,
	  特定のインタフェースを通ってきたパケット
	  だけにマッチするように, IP アドレスまたはローカル IP
	  インタフェースの ドメイン名, またはインタフェース名
	  (たとえば <devicename>ed0</devicename>) を
	  指定することができます.
	  インタフェースユニット番号はオプションで,
	  ワイルドカードで指定することが できます. たとえば,
	  <literal>ppp*</literal> はすべてのカーネル PPP
	  インタフェースに マッチします.</para>

	<para><replaceable>address/mask</replaceable> の指定は:

	  <screen><replaceable>address</replaceable></screen>

	  または

	  <screen><replaceable>address</replaceable>/<replaceable>mask-bits</replaceable></screen>

	  または

	  <screen><replaceable>address</replaceable>:<replaceable>mask-pattern</replaceable></screen>
	</para>

	<para>IP
	  アドレスのかわりに有効なホスト名を指定することも可能です.
	  <option><replaceable>mask-bits</replaceable></option>
	  はアドレスマスクで上位何ビットを１にするべきかを
	  示す十進数値です. たとえば次の指定,
	  <literal>192.216.222.1/24</literal> はクラス C のサブネット
	  (この場合 192.216.222) の任意のアドレスにマッチする
	  マスクを作成します.
	  <option><replaceable>mask-pattern</replaceable></option>
	  は与えられたアドレスと 論理 AND される IP アドレスです.
	  キーワード <literal>any</literal> は<quote>任意の IP
	  アドレス</quote>を指定するために
	  使用することができます.</para>

	<para>ブロックするポート番号は以下のように指定します:

	  <cmdsynopsis>
	    <arg choice="plain"><replaceable>port</replaceable><arg>,
		<replaceable>port</replaceable><arg>,
		  <replaceable>port</replaceable><arg>&hellip;
		  </arg></arg></arg></arg>
	  </cmdsynopsis>

	  のように単独のポートまたはポートのリストを指定します.
	  または

	  <cmdsynopsis>
	    <arg choice="plain"><replaceable>port</replaceable>-
	      <replaceable>port</replaceable></arg>
	  </cmdsynopsis>

	  のようにポートの範囲を指定します.
	  単独のポートとポートのリストを
	  組み合わせて指定することも可能ですが,
	  その場合は常に範囲の方を
	  最初に指定しなければなりません.</para>

	<para>使用可能な <emphasis> オプション </emphasis> は:</para>

	<variablelist>
	  <varlistentry><term>frag</term>
	    <listitem>
	      <para>データグラムの最初の
		フラグメントでなければマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>in</term>
	    <listitem>
	      <para>入力途中のパケットであればマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>out</term>
	    <listitem>
	      <para>出力途中のパケットであればマッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>ipoptions <replaceable>spec</replaceable></term>
	    <listitem>
	      <para>IP ヘッダが <replaceable>spec</replaceable>
		に指定された カンマで区切られた
		オプションのリストを含んでいればマッチします.
		サポートされている IP オプションのリストは:
		<literal>ssrr</literal> (ストリクトソースルート),
		<literal>lsrr</literal> (ルーズソースルート),
		<literal>rr</literal> (レコードパケットルート),
		そして <literal>ts</literal> (タイムスタンプ) です.
		特定のオプションを含まないことを指定するには
		<literal>!</literal> を先頭につけます.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>established</term>
	    <listitem>
	      <para>パケットが既に確立されている TCP
		コネクションの一部であれば (つまり RST または ACK
		ビットがセットされていれば) マッチします.
		<emphasis>established</emphasis>
		ルールをチェーンの最初の方に置くことで,
		ファイアウォールのパフォーマンスを向上させることが
		できます.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>setup</term>
	    <listitem>
	      <para>パケットが TCP
		コネクションを確立しようとするものであれば (SYN
		ビットがセットされ ACK ビットはセットされていなければ)
		マッチします.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>tcpflags <replaceable>flags</replaceable></term>
	    <listitem>
	      <para>TCP ヘッダが <replaceable>flags</replaceable>
		に指定された カンマで区切られたフラグの
		リストを含んでいればマッチします.
		サポートされているフラグは, <literal>fin</literal>,
		<literal>syn</literal>, <literal>rst</literal>,
		<literal>psh</literal>, <literal>ack</literal> と
		<literal>urg</literal> です.
		特定のフラグを含まないことを指定するには
		<literal>!</literal> を先頭につけます.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>icmptypes <replaceable>types</replaceable></term>
	    <listitem>
	      <para>ICMP タイプが <replaceable>types</replaceable>
		リストに 存在していればマッチします.
		リストはタイプの範囲または個々のタイプを
		カンマで区切った任意の組合せで指定できます.
		一般的に使用されている ICMP タイプは:
		<literal>0</literal> エコーリプライ (ping リプライ),
		<literal>3</literal> 相手先到達不可能,
		<literal>5</literal> リダイレクト,
		<literal>8</literal> エコーリクエスト (ping
		リクエスト), そして <literal>11</literal> 時間超過
		(&man.traceroute.8; で使用されているように,  TTL
		満了を示すのに使用されます) です.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>IPFW ルールリストの表示</title>

	<para>この形式での使用法は:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg>-a</arg>
	    <arg>-t</arg>
	    <arg>-N</arg>
	    <arg choice="plain">l</arg>
	  </cmdsynopsis>
	</para>

	<para>この形式で使用する際に有効なフラグは三つあります:</para>

	<variablelist>
	  <varlistentry><term>-a</term>
	    <listitem>
	      <para>リスト表示の際にカウンタの値も表示します.
		このオプションは アカウンティングカウンタの
		内容を見る唯一の手段です.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>-t</term>
	    <listitem>
	      <para>各チェーンエントリが最後に
		マッチした時刻を表示します.  この時刻表示は
		  &man.ipfw.8; ユーティリティで使用される入力形式と
		互換性がありません.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry><term>-N</term>
	    <listitem>
	      <para>(可能であれば)
		アドレスやサービス名を文字列に変換して表示します.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>IPFW ルールのフラッシュ</title>

	<para>チェーンをフラッシュするには:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg choice="plain">flush</arg>
	  </cmdsynopsis>
	</para>

	<para>カーネルに固定されているデフォルトルール (インデックス
	  65535 番)  以外の,
	  ファイアウォールチェーンの中のすべてのエントリを削除します.
	  デフォルトではすべてのパケットが拒絶されるので,
	  一旦これを実行すると,
	  パケットを許可するエントリがチェーンに追加されるまで,
	  あなたのシステムがネットワークから切り放されてしまいます.
	  そのため,
	  ルールのフラッシュをおこなうときは注意が必要です.</para>
      </sect3>

      <sect3>
	<title>IPFW パケットカウンタのクリア</title>

	<para>一つまたはそれ以上のパケットカウンタをクリアするためには:
	  <cmdsynopsis>
	    <command>ipfw</command>
	    <arg choice="plain">zero</arg>
	    <arg choice="opt"><replaceable>index</replaceable></arg>
	  </cmdsynopsis>
	</para>

	<para><replaceable>index</replaceable> が指定されていなければ,
	  すべてのパケットカウンタが クリアされます.
	  <replaceable>index</replaceable> が指定されていれば,
	  特定のチェーンエントリだけが クリアされます.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>ipfw に対するコマンドの例</title>

      <para>このコマンドは, ホスト <hostid
	  role="fqdn">evil.crackers.org</hostid> から ホスト <hostid
	  role="fqdn">nice.people.org</hostid> の telnet ポートへの
	すべてのパケットを拒絶します:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from evil.crackers.org to nice.people.org 23</userinput></screen>

      <para>次の例は, ネットワーク <hostid
	  role="domainname">crackers.org</hostid> (クラス C) 全体から
	マシン <hostid role="fqdn">nice.people.org</hostid>
	(の任意のポート) への 任意の TCP トラフィックを拒絶し,
	ログを取ります.</para>

      <screen>&prompt.root; <userinput>ipfw add deny log tcp from evil.crackers.org/24 to nice.people.org</userinput></screen>

      <para>あなたの内部ネットワーク (クラス C のサブネット) に対する
	X セッションを 張れないようにする場合,
	以下のコマンドで必要なフィルタリングがおこなえます:</para>

      <screen>&prompt.root; <userinput>ipfw add deny tcp from any to my.org/28 6000 setup</userinput></screen>

      <para>アカウンティングレコードを見るには:

	<screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

	または短縮形式で</para>

      <screen>&prompt.root; <userinput>ipfw -a l</userinput></screen>

      <para>最後にチェーンエントリがマッチした
	時刻を見ることもできます.</para>

      <screen>&prompt.root; <userinput>ipfw -at l</userinput></screen>
    </sect2>

    <sect2>
      <title>パケットフィルタリングファイアウォールの構築</title>

      <note>
	<para>以下の提案は, ただの提案にすぎません:
	  必要な処理はそれぞれのファイアウォールで異なるため,
	  あなた独自の要求にあったファイアウォールを構築する方法を
	  ここで述べることはできないのです.</para>
      </note>

      <para>最初にファイアウォールをセットアップするとき,
	コントロールされた環境でファイアウォールホストの
	設定がおこなえるような
	テストベンチセットアップが用意できない場合には,
	カーネルのログ取りを
	有効にしてログ取り版のコマンドを使用することを
	強くおすすめします.  そうすることで,
	大した混乱や中断なしに問題となる範囲の特定と処置を
	素早くおこなうことができます.
	初期セットアップフェーズが完了してからであっても,
	アタックの可能性のあるアクセスをトレースしたり,
	要求の変化に応じてファイアウォールルールを
	変更したりできるので,  `deny'
	に対するログ取りをおこなうことをおすすめします.</para>

      <note>
	<para><command>accept</command>
	  コマンドのログ取りをおこなっていると,
	  ファイアウォールをパケットが一つ通過する毎に 1
	  行のログが生成されるため <emphasis>大量の</emphasis>
	  ログデータが発生します.  そのため, 大規模な ftp/http
	  転送などをおこなうと, システムが非常に 遅くなってしまいます.
	  また, パケットが通過するまでにカーネルにより
	  多くの仕事を要求するため,  パケットのレイテンシ (latency)
	  を増加させてしまいます.  syslogd
	  もログをディスクに記録するなど, より多くの CPU タイムを
	  使用し始め, 実に容易に <filename>/var/log</filename>
	  が置かれているパーティションを
	  パンクさせてしまう可能性があります.</para>
      </note>

      <para>ファイアウォールは, 
	<filename>/etc/rc.conf.local</filename> か, もしくは
	<filename>/etc/rc.conf</filename> によって有効化されるべきです.
        関連マニュアルページには, どのドアノブ(訳注:
        ポートや IP アドレスなど,
        ネットワークからの入口を示すもののこと)に手をつければ良いのかに
        ついての説明と, ファイアウォール設定の既定値のリストがあります.
        もし, 設定の既定値を使わない場合には,
        <command>ipfw list</command> とすることで,
        現在のルールセットを <filename>rc.conf</filename> から読み込める形で
        ファイルに出力することができます.
        また, <filename>/etc/rc.conf.local</filename> や
	<filename>/etc/rc.conf</filename> によってファイアウォールを
        有効化しない場合には, ファイアウォールの有効化がすべての
        IP インタフェイス設定より先に行なわれるように確認することが重要です.
      </para>

      <para>次の問題は, ファイアウォールが実際には何を <emphasis> する
	</emphasis> べきかです !
	これは外部からそのネットワークへのどんなアクセスを許したいか,
	また内部から外界へのアクセスを
	どのくらい許したいかに大きく依存します.
	いくつか一般的なルールを挙げると:</para>

      <itemizedlist>
	<listitem>
	  <para>1024 番以下のポートへのすべての TCP
	    入力アクセスをブロックします.  ここは finger, SMTP (mail)
	    そして telnet など, 最もセキュリティに敏感な
	    サービスが存在する場所だからです.</para>
	</listitem>

	<listitem>
	  <para><emphasis> すべての </emphasis> 入力 UDP
	    トラフィックをブロックします.  これは UDP
	    を使用しているサービスで有用なものは極めて少ないうえ,
	    有用なトラフィック (たとえば Sun の RPC と NFS プロトコル)
	    は,  通常セキュリティに対する脅威となるためです.  UDP
	    はコネクションレスプロトコルであるため,  入力 UDP
	    トラフィックを拒絶することは すなわち出力 UDP
	    トラフィックに対する返答をも ブロックすることになるので,
	    このことはそれなりの不利益をもたらします.  たとえば外部の
	    archie (prospero) サーバを使用している (内部の) ユーザに
	    とって問題となる可能性があります.  もし archie
	    へのアクセスを許したければ, 191 番と 1525 番のポートから
	    任意の UDP
	    ポートへ来るパケットがファイアウォールを通過することを
	    許可しなければなりません.  123
	    番のポートから来るパケットは ntp パケットで,
	    これも通過の許可を考慮する必要がある
	    もう一つのサービスです.</para>
	</listitem>

	<listitem>
	  <para>外部から 6000
	    番のポートへのトラフィックをブロックします.  6000
	    番のポートは X11 サーバへのアクセスに使用されるポートで,
	    セキュリティに対する脅威となりえます.
	    (特に自分のワークステーションで  <command>xhost
	      +</command>
	    をおこなう癖を持っている人がいればなおさらです).  X11
	    は実際に 6000 番以降のポートを使用する可能性があるため,
	    通過許可に 上限を定めると,
	    そのマシンで走らせることのできる X ディスプレイの
	    個数が制限されます.  RFC 1700 (Assigned Numbers)
	    で定義されているように, 上限は 6063 です.</para>
	</listitem>

	<listitem>
	  <para>内部のサーバ (たとえば SQL サーバなど)
	    がどのポートを使用するかを チェックします.
	    それらのポートは通常, 上で指定した 1-1024
	    番の範囲から外れていますので,
	    これらも同様にブロックしておくことは
	    おそらく良い考えです.</para>
	</listitem>
      </itemizedlist>

      <para>これとは別のファイアウォール設定に 関するチェックリストが
	CERT から 入手可能です.  <ulink
	  url="http://www.cert.org/tech_tips/packet_filtering.html">http://www.cert.org/tech_tips/packet_filtering.html</ulink></para>

      <para>前にも述べたように, これはただの <emphasis> ガイドライン
	</emphasis> にすぎません.
	ファイアウォールでどのようなフィルタルールを使用するかは,
	あなた自身が 決めなければなりません.
	これまでのアドバイスにしたがったにも関わらず,
	誰かがあなたのネットワークに 侵入してきたとしても,
	わたしたちは「いかなる」責任もとることはできません.</para>
    </sect2>
  </sect1>

  <sect1 id="openssl">
    <title>OpenSSL</title>

    <para>FreeBSD 4.0 では, OpenSSL ツールキットが基本構成の一部に
      含まれています. <ulink url="http://www.openssl.org/">OpenSSL</ulink> は,
      Secure Sockets Layer v2/v3 (SSLv2/SSLv3) や Transport Layer
      Security v1 (TLSv1) ネットワークセキュリティプロトコルと同様の
      多目的な暗号化ライブラリを提供します.</para>

    <para>しかしながら, OpenSSL に含まれるアルゴリズムのひとつ
      (特に IDEA) は, 合衆国内, その他の地域において,
      特許により保護されています. そのため,
      無制約な利用は許されません. IDEA は
      FreeBSD の OpenSSL 配布に含まれていますが, デフォルトではコンパ
      イルされません. もし IDEA を使いたいなら, そしてあなたがそのライ
      センス条項に合致するなら, /etc/make.conf の中の MAKE_IDEA スイッ
      チを有効にして, 'make world' でソースをリビルドしてください.
      </para>

    <para>現在は RSA アルゴリズムはアメリカとその他の国で自由に利用で
      きます. 以前は特許により保護されていました.</para>

    <sect2>
      <title>ソースコードのインストール</title>
      
      <para>OpenSSL は <literal>src-crypto</literal> と
        <literal>src-secure</literal> cvsup コレクションの一部です. 
        FreeBSD のソースコードの取得と更新の詳細は,
        <link linkend="mirrors">FreeBSD
          の入手</link>の項を参照して下さい.</para>
    </sect2>
  </sect1>

  <sect1 id="ipsec">
    <title>IPsec</title>
    <para><emphasis>原作: &a.shin;, 5 March
        2000.</emphasis></para>
    <para><emphasis>訳: &a.jp.hino;, 14 March
        2001.</emphasis></para>

    <para>IPsec 機構は, IP 層とソケット層の両方に対して安全な通
      信を提供します.  実装の詳細に関しては <ulink
      url="http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook/ipv6.html">The
      Developers' Handbook</ulink> を参照してください.
      <!-- si006:2001/08/11 - developers handbook is not translated yet. -->
      </para>

    <para>現在の IPsec の実装は, トランスポートモードとトンネルモード
      の両方をサポートしています. しかし, トンネルモードにはいくつかの
      制限事項があります. <ulink
      url="http://www.kame.net/newsletter/">http://www.kame.net/newsletter/
      </ulink> にはより総合的な例が載っています.</para>

    <para>ここで述べる機能を利用するには, 以下のオプションをカーネルコ
      ンパイル時に指定する必要があることにご注意ください.</para>

    <programlisting>options          IPSEC              #IP security
options          IPSEC_ESP          #IP security (crypto; define w/IPSEC)</programlisting>

    <sect2>
      <title>IPv4 におけるトランスポートモードの例</title>

     
      <para>ホスト A (10.2.3.4) とホスト B (10.6.7.8) との間に安全なチャ
        ネルを配置するために, セキュリティアソシエーションを設定しましょ
        う. ここでは, 少し込み入った例を示します. ホスト A からホストB 
        へは old AH のみを使います. ホスト B からホスト A へは new AH 
        と new ESP を組み合わせます.</para>

      <para>ここで "AH"/"new AH"/"ESP"/"new ESP" に対応するアルゴリズ
        ムを決めないといけません. アルゴリズムの名前を知るには, 
        &man.setkey.8; マニュアルページをご覧ください. ここでは, AH に
        MD5 を, new AH には new-HMAC-SHA1 を, new ESP には 8 バイト IV 
        の new-DES-expIV を選びました.</para>

      <para>鍵長はそれぞれのアルゴリズムに大きく依存します. たとえば,
        MD5 では鍵長は 16 バイトでなければなりませんし, new-HMAC-SHA1 
        では 20 バイトでなければなりませんし, new-DES-expIV では 8 バ
        イトでなければなりません. ここではそれぞれ "MYSECRETMYSECRET",
        "KAMEKAMEKAMEKAMEKAME", "PASSWORD", とします.</para>

      <para>次に, それぞれのプロトコルに対して SPI (セキュリティパラメー
        タインデックス: Security Parameter Index) を割り当てます. 三種
        類のセキュリティヘッダ (ホスト A からホスト B に一つ, ホスト B 
        から ホスト A に二つ) を生成するので, この安全なチャネルには三
        つの SPI が必要になることに注意してください. さらに, SPI は 
        256 以上である必要があることにも注意してください. ここではそれ
        ぞれ 1000, 2000, 3000 を割り当てます.</para>

      <screen>

	           (1)
	ホスト A ------> ホスト B

	(1)PROTO=AH
		ALG=MD5(RFC1826)
		KEY=MYSECRETMYSECRET
		SPI=1000

	           (2.1)
	ホスト A <------ ホスト B
	         <------
	           (2.2)

	(2.1)
	PROTO=AH
		ALG=new-HMAC-SHA1(new AH)
		KEY=KAMEKAMEKAMEKAMEKAME
		SPI=2000

	(2.2)
	PROTO=ESP
		ALG=new-DES-expIV(new ESP)
			IV length = 8
		KEY=PASSWORD
		SPI=3000

      </screen>

      <para>次に, セキュリティアソシエーションを設定しましょう. ホスト
        A とホスト B の両方で, &man.setkey.8; を実行します:</para>

      <screen>

&prompt.root; <command>setkey -c</command>
add 10.2.3.4 10.6.7.8 ah-old  1000 -m transport -A keyed-md5 "MYSECRETMYSECRET" ;
add 10.6.7.8 10.2.3.4 ah  2000 -m transport -A hmac-sha1 "KAMEKAMEKAMEKAMEKAME" ;
add 10.6.7.8 10.2.3.4 esp 3000 -m transport -E des-cbc "PASSWORD" ;
^D

     </screen>

     <para>実際には, セキュリティポリシのエントリが定義されるまでは
       IPsec による通信は行われません. この例の場合, 両方のホストを設
       定する必要があります.</para>

     <screen>

A で:

&prompt.root; <command>setkey -c</command>
spdadd 10.2.3.4 10.6.7.8 any -P out ipsec
	ah/transport/10.2.3.4-10.6.7.8/require ;
^D

B で:

&prompt.root; <command>setkey -c</command>
spdadd 10.6.7.8 10.2.3.4 any -P out ipsec
	esp/transport/10.6.7.8-10.2.3.4/require ;
spdadd 10.6.7.8 10.2.3.4 any -P out ipsec
	ah/transport/10.6.7.8-10.2.3.4/require ;
^D


  ホスト A -------------------------------------> ホスト B
  10.2.3.4                                       10.6.7.8
          |                                     |
          ========== old AH keyed-md5 ==========>

          <========= new AH hmac-sha1 ===========
          <========= new ESP des-cbc ============

     </screen>
    </sect2>

    <sect2>
      <title>IPv6 におけるトランスポートモードの例</title>

      <para>IPv6 を使ったもう一つの例.</para>

      <para>ホスト-A とホスト-B 間の TCP ポート番号 110 番の通信には, 
        ESP トランスポートモードが推奨されます.</para>

      <screen>

              ============ ESP ============
              |                           |
          ホスト-A                      ホスト-B
          fec0::10 -------------------- fec0::11

      </screen>

      <para>暗号化アルゴリズムは blowfish-cbc で, その鍵は "kamekame", 
        認証アルゴリズムは hmac-sha1 で, その鍵は "this is the test
        key" とします. ホスト-A の設定:</para>

      <screen>

        &prompt.root; <command>setkey -c</command> &lt;&lt;<filename>EOF</filename>
        spdadd fec0::10[any] fec0::11[110] tcp -P out ipsec
                esp/transport/fec0::10-fec0::11/use ;
        spdadd fec0::11[110] fec0::10[any] tcp -P in ipsec
                esp/transport/fec0::11-fec0::10/use ;
        add fec0::10 fec0::11 esp 0x10001
                -m transport
                -E blowfish-cbc "kamekame"
                -A hmac-sha1 "this is the test key" ;
        add fec0::11 fec0::10 esp 0x10002
                -m transport
                -E blowfish-cbc "kamekame"
                -A hmac-sha1 "this is the test key" ;
        EOF

      </screen>

      <para>そしてホスト-B の設定:</para>

      <screen>
        &prompt.root; <command>setkey -c</command> &lt;&lt;<filename>EOF</filename>
        spdadd fec0::11[110] fec0::10[any] tcp -P out ipsec
                esp/transport/fec0::11-fec0::10/use ;
        spdadd fec0::10[any] fec0::11[110] tcp -P in ipsec
                esp/transport/fec0::10-fec0::11/use ;
        add fec0::10 fec0::11 esp 0x10001 -m transport
                -E blowfish-cbc "kamekame"
                -A hmac-sha1 "this is the test key" ;
        add fec0::11 fec0::10 esp 0x10002 -m transport
                -E blowfish-cbc "kamekame"
                -A hmac-sha1 "this is the test key" ;
        EOF

      </screen>

      <para>SP の方向に注意してください.</para>
    </sect2>
 
   <sect2>
      <title>IPv4 におけるトンネルモードの例</title>

      <para>二台のセキュリティゲートウェイ間のトンネルモード</para>

      <para>セキュリティプロトコルは old AH トンネルモード, すなわち 
      RFC1826 で指定されるものです. 認証アルゴリズムは "this is the
      test" を鍵とする keyed-md5 です.</para>

      <screen>

                             ======= AH =======
                             |                |
     ネットワーク-A   ゲートウェイ-A    ゲートウェイ-B   ネットワーク-B
        10.0.1.0/24 ---- 172.16.0.1 ----- 172.16.0.2 ---- 10.0.2.0/24

      </screen>

      <para>ゲートウェイ-A における設定:</para>

      <screen>

        &prompt.root; <command>setkey -c</command> &lt;&lt;<filename>EOF</filename>
        spdadd 10.0.1.0/24 10.0.2.0/24 any -P out ipsec
                ah/tunnel/172.16.0.1-172.16.0.2/require ;
        spdadd 10.0.2.0/24 10.0.1.0/24 any -P in ipsec
                ah/tunnel/172.16.0.2-172.16.0.1/require ;
        add 172.16.0.1 172.16.0.2 ah-old 0x10003 -m any
                -A keyed-md5 "this is the test" ;
        add 172.16.0.2 172.16.0.1 ah-old 0x10004 -m any
                -A keyed-md5 "this is the test" ;

        EOF

      </screen>

      <para>上記の例のように, もしポート番号フィールドを書かないと, 
        "[any]" と同じ意味になります. `-m' は使用される SA のモードを
        指定します. "-m any" はセキュリティプロトコルのモードのワイル
        ドカードを意味します. この SA をトンネルモードとトランスポート
        モードの両方で使用できます.</para>

      <para>そしてゲートウェイ-B では:</para>

      <screen>

        &prompt.root; <command>setkey -c</command> &lt;&lt;<filename>EOF</filename>
        spdadd 10.0.2.0/24 10.0.1.0/24 any -P out ipsec
                ah/tunnel/172.16.0.2-172.16.0.1/require ;
        spdadd 10.0.1.0/24 10.0.2.0/24 any -P in ipsec
                ah/tunnel/172.16.0.1-172.16.0.2/require ;
        add 172.16.0.1 172.16.0.2 ah-old 0x10003 -m any
                -A keyed-md5 "this is the test" ;
        add 172.16.0.2 172.16.0.1 ah-old 0x10004 -m any
                -A keyed-md5 "this is the test" ;

        EOF

      </screen>

      <para>二台のセキュリティゲートウェイ間の SA の束を作ります</para>

      <para>ゲートウェイ-A とゲートウェイ-B の間では, AH トランスポー
      トモードと ESP トンネルモードが要求されます. この例では, ESP ト
      ンネルモードが先に適用され, 次に AH トランスポートモードが適用さ
      れます.</para>

      <screen>

                            ========== AH =========
                            |  ======= ESP =====  |
                            |  |               |  |
    ネットワーク-A     ゲートウェイ-A     ゲートウェイ-B     ネットワーク-B
    fec0:0:0:1::/64 --- fec0:0:0:1::1 ---- fec0:0:0:2::1 --- fec0:0:0:2::/64

      </screen>
    </sect2>

    <sect2>
      <title>IPv6 におけるトンネルモードの例</title>

      <para>暗号化アルゴリズムは 3des-cbc, ESP の認証アルゴリズムは
        hmac-sha1 とします. AH の認証アルゴリズムは hmac-md5 とします. 
        ゲートウェイ-A での設定は:</para>

      <screen>

        &prompt.root; <command>setkey -c</command> &lt;&lt;<filename>EOF</filename>
        spdadd fec0:0:0:1::/64 fec0:0:0:2::/64 any -P out ipsec
                esp/tunnel/fec0:0:0:1::1-fec0:0:0:2::1/require
                ah/transport/fec0:0:0:1::1-fec0:0:0:2::1/require ;
        spdadd fec0:0:0:2::/64 fec0:0:0:1::/64 any -P in ipsec
                esp/tunnel/fec0:0:0:2::1-fec0:0:0:1::1/require
                ah/transport/fec0:0:0:2::1-fec0:0:0:1::1/require ;
        add fec0:0:0:1::1 fec0:0:0:2::1 esp 0x10001 -m tunnel
                -E 3des-cbc "kamekame12341234kame1234"
                -A hmac-sha1 "this is the test key" ;
        add fec0:0:0:1::1 fec0:0:0:2::1 ah 0x10001 -m transport
                -A hmac-md5 "this is the test" ;
        add fec0:0:0:2::1 fec0:0:0:1::1 esp 0x10001 -m tunnel
                -E 3des-cbc "kamekame12341234kame1234"
                -A hmac-sha1 "this is the test key" ;
        add fec0:0:0:2::1 fec0:0:0:1::1 ah 0x10001 -m transport
                -A hmac-md5 "this is the test" ;

        EOF

      </screen>

      <para>異なる通信端での SA を作る</para>

      <para>ホスト-A とゲートウェイ-A の間では ESP トンネルモードが要
        求されています. 暗号化アルゴリズムは cast128-cbc で, ESP の認
        証アルゴリズムは hmac-sha1 です. ホスト-A とホスト-B との間で
        は ESP トランスポートモードが推奨されています. 暗号化アルゴリ
        ズムは rc5-cbc で, ESP の認証アルゴリズムは hmac-md5 です.
        </para>

      <screen>

              ================== ESP =================
              |  ======= ESP =======                 |
              |  |                 |                 |
            ホスト-A        ゲートウェイ-A         ホスト-B
          fec0:0:0:1::1 ---- fec0:0:0:2::1 ---- fec0:0:0:2::2

      </screen>

      <para>ホスト-A での設定:</para>

      <screen>

        &prompt.root; <command>setkey -c</command> &lt;&lt;<filename>EOF</filename>
        spdadd fec0:0:0:1::1[any] fec0:0:0:2::2[80] tcp -P out ipsec
                esp/transport/fec0:0:0:1::1-fec0:0:0:2::2/use
                esp/tunnel/fec0:0:0:1::1-fec0:0:0:2::1/require ;
        spdadd fec0:0:0:2::1[80] fec0:0:0:1::1[any] tcp -P in ipsec
                esp/transport/fec0:0:0:2::2-fec0:0:0:l::1/use
                esp/tunnel/fec0:0:0:2::1-fec0:0:0:1::1/require ;
        add fec0:0:0:1::1 fec0:0:0:2::2 esp 0x10001
                -m transport
                -E cast128-cbc "12341234"
                -A hmac-sha1 "this is the test key" ;
        add fec0:0:0:1::1 fec0:0:0:2::1 esp 0x10002
                -E rc5-cbc "kamekame"
                -A hmac-md5 "this is the test" ;
        add fec0:0:0:2::2 fec0:0:0:1::1 esp 0x10003
                -m transport
                -E cast128-cbc "12341234"
                -A hmac-sha1 "this is the test key" ;
        add fec0:0:0:2::1 fec0:0:0:1::1 esp 0x10004
                -E rc5-cbc "kamekame"
                -A hmac-md5 "this is the test" ;

        EOF
      </screen>
    </sect2>
 </sect1>

  <sect1 id="openssh">
    <title>OpenSSH</title>

    <para><emphasis>原作: &a.chern;,
        2001 年 4 月 21 日. </emphasis>
    </para>

    <para>セキュアシェル (secure shell) はリモートマシンへのセキュアなアクセスに使われる
      ネットワーク接続ツールのセットです.  それは <command>rlogin</command>,
      <command>rsh</command>, <command>rcp</command>,
      <command>telnet</command> を直接置き換えて使うことができます.
      また, 他のあらゆる TCP/IP 接続を
      ssh 経由でセキュアにトンネル/フォワードすることもできます.
      ssh はすべてのトラフィックを暗号化し,
      盗聴や接続の乗っ取り等のネットワークレベルの攻撃を事実上無効化します.</para>

    <para>OpenSSH は OpenBSD プロジェクトによって維持管理されており, SSH v1.2.12 
      に最新のすべてのバグ修正と更新を適用したものをベースにしています.
      OpenSSH クライアントは SSH プロトコル 1 と 2 の両方に互換性があります.
      OpenSSH は FreeBSD 4.0 以降ベースシステムに取り込まれています.</para>

    <sect2>
      <title>OpenSSH を使うことの利点</title>

      <para>&man.telnet.1; や &man.rlogin.1;
        を使う場合, 一般にデータはネットワークを平文で流れます.
        ネットワークをクライアントとサーバの間のどこかで盗聴することで
        あなたのユーザ/パスワード情報やセション中を流れるデータを盗むことが可能です.
        OpenSSH はこれらを予防する為にさまざまな認証と暗号化の方法を提供します.</para>
    </sect2>

    <sect2>
      <title>sshd を有効にする</title>

      <para><filename>rc.conf</filename> ファイルに
        以下の行を追加してください.</para>

      <screen>sshd_enable="YES"</screen>

      <para>次に起動したときから ssh デーモンが起動します.
        もしくは単に <command>sshd</command>
        デーモンを実行しても構いません.</para>
    </sect2>

    <sect2>
      <title>SSH クライアント</title>
      
      <para>&man.ssh.1; ユーティリティは
        &man.rlogin.1; と同様に働きます.</para>

      <screen>&prompt.root <userinput>ssh user@foobardomain.com</userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'foobardomain.com' added to the list of known hosts.
user@foobardomain.com's password: <userinput>*******</userinput></screen>

      <para>ログインは rlogin や telnet でセションを張った時と同様に続きます.
        SSH はクライアントが接続した時,
        サーバの信頼性の検証のために鍵指紋システム
        (key fingerprint system) を利用します.
        初めての接続の際にのみ, ユーザは 'yes' と入力することを要求されます.
        これ以降の login では保存されていた鍵指紋を照合することで検証されます.
        SSH クライアントは保存されていた鍵指紋が
        login しようとした際に送られてきたものと異なっていた場合には警告を表示します.
        指紋は <filename>~/.ssh/known_hosts</filename> に保存されます.</para>
    </sect2>
    
    <sect2>
      <title>Secure copy</title>

      <para><command>scp</command> コマンドが  rcp と異なるのは,
        セキュアになっているという点だけです.
        つまりローカルのファイルをリモートマシンへ,
        あるいはリモートマシンのファイルをローカルにコピーします.</para>

      <screen>&prompt.root <userinput> scp <replaceable>user@foobardomain.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@foobardomain.com's password: 
COPYRIGHT            100% |*****************************|  4735       
00:00    
&prompt.root</screen>

      <para>前回の例でこのホストの指紋がすでに保存されていれば
        この <command>scp</command> を使う時に検証が行なわれます.</para>
    </sect2>

    <sect2>
      <title>設定</title>

      <para>システム全体の設定ファイルは, OpenSSH デーモン,
        クライアントの両方とも <filename>/etc/ssh</filename> ディレクトリにあります.</para>

      <para><filename>ssh_config</filename> はクライアントの動作設定,
        <filename>sshd_config</filename> はデーモンの動作設定を行ないます.</para>
    </sect2>

    <sect2>
      <title>ssh-keygen</title>

      <para>パスワードの代わりに &man.ssh-keygen.1; を使って
        ユーザの認証用の RSA 暗号鍵を作ることができます.</para>

      <screen>&prompt.user <userinput>ssh-keygen</userinput>
Initializing random number generator...
Generating p:  .++ (distance 66)
Generating q:  ..............................++ (distance 498)
Computing the keys...
Key generation complete.
Enter file in which to save the key (/home/user/.ssh/identity):
Enter passphrase:
Enter the same passphrase again:
Your identification has been saved in /home/user/.ssh/identity.
...</screen>

      <para>&man.ssh-keygen.1; は認証に使う為の公開鍵と秘密鍵のペアを作ります.
        秘密鍵は <filename>~/.ssh/identity</filename> に保存され,
        公開鍵は <filename>~/.ssh/identity.pub</filename> に保存されます.
        公開鍵はリモートマシンの <filename>~/.ssh/authorized_keys</filename>
        にも置かなければなりません.</para>

      <para>これでパスワードの代わり RSA 認証を使って
        リモートマシンに接続できるようになったはずです.</para>

      <para>&man.ssh-keygen.1; でパスフレーズを使っている場合は,
        ユーザは秘密鍵を使うために毎回パスフレーズの入力を行なう必要があります.</para>

      <para>&man.ssh-agent.1; と &man.ssh-add.1; は
        多重にパスワード化された秘密鍵の管理に使われます.</para>
    </sect2>

    <sect2>
      <title>SSH トンネリング</title>

      <para>OpenSSH は暗号化されたセションの中に他のプロトコルを
        カプセル化することでトンネルを作ることができます.</para>

      <para>以下のコマンドは &man.ssh.1; で telnet
        用のトンネルを作成します.</para>

      <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.bar.com</replaceable></userinput>
&prompt.user;</screen>

      <itemizedlist>
        <listitem>
          <para><emphasis>-2</emphasis> は &man.ssh.1; にプロトコル
            2 を使うことを指示します.
            (古い ssh サーバを使っているときには指定しないでください)</para>
        </listitem>
        
        <listitem>
          <para><emphasis>-N</emphasis>
            はトンネルだけでコマンドはないことを示します.
            省略されると &man.ssh.1; は通常のセッションを開始します.</para>
        </listitem>
        
        <listitem><para><emphasis>-f</emphasis> は &man.ssh.1;
            にバックグラウンド実行を強制します.</para>
        </listitem>
        
        <listitem>
          <para><emphasis>-L</emphasis> はローカルトンネルとして
            <replaceable>localport:localhost:remoteport</replaceable>
            形式を指示します.
          </para>
        </listitem>
         
        <listitem>
          <para><replaceable>foo.bar.com</replaceable> はリモート/ターゲットの
            SSH サーバです.
          </para>
        </listitem>
      </itemizedlist>

      <para>SSH のトンネルは指定されたローカルホストとポートを listen する
        ソケットを作ることで実現されています.
        SSH はローカルのホスト/ポートへのすべての接続を SSH
        接続経由でリモートマシンの指定されたリモートポートへ
        転送 (フォワード) します.</para>

       <para>たとえば, ローカルホストのポート <replaceable>5023</replaceable>
        がリモートマシンの <replaceable>23</replaceable>
        に転送されるようになっているとします.
        <replaceable>23</replaceable> は telnet なのでこれは SSH
        トンネルを通るセキュアな telnet セッションを作ります.</para>

      <para>このようにして smtp や pop3, ftp 等のセキュアではない TCP
        プロトコルをカプセル化することができます.</para>

      <para>典型的な SSH トンネル</para>
      
      <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.foobar.com</replaceable></userinput>
user@mailserver.foobar.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.foobar.com ESMTP</screen>     

      <para>&man.ssh-keygen.1; と別のユーザアカウントを組み合わせて使うことで
        より透過的で悩まずに済むような SSH のトンネル環境を作ることができます.
        パスワードを入力するところで暗号鍵を使い,
        トンネルは別のユーザ権限で実行することが可能です.</para>
    </sect2>

    <sect2>
      <title>さらに知りたい人へ</title>

      <para><ulink url="http://www.openssh.com">OpenSSH</ulink></para>

      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1; 
        &man.ssh-agent.1; &man.ssh-add.1;</para>
      
      <para>&man.sshd.8; &man.sftp-server.8;</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
