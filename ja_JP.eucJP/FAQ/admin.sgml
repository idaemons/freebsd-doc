<!-- $Id: admin.sgml,v 1.2 1998-01-22 08:48:52 hanai Exp $ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.2 --> 

  <sect>
    <heading>システム管理<label id="admin"></heading>
    <p><em>訳: &a.nishika;.<newline>12 November 1997.</em>

    <sect1>
      <heading>システムスタートアップファイルはどこにあるのですか?</heading>

      <p>2.0.5R から 2.2.1R までは, プライマリコンフィグレーションファイルは
      <tt>/etc/sysconfig</tt> にあります. オプションはすべて, このファイルと
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?rc"
      name="/etc/rc"> および <tt>/etc/netstart</tt>といった, 
      別のファイルに指定されています. 

      <p>ファイル <tt>/etc/sysconfig</tt> を見て, システムに適合するように
      変更してください. このファイルはそれぞれの場所に何を書けばいいのかを表す
      コメントがたくさん書かれています. 

      <p>2.2.2 に続くリリース と 3.0 では, <tt>/etc/sysconfig</tt> は, 
      より分りやすい名前の <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)"
      name="rc.conf"> に改名され, それに従って
      書式もいくぶん改められます. <tt>/etc/netstart</tt> も
      <tt>/etc/rc.network</tt> に改名され, 全部のファイルを
      <tt><htmlurl url="http://www.freebsd.org/cgi/man.cgi?cp"
      name="cp"> /usr/src/etc/rc* /etc</tt>で一度にコピーすることが
      出来るようになります. 

      <p>ファイル <tt>/etc/rc.local</tt> は常にここにあり, <htmlurl
      url="http://www.freebsd.org/cgi/ports.cgi?^inn" name="INN">
      や <tt/http/ といった追加のサービス開始や
      カスタムオプションを記述するために使われるでしょう. 

      <p>ファイル <tt>/etc/rc.serial</tt> はシリアルポートの初期化
      (例えばポートの設定を固定したり等々) のためにあります. 

      <p>ファイル <tt>/etc/rc.i386</tt> は iBCS2 エミュレーションのような
      Intel アーキテクチャ固有の設定や PC システムコンソール設定のためにあります. 

      <p>2.1.0R からは, "ローカル" スタートアップファイルをディレクトリ 
      <tt>/etc/sysconfig</tt> (または <tt>/etc/rc.conf</tt>) 
      の中に作って指定することもできます:

      <verb>
        # Location of local startup files.
        local_startup=/usr/local/etc/rc.local.d
      </verb>

      <p>.sh で終わるそれぞれのファイルは, アルファベット順に実行されます. 

      <p>ファイル名を変えることなくある一定の順序で確実に実行したいのであれば, 
      順序が保証されるように以下のようにして, 
      それぞれのファイルの頭に数値をつけるようなデザインを
      使うことができます:

      <verb>
        10news.sh
        15httpd.sh
        20ssh.sh
      </verb>

      <p>この方法は見苦しく (あるいは SysV のように :-)) なりますが, 
      <tt>/etc/rc.local</tt> を 手品のような編集でソートするようなことなく
      ローカルの追加パッケージを使うためには, シンプルでしかもよく使われる
      手法ではあります. ほとんどの ports/packages は 
      <tt>/usr/local/etc/rc.d</tt> をローカルスタートアップディレクトリ
      であると仮定しています. 

    <sect1>
      <heading>簡単にユーザを追加するにはどうすればいいのですか?</heading>

      <p><htmlurl url="http://www.freebsd.org/cgi/man.cgi?adduser"
      name="adduser"> コマンドを使用してください. 

      <p>Ollivier Robert によって Perl で書かれた ``<tt/new-account/'' と
      呼ばれるパッケージもあります. これについては
      <tt>&lt;roberto@FreeBSD.ORG&gt;</tt> にたずねてみてください. 
      現在さらなる開発をおこなっています. 

      <p>また, ユーザを削除するには <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rmuser" name="rmuser">
      コマンドを使用してください. 

    <sect1>
      <heading>FreeBSD システムに新しいハードディスクを追加するには?</heading>

      <p>最も簡単な方法はインストールプログラムからおこなうことです. root で
      <tt>/stand/sysinstall</tt> を起動してインストールプログラム
      を利用することができます. 

      <p>また, インストールフロッピーディスクを持っている場合は, そこから
      リブートしてシステムが完全に動作していないインストールプログラムの内で, 
      パーティション & ラベルエディタを利用してください. 

      <p><label id="2_1-disklabel-fix">上記の方法でうまくいかないとか, 
      あなたが不可解なインタフェースを好む変わり者である場合は, 以下の 
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel"> コマンドを手動で使用する方法を読んでください:

      <p><em>警告: 注意深く読んで自分が何をおこなっているか理解する
      以外に方法はありません!  ここで説明されていることはシステム
      を「破壊する」かもしれません. 注意しておこなってください! 
      事前に「バックアップ」をおこなうことを忘れずに!</em>

      <p>2.1.5-RELEASE までの <tt /sysinstall/ は不具合いがあり, 
      ディスクラベルエディタで / に何かをマウントすることを
      強要します. <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?newfs"name="newfs">
      を実行する前に <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel">
      を手動で実行する必要があるでしょう. 
      つまり, パーティション分割の計算を自分でおこなうということです. 
      これは簡単だというウワサです :-)
      ''<tt>disklabel -r &lt;diskname&gt;</tt>'' 
      を実行してラベルのひな型が得られるかどうかを確認してください. 
      <em> (例えば </em>''<tt>disklabel -r /dev/rwd0s2</tt>''<em> は, 
      新しいディスクが wd0 つまり 1 台めの IDE ディスク, そして 
      FreeBSD スライスは二つめ, つまり s2 であることを仮定しています)
      </em>. 以下のようなものが出力されるはずです:-

      <verb>
        # /dev/rwd0s2:
        type: ESDI
        disk: wd0s2
        label:
        flags:
        bytes/sector: 512
        sectors/track: 63
        tracks/cylinder: 64
        sectors/cylinder: 4032
        cylinders: 610
        sectors/unit: 2459520
        rpm: 3600
        interleave: 1
        trackskew: 0
        cylinderskew: 0
        headswitch: 0           # milliseconds
        track-to-track seek: 0  # milliseconds
        drivedata: 0

        8 partitions:
        #        size   offset    fstype   [fsize bsize bps/cpg]
          c:  2459520        0    unused        0     0         # (Cyl. 0 - 609)
          e:  2459520        0    4.2BSD        0     0     0   # (Cyl. 0 - 609)
      </verb>

      <p>サイズ (size) が正しいことを確認してください. この例では, 
      2459520 sectors/unit x 512 bytes/sector / 2**20 (1 メガバイト) 
      = 1200 メガバイトとなっています. あとのものは (b/s, t/c, s/c,
      interleave, など), <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel"> から適切なデフォルト値が取得されますが, 
      古いディスクについては<ref id="ESDI" name="この注意事項">
      をご覧ください. 'fsize' はファイルシステム用の
      <ref id="fsize" name="フラグメントサイズ"> であり,'bsize' は 
      <ref id="bsize" name="ブロックサイズ"> です. 'c' は
      スライス全体をカバーするパーティション (またはスライスされていない
      ディスクではディスク全体) であり, そのまま残しておく必要があります. 
      <em>これはファイルシステムとして使用してはいけません</em>.
      'c' パーティションはディスクラベルが存在しない場合でもカーネルが
      存在するように見せかけている手品なのです. 

      <p>スライス全体を一つのファイルシステムとしたいようなごく普通の
      場合は, 'e' のエントリを修正する必要があります. ファイルシステム
      に妥当な値として fsize を 1024, bsize を 8192 
      (8 フラグメント/ブロック) に設定して, 'e' のエントリを以下のように
      修正します:-

      <verb>
        e:  2459520        0    4.2BSD     1024  8192
      </verb>

      <p>さて, 二つのファイルシステム用に二つのパーティションを
      作成したいいような (ちょっとだけ) 難しい場合です. <ref id="fsname" 
      name="BSD のネーミングの慣例">にしたがって, パーティションを
      <tt /wd0s2e/ &amp; <tt /wd0s2f/ のようにします. 1200MB を 'e' 
      用に 300MB, 残りの 900MB を 'f' に分割することにすると, 
      パーティションエントリは次のようになります:-

      <verb>
        8 partitions:
        #        size   offset    fstype   [fsize bsize bps/cpg]
        c:  2459520        0    unused        0     0         # (Cyl. 0 - 609)
        e:   614400        0    4.2BSD     1024  8192
        f:  1843200   614400    4.2BSD     1024  8192
      </verb>

      <p><bf /注:/ ''<tt>disklabel -e wd0s2</tt>'' で
      ディスクラベルを直接編集することができます. <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel"> を参照してください. 

      <p>FreeBSD 2.1.5 以降を使用していて, 他のシステムに関心がなく, 
      ディスク全体を FreeBSD 専用にするつもりなら, 以下のような手順を
      踏むことによって, 作業を短縮することも可能です. 

      <verb>
        # dd if=/dev/zero of=/dev/rwd0 count=100
        # disklabel -Brw wd0 auto
        # disklabel -e wd0
      </verb>

      <p>最初の <htmlurl url="http://www.freebsd.org/cgi/man.cgi?dd"
      name="dd"> コマンドは, カーネルのディスクコードを
      混乱させる可能性のある古いゴミが, ディスクの先頭に確実に
      残らないようにしています. 次はブート時にディスクから検出された
      デフォルト値を使って, 自動的にスケルトンラベルを生成しています. 
      それに続けて, ラベルの編集を行っています. 

      <p>やっと終りました! 以下のような感じでファイルシステムを
      初期化しましょう:-

      <verb>
        newfs -d0 /dev/rwd0s2e
        newfs -d0 /dev/rwd0s2f
      </verb>

      <p>ディスク名とスライス番号によって, 事前にスクリプト 
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?MAKEDEV"
      name="/dev/MAKEDEV"> を実行して, お望みのデバイスノードを
      作成する必要があるかもしれません. 

      <p>そして新しいファイルシステムを mount します (<htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?mount"
      name="mount"> を参照してください) :-

      <verb>
        mount /dev/wd0s2e /mnt/foo
        mount /dev/wd0s2f /mnt/bar
      </verb>

      <p>ブート時に自動的にファイルシステムを mount するには 
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fstab(5)"
      name="/etc/fstab"> を編集してください. 

      <p><bf /用語一覧:/

      <descrip>
        <tag><label id="fsize"><bf>フラグメントサイズ (fsize)</bf></tag>
        <tt /ffs/ におけるストレージの基本単位.
        M. McKusick, W. Joy, S. Leffler, and R. Fabry,
        "A Fast File System for  UNIX",
        ACM Transactions on Computer Systems 2, 3, pp 181-197, August
        1984, (再版は BSD System Manager's Manual, SMM:5) または
        <url url="file:/usr/share/doc/smm/05.fastfs/paper.ascii.gz"
        name="/usr/share/doc/smm/05.fastfs/paper.ascii.gz">
        を参照してください. 

        <tag><label id="bsize"><bf>ブロックサイズ (bsize)</bf></tag>
        ブロックは一つ以上のフラグメントを構成します. 上記の資料と
        <url url="file:/usr/include/sys/disklabel.h"
        name="&lt;sys/disklabel.h&gt;"> を参照してください. 

        <tag><label id="ESDI">
        <bf>古いディスク用のディスクラベル特性 (ESDI)</bf></tag>
        たまたま「本物のディスク」を持っている場合, より詳細な情報を 
        <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel"
        name="disklabel"> に与える必要があります. 例えば, 
        古い ESDIディスクのような画一的なジオメトリ, 本当のヘッド, 
        セクタ, シリンダです. これらすべてはディスクドライブのケース, 
        オーナーズマニュアル, 被害者仲間などから得ることができるはずです. :-)

        <tag><label id="fsname">
        <bf>BSD ファイルシステムのネーミングの慣例</bf></tag>
        慣例により, パーティション 'a' はブート可能なパーティション, 
        パーティション 'b' はスワップスペースとして予約されています. 
        正規のパーティションの名称は 'd' から始まることになっています. 
        (386BSD 0.1 から FreeBSD 2.0 までは 'd' は特別な意味を
        持っていたため, パーティション 'e' はファイルシステムを持つ
        最初のブート可能でないパーティションとして使われる場合
        もあります.)

        <tag><label id="swap">
        <bf>スワップスペースに関する警告</bf></tag>
        BSD パーティションテーブルが必要とする領域は, 
        ファイルシステム内に用意しておく必要があります. 
        これはスワップパーティションではいけません. したがって, 
        シリンダ 0 でスワップパーティションが始まらないように, 
        開始位置をずらすかパーティション 'a' にファイルシステム
        を配置してください. 
      </descrip>

    <sect1>
      <heading>新しいリムーバブルドライブを持っていますが, どうやって使うの?</heading>

      <p>そのリムーバブルドライブが ZIP であれ EZ drive であれ 
      (あるいはもしそういう風に使いたいのなら, フロッピーであれ), 
      またハードディスクであれ, 一旦システムにインストールされて認識され, 
      カートリッジ, フロッピー等々が挿入されていれば, 
      ことはどのデバイスでも全く同じように進みます. 

      <p><label id="disklabel"> (このセクションは<url
      url="http://vinyl.quickweb.com/mark/FreeBSD/ZIP-FAQ.html"
      name="Mark Mayo's ZIP FAQ"> に基づいています.)

      <p>ZIP ドライブやフロッピーで, すでに DOS のファイルシステムで
      フォーマットしてある場合, 次のコマンドを使うことができます. 
      これはフロッピーの場合です. 

      <verb>
        mount -t msdos /dev/fd0c /floppy
      </verb>

      <p>出荷時の設定の ZIP ディスクではこうです. 

      <verb>
        mount -t msdos /dev/sd2s4 /zip
      </verb>

      <p>その他のディスクに関しては, <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?fdisk" name="fdisk">
      や <tt>/stand/sysinstall</tt> を使って, どのようにレイアウト
      されているか確かめてください. 

      <p>以降は ZIP ドライブが 3 番目の SCSI ディスクで, 
      sd2 と認識されている場合の例です. 

      <p>他人と共有しなければならないフロッピーやリムーバブルディスク
      でなければ, BSD ファイルシステムを載せてしまうのが良い考えでしょう. 
      ロングファイル名もサポートされ, パフォーマンスは少なくとも 
      2 倍は向上しますし, おまけにずっと安定しています. 
      まず最初に, DOS レベルでのパーティション / ファイルシステムを
      無効にしておく必要があります. 使用するのは <tt/fdisk/ でも
      <tt>/stand/sysinstall</tt> でも結構です. 
      複数のオペレーティングシステムを入れることを考慮する
      必要がないような容量の小さなドライブの場合は, 
      次のように FAT パーティションテーブル (スライス) 
      全体を飛ばして, BSD のパーティション設定を行うだけで良いでしょう. 

      <verb>
        dd if=/dev/zero of=/dev/rsd2 count=2
        disklabel -Brw sd2 auto
      </verb>

      <p>複数の BSD パーティションをつくる場合, disklabel (詳しい情報は
      <ref id="2_1-disklabel-fix" name="この注意事項"> にあります) か
      <tt>/stand/sysinstall</tt> を使います. 固定ディスク上にスワップ領域
      を加える場合はそういうことをしたいと思うのはもっともですが, 
      ZIP のようなリムーバブルドライブの上ではそういう考えは不適切
      でしょう. 

      <p>最後に, 新しいファイルシステムをつくります. ディスク全体を使用する
      ZIP ドライブの場合は, 以下のようにします. 

      <verb>
        newfs /dev/rsd2c
      </verb>

      <p>次にマウントします. 

      <verb>
        mount /dev/sd2c /zip
      </verb>

      <p>また, 次のような行を <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?fstab"
      name="/etc/fstab"> に入れておくのも良い考えでしょう. 
      "mount /zip" と入力するだけでマウントできるようになります. 

      <verb>
        /dev/sd2c /zip ffs rw,noauto 0 0
      </verb>

    <sect1>
       <heading>どのようにしたら DOS の拡張パーティションをマウントできますか?</heading>

       <p>DOS 拡張パーティションはすべての基本パーティションの後に
       認識されます. たとえば, 2台目の SCSIドライブの拡張パーティションに 
       "E" パーティションがあるとしますと, これは /dev にスライス 5 
       のスペシャルファイルを作る必要があり, /dev/sd1s5 としてマウントされます. 

      <verb>
        # cd /dev
        # ./MAKEDEV sd1s5
        # mount -t msdos /dev/sd1s5 /dos/e
      </verb>

    <sect1>
       <heading>他のシステムのファイルシステムを FreeBSD でマウントすることはできますか?</heading>

       <p><bf/ Digital UNIX/ UFS CDROM は直接 FreeBSD でマウント
       することができます. Digital UNIX やそれ以外のシステムのサポートする
       UFS のディスクパーティションをマウントすることはもっと複雑
       なことで, オペレーティングシステムのディスクパーティション
       の詳細に依存します. 

       <p><bf/ Linux/: 2.2 以降は <bf/ext2fs/ パーティションをサポートします. 
       マニュアルの <htmlurl
       url="http://www.freebsd.org/cgi/man.cgi?mount_ext2fs"
       name="mount_ext2fs"> を見てください. より多くの情報があります. 

       <p>この問題について他の情報があれば, 他の人から感謝されるでしょう. 

    <sect1>
      <heading>どのようにしたら FreeBSD を NT ローダーからブートさせることができますか?</heading>

      <p>FreeBSD のネイティブルートパーティションの最初のセクタを
      ファイルにして DOS/NT パーティション上に置くという画期的な
      アイディアがあります. 
      ファイル名を <tt>c:&bsol;bootsect.bsd</tt> 
      (<tt>c:&bsol;bootsect.dos</tt> からの発想です) 
      としたとします. <tt>c:&bsol;boot.ini</tt> 
      ファイルを次のように編集します:

      <verb>
        [boot loader]
        timeout=30
        default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
        [operating systems]
        multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
        C:\BOOTSECT.BSD="FreeBSD"
        C:\="DOS"
      </verb>

      <p>この手順では DOS, NT, FreeBSD その他が<bf/同じ/ディスクのそれぞれの 
      fdisk パーティションにインストールされているとしています. 
      私の場合は, DOS と NT は最初のパーティション, FreeBSDは 2番目にあります. 
      また, FreeBSD は MBR を<bf/使わずに/, ネイティブパーティションから
      ブートするようにインストールしてあります. 
      (訳注: FreeBSD のインストールではブートマネジャを使わずに標準 
      MBR を使う場合に相当します)

      <p>(もし NTFS に変換してしまっているなら) DOS フォーマットの
      フロッピーディスクか FAT パーティションを <tt>/mnt</tt> に DOS 
      マウントします. 

      <verb>
        dd if=/dev/rsd0a of=/mnt/bootsect.bsd bs=512 count=1
      </verb>

      <p>リブートして DOS か NT に切替えます. NTFS ユーザは 
      <tt/bootsect.bsd/ や <tt/bootsect.lnx/ をフロッピーディスクから
      <tt/C:&bsol;/ へコピーします. <tt/boot.ini/ のファイル属性 
      (パーミッション) の変更を以下のようにおこないます:

      <verb>
        attrib -s -r c:\boot.ini
      </verb>

      <p>上の例の <tt/boot.ini/ で示したような正しいエントリを加え, 
      ファイル属性を元に戻します. 

      <verb>
        attrib -r -s c:\boot.ini
      </verb>

      <p>FreeBSD が MBR からブートするようになっている場合, 
      それぞれのネイティブパーティションからブートするように設定した後で, 
      DOS から ``<tt/fdisk/'' コマンドを実行して元に戻してください. 

    <sect1>
      <heading>
        FreeBSD と Linux を LILO からブートするには?
      </heading>

      <p>理論的には, LILO から FreeBSD をブートするには DOS スタイルの
      オペレーティングシステムとして扱えばできるはずですが, 私はいまだに
      うまくいったためしがありません. LILO を置く場所を MBR から Linux 
      のブートパーティションの先頭に変えれば, FreeBSD のブートマネージャから 
      LILO をブートすることができます. 私はこっちを使っています. 

      <p>Windows95 と Linux を使用している場合は, いずれにせよ後者の方が
      お勧めです. Windows95 を再インストールする必要にかられたとき, 
      Linux をブート可能に戻す手続きが簡単ですむからです
      (Windows95 は偏屈なオペレーティングシステムで, マスターブートレコード 
      (MBR) から他のオペレーティングシステムを追い払ってしまうのです).

    <sect1>
      <heading>
        「危険覚悟の専用 (dangerously dedicated) ディスク」は健康に悪いの?
      </heading>

      <p><label id="dedicate">
      インストール作業中, ハードディスクのパーティションを切る際に
      2 つの方法を選ぶことができます. デフォルトの方法では, fdisk の
      テーブルエントリ (FreeBSD ではスライスと呼ばれる) を使って, 
      自身のパーティションを使用する FreeBSD のスライスを, 同じマシン
      の他のオペレーティングシステムと互換性のある形にします. 
      それに付随して, ブートセレクタをインストールすれば, ディスク上の
      使用可能なオペレーションシステムを切り替えることができます. 

      <p>さて, これは確かに PC の世界からやって来た人々にとっては
      一般的なお話でしょうが, ここで Unix の世界の方からやって来た, 
      FreeBSD が動作する, しかも FreeBSD だけが動作するマシンをセットアップ
      しようとしている人の場合を考えてみましょう. 彼らは
      オペレーティングシステムがディスク全体を, その始めのセクタから
      終りの 1 つに至るまで使い切る, 古典的な Unix の流儀に慣れ親しんで
      います. このような, FreeBSD が 1 日 24 時間, 1 週間に 7 日走り続け, 
      他のオペレーティングシステムがブートされることなど有り得ないマシン
      では, 正しい fdisk のテーブルは何の役にも立ちません. 結果, もし
      sysinstall の fdisk エディタで ``A)ll FreeBSD'' を選択し, 続く質問に
      ``No'' と答えれば, こちらのモードを選択したことになります. 
      この場合, BSD のブートストラップがこのドライブの MBR になるので, 
      ブートマネージャ等にスペースが残されていないことに注意してください. 
      何かを MBR にインストールすれば, BSD のブートストラップに
      ダメージを与えることになるでしょう. 

      <p>では, なぜこれが 「危険覚悟の」と言われるのでしょう?
      このモードのディスクが, 通常の PC のユーティリティが有効な fdisk
      テーブルと見なす情報を持っていないからです. ユーティリティの出来
      如何によりますが, そのようなディスクを発見したとき, 警告を
      出すものもあります. また, もっと悪い場合, 確認も通告もなしに
      BSD のブートストラップにダメージを与えるものもあるでしょう. 
      PC ではより広範囲で使われているあるオペレーティングシステムは, 
      そういう非ユーザフレンドリーな行為をすることでよく知られています
      (もちろん, その行為は「ユーザフレンドリ」の名の元で
      行われるわけですが). 少なくとも 1 種の, 例えば HP Netserver 
      で使用されていた (もちろん, そこだけではありませんが) Award の 
      BIOS は, 有効な fdisk テーブルを持っていないと認識した全ての
      ハードディスクを無視することで知られています. 
      ブート時にこの現象が起こると, BIOS はそのようなディスクをさっさと
      無視してフロッピードライブを読みに行き, しかも ``Read error'' 
      というあっさりしたメッセージしか吐きません. 感動ものでしょ? 
      多分彼らにとってはこれが「ユーザフレンドリ」なんでしょうね. 
      よくわかりませんけど. 

      <p>このモードの利点はいくつかあります. FreeBSD がディスク全体を所有でき, 
      1980 年代の素朴なパーティショニングモデルのためだけに, いくつもの
      本来不要な「トラック」を無駄使いする必要がなくなります. 
      このモデルは, パーティショニングをどのようにすべきかという点に関して, 
      いくらか不自然で, 今では無意味でさえある制限を課します. 
      この制限は, しばしば PC に OS をインストールする際の最大の頭痛の種と
      なります. パーティショニングの情報を fdisk のテーブルに保存する際に
      2 つの異なる, 冗長な方法が用意されているがゆえに, 結果として
      ジオメトリの不整合を引き起こすのです. <ref id="missing_os"
      name="Missing Operating System"> の章をご覧下さい. 
      「危険覚悟の専用」モードでは, BSD のブートストラップはセクタ 0 
      から始まりますが, BIOS のディスクジオメトリ「変換」の方式とは
      無関係に, 常に等しい C/H/S の値に変換される唯一のセクタ
      なのです. したがって, ブートしなくなる危険を犯すことなしに, 
      異なる変換方式を採用しているシステム / コントローラ間で, 
      ディスクを交換することができるのです. 

      <p>「危険覚悟の専用ディスク」を通常の PC での使用法に
      戻すには, 原則として 2 つ方法があります. 1 つは十分な NULL 
      バイトを MBR に書き込んで, きたるべきインストーラにディスク
      はまっさらだと思い込ませる方法です. 例えば, こんな感じです. 
          
      <verb>
        dd if=/dev/zero of=/dev/rsd0 count=15
      </verb>

      <p>また, マニュアルには書かれていない DOS の「機能」

      <verb>
        fdisk /mbr
      </verb>

      <p>は, BSD ブートストラップを追い払ってくれる上に, 
      新しいマスターブートレコードをインストールしてくれます. 

    <sect1>
      <heading>どのようにしたらスワップ領域を増やせますか?</heading>

      <p>スワップパーティションのサイズを増やすのが最良の方法ですが, 
      別のディスクを追加しなくて済むという利点のある方法があります. 
      (これを行う時には <ref id="swap" name="この注意事項"> 
      も見ておいてください)

      <p>スワップを別のディスク上に追加することは, 単純に同じディスク上
      にスワップを追加する場合よりも高速に動作するようになります. 
      例に挙げれば, あるディスク上のソースをコンパイルしているとして, 
      スワップが別のディスク上に作られていれば, これらが同じディスク上
      にある場合よりも断然速いです. SCSI ディスクの場合は特にそうだと言えます. 

      <p> IDE ドライブは同時に同じチャネル上の複数のドライブには
      アクセスできません (FreeBSD は mode 4 をサポートしていないので, 
      すべての IDE ディスク I/O は ``programmed'' です). 
      IDE の場合であってもやはり, スワップを別のハードディスク上に
      作成することをおすすめします. 
      ドライブは実に安いものです, 心配するだけ無駄です. 

      <p>よいサーバと非常に高速なネットワーク環境でないのであれば, 
      スワップを NFS 上に置こうというのは本当にばかげた考えです. 

      <p>これは 64MBの vn-swap を作る例です (ここでは <tt>/usr/swap0</tt> 
      としますが, もちろん好きな名前を使うことができます).

      <p>カーネルが次の行を含むコンフィグファイルから構成されているかを
      確認します. GENERIC カーネルには, この行が含まれています. 

      <verb>
        pseudo-device   vn 1   #Vnode driver (turns a file into a device)
      </verb>

      <enum>
        <item>vn デバイスを作ります
        <verb>
          cd /dev
          sh ./MAKEDEV vn0
        </verb>

        <item>スワップファイルを作ります (<tt>/usr/swap0</tt>)

        <verb>
          dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
        </verb>

        <item><tt>/etc/rc.conf</tt> でスワップファイルを有効化させます

        <verb>
          swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
        </verb>

        <item>マシンをリブートします
      </enum>

      <p>スワップファイルをすぐに有効化させたいのなら以下のようにタイプします
      <verb>
        vnconfig -ce /dev/vn0c /usr/swap0 swap
      </verb>

    <sect1>
      <heading>プリンタのセットアップで問題があります</heading>

      <p>ハンドブックのプリンタの部分を参照してください. 
      探している問題のほとんどが書かれているはずです. 
      <url url="../handbook/printing.html" 
      name="ハンドブック中のプリンタの利用">をご覧ください. 

    <sect1>
      <heading>私のシステムのキーボードマッピングは間違っています. </heading>

      <p>kbdcontrol プログラムは, キーボードマップファイルを読み込むための
      オプションを備えています. 
      <tt>/usr/share/syscons/keymaps</tt> の下にたくさんのマップファイルがあります. 
      システムに関連のあるものを一つ選んで, ロードしてください. 

      <verb>
        kbdcontrol -l uk.iso
      </verb>

      <tt>/usr/share/syscons/keymaps</tt> と拡張子 <tt/.kbd/ は
      どちらも <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?kbdcontrol"
      name="kbdcontrol"> によって使用されます. 

      <p>これは <tt>/etc/sysconfig</tt> (または <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)"
      name="rc.conf">) 中で設定することができます. 
      このファイル中にあるそれぞれのコメントを参照してください. 

      <p>2.0.5R やそれ以降の版では, テキストフォントやキーボードマッピングに
      関係のあるものはすべて, <tt>/usr/share/examples/syscons</tt> 
      の中におさめられています. 

      <p>現在以下のマッピングがサポートされています:

      <itemize>
        <!-- generate by `kbdmap -p' -->
        <item>Belgian ISO-8859-1 
        <item>Brazilian 275 keyboard Codepage 850 
        <item>Brazilian 275 keyboard ISO-8859-1 
        <item>Danish Codepage 865 
        <item>Danish ISO-8859-1 
        <item>French ISO-8859-1 
        <item>German Codepage 850 
        <item>German ISO-8859-1 
        <item>Italian ISO-8859-1 
        <item>Japanese 106 
        <item>Japanese 106x 
        <item>Latin American 
        <item>Norwegian ISO-8859-1 
        <item>Polish ISO-8859-2 (programmer's) 
        <item>Russian Codepage 866 (alternative) 
        <item>Russian koi8-r (shift) 
        <item>Russian koi8-r 
        <item>Spanish ISO-8859-1 
        <item>Swedish Codepage 850 
        <item>Swedish ISO-8859-1 
        <item>Swiss-German ISO-8859-1 
        <item>United Kingdom Codepage 850 
        <item>United Kingdom ISO-8859-1 
        <item>United States of America ISO-8859-1 
        <item>United States of America dvorak 
        <item>United States of America dvorakx 
      </itemize>

    <sect1>
      <heading>ユーザディスククォータが正常に動作していないようです. </heading>

      <p>
      <enum>
        <item>'/' にはディスククォータを設定しないでください, 

        <item>クォータファイルが置かれるファイルシステム上に
        クォータファイルを置くようにしてください. つまり:
        <verb>
          FS      QUOTA FILE
          /usr    /usr/admin/quotas
          /home   /home/admin/quotas
          ...
        </verb>
      </enum>

    <sect1>
      <heading>わたしの ccd の何が適合していない (Inappropriate) のでしょう?</heading>

      <p>このような症状が現れます:

      <verb>
        # ccdconfig -C
        ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format
        #
      </verb>

      <p>通常この現象はタイプを ' 未使用 (unused)' のまま放っておかれた
      'c' パーティションをつなげようとした場合に現れます. ccd ドライバは
      FS_BSDFFS タイプをベースとするパーティションを要求します. 
      つなげようとしているディスクのディスクラベルを編集して, 
      パーティションのタイプを '4.2BSD' に変更してください. 

    <sect1>
      <heading>どうしてわたしの ccd のディスクラベルを変更することができないのでしょう?</heading>

      <p>このような症状が現れます:

      <verb>
        # disklabel ccd0
        (it prints something sensible here, so let's try to edit it)
        # disklabel -e ccd0
        (edit, save, quit)
        disklabel: ioctl DIOCWDINFO: No disk label on disk;
        use "disklabel -r" to install initial label
        #
      </verb>

      <p>これは ccd から返されるディスクラベルが, 実はディスク上にはない
      まったくの偽の情報だからです. これを明示的に書き直すことで
      問題を解消できます, このようになります:

      <verb>
        # disklabel ccd0 > /tmp/disklabel.tmp
        # disklabel -Rr ccd0 /tmp/disklabel.tmp
        # disklabel -e ccd0
        (this will work now)
      </verb>

    <sect1>
      <heading>FreeBSD は System V の IPC プリミティブをサポートしますか? </heading>

      <p>はい. FreeBSD は System-V スタイルの IPC をサポートします. 
      共有メモリ, メッセージ, セマフォが含まれます. 以下の行を
      カーネルコンフィグファイルに加えると, サポートが有効になります. 

      <verb>
        options    SYSVSHM
        options    "SHMMAXPGS=64"   # 256Kb of sharable memory
        options    SYSVSEM          # enable for semaphores
        options    SYSVMSG          # enable for messaging
      </verb>

      <p>コンパイルしてインストールしてください. 

      <p><bf/注:/ GIMP を実行したい場合は, SHMMAXPGS を 4096(16M) 
      くらい馬鹿でかい数字に増やす必要があります. X11R6 の共有メモリは 
      256Kb で十分です. 

    <sect1>
      <heading>
        UUCP で mail を配送するには sendmail をどう使えばよいのですか?<label id="uucpmail">
      </heading>

      <p>FreeBSD に付属している sendmail は, インターネットに直接
      つながっているサイトにあわせて設定してあります. UUCP 経由で mail 
      を交換したい場合には sendmail の設定ファイルを改めてインストール
      しなければなりません. 

      <p><tt>/etc/sendmail.cf</tt>を自分の手で改造するのは純粋主義者の
      やるような事です. sendmailの version 8 は <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?m4" name="m4"> のような
      プリプロセッサを通して設定ファイルを生成する新しいアプローチを
      取っており, より抽象化されたレベルの設定ファイルを編集します. 
      以下のディレクトリの中にある設定ファイルを使用してください. 

      <verb>
        /usr/src/usr.sbin/sendmail/cf
      </verb>

      <p>もしすべてのソースをインストールしていない場合には sendmail 
      の設定ツールは, 別の tar ファイルにまとめてあります. CD-ROM が 
      mount されている場合には, 次のようにしてください. 

      <verb>
        cd /usr/src
        tar -xvzf /cdrom/dists/src/ssmailcf.aa
      </verb>

      <p>これはたった数 100Kbyte ですから心配ないでしょう. <tt>cf</tt> 
      ディレクトリにある <tt>README</tt> に, m4 での設定の基本的な説明があります. 

      <p>UUCP での配送のためには, <em>mailertable</em> を使用すれば
      よいでしょう. これによって, sendmail が配送方式を決定するデータベースを
      作成することができます. 

      <p>まずはじめに, <tt>.mc</tt> ファイルを作成しなければなりません. 
      <tt>/usr/src/usr.sbin/sendmail/cf/cf</tt> というディレクトリが, 
      これらのファイルを作成する場所です. 既にいくつか例があると思います. 
      これから作成するファイルの名前を <tt>foo.mc</tt> とすると, 
      <tt>sendmail.cf</tt> を求めているような形式に変換するには, 
      次のようにしてください. 

      <verb>
        cd /usr/src/usr.sbin/sendmail/cf/cf
        make foo.cf
        cp foo.cf /etc/sendmail.cf
      </verb>

      <p>標準的な <tt>.mc</tt> ファイルは次のようになります. 

      <verb>
        include(`../m4/cf.m4')
        VERSIONID(`Your version number')
        OSTYPE(bsd4.4)

        FEATURE(nodns)
        FEATURE(nocanonify)
        FEATURE(mailertable)

        define(`UUCP_RELAY', your.uucp.relay)
        define(`UUCP_MAX_SIZE', 200000)

        MAILER(local)
        MAILER(smtp)
        MAILER(uucp)

        Cw    your.alias.host.name
        Cw    youruucpnodename.UUCP
      </verb>

      <p><em>nodns</em> と <em>nocanonify</em> という指定をすることで, 
      mail の配送に DNS を使用しなくなります. <em>UUCP_RELAY</em> という
      行に関しては, ある理由から必要ですがそれは聞かないでください. 
      .UUCPで終わる仮想ドメインを処理することのできるインターネット上での
      ホスト名をここに書いてください. 通常は, ISP の mail リレーホストを
      書くことになると思います. 

      <p>これが終了したら, 次に <tt>/etc/mailertable</tt> というファイル
      が必要です. 標準的な例は次のとおりです. 

      <verb>
        #
        # makemap hash /etc/mailertable.db < /etc/mailertable
        #
        horus.interface-business.de   uucp-dom:horus
        .interface-business.de        uucp-dom:if-bus
        interface-business.de         uucp-dom:if-bus
        .heep.sax.de                  smtp8:%1
        horus.UUCP                    uucp-dom:horus
        if-bus.UUCP                   uucp-dom:if-bus
        .                             uucp-dom:sax
      </verb>

      <p>見れば分かるように, これは実在する設定のファイルです. はじめの
      3 行はドメイン名で指定されたメールが default の経路で配送されずに, 
      ``近道'' するために UUCP で隣りのサイトに送るための特別な状況を
      処理するものです. 
      次の行は Ethernet でつながっているローカルのドメインに対しては 
      SMTP で送るための設定です. 
      最後に, UUCP での隣りのサイトが. UUCP で終わる仮想ドメインの書式で
      指定されており, default の rule を ``uucp-neighbour!recipient'' 
      で上書きするためのものです. 一番最後の行はいつもドットを一つ書きます. 
      これは, ここまでの行でマッチしなかったすべてのホストにマッチし, 
      このサイトから世界に向けて出ていくための mail gateway に UUCP 
      で配送するためのものです. 
      <tt>uucp-dom:</tt> に続けて書かれているノード名は, 
      <tt>uuname</tt> コマンドで指定することによって UUCP 
      で直接配送される正しいノード名でなければなりません. 

      <p>最後に, このファイルは使用する前に DBM データベースのファイルに
      変換する必要があります. これをおこなうコマンドラインは mailertable
      の最初のコメントに書いてあります. mailertable を変更した時には, 
      必ずこのコマンドを実行してください. 

      <p>最後のヒントです: もし特定のメール配送がうまく作動するかどうか
      確かめたい場合には, sendmail の<tt>-bt</tt> オプションを
      使用してください. このオプションによって sendmail は
      <em>アドレステストモード</em>で起動します. ``0 '' の後に
      配送したいアドレスを書いてください. 最後の行に, 実際に使用される 
      mail agent, この mail agent で送られる送信先のホスト, そして 
      (多分変換されている) アドレスが表示されます. このモードを抜けるには 
      Control-D を押してください. 

      <verb>
        j@uriah 191% sendmail -bt
        ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
        Enter <ruleset> <address>
        > 0 foo@interface-business.de
        rewrite: ruleset  0   input: foo @ interface-business . de
        ...
        rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
        < @ interface-business . de >
        > ^D
        j@uriah 192%
      </verb>

    <sect1>
      <heading>
        ダイアルアップでインターネットに接続する環境でメールをセットアップするにはどうやるの?
        <label id="ispmail">
      </heading>

      <p>静的に IP アドレスが割り当てられる場合は, デフォルトの状態を
      変更する必要はありません. 割り当てられた名前をホストネームと
      するだけで, sendmail が後のことを引き受けてくれます. 

      <p>ダイアルアップ <bf/ppp/ をインターネット接続に使用し, 動的に IP
      アドレスが割り当てられる場合は, インターネットサービスプロバイダ
      (ISP) のメールサーバにメールボックスがあるはずです. ISP のドメイン
      が <tt/myISP.com/ で, あなたのユーザ名が <tt/user/ だと仮定します. 
      また, あなたが自分のマシンを <tt/bsd.home/ と呼んでおり, ISP が
      <tt/relay.myISP.com/ をメールリレーとして使用できると言っていると
      しましょう. 

      <p>メールボックスからメールを取ってくるためには, retrieval (回収)
      エージェントをインストールする必要があります. <bf/Fetchmail/ は
      多種多様なプロトコルをサポートしているのでお勧めです. ISP が
      使用しているのは大抵 POP3 プロトコルです. ユーザ ppp を使用している場合, 
      <tt>/etc/ppp/ppp.linkup</tt> に以下のように記述すると, インターネットと
      接続が完了した時点で自動的にメールを取得するようになります. 

      <verb>
        MYADDR:
          !bg su user -c fetchmail
      </verb>

      <p>この例では, <tt/user/ が <tt/bsd.home/ にアカウントを持ち, 
      <tt/bsd.home/ 上の <tt/user/ のホームディレクトリに, 以下のような
      <tt/.fetchmailrc/ ファイルがつくられていることを想定しています. 

      <verb>
        poll myISP.com protocol pop3 fetchall pass MySecret;
      </verb>

      <p>言うまでもなく, このファイルは <tt/user/ 以外のユーザが読むことが
      出来ないようにしなくてはなりません. 内容にパスワード <tt/MySecret/ が
      含まれているからです. 

      <p>正しい <bf/from:/ ヘッダをつけてメールを送るためには, sendmail に
      <tt/user@bsd.home/ ではなく <tt/user@myISP.com/ を使用するよう教える
      必要があります. メールをより早く転送するために, 全てのメールを
      <tt/relay.myISP.com/ へ送るように sendmail に指示しておくのも良い
      でしょう. 

      <p>上の要件を満たすには, 以下のような <tt/.mc/ ファイルが適しています. 

      <verb>
        VERSIONID(`bsd.home.mc version 1.0')
        OSTYPE(bsd4.4)dnl
        FEATURE(nouucp)dnl
        MAILER(local)dnl
        MAILER(smtp)dnl
        Cwlocalhost
        Cwbsd.home
        CwmyISP.com
        MASQUERADE_AS(`myISP.com')dnl
        FEATURE(allmasquerade)dnl
        FEATURE(masquerade_envelope)dnl
        FEATURE(nocanonify)dnl
        FEATURE(nodns)dnl
        define(SMART_HOST, `relay.myISP.com')
        DmmyISP.com
        define(`confDOMAIN_NAME',`myISP.com')dnl
        define(`confDELIVERY_MODE', `deferred')dnl
      </verb>

      <p><tt/.mc/ ファイルから <tt/sendmail.rc/ への変換方法については, 
      前のセクションを参照してください. sendmail.cf を更新した後に
      sendmail をリスタートするのもお忘れなく. 

  </sect>

