<!-- $Id: admin.sgml,v 1.3 1998-03-27 06:10:19 hanai Exp $ -->
<!-- The FreeBSD Documentation Project -->

  <sect>
    <heading>System Administration<label id="admin"></heading>

    <sect1>
      <heading>Where are the system start-up configuration files?</heading>

      <p>From 2.0.5R to 2.2.1R, the primary configuration file is
      <tt>/etc/sysconfig</tt>. All the options are to be specified in
      this file and other files such as <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?rc" name="/etc/rc"> and
      <tt>/etc/netstart</tt> just include it.

      <p>Look in the <tt>/etc/sysconfig</tt> file and change the value to
      match your system. This file is filled with comments to show what
      to put in there.

      <p>In post-2.2.1 and 3.0, <tt>/etc/sysconfig</tt> was renamed
      to a more self-describing <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)" name="rc.conf">
      file and the syntax cleaned up a bit in the process.
      <tt>/etc/netstart</tt> was also renamed to <tt>/etc/rc.network</tt>
      so that all files could be copied with a <tt><htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?cp" name="cp"> /usr/src/etc/rc*
      /etc</tt> command.

      <p><tt>/etc/rc.local</tt> is here as always and may be used to
      start up additional local services like <htmlurl
      url="http://www.freebsd.org/cgi/ports.cgi?^inn" name="INN">
      or set custom options.

      <p>The <tt>/etc/rc.serial</tt> is for serial port initialization
      (e.g. locking the port characteristics, and so on.).

      <p>The <tt>/etc/rc.i386</tt> is for Intel-specifics settings, such
      as iBCS2 emulation or the PC system console configuration.

      <p>Starting with 2.1.0R, you can also have "local" startup files in a
      directory specified in <tt>/etc/sysconfig</tt> (or
      <tt>/etc/rc.conf</tt>):

      <verb>
        # Location of local startup files.
        local_startup=/usr/local/etc/rc.local.d
      </verb>

      <p>Each file ending in <tt/.sh/ will be executed in alphabetical order.

      <p>If you want to ensure a certain execution order without changing all
      the file names, you can use a scheme similar to the following with
      digits prepended to each file name to insure the ordering:

      <verb>
        10news.sh
        15httpd.sh
        20ssh.sh
      </verb>

      <p>It can be seen as ugly (or SysV :-)) but it provides a simple and
      regular scheme for locally-added packages without resorting to
      magical editing of <tt>/etc/rc.local</tt>.  Many of the ports/packages
      assume that <tt>/usr/local/etc/rc.d</tt> is a local startup directory.

    <sect1>
      <heading>How do I add a user easily?</heading>

      <p>Use the <htmlurl url="http://www.freebsd.org/cgi/man.cgi?adduser"
      name="adduser"> command.

      <p>There is another package called ``<tt/new-account/'' also written
      in Perl by Ollivier Robert. Ask <tt>&lt;roberto@FreeBSD.ORG&gt;</tt>
      about it.  It is currently undergoing further development.

      <p>To remove the user again, use the <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rmuser" name="rmuser"> command.

    <sect1>
      <heading>How can I add my new hard disk to my FreeBSD system?</heading>

      <p>The easiest way to do this is from the installation program. You
      can start the installation program by running
      <tt>/stand/sysinstall</tt> as root.

      <p>Alternatively, if you still have the install floppy, you can just
      reboot from that and use the partition & label editors while
      the system is totally quiescent.

      <p><label id="2_1-disklabel-fix">If the above does not work for you,
      or if you're a total masochist who likes arcane interfaces, this is how
      to use <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel"> manually:

      <p><em>WARNING: There is no substitute for reading carefully
      &amp; understanding what you are doing! Things described here may
      DESTROY your system. Proceed with caution! Remember, a BACKUP is your
      friend!</em>

      <p><tt /sysinstall/ used to be broken up to 2.1.5-RELEASE and will
      insist on mounting something at / in the disklabel editor. You will
      have to manually run
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel"> before you can run
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?newfs" name="newfs">/.
      This means doing the math for partitions yourself. This is rumored to
      be easy :-) See if you can obtain a skeletal label with
      ''<tt>disklabel -r &lt;diskname&gt;</tt>'' <em>(e.g.
      </em>''<tt>disklabel -r /dev/rwd0s2</tt>''<em>, assuming that your new
      disk is wd0, the first IDE drive, and the FreeBSD slice is the second
      one, s2)</em>. You should see something like:-

      <verb>
        # /dev/rwd0s2:
        type: ESDI
        disk: wd0s2
        label:
        flags:
        bytes/sector: 512
        sectors/track: 63
        tracks/cylinder: 64
        sectors/cylinder: 4032
        cylinders: 610
        sectors/unit: 2459520
        rpm: 3600
        interleave: 1
        trackskew: 0
        cylinderskew: 0
        headswitch: 0           # milliseconds
        track-to-track seek: 0  # milliseconds
        drivedata: 0

        8 partitions:
        #        size   offset    fstype   [fsize bsize bps/cpg]
          c:  2459520        0    unused        0     0         # (Cyl. 0 - 609)
          e:  2459520        0    4.2BSD        0     0     0   # (Cyl. 0 - 609)
      </verb>

      <p>Make sure that the size is correct, in this case, 2459520
      sectors/unit x 512 bytes/sector / 2**20 (1 Megabyte) = 1200
      Megabytes. The rest of the stuff (b/s, t/c, s/c, interleave, etc.)
      should get suitable defaults from <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel">, but see <ref id="ESDI" name="this note"> for older
      disks. 'fsize' is the <ref id="fsize" name="Fragment size"> for the
      filesystem, and 'bsize' is the <ref id="bsize" name="Block size">. 'c'
      is the partition covering the entire slice (or entire disk for a
      non-sliced disk), and must remain as it is. <em>It should not be
      used for a filesystem</em>. The 'c' partition is magic in that it
      is faked by the kernel even if no disklabel exists.

      <p>In the trivial case, where you want a single filesystem spanning
      the whole slice, the entry for 'e' has to be corrected. Setting fsize
      to 1024 and bsize to 8192 (8 fragments/block), which are reasonable
      values for a filesystem, the correct entry for 'e' would be:-

      <verb>
        e:  2459520        0    4.2BSD     1024  8192
      </verb>

      <p>Now, the (slightly) harder case, where we want 2 partitions for 2
      filesystems. Following the <ref id="fsname" name="BSD naming
      conventions">, the partitions will be <tt /wd0s2e/ &amp;
      <tt /wd0s2f/. Suppose we split up the 1200 MB into 300 MB for
      'e' and the remaining 900 MB for 'f'. The partition entries would
      be:-

      <verb>
        8 partitions:
        #        size   offset    fstype   [fsize bsize bps/cpg]
        c:  2459520        0    unused        0     0         # (Cyl. 0 - 609)
        e:   614400        0    4.2BSD     1024  8192
        f:  1843200   614400    4.2BSD     1024  8192
      </verb>

      <p><bf /Note:/ You can directly edit the disklabel with
      ''<tt>disklabel -e wd0s2</tt>''. See
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel">.

      <p>If you have at least FreeBSD 2.1.5, and you want to dedicate
      an entire disk to FreeBSD without any care for other
      systems, you might shorten the steps above to something like:

      <verb>
        # dd if=/dev/zero of=/dev/rwd0 count=100
        # disklabel -Brw wd0 auto
        # disklabel -e wd0
      </verb>

      <p>The first <htmlurl url="http://www.freebsd.org/cgi/man.cgi?dd"
      name="dd"> command ensures there is no old junk at
      the beginning of the disk that might confuse the disk code
      in the kernel.  Following is an automatic skeleton label
      generation using the defaults that have been probed from the
      disk at boot time.  Editing this label continues as described
      above.

      <p>You're done! Time to initialize the filesystems with something
      like:-

      <verb>
        newfs -d0 /dev/rwd0s2e
        newfs -d0 /dev/rwd0s2f
      </verb>

      <p>Depending on the disk name and slice number, it might be
      required that you run the script <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?MAKEDEV" name="/dev/MAKEDEV">
      before in order to create the desired device nodes.

      <p>And mount your new filesystems (See
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?mount" name="mount">):-

      <verb>
        mount /dev/wd0s2e /mnt/foo
        mount /dev/wd0s2f /mnt/bar
      </verb>

      <p>You may wish to edit <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?fstab(5)" name="/etc/fstab"> to
      automatically mount the filesystems at boot time.

      <p><bf /Glossary:/

      <descrip>
        <tag><label id="fsize"><bf>Fragment Size (fsize)</bf></tag>
        The basic unit of storage for <tt /ffs/. See
        M. McKusick, W. Joy, S. Leffler, and R. Fabry,
        "A Fast File System for  UNIX",
        ACM Transactions on Computer Systems 2, 3, pp 181-197, August
        1984, (reprinted in the BSD System Manager's Manual, SMM:5) or
        <url url="file:/usr/share/doc/smm/05.fastfs/paper.ascii.gz"
        name="/usr/share/doc/smm/05.fastfs/paper.ascii.gz"> on your system.

        <tag><label id="bsize"><bf>Block Size (bsize)</bf></tag>
        A block comprises one or more fragments. See the
        reference above and
        <url url="file:/usr/include/sys/disklabel.h"
        name="&lt;sys/disklabel.h&gt;">

        <tag><label id="ESDI">
        <bf>Disklabel Characteristics for Older Disks (ESDI)</bf></tag>
        You may need to provide more information to <htmlurl 
        url="http://www.freebsd.org/cgi/man.cgi?disklabel"
        name="disklabel"> if you happen to own a ``true disk'', i.e. one with a
        uniform geometry, real heads, sectors, and cylinders,
        such as an old ESDI drive. All of this should be easily
        obtainable from the drive case, owner's manual, fellow
        sufferers, etc. :-)

        <tag><label id="fsname">
        <bf>BSD Filesystem Naming Conventions</bf></tag>
        Partition 'a' is by convention reserved for a bootable
        partition, and partition 'b' for swap space. Regular
        partition names should start with 'd'. ('d' used to be
        magic in 386BSD 0.1 through FreeBSD 2.0, thus partition
        'e' is often used for the first non-bootable partition
        containing a filesystem.)

        <tag><label id="swap">
        <bf>Warning about swap space</bf></tag>
        The space required by the BSD partition table is allowed
        for in the file system. It's not allowed for by the swap
        partition. So don't start swap at cylinder 0, either offset
        it or put a file system in partition 'a'.
      </descrip>

    <sect1>
      <heading>I have a new removable drive, how do I use it?</heading>

      <p>Whether it's a removable drive like a ZIP or an EZ drive (or
      even a floppy, if you want to use it that way), or a new hard
      disk, once it's installed and recognized by the system, and
      you have your cartridge/floppy/whatever slotted in, things are
      pretty much the same for all devices.

      <p><label id="disklabel">(this section is based on <url
      url="http://vinyl.quickweb.com/mark/FreeBSD/ZIP-FAQ.html"
      name="Mark Mayo's ZIP FAQ">)

      <p>If it's a ZIP drive or a floppy , you've already got a DOS
      filesystem on it, you can use a command like this:

      <verb>
        mount -t msdos /dev/fd0c /floppy
      </verb>

      <p>if it's a floppy, or this:

      <verb>
        mount -t msdos /dev/sd2s4 /zip
      </verb>

      <p>for a ZIP disk with the factory configuration.

      <p>For other disks, see how they're laid out using <tt/fdisk/ or
      <tt>/stand/sysinstall</tt>.

      <p>The rest of the examples will be for a ZIP drive on sd2, the third
      SCSI disk.

      <p>Unless it's a floppy, or a removable you plan on sharing with
      other people, it's probably a better idea to stick a BSD file
      system on it. You'll get long filename support, at least a 2X
      improvement in performance, and a lot more stability. First, you
      need to redo the DOS-level partitions/filesystems. You can either
      use <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fdisk"
      name="fdisk"> or <tt>/stand/sysinstall</tt>, or for a small
      drive that you don't want to bother with multiple operating system
      support on, just blow away the whole FAT partition table (slices)
      and just use the BSD partitioning:

      <verb>
        dd if=/dev/zero of=/dev/rsd2 count=2
        disklabel -Brw sd2 auto
      </verb>

      <p>You can use disklabel (more info in <ref id="2_1-disklabel-fix"
      name="this note">) or <tt>/stand/sysinstall</tt> to create multiple
      BSD partitions. You'll certainly want to do this if you're adding
      swap space on a fixed disk, but it's probably irrelevant on a
      removable drive like a ZIP.

      <p>Finally, create a new file system, this one's on our ZIP drive
      using the whole disk:

      <verb>
        newfs /dev/rsd2c
      </verb>

      <p>and mount it:

      <verb>
        mount /dev/sd2c /zip
      </verb>

      <p>and it's probably a good idea to add a line like this to
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fstab"
      name="/etc/fstab"> so you can just type "mount /zip" in the
      future:

      <verb>
        /dev/sd2c /zip ffs rw,noauto 0 0
      </verb>

    <sect1>
      <heading>How do I mount a secondary DOS partition?</heading>

      <p>The secondary DOS partitions are found after ALL the primary
      partitions. For example, if you have an "E" partition as the
      second DOS partition on the second SCSI drive, you need to create
      the special files for "slice 5" in /dev, then mount /dev/sd1s5:

      <verb>
        # cd /dev
        # ./MAKEDEV sd1s5
        # mount -t msdos /dev/sd1s5 /dos/e
      </verb>

    <sect1>
      <heading>Can I mount other foreign filesystems under FreeBSD?</heading>

      <p><bf/ Digital UNIX/ UFS CDROMs can be mounted directly on FreeBSD.
      Mounting disk partitions from Digital UNIX and other systems
      that support UFS may be more complex, depending on the details
      of the disk partitioning for the operating system in question.

      <p><bf/ Linux/: 2.2 and later have support for <bf/ext2fs/ partitions.
      See <htmlurl url="http://www.freebsd.org/cgi/man.cgi?mount_ext2fs"
      name="mount_ext2fs"> for more information.

      <p>Any other information on this subject would be appreciated.

    <sect1>
      <heading>How can I use the NT loader to boot FreeBSD?</heading>

      <p>The general idea is that you copy the first sector of your
      native root FreeBSD partition into a file in the DOS/NT
      partition.  Assuming you name that file something like
      <tt>c:&bsol;bootsect.bsd</tt> (inspired by <tt>c:&bsol;bootsect.dos</tt>),
      you can then edit the <tt>c:&bsol;boot.ini</tt> file to come up with
      something like this:

      <verb>
        [boot loader]
        timeout=30
        default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
        [operating systems]
        multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
        C:\BOOTSECT.BSD="FreeBSD"
        C:\="DOS"
      </verb>

      <p>This procedure assumes that DOS, NT, FreeBSD, or whatever
      have been installed into their respective fdisk partitions on the
      <bf/same/ disk.  In my case DOS &amp; NT are in the first fdisk
      partition and FreeBSD is in the second.  I also installed FreeBSD
      to boot from its native partition, <bf/not/ the disk MBR.

      <p>Mount a DOS-formatted floppy (if you've converted to NTFS) or the
      FAT partition, under, say, <tt>/mnt</tt>.

      <verb>
        dd if=/dev/rsd0a of=/mnt/bootsect.bsd bs=512 count=1
      </verb>

      <p>Reboot into DOS or NT.  NTFS users copy the <tt/bootsect.bsd/
      and/or the <tt/bootsect.lnx/ file from the floppy to
      <tt/C:&bsol;/.  Modify the attributes (permissions) on
      <tt/boot.ini/ with:

      <verb>
        attrib -s -r c:\boot.ini
      </verb>

      <p>Edit to add the appropriate entries from the example
      <tt/boot.ini/ above, and restore the attributes:

      <verb>
        attrib -r -s c:\boot.ini
      </verb>

      <p>If FreeBSD is booting from the MBR, restore it with the DOS
      ``<tt/fdisk/'' command after you reconfigure them to boot from their
      native partitions.

    <sect1>
      <heading>
        How do I boot FreeBSD and Linux from LILO?
      </heading>

      <p>Theoretically you should be able to boot FreeBSD from LILO by
      treating it as a DOS-style operating system, but I haven't been
      able to get it to work. If you put LILO at the start of your Linux
      boot partition instead of in the MBR, you can boot LILO from the
      FreeBSD boot manager. This is what I do.

      <p>If you're running Windows-95 and Linux this is recommended anyway,
      to make it simpler to get Linux booting again if you should need
      to reinstall Windows95 (which is a Jealous Operating System, and
      will bear no other Operating Systems in the Master Boot Record).

    <sect1>
      <heading>
        Will a ``dangerously dedicated'' disk endanger my health?
      </heading>

      <p><label id="dedicate">The installation procedure allows you to chose
      two different methods in partitioning your harddisk(s).  The default way
      makes it compatible with other operating systems on the same machine,
      by using fdisk table entries (called ``slices'' in FreeBSD),
      with a FreeBSD slice that employs partitions of its own.
      Optionally, one can chose to install a boot-selector to switch
      between the possible operating systems on the disk(s).

      <p>Now, while this is certainly the common case for people
      coming from a PC background, those people coming more from a
      Unix background and who are going to setup a machine just to
      run FreeBSD and only FreeBSD, are more used to the classic
      Unix way where the operating system owns the entire disks,
      from the very first sector through the end.  A true fdisk
      table isn't of any use in this case, the machine is running
      FreeBSD 24 hours per day, 7 days per week, no other operating
      system should ever be booted on it.  So, if you select
      ``A)ll FreeBSD'' in sysinstall's fdisk editor, and answer the
      next question with ``No'', you'll get this mode.  Note that
      this means the BSD bootstrap also forms the MBR for this drive,
      so there's no space left for anything like a boot manager.
      Don't ever try to install one, or you'll damage the BSD
      bootstrap.

      <p>So why it is called ``dangerous''?  A disk in this mode
      doesn't contain what normal PC utilities would consider a
      valid fdisk table.  Depending on how well they have been
      designed, they might complain at you once they are getting
      in contact with such a disk, or even worse, they might
      damage the BSD bootstrap without even asking or notifying
      you.  Some kind of operating system that is in rather
      widespread use on PCs is known for this kind of
      user-unfriendliness (of course, it does this in the name of
      ``user-friendliness'').  At least one Award BIOS that is for
      example used in HP Netservers (but not only there) is known
      to ignore any harddisk that doesn't have what it believes to
      be a valid fdisk table.  When it comes to booting, it simply
      ignores such a disk drive, advances to the floppy drive, and
      barfs at you with just ``Read error''.  Very impressive, eh?
      They probably also call this ``user-friendly'', who knows?

      <p>The advantages of this mode are: FreeBSD owns the entire
      disk, no need to waste several fictitious `tracks' for just
      nothing but a 1980-aged simplistic partitioning model
      enforcing some artificial and now rather nonsensical
      constraints on how this partitioning needs to be done.
      These constraints often lead to what might be the biggest
      headaches for OS installations on PCs, geometry mismatch
      hassles resulting out of two different, redundant ways how
      to store the partitioning information in the fdisk table.
      See the chapter about <ref id="missing_os" name="Missing
      Operating System">.  In ``dangerously dedicated'' mode, the
      BSD bootstrap starts at sector 0, and this one is the only
      sector that always translates into the same C/H/S values,
      regardless of which `translation' your BIOS is using for
      your disk.  Thus, you can also swap disks between
      systems/controllers that use a different translation scheme,
      without risking that they won't boot anymore.

      <p>To return a ``dangerously dedicated'' disk for normal PC
      use, there are basically two options.  The first is, you
      write enough NULL bytes over the MBR to make any subsequent
      installation believe this to be a blank disk.  You can do
      this for example with

      <verb>
        dd if=/dev/zero of=/dev/rsd0 count=15
      </verb>

      <p>Alternatively, the undocumented DOS ``feature''

      <verb>
        fdisk /mbr
      </verb>

      <p>will to install a new master boot record as well, thus clobbering the
      BSD bootstrap.

    <sect1>
      <heading>How can I add more swap space?</heading>

      <p>The best way is to increase the size of your swap partition, or
      take advantage of this convenient excuse to add another disk (and
      see <ref id="swap" name="this note"> if you do).

      <p>Adding swap onto a separate disk makes things faster than
      simply adding swap onto the same disk.  As an example, if you
      are compiling source located on one disk, and the swap is on
      another disk, this is much faster than both swap and compile
      on the same disk.  This is true for SCSI disks specifically.

      <p> IDE drives are not able to allow access to both drives on
      the same channel at the same time (FreeBSD doesn't support mode 4, so
      all IDE disk I/O is ``programmed'').  I would still suggest putting
      your swap on a separate drive however.  The drives are so cheap,
      it is not worth worrying about.

      <p>It is a really bad idea to locate your swap file over NFS
      unless you are running in a very fast networking environment, with
      a good server.

      <p>Here is an example for 64Mb vn-swap (<tt>/usr/swap0</tt>, though
      of course you can use any name that you want).

      <p>Make sure your kernel was built with the line

      <verb>
        pseudo-device   vn 1   #Vnode driver (turns a file into a device)
      </verb>

      <p>in your config-file.  The GENERIC kernel already contains this.

      <enum>
        <item>create a vn-device

        <verb>
          cd /dev
          sh ./MAKEDEV vn0
        </verb>

        <item>create a swapfile (<tt>/usr/swap0</tt>)

        <verb>
          dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
        </verb>

        <item>enable the swap file in <tt>/etc/rc.conf</tt>

        <verb>
          swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
        </verb>

        <item>reboot the machine
      </enum>

      <p>To enable the swap file immediately, type

      <verb>
        vnconfig -ce /dev/vn0c /usr/swap0 swap
      </verb>

    <sect1>
      <heading>I'm having problems setting up my printer.</heading>

      <p>Please have a look at the Handbook entry on printing. It
      should cover most of your problem. See the
      <url url="../handbook/printing.html" name="Handbook entry on printing.">

    <sect1>
      <heading>The keyboard mappings are wrong for my system.</heading>

      <p>The kbdcontrol program has an option to load a keyboard map file.
      Under <tt>/usr/share/syscons/keymaps</tt> are a number of map
      files.  Choose the one relevant to your system and load it.

      <verb>
        kbdcontrol -l uk.iso
      </verb>

      <p>Both the <tt>/usr/share/syscons/keymaps</tt> and the <tt/.kbd/
      extension are assumed by 
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?kbdcontrol"
      name="kbdcontrol">.

      <p>This can be configured in <tt>/etc/sysconfig</tt> (or <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)" name="rc.conf">).
      See the appropriate comments in this file.

      <p>In 2.0.5R and later, everything related to text fonts, keyboard
      mapping is in <tt>/usr/share/examples/syscons</tt>.

      <p>The following mappings are currently supported:

      <itemize>
        <!-- generate by `kbdmap -p' -->
        <item>Belgian ISO-8859-1 
        <item>Brazilian 275 keyboard Codepage 850 
        <item>Brazilian 275 keyboard ISO-8859-1 
        <item>Danish Codepage 865 
        <item>Danish ISO-8859-1 
        <item>French ISO-8859-1 
        <item>German Codepage 850 
        <item>German ISO-8859-1 
        <item>Italian ISO-8859-1 
        <item>Japanese 106 
        <item>Japanese 106x 
        <item>Latin American 
        <item>Norwegian ISO-8859-1 
        <item>Polish ISO-8859-2 (programmer's) 
        <item>Russian Codepage 866 (alternative) 
        <item>Russian koi8-r (shift) 
        <item>Russian koi8-r 
        <item>Spanish ISO-8859-1 
        <item>Swedish Codepage 850 
        <item>Swedish ISO-8859-1 
        <item>Swiss-German ISO-8859-1 
        <item>United Kingdom Codepage 850 
        <item>United Kingdom ISO-8859-1 
        <item>United States of America ISO-8859-1 
        <item>United States of America dvorak 
        <item>United States of America dvorakx 
      </itemize>

    <sect1>
      <heading>I can't get user quotas to work properly.</heading>

      <p>
      <enum>
        <item>Don't turn on quotas on '/',

        <item>Put the quota file on the file system that the quotas are
        to be enforced on. ie:

        <verb>
          FS      QUOTA FILE
          /usr    /usr/admin/quotas
          /home   /home/admin/quotas
          ...
        </verb>
      </enum>

    <sect1>
      <heading>What's inappropriate about my ccd?</heading>

      <p>The symptom of this is:

      <verb>
        # ccdconfig -C
        ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format
        #
      </verb>

      <p>This usually happens when you are trying to concatenate the
      `c' partitions, which default to type `unused'.  The ccd
      driver requires the underlying partition type to be
      FS_BSDFFS.  Edit the disklabel of the disks you are trying
      to concatenate and change the types of partitions to
      `4.2BSD'.

    <sect1>
      <heading>Why can't I edit the disklabel on my ccd?</heading>

      <p>The symptom of this is:

      <verb>
        # disklabel ccd0
        (it prints something sensible here, so let's try to edit it)
        # disklabel -e ccd0
        (edit, save, quit)
        disklabel: ioctl DIOCWDINFO: No disk label on disk;
        use "disklabel -r" to install initial label
        #
      </verb>

      <p>This is because the disklabel returned by ccd is actually a
      `fake' one that is not really on the disk.  You can solve
      this problem by writing it back explicitly, as in:

      <verb>
        # disklabel ccd0 > /tmp/disklabel.tmp
        # disklabel -Rr ccd0 /tmp/disklabel.tmp
        # disklabel -e ccd0
        (this will work now)
      </verb>

    <sect1>
      <heading>Does FreeBSD support System V IPC primitives?</heading>

      <p>Yes, FreeBSD supports System V-style IPC.  This includes shared
      memory, messages and semaphores.  You need to add the following
      lines to your kernel config to enable them.

      <verb>
        options    SYSVSHM
        options    "SHMMAXPGS=64"   # 256Kb of sharable memory
        options    SYSVSEM          # enable for semaphores
        options    SYSVMSG          # enable for messaging
      </verb>

      <p>Recompile and install.

      <p><bf/NOTE:/ You may need to increase SHMMAXPGS to some
      ridiculous number like 4096 (16M!) if you want to run
      GIMP. 256Kb is plenty for X11R6 shared memory.

    <sect1>
      <heading>
        How do I use sendmail for mail delivery with UUCP?<label id="uucpmail">
      </heading>

      <p>The sendmail configuration that ships with FreeBSD is
      suited for sites that connect directly to the Internet.
      Sites that wish to exchange their mail via UUCP must install
      another sendmail configuration file.

      <p>Tweaking <tt>/etc/sendmail.cf</tt> manually is considered
      something for purists.  Sendmail version 8 comes with a
      new approach of generating config files via some 
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?m4"
      name="m4"> preprocessing, where the actual hand-crafted configuration
      is on a higher abstraction level.  You should use the
      configuration files under

      <verb>
        /usr/src/usr.sbin/sendmail/cf
      </verb>

      <p>If you didn't install your system with full sources, the sendmail
      config stuff has been broken out into a separate source distribution
      tarball just for you.  Assuming you've got your CD-ROM mounted, do:

      <verb>
        cd /usr/src
        tar -xvzf /cdrom/dists/src/ssmailcf.aa
      </verb>

      <p>Don't panic, this is only a few hundred kilobytes in size.
      The file <tt>README</tt> in the <tt>cf</tt> directory can
      serve as a basic introduction to m4 configuration.

      <p>For UUCP delivery, you are best advised to use the
      <em>mailertable</em> feature.  This constitutes a database
      that sendmail can use to base its routing decision upon.

      <p>First, you have to create your <tt>.mc</tt> file.  The
      directory <tt>/usr/src/usr.sbin/sendmail/cf/cf</tt> is the
      home of these files.  Look around, there are already a few
      examples.  Assuming you have named your file <tt>foo.mc</tt>,
      all you need to do in order to convert it into a valid
      <tt>sendmail.cf</tt> is:

      <verb>
        cd /usr/src/usr.sbin/sendmail/cf/cf
        make foo.cf
        cp foo.cf /etc/sendmail.cf
      </verb>

      <p>A typical <tt>.mc</tt> file might look like:

      <verb>
        include(`../m4/cf.m4')
        VERSIONID(`Your version number')
        OSTYPE(bsd4.4)

        FEATURE(nodns)
        FEATURE(nocanonify)
        FEATURE(mailertable)

        define(`UUCP_RELAY', your.uucp.relay)
        define(`UUCP_MAX_SIZE', 200000)

        MAILER(local)
        MAILER(smtp)
        MAILER(uucp)

        Cw    your.alias.host.name
        Cw    youruucpnodename.UUCP
      </verb>

      <p>The <em>nodns</em> and <em>nocanonify</em> features will
      prevent any usage of the DNS during mail delivery.  The
      <em>UUCP_RELAY</em> clause is needed for bizarre reasons,
      don't ask.  Simply put an Internet hostname there that
      is able to handle .UUCP pseudo-domain addresses; most likely,
      you will enter the mail relay of your ISP there.

      <p>Once you've got this, you need this file called
      <tt>/etc/mailertable</tt>.  A typical example of this
      gender again:

      <verb>
        #
        # makemap hash /etc/mailertable.db < /etc/mailertable
        #
        horus.interface-business.de   uucp-dom:horus
        .interface-business.de        uucp-dom:if-bus
        interface-business.de         uucp-dom:if-bus
        .heep.sax.de                  smtp8:%1
        horus.UUCP                    uucp-dom:horus
        if-bus.UUCP                   uucp-dom:if-bus
        .                             uucp-dom:sax
      </verb>

      <p>As you can see, this is part of a real-life file.  The first
      three lines handle special cases where domain-addressed mail
      should not be sent out to the default route, but instead to
      some UUCP neighbor in order to ``shortcut'' the delivery
      path.  The next line handles mail to the local Ethernet
      domain that can be delivered using SMTP.  Finally, the UUCP
      neighbors are mentioned in the .UUCP pseudo-domain notation,
      to allow for a ``uucp-neighbor!recipient'' override of the
      default rules.  The last line is always a single dot, matching
      everything else, with UUCP delivery to a UUCP neighbor that
      serves as your universal mail gateway to the world.  All of
      the node names behind the <tt>uucp-dom:</tt> keyword must
      be valid UUCP neighbors, as you can verify using the
      command <tt>uuname</tt>.

      <p>As a reminder that this file needs to be converted into a
      DBM database file before being usable, the command line to
      accomplish this is best placed as a comment at the top of
      the mailertable.  You always have to execute this command
      each time you change your mailertable.

      <p>Final hint: if you are uncertain whether some particular
      mail routing would work, remember the <tt>-bt</tt> option to
      sendmail.  It starts sendmail in <em>address test mode</em>;
      simply enter ``0 '', followed by the address you wish to
      test for the mail routing.  The last line tells you the used
      internal mail agent, the destination host this agent will be
      called with, and the (possibly translated) address.  Leave
      this mode by typing Control-D.

      <verb>
        j@uriah 191% sendmail -bt
        ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
        Enter <ruleset> <address>
        > 0 foo@interface-business.de
        rewrite: ruleset  0   input: foo @ interface-business . de
        ...
        rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
        < @ interface-business . de >
        > ^D
        j@uriah 192%
      </verb>

    <sect1>
      <heading>
        How do I set up mail with a dialup connection to the 'net?
        <label id="ispmail">
      </heading>

      <p>If you've got a statically assigned IP number, you should not
      need to adjust anything from the default.  Set your host name up
      as your assigned internet name and sendmail will do the rest.

      <p>If you've got a dynamically assigned IP number and use a dialup
      <bf/ppp/ connection to the internet, you will probably be given a
      mailbox on your ISPs mail server.  Lets assume your ISPs domain is
      <tt/myISP.com/, and that your user name is <tt/user/.  Lets also
      assume you've called your machine <tt/bsd.home/ and that your ISP
      has told you that you may use <tt/relay.myISP.com/ as a mail relay.

      <p>In order to retrieve mail from your mailbox, you'll need to
      install a retrieval agent.  <bf/Fetchmail/ is a good choice as it
      supports many different protocols.  Usually, POP3 will be provided
      by your ISP.  If you've chosen to use user-ppp, you can automatically
      fetch your mail when a connection to the 'net is established with the
      following entry in <tt>/etc/ppp/ppp.linkup</tt>:

      <verb>
        MYADDR:
          !bg su user -c fetchmail
      </verb>

      <p>I'm assuming that you have an account for <tt/user/ on <tt/bsd.home/.
      In the home directory of <tt/user/ on <tt/bsd.home/, create a
      <tt/.fetchmailrc/ file:

      <verb>
        poll myISP.com protocol pop3 fetchall pass MySecret;
      </verb>

      <p>Needless to say, this file should not be readable by anyone except
      <tt/user/ as it contains the password <tt/MySecret/.

      <p>In order to send mail with the correct <bf/from:/ header, you must
      tell sendmail to use <tt/user@myISP.com/ rather than
      <tt/user@bsd.home/.  You may also wish to tell sendmail to send all
      mail via <tt/relay.myISP.com/, allowing quicker mail transmission.

      <p>The following <tt/.mc/ file should suffice:

      <verb>
        VERSIONID(`bsd.home.mc version 1.0')
        OSTYPE(bsd4.4)dnl
        FEATURE(nouucp)dnl
        MAILER(local)dnl
        MAILER(smtp)dnl
        Cwlocalhost
        Cwbsd.home
        CwmyISP.com
        MASQUERADE_AS(`myISP.com')dnl
        FEATURE(allmasquerade)dnl
        FEATURE(masquerade_envelope)dnl
        FEATURE(nocanonify)dnl
        FEATURE(nodns)dnl
        define(SMART_HOST, `relay.myISP.com')
        DmmyISP.com
        define(`confDOMAIN_NAME',`myISP.com')dnl
        define(`confDELIVERY_MODE',`deferred')dnl
      </verb>

      <p>Refer to the previous section for details of how to turn this
      <tt/.mc/ file into a <tt/sendmail.cf/ file.  Also, don't forget to
      restart sendmail after updating sendmail.cf.

  </sect>

