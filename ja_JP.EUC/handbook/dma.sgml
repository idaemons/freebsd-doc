<!-- $Id: dma.sgml,v 1.10 1997-10-19 15:29:09 max Exp $ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.10 -->
<!-- 日本語訳 鈴木康修 (yasu@hike.te.chiba-u.ac.jp) -->
<!--
<!DOCTYPE linuxdoc PUBLIC "-//FreeBSD//DTD linuxdoc//EN" [

<!ENTITY % authors SYSTEM "authors.sgml">
%authors;

]>
-->
<sect><heading>DMAとはどういったものでどういう働きをするのか <label id="dma"></heading>

<p><em>原作: &a.uhclem;<newline>
<newline>訳: &a.yasu;<newline>
10 December 1996. 最終更新日 8 October 1997.</em>

<!-- Version 1(3) -->

        Direct Memory Access (DMA)は, 中央演算処理装置 (CPU)からの干渉なく
        データを計算機中である場所から別の場所に動かすための手法です. 

        DMA機能の実装の方法はそれぞれの計算機アーキテクチャ間で異なるもので
        あるため, ここでの議論はIBMパーソナルコンピュータ(PC), 
        PC/ATとその互換機におけるDMAサブシステムの実装と働きに限定します. 

        PCの DMAサブシステムは, Intelの 8237 DMAコントローラをベースにして
        います. 8237はそれぞれ独立にプログラムできる4つのDMAチャネルを持ち, 
        それぞれどのチャネルもいつでもアクティブにできます. 
        これらのチャネルは順に 0, 1, 2, 3となっています. 
        PC/ATからは, セカンド 8237 チップが追加され,それらは 4, 5, 6, 7と
        なっています. 

        オリジナルの DMAコントローラ(0, 1, 2, 3)は, 1回の転送で1バイト
        転送します.
	セカンドDMAコントローラ(4, 5, 6, 7)は1回で 隣接する2つのメモリ番地から
        16ビット転送します. 
        ここで, 最初のバイトは通常偶数のアドレスになります. 
        2つのコントローラは全く同じものであり, 転送量が異なるのは
        セカンドコントローラがシステムに直結しているためです. 

        8237 は個々のチャネルについて, DRQと-DACKという2つの電気信号を
        持っています. その他に, HRQ (Hold Request), HLDA (Hold Acknowledge), 
        -EOP (End of Process)があり, バス制御信号として -MEMR (Memory Read), 
        -MEMW (Memory Write), -IOR (I/O Read), and -IOW (I/O Write)があります. 

        8237 DMACは, いわゆる``fly-by'' DMAコントローラです. 
        これは, データの移動を行う際に, データは DMACチップを通過せず, 
        DMACチップに格納されないことを意味します. 
        また, DMACはI/Oポートとメモリアドレス間でのみデータを
        転送することができますが, 2つのI/Oポートもしくは2つのメモリアドレス
        間ではできません. 

      <quote><em>注:</em> 8237は, 非``fly-by''モードでは, 互いに接続された
        2つのチャネルでのメモリ-メモリ間でのDMA操作を許可します. 
        しかし, PCメーカは, ただでさえ乏しいこのリソースをこんなふうに
	使ったりしません。
        なぜなら, CPUを使用してメモリ間のデータを動かす方が早いからです. 
      </quote>

        PCアーキテクチャでは, それぞれのDMAチャネルは, 通常
        与えられたDMAチャネルを使用するハードウェアがそのチャネルについて
        DRQ線を使って転送を要求した時のみ動作します. 


    <sect1><heading>DMA転送の例</heading>

      <p>DMA転送の発生と処理の手順の例をあげてみましょう. 
        この例では, フロッピーディスクコントローラ (FDC)が
        ディスケットから1バイト読み込んで, DMAを使って,メモリの0x00123456番地に
        格納したいとします. 処理は, FDCが, DRQ2信号(DMAチャンネル2に
        対するDRQ線)を有効にして
        DMAコントローラに要求を伝えることで開始されます. 

        DMAコントローラはDRQ2シグナルが有効になったことを記録します. 
        するとDMAコントローラはDMAチャネル2がプログラムされ, マスクが
        かかっていない(有効になっている)ことを確認します. 
        同様に, DMAコントローラは, 他のDMAチャネルがアクティブまたは
	アクティブになろうとしていないこと, そしてより高い優先度を持って
        いないことを確認します. 
        一旦これらのチェックが完了すると, DMACはDMACがバスを使うために
        バスを開放するようにCPUに要求します. 
        DMACはCPUにHRQ信号を送ってバスを要求します. 

        CPUはHRQ信号を検出し, 現在の指示の実行を完了します. 
        一旦プロセッサがバスを開放することができる状態になると, 解放を
        行います. 
        通常は CPU により駆動される信号 (-MEMR, -MEMW, -IOR, -IOW, その他)を
        すべてハイインピーダンス (ハイともローとも指定しない)状態にした後, 
        CPUは HLDA信号を有効にして DMAコントローラにバスを明け渡したことを
        伝えます. 

        プロセッサによっては, CPUはバスを使用しないいくつかの
        命令を追加して実行することもできますが, 
        しかし,プロセッサの内部キャッシュやパイプライン以外のメモリから
        何か読み出すといった指示に到達したら結局CPUは待たなくてはなりません.

        ここで,DMACが バスを「託される」と,
        DMACはその -MEMR, -MEMW, -IOR, -IOW 出力信号をアクティブにし,
        DMACから出力されるアドレスは 0x3456にセットされます.これは
        転送しようとする特定のメモリ番地をバイトで指示するのに使われます.

        するとDMACはDMA転送をリクエストしたデバイスに転送が始まることを
        知らせます.これは -DACK信号をアクティブにすることで行われます. 
        フロッピーディスクコントローラの場合は, -DACK2を
        アクティブにすることで行われます.

        バスのデータ線に転送されるバイトにを出力することについては
        フロッピーディスクコントローラが責任をもつことになります.
        もし,フロッピーディスクコントローラがバス上にバイトデータを
        出力するのに余計な時間を必要としなければ 
        (もし周辺装置がもっと時間を必要とする場合には, READY信号を
        経由してDMACに通知します), DMAは 1 DMAクロック待ち,
	メモリにバス上のバイトデータを格納するために
        -MEMW および -IOR 信号を解除します. そして
        FDCはバイトデータが転送されたことを認識します.

        DMAサイクルは1度に1バイトしか転送しないので, 
        FDCはDRQ2信号を止めて, DMACに転送が終了したことを知らせます. 
        DMACは-DACK2信号を解除して, FDCはバス上へのデータ出力を
        停止しなくてはならないことを知らせます. 

        次にDMACは他のDMAチャネルのいずれかに要求がきていないか
        チェックを行います. もしどのチャネルのDRQも有効になっていなければ, 
        DMAコントローラは処理を完了して, -MEMR, -MEMW, -IOR, -IOW および
        アドレス信号をハイインピーダンス状態にします. 

        最後に, DMAはHRQ信号を解除します. CPUはこれを見ると,HOLDA信号を
        解除します. そしてCPUは自らの -MEMR, -MEMW, -IOR, -IOW 信号および
        アドレス線を有効にし, 命令の実行やメインメモリや周辺機器へのアクセスを
        再開します.

        典型的なフロッピーディスクの1セクタについては, 上記のプロセスが
	それぞれのバイトについて1回行われ, 全部で512回繰り返されます.  
        1バイト転送される毎に,DMAC内のアドレスレジスタはインクリメントされ,
        同じくDMAC内にある, 何バイト転送すればよいかを示すカウンタが
        デクリメントされます.

        カウンタが0になると, DMAはEOP信号を送ります. この信号は
        カウンタが0であり, DMAコントローラがCPUによって再び
        プログラムされるまで, これ以上データは転送されないことを
        示すものです. 

        このイベントはターミナルカウント(TC)とも呼ばれます. 
        EOP信号は1本しかありません. そして, 一度にアクティブにできる
        DMAチャネルは一本だけなので, 現在アクティブであるDMAチャネルこそが,
        たった今処理を終了したDMAチャネルだと言うことができます.

        もし, バッファの転送が完了した時に周辺機器から割り込みを発生させたい
	とき, 周辺機器は -DACKn信号およびEOP信号の両方が同時に発信されたか
	どうかをテストします. その場合, DMACはCPUの介在がなければ
	これ以上はその周辺機器についての情報を転送しません. 
        その後で, 周辺機器はプロセッサに割り込みを生じさせるために, 
        何らかの割り込み信号を発生させることができます. PCアーキテクチャ
        においては, DMAチップ自身が割り込みを生じさせることはできません. 
        周辺機器とそれに関連するハードウェアが割り込みを生成する責任を
        持ちます. また, DMAを使用する周辺機器が割り込みを使用しない
	可能性もあります.

        DMACが要求を出したときにはCPUは常にバスをDMACに開放しますが, 
        この動作は, DMACがアクティブになった時にプロセッサが命令を実行するのに
	かかる時間がわずかに変化することを除いては, アプリケーション, 
	オペレーティングシステムの両方からはわからないということを
	理解することが重要です. 
        そのため, プロセッサが確かにDMA転送が完了したことを知るためには, 
	周辺装置やDMAチップ中のレジスタを調べたり,周辺装置からの割り込みを
	受け取る必要があります. 


<sect1><heading>DMA ページレジスタ および 16メガ アドレス空間制限</heading>

      <p>これまで述べたのとは異なり, DMACはアドレス線を 0x0123456 にセットする
        代わりに 0x3456 だけをセットすることにあなたは気づいたかも
        しれません. この理由について少し説明します. 

        オリジナルのIBM PCがデザインされた時, IBMは, DMACと割込み制御チップの
        両方を, 8085(8ビットプロセッサで, 16ビットのアドレス空間(64k)を持つ)と
        組み合わせて使うように設計されたチップを使うことを選びました. 
        IBM PCが64k以上のメモリをサポートしていたため, 
        DMACが64kを越えるメモリ番地に読み込み又は書き込みを行うために
        変更を行う必要が生じました. 
        この問題を解決するためにIBMが行ったのは, それぞれのDMAチャネルに,
        読み込み元または書き込み先のアドレスの上位ビットを保持するための
        外部的なラッチを追加することでした.
        DMAチャネルがアクティブな時はいつでも, 
        このラッチの内容はアドレスバスに書かれて, そのチャネルのDMA操作が
        終了するまでそこに保持されます. 
        IBMはこれらのラッチを「ページレジスタ」と呼んでいます. 

        そのため上記に示した例では, DMACはアドレスの0x3456の部分をバス上に
        置き, DMAチャネル2に対するページレジスタは, 0x0012xxxxをバス上に
        置きます. これらの2つの値が組み合わされてアクセスされるメモリ中の完全な
        アドレスを形成します. 

        ページレジスタのラッチはDMAチップとは独立であるので, 
        読み込まれる又は書き込まれるメモリ領域は, 64kの物理的境界を
	またいではなりません. 例えば, もし
        DMACがメモリの0xffff番地をアクセスした場合, データの転送後, 
        DMACはアドレスレジスタをインクリメントし, 0x0000番地にある次のバイトを
        アクセスします.  0x10000番地ではありません. 
	これはおそらく意図されたものとは異なっているでしょう. 

        <quote><em>注:</em> 「物理的な」 64Kの境界を 8086モードの
        64k「セグメント」と混同してはいけません. セグメントは, セグメント
	レジスタに数学的にオフセットレジスタを加算して作られるものです. 
	ページレジスタにはアドレスのオーバーラップも無く,数学的に
	ORを取られることもありません. </quote>

        さらに複雑なことには, PC/ATでは外部のDMAアドレスのラッチは
        8ビットしか保持しません. よって8+16で24ビットになり, これは
        DMAが0から16メガの間のメモリ番地しか指し示せないことを
        意味します. 16メガ以上のメモリを持ったより新しいマシンにおいても, 
        標準的なPCコンパチブルなDMAでは16メガ以上のメモリ番地には
        アクセスできません. 

        この制限を避けるために, オペレーティングシステムは
        16メガ以下にある物理的な64kの境界をまたがない領域にRAMバッファを
        予約します. そして, DMACはデータを周辺機器からそのバッファに
        転送するようにプログラムされます. 一旦DMACがこのバッファに
        データを動かすと, オペレーティングシステムは本当にデータを
        格納したいアドレスにバッファからデータをコピーします. 

        16メガを越えるアドレスからDMAベースの周辺機器にデータを
        書き込む際には, データは16メガ以下に位置したバッファから最初に
        コピーされなくてはならず, その後, DMACはバッファからハードウェアに
        データをコピーすることができます. FreeBSDでは, これらの予約バッファは
        「バウンスバッファ」と呼ばれます. MS-DOSの世界では, 
        これらは「スマートバッファ」などと呼ばれます. 

        <quote><em>注意:</em> 82374と呼ばれる8237の新しい実装においては,
        ページレジスタを16ビットで指定して, バウンスバッファを使用しなくても,
        32ビットのアドレス空間全体にアクセスすることが可能です.</quote>


    <sect1><heading>DMA操作モードとその設定</heading>

      <p>8237 DMA はいくつかのモードで動作します. 主なモードは, 
        以下のとおりです. 

<descrip>

          <tag>シングル転送モード</tag>
            シングルバイト(もしくはワード)が転送されます. 
            DMAは1バイト毎にバスを開放し, 
            再び要求しなくてはなくてはなりません.
            これは一般に, すぐにはデータのブロック全てを転送できないデバイスに
            よって使用されます.
            周辺装置は次の転送の準備ができる毎にDMAを要求します. 

            標準的なPCコンパチブルなフロッピーディスクコントローラ(NEC 765)は
            1バイトのバッファしか持たないので, このモードを使用します. 


          <tag>ブロック/デマンド転送モード</tag>
            一旦DMACがシステムバスを取得すると, 最大64kまでのデータブロック
	    全体が転送されます. 
            もし周辺装置が余分に時間を必要とするときは, 
            転送を一時中断するためにREADY信号を有効にします. 
            READY信号は過度に使われるべきではなく, 遅い周辺装置の転送の場合は
            シングル転送モードを代わりに使うべきです. 

            ブロック転送モードとデマンド転送モードの違いは, 一旦ブロック転送が
            始まると,転送カウンタか0になるまでそれが行われるところです. 
            DRQは-DACKが有効になるまでの間は有効でなければなりません.
            デマンドモードはDRQが有効な間転送が続けられます. 
            DRQが有効でなくなった場合, DMAはその時点で転送を中断し,
            バスを解放してCPUに返します. 
	    その後、DRQが有効になると, 転送は中断したところから再開されます. 
 
            データの転送, 特に転送に使われるメモリ番地が16Mを越える場合に, 
            CPUを使った方が効率がよくなるまでCPUの速度が向上する以前の
            古いハードディスクコントローラはデマンドモードを使っていました. 


          <tag>カスケード転送モード</tag>
            このメカニズムはDMAチャネルがバスを要求することを許可する
            ものですが, 接続されたデバイスはバス上のアドレス情報の配置に
            ついてDMACに代わって責任を持ちます. 
            これは「バスマスタ」と呼ばれる技術の実装に利用されます. 

            カスケードモードのDMAチャネルがバスのコントロールを受け取ると, 
            DMAは通常行われるようなバス上のアドレスとI/Oコントロール信号の
            出力を行いません. 代わりに, DMAはアクティブなチャネルの -DACK信号を
            有効にします.

            この時点で, アドレスとバスコントロール信号の供給は
            DMAチャネルに接続された周辺機器が担当します. 
            周辺機器はシステムバスの完全なコントロールを行い, 
            16メガ以下の任意のアドレスの読み込みおよび書き込みを行うことが
            できます. 周辺機器はバスの使用を終えるとDRQ線を無効にするので, 
            DMAコントローラはCPUもしくは他のDMAチャネルに制御を返すことが
            できます. 

            カスケードモードは複数のDMAコントローラを相互接続するのに
	    使われます.  PC内ではDMAチャネル4がまさにこの用途に使われています. 
            周辺機器がDMAチャネル0, 1, 2, 3でバスを要求すると, 
            スレーブDMAコントローラは HLDREQ を有効にしますが, 
            この線はCPUではなく, 実際にはプライマリDMAコントローラのDRQ4に
            接続されています. 
            その後, チャンネル4になにか仕事があるものと見なしたプライマリの
            DMAコントローラは HLDREQ を使ってCPUにバスを
            要求します. バスが与えられると, -DACK4が有効になりますが, 
            この線は実際にはスレーブDMAコントローラの HLDA信号に
            接続されています. 
            スレーブDMAコントローラはその後要求したDMAチャネル 
            (0, 1, 2, 3) に対してデータを転送するか, SCSIコントローラのような
            バスマスタリングを要求する周辺機器にバスを許可します.

            このような配線がおこなわれているため, PC/ATシステムの
            周辺機器ではDMAチャネルは
            0, 1, 2, 3, 5, 6, 7のみが使用できます. 

            <quote><em>注:</em>
                初期のIBM PCコンピュータでは, DMAチャネル0は操作の
                リフレッシュのために予約されていますが, 
                最近のシステムでは通常, 周辺機器によって使用することができます. 
            </quote>

            周辺機器がバスマスタリングを行っている時は, 
            システムバスを保持している間絶えずメモリにもしくはメモリから
            データを転送することが重要です.もし, 周辺機器がこのように
            できないときは, システムがメインメモリのリフレッシュを
            行なえるようにしばしばバスを開放しなくてはなりません. 

            全てのPCでメインメモリとして使われるダイナミックRAMは, 
            中身が「満たされている」ビットを保持するため
            頻繁にアクセスされなくてはなりません. 
            ダイナミックRAMは, それぞれが1ビットのデータを記憶するコンデンサが
            たくさん集まって構成されています. これらのコンデンサは充電された
            状態で"1", 充電されていない状態で"0"を表します. 
            全てのコンデンサは放電するため, "1"の値を保持するために, 
            一定の間隔で電力を加える必要があります. 
            実際にRAMチップはRAMの適切な場所に電力を送る作業を行ないますが,
            メモリのリフレッシュ作業がRAMを普通にアクセスする時と
            衝突しないように, それをいつ行なうかを
            コンピュータが休止状態の時に知らせなくてはなりません. 
            もしコンピュータがメモリのリフレッシュを行なえない場合は, 
            メモリの中身はわずか数ミリ秒で壊れてしまいます。

            メモリの読み込みと書き込みのサイクルはリフレッシュサイクルとして
            カウントされる(ダイナミックRAMのリフレッシュサイクルは
            実際には不完全なメモリ読み込みサイクルになります)ので, 
            周辺機器のコントローラが連続するメモリ番地からデータの読み込み
            または書き込みを行う間は, メモリの全てがリフレッシュされます. 

            バスマスタリングはいくつかのSCSIホストインターフェースやその他の
	    ハイパフォーマンスな周辺機器コントローラに見られます. 


          <tag>自動初期化転送モード</tag>
            このモードにおいてDMAはバイト, ブロック, デマンド転送を行いますが, 
            DMA転送カウンタが0になると, カウンタとアドレスはDMAチャネルが
            もともとプログラムされた時のものに戻されます. 
            これは, 周辺機器が転送を要求している間は転送が続けられることを
            意味します. 
            転送領域としてDMACにプログラムされた固定バッファの中で, 
	    出力操作でDMACがデータを読み出す前もって新しいデータを
	    書き込んだり入力操作でDMACが書き込んだあとに, 
	    そこから新しいデータを読み出す作業はCPUが受け持ちます. 

            このテクニックは, サンプリング用のバッファが小さいもしくは 
            それを持たないオーディオデバイスによく使われます. 
            この「環状」バッファの管理は更なるCPUオーバーヘッドになりますが, 
            DMAカウンタが0になり, 再プログラムされるまでDMAが停止してしまう
            ことによって起きる遅延は, この方法でしかなくす事ができない
	    場合もあります. 
        </descrip>

    <sect1><heading>DMAのプログラミング</heading>

     <p>プログラムされるDMAチャネルは, 通常, 設定を行う前に
        「マスクする」べきです. 
        これはハードウェアが予期せずそのチャンネルに対してDRQを有効に
        した場合, たとえ全てのパラメータが
        満たされてない場合や更新されていない場合でも, DMACは
        それに応答してしまう可能性があるからです. 

        マスクを行ってから,ホストは転送の方向(メモリからI/O, 
        もしくはI/Oからメモリ)と, 転送に使用するDMA操作のモード
        (シングル, ブロック, デマンド, カスケードなど)を設定し, 最後に
        アドレスや転送の長さを設定します. 
        設定される長さはDMACに転送させたい量よりも1少なくなります. 
        アドレスや転送長のLSBとMSBは同じ8ビットI/Oポートに書き込まれます. 
	そのためDMACが最初のバイトをLSBとして, 2番目のバイトをMSBとして
	受け取ることを保証するために, 最初に別のポートに書き込みを行なって
	LSBとMSBの判別を行なうフリップフロップをクリアしておく必要があります. 

        そして,DMAのページレジスタを更新します. これはDMACの外部にあり
        I/Oポートの別のセットを通してアクセスされます. 

        すべての設定ができると, DMAチャネルはマスクを解除することができます. 
        そのDMAチャネルは「準備ができた」とみなされ, そのチャンネルのDRQが
        有効になると応答します.

        8237のプログラミングの正確な詳細については, 
        ハードウェアデータブックを参照してください. 
        PCシステムにおけるI/Oマップについても参照する必要があるでしょう. 
        このマップにはDMAおよびページレジスタのポートがどこに位置するのかを
        書いてあります. 以下に完全なポートのマップテーブルを示します.


    <sect1><heading>DMAポートのマップ</heading>

      <p>IBM-PCとPC/ATに基づくすべてのシステムでは, 同じI/Oポートに配置された
        DMAハードウェアを持っています. その完全なリストを以下に示します. 
        DMAコントローラ2に割り当てられたポートは, AT以外のデザインでは
	未定義になっています. 

<sect2><heading>0x00 - 0x1f DMA コントローラ &num;1 (Channels 0, 1, 2 and 3)</heading>

<p>DMA アドレス および カウントレジスタ

<verb>
0x00	write	Channel 0 starting address
0x00	read	Channel 0 current address
0x01	write	Channel 0 starting word count
0x01	read	Channel 0 remaining word count

0x02	write	Channel 1 starting address
0x02	read	Channel 1 current address
0x03	write	Channel 1 starting word count
0x03	read	Channel 1 remaining word count

0x04	write	Channel 2 starting address
0x04	read	Channel 2 current address
0x05	write	Channel 2 starting word count
0x05	read	Channel 2 remaining word count

0x06	write	Channel 3 starting address
0x06	read	Channel 3 current address
0x07	write	Channel 3 starting word count
0x07	read	Channel 3 remaining word count
</verb>

DMA コマンドレジスタ

<verb>
0x08	write	Command Register
0x08	read	Status Register
0x09	write	Request Register
0x09	read	-
0x0a	write	Single Mask Register Bit
0x0a	read	-
0x0b	write	Mode Register
0x0b	read	-
0x0c	write	Clear LSB/MSB Flip-Flop
0x0c	read	-
0x0d	write	Master Clear/Reset
0x0d	read	Temporary Register (新しいバージョンでは利用不可)
0x0e	write	Clear Mask Register
0x0e	read	-
0x0f	write	Write All Mask Register Bits
0x0f	read	Read All Mask Register Bits (Intel 82374にのみ存在する)
</verb>

<sect2><heading>0xc0 - 0xdf DMA コントローラ &num;2 (Channels 4, 5, 6 and 7)</heading>

<p>DMA アドレス および カウントレジスタ

<verb>
0xc0	write	Channel 4 starting address
0xc0	read	Channel 4 current address
0xc2	write	Channel 4 starting word count
0xc2	read	Channel 4 remaining word count

0xc4	write	Channel 5 starting address
0xc4	read	Channel 5 current address
0xc6	write	Channel 5 starting word count
0xc6	read	Channel 5 remaining word count

0xc8	write	Channel 6 starting address
0xc8	read	Channel 6 current address
0xca	write	Channel 6 starting word count
0xca	read	Channel 6 remaining word count

0xcc	write	Channel 7 starting address
0xcc	read	Channel 7 current address
0xce	write	Channel 7 starting word count
0xce	read	Channel 7 remaining word count
</verb>

DMA コマンドレジスタ

<verb>
0xd0	write	Command Register
0xd0	read	Status Register
0xd2	write	Request Register
0xd2	read	-
0xd4	write	Single Mask Register Bit
0xd4	read	-
0xd6	write	Mode Register
0xd6	read	-
0xd8	write	Clear LSB/MSB Flip-Flop
0xd8	read	-
0xda	write	Master Clear/Reset
0xda	read	Temporary Register (Intel 82374には存在しない)
0xdc	write	Clear Mask Register
0xdc	read	-
0xde	write	Write All Mask Register Bits
0xdf	read	Read All Mask Register Bits (Intel 82374にのみ存在する)
0xdf	read	Read All Mask Register Bits 
</verb>

<sect2><heading>0x80 - 0x9f DMA ページレジスタ</heading>

<p><verb>
0x87	r/w	Channel 0 Low byte (23-16) page Register
0x83	r/w	Channel 1 Low byte (23-16) page Register
0x81	r/w	Channel 2 Low byte (23-16) page Register
0x82	r/w	Channel 3 Low byte (23-16) page Register

0x8b	r/w	Channel 5 Low byte (23-16) page Register
0x89	r/w	Channel 6 Low byte (23-16) page Register
0x8a	r/w	Channel 7 Low byte (23-16) page Register
0x8f	r/w	Low byte page Refresh
</verb>

<sect2><heading>0x400 - 0x4ff 82374 Enhanced DMA Registers</heading>

<p>
Intel 82374 EISA System Component (ESC)は1996年の初めに発表されました. この中
には機能的には8237のスーパーセットであり, 1つのパッケージの中にその他の
PC互換機のコアとなる周辺コンポーネントをも含んだDMAコントローラも含まれています.
このチップはEISAとPCI両方のプラットホームをターゲットにしたものであり,
scatter-gather I/O やリングバッファを始めとして, システムDMAをして32ビットの
アドレス空間全体に直接アクセスする能力も提供しています.

<p>
これらの機能を使用する場合でも, 過去16年間のPC互換機で利用されてきた
同等機能を提供するコードも含めておく必要があります. 互換性の問題から, 82374の
レジスタの一部は, 従来の8237のレジスタをプログラムした<em>後</em>に, 
転送の度にプログラムされる必要があります. 8237のレジスタに書き込みを行うとき,
ソフトウェアの下位互換性のために, 82374で追加された一部のレジスタの内容が
強制的に0にクリアされるからです.


<p><verb>
0x401	r/w	Channel 0 High byte (bits 23-16) word count
0x403	r/w	Channel 1 High byte (bits 23-16) word count
0x405	r/w	Channel 2 High byte (bits 23-16) word count
0x407	r/w	Channel 3 High byte (bits 23-16) word count
0x4c6	r/w	Channel 5 High byte (bits 23-16) word count
0x4ca	r/w	Channel 6 High byte (bits 23-16) word count
0x4ce	r/w	Channel 7 High byte (bits 23-16) word count

0x487	r/w	Channel 0 High byte (bits 31-24) page Register
0x483	r/w	Channel 1 High byte (bits 31-24) page Register
0x481	r/w	Channel 2 High byte (bits 31-24) page Register
0x482	r/w	Channel 3 High byte (bits 31-24) page Register
0x48b	r/w	Channel 5 High byte (bits 31-24) page Register
0x489	r/w	Channel 6 High byte (bits 31-24) page Register
0x48a	r/w	Channel 6 High byte (bits 31-24) page Register
0x48f	r/w	High byte page Refresh

0x4e0	r/w	Channel 0 Stop Register (bits 7-2)
0x4e1	r/w	Channel 0 Stop Register (bits 15-8)
0x4e2	r/w	Channel 0 Stop Register (bits 23-16)
0x4e4	r/w	Channel 1 Stop Register (bits 7-2)
0x4e5	r/w	Channel 1 Stop Register (bits 15-8)
0x4e6	r/w	Channel 1 Stop Register (bits 23-16)
0x4e8	r/w	Channel 2 Stop Register (bits 7-2)
0x4e9	r/w	Channel 2 Stop Register (bits 15-8)
0x4ea	r/w	Channel 2 Stop Register (bits 23-16)
0x4ec	r/w	Channel 3 Stop Register (bits 7-2)
0x4ed	r/w	Channel 3 Stop Register (bits 15-8)
0x4ee	r/w	Channel 3 Stop Register (bits 23-16)
0x4f4	r/w	Channel 5 Stop Register (bits 7-2)
0x4f5	r/w	Channel 5 Stop Register (bits 15-8)
0x4f6	r/w	Channel 5 Stop Register (bits 23-16)
0x4f8	r/w	Channel 6 Stop Register (bits 7-2)
0x4f9	r/w	Channel 6 Stop Register (bits 15-8)
0x4fa	r/w	Channel 6 Stop Register (bits 23-16)
0x4fc	r/w	Channel 7 Stop Register (bits 7-2)
0x4fd	r/w	Channel 7 Stop Register (bits 15-8)
0x4fe	r/w	Channel 7 Stop Register (bits 23-16)

0x40a	write	Channels 0-3 Chaining Mode Register
0x40a	read	Channel Interrupt Status Register
0x4d4	write	Channels 4-7 Chaining Mode Register
0x4d4	read	Chaining Mode Status
0x40c	read	Chain Buffer Expiration Control Register

0x410	write	Channel 0 Scatter-Gather Command Register
0x411	write	Channel 1 Scatter-Gather Command Register
0x412	write	Channel 2 Scatter-Gather Command Register
0x413	write	Channel 3 Scatter-Gather Command Register
0x415	write	Channel 5 Scatter-Gather Command Register
0x416	write	Channel 6 Scatter-Gather Command Register
0x417	write	Channel 7 Scatter-Gather Command Register

0x418	read	Channel 0 Scatter-Gather Status Register
0x419	read	Channel 1 Scatter-Gather Status Register
0x41a	read	Channel 2 Scatter-Gather Status Register
0x41b	read	Channel 3 Scatter-Gather Status Register
0x41d	read	Channel 5 Scatter-Gather Status Register
0x41e	read	Channel 5 Scatter-Gather Status Register
0x41f	read	Channel 7 Scatter-Gather Status Register

0x420-0x423 r/w	Channel 0 Scatter-Gather Descriptor Table Pointer Register
0x424-0x427 r/w	Channel 1 Scatter-Gather Descriptor Table Pointer Register
0x428-0x42b r/w	Channel 2 Scatter-Gather Descriptor Table Pointer Register
0x42c-0x42f r/w	Channel 3 Scatter-Gather Descriptor Table Pointer Register
0x434-0x437 r/w	Channel 5 Scatter-Gather Descriptor Table Pointer Register
0x438-0x43b r/w	Channel 6 Scatter-Gather Descriptor Table Pointer Register
0x43c-0x43f r/w	Channel 7 Scatter-Gather Descriptor Table Pointer Register
</verb>

