<!--
        The FreeBSD Documentation Project
        The FreeBSD French Documentation Project

        $FreeBSD$
        Original revision: 1.8
--> 

<chapter id="internals">
  <title>Les &ldquo;internes&rdquo; de FreeBSD</title>
  &trans.a.haby;
  
  <sect1 id="booting">
    <title>Le processus de d&eacute;marrage</title>
    
    <para><emphasis>Contribution de &a.phk;. v1.1, 16 Avril 
      1995.</emphasis></para>
	
    <para>Le d&eacute;marrage de FreeBSD est essentiellement un processus en 
      trois &eacute;tapes&nbsp;: charger le noyau, identifier le syst&egrave;me
      de fichiers racine et initialiser utilisateur. Cela autorise 
      d'int&eacute;ressantes combinaisons d&eacute;crites plus loin.</para>
	
    <sect2>
      <title>Charger un noyau</title>
      
      <para>Nous disposons actuellement des trois m&eacute;canismes de base
        d&eacute;crits ci-dessous pour charger un noyau&nbsp;: ils transmettent
        tous des informations au noyau afin de l'aider &agrave; d&eacute;cider 
        de ce qu'il doit faire ensuite.</para>
	  
      <variablelist>
	<varlistentry>
	  <term>Biosboot</term>

	  <listitem>
	    <para>Biosboot est notre &ldquo;code de d&eacute;marrage&rdquo;. 
              Il consiste en deux fichiers qui seront copi&eacute;s sur les huit
              premiers kilo-octets de la disquette ou de la
              &ldquo;tranche&rdquo;&nbsp;-&nbsp;<foreignphrase>slice</foreignphrase>&nbsp;-&nbsp;du 
              disque dur &agrave; partir de laquelle on d&eacute;marrera.</para>
		  
	    <para>Biosboot peut charger un noyau donn&eacute; par son nom dans 
              un syst&egrave;me de fichiers FreeBSD.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>Dosboot</term>
	  
	  <listitem>
	    <para>Dosboot a &eacute;t&eacute; &eacute;crit par DI. Christian 
              Gusenbauer, et c'est malheureusement actuellement l'un des
              quelques codes qui ne compilent pas sous FreeBSD, parce qu'il est
              &eacute;crit pour les compilateurs Microsoft.</para>
		  
	    <para>Dosboot peut charger un noyau depuis un fichier MS-DOS ou un
              syst&egrave;me de fichiers FreeBSD sur disque. Il essaye de 
              n&eacute;gocier avec les divers et &eacute;tranges 
              gestionnires de m&eacute;moire qui hantent les adresses hautes des
              syst&egrave;mes MS-DOS et les gagne en g&eacute;n&eacute;ral 
              &agrave; sa cause.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>Netboot</term>
		
	  <listitem>
	    <para>Netboot recherche une carte Ethernet support&eacute;e et
              utilise BOOTP, TFTP et NFS pour trouver un noyau permettant de
              d&eacute;marrer.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
	
    <sect2>
      <title>Identifier le syst&egrave;me de fichiers racine</title>
      
      <para>D&egrave;s que le noyau est charg&eacute; et que le code de 
        d&eacute;marrage lui passe la main, le noyau s'initialise, il essaie de
        d&eacute;terminer quels sont les mat&eacute;riels install&eacute;s, et 
        ainsi de suite; il lui faut ensuite trouver le syst&egrave;me de 
        fichiers racine.</para>
      
      <para>Nous reconnaissons actuellement les types suivants de 
        syst&egrave;mes de fichiers racine&nbsp;:</para>

      <variablelist>
	<varlistentry>
	  <term>UFS</term>

	  <listitem>
	    <para>C'est le type de syst&egrave;me de fichiers racine le plus
              habituel. Il peut &ecirc;tre sur disquette ou sur disque 
              dur.</para>
	  </listitem>
	</varlistentry>
	      
	<varlistentry>
	  <term>MSDOS</term>
	  
	  <listitem>
	    <para>Bien que ce soit techniquement possible, ce n'est pas 
              particuli&egrave;rement utile, du fait de l'impossibilit&eacute;
              pour le syst&egrave;me de fichiers <acronym>FAT</acronym> de
              g&eacute;rer les liens, les fichiers sp&eacute;ciaux et autres
              particularit&eacute;s &ldquo;UNIX&rdquo;.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>MFS</term>
		
	  <listitem>
	    <para>Il s'agit en r&eacute;lit&eacute; d'un syst&egrave;me de 
              fichiers UFS int&eacute;gr&eacute; au noyau &agrave; la 
              compilation de ce dernier. Cela signifie que le noyau n'a pas 
              vraiment besoin de disque dur, disquette ou autre mat&eacute;riel
              pour s'ex&eacute;cuter.</para>  
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>CD9660</term>
	  
	  <listitem>
	    <para>Cela permet d'utiliser un CD-ROM comme syst&egrave;me de 
              fichiers racine.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>NFS</term>
	  
	  <listitem>
	    <para>Cela permet d'utiliser un serveur de fichiers comme 
              syst&egrave;me de fichiers racine, essentiellement pour
              faire fonctionner une machine sans disque dur.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
	
    <sect2>
      <title>Initialiser l'environnement utilisateur</title>
      
      <para>Pour que les programmes utilisateur puissent s'ex&eacute;cuter, le 
        noyau, quand la phase d'initialisation est termin&eacute;e, lance un
        processus de <literal>pid == 1</literal> et ex&eacute;cute
        un programme du syst&egrave;me de fichiers racine;, normalement
	<filename>/sbin/init</filename>.</para>
	  
      <para>Vous pouvez remplacer <command>/sbin/init</command> par n'importe 
        quel programme, tant que vous vous rappelez que&nbsp;:</para>
      
      <para>Il n'y a pas de stdin/out/err &agrave; moins que vous ne les ouvriez
        vous-m&ecirc;me. Si vous sortez du programme, la machine panique. La
        gestion des signaux par le processus de <literal>pid == 1</literal> est 
        particuli&egrave;re &agrave; ce processus.</para>
      
      <para>Le programme <command>/stand/sysinstall</command> de la disquette 
        d'installation est un exemple d'&ldquo;init&rdquo; adapt&eacute;.</para>
    </sect2>
    
    <sect2>
      <title>Combinaisons int&eacute;ressantes</title>
      
      <para>D&eacute;marrer un noyau contenant un syst&egrave;me de fichiers MFS
        avec un programme <filename>/sbin/init</filename> particulier 
        qui...</para>
	    
      <variablelist>
	<varlistentry>
	  <term>A &mdash; En utilisant DOS</term>

	  <listitem>
	    <itemizedlist>
	      <listitem>
		<para>monte votre disque <filename>C:</filename> sous le
		  r&eacute;pertoire <filename>/C:</filename></para>
	      </listitem>
	      
	      <listitem>
		<para>attache le fichier sp&eacute;cial 
                  <filename>/dev/vn0</filename> au fichier
                  <filename>C:/freebsd.fs</filename></para>
	      </listitem>
	      
	      <listitem>
		<para>monte <filename>/dev/vn0</filename> sous
		  <filename>/rootfs</filename></para>
	      </listitem>
	      
	      <listitem>
		<para>cr&eacute;e les liens symboliques
		  <filename>/rootfs/bin</filename> -&gt;
		  <filename>/bin</filename>, 
		  <filename>/rootfs/etc</filename> -&gt;
		  <filename>/etc</filename>,
		  <filename>/rootfs/sbin</filename> -&gt;
		  <filename>/sbin</filename> (etc.)</para>
	      </listitem>
	    </itemizedlist>
	    
	    <para>Vous faites maintenant tourner FreeBSD sans avoir 
              repartitionn&eacute; votre disque dur...</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>B &mdash; En utilisant NFS</term>
	  
	  <listitem>
	    <itemizedlist>
	      <listitem>
	        <para>monte avec NFS votre 
                  <filename>serveur:~vous/FreeBSD</filename> sur 
                  <filename>/nfs</filename>, red&eacute;finit la racine comme
                  <filename>/nfs</filename>&nbsp;-&nbsp;avec
                  <citerefentry><refentrytitle>chroot</refentrytitle>  
                  <manvolnum>8</manvolnum></citerefentry>&nbsp;-&nbsp;et
	          y ex&eacute;cute <filename>/sbin/init</filename></para>
	      </listitem>
	    </itemizedlist>

	    <para>Vous faites maintenant tourner FreeBSD sans disque dur, bien
              que vous n'ayez pas le contr&ocirc;le du serveur NFS...</para> 
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>C &mdash; D&eacute;marre un serveur X</term>
	  
	  <listitem>
	    <para>Vous avez maintenant un terminal X, bien plus efficace que X 
              sous Windows, tellement lent que vous pouvez- voir- tout- ce 
              qu'il- fait, alors que votre patron assure que cela est toujours 
              mieux que de d&eacute;penser encore de l'argent en 
              mat&eacute;riel.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>D &mdash; En utilisant une bande</term>
	  
	  <listitem>
            <itemizedlist>
              <listitem>
  	        <para>copie <filename>/dev/rwd0</filename> sur un lecteur de 
                  bandes sur le r&eacute;seau ou sur un serveur de 
                  fichiers.</para>
              </listitem>
            </itemizedlist>
		  
	    <para>Vous avez finalement la sauvegarde que vous auriez d&ucirc;
              faire il y a un an d&eacute;j&agrave;...</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>E &mdash; Fonctionne 
            comme coupe-feu&nbsp;/&nbsp;serveur Web&nbsp;/&nbsp;que sais-je
            encore...</term>
		
	  <listitem>
	    <para>C'est particuli&egrave;rement int&eacute;ressant parce que 
              vous pouvez d&eacute;marrer &agrave; partir d'une disquette 
              prot&eacute;g&eacute;e en &eacute;criture, et pouvez malgr&eacute;
              tout &eacute;crire sur votre syst&egrave;me de fichiers 
              racine.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>
      
  <sect1 id="memoryuse">
    <title>Utilisation de la m&eacute;moire du PC</title>
	
    <para><emphasis>Contribution de &a.joerg;. 16 Avril 1995.</emphasis></para>
	
    <para><emphasis>Une br&egrave;ve description de la mani&egrave;re dont 
      FreeBSD utilise la m&eacute;moire sur les plates-formes 
      i386</emphasis></para>
	
    <para>Le secteur de d&eacute;marrage est charg&eacute; &agrave; l'adresse
      <literal>0:0x7c00</literal>, et se reloge imm&eacute;diatement &agrave;
      l'adresse <literal>0x7c0:0</literal>. (Il n'y a rien de myst&eacute;rieux
      l&agrave;-dedans, c'est seulement un ajustement du registre
      <literal>%cs</literal>, effectu&eacute; par un
      <literal>ljmp</literal>.)</para>
	
    <para>Il charge ensuite les quinze premiers secteurs &agrave; l'adresse
      <literal>0x10000</literal> (segment <makevar>BOOTSEG</makevar> dans le 
      <filename>Makefile</filename> de 
      <citerefentry><refentrytitle>biosboot</refentrytitle></citerefentry>), et 
      initialise la pile pour qu'elle travaille aux adresses en-dessous
      de <literal>0x1fff0</literal>. Il passe ensuite au point d'entr&eacute;e
      <literal>boot2</literal> de ce code, i.e. il se branche au-del&agrave; de
      lui-m&ecirc;me et de la table de partition (fictive), et ajuste le 
      registre <literal>%cs</literal>&mdash;nous sommes alors encore en
      mode 16-bits.</para>
	
    <para><literal>boot2</literal> recherche le fichier de d&eacute;marrage, et 
      examine son en-t&ecirc;te <filename>a.out</filename>. Il masque le point 
      d'entr&eacute;e de ce fichier (habituellement 
      <literal>0xf0100000</literal>) avec <literal>0x00ffffff</literal> et
      charge le code &agrave; l'adresse ainsi obtenue. Il est donc 
      g&eacute;n&eacute;ralement charg&eacute; &agrave; l'adresse 1 MB 
      (<literal>0x00100000</literal>).  Pendant le chargement, le code va et 
      vient entre le mode r&eacute;el et le mode prot&eacute;g&eacute;, pour
      utiliser le BIOS en mode r&eacute;el.</para>
	
    <para>Le code de d&eacute;marrage lui-m&ecirc;me utilise les 
      s&eacute;lecteurs de segment <literal>0x18</literal> et
      <literal>0x20</literal> pour <literal>%cs</literal> et
      <literal>%ds/%es</literal> en mode prot&eacute;g&eacute;, et
      <literal>0x28</literal> pour revenir en mode r&eacute;el.  Le noyau est
      finalement lanc&eacute; avec <literal>%cs</literal> 
      <literal>0x08</literal> et <literal>%ds/%es/%ss</literal> 
      <literal>0x10</literal>, qui constituent des descripteurs fictifs
      recouvrant la totalit&eacute; de l'espace d'adressage.</para>
	
    <para>Le noyau d&eacute;marre &agrave; l'adresse &agrave; laquelle il est 
      charg&eacute;. Comme son &eacute;dition de liens a &eacute;t&eacute;
      effectu&eacute;e pour une autre adresse (haute), il doit ex&eacute;cuter
      du code <literal>PIC</literal> jusqu'&agrave; ce que la table de pages et
      le r&eacute;pertoire des pages soient correctement renseign&eacute;s, la
      pagination peut alors &ecirc;tre activ&eacute;e et le noyau 
      s'ex&eacute;cuter &agrave; l'adresse pour laquelle il a &eacute;t&eacute;
      g&eacute;n&eacute;r&eacute;.</para>
	
    <para><emphasis>Contribution de &a.dg;. 16 Avril 1995.</emphasis></para>
	
    <para>Les pages physiques qui suivent imm&eacute;diatement le segment
      <literal>BSS</literal> du noyau contiennent le r&eacute;pertoire de pages
      de <literal>proc0</literal>, ses tables de pages et les 
      pages utilisateur. Plus tard, quand le syst&egrave;me de 
      m&eacute;moire virtuelle est initialis&eacute;, la m&eacute;moire
      physique entre <literal>0x1000-0x9ffff</literal> et la m&eacute;moire
      physique apr&egrave;s le noyau (<literal>text+data+bss+proc0+d'autres 
      choses</literal>) est mise &agrave; disposition sous forme de pages de 
      m&eacute;moire virtuelle ordinaires et ajout&eacute;e &agrave; la liste 
      globales des pages libres.</para>
  </sect1>
      
  <sect1 id="dma">
    <title>L'acc&egrave;s direct &agrave; la 
      m&eacute;moire&nbsp;-&nbsp;-<foreignphrase>DMA</foreignphrase>&nbsp;: 
      Qu'est-ce que c'est et comment &ccedil;a marche</title>

    <para><emphasis>Copyright &copy; 1995,1997 &a.uhclem;, Tous Droits
	R&eacute;serv&eacute;s. 10 D&eacute;cembre 1996. Derni&egrave;re mise
        &agrave; jour le 8 Octobre 1997.</emphasis></para>
	
    <para>L'acc&egrave;s direct &agrave; la 
      m&eacute;moire&nbsp;-&nbsp;<foreignphrase>Direct 
      Memory Access (DMA)</foreignphrase>&nbsp;-&nbsp;est une technique qui
      permet que les mouvements de donn&eacute;es entre la m&eacute;moire et 
      les p&eacute;riph&eacute;riques se fassent sans intervention de 
      l'unit&eacute; centrale (<foreignphrase>CPU</foreignphrase>).</para>
	
    <para>L'impl&eacute;mentation de l'acc&egrave;s direct &agrave; la 
      m&eacute;moire diff&egrave;re selon les architectures mat&eacute;rielles,
      nous limiterons donc la discussion &agrave; son impl&eacute;mentation sur
      l'ordinateur personnel IBM (<foreignphrase>PC</foreignphrase>), sur l'IBM
      PC/AT, ses successeurs et ses diff&eacute;rents clones.</para>
	
    <para>Le sous-syst&egrave;me DMA du PC repose sur le contr&ocirc;leur DMA
      Intel 8237. Ce contr&ocirc;leur g&egrave;re quatre canaux DMA qui peuvent
      &ecirc;tre programm&eacute;s s&eacute;par&eacute;ment et chacun de ces 
      canaux peut &ecirc;tre le canal actif &agrave; un moment donn&eacute;. Ces
      canaux sont num&eacute;rot&eacute;s 0, 1, 2 et 3. Depuis le PC/AT, IBM a 
      ajout&eacute; une seconde puce 8237, et num&eacute;rot&eacute; ces canaux
      4, 5, 6 et 7.</para>
	
    <para>Le contr&ocirc;leur DMA d'origine (0,1, 2 et 3) effectue les 
      transferts octet par octet. Le second contr&ocirc;leur DMA (4, 5, 6 et 7) 
      effectue les transferts 16 bits par 16 bits, le premier octet &eacute;tant
      toujours un octet d'adresse paire. Les deux contr&ocirc;leurs sont des 
      composants identiques, la diff&eacute;rence dans la taille des transferts 
      vient du c&agrave;blage diff&eacute;rent du second 
      contr&ocirc;leur.</para>
	
    <para>Il y a deux signaux &eacute;lectriques par canal sur le 8237, 
      appel&eacute;s DRQ (<foreignphrase>Data Request</foreignphrase>) et -DACK
      (<foreignphrase>Data Acknowledge</foreignphrase>). Il y a des signaux            suppl&eacute;mentaires dont les noms sont HRQ (<foreignphrase>Hold 
      Request</foreignphrase>), HLDA (<foreignphrase>Hold 
      Ackwnoledge</foreignphrase>), -EOP (<foreignphrase>End Of 
      Process</foreignphrase>) et des signaux de contr&ocirc;le du bus -MEMR 
      (<foreignphrase>Memory Read</foreignphrase>), -MEMW (<foreignphrase>Memory
      Write</foreignphrase>), -IOR (<foreignphrase>I/O Read</foreignphrase>) et
      IOW (<foreignphrase>I/O Write</foreignphrase>).</para>
	
    <para>Le contr&ocirc;leur DMA 8237 est un contr&ocirc;leur
      &ldquo;<foreignphrase>fly-by</foreignphrase>&rdquo;&nbsp;-&nbsp;transparent. 
      Cela signifie que les donn&eacute;es transf&eacute;r&eacute;es ne 
      transitent pas par la puce DMA et n'y sont pas m&eacute;moris&eacute;es. 
      En cons&eacute;quence, le DMA ne peut effectuer de transferts qu'entre un
      port d'entr&eacute;e/sortie et la m&eacute;moire, pas entre deux ports 
      d'entr&eacute;e/sortie ou deux adresses m&eacute;moire.</para>
	
    <note>
      <para>Le 8237 autorise l'interconnexion de deux de ses canaux pour 
        permettre les op&eacute;rations DMA de m&eacute;moire &agrave; 
        m&eacute;moire, en mode
        non-&ldquo;<foreignphrase>fly-by</foreignphrase>&rdquo;, mais nul dans 
        l'industrie du PC n'utilise cette ressource rare de cette fa&ccedil;on,
        parce qu'il est plus rapide de transf&eacute;rer des donn&eacute;es 
        entre deux adresses m&eacute;moire en passant par le processeur.</para>
    </note>
	
    <para>Dans l'architecture PC, chaque canal DMA est normalement activ&eacute;
      uniquement quand le mat&eacute;riel qui utilise le canal DMA en question 
      demande un transfert en validant la ligne DRQ pour ce canal.</para>
	
    <sect2>
      <title>Un exemple de transfert DMA</title>
      
      <para>Voici un exemple des &eacute;tapes successives qui provoquent et 
        effectuent un transfert DMA. Dans cet exemple, le contr&ocirc;leur
        du lecteur de disquette&nbsp;-&nbsp;<foreignphrase>floppy disk 
        controller (FDC)</foreignphrase>&nbsp;-&nbsp;vient de lire un octet sur
        la disquette et demande au DMA de le ranger &agrave; l'adresse 
        m&eacute;moire <literal>0x00123456</literal>. Le processus commence 
        quand le FDC active le signal DRQ2 (la ligne DRQ pour le canal DMA
        num&eacute;ro 2) pour pr&eacute;venir le contr&ocirc;leur DMA.</para>
	  
      <para>Le contr&ocirc;leur DMA s'aper&ccedil;oit que le signal DRQ2 est
        positionn&eacute; et s'assure que le canal DMA 2 est programm&eacute;
        et non-masqu&eacute; (activ&eacute;). Le contr&ocirc;leur DMA s'assure
        aussi qu'aucun autre canal DMA n'est actif ou ne demande &agrave;
        l'&ecirc;tre et poss&egrave;de une plus haute priorit&eacute;. Ces
        v&eacute;rifications faites, le DMA demande au processeur de 
        lib&eacute;rer le bus pour pouvoir l'utiliser. Il le fait en activant 
        le signal HRQ, envoy&eacute; au processeur.</para>
	  
      <para>Le CPU d&eacute;tecte le signal HRQ et termine l'ex&eacute;cution de
        l'instruction en cours. D&egrave;s que le processeur est en mesure de 
        lib&eacute;rer le bus, il le fait. Tous les signaux normalement
        g&eacute;n&eacute;r&eacute;s par le processeur (-MEMR, -MEMW, -IOR,
        -IOW et quelques autres) sont positionn&eacute;s dans un &eacute;tat
        interm&eacute;diaire (ni haut, ni bas), puis le CPU positionne le
        signal HDLA qui pr&eacute;vient le contr&ocirc;leur DMA qu'il a 
        maintenant le contr&ocirc;le du bus.</para>
	  
      <para>Selon le processeur, le CPU peut encore &ecirc;tre capable 
        d'ex&eacute;cuter quelques instructions suppl&eacute;mentaires bien 
        qu'il n'ait plus acc&egrave;s au bus, mais il peut aussi devoir 
        attendre lorsqu'il arrive sur une instruction qui doit lire une
        donn&eacute;e en m&eacute;moire et que celle-ci ne se trouve pas dans le
        cache interne du processeur ou dans son 
        canal&nbsp;-&nbsp;&ldquo;<foreignphrase>pipeline</foreignphrase>&rdquo;.</para>
	  
      <para>Maintenant que le DMA &ldquo;a la main&rdquo;, il active ses signaux
	de sortie -MEMR, -MEMW, -IOR, -IOW, et fixe l'adresse de sortie du DMA 
        en <literal>0x3456</literal>, adresse qui sera utilis&eacute;e pour 
        diriger l'octet qui va &ecirc;tre transf&eacute;r&eacute; vers une 
        adresse m&eacute;moire donn&eacute;e.</para>
	  
      <para>Le DMA avertit ensuite le p&eacute;riph&eacute;rique qui a 
        demand&eacute; le transfert que celui-ci commence, en positionnant le
        signal -DACK, ou, dans le cas du contr&ocirc;leur de disquette, le 
        signal -DACK2.</para>
	  
      <para>C'est maintenant au contr&ocirc;leur de disquette de placer l'octet
        &agrave; transf&eacute;rer sur les lignes de donn&eacute;es du bus. A 
        moins qu'il ne faille plus de temps au contr&ocirc;leur de disquette 
        pour placer l'octet de donn&eacute;e sur le bus (et dans ce cas, il
        pr&eacute;vient le DMA via le signal READY), le DMA attend un cycle de
        son horloge, puis d&eacute;sactive les signaux -MEMW et -IOR, de
        fa&ccedil;on &agrave; ce que la m&eacute;moire bascule et stocke
        l'octet qui se trouve sur le bus, et que le contr&ocirc;leur de
        disquette sache que l'octet a &eacute;t&eacute; 
        transf&eacute;r&eacute;.</para>
	  
      <para>Comme le DMA ne transf&egrave;re qu'un seul octet &agrave; la fois 
        et par cycle, le FDC d&eacute;sactive maintenant le signal DRQ2, de
        sorte que le DMA sache que l'on n'a plus besoin de ses services. Le
        DMA d&eacute;sactive alors le signal -DACK2, pour avertir le FDC de
        ne plus mettre de donn&eacute;e sur le bus.</para>
	  
      <para>Le DMA regarde alors si les autres canaux DMA ont des 
        op&eacute;rations &agrave; effectuer. Si aucun des canaux n'a sa ligne 
        DRQ active, le travail du contr&ocirc;leur DMA est termin&eacute; et il
        positionne ses signaux -MEMR, -MEMW, -IOR, -IOW et d'adresse dans un 
        &eacute;tat interm&eacute;diaire.</para>
	  
      <para>Pour finir, le DMA d&eacute;sactive le signal HRQ. Le CPU s'en
        aper&ccedil;oit et d&eacute;sactive le signal HOLDA puis active ses 
        signaux -MEMR, -MEMW, -IOR, -IOW et d'adresse et enfin reprend 
        l'ex&eacute;cution des instructions et ses acc&egrave;s &agrave; la 
        m&eacute;moire et aux p&eacute;riph&eacute;riques.</para>
	  
      <para>Pour un secteur de disquette typique, le processus ci-dessus est
        r&eacute;p&eacute;t&eacute; 512 fois, une fois pour chaque octet. Chaque
        fois qu'un octet est transf&eacute;r&eacute;, le registre d'adresse du
        DMA est incr&eacute;ment&eacute; et le compteur du DMA qui indique
        combien d'octets ont &eacute;t&eacute; transf&eacute;r&eacute;s,
        d&eacute;cr&eacute;ment&eacute;.</para>
	  
      <para>Quand le compteur arrive &agrave; z&eacute;ro, le DMA positionne le
        signal EOP, qui indique que son compteur est nul et qu'aucune autre
        donn&eacute;e ne sera transf&eacute;r&eacute;e tant que le
        contr&ocirc;leur DMA n'aura pas &eacute;t&eacute; reprogramm&eacute; par
        le CPU. Cet &eacute;v&eacute;nement est aussi appel&eacute;
        &ldquo;fin de d&eacute;compte&rdquo;&nbsp;-&nbsp;<foreignphrase>Terminal
        Count (TC)</foreignphrase>. Il n'y a qu'un seul signal EOP, et comme il
        ne peut y avoir qu'un seul canal DMA actif &agrave; un moment 
        donn&eacute;, c'est n&eacute;cessairement le canal DMA actuellement 
        actif qui vient de terminer sa t&acirc;che.</para>
	  
      <para>Si un p&eacute;riph&eacute;rique veut g&eacute;n&eacute;rer une
        interruption &agrave; la fin du transfert d'un tampon, il peut tester si
        les signaux -DACKn et EOP sont simultan&eacute;ment actifs. Quand cela 
        se produit, c'est que le DMA ne transf&eacute;rera plus d'autre 
        donn&eacute;e pour ce p&eacute;riph&eacute;rique sans intervention du
        CPU. Le p&eacute;riph&eacute;rique peut alors positionner un de ses
        signaux d'interruption pour avertir le CPU. Dans l'architecture PC, le
        circuit DMA lui-m&ecirc;me ne peut pas g&eacute;n&eacute;rer 
        d'interruption. Le p&eacute;riph&eacute;rique et l'&eacute;lectronique
        associ&eacute;e sont responsables de la g&eacute;n&eacute;ration de
        toutes les interruptions qui peuvent intervenir. Il est en 
        cons&eacute;quence impossible d'avoir des p&eacute;riph&eacute;riques 
        qui utilisent le DMA mais n'emploient pas d'interruptions.</para>
	  
      <para>Il est important de comprendre que bien que le CPU laisse toujours
        l'acc&egrave;s au bus au DMA quand le DMA effectue sa demande, cette
        action est transparente pour les applications et pour le 
        syst&egrave;me d'exploitation, hormis pour le petit temps 
        suppl&eacute;mentaire que met le processeur agrave; ex&eacute;cuter des
        instructions quand le DMA est actif. En cons&eacute;quence, le 
        processeur doit interroger les p&eacute;riph&eacute;riques, les 
        registres du DMA ou recevoir une interruption du 
        p&eacute;riph&eacute;rique pour &ecirc;tre s&ucirc;r qu'un transfert DMA
        est termin&eacute;.</para>
    </sect2>

    <sect2>
      <title>Les registres de page DMA et la limite d'adressage de 16Mo</title>
	  
      <para>Vous avez peut-&ecirc;tre d&eacute;j&agrave; remarqu&eacute; qu'au
        lieu de prendre pour adresse la valeur <literal>0x00123456</literal>, le
        DMA utilise la valeur <literal>0x3456</literal>. Cela m&eacute;rite
        quelques explications.</para>
	  
      <para>Quand l'IBM PC d'origine a &eacute;t&eacute; con&ccedil;u, IBM a
        choisi d'utiliser &agrave; la fois des circuits contr&ocirc;leur DMA et
        contr&ocirc;leur d'interruptions pr&eacute;vus pour le 8085, un
        processeur 8-bits avec un espace adressable sur 16 bits (64Ko). Comme
        l'IBM PC supportait plus de 64Ko de m&eacute;moire, il fallait trouver
        le moyen de permettre au DMA de lire ou d'&eacute;crire &agrave; des
        emplacements m&eacute;moire au-del&agrave; de la limite de 64Ko. Pour
        r&eacute;soudre le probl&egrave;me, IBM a ajout&eacute; un registre
        externe pour chaque canal DMA qui re&ccedil;oit les bits de poids fort
        de l'adresse o&ugrave; lire ou &eacute;crire. Chaque fois
        qu'un canal DMA est actif, le contenu de ce registre est &eacute;crit
        sur le bus d'adresse et y reste jusqu'&agrave; ce que l'op&eacute;ration
        DMA pour ce canal soit termin&eacute;e. IBM a appel&eacute; ces 
        registres &ldquo;registres de page&rdquo;.</para>
	  
      <para>Dans notre exemple pr&eacute;c&eacute;dent donc, le DMA mettrait la
        partie <literal>0x3456</literal> de l'adresse sur le bus et le registre 
        de page du canal DMA 2 mettrait la partie <literal>0x0012xxxx</literal>
        sur le bus. Ensemble, ces deux valeurs constituent l'adresse 
        m&eacute;moire compl&egrave;te de l'acc&egrave;s.</para>
	  
      <para>Comme le registre de page est ind&eacute;pendant du circuit DMA, la
        zone m&eacute;moire o&ugrave; lire ou &eacute;crire ne doit pas franchir
        la limite d'une plage de 64Ko. Par exemple, si le DMA acc&egrave;de 
        &agrave; l'adresse <literal>0xffff</literal>, apr&egrave;s transfert, le
        DMA incr&eacute;mente le registre d'adresse et acc&egrave;de &agrave; 
        l'octet d'adresse suivante <literal>0x0000</literal> et non 
        <literal>0x10000</literal>. Ce n'est probablement pas le r&eacute;sultat
        attendu.</para>
	  
      <note>
	<para>Les limites &ldquo;physiques&rdquo; de 64Ko ne doivent pas
          &ecirc;tre confondues avec les &ldquo;segments&rdquo; de 64Ko du mode
          8086, qui sont d&eacute;finis par l'addition d'un registre de segment
          et d'un registre de d&eacute;placement. Les registres de page ne
          peuvent pas recouvrir d'adresses communes car ils font l'objet d'un 
          <literal>OU</literal> logique avec l'adresse basse.</para>
      </note>
      
      <para>Pour compliquer encore les choses, les registres externes d'adresse
        DMA du PC/AT n'ont que 8 bits, ce qui nous donne 8+16=24 bits, ce qui 
        signifie que le DMA ne peut adresser la m&eacute;moire qu'entre 0 et 
        16Mo. Sur les ordinateurs plus r&eacute;cents, qui permettent d'utiliser
        plus de 16Mo de m&eacute;moire, le DMA compatible PC standard ne peut
        adresser au-del&agrave; de 16Mo.</para>
	  
      <para>Pour contourner cette restriction, les syst&egrave;mes 
        d'exploitation r&eacute;servent une zone de m&eacute;moire en 
        dessous de 16Mo qui n'inclue pas une limite de plage de 64 Ko. Le DMA 
        est alors programm&eacute; pour effectuer les transferts dans cette zone
        tampon. Une fois que ce transfert est termin&eacute;, le syst&egrave;me
        d'exploitation copie alors les donn&eacute;es &agrave; l'adresse 
        o&ugrave; elles doivent effectivement &ecirc;tre stock&eacute;es.</para>
	  
      <para>Pour transf&eacute;rer des donn&eacute;es d'une adresse 
        au-del&agrave; de 16Mo vers un p&eacute;riph&eacute;rique utilisant le 
        DMA, les donn&eacute;es doivent d'abord &ecirc;tre copi&eacute;es dans 
        un tampon en dessous de 16Mo, et de l&agrave;, le DMA peut les 
        transf&eacute;rer au p&eacute;riph&eacute;rique. Sous FreeBSD, ces 
        tampons r&eacute;serv&eacute;s sont appel&eacute;s &ldquo;tampons 
        &agrave; rebonds&rdquo;&nbsp;-&nbsp;<foreignphrase>Bounce 
        Buffers</foreignphrase>. Dans le monde MS-DOS, ils sont parfois
        appel&eacute;s &ldquo;tampons 
        intelligents&rdquo;&nbsp;-&nbsp;<foreignphrase>Smart 
        Buffers</foreignphrase>.</para>
	  
      <note>
	<para>Une nouvelle impl&eacute;mentation du 8237, appel&eacute;e 82374,
          poss&egrave;de des registres de page de 16 bits, ce qui permet 
          l'adressage 32 bits, sans avoir &agrave; utiliser de tampon &agrave
          rebonds.</para>
      </note>
    </sect2>
	
    <sect2>
      <title>Modes op&eacute;ratoires et configurations du DMA</title>
      
      <para>Le DMA 8237 peut op&eacute;rer selon diff&eacute;rents modes. Les
        principaux sont&nbsp;:</para>
	  
      <variablelist>
	<varlistentry>
	  <term>Simple</term>

	  <listitem>
	    <para>Un seul octet (ou mot) est transf&eacute;r&eacute;. Le DMA
              doit lib&eacute;rer et r&eacute;obtenir le bus pour chaque nouvel
              octet. Ce mode est habituellement utilis&eacute; par les 
              p&eacute;riph&eacute;riques qui ne peuvent transf&eacute;rer
              imm&eacute;diatement un bloc entier de donn&eacute;es. Le
              p&eacute;riph&eacute;rique fait appel au DMA chaque fois qu'il est
              pr&ecirc;t &agrave; un nouveau transfert.</para>
	    
	    <para>Le contr&ocirc;leur de disquette standard des compatibles PC 
             (NEC 765) n'a qu'un tampon d'un octet. Il utilise donc ce
             mode.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>Bloc/A la Demande</term>
		
	  <listitem>
	    <para>Une fois que le DMA a eu le contr&ocirc;le du bus 
              syst&egrave;me, il transf&egrave;re un bloc entier de 
              donn&eacute;es, de 64Ko au plus. Si le p&eacute;riph&eacute;rique
              a besoin de plus de temps, il peut activer le signal READY pour
              suspendre bri&egrave;vement le transfert. READY doit &ecirc;tre
              utilis&eacute; parcimonieusement et, pour un 
              p&eacute;riph&eacute;rique lent, il faut plut&ocirc;t utiliser le
              mode simple.</para>
		  
	    <para>Le diff&eacute;rence entre les modes Bloc et A la Demande est
              que d&egrave;s qu'un transfert Bloc est entam&eacute;, il se
              poursuit jusqu'&agrave; ce que le compteur d'octets 
              transf&eacute;r&eacute;s atteigne la valeur z&eacute;ro. Le signal
              DRQ ne doit &ecirc;tre actif que jusqu'&agrave; ce que le signal
              -DACK soit activ&eacute;. En mode A la Demande, les octets sont
              transf&eacute;r&eacute;s jusqu'&agrave; ce que le signal DRQ soit
              d&eacute;sactiv&eacute;, le DMA interrompt alors le transfert et
              rend le contr&ocirc;le du bus au CPU. Quand le signal DRQ est 
              ensuite r&eacute;activ&eacute;, le transfert reprend l&agrave; 
              o&ugrave; il a &eacute;t&eacute; interrompu.</para>
		  
	    <para>Les anciens contr&ocirc;leurs de disques durs utilisaient le
              mode A la Demande, jusqu'&agrave; ce que la puissance des
              processeurs augmente au point qu'il soit plus efficace de 
              transf&eacute;rer les donn&eacute;es en utilisant le CPU, en 
              particulier lorsque les adresses m&eacute;moire utilis&eacute;es
              pour le transfert se situent au-del&agrave; de la limite des
              16Mo.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>Cascade</term>
		
	  <listitem>
	    <para>Ce m&eacute;canisme permet &agrave; un canal DMA de 
              prendre le contr&ocirc;le du bus, mais c'est ensuite le 
              p&eacute;riph&eacute;rique associ&eacute; et non le DMA qui est 
              charg&eacute; de param&eacute;trer le bus d'adresse. Ce mode est
              aussi utilis&eacute; pour mettre en oeuvre une technique 
              appel&eacute;e &ldquo;Ma&icirc;trise du 
              bus&rdquo;&nbsp;-&nbsp;<foreignphrase>Bus 
              Mastering</foreignphrase>.</para>
		  
	    <para>Quand un canal DMA en mode Cascade re&ccedil;oit le
              contr&ocirc;le du bus, le DMA ne met pas les adresses et les
              signaux de contr&ocirc;le des entr&eacute;es/sorties sur le bus
              comme le DMA le fait  normalement quand il est actif. Au lieu de
              cela, il positionne uniquement le signal -DACK pour le canal
              DMA actif.</para>
		  
	    <para>C'est au p&eacute;riph&eacute;rique reli&eacute; 
              &agrave; ce canal DMA de fournir l'adresse et les signaux de 
              contr&ocirc;le du bus. Le p&eacute;riph&eacute;rique 
              contr&ocirc;le alors int&eacute;gralement le bus syst&egrave;me
              et peut effectuer des op&eacute;rations de lecture et/ou
              d'&eacute;criture &agrave; n'importe quelle adresse en dessous de
              16 Mo. Quand le p&eacute;riph&eacute;rique en a termin&eacute;,
              il d&eacute;sactive le signal DRQ et le contr&ocirc;leur DMA peut
              alors rendre le main au processeur ou &agrave; un autre canal
	      DMA.</para>
		  
	    <para>Le mode Cascade peut servir &agrave; mettre plusieurs 
              contr&ocirc;leurs DMA en s&eacute;rie, et c'est exactement 
              &agrave; cela que sert le canal DMA 4 dans l'architecture PC.
              Quand un p&eacute;riph&eacute;rique demande le bus sur un des
              canaux DMA 0, 1, 2 ou 3, le contr&ocirc;leur DMA esclave active
              le signal HLDREQ, mais ce dernier est en fait reli&eacute; 
              &agrave; la ligne DRQ4 du contr&ocirc;leur DMA primaire et non au 
              processeur. Le contr&ocirc;leur DMA primaire, pensant qu'il a
              un transfert &agrave; effectuer sur le canal 4, demande le bus au
              processeur avec le signal HLDREQ. Une fois que le CPU lui a
              octroy&eacute; le bus, le signal -DACK4 est positionn&eacute; et
              ce dernier est en fait reli&eacute; au signal HLDA du 
              contr&ocirc;leur DMA esclave. Le contr&ocirc;leur DMA esclave
              transf&egrave;re alors des donn&eacute;es pour le canal DMA
              (0, 1, 2 ou 3) qui l'a demand&eacute; ou bien confie le bus 
              &agrave; un p&eacute;riph&eacute;rique qui veut en avoir la 
              ma&icirc;trise, un contr&ocirc;leur SCSI, par exemple.</para>
		  
	    <para>A cause de ce c&acirc;blage, seuls les canaux DMA 0, 1, 2, 3,
              5, 6 et 7 peuvent &ecirc;tre utilis&eacute;s par des
              p&eacute;riph&eacute;riques sur les syst&egrave;mes PC/AT.</para>
	    
	    <note>
	      <para>Le canal DMA 0 &eacute;tait r&eacute;serv&eacute; pour les
                op&eacute;rations de rafra&icirc;chissement sur les premiers
                IBM PC, mais est habituellement disponible pour les
                p&eacute;riph&eacute;riques sur les syst&egrave;mes 
                r&eacute;cents.</para>
	    </note>
	    
	    <para>Quand un p&eacute;riph&eacute;rique prend le contr&ocirc;le du
              bus, il faut qu'il transf&egrave;re des donn&eacute;es de ou vers
              la m&eacute;moire de fa&ccedil;on constante, tant qu'il garde le
              contr&ocirc;le du bus syst&egrave;me. Si le 
              p&eacute;riph&eacute;rique ne peut pas le faire, il faut qu'il
              lib&egrave;re fr&eacute;quemment le bus, pour que le 
              syst&egrave;me puisse rafra&icirc;chir la m&eacute;moire.</para>
		  
	    <para>La RAM dynamique utilis&eacute;e par tous les PCs doit
              &ecirc;tre rafra&icirc;chie fr&eacute;quemment pour que les bits
              stock&eacute;s par ses composants restent
	      &ldquo;charg&eacute;s&rdquo;. La RAM dynamique est essentiellement              constitu&eacute;e de millions de condensateurs repr&eacute;sentant
              chacun un bit de donn&eacute;e. Ces condensateurs sont 
              charg&eacute;s pour repr&eacute;senter un <literal>1</literal> ou
              d&eacute;charg&eacute;s pour repr&eacute;senter un
	      <literal>0</literal>. Comme tous les condensateurs fuient, il faut
              les recharger &agrave; intervalles r&eacute;guliers pour conserver
              les valeurs <literal>1</literal>.  Les circuits de m&eacute;moire
              s'occupent en fait de la t&acirc;che de recharger les cases 
              m&eacute;moire appropri&eacute;es, mais le reste du syst&egrave;me
              doit leur dire quand le faire, pour que cela n'interf&egrave;re 
              pas avec les acc&egrave;s normaux du syst&egrave;me &agrave; la 
              m&eacute;moire. Si l'ordinateur ne peut pas rafra&icirc;chir la 
              m&eacute;moire, le contenu de cette derni&egrave;re sera corrompu
              en quelques millisecondes.</para>
		  
	    <para>Comme les cycles de lecture et d'&eacute;criture en 
              m&eacute;moire &ldquo;comptent&rdquo; pour des cycles de
              rafra&icirc;chissement (un cycle de rafra&icirc;chissement de la
              RAM dynamique est en fait un cycle de lecture incomplet), tant que
              le p&eacute;riph&eacute;rique continue de lire ou d'&eacute;crire
              des donn&eacute;es en s&eacute;quence en m&eacute;moire, cette
              op&eacute;ration rafra&icirc;chit la totalit&eacute; de la
              m&eacute;moire.</para>
		  
	    <para>La prise de contr&ocirc;le du bus est utilis&eacute;e par les
              interfaces SCSI et d'autres contr&ocirc;leurs de 
              p&eacute;riph&eacute;rique de haute performance.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>Autoinitialisation</term>
	  
	  <listitem>
	    <para>Dans ce mode, le DMA op&egrave;re des transferts d'octet, de 
              bloc, ou &agrave; la demande mais, lorsque le compteur de
              transferts du DMA arrive &agrave; z&eacute;ro, le compteur et
              l'adresse sont r&eacute;initialis&eacute;s avec les valeurs
              initialement programm&eacute;es pour le canal DMA. Cela signifie
              que tant que le p&eacute;riph&eacute;rique demande des transferts,
              ils lui sont accord&eacute;s. C'est au processeur de placer les
              donn&eacute;es &agrave; l'avance dans le tampon fixe d'o&ugrave;
              le DMA les d&eacute;placera lors d'op&eacute;rations de sortie, et
              de lire les donn&eacute;es du tampon avant que le DMA n'y 
              r&eacute;&eacute;crive lors d'op&eacute;rations 
              d'entr&eacute;e.</para>
		  
	    <para>Cette technique est couramment  utilis&eacute;e par les
              p&eacute;riph&eacute;riques audio qui n'ont qu'un petit ou pas 
              de tampon mat&eacute;riel pour les &eacute;chantillons.
              Il y a occupation suppl&eacute;mentaire du processeur pour
              g&eacute;rer ce tampon &ldquo;circulaire&rdquo; mais, dans
              certains cas, c'est la seule fa&ccedil;on d'&eacute;liminer le
              temps de latence qui intervient lorsque le compteur du DMA
              arrive &agrave; z&eacute;ro et que le DMA arr&ecirc;te le 
              transfert jusqu'&agrave; ce qu'il soit reprogramm&eacute;.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Programmation du DMA</title>
      
      <para>Le canal DMA qui va &ecirc;tre programm&eacute; doit toujours
        &ecirc;tre &ldquo;masqu&eacute;&rdquo; avant de le param&eacute;trer.
        Cela parce que le mat&eacute;riel pourrait inopin&eacute;ment activer
        le signal DRQ pour ce canal avant que tous les param&egrave;tres n'aient
        &eacute;t&eacute; charg&eacute;s ou mis &agrave; jour.</para>
	  
      <para>Une fois masqu&eacute;, le processeur doit pr&eacute;ciser le sens 
        du transfert (de la m&eacute;moire vers le p&eacute;riph&eacute;rique 
        ou du p&eacute;riph&eacute;rique vers la m&eacute;moire), le mode
        d'op&eacute;ration du DMA (Simple, Bloc, A la Demande, Cascade, etc.)
        qui sera utilis&eacute; pour le transfert et, pour finir, l'adresse et 
        le volume de donn&eacute;es &agrave; transf&eacute;rer. La 
        quantit&eacute; de donn&eacute;es &agrave; indiquer est 
        inf&eacute;rieure d'un octet &agrave; celle que vous voulez que le DMA 
        transf&egrave;re. Le LSB (octet bas) et le MSB (octet haut) de l'adresse
        et de la quantit&eacute; sont &eacute;crites sur le m&ecirc;me port 
        d'entr&eacute;e/sortie 8 bits, il y a donc un autre
        port sur lequel il faut &eacute;crire d'abord pour s'assurer que le
        DMA comprenne le premier octet comme le LSB et le second comme le MSB
        de la quantit&eacute; et de l'adresse.</para>
	  
      <para>Enfin, il faut mettre &agrave; jour le registre de page, qui est 
        externe au DMA et est accessible via un autre jeu de ports
        d'entr&eacute;e/sortie.</para>
	  
      <para>Une fois que toutes ces valeurs sont d&eacute;finies, le canal DMA 
        peut &ecirc;tre d&eacute;masqu&eacute;. Le canal DMA en question est 
        maintenant consid&eacute;r&eacute; &ldquo;arm&eacute;&rdquo;, et 
        r&eacute;pondra quand la ligne DRQ correspondante sera 
        activ&eacute;e.</para>
	  
      <para>Reportez-vous &agrave; un manuel documentant le mat&eacute;riel
        pour conna&icirc;tre les d&eacute;tails de la programmation du 8237.
        Vous aurez aussi besoin de la carte des ports d'entr&eacute;/sortie des
        syst&egrave;mes PC, qui donne les adresses des ports du DMA et du 
        registre de page. Vous trouverez ci-dessous une table donnant une
        description compl&egrave;te de ces ports.</para>
    </sect2>
	
    <sect2>
      <title>Ports DMA</title>
      
      <para>Les contr&ocirc;leurs DMA sont situ&eacute;s sur les m&ecirc;mes
        ports d'entr&eacute;e/sortie sur tous les syst&egrave;mes de type IBM-PC
        et PC/AT. La table ci-dessous en donne la liste compl&egrave;te. Les
        ports affect&eacute;s au deuxi&egrave;me contr&ocirc;leur DMA ne sont
        pas d&eacute;finis sur les syst&egrave;mes non-AT.</para>
	  
      <sect3>
	<title>0x00&ndash;0x0f Contr&ocirc;leur num&eacute;ro 1 (Canaux 0, 1, 2
          et 3)</title>
	    
	<para>Registres d'adresse et compteur DMA</para>

	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x00</entry>
		<entry>&eacute;criture</entry>
		<entry>Adresse initiale Canal 0</entry>
	      </row>
	      
	      <row>
		<entry>0x00</entry>
		<entry>lecture</entry>
		<entry>Adresse courante Canal 0</entry>
	      </row>
	      
	      <row>
		<entry>0x01</entry>
		<entry>&eacute;criture</entry>
		<entry>Compteur initial Canal 0</entry>
	      </row>
	      
	      <row>
		<entry>0x01</entry>
		<entry>lecture</entry>
		<entry>Compteur courant Canal 0</entry>
	      </row>
	      
	      <row>
		<entry>0x02</entry>
		<entry>&eacute;criture</entry>
		<entry>Adresse initiale Canal 1</entry>
	      </row>
	      
	      <row>
		<entry>0x02</entry>
		<entry>lecture</entry>
		<entry>Adresse courante Canal 1</entry>
	      </row>
	      
	      <row>
		<entry>0x03</entry>
		<entry>&eacute;criture</entry>
		<entry>Compteur initial Canal 1</entry>
	      </row>
	      
	      <row>
		<entry>0x03</entry>
		<entry>lecture</entry>
		<entry>Compteur courant Canal 1</entry>
	      </row>
	      
	      <row>
		<entry>0x04</entry>
		<entry>&eacute;criture</entry>
		<entry>Adresse initiale Canal 2</entry>
	      </row>
	      
	      <row>
		<entry>0x04</entry>
		<entry>lecture</entry>
		<entry>Adresse courante Canal 2</entry>
	      </row>
	      
	      <row>
		<entry>0x05</entry>
		<entry>&eacute;criture</entry>
		<entry>Compteur initial Canal 2</entry>
	      </row>
	      
	      <row>
		<entry>0x05</entry>
		<entry>lecture</entry>
		<entry>Compteur courant Canal 2</entry>
	      </row>
	      
	      <row>
		<entry>0x06</entry>
		<entry>&eacute;criture</entry>
		<entry>Adresse initiale Canal 3</entry>
	      </row>
	      
	      <row>
		<entry>0x06</entry>
		<entry>lecture</entry>
		<entry>Adresse courante Canal 3</entry>
	      </row>
	      
	      <row>
		<entry>0x07</entry>
		<entry>&eacute;criture</entry>
		<entry>Compteur initial Canal 3</entry>
	      </row>
	      
	      <row>
		<entry>0x07</entry>
		<entry>lecture</entry>
		<entry>Compteur courant Canal 3</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
	<para>Registres de commande du DMA</para>
	
	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x08</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre de commande</entry>
	      </row>
	      
	      <row>
		<entry>0x08</entry>
		<entry>lecture</entry>
		<entry>Registre d'&eacute;tat</entry>
	      </row>
	      
	      <row>
		<entry>0x09</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre de requ&ecirc;te</entry>
	      </row>
	      
	      <row>
		<entry>0x09</entry>
		<entry>lecture</entry>
		<entry>-</entry>
	      </row>
	      
	      <row>
		<entry>0x0a</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre de masque de bit</entry>
	      </row>
	      
	      <row>
		<entry>0x0a</entry>
		<entry>lecture</entry>
		<entry>-</entry>
	      </row>
	      
	      <row>
		<entry>0x0b</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre de mode</entry>
	      </row>
	      
	      <row>
		<entry>0x0b</entry>
		<entry>lecture</entry>
		<entry>-</entry>
	      </row>
	      
	      <row>
		<entry>0x0c</entry>
		<entry>&eacute;criture</entry>
		<entry>Remise &agrave; z&eacute;ro du LSB/MSB de la 
                  bascule</entry>
	      </row>
	      
	      <row>
		<entry>0x0c</entry>
		<entry>lecture</entry>
		<entry>-</entry>
	      </row>
	      
	      <row>
		<entry>0x0d</entry>
		<entry>&eacute;criture</entry>
		<entry>Remise &agrave; z&eacute;ro/r&eacute;initialisation
                  ma&icirc;tre</entry>
	      </row>
	      
	      <row>
		<entry>0x0d</entry>
		<entry>lecture</entry>
		<entry>Registre temporaire (non disponible sur les versions
                  r&eacute;centes)</entry>
	      </row>

	      <row>
		<entry>0x0e</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre de remise &agrave; z&eacute;ro du masque</entry>
	      </row>
	      
	      <row>
		<entry>0x0e</entry>
		<entry>lecture</entry>
		<entry>-</entry>
	      </row>
	      
	      <row>
		<entry>0x0f</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre d'&eacute;criture de tous les bits du 
                  masque</entry>
	      </row>
	      
	      <row>
		<entry>0x0f</entry>
		<entry>lecture</entry>
		<entry>Registre de lecture de tous les bits du masque (Intel
                  82374 uniquement)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
      
      <sect3>
	<title>0xc0&ndash;0xdf Contr&ocirc;leur num&eacute;ro 2 (Canaux 4, 5, 6
          et 7)</title>
	    
	<para>Registres d'adresse et compteur DMA</para>

	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0xc0</entry>
		<entry>&eacute;riture</entry>
		<entry>Adresse initiale Canal 4</entry>
	      </row>
	      
	      <row>
		<entry>0xc0</entry>
		<entry>lecture</entry>
		<entry>Adresse courante Canal 4</entry>
	      </row>
	      
	      <row>
		<entry>0xc2</entry>
		<entry>&eacute;criture</entry>
		<entry>Compteur initial Canal 4</entry>
	      </row>
	      
	      <row>
		<entry>0xc2</entry>
		<entry>lecture</entry>
		<entry>Compteur courant Canal 4</entry>
	      </row>
	      
	      <row>
		<entry>0xc4</entry>
		<entry>&eacute;criture</entry>
		<entry>Adresse initiale Canal 5</entry>
	      </row>
	      
	      <row>
		<entry>0xc4</entry>
		<entry>lecture</entry>
		<entry>Adresse courante Canal 5</entry>
	      </row>
	      
	      <row>
		<entry>0xc6</entry>
		<entry>&eacute;criture</entry>
		<entry>Compteur initial Canal 5</entry>
	      </row>
	      
	      <row>
		<entry>0xc6</entry>
		<entry>lecture</entry>
		<entry>Compteur courant Canal 5</entry>
	      </row>
	      
	      <row>
		<entry>0xc8</entry>
		<entry>&eacute;criture</entry>
		<entry>Adresse initiale Canal 6</entry>
	      </row>
	      
	      <row>
		<entry>0xc8</entry>
		<entry>lecture</entry>
		<entry>Adresse courante Canal 6</entry>
	      </row>
	      
	      <row>
		<entry>0xca</entry>
		<entry>&eacute;criture</entry>
		<entry>Compteur initial Canal 6</entry>
	      </row>
	      
	      <row>
		<entry>0xca</entry>
		<entry>lecture</entry>
		<entry>Compteur courant Canal 6</entry>
	      </row>
	      
	      <row>
		<entry>0xcc</entry>
		<entry>&eacute;criture</entry>
		<entry>Adresse initiale Canal 7</entry>
	      </row>
	      
	      <row>
		<entry>0xcc</entry>
		<entry>lecture</entry>
		<entry>Adresse courante Canal 7</entry>
	      </row>
	      
	      <row>
		<entry>0xce</entry>
		<entry>&eacute;criture</entry>
		<entry>Compteur initial Canal 7</entry>
	      </row>
	      
	      <row>
		<entry>0xce</entry>
		<entry>lecture</entry>
		<entry>Compteur courant Canal 7</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
	
	<para>Registres de commande du DMA</para>
	
	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0xd0</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre de commande</entry>
	      </row>
	      
	      <row>
		<entry>0xd0</entry>
		<entry>lecture</entry>
		<entry>Registre d'&eacute;tat</entry>
	      </row>
	      
	      <row>
		<entry>0xd2</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre de requ&ecirc;te</entry>
	      </row>
	      
	      <row>
		<entry>0xd2</entry>
		<entry>lecture</entry>
		<entry>-</entry>
	      </row>
	      
	      <row>
		<entry>0xd4</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre de masque de bit</entry>
	      </row>
	      
	      <row>
		<entry>0xd4</entry>
		<entry>lecture</entry>
		<entry>-</entry>
	      </row>
	      
	      <row>
		<entry>0xd6</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre de mode</entry>
	      </row>
	      
	      <row>
		<entry>0xd6</entry>
		<entry>lecture</entry>
		<entry>-</entry>
	      </row>
	      
	      <row>
		<entry>0xd8</entry>
		<entry>&eacute;criture</entry>
		<entry>Remise &agrave; z&eacute;ro du LSB/MSB de la
                  bascule</entry>
	      </row>
	      
	      <row>
		<entry>0xd8</entry>
		<entry>lecture</entry>
		<entry>-</entry>
	      </row>
	      
	      <row>
		<entry>0xda</entry>
		<entry>&eacute;criture</entry>
		<entry>Remise &agrave; z&eacute;ro/r&eacute;initialisation
                  ma&icirc;tre</entry>
	      </row>
	      
	      <row>
		<entry>0xda</entry>
		<entry>lecture</entry>
		<entry>Registre temporaire (non disponible sur l'Intel
                  82374)</entry>
	      </row>

	      <row>
		<entry>0xdc</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre de remise &agrave; z&eacute;ro du masque</entry>
	      </row>
	      
	      <row>
		<entry>0xdc</entry>
		<entry>lecture</entry>
		<entry>-</entry>
	      </row>
	      
	      <row>
		<entry>0xde</entry>
		<entry>&eacute;criture</entry>
		<entry>Registre d'&eacute;criture de tous les bits du 
                  masque</entry>
	      </row>
	      
	      <row>
		<entry>0xdf</entry>
		<entry>lecture</entry>
		<entry>Registre de lecture de tous les bits du masque (Intel
                  82374 uniquement)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>0x80&ndash;0x9f Registres de page du DMA</title>
	
	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x87</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 0 octet bas (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x83</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 1 octet bas (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x81</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 2 octet bas (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x82</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 3 octet bas (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x8b</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 5 octet bas (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x89</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 6 octet bas (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x8a</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 7 octet bas (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x8f</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Octet bas rafra&icirc;chissement de page</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
      
      <sect3>
	<title>0x400&ndash;0x4ff Registres du DMA Etendu 82374</title>
	
	<para>Le composant syst&egrave;me EISA&nbsp;-&nbsp;<foreignphrase>EISA 
          System Component (ESC)</foreignphrase>&nbsp;-&nbsp;Intel 82374 est
          apparu au d&eacute;but de 1996 et comporte un contr&ocirc;leur DMA
          qui fournit un sur-ensemble des fonctionnalit&eacute;s du 8237 en
          m&ecirc;me temps que d'autres composants p&eacute;riph&eacute;riques
          compatibles PC de base sur une seule puce. Ce composant est 
          destin&eacute; &agrave; la fois aux plates-formes EISA et PCI et
          offre des fonctionnalit&eacute;s DMA r&eacute;centes telles que
          dispersion/regroupement, tampons en anneau et acc&egrave;s direct
          via le DMA &agrave; la totalit&eacute; de l'espace d'adressage sur 32
          bits.</para>
	    
	<para>Lorsque ces possibilit&eacute;s sont utilis&eacute;es, il faut
          aussi fournir le code qui procure les m&ecirc;mes 
          fonctionnalit&eacute;s aux ordinateurs compatibles PC des 16
          ann&eacute;es pr&eacute;c&eacute;dentes. Pour des raisons de
          compatibilit&eacute;, il faut programmer certains registres du 82374
	  <emphasis>apr&egrave;s</emphasis> avoir programm&eacute; les registres
          traditionnels du 8237, pour chaque transfert. Ecrire dans un registre
          8237 traditionnel remet &agrave; z&eacute;ro certains registres
          &eacute;tendus du 82374 de fa&ccedil;on &agrave; assurer la
          r&eacute;tro-compatibilit&eacute; du logiciel.</para>
	
	<informaltable frame="none">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x401</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 0 octet haut (23-16) du compteur de mots</entry>
	      </row>
	      
	      <row>
		<entry>0x403</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 1 octet haut (23-16) du compteur de mots</entry>
	      </row>
	      
	      <row>
		<entry>0x405</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 2 octet haut (23-16) du compteur de mots</entry>
	      </row>
	      
	      <row>
		<entry>0x407</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 3 octet haut (23-16) du compteur de mots</entry>
	      </row>
	      
	      <row>
		<entry>0x4c6</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 5 octet haut (23-16) du compteur de mots</entry>
	      </row>
	      
	      <row>
		<entry>0x4ca</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 6 octet haut (23-16) du compteur de mots</entry>
	      </row>
	      
	      <row>
		<entry>0x4ce</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 7 octet haut (23-16) du compteur de mots</entry>
	      </row>
	      
	      <row>
		<entry>0x487</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 0 octet haut (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x483</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 1 octet haut (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x481</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 2 octet haut (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x482</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 3 octet haut (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x48b</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 5 octet haut (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x489</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 6 octet haut (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x48a</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 7 octet haut (23-16) du registre de page</entry>
	      </row>
	      
	      <row>
		<entry>0x48f</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Octet haut rafra&icirc;chissement de page</entry>
	      </row>
	      
	      <row>
		<entry>0x4e0</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 0 registre Stop (bits 7-2)</entry>
	      </row>
	      
	      <row>
		<entry>0x4e1</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 0 registre Stop (bits 15-8)</entry>
	      </row>
	      
	      <row>
		<entry>0x4e2</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 0 registre Stop (bits 23-16)</entry>
	      </row>
	      
	      <row>
		<entry>0x4e4</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 1 registre Stop (bits 7-2)</entry>
	      </row>
	      
	      <row>
		<entry>0x4e5</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 1 registre Stop (bits 15-8)</entry>
	      </row>
	      
	      <row>
		<entry>0x4e6</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 1 registre Stop (bits 23-16)</entry>
	      </row>
	      
	      <row>
		<entry>0x4e8</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 2 registre Stop (bits 7-2)</entry>
	      </row>
	      
	      <row>
		<entry>0x4e9</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 2 registre Stop (bits 15-8)</entry>
	      </row>
	      
	      <row>
		<entry>0x4ea</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 2 registre Stop (bits 23-16)</entry>
	      </row>
	      
	      <row>
		<entry>0x4ec</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 3 registre Stop (bits 7-2)</entry>
	      </row>
	      
	      <row>
		<entry>0x4ed</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 3 registre Stop (bits 15-8)</entry>
	      </row>
	      
	      <row>
		<entry>0x4ee</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 3 registre Stop (bits 23-16)</entry>
	      </row>
	      
	      <row>
		<entry>0x4f4</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 5 registre Stop (bits 7-2)</entry>
	      </row>
	      
	      <row>
		<entry>0x4f5</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 5 registre Stop (bits 15-8)</entry>
	      </row>
	      
	      <row>
		<entry>0x4f6</entry>
		<entry>lecture/&eacute;criture</entry>
	        <entry>Canal 5 registre Stop (bits 23-16)</entry>
	      </row>
	      
	      <row>
		<entry>0x4f8</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 6 registre Stop (bits 7-2)</entry>
	      </row>
	      
	      <row>
		<entry>0x4f9</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 6 registre Stop (bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4fa</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 6 registre Stop (bits 23-16)</entry>
	      </row>
	      
	      <row>
		<entry>0x4fc</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 7 registre Stop (bits 7-2)</entry>
	      </row>
	      
	      <row>
		<entry>0x4fd</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 7 registre Stop (bits 15-8)</entry>
	      </row>
	      
	      <row>
		<entry>0x4fe</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 7 registre Stop (bits 23-16)</entry>
	      </row>
	      
	      <row>
		<entry>0x40a</entry>
		<entry>&eacute;criture</entry>
		<entry>Canaux 0-3 registre de mode cha&icirc;nage</entry>
	      </row>
	      
	      <row>
		<entry>0x40a</entry>
		<entry>lecture</entry>
		<entry>Registre d'&eacute;tat d'interruption du canal</entry>
	      </row>
	      
	      <row>
		<entry>0x4d4</entry>
		<entry>&eacute;criture</entry>
		<entry>Canaux 4-7 registre de mode cha&icirc;nage</entry>
	      </row>
	      
	      <row>
		<entry>0x4d4</entry>
		<entry>lecture</entry>
		<entry>Etat du mode cha&icirc;nage</entry>
	      </row>
	      
	      <row>
		<entry>0x40c</entry>
		<entry>lecture</entry>
		<entry>Registre de contr&ocirc;le d'expiration du tampon de 
                  cha&icirc;nage</entry>
	      </row>
	      
	      <row>
		<entry>0x410</entry>
		<entry>&eacute;criture</entry>
		<entry>Canal 0 registre de commande 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x411</entry>
		<entry>&eacute;criture</entry>
		<entry>Canal 1 registre de commande 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x412</entry>
		<entry>&eacute;criture</entry>
		<entry>Canal 2 registre de commande 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x413</entry>
		<entry>&eacute;criture</entry>
		<entry>Canal 3 registre de commande 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x415</entry>
		<entry>&eacute;criture</entry>
		<entry>Canal 5 registre de commande 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x416</entry>
		<entry>&eacute;criture</entry>
		<entry>Canal 6 registre de commande 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x417</entry>
		<entry>&eacute;criture</entry>
		<entry>Canal 7 registre de commande 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x418</entry>
		<entry>lecture</entry>
		<entry>Canal 0 registre d'&eacute;tat 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x419</entry>
		<entry>lecture</entry>
		<entry>Canal 1 registre d'&eacute;tat
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x41a</entry>
		<entry>lecture</entry>
		<entry>Canal 2 registre d'&eacute;tat 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x41b</entry>
		<entry>lecture</entry>
		<entry>Canal 3 registre d'&eacute;tat 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x41d</entry>
		<entry>lecture</entry>
		<entry>Canal 5 registre d'&eacute;tat 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x41e</entry>
		<entry>lecture</entry>
		<entry>Canal 6 registre d'&eacute;tat 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x41f</entry>
		<entry>lecture</entry>
		<entry>Canal 7 registre d'&eacute;tat 
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x420-0x423</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 0 registre de pointeur sur le table de descripteurs
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x424-0x427</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 1 registre de pointeur sur le table de descripteurs
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x428-0x42b</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 2 registre de pointeur sur le table de descripteurs
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x42c-0x42f</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 3 registre de pointeur sur le table de descripteurs
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x434-0x437</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 5 registre de pointeur sur le table de descripteurs
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x438-0x43b</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 6 registre de pointeur sur le table de descripteurs
                  dispersion/regroupement</entry>
	      </row>
	      
	      <row>
		<entry>0x43c-0x43f</entry>
		<entry>lecture/&eacute;criture</entry>
		<entry>Canal 7 registre de pointeur sur le table de descripteurs
                  dispersion/regroupement</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
    </sect2>
  </sect1>
  
  <sect1 id="internals-vm">
    <title>La gestion de m&eacute;moire virtuelle de FreeBSD</title>
    
    <para><emphasis>Contribution de &a.dillon;. 6 F&eacute;vrier 
      1999</emphasis></para>
    
    <sect2>
      <title>Gestion de la m&eacute;moire
	physique&mdash;<literal>vm_page_t</literal></title>
      
      <para>La m&eacute;moire physique est g&eacute;r&eacute;e page par page
        via la structure <literal>vm_page_t</literal>. Les pages de 
        m&eacute;moire physique sont caract&eacute;ris&eacute;es par 
        l'emplacement de leurs structures <literal>vm_page_t</literal> 
        respectives dans l'une des queues de pagination.</para>

      <para>Une page peut &ecirc;tre verrouill&eacute;e, active, inactive, dans
        le cache ou libre. Sauf lorsqu'elle est verrouill&eacute;e, la page est
        typiquement plac&eacute;e dans une queue repr&eacute;sent&eacute;e par 
        une liste &agrave; double cha&icirc;nage d&eacute;crivant l'&eacute;tat
        dans lequel elle est. Les pages verrouill&eacute;es n'appartiennent 
        &agrave; aucune queue.</para>
	
      <para>FreeBSD impl&eacute;ment syst&egrave;me de queues de pagination plus
        sophistiqu&eacute; pour les pages libres ou dans le cache, de
        fa&ccedil;on &agrave; mettre en oeuvre un algorithme de coloration des 
        pages.  Chacun de ces &eacute;tats (libre, cach&eacute;) met en oeuvre 
        des files d'attente multiples selon la taille des caches L1 et L2 du 
        processeur. Quand il faut allouer une nouvelle page, FreeBSD essaie d'en
        obtenir une qui soit raisonnablement align&eacute;e du point de vue des 
        caches L1 et L2 selon le type d'objet en m&eacute;moire virtuelle pour 
        lequel la page est allou&eacute;e.</para>
	
      <para>De plus, une page peut &ecirc;tre retenue par un compteur
        de r&eacute;f&eacute;rence, ou bloqu&eacute;e avec un compteur
        d'utilisation. Le syst&egrave;me de m&eacute;moire virtuelle 
        impl&eacute;mente aussi un &eacute;tat &ldquo;verrouillage 
        ultime&rdquo; lorsque la page utilise le bit PG_BUSY des drapeaux de
        page.</para>
	
      <para>En termes g&eacute;n&eacute;raux, chacune des queues de pagination
        op&egrave;re en mode LRU (moins r&eacute;cemment utilis&eacute;). Une 
        page est habituellement initialement plac&eacute;e dans l'&eacute;tat 
        actif ou verrouill&eacute;. Lorsqu'elle est verrouill&eacute;e, la page
        est normalement associ&eacute;e &agrave; une table de pages quelque 
        part. Le syst&egrave;me de m&eacute;moire virtuelle 
        &ldquo;viellit&rdquo; les pages en parcourant les pages d'une queue de 
        pagination plus active de fa&ccedil;on &agrave; les d&eacute;placer vers
        une queue moins active. Les pages qui sont d&eacute;plac&eacute;es vers
        le cache sont toujours associ&eacute;es &agrave; un objet en 
        m&eacute;moire virtuelle mais sont candidates &agrave; une 
        r&eacute;utilisation imm&eacute;diate. Les pages dans la queue libre 
        sont vraiment disponibles. FreeBSD essaie de minimiser le nombre de 
        pages dans la queue libre, mais il faut conserver un certain nombre de 
        pages r&eacute;ellement disponibles pour pouvoir g&eacute;rer 
        l'allocation de pages lors d'interruptions.</para>
	
      <para>Si un processus essaie d'acc&eacute;der &agrave; une page qui 
        n'existe pas dans sa table de pages mais existe dans une des queues de
        pagination (la queue inactive ou celle du cache par exemple), il se
        produit un d&eacute;faut relativement peu p&eacute;nalisant de 
        r&eacute;activation de page, qui fait que la page est 
        r&eacute;activ&eacute;e. Si la page n'existe nulle part en 
        m&eacute;moire, le processus doit attendre que la page soit
        r&eacute;cup&eacute;r&eacute;e sur disque.</para>
	
      <para>FreeBSD optimise dynamiquement ses queues de pagination et essaie de
        maintenir un ratio raisonnable entre les diff&eacute;rentes queues de
        m&ecirc;me qu'entre les pages &agrave; jour et celles qui ne le sont
        pas. Ce r&eacute;&eacute;quilibrage est mis en oeuvre par le 
        d&eacute;mon de pagination et comprend le nettoyage des pages 
        d&eacute;grad&eacute;es (leur synchronisation avec la version en
        arri&egrave;re-plan), la surveillance des pages 
        r&eacute;f&eacute;renc&eacute;es par des t&acirc;ches actives (leur 
        repositionnement dans les queues LRU ou leur d&eacute;placement d'une 
        queue &agrave; une autre), la migration de pages entre queues lorsque 
        les queues sont d&eacute;s&eacute;quilibr&eacute;es, et ainsi de suite.
        Le syst&egrave;me de m&eacute;moire virtuelle de FreeBSD accepte un
        nombre raisonnable de d&eacute;fauts de r&eacute;activation de page afin
        de savoir &agrave; quel point une page est active ou inactive. Cela 
        permet de prendre de meilleures d&eacute;cisions pour savoir quand 
        mettre &agrave; jour ou d&eacute;charger une page sur disque.</para>
    </sect2>
    
    <sect2>
      <title>Le tampon cache
	unifi&eacute;&mdash;<literal>vm_object_t</literal></title>
	  
      <para>FreeBSD impl&eacute;mente la notion d'&ldquo;objet en m&eacute;moire
        virtuelle&rdquo; g&eacute;n&eacute;rique. Les objets en m&eacute;moire
        virtuelle peuvent &ecirc;tre associ&eacute;s &agrave; diff&eacute;rents
        types de mise en arri&egrave;re-plan&mdash;non sauvegard&eacute;, 
        sauvegard&eacute; sur disque (<foreignphrase>swap</foreignphrase>), 
        sauvegard&eacute; sur un p&eacute;riph&eacute;rique physique, ou 
        sauvegard&eacute; dans un fichier. Comme le syst&egrave;me de fichiers
        utilise les m&ecirc;mes objets en m&eacute;moire virtuelle pour
        g&eacute;rer les informations de base relatives aux fichiers, le
        r&eacute;sultat est un tampon cache unifi&eacute;.</para>
	
      <para>Les objets en m&eacute;moire virtuelle peuvent &ecirc;tre des objets
        <emphasis>ombre&nbsp;-&nbsp;<foreignphrase>shadowed</foreignphrase></emphasis>,
        c'est-&agrave;-dire qu'ils peuvent &ecirc;tre empil&eacute;s les uns au
        dessus des autres. Par exemple, il peut y avoir un objet ombre
        sauvegard&eacute; dans l'espace de <foreignphrase>swap</foreignphrase> 
        empil&eacute; sur un objet sauvegard&eacute; dans un fichier pour
        impl&eacute;menter une correspondance 
        <citerefentry><refentrytitle>mmap</refentrytitle> 
        <manvolnum>2</manvolnum></citerefentry> de type 
        <literal>MAP_PRIVATE</literal>. Ce type d'empilement est aussi
        utilis&eacute; pour impl&eacute;menter diff&eacute;rents types de
        partage, dont la copie sur &eacute;criture pour les espaces d'adressage
        de processus fils (cr&eacute;&eacute;s par
        <citerefentry><refentrytitle>fork</refentrytitle> <manvolnum>2</manvolnum></citerefentry>.</para>
	
      <para>Il faut noter qu'un <literal>vm_page_t</literal> ne peut &ecirc;tre
        associ&eacute; qu'&agrave; un seul objet en m&eacute;moire virtuelle
        &agrave; la fois. Les objets ombre en m&eacute;moire
        virtuelle impl&eacute;mentent le partage apparent de la m&ecirc;me page
        pour des instances multiples.</para>
    </sect2>

    <sect2>
      <title>Entr&eacute;e/sortie sur le syst&egrave;me de 
        fichiers&mdash;<literal>struct buf</literal></title>
      
      <para>Les objets en m&eacute;moire virtuelle sauvegard&eacute;s via le
        syst&egrave;me de &ldquo;vnodes&rdquo;, tels que les objets 
        sauvegard&eacute;s dans des fichiers, doivent g&eacute;n&eacute;ralement
        maintenir eux-m&ecirc;mes leurs informations d'&eacute;tat &agrave 
        jour/p&eacute;rim&eacute;, ind&eacute;pendamment de l'id&eacute;e que 
        s'en fait le syst&egrave;me de m&eacute;moire virtuelle. Par exemple, 
        quand le syst&egrave;me de m&eacute;moire virtuelle d&eacute;cide de 
        synchroniser une page physique avec sa version en arri&egrave;re-plan, 
        il doit indiquer que la page est &agrave; jour avant qu'elle ne soit 
        effectivement &eacute;crite en arri&egrave;re-plan. De plus, les 
        syst&egrave;mes de fichiers doivent &ecirc;tre capables de faire 
        correspondre des parties d'un fichier ou de m&eacute;ta-informations 
        sur un fichier avec l'interface entre la m&eacute;moire virtuelle et le
        noyau, pour pouvoir travailler sur ces informations.</para> 
	
      <para>Les entit&eacute;s qui servent &agrave; g&eacute;rer cela sont
        appel&eacute;es tampons du syst&egrave;me de fichiers,
        <literal>struct buf</literal>s, ou encore <literal>bp</literal>s. Quand
        un syst&egrave;me de fichiers doit op&eacute;rer sur une partie d'un 
        objet en m&eacute;moire virtuelle, il fait typiquement correspondre
        une partie de l'objet &agrave; un <literal>struct buf</literal> puis
        les pages du <literal>struct buf</literal> &agrave; l'interface entre
        la m&eacute;moire virtuelle et le noyau. De m&ecirc;me, les
        entr&eacute;es/sorties disque sont typiquement g&eacute;r&eacute;es en
        faisant correspondre des parties des objets et des structures tampon
        et en effectuent les entr&eacute;es/sorties sur ces structures. Les
	<literal>vm_page_t</literal>s sous-jacentes sont habituellement
        monopolis&eacute;es le temps des entr&eacute;es/sorties. Les tampons du
        syst&egrave;me de fichiers ont leur propre notion d'occupation, ce qui
        est utile pour le code des pilotes du syst&egrave;me de fichiers, qui
        travaille plut&ocirc;t sur ces tampons que directement sur les pages de
        la m&eacute;moire virtuelle.</para>
	
      <para>FreeBSD r&eacute;serve une quantit&eacute; limit&eacute;e de
        l'interface m&eacute;moire virtuelle du noyau pour les correspondances
        avec les <literal>struct buf</literal>s, mais il faut garder &agrave;
        l'esprit que cet espace n'est utilis&eacute; que pour stocker les
        correspondances et que cela ne diminue pas les possibilit&eacute;s de
        mettre des donn&eacute;es dans un cache. Le cache physique de 
        donn&eacute;es est une fonction des <literal>vm_page_t</literal>s, et
        non des tampons du syst&egrave;me de fichiers. Cependant, comme les 
        tampons du syst&egrave;me de fichiers sont utilis&eacute;s pour les
        entr&eacute;es/sorties, ils limitent de fait le nombre 
        d'entr&eacute;es/sorties possibles simultan&eacute;ment. Comme il y a
        habituellement quelques milliers de tampons de syst&egrave;me de
        fichiers disponibles, ce n'est g&eacute;n&eacute;ralement pas un
        probl&egrave;me.</para>
    </sect2>
    
    <sect2>
      <title>Tables de correspondance des 
        pages&mdash;<literal>vm_map_t</literal>, 
        <literal>vm_entry_t</literal></title>
      
      <para>FreeBSD dissocie l'organisation des tables de pages physiques du
        syst&egrave;me de m&eacute;moire virtuelle. Toutes les tables en dur de
        pages par processus peuvent &ecirc;tre reconstruites &agrave; la 
        vol&eacute;e et sont g&eacute;n&eacute;ralement 
        consid&eacute;r&eacute;es comme jetables. Des tables de pages 
        particuli&egrave;res, comme celles qui g&egrave;rent l'interface entre 
        la m&eacute;moire virtuelle et le noyau, sont allou&eacute;es de 
        fa&ccedil;on permanente. Ces pages ne sont pas consid&eacute;r&eacute;es
        comme jetables.</para>
	
      <para>FreeBSD associe des parties des <literal>vm_object</literal>s
        &agrave; des plages d'adresses via les structures 
        <literal>vm_map_t</literal> et <literal>vm_entry_t</literal>. Les tables
        de pages sont construites synth&eacute;tiquement &agrave; partir de la
        hi&eacute;rarchie
	<literal>vm_map_t</literal>/<literal>vm_entry_t</literal>/<literal>vm_object_t</literal>.  
        Rappelez-vous que j'ai dit que les pages physiques n'&eacute;taient
        directement associ&eacute;es qu'&agrave; un 
        <literal>vm_object</literal>. Ce n'est en fait pas tout-&agrave;-fait
        vrai. Les <literal>vm_page_t</literal>s sont aussi li&eacute;s aux
        tables de pages auxquelles ils sont activement associ&eacute;s.
	Un <literal>vm_page_t</literal> peut &ecirc;tre li&eacute; &agrave;
        plusieurs <emphasis>pmaps</emphasis>, nom que l'on donne aux tables de
        pages. Cependant, l'association hi&eacute;rarchique fait que toutes les
        r&eacute;f&eacute;rences du m&ecirc;me objet &agrave; la m&ecirc;me page
        se rapportent &agrave; la m&ecirc;me <literal>vm_page_t</literal> de 
        sorte que le tampon cache est globalement unifi&eacute;.</para>
    </sect2>
      
    <sect2>
      <title>Organisation m&eacute;moire de l'interface m&eacute;moire virtuelle
        du noyau&nbsp;-&nbsp;<foreignphrase>KVM</foreignphrase></title>
      
      <para>FreeBSD utilise l'interface m&eacute;moire virtuelle du noyau pour
        stocker diff&eacute;rentes structures de donn&eacute;es du noyau. 
        L'unique plus grosse entit&eacute; de cette interface est le tampon
        de cache du syst&egrave;me de fichiers. C'est-&agrave;-dire, les
        correspondances se rapportant aux <literal>struct buf</literal>s.</para>
	
      <para>Au contraire de Linux, FreeBSD ne fait <emphasis>pas</emphasis>
        correspondre toute la m&eacute;moire physique avec l'interface de 
        m&eacute;moire virtuelle. Ce qui signifie que FreeBSD peut g&eacute;rer
        des configurations ayant jusqu'&agrave; 4 Go de m&eacute;moire sur les
        plates-formes 32 bits. En fait, si l'unit&eacute; de gestion de la 
        m&eacute;moire&nbsp;-&nbsp;<foreignphrase>Memory Management Unit 
        (MMU)</foreignphrase> en &eacute;tait capable, FreeBSD pourrait 
        th&eacute;oriquement g&eacute;rer jusqu'&agrave; 8 To sur une 
        plate-forme 32 bits. N&eacute;nmoins, comme la plupart des plates-formes
        32 bits ne peuvent pas recevoir plus de 4 Go, c'est un sujet de 
        controverse.</para>

        <para>L'interface de m&eacute;moire virtuelle du noyau est
          g&eacute;r&eacute;e par diff&eacute;rents m&eacute;canismes. Le
          m&eacute;canisme principal de gestion de cette interface est 
	  l'allocateur de zone&nbsp;-&nbsp;<emphasis>zone allocator</emphasis>.
          L'allocateur de zone prend une portion de l'interface de 
          m&eacute;moire virtuelle et la d&eacute;coupe en blocs de 
          m&eacute;moire de m&ecirc;me taille pour y allouer un type
          particulier de structure. Vous pouvez utiliser la commande
	  <command>vmstat -m</command> pour avoir une vue d'ensemble de
          l'utilisation actuelle de l'interface entre le noyau et la
          m&eacute;moire virtuelle zone par zone.</para>
    </sect2>
    
    <sect2>
      <title>Optimisation du syst&egrave;me de gestion de m&eacute;moire 
        virtuelle de FreeBSD</title>
      
      <para>Il a &eacute;t&eacute; fourni un effort concert&eacute; pour que le
        noyau de FreeBSD optimise lui-m&ecirc;me dynamiquement son 
        fonctionnement. Vous n'avez normalement pas &agrave; vous casser la
        t&ecirc;te avec les options <literal>maxusers</literal> et
	<literal>NMBCLUSTERS</literal> de configuration du noyau, options de
        compilation habituellement d&eacute;finies dans
	<filename>/usr/src/sys/i386/conf/<replaceable>FICHIER_DE_CONFIGURATION</replaceable></filename>.
        On trouve une description de toutes les options de configuration du
        noyau dans <filename>/usr/src/sys/i386/conf/LINT</filename>.</para>
	
      <para>Lors de la configuration d'un gros syst&egrave;me, vous pouvez 
        vouloir augmenter <literal>maxusers</literal>. Ses valeurs sont
        g&eacute;n&eacute;ralement comprises entre 10 et 128. Remarquez que
        donner une valeur trop importante &agrave;
	<literal>maxusers</literal> peut provoquer un d&eacute;bordement de
        l'interface de m&eacute;moire virtuelle disponible, entra&icirc;nant des
        r&eacute;sultats impr&eacute;visibles. Il vaut mieux donner &agrave;
	<literal>maxusers</literal> une valeur raisonnable et ajouter d'autres
	options, telles que <literal>NMBCLUSTERS</literal>, pour augmenter des
        ressources pr&eacute;cises.</para>
	
      <para>Si votre syst&egrave;me va faire beaucoup appel au r&eacute;seau,
        vous pouvez augmenter <literal>NMBCLUSTERS</literal>. Les valeurs
        usuelles sont comprises entre 1024 et 4096.</para>
	
      <para>Le param&egrave;tre <literal>NBUF</literal> est aussi 
        traditionnellement utilis&eacute; pour dimensionner le syst&egrave;me.
        Ce param&egrave;tre d&eacute;finit la taille de l'interface de
        m&eacute;moire virtuelle du noyau disponible pour les correspondances
        avec les tampons d'entr&eacute;e/sortie du syst&egrave;me de fichiers.
        Notez bien que ce param&egrave;tre n'a rien &agrave; voir avec le
        tampon cache unifi&eacute;&nbsp;! Ce param&egrave;tre est 
        optimis&eacute; dynamiquement par le noyau 
        <literal>3.0-current</literal> et les noyaux ult&eacute;rieurs et n'a 
        normalement pas besoin d'&ecirc;tre ajust&eacute; &agrave; la main.
        Nous recommandons de ne <emphasis>pas</emphasis> essayer de fixer le
        param&egrave;tre <literal>NBUF</literal>. Laissez le syst&egrave;me
        s'en charger. Une valeur trop faible peut rendre le syst&egrave;me de
        fichiers largement inefficace et une valeur trop grande saturer les
        queues de pages en entra&icirc;nant le verrouillage d'un trop grand
        nombre de pages.</para>

      <para>Par d&eacute;faut, les noyaux FreeBSD ne sont pas optimis&eacute;s.
        Vous pouvez positionner les indicateurs d'optimisation et de
        d&eacute;boguage avec les directives <literal>makeoptions</literal> de
        configuration du noyau. Remarquez que vous ne devriez pas utiliser
        l'option <option>-g</option> &agrave; moins que vous ne puissiez vous
        accommoder des noyaux de taille importante (habituellement plus de 7 Mo)
        qui en r&eacute;sultent.</para>

      <programlisting>
makeoptions    DEBUG="-g"
makeoptions    COPTFLAGS="-O2 -pipe"
      </programlisting>
	
      <para><command>sysctl</command> fournit un moyen d'optimiser le noyau en
        temps r&eacute;el. Vous n'avez habituellement pas &agrave; vous
        pr&eacute;occuper des variables de <command>sysctl</command>, et en 
        particulier pas de celles qui concernent la m&eacute;moire
        virtuelle.</para>
	
      <para>L'optimisation de la gestion de m&eacute;moire virtuelle et du
        syst&egrave;me d'ex&eacute;cution est relativement simple. Tout
        d'abord, utilisez &ldquo;les mises &agrave; jour 
        logicielles&rdquo;&nbsp;-&nbsp;<foreignphrase>softupdates</foreignphrase>&nbsp;-&nbsp;sur
        vos syst&egrave;mes de fichiers UFS/FFS chaque fois que c'est possible.
        Le fichier
	<filename>/usr/src/contrib/sys/softupdates/README</filename> donne
	les indications (et les restrictions) sur la fa&ccedil;on de les
        configurer.</para>
	
      <para>En second lieu, pr&eacute;voyez suffisamment d'espace de pagination.
        Vous devriez avoir une partition de pagination sur chaque disque
        physique, jusqu'&agrave; quatre, m&ecirc;me sur vos disques &ldquo;de
        travail&rdquo;. Il doit y avoir au moins deux fois autant d'espace de
        pagination que de m&eacute;moire, et &eacute;ventuellement m&ecirc;me
        plus si vous n'avez pas beaucoup de m&eacute;moire. Vous devriez aussi
        dimensionner votre partition de pagination en fonction de la
        quantit&eacute; maximale de m&eacute;moire que vous comptez installer
        sur votre syst&egrave;me pour ne pas avoir &agrave; repartitionner vos
        disques par la suite. Si vous voulez pouvoir garder une trace en cas
        de plantage&nbsp;-&nbsp;<foreignphrase>crash 
        dump</foreignphrase>&nbsp;-&nbsp;votre premi&egrave;re partition de 
        pagination doit &ecirc;tre au moins de la taille de la m&eacute;moire et
	<filename>/var/crash</filename> doit disposer de suffisamment de place
        libre pour recevoir la trace.</para>
	
      <para>Il est tout &agrave; fait admissible de paginer via NFS &agrave;
        partir des syst&egrave;mes <literal>-4.x</literal> et ult&eacute;rieurs,
        mais il faut &ecirc;tre conscient que le serveur NFS supportera le plus
        fort de la charge de pagination.</para>
    </sect2>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../handbook.sgml" "part" "chapter")
     End:
-->
