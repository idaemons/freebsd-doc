<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.91
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Ecrit par </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
        <firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Bas&eacute; sur un guide r&eacute;dig&eacute;
	  par </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
        <firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Egalement bas&eacute; sur la page de manuel tuning(7)
	  &eacute;crite par </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Configuration et optimisation</title>
  &trans.a.fonvieille;

  <sect1 id="config-synopsis">
    <title>Synopsis</title>

    <indexterm><primary>configuration du
      syst&egrave;me</primary></indexterm>
    <indexterm><primary>optimisation du
      syst&egrave;me</primary></indexterm>

    <para>La configuration correcte d'un syst&egrave;me peut sensiblement
      r&eacute;duire la quantit&eacute; de travail impliqu&eacute;e
      dans la maintenance et la mise &agrave; jour.  Ce chapitre
      d&eacute;crit certains des aspects de la configuration des
      syst&egrave;mes FreeBSD.</para>

    <para>Ce chapitre d&eacute;crira &eacute;galement certains
      param&egrave;tres qui peuvent &ecirc;tre modifi&eacute;s
      pour configurer un syst&egrave;me FreeBSD pour des performances
      optimales.</para>

    <para>Apr&egrave;s la lecture de ce chapitre, vous saurez:</para>

    <itemizedlist>
      <listitem>
	<para>Pourquoi et comment dimensionner, organiser, et
	  positionner efficacement les partitions des syst&egrave;mes
	  de fichiers et de pagination sur votre disque dur.</para>
      </listitem>
      <listitem>
	<para>Les bases de la configuration du fichier
	  <filename>rc.conf</filename> et des fichiers de d&eacute;marrage
	  <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>
      <listitem>
	<para>Comment configurer et tester une carte
	  r&eacute;seau.</para>
      </listitem>
      <listitem>
	<para>Comment configurer des h&ocirc;tes virtuels sur vos
	  p&eacute;riph&eacute;riques r&eacute;seau.</para>
      </listitem>
      <listitem>
	<para>Comment utiliser les divers fichiers de configuration du
	  r&eacute;pertoire <filename>/etc</filename>.</para>
      </listitem>
      <listitem>
        <para>Comment optimiser FreeBSD en utilisant les variables
	  <command>sysctl</command>.</para>
      </listitem>
      <listitem>
	<para>Comment optimiser les performances des disques et
	  modifier les limitations du noyau.</para>
      </listitem>
    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem>
	<para>Comprendre les fondements d'Unix et de FreeBSD (<xref
	  linkend="basics">).</para>
      </listitem>
      <listitem>
	<para>Etre familier avec la mise &agrave; jour des sources
	  (<xref linkend="cutting-edge">), et
	  les bases de la configuration et la compilation du noyau
	  (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Configuration initiale</title>

    <sect2>
      <title>Organisation des partitions</title>

      <indexterm><primary>Organisation des partitions</primary></indexterm>
      <indexterm>
        <primary><filename>/etc</filename></primary>
      </indexterm>
      <indexterm>
        <primary><filename>/var</filename></primary>
      </indexterm>
      <indexterm>
        <primary><filename>/usr</filename></primary>
      </indexterm>

      <sect3>
	<title>Partitions de base</title>

	<para>Quand vous organisez votre syst&egrave;me de fichiers &agrave;
	  l'aide de &man.disklabel.8; ou &man.sysinstall.8;, il est
	  important de se rappeler que les disques durs peuvent
	  transf&eacute;rer des donn&eacute;es plus rapidement depuis
	  les pistes externes que depuis celles &agrave; l'int&eacute;rieur.
	  En sachant cela, vous devriez placer vos syst&egrave;mes de
	  fichiers les plus petits, auxquels on acc&egrave;de le plus
	  souvent, comme la racine et l'espace de pagination, proche
	  de la partie externe du disque, alors que les grandes
	  partitions, comme <filename>/usr</filename>, devraient &ecirc;tre
	  plus &agrave; l'int&eacute;rieur.  Pour faire cela, c'est une bonne
	  id&eacute;e de cr&eacute;er les partitions dans l'ordre
	  suivant: racine, pagination, <filename>/var</filename>,
	  <filename>/usr</filename>.</para>

	<para>La taille de votre partition <filename>/var</filename>
	  refl&egrave;te l'utilisation pr&eacute;vue de votre machine.
	  <filename>/var</filename> est principalement utilis&eacute;e pour
	  h&eacute;berger les bo&icirc;tes aux lettres, les fichiers de traces,
	  les queues d'impression.  Les bo&icirc;tes aux lettres et les fichiers
	  de traces, en particulier, peuvent cro&icirc;tre dans des tailles
	  inattendues en fonction du nombre d'utilisateurs de votre
	  syst&egrave;me et de combien de temps sont conserv&eacute;s les
	  fichiers de traces.  Si vous avez l'intention de faire fonctionner un
	  serveur de courrier &eacute;lectronique, une partition
	  <filename>/var</filename> de plus d'un gigaoctet pourra
	  convenir.  De plus, <filename>/var/tmp</filename> doit &ecirc;tre
	  assez grand pour contenir tout logiciel pr&eacute;-compil&eacute; que
	  vous pourrez vouloir ajouter.</para>

	<para>La partition <filename>/usr</filename> contient la
	  majeure partie des fichiers n&eacute;cessaires au syst&egrave;me
	  et un sous-r&eacute;pertoire appel&eacute;
	  <filename>/usr/local</filename>
	  qui lui h&eacute;berge la plupart des fichiers install&eacute;s
	  par le catalogue des logiciels port&eacute;s.  Si vous n'employez
	  pas vraiment les logiciels port&eacute;s et que vous n'avez pas
	  l'intention de conserver les sources du syst&egrave;me sur
	  la machine (<filename>/usr/src</filename>), vous pouvez
	  utiliser une partition <filename>/usr</filename> d'un
	  gigaoctet.  Cependant, si vous installez beaucoup de
	  logiciels port&eacute;s (tout particuli&egrave;rement des
	  gestionnaires de fen&ecirc;tres et des binaires Linux), nous
	  recommandons au moins un <filename>/usr</filename> de deux
	  gigaoctets et si vous avez &eacute;galement l'intention d'avoir les
	  sources du syst&egrave;me sur la machine nous recommandons un
	  <filename>/usr</filename> de trois gigaoctets.  Ne
	  sous-estimez pas la quantit&eacute; d'espace dont vous aurez besoin
	  sur cette partition, vous risquez d'&ecirc;tre surpris!</para>

	<para>Quand vous dimensionnez vos partitions, gardez &agrave;
	  l'esprit les besoins en espace pour permettre &agrave; votre
	  syst&egrave;me de se d&eacute;velopper.  Manquer d'espace sur une
	  partition alors qu'il y en a plein sur les autres peut &ecirc;tre
	  tr&egrave;s frustrant.</para>

	<note><para>Certains utilisateurs qui ont employ&eacute;
	    l'option <literal>Auto-defaults</literal> de l'outil de
	    partitionnement de &man.sysinstall.8; ont trouv&eacute; plus
	    tard que leurs partitions racine et
	    <filename>/var</filename> &eacute;taient trop petites.
	    Partitionnez g&eacute;n&eacute;reusement et avec
	    sagesse.</para></note>

      </sect3>

      <sect3 id="swap-design">
	<title>Partition de pagination</title>

	<indexterm><primary>dimensionnement de l'espace de
	  pagination</primary></indexterm>
	<indexterm><primary>partition de pagination</primary></indexterm>

	<para>Par principe, votre espace de pagination devrait
	  typiquement avoir une taille double de la quantit&eacute; de
	  m&eacute;moire principale.  Par exemple, si la machine
	  poss&egrave;de 128 m&eacute;gaoctets de m&eacute;moire, le
	  fichier de pagination devrait &ecirc;tre de 256 m&eacute;gaoctets.
	  Les syst&egrave;mes avec peu de m&eacute;moire pourront avoir
	  de meilleures performances avec beaucoup plus d'espace de
	  pagination.  Il n'est pas recommand&eacute; d'avoir moins
	  de 256 m&eacute;gaoctets d'espace de pagination sur un
	  syst&egrave;me et vous devriez garder &agrave; l'esprit les futures
	  extensions de m&eacute;moire quand vous dimensionnez votre
	  partition de pagination.  Les algorithmes de pagination du
	  noyau sont optimis&eacute;s pour une meilleure efficacit&eacute;
	  avec une partition de pagination d'au moins deux fois la
	  taille de la m&eacute;moire principale.  Configurer trop peu
	  d'espace de pagination peut conduire &agrave; une certaine
	  inefficacit&eacute; du code de pagination de la m&eacute;moire virtuelle
	  comme &agrave; l'apparition de probl&egrave;mes
	  ult&eacute;rieurement si vous ajoutez plus de
	  m&eacute;moire &agrave; votre machine.</para>

	<para>Et enfin, sur des syst&egrave;mes importants avec de
	  multiples disques SCSI (ou de multiples disques IDE
	  fonctionnant sur diff&eacute;rents contr&ocirc;leurs), il est
	  vivement recommand&eacute; que vous configuriez un espace de
	  pagination sur chaque disque (jusqu'&agrave; quatre disques).
	  Les partitions de pagination sur les diff&eacute;rents disques
	  devront avoir approximativement la m&ecirc;me taille.  Le
	  noyau peut g&eacute;rer des tailles arbitraires mais les
	  structures de donn&eacute;es internes sont dimensionn&eacute;es pour 4
	  fois la taille de la plus grande partition de pagination.
	  Garder la taille des partitions de pagination proche
	  permettra au noyau de r&eacute;partir de mani&egrave;re
	  optimale l'espace de pagination entre les disques.  Ne vous
	  inqui&eacute;tez pas trop si vous les surdimensionnez, l'espace de
	  pagination est un des avantages d'Unix.  M&ecirc;me si vous
	  n'utilisez normalement pas beaucoup de cet espace, il peut
	  vous permettre d'avoir plus temps pour r&eacute;cup&eacute;rer
	  face &agrave; programme incontr&ocirc;lable avant
	  d'&ecirc;tre forc&eacute; &agrave; relancer la machine.</para>
      </sect3>

      <sect3>
	<title>Pourquoi des Partitions?</title>

	<para>Pourquoi des partitions?  Pourquoi ne pas cr&eacute;er une
	  seule grande partition racine?  Ainsi je n'aurais pas &agrave;
	  me soucier d'avoir sous-dimensionn&eacute; certaines choses!</para>

	<para>Pour plusieurs raisons cela n'est pas une bonne id&eacute;e.
	  Tout d'abord, chaque partition a diff&eacute;rentes
	  caract&eacute;ristiques d'utilisation et les s&eacute;parer autorise
	  le syst&egrave;me de fichiers &agrave; s'optimiser lui-m&ecirc;me
	  pour ces caract&eacute;ristiques.  Par exemple, les partitions
	  racine et <filename>/usr</filename> sont surtout lues, et
	  rarement utilis&eacute;es en &eacute;criture, alors que de nombreuses
	  op&eacute;rations de lecture et &eacute;criture pourront avoir lieu
	  sur <filename>/var</filename> et
	  <filename>/var/tmp</filename>.</para>

	<para>En partitionnant correctement votre syst&egrave;me,
	  la fragmentation introduite sur les partitions plus petites et
	  plus charg&eacute;es en &eacute;criture ne s'&eacute;tendra pas sur
	  les partitions principalement utilis&eacute;es en lecture.
	  De plus, avoir les partitions principalement utilis&eacute;es
	  en &eacute;criture proche du bord du disque, par exemple avant la
	  grande partition au lieu qu'apr&egrave;s dans la table des
	  partitions, augmentera les performances d'E/S sur les
	  partitions qui le demandent le plus.  Maintenant il est
	  &eacute;galement vrai que vous avez besoin de performances d'E/S
	  sur les grandes partitions, mais elles sont si grandes que
	  les d&eacute;placer plus vers l'ext&eacute;rieur du disque ne
	  donnera pas lieu &agrave; une augmentation significative des
	  performances alors que le d&eacute;placement de
	  <filename>/var</filename> vers le bord peut avoir un s&eacute;rieux
	  impact.  Et enfin, il y a &eacute;galement des raisons de
	  s&eacute;curit&eacute;.  Avoir une partition racine petite et
	  ordonn&eacute;e qui est essentiellement en lecture seule lui
	  donne plus de chance de rester intacte apr&egrave;s un crash
	  s&eacute;v&egrave;re.</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Configuration principale</title>

    <indexterm>
      <primary>fichiers rc</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>L'emplacement principal pour les donn&eacute;es de configuration
      du syst&egrave;me est le fichier <filename>/etc/rc.conf</filename>.
      Ce fichier contient une large gamme d'informations de
      configuration, principalement utilis&eacute;es au d&eacute;marrage
      du syst&egrave;me
      pour configurer ce dernier.  Son nom le sous-entend; c'est
      l'information de configuration pour les fichiers
      <filename>rc*</filename>.</para>

    <para>Un administrateur devrait ajouter des entr&eacute;es dans le
      fichier <filename>rc.conf</filename> pour remplacer les valeurs
      par d&eacute;faut du fichier
      <filename>/etc/defaults/rc.conf</filename>.  Les fichiers de
      valeurs par d&eacute;faut ne devraient pas &ecirc;tre copi&eacute;s
      directement tels quels dans <filename>/etc</filename> - ils
      contiennent des valeurs par d&eacute;faut, et non pas des exemples.
      Tout changement sp&eacute;cifique au syst&egrave;me devrait
      &ecirc;tre fait dans le fichier <filename>rc.conf</filename>.</para>

    <para>Un certain nombre de strat&eacute;gies peuvent &ecirc;tre
      appliqu&eacute;es dans le cas d'applications en grappe pour
      s&eacute;parer la configuration d'un site de celle d'un syst&egrave;me
      afin de r&eacute;duire le travail d'administration.  L'approche
      recommand&eacute;e est
      de placer la configuration propre au site dans un autre fichier
      comme <filename>/etc/rc.conf.site</filename>, puis ensuite
      inclure ce fichier dans <filename>/etc/rc.conf</filename>, qui
      ne contiendra seulement que les informations sp&eacute;cifiques au
      syst&egrave;me.</para>

    <para>Comme <filename>rc.conf</filename> est lu par &man.sh.1; il est
      assez trivial d'effectuer cela.  Par exemple:</para>

    <itemizedlist>
      <listitem><para>rc.conf:</para>
<programlisting>	. rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"</programlisting></listitem>
      <listitem><para>rc.conf.site:</para>
<programlisting>	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"</programlisting></listitem>
    </itemizedlist>

    <para>Le fichier <filename>rc.conf.site</filename> peut &ecirc;tre
      distribu&eacute; &agrave; l'ensemble des syst&egrave;mes en utilisant
      <command>rsync</command> ou un programme semblable, tandis que
      le fichier <filename>rc.conf</filename> reste unique.</para>

    <para>Mettre &agrave; jour le syst&egrave;me en employant
      &man.sysinstall.8; ou <command>make world</command> n'&eacute;crasera
      pas le fichier <filename>rc.conf</filename>, les informations de
      configuration du syst&egrave;me ne seront donc pas perdues.</para>

  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Configuration des applications</title>

    <para>G&eacute;n&eacute;ralement, les applications install&eacute;es
      ont leurs propres fichiers de configuration, avec leur propre
      syntaxe, etc...  Il est important que ces fichiers soient
      s&eacute;par&eacute;s du syst&egrave;me de base, de sorte qu'ils soient
      facilement localisables et g&eacute;rables par les outils de gestion
      des logiciels install&eacute;s.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>Ces fichiers sont g&eacute;n&eacute;ralement install&eacute;s
      dans le r&eacute;pertoire <filename>/usr/local/etc</filename>.  Dans
      le cas o&ugrave; une application poss&egrave;de un grand nombre
      de fichiers de configuration, un sous-r&eacute;pertoire sera
      cr&eacute;&eacute; pour les h&eacute;berger.</para>

    <para>Normalement, quand un logiciel port&eacute; ou
      pr&eacute;-compil&eacute; est install&eacute;, des exemples de
      fichiers de configuration sont &eacute;galement install&eacute;s.
      Ces derniers sont g&eacute;n&eacute;ralement identifi&eacute;s
      par un suffixe &ldquo;.default&rdquo;.  Si aucun fichier de
      configuration n'existe pour l'application, on les cr&eacute;era en
      copiant les fichiers .default.</para>

    <para>Par exemple, consid&eacute;rez le contenu du
      r&eacute;pertoire <filename>/usr/local/etc/apache</filename>:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>La diff&eacute;rence de taille des fichiers indique que seul le
      fichier <filename>srm.conf</filename> a &eacute;t&eacute; modifi&eacute;.  Une mise &agrave;
      jour, plus tard, du logiciel apache ne devrait pas &eacute;craser le
      fichier modifi&eacute;.</para>

  </sect1>

  <sect1 id="configtuning-starting-services">
    <title>D&eacute;marrer des services</title>

    <indexterm><primary>services</primary></indexterm>

    <para>Il est assez courant qu'un syst&egrave;me h&eacute;berge
      un certain nombre de services.  Ces derniers peuvent &ecirc;tre
      d&eacute;marr&eacute;s de diff&eacute;rentes fa&ccedil;ons, chacune
      ayant diff&eacute;rents avantages.</para>

    <indexterm><primary>/usr/local/etc/rc.d</primary></indexterm>

    <para>Un logiciel install&eacute; &agrave; partir du catalogue
      des logiciels port&eacute;s ou depuis une version
      pr&eacute;-compil&eacute;e placera souvent une proc&eacute;dure dans
      <filename>/usr/local/etc/rc.d</filename> qui sera invoqu&eacute;e
      au d&eacute;marrage du syst&egrave;me avec un argument
      <option>start</option>, et &agrave; l'arr&ecirc;t du
      syst&egrave;me avec l'argument <option>stop</option>.  C'est la
      m&eacute;thode recommand&eacute;e pour d&eacute;marrer des services
      sur le syst&egrave;me qui doivent fonctionner avec les privil&egrave;ges
      de <username>root</username>, ou s'attendent &agrave; fonctionner
      avec ces privil&egrave;ges.  Ces proc&eacute;dures font partie
      de l'installation du logiciel, et seront effac&eacute;es quand le
      logiciel sera d&eacute;sinstall&eacute;.</para>

    <para>Une proc&eacute;dure g&eacute;n&eacute;rique de d&eacute;marrage dans
      <filename>/usr/local/etc/rc.d</filename> ressemble &agrave;:</para>

    <programlisting>#!/bin/sh
echo -n ' FooBar'

case "$1" in
start)
        /usr/local/bin/foobar
        ;;
stop)
        kill -9 `cat /var/run/foobar.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0
    </programlisting>

    <para>Les proc&eacute;dures de d&eacute;marrage de FreeBSD rechercheront
      dans <filename>/usr/local/etc/rc.d</filename> les proc&eacute;dures
      qui ont une extension <literal>.sh</literal> et qui sont
      ex&eacute;cutables par <username>root</username>.  Les
      proc&eacute;dures trouv&eacute;es seront lanc&eacute;es avec une
      option <option>start</option> au d&eacute;marrage, et
      <option>stop</option> &agrave; l'arr&ecirc;t pour leur permettre de
      faire ce qu'elles ont &agrave; faire.  Donc si vous aviez voulu que la
      proc&eacute;dure pr&eacute;c&eacute;dente soit
      ex&eacute;cut&eacute;e au moment voulu pendant le d&eacute;marrage
      du syst&egrave;me, vous auriez d&ucirc; la sauver dans un fichier
      appel&eacute; <filename>FooBar.sh</filename> dans le r&eacute;pertoire
      <filename>/usr/local/etc/rc.d</filename> et en v&eacute;rifiant qu'elle
      soit ex&eacute;cutable.  Vous pouvez rendre une proc&eacute;dure
      d'interpr&eacute;teur de commandes ex&eacute;cutable avec la commande
      &man.chmod.1; comme montr&eacute; ci-dessous:</para>

    <screen>&prompt.root; <userinput>chmod 755 <replaceable>FooBar.sh</replaceable></userinput></screen>

    <para>Certains services s'attendent &agrave; &ecirc;tre invoqu&eacute;
      par &man.inetd.8; quand une demande de connexion est re&ccedil;ue
      sur le bon port.  Ceci est courant pour les serveurs de
      r&eacute;cup&eacute;ration du courrier (POP et IMAP, etc...).
      Ces services sont activ&eacute;s en &eacute;ditant le fichier
      <filename>/etc/inetd.conf</filename>. Voir la page de manuel
      &man.inetd.8; pour plus de d&eacute;tails sur l'&eacute;dition
      de ce fichier.</para>

    <para>Certains services syst&egrave;mes additionnels ne peuvent
      pas &ecirc;tre couverts par les options de
      <filename>/etc/rc.conf</filename>.  Ils sont traditionnellement
      activ&eacute;s en pla&ccedil;ant la/les commande(s) pour les invoquer
      dans le fichier <filename>/etc/rc.local</filename>.  Depuis FreeBSD 3.1
      il n'y a plus de fichier <filename>/etc/rc.local</filename> par
      d&eacute;faut; s'il est cr&eacute;&eacute; par
      l'administrateur il sera utilis&eacute; par le syst&egrave;me de
      fa&ccedil;on habituelle.  Notez que <filename>/etc/rc.local</filename>
      est g&eacute;n&eacute;ralement vu comme l'emplacement de dernier recours;
      s'il y a un meilleur emplacement pour d&eacute;marrer un service,
      utilisez-le.</para>

    <note><para>Ne placez <emphasis>aucune</emphasis> commande dans
      <filename>/etc/rc.conf</filename>.  Pour d&eacute;marrer des
      &ldquo;daemons&rdquo;, ou lancer tout autre commande au
      d&eacute;marrage, placez une proc&eacute;dure dans
      <filename>/usr/local/etc/rc.d</filename> &agrave; la place.</para>
    </note>

    <para>Il est &eacute;galement possible d'utiliser le &ldquo;daemon&rdquo;
      &man.cron.8; pour d&eacute;marrer des services syst&egrave;me.  Cette
      approche pr&eacute;sente un certain nombre d'avantages, et non des
      moindres parce que &man.cron.8; ex&eacute;cute ces proc&eacute;dures
      sous les privil&egrave;ges du propri&eacute;taire de la table
      <command>crontab</command>, les services pourront &ecirc;tre
      d&eacute;marr&eacute;s et maintenus par des utilisateurs
      non-<username>root</username>.</para>

    <para>Cela peut utiliser avantageusement une des
      caract&eacute;ristiques de &man.cron.8;: la sp&eacute;cification
      de la date d'ex&eacute;cution peut &ecirc;tre remplac&eacute;e
      par <literal>@reboot</literal>, qui provoquera l'ex&eacute;cution
      de la t&acirc;che quand &man.cron.8; est lanc&eacute;, peu de temps
      apr&egrave;s le d&eacute;marrage du syst&egrave;me.</para>
  </sect1>

  <sect1 id="configtuning-cron">
    <sect1info>
      <authorgroup>
	<author>
	<firstname>Tom</firstname>
	<surname>Rhodes</surname>
	<contrib>Contribution de </contrib>
	<!-- 20 May 2003 -->
	</author>
      </authorgroup>
    </sect1info>
    <title>Configuration de l'utilitaire
      <command>cron</command></title>

    <indexterm><primary>cron</primary>
      <secondary>configuration</secondary></indexterm>

    <para>Un des utilitaires les plus importants de &os; est
      &man.cron.8;.  L'utilitaire <command>cron</command> tourne en
      arri&egrave;re plan et contr&ocirc;le constamment le fichier
      <filename>/etc/crontab</filename>.  L'utilitaire
      <command>cron</command> consulte &eacute;galement le
      r&eacute;pertoire <filename
      role="directory">/var/cron/tabs</filename>, &agrave; la
      recherche de nouveaux fichiers <filename>crontab</filename>.
      Ces fichiers <filename>crontab</filename> conservent les
      informations sur les t&acirc;ches que <command>cron</command>
      est cens&eacute; ex&eacute;cuter &agrave; des moments
      donn&eacute;s.</para>

    <para>Examinons le fichier
      <filename>/etc/crontab</filename>:</para>


    <programlisting># /etc/crontab - root's crontab for &os;
#
# &dollar;&os;: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co id="co-comments">
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co id="co-env">
HOME=/var/log
#
#
#minute	heure	date	mois	jour	utilisateur	commande <co id="co-field-descr">
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <co id="co-main"></programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>Comme pour la plupart des fichiers de configuration de
	  &os;, le caract&egrave;re <literal>#</literal> indique un
	  commentaire.  Un commentaire peut &ecirc;tre ajout&eacute;
	  dans le fichier comme rappel de ce que fait une action bien
	  pr&eacute;cise et pourquoi elle est effectu&eacute;e.  Les
	  commentaires ne peuvent &ecirc;tre situ&eacute;s sur la
	  m&ecirc;me ligne qu'une commande ou sinon ils seront
	  interpr&eacute;t&eacute;s comme faisant partie de la commande;
	  ils doivent se trouver sur une nouvelle ligne.  Les lignes
	  vides sont ignor&eacute;es.</para>
      </callout>

      <callout arearefs="co-env">
	<para>Tout d'abord, les variables d'environnement doivent
	  &ecirc;tre d&eacute;finies.  Le caract&egrave;re &eacute;gal
	  (<literal>=</literal>) est utilis&eacute; pour d&eacute;finir
	  tout param&egrave;tre concernant l'environnement, comme dans
	  notre exemple o&ugrave; il a &eacute;t&eacute; utilis&eacute;
	  pour les variables <envar>SHELL</envar>, <envar>PATH</envar>,
	  et <envar>HOME</envar>.  Si la ligne concernant
	  l'interpr&eacute;teur de commande est omise,
	  <command>cron</command> utilisera celui par d&eacute;faut, qui
	  est <command>sh</command>.  Si la variable <envar>PATH</envar>
	  est omise, il n'y aura pas de valeur par d&eacute;faut
	  utilis&eacute;e et l'emplacement des fichiers devra &ecirc;tre
	  absolu.  Si <envar>HOME</envar> est omise,
	  <command>cron</command> utilisera le r&eacute;pertoire
	  personnel de l'utilisateur qui l'invoque.</para>
	</callout>

      <callout arearefs="co-field-descr">
	<para>Cette ligne d&eacute;finie un total de sept champs.
	  Sont list&eacute;s ici les valeurs <literal>minute</literal>,
	  <literal>heure</literal>, <literal>date</literal>,
	  <literal>mois</literal>, <literal>jour</literal>,
	  <literal>utilisateur</literal>, et
	  <literal>commande</literal>.  Ces champs sont relativement
	  explicites.  <literal>minute</literal> repr&eacute;sente
	  l'heure en minute &agrave; laquelle la commande sera
	  ex&eacute;cut&eacute;e.  L'option <literal>heure</literal> est
	  semblable &agrave; l'option <literal>minute</literal>, mais en
	  heures.  Le champ <literal>date</literal> pr&eacute;cise le
	  jour dans le mois.  <literal>mois</literal> est similaire
	  &agrave; <literal>heure</literal> et <literal>minute</literal>
	  mais d&eacute;signe le mois.  L'option <literal>jour</literal>
	  repr&eacute;sente le jour de la semaine.  Tous ces champs
	  doivent &ecirc;tre des valeurs num&eacute;riques, et respecter
	  un format horaire de vingt quatre heures.  Le champ
	  <literal>utilisateur</literal> est sp&eacute;cial, et n'existe
	  que dans le fichier <filename>/etc/crontab</filename>.  Ce
	  champ pr&eacute;cise sous quel utilisateur sera
	  ex&eacute;cut&eacute;e la commande.  Quand un utilisateur
	  installe son fichier <filename>crontab</filename>, il n'aura
	  pas cette option.  Pour finir, l'option
	  <literal>commande</literal> est list&eacute;e.  C'est le
	  dernier champ, qui naturellement devrait d&eacute;signer la
	  commande &agrave; ex&eacute;cuter.</para>
      </callout>

      <callout arearefs="co-main">
	<para>Cette derni&egrave;re ligne d&eacute;finie les valeurs
	  discut&eacute;es ci-dessus.  Nous avons ici
	  <literal>*/5</literal> suivi de plusieurs caract&egrave;res
	  <literal>*</literal>.  Ces caract&egrave;res
	  <literal>*</literal> signifient &ldquo;premier-dernier&rdquo;,
	  et peuvent &ecirc;tre interpr&eacute;t&eacute;s comme voulant
	  dire &agrave; <emphasis>chaque</emphasis> instance.  Aussi,
	  d'apr&egrave;s cette ligne, il appara&icirc;t que la commande
	  <command>atrun</command> sera invoqu&eacute;e par
	  l'utilisateur <username>root</username> toutes les cinq
	  minutes ind&eacute;pendemment du jour ou du mois.  Pour plus
	  d'informations sur la commande <command>atrun</command>,
	  consultez la page de manuel de &man.atrun.8;.</para>

	<para>N'importe quel nombre d'indicateur peut &ecirc;tre
	  pass&eacute; &agrave; ces commandes; cependant, les
	  commandes qui s'&eacute;tendent sur de multiples lignes
	  doivent &ecirc;tre &ldquo;cass&eacute;es&rdquo; avec le
	  caract&egrave;re, contre-oblique <literal>\</literal>, de
	  continuation de lignes.</para>
      </callout>
    </calloutlist>

    <para>Ceci est la configuration de base pour chaque fichier
      <filename>crontab</filename>, bien qu'il y ait une
      diff&eacute;rence dans celui pr&eacute;sent&eacute; ici.  Le
      sixi&egrave;me champ, o&ugrave; est pr&eacute;cis&eacute; le nom
      d'utilisateur, n'existe que dans le fichier syst&egrave;me
      <filename>/etc/crontab</filename>.  Ce champ devrait &ecirc;tre
      omis pour les fichiers <filename>crontab</filename>
      d'utilisateur.</para>

    <sect2 id="configtuning-installcrontab">
      <title>Installer un fichier crontab</title>

      <para>Pour installer un fichier <filename>crontab</filename>
	fraichement r&eacute;dig&eacute;, utilisez simplement
	l'utilitaire <command>crontab</command>.  L'usage le plus
	typique est:</para>

      <screen>&prompt.root; <userinput>crontab crontab</userinput></screen>

      <para>Il existe &eacute;galement une option pour afficher les
	fichiers <filename>crontab</filename> install&eacute;s, passez
	simplement le param&egrave;tre <option>-l</option> &agrave;
	<command>crontab</command> et lisez ce qui est
	affich&eacute;.</para>

      <para>Pour les utilisateurs d&eacute;sirant cr&eacute;er leur
	fichier crontab &agrave; partir de z&eacute;ro, sans utiliser
	de mod&egrave;le, l'option <command>crontab -e</command> est
	disponible.  Cela invoquera l'&eacute;diteur par d&eacute;faut
	avec un fichier vide.  Quand le fichier est sauvegard&eacute;,
	il sera automatiquement install&eacute; par la commande
	<command>crontab</command>.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-rcNG">
    <sect1info>
      <authorgroup>
        <author>
	 <firstname>Tom</firstname>
	 <surname>Rhodes</surname>
	 <contrib>Contribution de </contrib>
	 <!-- 16 May 2003 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>Utilisation du syst&egrave;me rc sous &os;&nbsp;5.X</title>

    <indexterm><primary>rcNG</primary></indexterm>

    <para>Le syst&egrave;me <filename>rc.d</filename> de NetBSD pour
      l'initialisation du syst&egrave;me a r&eacute;cemment
      &eacute;t&eacute; int&eacute;gr&eacute; &agrave; &os;.  Les
      utilisateurs noteront les fichiers pr&eacute;sents dans le
      r&eacute;pertoire <filename
      role="directory">/etc/rc.d</filename>.  Plusieurs de ces
      fichiers sont destin&eacute;s aux services de base qui peuvent
      &ecirc;tre contr&ocirc;l&eacute;s avec les options
      <option>start</option>, <option>stop</option>, et
      <option>restart</option>.  Par exemple, &man.sshd.8; peut
      &ecirc;tre relanc&eacute; avec la commande suivante:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd restart</userinput></screen>
    <para>Cette proc&eacute;dure est similaire pour d'autres services.
      Bien s&ucirc;r, les services sont g&eacute;n&eacute;ralement
      lanc&eacute;s automatiquement d&egrave;s qu'ils sont
      sp&eacute;cifi&eacute;s dans le fichier &man.rc.conf.5;.  Par
      exemple, activer le &ldquo;daemon&rdquo; de translation d'adresses
      au d&eacute;marrage est aussi simple que d'ajouter la ligne
      suivante au fichier <filename>/etc/rc.conf</filename>:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Si une ligne <option>natd_enable="NO"</option> est
      d&eacute;j&agrave; pr&eacute;sente, modifiez alors le
      <option>NO</option> par <option>YES</option>.  Les
      proc&eacute;dures rc chargeront automatiquement les autres
      services d&eacute;pendants lors du prochain red&eacute;marrage
      comme d&eacute;crit ci-dessous.</para>

    <para>Comme le syst&egrave;me <filename>rc.d</filename> est
      &agrave; l'origine destin&eacute; pour lancer/arr&ecirc;ter les
      services au d&eacute;marrage/&agrave; l'arr&ecirc;t du
      syst&egrave;me, les options standards <option>start</option>,
      <option>stop</option> et <option>restart</option> ne seront
      effectives que si les variables appropri&eacute;es sont
      positionn&eacute;es dans le fichier
      <filename>/etc/rc.conf</filename>.  Par exemple, la commande
      <command>sshd restart</command> ci-dessus ne fonctionnera que si
      <varname>sshd_enable</varname> est fix&eacute;e &agrave;
      <option>YES</option> dans <filename>/etc/rc.conf</filename>.
      Pour lancer, arr&ecirc;ter ou red&eacute;marrer un service
      ind&eacute;pendemment des param&eacute;trages du fichier
      <filename>/etc/rc.conf</filename>, les commandes doivent
      &ecirc;tre pr&eacute;c&eacute;d&eacute;es par
      &ldquo;force&rdquo;.  Par exemple pour red&eacute;marrer
      <command>sshd</command> ind&eacute;pendemment du
      param&eacute;trage du fichier <filename>/etc/rc.conf</filename>,
      ex&eacute;cutez la commande suivante:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd forcerestart</userinput></screen>

    <para>Il est facile de contr&ocirc;ler si un service est
      activ&eacute; dans le fichier <filename>/etc/rc.conf</filename>
      en ex&eacute;cutant la proc&eacute;dure
      <filename>rc.d</filename> appropri&eacute;e avec l'option
      <option>rcvar</option>.  Ainsi, un administrateur peut
      contr&ocirc;ler que <command>sshd</command> est
      r&eacute;ellement activ&eacute; dans
      <filename>/etc/rc.conf</filename> en ex&eacute;cutant:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note>
      <para>La seconde ligne (<literal># sshd</literal>) est la sortie
	de la commande <command>sshd</command> et non pas une console
	<username>root</username>.</para>
    </note>

    <para>Pour d&eacute;terminer si un service est actif, une option
      appel&eacute;e <option>status</option> est disponible.  Par
      exemple pour v&eacute;rifier que <command>sshd</command> a
      r&eacute;ellement &eacute;t&eacute; lanc&eacute;:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>Il est &eacute;galement possible de recharger un service
      avec l'option <option>reload</option>.  Le syst&egrave;me
      tentera d'envoyer un signal &agrave; un service individuel, le
      for&ccedil;ant &agrave; recharger ses fichiers de configuration.
      Dans la plupart des cas cela signifie envoyer un signal
      <literal>SIGHUP</literal> au service.</para>

    <para>La structure <application>rcNG</application> n'est pas
      uniquement utilis&eacute;e pour les services r&eacute;seaux,
      elle participe &agrave; la majeure partie de l'initialisation du
      syst&egrave;me.  Prenez par exemple le fichier
      <filename>bgfsck</filename>.  Quand cette proc&eacute;dure est
      ex&eacute;cut&eacute;e, il affichera le message suivant:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Donc ce fichier est utilis&eacute; pour les
      v&eacute;rifications du syst&egrave;me de fichiers en
      arri&egrave;re plan, qui sont uniquement effectu&eacute;es lors
      de l'initialisation du syst&egrave;me.</para>

    <para>De nombreux services syst&egrave;me d&eacute;pendent
      d'autres services pour fonctionner correctement.  Par exemple,
      NIS et les autres services bas&eacute;s sur les RPCs peuvent
      &eacute;chouer s'ils sont lanc&eacute;s apr&egrave;s le
      lancement du service <command>rpcbind</command> (portmapper).
      Pour r&eacute;soudre ce probl&egrave;me, l'information
      concernant les d&eacute;pendances et autres
      m&eacute;ta-donn&eacute;es est inclue dans les commentaires au
      d&eacute;but de chaque proc&eacute;dure de d&eacute;marrage.  Le
      programme &man.rcorder.8; est alors utilis&eacute; pour analyser
      ces commentaires lors de l'initialisation du syst&egrave;me en
      vue de d&eacute;terminer l'ordre dans lequel les services
      syst&egrave;me seront invoqu&eacute;s pour satisfaire les
      d&eacute;pendances.  Les mots suivants peuvent &ecirc;tre
      pr&eacute;sents en t&ecirc;te de chaque fichier de
      d&eacute;marrage:</para>

    <itemizedlist>
      <listitem>
	<para><literal>PROVIDE</literal>: indique les services que
	  fournit ce fichier.<para>
      </listitem>

      <listitem>
	<para><literal>REQUIRE</literal>: liste les fichiers dont
	  d&eacute;pend ce service.  Ce fichier sera
	  ex&eacute;cut&eacute; <emphasis>apr&egrave;s</emphasis> les
	  services indiqu&eacute;s.</para>
      </listitem>

      <listitem>
	<para><literal>BEFORE</literal>: liste les services qui
	  d&eacute;pendent du service pr&eacute;sent.  Ce fichier sera
	  ex&eacute;cut&eacute; <emphasis>avant</emphasis> les services
	  indiqu&eacute;s.</para>
      </listitem>

      <listitem>
	<para><literal>KEYWORD</literal>: &os; ou NetBSD.  Ceci est
	  utilis&eacute; pour des fonctionnalit&eacute;s propres au
	  syst&egrave;me d'exploitation.</para>
      </listitem>
    </itemizedlist>

    <para>En utilisant ce syst&egrave;me, un administrateur peut
      facilement contr&ocirc;ler les services du syst&egrave;me sans
      avoir &agrave; se battre avec les &ldquo;runlevels&rdquo; comme
      sur d'autres syst&egrave;mes d'exploitation &unix;.</para>

    <para>Des informations suppl&eacute;mentaires concernant le
      syst&egrave;me <filename>rc.d</filename> de &os;&nbsp;5.X
      peuvent &ecirc;tre trouv&eacute;es dans les pages de manuel
      &man.rc.8; et &man.rc.subr.8;.</para>
  </sect1>

  <sect1 id="config-network-setup">
    <sect1info>
      <authorgroup>
        <author>
	 <firstname>Marc</firstname>
	 <surname>Fonvieille</surname>
	 <contrib>Contribution de </contrib>
	 <!-- 6 October 2002 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>Configuration des cartes r&eacute;seaux</title>

    <indexterm><primary>Configuration des cartes r&eacute;seaux</primary></indexterm>

    <para>De nos jours il est impossible de penser &agrave; un ordinateur
      sans penser connexion &agrave; un r&eacute;seau.  Installer et configurer
      une carte r&eacute;seau est une t&acirc;che classique pour tout
      administrateur FreeBSD.</para>

    <sect2>
      <title>D&eacute;terminer le bon pilote de
	p&eacute;riph&eacute;rique</title>

      <indexterm>
	<primary>Configuration des cartes r&eacute;seaux</primary>
	<secondary>D&eacute;terminer le pilote de
	  p&eacute;riph&eacute;rique</secondary>
      </indexterm>

      <para>Avant de commencer, vous devez conna&icirc;tre le mod&egrave;le
	de la carte dont vous disposez, le circuit qu'elle
	utilise, et si c'est une carte PCI ou ISA.  FreeBSD supporte
	une large vari&eacute;t&eacute; de cartes PCI et ISA.  Consultez la liste de
	compatibilit&eacute; mat&eacute;rielle pour votre version de FreeBSD afin de
	voir si votre carte est support&eacute;e.</para>

      <para>Une fois que vous &ecirc;tes s&ucirc;rs que votre carte
	est support&eacute;e, vous devez d&eacute;terminer le bon pilote de
	p&eacute;riph&eacute;rique pour la carte.  Le fichier
	<filename>/usr/src/sys/i386/conf/LINT</filename> vous donnera
	la liste des pilotes de p&eacute;riph&eacute;riques pour cartes
	r&eacute;seaux avec des informations sur les cartes/circuits
	support&eacute;s.  Si vous avez des doutes au sujet du bon pilote,
	lisez la page de manuel du pilote.  La page de manuel vous
	donnera plus d'information sur le mat&eacute;riel support&eacute; et
	m&ecirc;me les &eacute;ventuels probl&egrave;mes qui pourront
	appara&icirc;tre.</para>

      <para>Si vous poss&eacute;dez une carte courante, la plupart du temps
	vous n'aurez pas &agrave; chercher trop loin pour trouver un pilote.
	Les pilotes pour les cartes r&eacute;seaux courantes sont
	pr&eacute;sents dans le noyau <filename>GENERIC</filename>, aussi
	votre carte devrait appara&icirc;tre au d&eacute;marrage, comme
	suit:</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</screen>

      <para>Dans cet exemple, nous voyons que deux cartes utilisant le
	pilote de p&eacute;riph&eacute;rique &man.dc.4; sont pr&eacute;sentes
	sur le syst&egrave;me.</para>

      <para>Pour utiliser votre carte r&eacute;seau, vous devrez charger
	le pilote de p&eacute;riph&eacute;rique correct.  Cela peut
	&ecirc;tre accompli de deux fa&ccedil;ons.  La plus simple est de charger
	le module pour votre carte r&eacute;seau avec &man.kldload.8;.
	Un module n'est pas disponible pour toutes les cartes r&eacute;seaux
	(les cartes ISA ou celles utilisant le pilote &man.ed.4;, par
	exemple).  Alternativement, vous pouvez compiler en statique
	le support pour votre carte dans votre noyau.  Consultez
	<filename>/usr/src/sys/i386/conf/LINT</filename> et la page
	de manuel du pilote de p&eacute;riph&eacute;rique pour savoir ce qu'il
	faut ajouter &agrave; votre fichier de configuration de votre noyau.
	Pour plus d'information sur la recompilation de votre noyau,
	veuillez lire le <xref linkend="kernelconfig">.  Si votre
	carte a &eacute;t&eacute; d&eacute;tect&eacute;e au d&eacute;marrage par
	votre noyau (<filename>GENERIC</filename>) vous n'avez pas
	&agrave; compiler un nouveau noyau.</para>
    </sect2>

    <sect2>
      <title>Configuration de la carte r&eacute;seau</title>

      <indexterm>
	<primary>Configuration des cartes r&eacute;seaux</primary>
	<secondary>configuration</secondary>
      </indexterm>

      <para>Une fois que le bon pilote de p&eacute;riph&eacute;rique
	pour la carte r&eacute;seau est charg&eacute;, la carte doit
	&ecirc;tre configur&eacute;e.  Comme beaucoup d'autres choses, la carte
	aura pu &ecirc;tre configur&eacute;e &agrave;
	l'installation par <application>sysinstall</application>.</para>

      <para>Pour afficher la configuration des interfaces r&eacute;seaux
	de votre syst&egrave;me, entrer la commande suivante:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</screen>

      <note>
	<para>D'anciennes versions de FreeBSD pourront n&eacute;cessiter
	  l'option <option>-a</option> apr&egrave;s &man.ifconfig.8;,
	  pour plus de d&eacute;tails au sujet de la syntaxe d'&man.ifconfig.8;,
	  veuillez vous r&eacute;f&eacute;rer &agrave; la page de manuel.
	  Notez &eacute;galement que les entr&eacute;es concernant l'IPv6
	  (<literal>inet6</literal> etc...) ont &eacute;t&eacute; omises
	  dans cet exemple.</para>
      </note>

      <para>Dans cet exemple, les p&eacute;riph&eacute;riques suivants
	ont &eacute;t&eacute; affich&eacute;s:</para>

      <itemizedlist>
	<listitem>
	  <para><devicename>dc0</devicename>: La premi&egrave;re
	    interface Ethernet</para>
	</listitem>

	<listitem>
	  <para><devicename>dc1</devicename>: La seconde
	    interface Ethernet</para>
	</listitem>

	<listitem>
	  <para><devicename>lp0</devicename>: L'interface du port
	    parall&egrave;le</para>
	</listitem>

	<listitem>
	  <para><devicename>lo0</devicename>: L'interface
	    &ldquo;en boucle&rdquo; (&ldquo;loopback&rdquo;)</para>
	</listitem>

	<listitem>
	  <para><devicename>tun0</devicename>: L'interface
	    &ldquo;tunnel&rdquo; utilis&eacute;e par
	    <application>ppp</application></para>
	</listitem>
      </itemizedlist>

      <para>FreeBSD utilise le nom du pilote de p&eacute;riph&eacute;rique
	suivi par un chiffre repr&eacute;sentant l'ordre dans lequel
	la carte est d&eacute;tect&eacute;e au d&eacute;marrage du noyau pour nommer la
	carte.  Par exemple <devicename>sis2</devicename> serait la
	troisi&egrave;me carte sur le syst&egrave;me utilisant le pilote de
	p&eacute;riph&eacute;rique &man.sis.4;.</para>

      <para>Dans cet exemple, le p&eacute;riph&eacute;rique
	<devicename>dc0</devicename> est actif et en fonctionnement.
	Les indicateurs importants sont:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> signifie que la carte est
	    configur&eacute;e et pr&ecirc;te.</para>
	</listitem>

	<listitem>
	  <para>La carte poss&egrave;de une adresse Internet
	    (<literal>inet</literal>) (dans ce cas-ci
	    <hostid role="ipaddr">192.168.1.3</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Elle a un masque de sous-r&eacute;seau valide 
	    (<literal>netmask</literal>;
	    <hostid role="netmask">0xffffff00</hostid> est &eacute;quivalent
	    &agrave; <hostid role="netmask">255.255.255.0</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Elle a une adresse de diffusion valide (dans ce cas-ci
	    <hostid role="ipaddr">192.168.1.255</hostid>).</para>
	</listitem>

	<listitem>
	  <para>L'adresse MAC de la carte (<literal>ether</literal>)
	    est <hostid role="mac">00:a0:cc:da:da:da</hostid></para>
	</listitem>

	<listitem>
	  <para>La s&eacute;lection du m&eacute;dia est sur le mode
	    d'autos&eacute;lection (<literal>media: Ethernet autoselect
	    (100baseTX &lt;full-duplex&gt;)</literal>).  Nous voyons
	    que <devicename>dc1</devicename> a &eacute;t&eacute; configur&eacute;e
	    pour utiliser un mat&eacute;riel de type
	    <literal>10baseT/UTP</literal>.  Pour plus d'information
	    sur le type de mat&eacute;riel disponible pour un pilote de
	    p&eacute;riph&eacute;rique, r&eacute;f&eacute;rez-vous &agrave;
	    sa page de manuel.</para>
	</listitem>

	<listitem>
	  <para>La liaison (<literal>status</literal>)
	    est <literal>active</literal>, i.e. la porteuse est
	    d&eacute;tect&eacute;e.  Pour <devicename>dc1</devicename>, nous lisons
	    <literal>status: no carrier</literal>.  Cela est normal
	    lorsqu'aucun c&acirc;ble n'est branch&eacute; &agrave;
	    la carte.</para>
	</listitem>
      </orderedlist>

      <para>Si le r&eacute;sultat de la commande &man.ifconfig.8; est
	similaire &agrave;:</para>

<screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
	        ether 00:a0:cc:da:da:da</screen>

      <para>cela indiquerait que la carte n'a pas &eacute;t&eacute;
	configur&eacute;e.</para>

      <para>Pour configurer votre carte, vous avez besoin des
	privil&egrave;ges de l'utilisateur <username>root</username>.
	La configuration de la carte r&eacute;seau peut &ecirc;tre
	faite &agrave; partir de la ligne de commande avec &man.ifconfig.8;
	mais vous aurez &agrave; r&eacute;p&eacute;ter cette
	op&eacute;ration &agrave; chaque red&eacute;marrage du syst&egrave;me.
	Le fichier <filename>/etc/rc.conf</filename> est l'endroit o&ugrave;
	ajouter la configuration de la carte r&eacute;seau.</para>

      <para>Ouvrez le fichier <filename>/etc/rc.conf</filename>
	dans votre &eacute;diteur favori.  Vous devez ajouter une ligne
	pour chaque carte r&eacute;seau pr&eacute;sente sur le syst&egrave;me, par exemple
	dans notre cas, nous avons ajout&eacute; ces lignes:</para>

<programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>Vous devez remplacer <devicename>dc0</devicename>,
	<devicename>dc1</devicename>, et ainsi de suite, avec
	le p&eacute;riph&eacute;rique correspondant pour vos cartes, et les adresses
	avec celles d&eacute;sir&eacute;es.  Vous devriez lire les pages de manuel
	du pilote de p&eacute;riph&eacute;rique et d'&man.ifconfig.8; pour
	plus de d&eacute;tails sur les options autoris&eacute;es et
	&eacute;galement la page de manuel de &man.rc.conf.5; pour plus
	d'information sur la syntaxe de
	<filename>/etc/rc.conf</filename>.</para>

      <para>Si vous avez configur&eacute; le r&eacute;seau &agrave;
	l'installation, des lignes concernant la/les carte(s)
	r&eacute;seau pourront &ecirc;tre d&eacute;j&agrave; pr&eacute;sentes.
	Contr&ocirc;ler &agrave; deux fois le fichier
	<filename>/etc/rc.conf</filename> avant d'y ajouter des
	lignes.</para>

      <para>Vous devrez &eacute;galement &eacute;diter le fichier
	<filename>/etc/hosts</filename> pour ajouter les noms et les
	adresses IP des diverses machines du r&eacute;seau local, si elles
	ne sont pas d&eacute;j&agrave; pr&eacute;sentes.  Pour plus
	d'information r&eacute;f&eacute;rez-vous &agrave; la page de manuel &man.hosts.5;
	et au fichier
	<filename>/usr/share/examples/etc/hosts</filename>.</para>
    </sect2>

    <sect2>
      <title>Test et d&eacute;pannage</title>

      <para>Une fois les modifications n&eacute;cessaires du fichier
	<filename>/etc/rc.conf</filename> effectu&eacute;es, vous
	devrez red&eacute;marrer votre syst&egrave;me.  Cela
	permettra la prise en compte de la ou les modifications
	au niveau des interfaces, et permettra de v&eacute;rifier
	que le syst&egrave;me red&eacute;marre sans erreur de
	configuration.</para>

      <para>Une fois que le syst&egrave;me a &eacute;t&eacute;
	red&eacute;marr&eacute;, vous devrez tester les interfaces
	r&eacute;seau.</para>

      <sect3>
	<title>Tester la carte Ethernet</title>

	<indexterm>
	  <primary>Configuration des cartes r&eacute;seaux</primary>
	  <secondary>Test de la carte</secondary>
	</indexterm>

	<para>Pour v&eacute;rifier qu'une carte Ethernet est
	  configur&eacute;e correctement, vous devez essayer deux choses.
	  Premi&egrave;rement, &ldquo;pinguer&rdquo; l'interface, puis une
	  autre machine sur le r&eacute;seau local.</para>

	<para>Tout d'abord testons l'interface:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

	<para>Nous devons maintenant &ldquo;pinguer&rdquo; une
	  autre machine sur le r&eacute;seau:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

	<para>Vous pourrez utiliser le noms de la machine &agrave;
	  la place de <hostid role="ipaddr">192.168.1.2</hostid>
	  si vous avez configur&eacute; le fichier
	  <filename>/etc/hosts</filename>.</para>
      </sect3>

      <sect3>
	<title>D&eacute;pannage</title>

      <indexterm>
	<primary>Configuration des cartes r&eacute;seaux</primary>
	<secondary>D&eacute;pannage</secondary>
      </indexterm>

	<qandaset>
	  <qandaentry>
	    <question>
	      <para>O&ugrave; puis-je trouver de l'information au sujet des
		possibles probl&egrave;mes que je peux rencontrer avec ma
		carte r&eacute;seau.</para>
	    </question>

	    <answer>
	      <para>La page de manuel du pilote de p&eacute;riph&eacute;rique
		est la premi&egrave;re documentation &agrave; lire.  Les archives
		des listes de diffusion peuvent &eacute;galement
		&ecirc;tre utiles.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question>
	      <para>Quand j'essaye un &ldquo;ping&rdquo; vers une
		machine du r&eacute;seau, j'obtiens le message suivant:
		<errorname>ping: sendto: Permission denied</errorname>.</para>
	    </question>

	    <answer>
	      <para>Cela signifie que vous n'avez pas la permission
		d'envoyer des paquets ICMP.  Contr&ocirc;lez si un coupe-feu
		tourne sur la machine et s'il y a des r&egrave;gles bloquant
		l'ICMP.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question>
	      <para>Je vois beaucoup de messages
		<errorname>watchdog timeout</errorname> dans les
		fichiers de trace du syst&egrave;me, et quand je tente un
		&ldquo;ping&rdquo; vers une autre machine sur le
		r&eacute;seau local, j'obtiens ce message:
		<errorname>ping: sendto: No route to host</errorname>.</para>
	    </question>

	    <answer>
	      <para>La premi&egrave;re chose &agrave; contr&ocirc;ler
		est votre c&acirc;ble r&eacute;seau.  De nombreuses cartes
		r&eacute;seaux demandent un slot PCI supportant
		le &ldquo;Bus Mastering&rdquo;.  Sur certaines cartes
		m&egrave;res anciennes, seul un slot PCI le permet (la
		plupart du temps le slot 0).  Consultez la
		documentation de la carte r&eacute;seau et de la carte m&egrave;re
		pour d&eacute;terminer si cela peut &ecirc;tre &agrave;
		l'origine du probl&egrave;me.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question>
	      <para>Je vois beaucoup de messages
		<errorname>device timeout</errorname> dans les
		fichiers de trace du syst&egrave;me, et ma carte r&eacute;seau
		ne fonctionne pas.</para>
	    </question>

	    <answer>
	      <para>Avoir un ou deux de ces messages est parfois
		normal avec certaines cartes.  Cependant s'ils
		persistent et que le r&eacute;seau n'est pas utilisable,
		assurez-vous que le c&acirc;ble r&eacute;seau est
		branch&eacute; et qu'il n'y a aucun conflit d'IRQ entre la
		carte r&eacute;seau et un autre p&eacute;riph&eacute;rique (ou
		p&eacute;riph&eacute;riques) sur le syst&egrave;me.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question>
	      <para>Les performances de la carte sont mauvaises, que
		puis-je faire?</para>
	    </question>

	    <answer>
	      <para>Il est difficile de r&eacute;pondre &agrave; cette
		question.  Quelle est votre d&eacute;finition de
		&ldquo;mauvaises performances&rdquo;?  Rev&eacute;rifiez
		l'ensemble de votre configuration, lisez la page
		de manuel &man.tuning.7;, et essayez d'&eacute;viter les
		cartes r&eacute;seaux bon march&eacute;.  De nombreux utilisateurs
		ont remarqu&eacute; que positionner la s&eacute;lection du m&eacute;dia
		dans le mode <literal>autoselect</literal> peut
		&ecirc;tre &agrave; l'origine de mauvaises performances sur
		certains mat&eacute;riels.</para>
	    </answer>
	  </qandaentry>

	  <qandaentry>
	    <question>
	      <para>Y-a-t-il des cartes r&eacute;seaux recommand&eacute;es ou des
		cartes que je devrais &eacute;viter?</para>
	    </question>

	    <answer>
	      <para>Vous devriez &eacute;viter les cartes bon march&eacute; pour une
		utilisation s&eacute;rieuse.  Les cartes bon march&eacute; utilisent
		souvent des circuits bogu&eacute;s, et la plupart du temps ne
		peuvent fournir de bonnes performances.  De nombreux
		utilisateurs de FreeBSD appr&eacute;cient les cartes
		utilisant le circuit &man.fxp.4;, cependant, cela ne
		veut pas dire que les autres circuits sont
		mauvais.</para>
	    </answer>
	  </qandaentry>
	</qandaset>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>H&ocirc;tes virtuels</title>

    <indexterm><primary>h&ocirc;tes virtuels</primary></indexterm>
    <indexterm><primary>alias IP</primary></indexterm>

    <para>Une utilisation tr&egrave;s courante de FreeBSD est
      l'h&eacute;bergement de sites virtuels, o&ugrave; un serveur
      appara&icirc;t pour le r&eacute;seau comme &eacute;tant
      plusieurs serveurs diff&eacute;rents.  Ceci est possible en assignant
      plusieurs adresses r&eacute;seau &agrave; une interface.</para>

    <para>Une interface r&eacute;seau donn&eacute;e poss&egrave;de une
      adresse &ldquo;r&eacute;elle&rdquo;, et peut avoir n'importe
      quel nombre d'adresses &ldquo;alias&rdquo;.  Ces alias sont
      normalement ajout&eacute;s en pla&ccedil;ant les entr&eacute;es
      correspondantes dans le fichier
      <filename>/etc/rc.conf</filename>.</para>

    <para>Une entr&eacute;e d'alias pour l'interface
      <devicename>fxp0</devicename> ressemble &agrave;:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Notez que les entr&eacute;es d'alias doivent commencer avec alias0
      et continuer en ordre croissant, (par exemple, _alias1, _alias2,
      et ainsi de suite).  Le processus de configuration s'arr&ecirc;tera
      au premier nombre absent.</para>

    <para>Le calcul des masques de r&eacute;seau est important, mais
      heureusement assez simple.  Pour une interface donn&eacute;e, il doit y
      avoir une adresse qui repr&eacute;sente correctement le masque de
      r&eacute;seau de votre r&eacute;seau.  Tout autre adresse appartenant
      &agrave; ce r&eacute;seau devra avoir un masque de r&eacute;seau
      avec chaque bit &agrave; <literal>1</literal>.</para>

    <para>Par exemple, consid&eacute;rez le cas o&ugrave;
      l'interface <devicename>fxp0</devicename> est connect&eacute;e &agrave;
      deux r&eacute;seaux, le r&eacute;seau <hostid role="ipaddr">10.1.1.0</hostid> avec un masque de
      r&eacute;seau de
      <hostid role="netmask">255.255.255.0</hostid> et le r&eacute;seau <hostid role="ipaddr">202.0.75.16</hostid> avec un masque de
      <hostid role="netmask">255.255.255.240</hostid>.  Nous voulons que le syst&egrave;me apparaisse de
      <hostid role="ipaddr">10.1.1.1</hostid> jusqu'&agrave; <hostid role="ipaddr">10.1.1.5</hostid> et &agrave; <hostid role="ipaddr">202.0.75.17</hostid> jusqu'&agrave;
      <hostid role="ipaddr">202.0.75.20</hostid>.</para>

    <para>Les entr&eacute;es suivantes configurent la carte
      correctement pour cet arrangement:</para>

<programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Fichiers de configuration</title>

    <sect2>
      <title>Organisation du r&eacute;pertoire <filename>/etc</filename></title>
      <para>Il existe un certain nombre de r&eacute;pertoires dans lesquels
	se trouvent les informations de configuration.  Ceux-ci
	incluent:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>Information de configuration g&eacute;n&eacute;rique du
		syst&egrave;me; les donn&eacute;es ici sont
		sp&eacute;cifiques au syst&egrave;me.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>Version par d&eacute;faut des fichiers de configuration
		du syst&egrave;me.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>Configuration de &man.sendmail.8;, et autres fichiers
		de configuration d'agent de transmission du courrier
		&eacute;lectronique.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>Configuration pour les programmes PPP utilisateur
		et int&eacute;gr&eacute; au noyau.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>Emplacement par d&eacute;faut pour les donn&eacute;es de
		 &man.named.8;.  Normalement
		 <filename>named.conf</filename> et les fichiers de zone
		 sont stock&eacute;s dans ce r&eacute;pertoire.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc</filename></entry>
	      <entry>Fichiers de configuration pour les applications
		install&eacute;es.  Peut contenir des sous-r&eacute;pertoires
		pour chaque application.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>Proc&eacute;dures de lancement/d'arr&ecirc;t pour les
		applications install&eacute;es.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>Fichiers de bases de donn&eacute;es automatiquement
		g&eacute;n&eacute;r&eacute;s, sp&eacute;cifiques
		au syst&egrave;me, comme la base de donn&eacute;es
		des logiciels install&eacute;s, la base de donn&eacute;es de
		localisation des fichiers, et ainsi de suite.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Nom d'h&ocirc;tes</title>

      <indexterm><primary>nom d'h&ocirc;te</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm>
	  <primary><filename>resolv.conf</filename></primary>
	</indexterm>

	<para><filename>/etc/resolv.conf</filename> g&egrave;re comment
	  le r&eacute;solveur de FreeBSD acc&egrave;de au syst&egrave;me
	  de nom de domaine d'Internet (DNS).</para>

	<para>Les entr&eacute;es la plus classiques du fichier
	  <filename>resolv.conf</filename> sont:</para>

	<informaltable frame="none">
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>
		<entry>L'adresse IP du serveur de noms auquel le
		  r&eacute;solveur devrait envoyer ses requ&ecirc;tes.  Les
		  serveurs sont sollicit&eacute;s dans l'ordre list&eacute;
		  avec un maximum de trois.</entry>
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Liste de recherche pour la r&eacute;solution de nom de
		  machine.  Ceci est normalement d&eacute;termin&eacute; par le
		  domaine de l'h&ocirc;te local.</entry>
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Le nom du domaine local.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Un fichier <filename>resolv.conf</filename> typique:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note><para>Seule une des options <literal>search</literal> et
	  <literal>domain</literal> devrait &ecirc;tre
	  utilis&eacute;e.</para></note>

	<para>Si vous utilisez DHCP, &man.dhclient.8; r&eacute;&eacute;crit
	  habituellement <filename>resolv.conf</filename> avec
	  l'information re&ccedil;ue du serveur DHCP.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>

	<para><filename>/etc/hosts</filename> est une simple base de
	  donn&eacute;es texte, une r&eacute;miniscence des d&eacute;buts
	  d'Internet.  Il travaille en conjonction avec les serveurs
	  DNS et NIS pour fournir les correspondances nom vers adresse
	  IP.  Les ordinateurs locaux reli&eacute;s par
	  l'interm&eacute;diaire d'un r&eacute;seau local peuvent
	  &ecirc;tre ajout&eacute;s dans ce fichier pour une r&eacute;solution
	  de noms simple plut&ocirc;t que de configurer un serveur
	  &man.named.8;.
	  De plus <filename>/etc/hosts</filename> peut &ecirc;tre
	  utilis&eacute; pour fournir un enregistrement local de
	  correspondances de nom, r&eacute;duisant ainsi le besoin
	  de requ&ecirc;tes vers l'ext&eacute;rieur pour les noms auxquels on
	  acc&egrave;de couramment.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#</programlisting>

	<para><filename>/etc/hosts</filename> suit le format simple
	  suivant:</para>

	<programlisting>[Internet address] [official hostname] [alias1] [alias2] ...</programlisting>

	<para>Par exemple:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Consultez la page de manuel &man.hosts.5; pour plus
	  d'informations.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configuration des fichiers de trace</title>

      <indexterm><primary>fichiers de trace</primary></indexterm>

      <sect3>
	<title><filename>syslog.conf</filename></title>

	<indexterm><primary>syslog.conf</primary></indexterm>

	<para><filename>syslog.conf</filename> est le fichier de configuration
	  du programme &man.syslogd.8;.  Il indique quel type de
	  messages <command>syslog</command> sera enregistr&eacute;
	  dans des fichiers de traces particuliers.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

	<para>Consultez la page de manuel &man.syslog.conf.5; pour plus
	  d'informations.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>

	<para><filename>newsyslog.conf</filename> est le fichier de
	  configuration de &man.newsyslog.8;, un programme qui est
	  normalement programm&eacute; &man.cron.8; pour s'ex&eacute;cuter
	  p&eacute;riodiquement.  &man.newsyslog.8; d&eacute;termine quand les
	  fichiers de traces doivent &ecirc;tre archiv&eacute;s
	  ou r&eacute;organis&eacute;s.  <filename>logfile</filename> devient
	  <filename>logfile.0</filename>, <filename>logfile.0</filename>
	  devient &agrave; son tour <filename>logfile.1</filename>, et ainsi
	  de suite.  D'autre part, les fichiers de traces peuvent &ecirc;tre
	  archiv&eacute;s dans le format &man.gzip.1;, ils se nommeront
	  alors: <filename>logfile.0.gz</filename>,
	  <filename>logfile.1.gz</filename>, et ainsi de suite.</para>

	<para><filename>newsyslog.conf</filename> indique quels
	  fichiers de traces doivent &ecirc;tre g&eacute;r&eacute;s,
	  combien doivent &ecirc;tre conserv&eacute;s, et quand ils
	  doivent &ecirc;tre modifi&eacute;s.  Les fichiers de traces
	  peuvent &ecirc;tre r&eacute;organis&eacute;s et/ou archiv&eacute;s
	  quand ils ont soit atteint une certaine taille, soit &agrave; une
	  certaine p&eacute;riode/date.</para>

	<programlisting># configuration file for newsyslog
# &dollar;FreeBSD&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

	<para>Consultez la page de manuel &man.newsyslog.8; pour plus
	  d'informations.</para>
      </sect3>
    </sect2>

    <sect2>
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> ressemble &agrave;
	<filename>rc.conf</filename>.  Les valeurs sont fix&eacute;es sous
	la forme <literal>variable=value</literal>.  Les valeurs
	sp&eacute;cifi&eacute;es sont positionn&eacute;es
	apr&egrave;s que le syst&egrave;me soit pass&eacute;
	dans le mode multi-utilisateurs.  Toutes les variables ne sont
	pas param&eacute;trables dans ce mode.</para>

      <para>Un exemple de <filename>sysctl.conf</filename> d&eacute;sactivant
	la trace signaux fatals de fin de processus et faisant savoir
	aux programmes Linux qu'ils tournent sous FreeBSD.</para>

      <programlisting>kern.logsigexit=0       # Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=FreeBSD
compat.linux.osrelease=4.3-STABLE</programlisting>
    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Optimisation avec sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm><primary>optimisation avec sysctl</primary></indexterm>

    <para>&man.sysctl.8; est une interface qui vous permet d'effectuer
      des changements de param&eacute;trage sur un syst&egrave;me
      FreeBSD en fonctionnement.  Cela comprend de nombreuses options
      avanc&eacute;es de la pile TCP/IP et du syst&egrave;me de
      m&eacute;moire virtuelle qui peuvent am&eacute;liorer dramatiquement les
      performances pour un administrateur syst&egrave;me
      exp&eacute;riment&eacute;.  Plus de cinq cent variables
      syst&egrave;me peuvent &ecirc;tre lues et modifi&eacute;es
      gr&acirc;ce &agrave; &man.sysctl.8;.</para>

    <para>&man.sysctl.8; remplit deux fonctions: lire et modifier
      les param&eacute;trages du syst&egrave;me.</para>

    <para>Pour afficher toutes les variables lisibles:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Pour lire une variable particuli&egrave;re, par exemple,
      <varname>kern.maxproc</varname>:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Pour fixer une variable particuli&egrave;re, utilisez
      la syntaxe intuitive
      <replaceable>variable</replaceable>=<replaceable>valeur</replaceable>
      :</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>Les valeurs des variables sysctl sont g&eacute;n&eacute;ralement des
      cha&icirc;nes de caract&egrave;res, des nombres, ou des
      bool&eacute;ens (un variable bool&eacute;enne &eacute;tant
      <literal>1</literal> pour oui ou un <literal>0</literal> pour
      non).</para>

  <sect2 id="sysctl-readonly">
    <sect2info>
      <authorgroup>
	<author>
	 <firstname>Tom</firstname>
	 <surname>Rhodes</surname>
	 <contrib>Contribution de </contrib>
	 <!-- 31 January 2003 -->
	</author>
      </authorgroup>
    </sect2info>
    <title>Variables &man.sysctl.8; en lecture seule</title>

    <para>Dans certains cas, il peut &ecirc;tre n&eacute;cessaire de
      modifier des variables &man.sysctl.8; en lecture seule.  Bien
      que cela n'est pas recommand&eacute;, c'est parfois
      in&eacute;vitable.</para>

    <para>Par exemple sur certains mod&egrave;les d'ordinateurs
      portables le p&eacute;riph&eacute;rique &man.cardbus.4; ne
      sondera pas le syst&egrave;me &agrave; la recherche des zones
      m&eacute;moires, et &eacute;chouera avec des erreurs du
      type:</para>

    <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

    <para>Des cas comme le pr&eacute;c&eacute;dent demandent
      g&eacute;n&eacute;ralement la modification de param&egrave;tres
      &man.sysctl.8; par d&eacute;faut qui sont en lecture seule.
      Pour palier &agrave; ces situations un utilisateur peut placer
      un param&eacute;trage (&ldquo;OID&rdquo;&mdash;Object
      IDentifier) &man.sysctl.8; dans le fichier local
      <filename>/boot/loader.conf.local</filename>.  Les
      param&eacute;trages par d&eacute;faut se trouvent dans le
      fichier <filename>/boot/defaults/loader.conf</filename>.</para>

    <para>Pour corriger le probl&egrave;me pr&eacute;c&eacute;dent, il
      faudrait que l'utilisateur ajoute la ligne
      <option>hw.pci.allow_unsupported_io_range=1</option> dans le
      fichier pr&eacute;c&eacute;demment indiqu&eacute;.
      D&eacute;sormais le p&eacute;riph&eacute;rique &man.cardbus.4;
      devrait fonctionner normalement.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Optimiser les disques</title>

    <sect2>
      <title>Les variables sysctl</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>

	<para>La variable sysctl <varname>vfs.vmiodirenable</varname>
	  peut &ecirc;tre positionn&eacute;e soit &agrave; 0
	  (d&eacute;sactiv&eacute;e) soit &agrave; 1
	  (activ&eacute;e); elle est a 1 par d&eacute;faut.  Cette variable
	  sp&eacute;cifie comment les r&eacute;pertoires sont
	  cach&eacute;s par le syst&egrave;me.
	  La plupart des r&eacute;pertoires sont petits, utilisant juste un
	  simple fragment du syst&egrave;me de fichiers (typiquement 1KO) et
	  moins dans le cache en m&eacute;moire (typiquement 512 octets).
	  Cependant, quand on fonctionne dans le mode par d&eacute;faut le
	  cache en m&eacute;moire ne cachera qu'un nombre fixe de
	  r&eacute;pertoires m&ecirc;me si vous disposez d'une grande
	  quantit&eacute; de m&eacute;moire.  Activer cette variable sysctl
	  permet au cache en m&eacute;moire d'utiliser le cache des pages de
	  m&eacute;moire virtuelle pour cacher les r&eacute;pertoires,
	  rendant toute la m&eacute;moire disponible pour cacher les
	  r&eacute;pertoires.  Cependant, la taille minimale de
	  l'&eacute;l&eacute;ment m&eacute;moire utilis&eacute; pour cacher
	  un r&eacute;pertoire est une page physique (typiquement 4KO)
	  plut&ocirc;t que 512 octets.
	  Nous recommandons l'activation de cette option si
	  vous faites fonctionner des services qui manipulent un grand
	  nombre de fichiers.  De tels services peuvent &ecirc;tre des
	  caches web, d'importants syst&egrave;mes de courrier
	  &eacute;lectronique, et des syst&egrave;mes serveurs de groupe
	  de discussion.  Activer cette option ne r&eacute;duira
	  g&eacute;n&eacute;ralement pas les performances m&ecirc;me
	  avec la m&eacute;moire gaspill&eacute;e mais vous devriez
	  faire des exp&eacute;riences pour le d&eacute;terminer.</para>
      </sect3>

     <sect3>
	<title><varname>vfs.write_behind</varname></title>

	<indexterm>
	  <primary><varname>vfs.write_behind</varname></primary>
	</indexterm>

	<para>La variable sysctl <varname>vfs.write_behind</varname> est
	  positionn&eacute;e par d&eacute;faut &agrave;
	  <literal>1</literal> (activ&eacute;e).  Elle demande au
	  syst&egrave;me de fichiers d'effectuer les &eacute;critures
	  lorsque des grappes compl&egrave;tes de donn&eacute;es ont
	  &eacute;t&eacute; collect&eacute;es, ce qui se produit
	  g&eacute;n&eacute;ralement lors de l'&eacute;criture
	  s&eacute;quentielle de gros fichiers.  L'id&eacute;e est
	  d'&eacute;viter de saturer le cache tampon avec des tampons
	  sales quand cela n'am&eacute;liorera pas les performances d'E/S.
	  Cependant, cela peut bloquer les processus et dans certaines
	  conditions vous pouvez vouloir d&eacute;sactiver cette
	  fonction.</para>
       </sect3>

       <sect3>
	<title><varname>vfs.hirunningspace</varname></title>

	<indexterm>
	  <primary><varname>vfs.hirunningspace</varname></primary>
	</indexterm>

	<para>La variable sysctl <varname>vfs.hirunningspace</varname>
	  d&eacute;termine combien d'op&eacute;rations d'&eacute;criture
	  peuvent &ecirc;tre mises en attente &agrave; tout moment au
	  niveau des contr&ocirc;leurs disques du syst&egrave;me.  La
	  valeur par d&eacute;faut est normalement suffisante mais sur les
	  machines avec de nombreux disques, vous pouvez vouloir
	  l'augmenter jusqu'&agrave; quatre ou cinq
	  <emphasis>m&eacute;ga-octets</emphasis>.  Notez que fixer une
	  valeur trop &eacute;lev&eacute;e (d&eacute;passant la limite
	  d'&eacute;criture du cache tampon) peut donner lieu &agrave; de
	  tr&egrave;s mauvaises performances.  Ne fixez pas cette valeur
	  &agrave; une valeur &eacute;lev&eacute;e arbitraire!  Des
	  valeurs d'&eacute;criture &eacute;lev&eacute;es peuvent ajouter
	  des temps de latence aux op&eacute;rations d'&eacute;criture
	  survenant au m&ecirc;me moment.</para>

	<para>Il existent d'autres variables sysctl relatives aux caches
	  tampons et aux pages VM.  Nous ne recommandons pas de modifier
	  ces valeurs.  Depuis &os;&nbsp;4.3, le syst&egrave;me VM
	  effectue un tr&egrave;s bon travail d'auto-optimisation.</para>
       </sect3>

       <sect3>
	<title><varname>vm.swap_idle_enabled</varname></title>

	<indexterm>
	  <primary><varname>vm.swap_idle_enabled</varname></primary>
	</indexterm>

	<para>La variable <varname>vm.swap_idle_enabled</varname> est
	  utile dans le cas de syst&egrave;mes multi-utilisateurs
	  importants o&ugrave; il y a beaucoup d'utilisateurs s'attachant
	  et quittant le syst&egrave;me et de nombreux processus inactifs.
	  De tels syst&egrave;mes tendent &agrave; g&eacute;n&eacute;rer
	  une pression assez importante et continue sur les
	  r&eacute;serves de m&eacute;moire libres.  Activer cette
	  fonction et r&eacute;gler l'hyst&eacute;resis de
	  lib&eacute;ration de l'espace de pagination (en secondes
	  d'inactivit&eacute;) par l'interm&eacute;diaire des variables
	  <varname>vm.swap_idle_threshold1</varname> et
	  <varname>vm.swap_idle_threshold2</varname>, vous permet de
	  diminuer la priorit&eacute; des pages m&eacute;moire
	  associ&eacute;es avec les processus inactifs plus rapidement
	  qu'avec l'algorithme normal de lib&eacute;ration.  Cela aide le
	  <quote>daemon</quote> de lib&eacute;ration des pages.  N'activez
	  cette option que si vous en besoin, parce que la concession que
	  vous faites est d'utiliser l'espace de pagination pour les pages
	  m&eacute;moire plus t&ocirc;t qu'&agrave; l'accoutum&eacute;,
	  consommant par cons&eacute;quent plus d'espace de pagination et
	  de bande passante disque.  Sur un petit syst&egrave;me, cette
	  option aura un effet limit&eacute; mais dans le cas d'un
	  syst&egrave;me important qui fait appel &agrave; l'espace de
	  pagination de fa&ccedil;on mod&eacute;r&eacute;e, cette option
	  permettra au syst&egrave;me VM de transf&eacute;rer l'ensemble
	  des processus de et vers la m&eacute;moire
	  ais&eacute;ment.</para>
       </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>FreeBSD 4.3 a flirt&eacute; avec la d&eacute;sactivation
	  du cache en &eacute;criture des disques IDE.  Cela r&eacute;duisit la
	  bande passante en &eacute;criture des disques IDE mais fut
	  consid&eacute;r&eacute; comme n&eacute;cessaire en raison de
	  s&eacute;rieux probl&egrave;mes de coh&eacute;rence de
	  donn&eacute;es introduits par les fabricants de disques durs.
	  Le probl&egrave;me est que les disques IDE mentent sur le
	  moment o&ugrave; une &eacute;criture est r&eacute;ellement
	  termin&eacute;e.  Avec le cache en &eacute;criture IDE
	  activ&eacute;, les disques durs IDE non seulement
	  n'&eacute;criront pas les donn&eacute;es dans l'ordre, mais parfois
	  retarderont l'&eacute;criture de certains blocs ind&eacute;finiment
	  sous une charge disque importante.  Un crash ou une coupure
	  secteur pourra &ecirc;tre &agrave; l'origine de
	  s&eacute;rieuses corruptions du syst&egrave;me de fichiers.
	  Par pr&eacute;caution le param&eacute;trage par d&eacute;faut
	  de FreeBSD fut modifi&eacute;.  Malheureusement, le
	  r&eacute;sultat fut une telle perte de performances que nous avons
	  r&eacute;activ&eacute; le cache en &eacute;criture
	  apr&egrave;s cette version de FreeBSD.  Vous devriez
	  contr&ocirc;ler la valeur par
	  d&eacute;faut sur votre syst&egrave;me en examinant la variable
	  sysctl <varname>hw.ata.wc</varname>.  Si le cache en
	  &eacute;criture des disques IDE est d&eacute;sactiv&eacute;,
	  vous pouvez le r&eacute;activer en positionnant la variable
	  &agrave; 1.  Cela doit &ecirc;tre fait &agrave; partir du chargeur au
	  d&eacute;marrage.  Tenter de le faire apr&egrave;s le
	  d&eacute;marrage du noyau n'aura aucun effet.</para>

	<para>Pour plus d'informations, veuillez consulter la page de
	  manuel &man.ata.4;.</para>
      </sect3>

      <sect3>
	<title><literal>SCSI_DELAY</literal>
	(<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm>
	  <primary><literal>SCSI_DELAY</literal></primary>
	  <secondary><varname>kern.cam.scsi_delay</varname></secondary>
	</indexterm>

	<para>L'option de configuration du noyau
	<literal>SCSI_DELAY</literal> peut &ecirc;tre utilis&eacute;e
	pour r&eacute;duire le temps de d&eacute;marrage du
	syst&egrave;me.  Le d&eacute;lai par d&eacute;faut est important
	et peut &ecirc;tre responsable de plus de <literal>15</literal>
	secondes d'attente lors du processus de d&eacute;marrage.
	R&eacute;duire ce d&eacute;lai &agrave; <literal>5</literal>
	secondes est g&eacute;n&eacute;ralement suffisant (tout
	particuli&egrave;rement avec les disques modernes).  Les
	versions de &os; r&eacute;centes (5.0 et suivantes) devraient
	utiliser l'option de d&eacute;marrage
	<varname>kern.cam.scsi_delay</varname>.  Cette option de
	d&eacute;marrage et celle de configuration du noyau acceptent
	des valeurs en <emphasis>millisecondes</emphasis> et <emphasis>non pas</emphasis> en
	<emphasis>secondes</emphasis>.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Les &ldquo;Soft Updates&rdquo;</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Le programme &man.tunefs.8; peut &ecirc;tre utilis&eacute;
	pour r&eacute;gler finement un syst&egrave;me de fichiers.
	Ce programme dispose de nombreuses options diff&eacute;rentes, mais
	pour l'instant nous nous int&eacute;resserons uniquement &agrave;
	l'activation et la d&eacute;sactivation des &ldquo;Soft
	Updates&rdquo;, ce qui fait avec:</para>

      <screen>&prompt.root; tunefs -n enable /filesystem
&prompt.root; tunefs -n disable /filesystem</screen>

      <para>Un syst&egrave;me de fichiers ne peut &ecirc;tre modifi&eacute;
	avec &man.tunefs.8; tant qu'il est mont&eacute;.  Un bon moment pour
	activer les &ldquo;Soft Updates&rdquo; est avant que les
	partitions ne soient mont&eacute;es en mode mono-utilisateur.</para>

      <note><para>Depuis FreeBSD 4.5, il est possible d'activer les
	&ldquo;Soft Updates&rdquo; au moment de la cr&eacute;ation du
	syst&egrave;me de fichiers, avec l'utilisation de l'option
	<literal>-U</literal> de la commande
	&man.newfs.8;.</para></note>

      <para>Les &ldquo;Soft Updates&rdquo; am&eacute;liorent de fa&ccedil;on
	drastique les performances sur les m&eacute;ta-donn&eacute;es,
	principalement la cr&eacute;ation et la suppression de fichier, par
	l'utilisation d'un cache m&eacute;moire.  Nous recommandons d'activer
	les &ldquo;Soft Updates&rdquo; sur tous vos syst&egrave;mes de
	fichiers.  Il y a deux inconv&eacute;nients aux &ldquo;Soft
	Updates&rdquo; que vous devez conna&icirc;tre: tout d'abord, les
	&ldquo;Soft Updates&rdquo; garantissent la coh&eacute;rence du
	syst&egrave;me de fichiers en cas de crash mais pourront facilement
	&ecirc;tre en retard de quelques secondes (voir m&ecirc;me une minute!)
	dans la mise &agrave; jour du disque.  Si votre syst&egrave;me plante
	il se peut que vous perdiez plus de travail que dans d'autres cas.
	Deuxi&egrave;mement, les &ldquo;Soft Updates&rdquo; retardent la
	lib&eacute;ration des blocs du syst&egrave;me de fichiers.  Si vous
	avez un syst&egrave;me de fichiers (comme le syst&egrave;me de
	fichiers racine) qui est presque plein, effectuer une mise &agrave;
	jour majeure, comme un <command>make installworld</command>,
	peut mener &agrave; un manque d'espace sur le syst&egrave;me de
	fichiers et faire &eacute;chouer la mise &agrave; jour.</para>

      <sect3>
	<title>Plus de d&eacute;tails &agrave; propos des
	  &ldquo;Soft Updates&rdquo;</title>

	<indexterm><primary>Soft Updates (D&eacute;tails)</primary></indexterm>

	<para>Il y a deux approches traditionnelles pour &eacute;crire les
	  m&eacute;ta-donn&eacute;es d'un syst&egrave;me de fichiers sur le
	  disque (mise &agrave; jour des m&eacute;ta-donn&eacute;es et mise
	  &agrave; jour des &eacute;l&eacute;ments sans donn&eacute;es
	  comme les inodes ou les r&eacute;pertoires).</para>

	<para>Historiquement, le comportement par d&eacute;faut
	  &eacute;tait d'&eacute;crire les mises &agrave; jour des
	  m&eacute;ta-donn&eacute;es de fa&ccedil;on synchrone.  Si un
	  r&eacute;pertoire a &eacute;t&eacute; modifi&eacute;, le
	  syst&egrave;me attendait jusqu'&agrave; ce que le changement soit
	  effectivement &eacute;crit sur le disque.  Les tampons des
	  donn&eacute;es de fichier (contenu du fichier) passaient par le
	  cache m&eacute;moire et &eacute;taient copi&eacute;s
	  sur le disque plus tard de fa&ccedil;on asynchrone.
	  L'avantage de cette impl&eacute;mentation est
	  qu'elle est effectu&eacute;e sans risque.  S'il y a un
	  probl&egrave;me durant une mise &agrave; jour, les
	  m&eacute;ta-donn&eacute;es sont toujours dans
	  un &eacute;tat consistant.  Un fichier est soit
	  cr&eacute;&eacute; compl&egrave;tement soit pas du tout.  Si les
	  blocs de donn&eacute;es d'un fichier n'ont pas trouv&eacute; leur
	  chemin du cache m&eacute;moire vers le disque au moment du crash,
	  &man.fsck.8; est capable de s'en apercevoir et de r&eacute;parer le
	  syst&egrave;me de fichiers en fixant la taille du fichier &agrave;
	  0.  De plus, l'impl&eacute;mentation est claire et simple.
	  L'inconv&eacute;nient est que la modification des
	  m&eacute;ta-donn&eacute;es
	  est lente.  Un <command>rm -r</command>, par exemple,
	  touche &agrave; tous les fichiers dans un r&eacute;pertoire
	  s&eacute;quentiellement, mais chaque modification du
	  r&eacute;pertoire (effacement d'un fichier) sera &eacute;crite
	  de fa&ccedil;on synchrone sur le disque.
	  Cela comprend les mises &agrave; jour
	  du r&eacute;pertoire lui-m&ecirc;me, de la table des inodes, et
	  &eacute;ventuellement celles sur des blocs indirects allou&eacute;s
	  par le fichier.  Des consid&eacute;rations semblables s'appliquent
	  &agrave; la cr&eacute;ation d'importantes hi&eacute;rarchies
	  ((<command>tar -x</command>).</para>

	<para>Le deuxi&egrave;me cas est la mise &agrave; jour
	  asynchrone des m&eacute;ta-donn&eacute;es.  C'est le comportement
	  par d&eacute;faut de Linux/ext2fs et de l'usage de
	  <command>mount -o async</command> pour l'UFS des syst&egrave;mes
	  BSD.  Toutes les mises &agrave; jour des m&eacute;ta-donn&eacute;es
	  passent &eacute;galement par l'interm&eacute;diaire d'un cache
	  m&eacute;moire, c'est &agrave; dire, qu'elles seront
	  m&eacute;lang&eacute;es
	  aux mises &agrave; jour des donn&eacute;es du contenu du fichier.
	  L'avantage de cette impl&eacute;mentation est qu'il n'y a pas
	  besoin d'attendre jusqu'&agrave; l'&eacute;criture sur le disque
	  de chaque mise &agrave; jour de m&eacute;ta-donn&eacute;es, donc
	  toutes les op&eacute;rations qui sont &agrave; l'origine d'une grande
	  quantit&eacute; de mise &agrave; jour de m&eacute;ta-donn&eacute;es
	  fonctionnent bien plus rapidement que dans le cas synchrone.
	  De plus, l'impl&eacute;mentation est toujours claire et simple, il y
	  a donc peu de risque qu'un bogue se cache dans le code.
	  L'inconv&eacute;nient est qu'il n'y a aucune garantie du tout sur la
	  coh&eacute;rence du syst&egrave;me de fichiers.  S'il y a un
	  probl&egrave;me durant une op&eacute;ration qui met &agrave; jour
	  une grande quantit&eacute; de m&eacute;ta-donn&eacute;es
	  (comme une coupure secteur, ou quelqu'un appuyant sur le
	  bouton reset), le syst&egrave;me de fichiers sera laiss&eacute;
	  dans un &eacute;tat impr&eacute;visible.  Il n'y a aucune
	  opportunit&eacute; d'examiner l'&eacute;tat du syst&egrave;me
	  de fichiers quand le syst&egrave;me est &agrave; nouveau relanc&eacute;;
	  les blocs de donn&eacute;es d'un fichier pourraient
	  d&eacute;j&agrave; avoir &eacute;t&eacute; inscrits sur
	  le disque alors que la mise &agrave; jour de la table des inodes
	  ou du r&eacute;pertoire associ&eacute; n'a pas
	  &eacute;t&eacute; faite.  Il est en fait impossible
	  d'impl&eacute;menter un <command>fsck</command>
	  qui est capable de nettoyer le chaos r&eacute;sultant (parce que
	  l'information n&eacute;cessaire n'est pas disponible sur le
	  disque).  Si le syst&egrave;me de fichiers a &eacute;t&eacute;
	  endommag&eacute; irr&eacute;m&eacute;diablement, le seul choix est
	  de le recr&eacute;er avec &man.newfs.8; et de
	  r&eacute;cup&eacute;rer les donn&eacute;es &agrave; partir
	  de sauvegardes.</para>

	<para>La solution commune pour ce probl&egrave;me fut
	  d'impl&eacute;menter une <emphasis>r&eacute;gion de
	  trace</emphasis>, dont
	  on fait souvent r&eacute;f&eacute;rence sous le terme de
	  <emphasis>journalisation</emphasis>, bien que ce terme ne
	  soit pas toujours utilis&eacute; de fa&ccedil;on
	  coh&eacute;rente et est occasionnellement utilis&eacute;
	  pour d'autres formes de transaction avec trace.  Les mises &agrave;
	  jour des m&eacute;ta-donn&eacute;es sont toujours &eacute;crites
	  de fa&ccedil;on synchrone, mais seulement sur une petite r&eacute;gion
	  du disque.  Elles seront plus tard d&eacute;plac&eacute;es vers
	  leur emplacement correct.  Parce que la r&eacute;gion de trace
	  est une petite r&eacute;gion contigu&euml; sur le disque,
	  il n'y a pas de grandes distances de d&eacute;placement
	  pour les t&ecirc;tes des disques, m&ecirc;me durant
	  les op&eacute;rations importantes, donc ces op&eacute;rations
	  sont plus rapides que les mises &agrave; jour synchrones.
	  De plus la complexit&eacute; de l'impl&eacute;mentation
	  est relativement
	  limit&eacute;e, donc le risque de pr&eacute;sence de bogues est
	  faible. Un inconv&eacute;nient est que toutes les
	  m&eacute;ta-donn&eacute;es sont &eacute;crites deux fois (une fois
	  dans la r&eacute;gion de trace et une fois sur l'emplacement
	  correct) donc pour un fonctionnement normal, une baisse
	  des performances pourra en r&eacute;sulter.  D'autre part,
	  dans le cas d'un crash, toutes les op&eacute;rations sur les
	  m&eacute;ta-donn&eacute;es en attente peuvent rapidement
	  &ecirc;tre annul&eacute;es ou compl&eacute;t&eacute;es
	  &agrave; partir de la zone de trace apr&egrave;s le
	  red&eacute;marrage du syst&egrave;me, ayant pour
	  r&eacute;sultat un d&eacute;marrage rapide du
	  syst&egrave;me de fichiers.</para>

	<para>Kirk McKusick, le d&eacute;veloppeur du FFS de Berkeley,
	  a r&eacute;solu le probl&egrave;me avec les
	  &ldquo;Soft Updates&rdquo;:
	  toutes les mises &agrave; jour des m&eacute;ta-donn&eacute;es sont
	  conserv&eacute;es en m&eacute;moire et inscrites sur le disque
	  selon une s&eacute;quence ordonn&eacute;e (&ldquo;mise
	  &agrave; jour ordonn&eacute;e des m&eacute;ta-donn&eacute;es&rdquo;).
	  Ceci a pour effet, dans le cas d'un nombre d'op&eacute;rations
	  sur les m&eacute;ta-donn&eacute;es important, que les
	  derni&egrave;res mises &agrave; jour sur un &eacute;l&eacute;ment
	  &ldquo;attrapent&rdquo; les premi&egrave;res si ces
	  derni&egrave;res sont encore en m&eacute;moire et n'ont pas
	  encore &eacute;t&eacute; inscrites sur le disque.  Donc toutes
	  les op&eacute;rations sur, par exemple, un r&eacute;pertoire sont
	  g&eacute;n&eacute;ralement effectu&eacute;es en
	  m&eacute;moire avant que la mise &agrave; jour ne soit
	  &eacute;crite sur le disque (les blocs de donn&eacute;es
	  sont ordonn&eacute;s en fonction de leur position de
	  sorte &agrave; ce qu'ils ne soient pas sur le disque avant leur
	  m&eacute;ta-donn&eacute;es).  Si le syst&egrave;me
	  crash, cela provoque un &ldquo;retour dans les traces&rdquo;
	  implicite: toutes les op&eacute;rations qui n'ont pas
	  trouv&eacute; leur chemin vers le disque apparaissent comme si
	  elles n'avaient jamais exist&eacute;.  Un &eacute;tat
	  coh&eacute;rent du syst&egrave;me de fichiers est maintenu et
	  appara&icirc;t comme &eacute;tant celui de 30 ou 60 secondes
	  plus t&ocirc;t.  L'algorithme utilis&eacute; garantie que toutes les
	  ressources utilis&eacute;es soient marqu&eacute;es
	  avec leur bons &ldquo;bitmaps&rdquo;: blocs et inodes.
	  Apr&egrave;s un crash, les seules erreurs d'allocation de
	  ressources qui apparaissent sont les ressources qui ont
	  &eacute;t&eacute; marqu&eacute;es comme
	  &ldquo;utilis&eacute;es&rdquo; et qui sont en fait
	  &rdquo;libre&rdquo;.  &man.fsck.8; reconna&icirc;t cette
	  situation, et lib&egrave;re les ressources qui ne sont plus
	  utilis&eacute;es.  On peut ignorer sans risque l'&eacute;tat
	  &ldquo;sale&rdquo; d'un syst&egrave;me de fichiers apr&egrave;s un
	  crash en for&ccedil;ant son montage avec <command>mount
	  -f</command>.  Afin de lib&eacute;rer les ressources qui peuvent
	  &ecirc;tre inutilis&eacute;es, &man.fsck.8; doit
	  &ecirc;tre ex&eacute;cut&eacute; plus tard.
	  C'est l'id&eacute;e qu'il y a derri&egrave;re le
	  &ldquo;<emphasis>background fsck</emphasis>&rdquo; (fsck en
	  t&acirc;che de fond): au d&eacute;marrage du syst&egrave;me, seule
	  un &ldquo;<emphasis>snapshot</emphasis>&rdquo; (photographie)
	  du syst&egrave;me de fichiers est prise.  La commande
	  <command>fsck</command> peut &ecirc;tre
	  ex&eacute;cut&eacute;e plus tard sur ce syst&egrave;me de
	  fichiers.  Tous les syst&egrave;mes de fichiers peuvent
	  &ecirc;tre mont&eacute;s &ldquo;sales&rdquo;, donc le
	  syst&egrave;me passe en
	  mode multi-utilisateurs.  Ensuite, les
	  <command>fsck</command> en t&acirc;che de fond seront
	  programm&eacute;s pour tous les syst&egrave;mes de fichiers pour
	  lesquels c'est n&eacute;cessaire, pour lib&eacute;rer les ressources
	  qui peuvent &ecirc;tre inutilis&eacute;es (les syst&egrave;mes
	  qui n'utilisent pas les &lsquo;Soft Updates&rdquo; ont
	  toujours besoin du <command>fsck</command>
	  en avant plan).</para>

	<para>L'avantage est que les op&eacute;rations sur les
	  m&eacute;ta-donn&eacute;es sont presque aussi rapides que les
	  mises &agrave; jour asynchrones (i.e. plus rapide qu'avec le
	  &ldquo;<emphasis>logging</emphasis>&rdquo; - tra&ccedil;age,
	  qui doit &eacute;crire les m&eacute;ta-donn&eacute;es deux
	  fois).  Les inconv&eacute;nients sont la complexit&eacute; du code
	  (impliquant un haut risque de bogues dans une zone qui est
	  hautement sensible en raison de risque perte de donn&eacute;es
	  utilisateur), et une plus grande consommation en m&eacute;moire.
	  De plus il y a quelques particularit&eacute;s que l'on peut
	  rencontrer lors de l'utilisation.  Apr&egrave;s un crash,
	  l'&eacute;tat du syst&egrave;me appara&icirc;t &ecirc;tre en quelque
	  sorte &ldquo;plus vieux&rdquo;.  Dans des situations
	  o&ugrave; l'approche synchrone classique aurait donn&eacute; lieu
	  &agrave; des fichiers de taille nulle restant apr&egrave;s le
	  <command>fsck</command>, ces fichiers n'existent pas du
	  tout avec un syst&egrave;me de fichiers utilisant les
	  &ldquo;Soft Updates&rdquo; parce que ni les
	  m&eacute;ta-donn&eacute;es ni les contenus de fichiers n'ont
	  jamais &eacute;t&eacute; inscrits sur le disque.  L'espace disque
	  n'est pas rendu tant que les mises &agrave; jour n'ont pas
	  &eacute;t&eacute; inscrites sur le disque, ce qui peut se produire
	  quelques temps apr&egrave;s l'ex&eacute;cution de
	  <command>rm</command>.  Cela peut &ecirc;tre &agrave;
	  l'origine de probl&egrave;mes quand on installe une grande
	  quantit&eacute; de donn&eacute;es sur un syst&egrave;me de fichiers
	  qui ne dispose pas de suffisamment d'espace pour contenir tous les
	  fichiers deux fois.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Param&eacute;trer les limitations du noyau</title>

    <indexterm><primary>Param&eacute;trer les limitations du noyau</primary></indexterm>

    <sect2 id="file-process-limits">
      <title>Limitations sur les fichiers et les processus</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>

	<para>Le param&egrave;tre <varname>kern.maxfiles</varname>
	  peut &ecirc;tre augment&eacute; ou diminu&eacute;
	  en fonction des besoins du syst&egrave;me.  Cette variable
	  indique le nombre maximal de descripteurs de fichier sur
	  votre syst&egrave;me.  Quand la table de descripteurs de fichier
	  est pleine, le message <errorname>file: table is
	  full</errorname> s'affichera r&eacute;guli&egrave;rement dans le
	  tampon des messages syst&egrave;me, qui peut &ecirc;tre
	  visualis&eacute; avec la commande
	  <command>dmesg</command>.</para>

	<para>Chaque fichier ouvert, chaque &ldquo;socket&rdquo;,
	  ou chaque emplacement en pile utilise un descripteur de fichier.
	  Un serveur important peut facilement demander plusieurs
	  milliers de descripteurs de fichiers, en fonction du type et
	  du nombre de services s'ex&eacute;cutant en m&ecirc;me temps.</para>

	<para>La valeur par d&eacute;faut de <varname>kern.maxfile</varname>
	  est fix&eacute;e par l'option <option>MAXUSERS</option>
	  dans votre fichier de configuration du noyau.
	  <varname>kern.maxfiles</varname> augmente proportionnellement
	  avec la valeur de <option>MAXUSERS</option>.  Quand vous
	  compilez un noyau sur mesure, il est bon de param&eacute;trer cette
	  option en fonction de l'utilisation de votre syst&egrave;me.  Ce
	  nombre fixe la plupart des limites pr&eacute;-d&eacute;finies du
	  noyau.
	  M&ecirc;me si une machine de production pourra ne pas avoir en
	  r&eacute;alit&eacute; 256 utilisateurs connect&eacute;s
	  simultan&eacute;ment, les ressources requises pourront &ecirc;tre
	  semblables pour un serveur web important.</para>

	<note><para>A partir de FreeBSD 4.5, positionner
	  <option>MAXUSERS</option> &agrave; <literal>0</literal> dans votre
	  fichier de configuration du noyau, le syst&egrave;me choisira une
	  valeur raisonnable par d&eacute;faut bas&eacute;e sur la
	  quantit&eacute; de m&eacute;moire pr&eacute;sente sur votre
	  syst&egrave;me.</para></note>
      </sect3>

      <sect3>
	<title><varname>kern.ipc.somaxconn</varname></title>

	<indexterm>
	  <primary><varname>kern.ipc.somaxconn</varname></primary>
	</indexterm>

	<para>La variable sysctl <varname>kern.ipc.somaxconn</varname>
	  limite la taille de la file d'attente acceptant les
	  nouvelles connexions TCP.  La valeur par d&eacute;faut de
	  <literal>128</literal> est g&eacute;n&eacute;ralement trop
	  faible pour une gestion robuste des nouvelles connexions
	  dans un environement de serveur web tr&egrave;s
	  charg&eacute;.  Pour de tels environnements, il est
	  recommand&eacute; d'augmenter cette valeur &agrave;
	  <literal>1024</literal> ou plus.  Le <quote>daemon</quote>
	  en service peut de lui-m&ecirc;me limiter la taille de la
	  file d'attente (e.g. &man.sendmail.8;, ou
	  <application>Apache</application>) mais disposera, la
	  plupart du temps, d'une directive dans son fichier de
	  configuration pour ajuster la taille de la file d'attente.
	  Les files d'attentes de grandes tailles sont plus
	  adapt&eacute;es pour &eacute;viter les attaques par
	  d&eacute;ni de service (<abbrev>DoS</abbrev>).</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Limitations r&eacute;seau</title>

      <para>L'literal du noyau <literal>NMBCLUSTERS</literal> fixe la
	quantit&eacute; de <quote>Mbuf</quote>;s disponibles pour le
	syst&egrave;me.  Un serveur &agrave; fort trafic avec un nombre faible
	de <quote>Mbuf</quote>;s sous-emploiera les capacit&eacute;s de FreeBSD.
	Chaque &ldquo;cluster&rdquo; repr&eacute;sente approximativement 2&nbsp;Ko
	de m&eacute;moire, donc une valeur de 1024 repr&eacute;sente 2
	m&eacute;gaoctets de m&eacute;moire noyau r&eacute;serv&eacute;e
	pour les tampons r&eacute;seau.  Un simple calcul peut
	&ecirc;tre fait pour d&eacute;terminer combien sont
	n&eacute;cessaires.  Si vous avez un serveur web qui culmine &agrave;
	1000 connexions simultan&eacute;es, et que chaque connexion
	consomme un tampon de r&eacute;ception de 16Ko et un tampon
	d'&eacute;mission de 16&nbsp;Ko, vous avez approximativement besoin
	de 32&nbsp;Mo de tampon r&eacute;seau pour couvrir les besoin du
	serveur web.  Un bon principe est de multiplier ce nombre
	par 2, soit 2x32&nbsp;Mo / 2&nbsp;Ko = 64&nbsp;Mo / 2&nbsp;Ko =32768.
	Nous recommendons des valeurs comprises entre 4096 et 32768
	pour les machines avec des quantit&eacute;s de m&eacute;moire
	plus &eacute;lev&eacute;es.  Vous ne devriez, dans aucun
	circonstance, sp&eacute;cifier de valeur &eacute;lev&eacute;e
	arbitraire pour ce param&egrave;tre &eacute;tant donn&eacute;
	que cela peut &ecirc;tre &agrave; l'origine d'un plantage au
	d&eacute;marrage.  L'option <option>-m</option> de
	&man.netstat.1; peut &ecirc;tre utilis&eacute;e pour observer
	l'utilisation des <quote>clusters</quote>.</para>

      <para>La variable <varname>kern.ipc.nmbclusters</varname>
	configurable au niveau du chargeur est utilis&eacute;e pour
	ajuster cela au d&eacute;marrage.  Seules les anciennes
	versions de &os; vous demanderont d'utiliser l'option de
	configuration du noyau <literal>NMBCLUSTERS</literal>.</para>

      <para>Pour les serveurs charg&eacute;s qui font une utilisation
	intensive de l'appel syst&egrave;me &man.sendfile.2;, il peut
	&ecirc;tre n&eacute;cessaire d'augmenter le nombre de tampons
	&man.sendfile.2; par l'interm&eacute;diaire de l'option de
	configuration du noyau <literal>NSFBUFS</literal> ou en fixant
	sa valeur dans le fichier
	<filename>/boot/loader.conf</filename> (consultez la page de
	manuel &man.loader.8; pour plus de d&eacute;tails).  Un
	indicateur de la n&eacute;cessit&eacute; d'ajuster ce
	param&egrave;tre est lorsque des processus sont dans
	l'&eacute;tat <literal>sfbufa</literal>.  La variable sysctl
	<varname>kern.ipc.nsfbufs</varname> est un aper&ccedil;u en
	lecture seule de la variable du noyau.  Ce param&egrave;tre
	s'ajuste de fa&ccedil;on optimale avec
	<varname>kern.maxusers</varname>, il peut &ecirc;tre cependant
	n&eacute;cessaire de l'ajuster en fonction des besoins.</para>

      <important>
	<para>M&ecirc;me si une <quote>socket</quote> a
	  &eacute;t&eacute; marqu&eacute;e comme &eacute;tant
	  non-bloquante, un appel de &man.sendfile.2; sur la
	  <quote>socket</quote> non-bloquante peut r&eacute;sulter en un
	  blocage de l'appel &man.sendfile.2; jusqu'&agrave; ce que
	  suffisament de <literal>struct sf_buf</literal> soient
	  lib&eacute;r&eacute;es.</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm>
	  <primary>net.inet.ip.portrange.*</primary>
	</indexterm>

	<para>Les variables <varname>net.inet.ip.portrange.*</varname>
	  contr&ocirc;lent les intervalles de ports automatiquement
	  allou&eacute;s aux <quote>socket</quote>s TCP et UDP.  Il y
	  a trois intervalles: un intervalle bas, un intervalle par
	  d&eacute;faut, et intervalle un haut.  La plupart des
	  programmes r&eacute;seau utilisent l'intervalle par
	  d&eacute;faut qui est contr&ocirc;l&eacute; par
	  <varname>net.inet.ip.portrange.first</varname> et
	  <varname>net.inet.ip.portrange.last</varname>, qui ont pour
	  valeur par d&eacute;faut respectivement 1024 et 5000.  Ces
	  intervalles de ports sont utilis&eacute;s pour les
	  connexions sortantes, et il est possible de se trouver
	  &agrave; court de ports dans certaines conditions.  Cela
	  arrive le plus souvent quand votre syst&egrave;me fait
	  tourner un proxy web tr&egrave;s charg&eacute;.
	  L'intervalle de ports n'est pas un probl&egrave;me quand
	  vous ex&eacute;cutez des serveurs qui ne g&egrave;rent
	  principalement que des connexions entrantes, comme un server
	  web classique, ou qui ont un nombre de connexions sortantes
	  limit&eacute;es comme un relai de messagerie.  Pour les cas
	  o&ugrave; vous risquez d'&ecirc;tre &agrave; court de ports,
	  il est recommand&eacute; d'augmenter
	  l&eacute;g&egrave;rement
	  <varname>net.inet.ip.portrange.last</varname>.  Une valeur
	  de <literal>10000</literal>, <literal>20000</literal> ou
	  <literal>30000</literal> doit &ecirc;tre suffisante.  Vous
	  devriez &eacute;galement penser au probl&egrave;me du
	  coupe-feu lors du changement de l'intervalle des ports.
	  Certains coupes-feu peuvent bloquer de grands intervalles de
	  ports (en g&eacute;n&eacute;ral les ports inf&eacute;rieurs)
	  et s'attendent &agrave; ce que les syst&egrave;mes utilisent
	  les intervalles sup&eacute;rieurs pour les connexions
	  sortantes &mdash; pour cette raison il est conseill&eacute;
	  de diminuer
	  <varname>net.inet.ip.portrange.first</varname>.</para>
      </sect3>

      <sect3>
	<title>Le produit d&eacute;lai-bande passante TCP</title>

	<indexterm>
	  <primary>limitation du produit d&eacute;lai-bande passante
	    TCP</primary>
	  <secondary><varname>net.inet.tcp.inflight_enable</varname></secondary>
	</indexterm>

	<para>La limitation du produit d&eacute;lai-bande passante TCP
	  est semblable au TCP/Vegas sous NetBSD.  Elle peut
	  &ecirc;tre activ&eacute;e en positionnant &agrave;
	  <literal>1</literal> la variable
	  <varname>net.inet.tcp.inflight_enable</varname>.  Le
	  syst&egrave;me tentera alors de calculer le produit
	  d&eacute;lai-bande passante pour chaque connexion et
	  limitera la quantit&eacute; de donn&eacute;es en attente
	  &agrave; la quantit&eacute; juste n&eacute;cessaire au
	  maintient d'un flux de sortie optimal.</para>

	<para>Cette fonctionnalit&eacute; est utile si vous diffusez
	  des donn&eacute;es par l'interm&eacute;diare de modems, de
	  connexions Ethernet Gigabit, ou m&ecirc;me de liaisons hauts
	  d&eacute;bits WAN (ou toute autre liaison avec un produit
	  d&eacute;lai-bande passante &eacute;lev&eacute;), tout
	  particuli&egrave;rement si vous utilisez &eacute;galement le
	  dimensionnement des fen&ecirc;tres d'&eacute;mission ou que
	  vous avez configur&eacute; une fen&ecirc;tre
	  d'&eacute;mission importante.  Si vous activez cette option,
	  vous devriez &eacute;galement vous assurer que
	  <varname>net.inet.tcp.inflight_debug</varname> est
	  positionn&eacute;e &agrave; <literal>0</literal>
	  (d&eacute;sactive le d&eacute;bogage), et pour une
	  utilisation en production, fixer
	  <varname>net.inet.tcp.inflight_min</varname> &agrave; au
	  moins <literal>6144</literal> peut &ecirc;tre
	  b&eacute;n&eacute;fique.  Notez, cependant,  que fixer des
	  minimas &eacute;lev&eacute;s peut d&eacute;sactiver la
	  limitation de bande passante selon la liaison.  La fonction
	  de limitation diminue la quantit&eacute; de donn&eacute;es
	  accumul&eacute;es dans les files d'attente
	  interm&eacute;diaire de routage et de commutation, et
	  diminue &eacute;galement la quantit&eacute; de
	  donn&eacute;es pr&eacute;sentes dans les files d'attente de
	  l'interface de la machine locale.  Avec moins de paquets
	  dans les files d'attente, les connexions interactives, tout
	  particuli&egrave;rement sur des modems lents, seront en
	  mesure de fonctionner avec des <emphasis>temps
	  d'aller-retour</emphasis> plus faible.  Mais cette
	  fonctionnalit&eacute; n'affecte que la transmission de
	  donn&eacute;es (transmission c&ocirc;t&eacute; serveur).
	  Ceci n'a aucun effet sur la r&eacute;ception de
	  donn&eacute;es (t&eacute;l&eacute;chargement).
	</para>

	<para>Modifier <varname>net.inet.tcp.inflight_stab</varname>
	  n'est <emphasis>pas</emphasis> recommand&eacute;.  Ce
	  param&egrave;tre est fix&eacute; par d&eacute;faut &agrave;
	  la valeur 20, repr&eacute;sentant au maximum 2 paquets
	  ajout&eacute;s &agrave; la fen&ecirc;tre de calcul du
	  produit d&eacute;lai-bande passante.  La fen&ecirc;tre
	  suppl&eacute;mentaire est n&eacute;cessaire pour stabiliser
	  l'algorithme et am&eacute;liorer la r&eacute;ponse aux
	  changements de conditions, mais il peut en r&eacute;sulter
	  des temps de <quote>ping</quote> plus &eacute;lev&eacute;s
	  sur les liaisons lentes (mais cependant inf&eacute;rieurs
	  &agrave; ce que vous obtiendriez sans l'algorithme de
	  limitation).  Dans de tels cas, vous pouvez essayer de
	  r&eacute;duire ce param&egrave;tre &agrave; 15, 10, ou 5, et
	  vous pouvez avoir &agrave; r&eacute;duire le
	  param&egrave;tre
	  <varname>net.inet.tcp.inflight_min</varname> (par exemple
	  &agrave; 3500) pour obtenir l'effet d&eacute;sir&eacute;.
	  Ces param&egrave;tres ne doivent &ecirc;tre r&eacute;duits
	  qu'en dernier ressort.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Ajouter de l'espace de pagination</title>

    <para>Peu importe comment vous l'avez pens&eacute;, parfois un
      syst&egrave;me ne fonctionne pas comme pr&eacute;vu.  Si vous
      trouvez que vous avez besoin de plus d'espace de pagination, il
      est assez simple d'en rajouter.  Vous avez trois mani&egrave;res
      d'augmenter votre espace de pagination: ajouter un nouveau
      disque dur, activer la pagination sur NFS, et cr&eacute;er un fichier
      de pagination sur une partition existante.</para>

    <sect2 id="new-drive-swap">
      <title>Espace de pagination sur un nouveau disque dur</title>

      <para>La meilleur fa&ccedil;on d'ajouter de l'espace de pagination,
	bien s&ucirc;r, est d'utiliser ceci comme excuse pour ajouter un
	autre disque dur.  Vous pouvez toujours utiliser un autre
	disque apr&egrave;s tout.  Si vous pouvez faire cela, allez relire la
	discussion sur <ulink
	url="configtuning-initial.html#SWAP-DESIGN">l'espace de
	pagination</ulink> dans la section <ulink
	url="configtuning-initial.html">Configuration initiale</ulink>
	du Manuel pour des suggestions sur la meilleure fa&ccedil;on
	d'arranger votre espace de pagination.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Espace de pagination sur NFS</title>

      <para>L'espace de pagination sur NFS n'est recommand&eacute; que si
	vous n'avez pas de disque dur local sur lequel avoir l'espace
	de pagination.  Avoir son espace de pagination sur NFS sera
	lent et inefficace sur les versions de FreeBSD ant&eacute;rieures
	&agrave; la branche 4.X.  c'est raisonnablement rapide et efficace
	sur 4.0-RELEASE et suivante.  M&ecirc;me avec une version
	r&eacute;cente de FreeBSD, la pagination sur NFS sera limit&eacute;e
	par la bande passante du r&eacute;seau et sera un fardeau
	suppl&eacute;mentaire pour le serveur NFS.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>Fichiers de pagination</title>

      <para>Vous pouvez cr&eacute;er un fichier d'une taille
	sp&eacute;cifique pour	l'utiliser comme fichier de pagination.
	Dans notre exemple nous utiliserons un fichier de 64MO appel&eacute;
	<filename>/usr/swap0</filename>.  Vous pouvez, bien s&ucirc;r,
	utiliser le nom de votre choix.</para>

      <example>
        <title>Cr&eacute;er un fichier de pagination sous FreeBSD&nbsp;4.X</title>

      <orderedlist>
        <listitem>
          <para>Soyez s&ucirc;r que votre configuration de noyau inclut le
	    pilote vnode.  Ce n'est <emphasis>pas</emphasis> le cas dans
	    les versions r&eacute;centes de
	    <filename>GENERIC</filename>.</para>

          <programlisting>pseudo-device   vn 1   #Vnode driver (turns a file into a device)</programlisting>
        </listitem>

	<listitem>
	  <para>Cr&eacute;ez un p&eacute;riph&eacute;rique vn:</para>
	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Cr&eacute;ez un fichier de pagination
	    (<filename>/usr/swap0</filename>):</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	</listitem>

	<listitem>
	  <para>Fixez les bonnes permissions sur
	    <filename>/usr/swap0</filename>:</para>

	  <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Activez le fichier de pagination dans
	    <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	</listitem>

	<listitem>

          <para>Red&eacute;marrez la machine ou activez directement le
	    fichier de pagination:</para>

          <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
        </listitem>
      </orderedlist>

      </example>
      <example>
	<title>Cr&eacute;er un fichier de pagination sous FreeBSD&nbsp;5.X</title>

      <orderedlist>
	<listitem>
	  <para>Assurez-vous que votre configuration de noyau inclut
	    le pilote de disque m&eacute;moire (&man.md.4;).  Il se
	    trouve par d&eacute;faut dans le noyau
	    <filename>GENERIC</filename>.</para>

	  <programlisting>device   md   # Memory "disks"</programlisting>
	</listitem>

	<listitem>
	  <para>Cr&eacute;ez un fichier de pagination
	    (<filename>/usr/swap0</filename>):</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	</listitem>

	<listitem>
	  <para>Fixez les bonnes permissions sur
	    <filename>/usr/swap0</filename>:</para>

	  <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Activez le fichier de pagination dans
	    <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	</listitem>

	<listitem>

	  <para>Red&eacute;marrez la machine ou activez directement le
	    fichier de pagination:</para>

	  <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 && swapon /dev/md0</userinput></screen>
        </listitem>
      </orderedlist>

      </example>
    </sect2>

  <sect1 id="acpi-overview">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Hiten</firstname>
	  <surname>Pandya</surname>
	  <contrib>Ecrit par </contrib>
	</author>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>ACPI et FreeBSD</title>

    <para>Il est vraiment important d'utiliser les ressources
      mat&eacute;rielles d'une mani&egrave;re efficace.  Avant
      l'apparition de l'<acronym>ACPI</acronym>, il &eacute;tait
      tr&egrave;s difficile pour les syst&egrave;mes d'exploitation de
      g&eacute;rer l'utilisation de l'alimentation et la temp&eacute;rature
      d'un syst&egrave;me.  Le mat&eacute;riel &eacute;tait soit
      contr&ocirc;l&eacute; par certaines interfaces du
      <acronym>BIOS</acronym>, i.e.: le syst&egrave;me
      <emphasis>Plug and Play BIOS (PNPBIOS)</emphasis>,
      l'<emphasis>Advanced Power Management (APM)</emphasis> et ainsi
      de suite.  La gestion de l'&eacute;nergie et des ressources est un
      des &eacute;l&eacute;ments cl&eacute;s d'un syst&egrave;me
      d'exploitation moderne.  Par exemple, vous pourrez vouloir qu'un
      syst&egrave;me d'exploitation surveille certaines limites (et
      prenne eventuellement des mesures), au cas o&ugrave; la
      temp&eacute;rature de votre syst&egrave;me augmente de fa&ccedil;on
      inattendue.</para>

    <para>Dans cette section,  nous fournirons une information
      compl&egrave;te au sujet de l'<acronym>ACPI</acronym>.  Il sera
      fait r&eacute;f&eacute;rence &agrave; des documents
      suppl&eacute;mentaires en fin de section pour plus de
      d&eacute;tails.  Soyez conscient que l'<acronym>ACPI</acronym>
      n'est disponible que sur les syst&egrave;mes FreeBSD&nbsp;5.X et
      suivants.</para>

    <sect2 id="acpi-intro">
      <title>Qu'est-ce que l'ACPI?</title>

      <para>L'&ldquo;Advanced Configuration and Power Interface&rdquo;
	(<acronym>ACPI</acronym>) est une norme cr&eacute;&eacute;e
	par un ensemble de constructeurs pour fournir une interface
	standard &agrave; la gestion des ressources et de l'&eacute;nergie.
	C'est un &eacute;l&eacute;ment cl&eacute; dans le contr&ocirc;le
	et la configuration par le syst&egrave;me d'exploitation de
	de la gestion d'&eacute;nergie, i.e., il permet plus de contr&ocirc;le
	et flexibilit&eacute; au syst&egrave;me d'exploitation.  Les
	syst&egrave;mes modernes ont &ldquo;repouss&eacute;&rdquo; les limites
	des interfaces &ldquo;Plug and Play&rdquo; actuelles (comme
	l'APM, qui est utilis&eacute; sous FreeBSD&nbsp;4.X), avant
	l'apparition de l'<acronym>ACPI</acronym>.
	L'<acronym>ACPI</acronym> est le descendant direct de
	l'<acronym>APM</acronym> (Advanced Power Management - gestion
	avanc&eacute;e de l'&eacute;nergie).</para>

    <sect2 id="acpi-config">
      <title>Configurer l'<acronym>ACPI</acronym></title>
      
      <para>Le pilote <filename>acpi.ko</filename> est par d&eacute;faut
	charg&eacute; par le &man.loader.8; au d&eacute;marrage et ne devrait
	<emphasis>pas</emphasis> &ecirc;tre compil&eacute; dans
	le noyau.  La raison derri&egrave;re cela est que les modules
	sont plus facile &agrave; manipuler, par exemple pour passer &agrave;
	une autre version du module <filename>acpi.ko</filename> sans
	avoir &agrave; recompiler le noyau.  Cela pr&eacute;sente l'avantage
	de rendre les tests ais&eacute;s.  Une autre raison est que lancer
	l'<acronym>ACPI</acronym> apr&egrave;s qu'un syst&egrave;me ait
	termin&eacute; son lancement n'est pas tr&egrave;s utile, et dans
	certain cas peut m&ecirc;me &ecirc;tre fatal.  Dans le doute,
	d&eacute;sactiver l'<acronym>ACPI</acronym>.  Ce pilote ne devrait
	et ne peut &ecirc;tre d&eacute;charg&eacute; car le bus
	syst&egrave;me l'utilise pour diff&eacute;rentes
	int&eacute;raction avec le mat&eacute;riel.
	L'<acronym>ACPI</acronym> peut &ecirc;tre d&eacute;activ&eacute;
	avec l'utilitaire &man.acpiconf.8;.  En fait la plupart des
	interactions avec <acronym>ACPI</acronym> peuvent &ecirc;tre
	effectu&eacute;es via &man.acpiconf.8;.  A la base cela signifie
	que si quelque chose en rapport avec l'<acronym>ACPI</acronym>
	appara&icirc;t dans la sortie de &man.dmesg.8;, alors c'est
	d&eacute;j&agrave; en fonctionnement.</para>

      <note>
	<para>L'<acronym>ACPI</acronym> et l'<acronym>APM</acronym>
	  ne peuvent co&eacute;xister et devraient &ecirc;tre utilis&eacute;
	  s&eacute;par&eacute;ment.  Le dernier charg&eacute;
	  s'arr&ecirc;tera s'il d&eacute;tecte l'autre en
	  focntionnement.</para>
      </note>

      <para>Dans sa plus simple forme, l'<acronym>ACPI</acronym> peut
	&ecirc;tre utilis&eacute; pour mettre en veille un syst&egrave;me avec
	&man.acpiconf.8;, les options <option>-s</option> et
	<literal>1-5</literal>.  La plupart des utilisateurs n'auront
	besoin que de <literal>1</literal>.  L'option
	<literal>5</literal> provoquera un arr&ecirc;t de l'alimentation
	par logiciel, effet identique &agrave; un:</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>
      
      <para>D'autres options sont disponibles.  Consultez la page de
	manuel d'&man.acpiconf.8; pour plus d'informations.</para>
    </sect2>

    <sect2 id="acpi-debug">
      <title>D&eacute;boguage de l'<acronym>ACPI</acronym></title>

      <para>Presque tout dans l'<acronym>ACPI</acronym> est transparent,
	jusqu'au moment o&ugrave; cela ne fonctionne plus.  C'est en
	g&eacute;n&eacute;ral &agrave; ce moment o&ugrave; vous en tant
	qu'utilisateur saurez que quelque chose ne fonctionne pas
	correctement.</para>

    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
