<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     $Id: chapter.sgml,v 1.3 2002-09-11 19:05:15 blackend Exp $
     Original revision: 1.55
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Ecrit par </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
        <firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Bas&eacute; sur un guide r&eacute;dig&eacute;
	  par </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
        <firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Egalement bas&eacute; sur la page de manuel tuning(7)
	  &eacute;crite par </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Configuration et optimisation</title>
  &trans.a.fonvieille;

  <sect1>
    <title>Synopsis</title>

    <indexterm><primary>configuration/optimisation du
      syst&egrave;me</primary></indexterm>

    <para>La configuration correcte d'un syst&egrave;me peut sensiblement
      r&eacute;duire la quantit&eacute; de travail impliqu&eacute;e
      dans la maintenance et la mise &agrave; jour.  Ce chapitre
      d&eacute;crit certains des aspects de la configuration des
      syst&egrave;mes FreeBSD.</para>

    <para>Ce chapitre d&eacute;crira &eacute;galement certains
      param&egrave;tres qui peuvent &ecirc;tre modifi&eacute;s
      pour configurer un syst&egrave;me FreeBSD pour des performances
      optimales.</para>

    <para>Apr&egrave;s la lecture de ce chapitre, vous saurez:</para>

    <itemizedlist>
      <listitem>
	<para>Pourquoi et comment dimensionner, organiser, et
	  positionner efficacement les partitions des syst&egrave;mes
	  de fichiers et de pagination sur votre disque dur.</para>
      </listitem>
      <listitem>
	<para>Les bases de la configuration du fichier
	  <filename>rc.conf</filename> et des fichiers de d&eacute;marrage
	  <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>
      <listitem>
	<para>Comment configurer des h&ocirc;tes virtuels sur vos
	  p&eacute;riph&eacute;riques r&eacute;seau.</para>
      </listitem>
      <listitem>
	<para>Comment utiliser les divers fichiers de configuration du
	  r&eacute;pertoire <filename>/etc</filename>.</para>
      </listitem>
      <listitem>
        <para>Comment optimiser FreeBSD en utilisant les variables
	  <command>sysctl</command>.</para>
      </listitem>
      <listitem>
	<para>Comment optimiser les performances des disques et
	  modifier les limitations du noyau.</para>
      </listitem>
    </itemizedlist>

    <para>Avant de lire ce chapitre, vous devrez:</para>

    <itemizedlist>
      <listitem>
	<para>Comprendre les fondements d'Unix et de FreeBSD (<xref
	  linkend="basics">).</para>
      </listitem>
      <listitem>
	<para>Etre familier avec la mise &agrave; jour des sources
	  (<xref linkend="cutting-edge">), et
	  les bases de la configuration et la compilation du noyau
	  (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Configuration initiale</title>

    <sect2>
      <title>Organisation des partitions</title>

      <indexterm><primary>Organisation des partitions</primary></indexterm>
      <indexterm>
        <primary><filename>/etc</filename></primary>
      </indexterm>
      <indexterm>
        <primary><filename>/var</filename></primary>
      </indexterm>
      <indexterm>
        <primary><filename>/usr</filename></primary>
      </indexterm>

      <sect3>
	<title>Partitions de base</title>

	<para>Quand vous organisez votre syst&egrave;me de fichiers &agrave;
	  l'aide de &man.disklabel.8; ou &man.sysinstall.8;, il est
	  important de se rappeler que les disques durs peuvent
	  transf&eacute;rer des donn&eacute;es plus rapidement depuis
	  les pistes externes que depuis celles &agrave; l'int&eacute;rieur.
	  En sachant cela, vous devriez placer vos syst&egrave;mes de
	  fichiers les plus petits, auxquels on acc&egrave;de le plus
	  souvent, comme la racine et l'espace de pagination, proche
	  de la partie externe du disque, alors que les grandes
	  partitions, comme <filename>/usr</filename>, devraient &ecirc;tre
	  plus &agrave; l'int&eacute;rieur.  Pour faire cela, c'est une bonne
	  id&eacute;e de cr&eacute;er les partitions dans l'ordre
	  suivant: racine, pagination, <filename>/var</filename>,
	  <filename>/usr</filename>.</para>

	<para>La taille de votre partition <filename>/var</filename>
	  refl&egrave;te l'utilisation pr&eacute;vue de votre machine.
	  <filename>/var</filename> est principalement utilis&eacute;e pour
	  h&eacute;berger les bo&icirc;tes aux lettres, les fichiers de traces,
	  les queues d'impression.  Les bo&icirc;tes aux lettres et les fichiers
	  de traces, en particulier, peuvent cro&icirc;tre dans des tailles
	  inattendues en fonction du nombre d'utilisateurs de votre
	  syst&egrave;me et de combien de temps sont conserv&eacute;s les
	  fichiers de traces.  Si vous avez l'intention de faire fonctionner un
	  serveur de courrier &eacute;lectronique, une partition
	  <filename>/var</filename> de plus d'un gigaoctet pourra
	  convenir.  De plus, <filename>/var/tmp</filename> doit &ecirc;tre
	  assez grand pour contenir tout logiciel pr&eacute;-compil&eacute; que
	  vous pourrez vouloir ajouter.</para>

	<para>La partition <filename>/usr</filename> contient la
	  majeure partie des fichiers n&eacute;cessaires au syst&egrave;me
	  et un sous-r&eacute;pertoire appel&eacute;
	  <filename>/usr/local</filename>
	  qui lui h&eacute;berge la plupart des fichiers install&eacute;s
	  par le catalogue des logiciels port&eacute;s.  Si vous n'employez
	  pas vraiment les logiciels port&eacute;s et que vous n'avez pas
	  l'intention de conserver les sources du syst&egrave;me sur
	  la machine (<filename>/usr/src</filename>), vous pouvez
	  utiliser une partition <filename>/usr</filename> d'un
	  gigaoctet.  Cependant, si vous installez beaucoup de
	  logiciels port&eacute;s (tout particuli&egrave;rement des
	  gestionnaires de fen&ecirc;tres et des binaires Linux), nous
	  recommandons au moins un <filename>/usr</filename> de deux
	  gigaoctets et si vous avez &eacute;galement l'intention d'avoir les
	  sources du syst&egrave;me sur la machine nous recommandons un
	  <filename>/usr</filename> de trois gigaoctets.  Ne
	  sous-estimez pas la quantit&eacute; d'espace dont vous aurez besoin
	  sur cette partition, vous risquez d'&ecirc;tre surpris!</para>

	<para>Quand vous dimensionnez vos partitions, gardez &agrave;
	  l'esprit les besoins en espace pour permettre &agrave; votre
	  syst&egrave;me de se d&eacute;velopper.  Manquer d'espace sur une
	  partition alors qu'il y en a plein sur les autres peut &ecirc;tre
	  tr&egrave;s frustrant.</para>

	<note><para>Certains utilisateurs qui ont employ&eacute;
	    l'option <literal>Auto-defaults</literal> de l'outil de
	    partitionnement de &man.sysinstall.8; ont trouv&eacute; plus
	    tard que leurs partitions racine et
	    <filename>/var</filename> &eacute;taient trop petites.
	    Partitionnez g&eacute;n&eacute;reusement et avec
	    sagesse.</para></note>

      </sect3>

      <sect3 id="swap-design">
	<title>Partition de pagination</title>

	<indexterm><primary>dimensionnement de l'espace de
	  pagination</primary></indexterm>
	<indexterm><primary>partition de pagination</primary></indexterm>

	<para>Par principe, votre espace de pagination devrait
	  typiquement avoir une taille double de la quantit&eacute; de
	  m&eacute;moire principale.  Par exemple, si la machine
	  poss&egrave;de 128 m&eacute;gaoctets de m&eacute;moire, le
	  fichier de pagination devrait &ecirc;tre de 256 m&eacute;gaoctets.
	  Les syst&egrave;mes avec peu de m&eacute;moire pourront avoir
	  de meilleures performances avec beaucoup plus d'espace de
	  pagination.  Il n'est pas recommand&eacute; d'avoir moins
	  de 256 m&eacute;gaoctets d'espace de pagination sur un
	  syst&egrave;me et vous devriez garder &agrave; l'esprit les futures
	  extensions de m&eacute;moire quand vous dimensionnez votre
	  partition de pagination.  Les algorithmes de pagination du
	  noyau sont optimis&eacute;s pour une meilleure efficacit&eacute;
	  avec une partition de pagination d'au moins deux fois la
	  taille de la m&eacute;moire principale.  Configurer trop peu
	  d'espace de pagination peut conduire &agrave; une certaine
	  inefficacit&eacute; du code de pagination de la m&eacute;moire virtuelle
	  comme &agrave; l'apparition de probl&egrave;mes
	  ult&eacute;rieurement si vous ajoutez plus de
	  m&eacute;moire &agrave; votre machine.</para>

	<para>Et enfin, sur des syst&egrave;mes importants avec de
	  multiples disques SCSI (ou de multiples disques IDE
	  fonctionnant sur diff&eacute;rents contr&ocirc;leurs), il est
	  vivement recommand&eacute; que vous configuriez un espace de
	  pagination sur chaque disque (jusqu'&agrave; quatre disques).
	  Les partitions de pagination sur les diff&eacute;rents disques
	  devront avoir approximativement la m&ecirc;me taille.  Le
	  noyau peut g&eacute;rer des tailles arbitraires mais les
	  structures de donn&eacute;es internes sont dimensionn&eacute;es pour 4
	  fois la taille de la plus grande partition de pagination.
	  Garder la taille des partitions de pagination proche
	  permettra au noyau de r&eacute;partir de mani&egrave;re
	  optimale l'espace de pagination entre les disques.  Ne vous
	  inqui&eacute;tez pas trop si vous les surdimensionnez, l'espace de
	  pagination est un des avantages d'Unix.  M&ecirc;me si vous
	  n'utilisez normalement pas beaucoup de cet espace, il peut
	  vous permettre d'avoir plus temps pour r&eacute;cup&eacute;rer
	  face &agrave; programme incontr&ocirc;lable avant
	  d'&ecirc;tre forc&eacute; &agrave; relancer la machine.</para>
      </sect3>

      <sect3>
	<title>Pourquoi des Partitions?</title>

	<para>Pourquoi des partitions?  Pourquoi ne pas cr&eacute;er une
	  seule grande partition racine?  Ainsi je n'aurais pas &agrave;
	  me soucier d'avoir sous-dimensionn&eacute; certaines choses!</para>

	<para>Pour plusieurs raisons cela n'est pas une bonne id&eacute;e.
	  Tout d'abord, chaque partition a diff&eacute;rentes
	  caract&eacute;ristiques d'utilisation et les s&eacute;parer autorise
	  le syst&egrave;me de fichiers &agrave; s'optimiser lui-m&ecirc;me
	  pour ces caract&eacute;ristiques.  Par exemple, les partitions
	  racine et <filename>/usr</filename> sont surtout lues, et
	  rarement utilis&eacute;es en &eacute;criture, alors que de nombreuses
	  op&eacute;rations de lecture et &eacute;criture pourront avoir lieu
	  sur <filename>/var</filename> et
	  <filename>/var/tmp</filename>.</para>

	<para>En partitionnant correctement votre syst&egrave;me,
	  la fragmentation introduite sur les partitions plus petites et
	  plus charg&eacute;es en &eacute;criture ne s'&eacute;tendra pas sur
	  les partitions principalement utilis&eacute;es en lecture.
	  De plus, avoir les partitions principalement utilis&eacute;es
	  en &eacute;criture proche du bord du disque, par exemple avant la
	  grande partition au lieu qu'apr&egrave;s dans la table des
	  partitions, augmentera les performances d'E/S sur les
	  partitions qui le demandent le plus.  Maintenant il est
	  &eacute;galement vrai que vous avez besoin de performances d'E/S
	  sur les grandes partitions, mais elles sont si grandes que
	  les d&eacute;placer plus vers l'ext&eacute;rieur du disque ne
	  donnera pas lieu &agrave; une augmentation significative des
	  performances alors que le d&eacute;placement de
	  <filename>/var</filename> vers le bord peut avoir un s&eacute;rieux
	  impact.  Et enfin, il y a &eacute;galement des raisons de
	  s&eacute;curit&eacute;.  Avoir une partition racine petite et
	  ordonn&eacute;e qui est essentiellement en lecture seule lui
	  donne plus de chance de rester intacte apr&egrave;s un crash
	  s&eacute;v&egrave;re.</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Configuration principale</title>

    <indexterm>
      <primary>fichiers rc</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>L'emplacement principal pour les donn&eacute;es de configuration
      du syst&egrave;me est le fichier <filename>/etc/rc.conf</filename>.
      Ce fichier contient une large gamme d'informations de
      configuration, principalement utilis&eacute;es au d&eacute;marrage
      du syst&egrave;me
      pour configurer ce dernier.  Son nom le sous-entend; c'est
      l'information de configuration pour les fichiers
      <filename>rc*</filename>.</para>

    <para>Un administrateur devrait ajouter des entr&eacute;es dans le
      fichier <filename>rc.conf</filename> pour remplacer les valeurs
      par d&eacute;faut du fichier
      <filename>/etc/defaults/rc.conf</filename>.  Les fichiers de
      valeurs par d&eacute;faut ne devraient pas &ecirc;tre copi&eacute;s
      directement tels quels dans <filename>/etc</filename> - ils
      contiennent des valeurs par d&eacute;faut, et non pas des exemples.
      Tout changement sp&eacute;cifique au syst&egrave;me devrait
      &ecirc;tre fait dans le fichier <filename>rc.conf</filename>.</para>

    <para>Un certain nombre de strat&eacute;gies peuvent &ecirc;tre
      appliqu&eacute;es dans le cas d'applications en grappe pour
      s&eacute;parer la configuration d'un site de celle d'un syst&egrave;me
      afin de r&eacute;duire le travail d'administration.  L'approche
      recommand&eacute;e est
      de placer la configuration propre au site dans un autre fichier
      comme <filename>/etc/rc.conf.site</filename>, puis ensuite
      inclure ce fichier dans <filename>/etc/rc.conf</filename>, qui
      ne contiendra seulement que les informations sp&eacute;cifiques au
      syst&egrave;me.</para>

    <para>Comme <filename>rc.conf</filename> est lu par &man.sh.1; il est
      assez trivial d'effectuer cela.  Par exemple:</para>

    <itemizedlist>
      <listitem><para>rc.conf:</para>
<programlisting>	. rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"</programlisting></listitem>
      <listitem><para>rc.conf.site:</para>
<programlisting>	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"</programlisting></listitem>
    </itemizedlist>

    <para>Le fichier <filename>rc.conf.site</filename> peut &ecirc;tre
      distribu&eacute; &agrave; l'ensemble des syst&egrave;mes en utilisant
      <command>rsync</command> ou un programme semblable, tandis que
      le fichier <filename>rc.conf</filename> reste unique.</para>

    <para>Mettre &agrave; jour le syst&egrave;me en employant
      &man.sysinstall.8; ou <command>make world</command> n'&eacute;crasera
      pas le fichier <filename>rc.conf</filename>, les informations de
      configuration du syst&egrave;me ne seront donc pas perdues.</para>

  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Configuration des applications</title>

    <para>G&eacute;n&eacute;ralement, les applications install&eacute;es
      ont leurs propres fichiers de configuration, avec leur propre
      syntaxe, etc...  Il est important que ces fichiers soient
      s&eacute;par&eacute;s du syst&egrave;me de base, de sorte qu'ils soient
      facilement localisables et g&eacute;rables par les outils de gestion
      des logiciels install&eacute;s.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>Ces fichiers sont g&eacute;n&eacute;ralement install&eacute;s
      dans le r&eacute;pertoire <filename>/usr/local/etc</filename>.  Dans
      le cas o&ugrave; une application poss&egrave;de un grand nombre
      de fichiers de configuration, un sous-r&eacute;pertoire sera
      cr&eacute;&eacute; pour les h&eacute;berger.</para>

    <para>Normalement, quand un logiciel port&eacute; ou
      pr&eacute;-compil&eacute; est install&eacute;, des exemples de
      fichiers de configuration sont &eacute;galement install&eacute;s.
      Ces derniers sont g&eacute;n&eacute;ralement identifi&eacute;s
      par un suffixe &ldquo;.default&rdquo;.  Si aucun fichier de
      configuration n'existe pour l'application, on les cr&eacute;era en
      copiant les fichiers .default.</para>

    <para>Par exemple, consid&eacute;rez le contenu du
      r&eacute;pertoire <filename>/usr/local/etc/apache</filename>:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>La diff&eacute;rence de taille des fichiers indique que seul le
      fichier <filename>srm.conf</filename> a &eacute;t&eacute; modifi&eacute;.  Une mise &agrave;
      jour, plus tard, du logiciel apache ne devrait pas &eacute;craser le
      fichier modifi&eacute;.</para>

  </sect1>

  <sect1 id="configtuning-starting-services">
    <title>D&eacute;marrer des services</title>

    <indexterm><primary>services</primary></indexterm>

    <para>Il est assez courant qu'un syst&egrave;me h&eacute;berge
      un certain nombre de services.  Ces derniers peuvent &ecirc;tre
      d&eacute;marr&eacute;s de diff&eacute;rentes fa&ccedil;ons, chacune
      ayant diff&eacute;rents avantages.</para>

    <indexterm><primary>/usr/local/etc/rc.d</primary></indexterm>

    <para>Un logiciel install&eacute; &agrave; partir du catalogue
      des logiciels port&eacute;s ou depuis une version
      pr&eacute;-compil&eacute;e placera souvent une proc&eacute;dure dans
      <filename>/usr/local/etc/rc.d</filename> qui sera invoqu&eacute;e
      au d&eacute;marrage du syst&egrave;me avec un argument
      <option>start</option>, et &agrave; l'arr&ecirc;t du
      syst&egrave;me avec l'argument <option>stop</option>.  C'est la
      m&eacute;thode recommand&eacute;e pour d&eacute;marrer des services
      sur le syst&egrave;me qui doivent fonctionner avec les privil&egrave;ges
      de <username>root</username>, ou s'attendent &agrave; fonctionner
      avec ces privil&egrave;ges.  Ces proc&eacute;dures font partie
      de l'installation du logiciel, et seront effac&eacute;es quand le
      logiciel sera d&eacute;sinstall&eacute;.</para>

    <para>Une proc&eacute;dure g&eacute;n&eacute;rique de d&eacute;marrage dans
      <filename>/usr/local/etc/rc.d</filename> ressemble &agrave;:</para>

    <programlisting>#!/bin/sh
echo -n ' FooBar'

case "$1" in
start)
        /usr/local/bin/foobar
        ;;
stop)
        kill -9 `cat /var/run/foobar.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0
    </programlisting>

    <para>Les proc&eacute;dures de d&eacute;marrage de FreeBSD rechercheront
      dans <filename>/usr/local/etc/rc.d</filename> les proc&eacute;dures
      qui ont une extension <literal>.sh</literal> et qui sont
      ex&eacute;cutables par <username>root</username>.  Les
      proc&eacute;dures trouv&eacute;es seront lanc&eacute;es avec une
      option <option>start</option> au d&eacute;marrage, et
      <option>stop</option> &agrave; l'arr&ecirc;t pour leur permettre de
      faire ce qu'elles ont &agrave; faire.  Donc si vous aviez voulu que la
      proc&eacute;dure pr&eacute;c&eacute;dente soit
      ex&eacute;cut&eacute;e au moment voulu pendant le d&eacute;marrage
      du syst&egrave;me, vous auriez d&ucirc; la sauver dans un fichier
      appel&eacute; <filename>FooBar.sh</filename> dans le r&eacute;pertoire
      <filename>/usr/local/etc/rc.d</filename> et en v&eacute;rifiant qu'elle
      soit ex&eacute;cutable.  Vous pouvez rendre une proc&eacute;dure
      d'interpr&eacute;teur de commandes ex&eacute;cutable avec la commande
      &man.chmod.1; comme montr&eacute; ci-dessous:</para>

    <screen>&prompt.root; <userinput>chmod 755 <replaceable>FooBar.sh</replaceable></userinput></screen>

    <para>Certains services s'attendent &agrave; &ecirc;tre invoqu&eacute;
      par &man.inetd.8; quand une demande de connexion est re&ccedil;ue
      sur le bon port.  Ceci est courant pour les serveurs de
      r&eacute;cup&eacute;ration du courrier (POP et IMAP, etc...).
      Ces services sont activ&eacute;s en &eacute;ditant le fichier
      <filename>/etc/inetd.conf</filename>. Voir la page de manuel
      &man.inetd.8; pour plus de d&eacute;tails sur l'&eacute;dition
      de ce fichier.</para>

    <para>Certains services syst&egrave;mes additionnels ne peuvent
      pas &ecirc;tre couverts par les options de
      <filename>/etc/rc.conf</filename>.  Ils sont traditionnellement
      activ&eacute;s en pla&ccedil;ant la/les commande(s) pour les invoquer
      dans le fichier <filename>/etc/rc.local</filename>.  Depuis FreeBSD 3.1
      il n'y a pas de fichier <filename>/etc/rc.local</filename> par
      d&eacute;faut; s'il est cr&eacute;&eacute; par
      l'administrateur il sera utilis&eacute; par le syst&egrave;me de
      fa&ccedil;on habituelle.  Notez que <filename>/etc/rc.local</filename>
      est g&eacute;n&eacute;ralement vu comme l'emplacement de dernier recours;
      s'il y a un meilleur emplacement pour d&eacute;marrer un service,
      utilisez-le.</para>

    <note><para>Ne placez <emphasis>aucune</emphasis> commande dans
      <filename>/etc/rc.conf</filename>.  Pour d&eacute;marrer des
      &ldquo;daemons&rdquo;, ou lancer tout autre commande au
      d&eacute;marrage, placez une proc&eacute;dure dans
      <filename>/usr/local/etc/rc.d</filename> &agrave; la place.</para>
    </note>

    <para>Il est &eacute;galement possible d'utiliser le &ldquo;daemon&rdquo;
      &man.cron.8; pour d&eacute;marrer des services syst&egrave;me.  Cette
      approche pr&eacute;sente un certain nombre d'avantages, et non des
      moindres parce que &man.cron.8; ex&eacute;cute ces proc&eacute;dures
      sous les privil&egrave;ges du propri&eacute;taire de la table
      <command>crontab</command>, les services pourront &ecirc;tre
      d&eacute;marr&eacute;s et maintenus par des utilisateurs
      non-<username>root</username>.</para>

    <para>Cela peut utiliser avantageusement une des
      caract&eacute;ristiques de &man.cron.8;: la sp&eacute;cification
      de la date d'ex&eacute;cution peut &ecirc;tre remplac&eacute;e
      par <literal>@reboot</literal>, qui provoquera l'ex&eacute;cution
      de la t&acirc;che quand &man.cron.8; est lanc&eacute;, peu de temps
      apr&egrave;s le d&eacute;marrage du syst&egrave;me.</para>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>H&ocirc;tes virtuels</title>

    <indexterm><primary>h&ocirc;tes virtuels</primary></indexterm>
    <indexterm><primary>alias IP</primary></indexterm>

    <para>Une utilisation tr&egrave;s courante de FreeBSD est
      l'h&eacute;bergement de sites virtuels, o&ugrave; un serveur
      appara&icirc;t pour le r&eacute;seau comme &eacute;tant
      plusieurs serveurs diff&eacute;rents.  Ceci est possible en assignant
      plusieurs adresses r&eacute;seau &agrave; une interface.</para>

    <para>Une interface r&eacute;seau donn&eacute;e poss&egrave;de une
      adresse &ldquo;r&eacute;elle&rdquo;, et peut avoir n'importe
      quel nombre d'adresses &ldquo;alias&rdquo;.  Ces alias sont
      normalement ajout&eacute;s en pla&ccedil;ant les entr&eacute;es
      correspondantes dans le fichier
      <filename>/etc/rc.conf</filename>.</para>

    <para>Une entr&eacute;e d'alias pour l'interface
      <devicename>fxp0</devicename> ressemble &agrave;:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Notez que les entr&eacute;es d'alias doivent commencer avec alias0
      et continuer en ordre croissant, (par exemple, _alias1, _alias2,
      et ainsi de suite).  Le processus de configuration s'arr&ecirc;tera
      au premier nombre absent.</para>

    <para>Le calcul des masques de r&eacute;seau est important, mais
      heureusement assez simple.  Pour une interface donn&eacute;e, il doit y
      avoir une adresse qui repr&eacute;sente correctement le masque de
      r&eacute;seau de votre r&eacute;seau.  Tout autre adresse appartenant
      &agrave; ce r&eacute;seau devra avoir un masque de r&eacute;seau
      avec chaque bit &agrave; 1.</para>

    <para>Par exemple, consid&eacute;rez le cas o&ugrave;
      l'interface <devicename>fxp0</devicename> est connect&eacute;e &agrave;
      deux r&eacute;seaux, le r&eacute;seau 10.1.1.0 avec un masque de
      r&eacute;seau de
      255.255.255.0 et le r&eacute;seau 202.0.75.16 avec un masque de
      255.255.255.240.  Nous voulons que le syst&egrave;me apparaisse de
      10.1.1.1 jusqu'&agrave; 10.1.1.5 et &agrave; 202.0.75.17 jusqu'&agrave;
      202.0.75.20.</para>

    <para>Les entr&eacute;es suivantes configurent la carte
      correctement pour cet arrangement:</para>

<programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Fichiers de configuration</title>

    <sect2>
      <title>Organisation du r&eacute;pertoire <filename>/etc</filename></title>
      <para>Il existe un certain nombre de r&eacute;pertoires dans lesquels
	se trouvent les informations de configuration.  Ceux-ci
	incluent:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>Information de configuration g&eacute;n&eacute;rique du
		syst&egrave;me; les donn&eacute;es ici sont
		sp&eacute;cifiques au syst&egrave;me.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>Version par d&eacute;faut des fichiers de configuration
		du syst&egrave;me.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>Configuration de &man.sendmail.8;, et autres fichiers
		de configuration d'agent de transmission du courrier
		&eacute;lectronique.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>Configuration pour les programmes PPP utilisateur
		et int&eacute;gr&eacute; au noyau.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>Emplacement par d&eacute;faut pour les donn&eacute;es de
		 &man.named.8;.  Normalement
		 <filename>named.conf</filename> et les fichiers de zone
		 sont stock&eacute;s dans ce r&eacute;pertoire.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc</filename></entry>
	      <entry>Fichiers de configuration pour les applications
		install&eacute;es.  Peut contenir des sous-r&eacute;pertoires
		pour chaque application.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>Proc&eacute;dures de lancement/d'arr&ecirc;t pour les
		applications install&eacute;es.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>Fichiers de bases de donn&eacute;es automatiquement
		g&eacute;n&eacute;r&eacute;s, sp&eacute;cifiques
		au syst&egrave;me, comme la base de donn&eacute;es
		des logiciels install&eacute;s, la base de donn&eacute;es de
		localisation des fichiers, et ainsi de suite.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Nom d'h&ocirc;tes</title>

      <indexterm><primary>nom d'h&ocirc;te</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm>
	  <primary><filename>resolv.conf</filename></primary>
	</indexterm>

	<para><filename>/etc/resolv.conf</filename> g&egrave;re comment
	  le r&eacute;solveur de FreeBSD acc&egrave;de au syst&egrave;me
	  de nom de domaine d'Internet (DNS).</para>

	<para>Les entr&eacute;es la plus classiques du fichier
	  <filename>resolv.conf</filename> sont:</para>

	<informaltable frame="none">
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>
		<entry>L'adresse IP du serveur de noms auquel le
		  r&eacute;solveur devrait envoyer ses requ&ecirc;tes.  Les
		  serveurs sont sollicit&eacute;s dans l'ordre list&eacute;
		  avec un maximum de trois.</entry>
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Liste de recherche pour la r&eacute;solution de nom de
		  machine.  Ceci est normalement d&eacute;termin&eacute; par le
		  domaine de l'h&ocirc;te local.</entry>
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Le nom du domaine local.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Un fichier <filename>resolv.conf</filename> typique:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note><para>Seule une des options <literal>search</literal> et
	  <literal>domain</literal> devrait &ecirc;tre
	  utilis&eacute;e.</para></note>

	<para>Si vous utilisez DHCP, &man.dhclient.8; r&eacute;&eacute;crit
	  habituellement <filename>resolv.conf</filename> avec
	  l'information re&ccedil;u du serveur DHCP.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>

	<para><filename>/etc/hosts</filename> est une simple base de
	  donn&eacute;es texte, une r&eacute;miniscence des d&eacute;buts
	  d'Internet.  Il travaille en conjonction avec les serveurs
	  DNS et NIS pour fournir les correspondances nom vers adresse
	  IP.  Les ordinateurs locaux reli&eacute;s par
	  l'interm&eacute;diaire d'un r&eacute;seau local peuvent
	  &ecirc;tre ajout&eacute;s dans ce fichier pour une r&eacute;solution
	  de noms simple plut&ocirc;t que de configurer un serveur
	  &man.named.8;.
	  De plus <filename>/etc/hosts</filename> peut &ecirc;tre
	  utilis&eacute; pour fournir un enregistrement local de
	  correspondances de nom, r&eacute;duisant ainsi le besoin
	  de requ&ecirc;tes vers l'ext&eacute;rieur pour les noms auxquels on
	  acc&egrave;de couramment.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#</programlisting>

	<para><filename>/etc/hosts</filename> suit le format simple
	  suivant:</para>

	<programlisting>[Internet address] [official hostname] [alias1] [alias2] ...</programlisting>

	<para>Par exemple:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Consultez la page de manuel &man.hosts.5; pour plus
	  d'informations.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configuration des fichiers de trace</title>

      <indexterm><primary>fichiers de trace</primary></indexterm>

      <sect3>
	<title><filename>syslog.conf</filename></title>

	<indexterm><primary>syslog.conf</primary></indexterm>

	<para><filename>syslog.conf</filename> est le fichier de configuration
	  du programme &man.syslogd.8;.  Il indique quel type de
	  messages <command>syslog</command> sera enregistr&eacute;
	  dans des fichiers de traces particuliers.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

	<para>Consultez la page de manuel &man.syslog.conf.5; pour plus
	  d'informations.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>

	<para><filename>newsyslog.conf</filename> est le fichier de
	  configuration de &man.newsyslog.8;, un programme qui est
	  normalement programm&eacute; &man.cron.8; pour s'ex&eacute;cuter
	  p&eacute;riodiquement.  &man.newsyslog.8; d&eacute;termine quand les
	  fichiers de traces doivent &ecirc;tre archiv&eacute;s
	  ou r&eacute;organis&eacute;s.  <filename>logfile</filename> devient
	  <filename>logfile.0</filename>, <filename>logfile.0</filename>
	  devient &agrave; son tour <filename>logfile.1</filename>, et ainsi
	  de suite.  D'autre part, les fichiers de traces peuvent &ecirc;tre
	  archiv&eacute;s dans le format &man.gzip.1;, ils se nommeront
	  alors: <filename>logfile.0.gz</filename>,
	  <filename>logfile.1.gz</filename>, et ainsi de suite.</para>

	<para><filename>newsyslog.conf</filename> indique quels
	  fichiers de traces doivent &ecirc;tre g&eacute;r&eacute;s,
	  combien doivent &ecirc;tre conserv&eacute;s, et quand ils
	  doivent &ecirc;tre modifi&eacute;s.  Les fichiers de traces
	  peuvent &ecirc;tre r&eacute;organis&eacute;s et/ou archiv&eacute;s
	  quand ils ont soit atteint une certaine taille, soit &agrave; une
	  certaine p&eacute;riode/date.</para>

	<programlisting># configuration file for newsyslog
# &dollar;FreeBSD&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

	<para>Consultez la page de manuel &man.newsyslog.8; pour plus
	  d'informations.</para>
      </sect3>
    </sect2>

    <sect2>
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> ressemble &agrave;
	<filename>rc.conf</filename>.  Les valeurs sont fix&eacute;es sous
	la forme <literal>variable=value</literal>.  Les valeurs
	sp&eacute;cifi&eacute;es sont positionn&eacute;es
	apr&egrave;s que le syst&egrave;me soit pass&eacute;
	dans le mode multi-utilisateurs.  Toutes les variables ne sont
	pas param&eacute;trables dans ce mode.</para>

      <para>Un exemple de <filename>sysctl.conf</filename> d&eacute;sactivant
	la trace signaux fatals de fin de processus et faisant savoir
	aux programmes Linux qu'ils tournent sous FreeBSD.</para>

      <programlisting>kern.logsigexit=0       # Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=FreeBSD
compat.linux.osrelease=4.3-STABLE</programlisting>
    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Optimisation avec sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm><primary>optimisation avec sysctl</primary></indexterm>

    <para>&man.sysctl.8; est une interface qui vous permet d'effectuer
      des changements de param&eacute;trage sur un syst&egrave;me
      FreeBSD en fonctionnement.  Cela comprend de nombreuses options
      avanc&eacute;es de la pile TCP/IP et du syst&egrave;me de
      m&eacute;moire virtuelle qui peuvent am&eacute;liorer dramatiquement les
      performances pour un administrateur syst&egrave;me
      exp&eacute;riment&eacute;.  Plus de cinq cent variables
      syst&egrave;me peuvent &ecirc;tre lues et modifi&eacute;es
      gr&acirc;ce &agrave; &man.sysctl.8;.</para>

    <para>&man.sysctl.8; remplit deux fonctions: lire et modifier
      les param&eacute;trages du syst&egrave;me.</para>

    <para>Pour afficher toutes les variables lisibles:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Pour lire une variable particuli&egrave;re, par exemple,
      <varname>kern.maxproc</varname>:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Pour fixer une variable particuli&egrave;re, utilisez
      la syntaxe intuitive
      <replaceable>variable</replaceable>=<replaceable>valeur</replaceable>
      :</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>Les valeurs des variables sysctl sont g&eacute;n&eacute;ralement des
      cha&icirc;nes de caract&egrave;res, des nombres, ou des
      bool&eacute;ens (un variable bool&eacute;enne &eacute;tant
      <literal>1</literal> pour oui ou un <literal>0</literal> pour
      non).</para>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Optimiser les disques</title>

    <sect2>
      <title>Les variables sysctl</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>

	<para>La variable sysctl <varname>vfs.vmiodirenable</varname>
	  peut &ecirc;tre positionn&eacute;e soit &agrave; 0
	  (d&eacute;sactiv&eacute;e) soit &agrave; 1
	  (activ&eacute;e); elle est a 1 par d&eacute;faut.  Cette variable
	  sp&eacute;cifie comment les r&eacute;pertoires sont
	  cach&eacute;s par le syst&egrave;me.
	  La plupart des r&eacute;pertoires sont petits, utilisant juste un
	  simple fragment du syst&egrave;me de fichiers (typiquement 1KO) et
	  moins dans le cache en m&eacute;moire (typiquement 512 octets).
	  Cependant, quand on fonctionne dans le mode par d&eacute;faut le
	  cache en m&eacute;moire ne cachera qu'un nombre fixe de
	  r&eacute;pertoires m&ecirc;me si vous disposez d'une grande
	  quantit&eacute; de m&eacute;moire.  Activer cette variable sysctl
	  permet au cache en m&eacute;moire d'utiliser le cache des pages de
	  m&eacute;moire virtuelle pour cacher les r&eacute;pertoires,
	  rendant toute la m&eacute;moire disponible pour cacher les
	  r&eacute;pertoires.  Cependant, la taille minimale de
	  l'&eacute;l&eacute;ment m&eacute;moire utilis&eacute; pour cacher
	  un r&eacute;pertoire est une page physique (typiquement 4KO)
	  plut&ocirc;t que 512 octets.
	  Nous recommandons l'activation de cette option si
	  vous faites fonctionner des services qui manipulent un grand
	  nombre de fichiers.  De tels services peuvent &ecirc;tre des
	  caches web, d'importants syst&egrave;mes de courrier
	  &eacute;lectronique, et des syst&egrave;mes serveurs de groupe
	  de discussion.  Activer cette option ne r&eacute;duira
	  g&eacute;n&eacute;ralement pas les performances m&ecirc;me
	  avec la m&eacute;moire gaspill&eacute;e mais vous devriez
	  faire des exp&eacute;riences pour le d&eacute;terminer.</para>
      </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>FreeBSD 4.3 a flirt&eacute; avec la d&eacute;sactivation
	  du cache en &eacute;criture des disques IDE.  Cela r&eacute;duisit la
	  bande passante en &eacute;criture des disques IDE mais fut
	  consid&eacute;r&eacute; comme n&eacute;cessaire en raison de
	  s&eacute;rieux probl&egrave;mes de coh&eacute;rence de
	  donn&eacute;es introduits par les fabricants de disques durs.
	  Le probl&egrave;me est que les disques IDE mentent sur le
	  moment o&ugrave; une &eacute;criture est r&eacute;ellement
	  termin&eacute;e.  Avec le cache en &eacute;criture IDE
	  activ&eacute;, les disques durs IDE non seulement
	  n'&eacute;criront pas les donn&eacute;es dans l'ordre, mais parfois
	  retarderont l'&eacute;criture de certains blocs ind&eacute;finiment
	  sous une charge disque importante.  Un crash ou une coupure
	  secteur pourra &ecirc;tre &agrave; l'origine de
	  s&eacute;rieuses corruptions du syst&egrave;me de fichiers.
	  Par pr&eacute;caution le param&eacute;trage par d&eacute;faut
	  de FreeBSD fut modifi&eacute;.  Malheureusement, le
	  r&eacute;sultat fut une telle perte de performances que nous avons
	  r&eacute;activ&eacute; le cache en &eacute;criture
	  apr&egrave;s cette version de FreeBSD.  Vous devriez
	  contr&ocirc;ler la valeur par
	  d&eacute;faut sur votre syst&egrave;me en examinant la variable
	  sysctl <varname>hw.ata.wc</varname>.  Si le cache en
	  &eacute;criture des disques IDE est d&eacute;sactiv&eacute;,
	  vous pouvez le r&eacute;activer en positionnant la variable
	  &agrave; 1.  Cela doit &ecirc;tre fait &agrave; partir du chargeur au
	  d&eacute;marrage.  Tenter de le faire apr&egrave;s le
	  d&eacute;marrage du noyau n'aura aucun effet.</para>

	<para>Pour plus d'informations, veuillez consulter la page de
	  manuel &man.ata.4;.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Les &ldquo;Soft Updates&rdquo;</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Le programme &man.tunefs.8; peut &ecirc;tre utilis&eacute;
	pour r&eacute;gler finement un syst&egrave;me de fichiers.
	Ce programme dispose de nombreuses options diff&eacute;rentes, mais
	pour l'instant nous nous int&eacute;resserons uniquement &agrave;
	l'activation et la d&eacute;sactivation des &ldquo;Soft
	Updates&rdquo;, ce qui fait avec:</para>

      <screen>&prompt.root; tunefs -n enable /filesystem
&prompt.root; tunefs -n disable /filesystem</screen>

      <para>Un syst&egrave;me de fichiers ne peut &ecirc;tre modifi&eacute;
	avec &man.tunefs.8; tant qu'il est mont&eacute;.  Un bon moment pour
	activer les &ldquo;Soft Updates&rdquo; est avant que les
	partitions ne soient mont&eacute;es en mode mono-utilisateur.</para>

      <note><para>Depuis FreeBSD 4.5, il est possible d'activer les
	&ldquo;Soft Updates&rdquo; au moment de la cr&eacute;ation du
	syst&egrave;me de fichiers, avec l'utilisation de l'option
	<literal>-U</literal> de la commande
	&man.newfs.8;.</para></note>

      <para>Les &ldquo;Soft Updates&rdquo; am&eacute;liorent de fa&ccedil;on
	drastique les performances sur les m&eacute;ta-donn&eacute;es,
	principalement la cr&eacute;ation et la suppression de fichier, par
	l'utilisation d'un cache m&eacute;moire.  Nous recommandons d'activer
	les &ldquo;Soft Updates&rdquo; sur tous vos syst&egrave;mes de
	fichiers.  Il y a deux inconv&eacute;nients aux &ldquo;Soft
	Updates&rdquo; que vous devez conna&icirc;tre: tout d'abord, les
	&ldquo;Soft Updates&rdquo; garantissent la coh&eacute;rence du
	syst&egrave;me de fichiers en cas de crash mais pourront facilement
	&ecirc;tre en retard de quelques secondes (voir m&ecirc;me une minute!)
	dans la mise &agrave; jour du disque.  Si votre syst&egrave;me plante
	il se peut que vous perdiez plus de travail que dans d'autres cas.
	Deuxi&egrave;mement, les &ldquo;Soft Updates&rdquo; retardent la
	lib&eacute;ration des blocs du syst&egrave;me de fichiers.  Si vous
	avez un syst&egrave;me de fichiers (comme le syst&egrave;me de
	fichiers racine) qui est presque plein, effectuer une mise &agrave;
	jour majeure, comme un <command>make installworld</command>,
	peut mener &agrave; un manque d'espace sur le syst&egrave;me de
	fichiers et faire &eacute;chouer la mise &agrave; jour.</para>

      <sect3>
	<title>Plus de d&eacute;tails &agrave; propos des
	  &ldquo;Soft Updates&rdquo;</title>

	<indexterm><primary>Soft Updates (D&eacute;tails)</primary></indexterm>

	<para>Il y a deux approches traditionnelles pour &eacute;crire les
	  m&eacute;ta-donn&eacute;es d'un syst&egrave;me de fichiers sur le
	  disque (mise &agrave; jour des m&eacute;ta-donn&eacute;es et mise
	  &agrave; jour des &eacute;l&eacute;ments sans donn&eacute;es
	  comme les inodes ou les r&eacute;pertoires).</para>

	<para>Historiquement, le comportement par d&eacute;faut
	  &eacute;tait d'&eacute;crire les mises &agrave; jour des
	  m&eacute;ta-donn&eacute;es de fa&ccedil;on synchrone.  Si un
	  r&eacute;pertoire a &eacute;t&eacute; modifi&eacute;, le
	  syst&egrave;me attendait jusqu'&agrave; ce que le changement soit
	  effectivement &eacute;crit sur le disque.  Les tampons des
	  donn&eacute;es de fichier (contenu du fichier) passaient par le
	  cache m&eacute;moire et &eacute;taient copi&eacute;s
	  sur le disque plus tard de fa&ccedil;on asynchrone.
	  L'avantage de cette impl&eacute;mentation est
	  qu'elle est effectu&eacute;e sans risque.  S'il y a un
	  probl&egrave;me durant une mise &agrave; jour, les
	  m&eacute;ta-donn&eacute;es sont toujours dans
	  un &eacute;tat consistant.  Un fichier est soit
	  cr&eacute;&eacute; compl&egrave;tement soit pas du tout.  Si les
	  blocs de donn&eacute;es d'un fichier n'ont pas trouv&eacute; leur
	  chemin du cache m&eacute;moire vers le disque au moment du crash,
	  &man.fsck.8; est capable de s'en apercevoir et de r&eacute;parer le
	  syst&egrave;me de fichiers en fixant la taille du fichier &agrave;
	  0.  De plus, l'impl&eacute;mentation est claire et simple.
	  L'inconv&eacute;nient est que la modification des
	  m&eacute;ta-donn&eacute;es
	  est lente.  Un <command>rm -r</command>, par exemple,
	  touche &agrave; tous les fichiers dans un r&eacute;pertoire
	  s&eacute;quentiellement, mais chaque modification du
	  r&eacute;pertoire (effacement d'un fichier) sera &eacute;crite
	  de fa&ccedil;on synchrone sur le disque.
	  Cela comprend les mises &agrave; jour
	  du r&eacute;pertoire lui-m&ecirc;me, de la table des inodes, et
	  &eacute;ventuellement celles sur des blocs indirects allou&eacute;s
	  par le fichier.  Des consid&eacute;rations semblables s'applique
	  &agrave; la cr&eacute;ation d'importantes hi&eacute;rarchies
	  ((<command>tar -x</command>).</para>

	<para>Le deuxi&egrave;me cas est la mise &agrave; jour
	  asynchrone des m&eacute;ta-donn&eacute;es.  C'est le comportement
	  par d&eacute;faut de Linux/ext2fs et de l'usage de
	  <command>mount -o async</command> pour l'UFS des syst&egrave;mes
	  BSD.  Toutes les mises &agrave; jour des m&eacute;ta-donn&eacute;es
	  passent &eacute;galement par l'interm&eacute;diaire d'un cache
	  m&eacute;moire, c'est &agrave; dire, qu'elles seront
	  m&eacute;lang&eacute;es
	  aux mises &agrave; jour des donn&eacute;es du contenu du fichier.
	  L'avantage de cette impl&eacute;mentation est qu'il n'y a pas
	  besoin d'attendre jusqu'&agrave; l'&eacute;criture sur le disque
	  de chaque mise &agrave; jour de m&eacute;ta-donn&eacute;es, donc
	  toutes les op&eacute;rations qui sont &agrave; l'origine d'une grande
	  quantit&eacute; de mise &agrave; jour de m&eacute;ta-donn&eacute;es
	  fonctionnent bien plus rapidement que dans le cas synchrone.
	  De plus, l'impl&eacute;mentation est toujours claire et simple, il y
	  a donc peu de risque qu'un bogue se cache dans le code.
	  L'inconv&eacute;nient est qu'il n'y a aucune garantie du tout sur la
	  coh&eacute;rence du syst&egrave;me de fichiers.  S'il y a un
	  probl&egrave;me durant une op&eacute;ration qui met &agrave; jour
	  une grande quantit&eacute; de m&eacute;ta-donn&eacute;es
	  (comme une coupure secteur, ou quelqu'un appuyant sur le
	  bouton reset), le syst&egrave;me de fichiers sera laiss&eacute;
	  dans un &eacute;tat impr&eacute;visible.  Il n'y a aucune
	  opportunit&eacute; d'examiner l'&eacute;tat du syst&egrave;me
	  de fichiers quand le syst&egrave;me est a nouveau relanc&eacute;;
	  les blocs de donn&eacute;es d'un fichier pourraient
	  d&eacute;j&agrave; avoir &eacute;t&eacute; inscrit sur
	  le disque alors que la mise &agrave; jour de la table des inodes
	  ou du r&eacute;pertoire associ&eacute; n'a pas
	  &eacute;t&eacute; faite.  Il est en fait impossible
	  d'impl&eacute;menter un <command>fsck</command>
	  qui est capable de nettoyer le chaos r&eacute;sultant (parce que
	  l'information n&eacute;cessaire n'est pas disponible sur le
	  disque).  Si le syst&egrave;me de fichiers a &eacute;t&eacute;
	  endommag&eacute; irr&eacute;m&eacute;diablement, le seul choix est
	  de le recr&eacute;er avec <command>newfs</command> et de
	  r&eacute;cup&eacute;rer les donn&eacute;es &agrave; partir
	  de sauvegardes.</para>

	<para>La solution commune pour ce probl&egrave;me fut
	  d'impl&eacute;menter une <emphasis>r&eacute;gion de
	  trace</emphasis>, dont
	  on fait souvent r&eacute;f&eacute;rence sous le terme de
	  <emphasis>journalisation</emphasis>, bien que ce terme ne
	  soit pas toujours utilis&eacute; de fa&ccedil;on
	  coh&eacute;rente et est occasionnellement utilis&eacute;
	  pour d'autres formes de transaction avec trace.  Les mises &agrave;
	  jour des m&eacute;ta-donn&eacute;es sous toujours &eacute;crites
	  de fa&ccedil;on synchrone, mais seulement sur une petite r&eacute;gion
	  du disque.  Elles seront plus tard d&eacute;plac&eacute;es vers
	  leur emplacement correct.  Parce que la r&eacute;gion de trace
	  est une petite r&eacute;gion contigu&euml; sur le disque,
	  il n'y a pas de grandes distances de d&eacute;placement
	  pour les t&ecirc;tes des disques, m&ecirc;me durant
	  les op&eacute;rations importantes, donc ces op&eacute;rations
	  sont plus rapides que les mises &agrave; jour synchrones.
	  De plus la complexit&eacute; de l'impl&eacute;mentation
	  est relativement
	  limit&eacute;e, donc le risque de pr&eacute;sence de bogues est
	  faible. Un inconv&eacute;nient est que toutes les
	  m&eacute;ta-donn&eacute;es sont &eacute;crites deux fois (une fois
	  dans la r&eacute;gion de trace et une fois sur l'emplacement
	  correct) donc pour un fonctionnement normal, une baisse
	  des performances pourra en r&eacute;sulter.  D'autre part,
	  dans le cas d'un crash, toutes les op&eacute;rations sur les
	  m&eacute;ta-donn&eacute;es en attente peuvent rapidement
	  &ecirc;tre annul&eacute;es ou compl&eacute;t&eacute;es
	  &agrave; partir de la zone de trace apr&egrave;s le
	  red&eacute;marrage du syst&egrave;me, ayant pour
	  r&eacute;sultat un d&eacute;marrage rapide du
	  syst&egrave;me de fichiers.</para>

	<para>Kirk McKusick, le d&eacute;veloppeur du FFS de Berkeley,
	  a r&eacute;solu le probl&egrave;me avec les
	  &ldquo;Soft Updates&rdquo;:
	  toutes les mises &agrave; jour des m&eacute;ta-donn&eacute;es sont
	  conserv&eacute;es en m&eacute;moire et inscrites sur le disque
	  selon une s&eacute;quence ordonn&eacute;e (&ldquo;mise
	  &agrave; jour ordonn&eacute;e des m&eacute;ta-donn&eacute;es&rdquo;).
	  Ceci a pour effet, dans le cas d'un nombre d'op&eacute;rations
	  sur les m&eacute;ta-donn&eacute;es important, que les
	  derni&egrave;res mises &agrave; jour sur un &eacute;l&eacute;ment
	  &ldquo;attrapent&rdquo; les premi&egrave;res si ces
	  derni&egrave;res sont encore en m&eacute;moire et n'ont pas
	  encore &eacute;t&eacute; inscrites sur le disque.  Donc toutes
	  les op&eacute;rations sur, par exemple, un r&eacute;pertoire sont
	  g&eacute;n&eacute;ralement effectu&eacute;es en
	  m&eacute;moire avant que la mise &agrave; jour ne soit
	  &eacute;crite sur le disque (les blocs de donn&eacute;es
	  sont ordonn&eacute;s en fonction de leur position de
	  sorte &agrave; ce qu'ils ne soient pas sur le disque avant leur
	  m&eacute;ta-donn&eacute;es).  Si le syst&egrave;me
	  crash, cela provoque un &ldquo;retour dans les traces&rdquo;
	  implicite: toutes les op&eacute;rations qui n'ont pas
	  trouv&eacute; leur chemin vers le disque apparaissent comme si
	  elles n'avaient jamais exist&eacute;.  Un &eacute;tat
	  coh&eacute;rent du syst&egrave;me de fichiers est maintenu et
	  appara&icirc;t comme &eacute;tant celui de 30 ou 60 secondes
	  plus t&ocirc;t.  L'algorithme utilis&eacute; garantie que toutes les
	  ressources utilis&eacute;es soient marqu&eacute;es
	  avec leur bons &ldquo;bitmaps&rdquo;: blocs et inodes.
	  Apr&egrave;s un crash, les seules erreurs d'allocation de
	  ressources qui apparaissent sont les ressources qui ont
	  &eacute;t&eacute; marqu&eacute;es comme
	  &ldquo;utilis&eacute;es&rdquo; et qui sont en fait
	  &rdquo;libre&rdquo;.  &man.fsck.8; reconna&icirc;t cette
	  situation, et lib&egrave;re les ressources qui ne sont plus
	  utilis&eacute;es.  On peut ignorer sans risque l'&eacute;tat
	  &ldquo;sale&rdquo; d'un syst&egrave;me de fichiers apr&egrave;s un
	  crash en for&ccedil;ant sont montage avec <command>mount
	  -f</command>.  Afin de lib&eacute;rer les ressources qui peuvent
	  &ecirc;tre inutilis&eacute;es, &man.fsck.8; doit
	  &ecirc;tre ex&eacute;cut&eacute; plus tard.
	  C'est l'id&eacute;e qu'il y a derri&egrave;re le
	  &ldquo;<emphasis>background fsck</emphasis>&rdquo; (fsck en
	  t&acirc;che de fond): au d&eacute;marrage du syst&egrave;me, seule
	  un &ldquo;<emphasis>snapshot</emphasis>&rdquo; (photographie)
	  du syst&egrave;me de fichiers est prise.  La commande
	  <command>fsck</command> peut &ecirc;tre
	  ex&eacute;cut&eacute;e plus tard sur ce syst&egrave;me de
	  fichiers.  Tous les syst&egrave;mes de fichiers peuvent
	  &ecirc;tre mont&eacute;s &ldquo;sales&rdquo;, donc le
	  syst&egrave;me passe en
	  mode multi-utilisateurs.  Ensuite, les
	  <command>fsck</command> en t&acirc;che de fond seront
	  programm&eacute;s pour tous les syst&egrave;mes de fichiers pour
	  lesquels c'est n&eacute;cessaire, pour lib&eacute;rer les ressources
	  qui peuvent &ecirc;tre inutilis&eacute;es (les syst&egrave;mes
	  qui n'utilisent pas les &lsquo;Soft Updates&rdquo; ont
	  toujours besoin du <command>fsck</command>
	  en avant plan).</para>

	<para>L'avantage est que les op&eacute;rations sur les
	  m&eacute;ta-donn&eacute;es sont presque aussi rapides que les
	  mises &agrave; jour asynchrones (i.e. plus rapide qu'avec le
	  &ldquo;<emphasis>logging</emphasis>&rdquo; - tra&ccedil;age,
	  qui doit &eacute;crire les m&eacute;ta-donn&eacute;es deux
	  fois).  Les inconv&eacute;nients sont la complexit&eacute; du code
	  (impliquant un haut risque de bogues dans une zone qui est
	  hautement sensible en raison de risque perte de donn&eacute;es
	  utilisateur), et une plus grande consommation en m&eacute;moire.
	  De plus il y a quelques particularit&eacute;s que l'on peut
	  rencontrer lors de l'utilisation.  Apr&egrave;s un crash,
	  l'&eacute;tat du syst&egrave;me appara&icirc;t &ecirc;tre en quelque
	  sorte &ldquo;plus vieux&rdquo;.  Dans des situations
	  o&ugrave; l'approche synchrone classique aurait donn&eacute; lieu
	  &agrave; des fichiers de taille nulle restant apr&egrave;s le
	  <command>fsck</command>, ces fichiers n'existent pas du
	  tout avec un syst&egrave;me de fichiers utilisant les
	  &ldquo;Soft Updates&rdquo; parce que ni les
	  m&eacute;ta-donn&eacute;es ni les contenus de fichiers n'ont
	  jamais &eacute;t&eacute; inscrits sur le disque.  L'espace disque
	  n'est pas rendu tant que les mises &agrave; jour n'ont pas
	  &eacute;t&eacute; inscrites sur le disque, ce qui peut se produire
	  quelques temps apr&egrave;s l'ex&eacute;cution de
	  <command>rm</command>.  Cela peut &ecirc;tre &agrave;
	  l'origine de probl&egrave;mes quand on installe une grande
	  quantit&eacute; de donn&eacute;es sur un syst&egrave;me de fichiers
	  qui ne dispose pas de suffisamment d'espace pour contenir tous les
	  fichiers deux fois.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Param&eacute;trer les limitations du noyau</title>

    <indexterm><primary>Param&eacute;trer les limitations du noyau</primary></indexterm>

    <sect2 id="file-process-limits">
      <title>Limitations sur les fichiers et les processus</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>

	<para>Le param&egrave;tre <varname>kern.maxfiles</varname>
	  peut &ecirc;tre augment&eacute; ou diminu&eacute;
	  en fonction des besoins du syst&egrave;me.  Cette variable
	  indique le nombre maximal de descripteurs de fichier sur
	  votre syst&egrave;me.  Quand la table de descripteurs de fichier
	  est pleine, le message <errorname>file: table is
	  full</errorname> s'affichera r&eacute;guli&egrave;rement dans le
	  tampon des messages syst&egrave;me, qui peut &ecirc;tre
	  visualis&eacute; avec la commande
	  <command>dmesg</command>.</para>

	<para>Chaque fichier ouvert, chaque &ldquo;socket&rdquo;,
	  ou chaque emplacement en pile utilise un descripteur de fichier.
	  Un serveur important peut facilement demander plusieurs
	  milliers de descripteurs de fichiers, en fonction du type et
	  du nombre de services s'ex&eacute;cutant en m&ecirc;me temps.</para>

	<para>La valeur par d&eacute;faut de <varname>kern.maxfile</varname>
	  est fix&eacute;e par l'option <option>MAXUSERS</option>
	  dans votre fichier de configuration du noyau.
	  <varname>kern.maxfiles</varname> augmente proportionnellement
	  avec la valeur de <option>MAXUSERS</option>.  Quand vous
	  compilez un noyau sur mesure, il est bon de param&eacute;trer cette
	  option en fonction de l'utilisation de votre syst&egrave;me.  Ce
	  nombre fixe la plupart des limites pr&eacute;-d&eacute;finies du
	  noyau.
	  M&ecirc;me si une machine de production pourra ne pas avoir en
	  r&eacute;alit&eacute; 256 utilisateurs connect&eacute;s
	  simultan&eacute;ment, les ressources requises pourront &ecirc;tre
	  semblables pour un serveur web important.</para>

	<note><para>A partir de FreeBSD 4.5, positionner
	  <option>MAXUSERS</option> &agrave; <literal>0</literal> dans votre
	  fichier de configuration du noyau, le syst&egrave;me choisira une
	  valeur raisonnable par d&eacute;faut bas&eacute;e sur la
	  quantit&eacute; de m&eacute;moire pr&eacute;sente sur votre
	  syst&egrave;me.</para></note>

      </sect3>
    </sect2>
    <sect2>
      <title>Limitations r&eacute;seau</title>

      <para>L'option du noyau <option>NMBCLUSTERS</option> fixe la
	quantit&eacute; de &ldquo;mbuf&rdquo;s disponibles pour le
	syst&egrave;me.  Un serveur &agrave; fort trafic avec un nombre faible
	de &ldquo;mbuf&rdquo;s sous-emploiera les capacit&eacute;s de FreeBSD.
	Chaque &ldquo;cluster&rdquo; repr&eacute;sente approximativement 2KO
	de m&eacute;moire, donc une valeur de 1024 repr&eacute;sente 2
	m&eacute;gaoctets de m&eacute;moire noyau r&eacute;serv&eacute;e
	pour les tampons r&eacute;seau.  Un simple calcul peut
	&ecirc;tre fait pour d&eacute;terminer combien sont
	n&eacute;cessaires.  Si vous avez un serveur web qui culmine &agrave;
	1000 connexions simultan&eacute;es, et que chaque connexion
	consomme un tampon de r&eacute;ception de 16KO et un tampon
	d'&eacute;mission de 16KO, vous avez approximativement besoin
	de 32MO de tampon r&eacute;seau pour couvrir les besoin du
	serveur web.  Un bon principe est de multiplier ce nombre
	par 2, soit 2x32 MO / 2KO = 64MO / 2KO =32768.</para>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Ajouter de l'espace de pagination</title>

    <para>Peu importe comment vous l'avez pens&eacute;, parfois un
      syst&egrave;me ne fonctionne pas comme pr&eacute;vu.  Si vous
      trouvez que vous avez besoin de plus d'espace de pagination, il
      est assez simple d'en rajouter.  Vous avez trois mani&egrave;res
      d'augmenter votre espace de pagination: ajouter un nouveau
      disque dur, activer la pagination sur NFS, et cr&eacute;er un fichier
      de pagination sur une partition existante.</para>

    <sect2 id="new-drive-swap">
      <title>Espace de pagination sur un nouveau disque dur</title>

      <para>La meilleur fa&ccedil;on d'ajouter de l'espace de pagination,
	bien s&ucirc;r, est d'utiliser ceci comme excuse pour ajouter un
	autre disque dur.  Vous pouvez toujours utiliser un autre
	disque apr&egrave;s tout.  Si vous pouvez faire cela, allez relire la
	discussion sur <ulink
	url="configtuning-initial.html#SWAP-DESIGN">l'espace de
	pagination</ulink> dans la section <ulink
	url="configtuning-initial.html">Configuration initiale</ulink>
	du Manuel pour des suggestions sur la meilleure fa&ccedil;on
	d'arranger votre espace de pagination.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Espace de pagination sur NFS</title>

      <para>L'espace de pagination sur NFS n'est recommand&eacute; que si
	vous n'avez pas de disque dur local sur lequel avoir l'espace
	de pagination.  Avoir son espace de pagination sur NFS sera
	lent et inefficace sur les versions de FreeBSD ant&eacute;rieures
	&agrave; la branche 4.X.  c'est raisonnablement rapide et efficace
	sur 4.0-RELEASE et suivante.  M&ecirc;me avec une version
	r&eacute;cente de FreeBSD, la pagination sur NFS sera limit&eacute;e
	par la bande passante du r&eacute;seau et sera un fardeau
	suppl&eacute;mentaire pour le serveur NFS.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>Fichiers de pagination</title>

      <para>Vous pouvez cr&eacute;er un fichier d'une taille
	sp&eacute;cifique pour	l'utiliser comme fichier de pagination.
	Dans notre exemple nous utiliserons un fichier de 64MO appel&eacute;
	<filename>/usr/swap0</filename>.  Vous pouvez, bien s&ucirc;r,
	utiliser le nom de votre choix.</para>

      <example>
        <title>Cr&eacute;er un fichier de pagination</title>

      <orderedlist>
        <listitem>
          <para>Soyez s&ucirc;r que votre configuration de noyau inclut le
	    pilote vnode.  Ce n'est <emphasis>pas</emphasis> le cas dans
	    les versions r&eacute;centes de
	    <filename>GENERIC</filename>.</para>

          <programlisting>pseudo-device   vn 1   #Vnode driver (turns a file into a device)</programlisting>
        </listitem>

	<listitem>
	  <para>Cr&eacute;ez un p&eacute;riph&eacute;rique vn:</para>
	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Cr&eacute;ez un fichier de pagination
	    (<filename>/usr/swap0</filename>):</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	</listitem>

	<listitem>
	  <para>Fixez les bonnes permissions sur
	    <filename>/usr/swap0</filename>:</para>

	  <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Activez le fichier de pagination dans
	    <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	</listitem>

	<listitem>

          <para>Red&eacute;marrez la machine ou activez directement le
	    fichier de pagination:</para>

          <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
        </listitem>
      </orderedlist>

      </example>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
