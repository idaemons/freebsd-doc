<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     $Id: chapter.sgml,v 1.5 2002-11-17 20:35:52 blackend Exp $
     Original revision: 1.86
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>R&eacute;&eacute;crit par </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>Quelques bases d'Unix</title>
  &trans.a.fonvieille;

  <sect1>
    <title>Synopsis</title>
    <indexterm><primary>bases</primary></indexterm>


   <para>Le chapitre suivant couvrira les commandes et fonctionnalit&eacute;s
     de base du syst&egrave;me d'exploitation FreeBSD.  La plupart de ces
     informations sera valable pour n'importe quel syst&egrave;me
     d'exploitation Unix.  Soyez libre de passer ce chapitre si vous
     &ecirc;tes familier avec ces informations.  Si vous &ecirc;tes nouveau
     &agrave;
     FreeBSD, alors vous voudrez certainement lire attentivement ce
     chapitre.</para>

    <para>Apr&egrave;s la lecture de ce chapitre, vous saurez:</para>

    <itemizedlist>
      <listitem>
	<para>Comment les permissions de fichier d'Unix
	  fonctionnent.</para>
      </listitem>
      <listitem>
	<para>Ce que sont les processus, daemons et signaux.</para>
      </listitem>
      <listitem>
	<para>Ce qu'est un interpr&eacute;teur de commande, et comment changer
	  votre environnement de session par d&eacute;faut.</para>
      </listitem>
      <listitem>
	<para>Comment utiliser les &eacute;diteurs de texte de base.</para>
      </listitem>
      <listitem>
	<para>Comment lire les pages de manuel pour plus
	  d'information.</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="permissions">
    <title>Permissions</title>
    <indexterm><primary>Unix</primary></indexterm>

    <para>FreeBSD, &eacute;tant un descendant direct de l'Unix BSD, est
      bas&eacute; sur plusieurs concepts cl&eacute;s d'Unix.  Le premier,
      et le plus prononc&eacute;, est le fait que FreeBSD est un
      syst&egrave;me d'exploitation multi-utilisateurs.  Le syst&egrave;me
      peut g&eacute;rer plusieurs utilisateurs travaillant tous
      simultan&eacute;ment sur des t&acirc;ches compl&egrave;tement
      ind&eacute;pendantes.  Le syst&egrave;me est responsable du partage
      correct et de la gestion des requ&ecirc;tes pour les
      p&eacute;riph&eacute;riques mat&eacute;riels, la m&eacute;moire,
      et le temps CPU de fa&ccedil;on &eacute;quitable entre chaque
      utilisateur.</para>

    <para>Puisque le syst&egrave;me est capable de supporter des utilisateurs
      multiples, tout ce que le syst&egrave;me g&egrave;re poss&egrave;de un
      ensemble de permissions d&eacute;finissant qui peut &eacute;crire, lire,
      et ex&eacute;cuter la ressource.  Ces permissions sont stock&eacute;es
      sous forme de deux octets divis&eacute;s en trois parties, une pour le
      propri&eacute;taire du fichier, une pour le groupe auquel appartient le
      fichier, et une autre pour le reste du monde.
      Cette repr&eacute;sentation num&eacute;rique fonctionne comme
      ceci:</para>

    <indexterm><primary>permissions</primary></indexterm>
    <indexterm>
      <primary>permissions de fichier</primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Valeur</entry>
	    <entry>Permission</entry>
	    <entry>Contenu du r&eacute;pertoire</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Pas d'acc&egrave;s en lecture, pas d'acc&egrave;s en
	      &eacute;criture,
	      pas d'acc&egrave;s en ex&eacute;cution</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Pas d'acc&egrave;s en lecture, pas d'acc&egrave;s en
	      &eacute;criture, ex&eacute;cution</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Pas d'acc&egrave;s en lecture, &eacute;criture, pas
	      d'acc&egrave;s en ex&eacute;cution</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Pas d'acc&egrave;s en lecture, &eacute;criture,
	      ex&eacute;cution</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lecture, pas d'acc&egrave;s en &eacute;criture, pas
	      d'acc&egrave;s en ex&eacute;cution</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lecture, pas d'acc&egrave;s en &eacute;criture,
	      ex&eacute;cution</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lecture, &eacute;criture, pas d'acc&egrave;s en
	      ex&eacute;cution</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lecture, &eacute;criture, ex&eacute;cution</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>r&eacute;pertoires</primary></indexterm>

    <para>Vous pouvez utiliser l'option <option>-l</option> avec la
      commande &man.ls.1; pour afficher le contenu du r&eacute;pertoire
      sous forme une longue et d&eacute;taill&eacute;e qui inclut une colonne
      avec des informations sur les permissions d'acc&egrave;s des fichiers
      pour le propri&eacute;taire, le groupe, et le reste du monde.  Voici
      comment est divis&eacute;e la premi&egrave;re colonne de l'affichage
      g&eacute;n&eacute;r&eacute; par <command>ls -l</command>:</para>

    <screen>-rw-r--r--</screen>

    <para>Le premier caract&egrave;re (le plus &agrave; gauche) indique
      si c'est un fichier normal, un r&eacute;pertoire, ou
      un p&eacute;riph&eacute;rique mode caract&egrave;re,
      une socket, ou tout autre pseudo-p&eacute;riph&eacute;rique.
      Dans ce cas, <literal>-</literal>
      indique un fichier normal.  Les trois caract&egrave;res suivants,
      <literal>rw-</literal> dans cet exemple, donnent les
      permissions pour le propri&eacute;taire du fichier.  Les trois
      caract&egrave;res qui suivent, <literal>r--</literal>, donnent les
      permissions pour le groupe auquel appartient le fichier.
      Les trois derniers caract&egrave;res, <literal>r--</literal>,
      donnent les permissions pour le reste du
      monde. Un tiret signifie que la permission est d&eacute;sactiv&eacute;e.
      Dans le cas de ce fichier, les permissions sont telles que le
      propri&eacute;taire peut lire et &eacute;crire le fichier, le groupe
      peut lire le fichier, et le reste du monde peut seulement lire le fichier.
      D'apr&egrave;s la table ci-dessus, les permissions pour ce fichier
      seraient <literal>644</literal>, o&ugrave; chaque chiffre
      repr&eacute;sente les
      trois parties des permissions du fichier.</para>

    <para>Tout cela est bien beau, mais comment le syst&egrave;me
      contr&ocirc;le les permissions sur les p&eacute;riph&eacute;riques?
      En fait FreeBSD traite la plupart des p&eacute;riph&eacute;riques
      sous la forme d'un fichier que les programmes peuvent ouvrir, lire,
      et &eacute;crire des donn&eacute;es dessus comme tout autre fichier.
      Ces p&eacute;riph&eacute;riques sp&eacute;ciaux sont stock&eacute;s
      dans le r&eacute;pertoire <filename>/dev</filename>.</para>

    <para>Les r&eacute;pertoires sont aussi trait&eacute;s comme des fichiers.
      Ils ont des droits en lecture, &eacute;criture et ex&eacute;cution.
      Le bit d'ex&eacute;cution pour un r&eacute;pertoire a une signification
      l&eacute;g&egrave;rement diff&eacute;rente que pour les fichiers.
      Quand un r&eacute;pertoire est marqu&eacute; ex&eacute;cutable, cela
      signifie que l'on peut se d&eacute;placer dedans, i.e. il est possible
      d'utiliser &ldquo;cd&rdquo;.  Ceci signifie &eacute;galement qu'&agrave;
      l'int&eacute;rieur du r&eacute;pertoire il est possible d'acc&eacute;der
      aux fichiers dont les noms sont connues (en fonction, bien s&ucirc;r,
      des permissions sur les fichiers eux-m&ecirc;mes).</para>

    <para>En particulier, afin d'&ecirc;tre capable d'obtenir la liste du
      contenu d'un r&eacute;pertoire, la permission de lecture doit &ecirc;tre
      positionn&eacute;e sur le r&eacute;pertoire, tandis que pour effacer un
      fichier dont on conna&icirc;t le nom, il est n&eacute;cessaire d'avoir
      les droits d'&eacute;criture <emphasis>et</emphasis> d'ex&eacute;cution
      sur le r&eacute;pertoire contenant le fichier.</para>

    <para>Il y a d'autres types de permissions, mais elles sont
      principalement employ&eacute;es dans des circonstances
      sp&eacute;ciales comme les binaires &ldquo;setuid&rdquo; et
      les r&eacute;pertoires &ldquo;sticky&rdquo;.  Si
      vous d&eacute;sirez plus d'information sur les permissions de fichier et
      comment les positionner, soyez s&ucirc;r de consulter la page de manuel
      &man.chmod.1;.</para>
  </sect1>

  <sect1 id="dirstructure">
    <title>Organisation de l'arborescence des r&eacute;pertoires</title>
    <indexterm><primary>hi&eacute;rarchie des r&eacute;pertoires</primary></indexterm>

    <para>L'organisation de l'arborescence des r&eacute;pertoires de FreeBSD
      est essentielle pour obtenir une compr&eacute;hension globale du
      syst&egrave;me.  Le concept le plus important &agrave; saisir est
      celui du r&eacute;pertoire racine, &ldquo;/&rdquo;.
      Ce r&eacute;pertoire est le premier a &ecirc;tre mont&eacute; au
      d&eacute;marrage et il contient le syst&egrave;me de base
      n&eacute;cessaire pour pr&eacute;parer le syst&egrave;me d'exploitation
      au fonctionnement multi-utilisateurs.
      Le r&eacute;pertoire racine contient &eacute;galement les
      points de montage pour tous les autres syst&egrave;mes de fichiers que
      vous pourriez vouloir monter.</para>

    <para>Un point de montage est un r&eacute;pertoire o&ugrave; peuvent
      &ecirc;tre greff&eacute;s des syst&egrave;mes de fichiers
      suppl&eacute;mentaires au syst&egrave;me de
      fichiers racine.  Les points de montage standards incluent
      <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/mnt</filename>, et <filename>/cdrom</filename>.  Ces
      r&eacute;pertoires sont en g&eacute;n&eacute;ral
      r&eacute;f&eacute;renc&eacute;s par des entr&eacute;es dans le
      fichier <filename>/etc/fstab</filename>.
      <filename>/etc/fstab</filename> est une table des divers syst&egrave;mes
      de fichiers et de leur point de montage utilis&eacute; comme
      r&eacute;f&eacute;rence par le syst&egrave;me.
      La plupart des syst&egrave;mes de fichiers pr&eacute;sents dans
      <filename>/etc/fstab</filename> sont mont&eacute;s automatiquement au
      moment du d&eacute;marrage par la proc&eacute;dure &man.rc.8; &agrave;
      moins que
      l'option <option>noauto</option> soit pr&eacute;sente.  Consultez la page
      de manuel de &man.fstab.5; pour plus d'information sur le format
      du fichier <filename>/etc/fstab</filename> et des options qu'il
      contient.</para>

    <para>Une description compl&egrave;te de l'arborescence du syst&egrave;me de
      fichiers est disponible dans la page de manuel &man.hier.7;.  Pour
      l'instant, une br&egrave;ve vue d'ensemble des r&eacute;pertoires les plus
      courants suffira.</para>

    <para>
      <informaltable frame="none">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>R&eacute;pertoire</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody>
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>R&eacute;pertoire racine du syst&egrave;me de
		fichiers.</entry>
            </row>

	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Programmes utilisateur fondamentaux aux deux modes
		de fonctionnement mono et multi-utilisateurs.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Programmes et fichiers de configuration utilis&eacute;s
		durant le processus de d&eacute;marrage du
		syst&egrave;me.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Fichiers de configuration par d&eacute;faut du processus
		de d&eacute;marrage; voir la page de manuel
		&man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Fichiers sp&eacute;ciaux de p&eacute;riph&eacute;rique;
		voir la page de manuel &man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Proc&eacute;dures et fichiers de configuration du
		syst&egrave;me.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Fichiers de configuration du syst&egrave;me par
		d&eacute;faut; voir la page de manuel &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>Fichiers de configuration pour les agents de
		transport du courrier &eacute;lectronique comme
		&man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry>Fichiers de configuration de <command>named</command>;
		voir la page de manuel &man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>Proc&eacute;dures qui sont ex&eacute;cut&eacute;es de
		fa&ccedil;on quotidienne, hebdomadaire et mensuelle par
		l'interm&eacute;diaire de &man.cron.8;;
		voir la page de manuel &man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry>Fichiers de configuration de <command>ppp</command>; voir
		la page de manuel &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>R&eacute;pertoire vide habituellement utilis&eacute;
		par les administrateurs syst&egrave;me comme un point de
		montage temporaire.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Le syst&egrave;me de fichiers pour les processus; voir les
		pages de manuel &man.procfs.5;, &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry>R&eacute;pertoire personnel du compte
		<username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>Programmes syst&egrave;mes et utilitaires syst&egrave;mes
		fondamentaux aux environnements mono et multi-utilisateurs.
		</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
	      <entry>Programmes utilis&eacute;s dans un environnement
		autonome.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Fichiers temporaires, g&eacute;n&eacute;ralement un
		syst&egrave;me de fichiers en m&eacute;moire &man.mfs.8;
		(le contenu de <filename class="directory">/tmp</filename>
		n'est en g&eacute;n&eacute;ral PAS pr&eacute;serv&eacute;
		par un red&eacute;marrage du syst&egrave;me).</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>La majorit&eacute; des utilitaires et applications
		utilisateur.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Utilitaires g&eacute;n&eacute;raux, outils de
		programmation, et applications.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Fichiers d'en-t&ecirc;te C standard.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Ensemble des biblioth&egrave;ques.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Divers fichiers de donn&eacute;es de service.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>Utilitaires et daemons syst&egrave;me
		(ex&eacute;cut&eacute;s par d'autres programmes).</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>Ex&eacute;cutables, biblioth&egrave;ques, etc...  Egalement
		utilis&eacute; comme destination de d&eacute;faut pour les
		logiciels port&eacute;s pour FreeBSD.  Dans
		<filename>/usr/local</filename>, l'organisation
		g&eacute;n&eacute;rale
		d&eacute;crite par la page de manuel &man.hier.7; pour
		<filename>/usr</filename> devrait &ecirc;tre utilis&eacute;e.
		Exceptions faites du r&eacute;pertoire man qui est directement
		sous <filename>/usr/local</filename> plut&ocirc;t que sous
		<filename>/usr/local/share</filename>, et la
		documentation des logiciels port&eacute;s est dans
		<filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Arborescence cible sp&eacute;cifique &agrave; une
		architecture produite par la compilation de l'arborescence
		<filename>/usr/src</filename>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
	      <entry>Le catalogue des logiciels port&eacute;s
		(optionnel).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>Utilitaires et daemons syst&egrave;me
		(ex&eacute;cut&eacute;s par les utilisateurs).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Fichiers ind&eacute;pendants de l'architecture.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>Fichiers source FreeBSD et/ou locaux.</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>Ex&eacute;cutables, biblioth&egrave;ques etc... de la
		distribution d'X11R6 (optionnel).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Fichiers de traces, fichiers temporaires, et
		fichiers tampons.
	      </entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Divers fichiers de trace du syst&egrave;me.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Bo&icirc;tes aux lettres des utilisateurs.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Divers r&eacute;pertoires tampons des syst&egrave;mes
		de courrier &eacute;lectronique et d'impression.
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Fichiers temporaires qui sont conserv&eacute;s durant les
		red&eacute;marrages.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>Tables NIS.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 id="mount-unmount">
    <title>Monter et d&eacute;monter des syst&egrave;mes de fichiers</title>

    <para>Le syst&egrave;me de fichiers peut &ecirc;tre vu comme un arbre
      enracin&eacute; sur le r&eacute;pertoire <filename>/</filename>.
      <filename>/dev</filename>, <filename>/usr</filename>, et les
      autres r&eacute;pertoires dans le r&eacute;pertoire racine sont des
      branches, qui peuvent avoir leurs propres branches, comme
      <filename>/usr/local</filename>, et ainsi de suite.</para>

    <indexterm><primary>syst&egrave;me de fichiers racine</primary></indexterm>
    <para>Il y a diverses raisons pour h&eacute;berger certains de ces
      r&eacute;pertoires sur des syst&egrave;mes de fichiers
      s&eacute;par&eacute;s.
      <filename>/var</filename> contient les r&eacute;pertoires
      <filename>log/</filename>, <filename>spool/</filename>, et divers
      types de fichiers temporaires, et en tant que tels, peuvent voir
      leur taille augmenter de fa&ccedil;on importante.
      Remplir le syst&egrave;me de
      fichiers racine n'est pas une bonne id&eacute;e, aussi s&eacute;parer
      <filename>/var</filename> de <filename>/</filename> est souvent
      favorable.</para>

    <para>Une autre raison courante de placer certains r&eacute;pertoires sur
      d'autres syst&egrave;mes de fichiers est s'ils doivent &ecirc;tre
      h&eacute;berg&eacute;s sur
      des disques physiques s&eacute;par&eacute;s, ou sur des disques virtuels
      s&eacute;par&eacute;s, comme les <link linkend="nfs">syst&egrave;mes de
      fichiers r&eacute;seau</link>, ou les lecteurs de CDROM.</para>

    <sect2 id="disks-fstab">
      <title>Le fichier <filename>fstab</filename></title>
      <indexterm>
	<primary>syst&egrave;mes de fichiers</primary>
	<secondary>mont&eacute;s avec fstab</secondary>
      </indexterm>

      <para>Durant le <link linkend="boot">processus de
	d&eacute;marrage</link>, les syst&egrave;mes de fichiers list&eacute;s
	dans <filename>/etc/fstab</filename> sont automatiquement
	mont&eacute;s (&agrave; moins qu'il ne soient list&eacute;s avec
	l'option <option>noauto</option>).</para>

      <para>Le fichier <filename>/etc/fstab</filename> contient une
	liste de lignes au format suivant:</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>Un nom de p&eacute;riph&eacute;rique (qui devrait exister),
	      comme expliqu&eacute; dans la
	      <xref linkend="disks-naming">.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem><para>Un r&eacute;pertoire (qui devrait exister), sur
	    lequel sera mont&eacute; le syst&egrave;me de fichier.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem><para>Le type de syst&egrave;me de fichiers &agrave;
	      indiquer &agrave;
	      &man.mount.8;.  Le syst&egrave;me de fichiers par d&eacute;faut de
	      FreeBSD est l'<literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem><para>Soit <option>rw</option> pour des syst&egrave;mes de
	      fichiers &agrave; lecture-&eacute;criture, soit
	      <option>ro</option> pour des syst&egrave;mes de fichiers
	      &agrave; lecture seule, suivi par toute
	      option qui peut s'av&eacute;rer n&eacute;cessaire.  Une option
	      courante est <option>noauto</option> pour les syst&egrave;mes de
	      fichiers qui ne sont normalement pas mont&eacute;s durant la
	      s&eacute;quence de d&eacute;marrage.  D'autres options sont
	      pr&eacute;sent&eacute;es dans la page de manuel &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

         <listitem><para>C'est utilis&eacute; par &man.dump.8; pour
	     d&eacute;terminer quels syst&egrave;mes de fichiers
	     n&eacute;cessitent
	     une sauvegarde.  Si ce champ est absent, une valeur
	     de z&eacute;ro est suppos&eacute;e.</para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>passno</literal></term>

         <listitem>
           <para>Ceci d&eacute;termine l'ordre dans lequel les syst&egrave;mes
	     de fichiers devront &ecirc;tre v&eacute;rifi&eacute;s.
	     Les syst&egrave;mes de fichiers
	     qui doivent &ecirc;tre ignor&eacute;s devraient avoir leur
	     <literal>passno</literal> positionn&eacute; &agrave; z&eacute;ro.
	     Le syst&egrave;me de fichiers racine (qui doit &ecirc;tre
	     v&eacute;rifi&eacute; avant tout le reste) devrait avoir son
	     <literal>passno</literal> positionn&eacute; &agrave; un,
	     et les options <literal>passno</literal> des autres
	     syst&egrave;mes fichiers devraient &ecirc;tre positionn&eacute;es
	     &agrave; des valeurs sup&eacute;rieures &agrave; un.  Si plus
	     d'un syst&egrave;me de fichiers ont le m&ecirc;me
	     <literal>passno</literal> alors &man.fsck.8; essaiera
	     de v&eacute;rifier les syst&egrave;mes de fichiers
	     en parall&egrave;le si c'est possible.</para>
         </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title>La commande <command>mount</command></title>
      <indexterm>
	<primary>syst&egrave;mes de fichiers</primary>
	<secondary>montage</secondary>
      </indexterm>

      <para>La commande &man.mount.8; est ce qui est finalement
	utilis&eacute; pour monter des syst&egrave;mes de fichiers.</para>

      <para>Dans sa forme la plus simple, vous utilisez:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Il y beaucoup d'options, comme mentionn&eacute; dans la page de
	manuel &man.mount.8;, mais les plus courantes sont:</para>

      <variablelist>
	<title>Options de montage</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Monte tous les syst&egrave;mes de fichiers list&eacute;s dans
	      <filename>/etc/fstab</filename>.  Exception faite de ceux
	      marqu&eacute;s comme &ldquo;noauto&rdquo;, ou exclus par
	      le drapeau <option>-t</option>, ou encore ceux qui sont
	      d&eacute;j&agrave; mont&eacute;s.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>Tout effectuer &agrave; l'exception de l'appel
	      syst&egrave;me r&eacute;el.  Cette option est utile
	      conjointement avec le drapeau <option>-v</option> pour
	      d&eacute;terminer ce que &man.mount.8; est en train
	      d'essayer de faire.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Force le montage d'un syst&egrave;me de fichiers non propre
	      (dangereux), ou force la r&eacute;vocation de l'acc&egrave;s en
	      &eacute;criture quand on modifie l'&eacute;tat de montage d'un
	      syst&egrave;me de fichiers de l'acc&egrave;s
	      lecture-&eacute;criture &agrave; l'acc&egrave;s
	      lecture seule.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
          <term><option>-r</option></term>

	  <listitem>
	    <para>Monte le syst&egrave;me de fichiers en lecture seule.  C'est
	      identique &agrave; l'utilisation de l'argument
	      <option>rdonly</option> avec l'option
	      <option>-o</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>Monte le syst&egrave;me de fichiers comme &eacute;tant
	    du type de syst&egrave;me donn&eacute;, ou monte
	      seulement les syst&egrave;mes de fichiers du type donn&eacute;,
	      si l'option <option>-a</option> est pr&eacute;cis&eacute;e.</para>

	    <para>&ldquo;ufs&rdquo; est le type de syst&egrave;me de
	      fichiers par d&eacute;faut.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Mets &agrave; jour les options de montage sur le
	      syst&egrave;me de fichiers.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Rends la commande prolixe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Monte le syst&egrave;me de fichiers en
	      lecture-&eacute;criture.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>L'option <option>-o</option> accepte une liste d'options
	s&eacute;par&eacute;es par des virgules, dont les suivantes:</para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	  <listitem>
	    <para>Ne pas prendre en compte les p&eacute;riph&eacute;riques
	      sp&eacute;ciaux sur le syst&egrave;me de fichiers.  C'est une
	      option de s&eacute;curit&eacute; utile.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
              <para>Ne pas autoriser l'ex&eacute;cution de binaires sur ce
		syst&egrave;me de fichiers.  C'est &eacute;galement une
		option de s&eacute;curit&eacute; utile.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>Ne pas prendre en compte les indicateurs setuid ou setgid
	      sur le syst&egrave;me de fichiers.  C'est &eacute;galement une
	      option de s&eacute;curit&eacute; utile.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>La commande <command>umount</command></title>
      <indexterm>
	<primary>syst&egrave;mes de fichiers</primary>
	<secondary>d&eacute;montage</secondary>
      </indexterm>

      <para>La commande &man.umount.8; prend, comme param&egrave;tre, un des
	points de montage, un nom de p&eacute;riph&eacute;rique, ou
	l'option <option>-a</option> ou <option>-A</option>.</para>

      <para>Toutes les formes acceptent <option>-f</option> pour forcer
	de d&eacute;montage, et <option>-v</option> pour le mode
	prolixe.  Soyez averti que l'utilisation de <option>-f</option>
	n'est g&eacute;n&eacute;ralement pas une bonne id&eacute;e.
	D&eacute;monter de force des syst&egrave;mes de fichiers pourrait
	faire planter l'ordinateur ou endommager les donn&eacute;es sur
	le syst&egrave;me de fichiers.</para>

      <para>Les options <option>-a</option> et <option>-A</option>
	sont utilis&eacute;es pour d&eacute;monter tous les syst&egrave;mes
	de fichiers actuellement mont&eacute;s, &eacute;ventuellement
	modifi&eacute; par les types de syst&egrave;mes de fichiers
	list&eacute;s apr&egrave;s l'option <option>-t</option>.
	Cependant l'option <option>-A</option>, n'essaye pas de
	d&eacute;monter le syst&egrave;me de fichiers racine.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Processus</title>

    <para>FreeBSD est un syst&egrave;me d'exploitation multi-t&acirc;ches.
      Cela veut dire qu'il semble qu'il y ait plus d'un programme
      fonctionnant &agrave;
      la fois.  Tout programme fonctionnant &agrave; un moment donn&eacute; est
      appel&eacute; un <firstterm>processus</firstterm>.  Chaque commande que
      vous utiliserez lancera au moins un nouveau processus, et il y a
      de nombreux processus syst&egrave;me qui tournent constamment, maintenant
      ainsi les fonctionnalit&eacute;s du syst&egrave;me.</para>

    <para>Chaque processus est identifi&eacute; de fa&ccedil;on unique par
      un nombre appel&eacute; <firstterm>process ID</firstterm> (identifiant de
      processus), ou <firstterm>PID</firstterm>, et, comme pour les fichiers,
      chaque processus poss&egrave;de &eacute;galement un propri&eacute;taire
      et un groupe.  Les informations sur le propri&eacute;taire et le groupe
      sont utilis&eacute;es pour d&eacute;terminer quels fichiers et
      p&eacute;riph&eacute;riques sont accessibles au processus, en utilisant le
      principe de permissions de fichiers abord&eacute; plus t&ocirc;t.
      La plupart
      des processus ont &eacute;galement un processus parent.  Le processus
      parent est le processus qui les a lanc&eacute;s.  Par exemple, si vous
      tapez des commandes sous un interpr&eacute;teur de commandes, alors
      l'interpr&eacute;teur de commandes est un processus, et toute commande
      que vous lancez est aussi un processus.  Chaque processus que vous
      lancez de cette mani&egrave;re aura votre interpr&eacute;teur de
      commandes comme processus parent.
      Une exception &agrave; cela est le processus sp&eacute;cial
      appel&eacute; <command>init</command>.  <command>init</command> est
      toujours le premier processus, donc son PID est toujours 1.
      <command>init</command> est lanc&eacute; automatiquement par le noyau au
      d&eacute;marrage de FreeBSD.</para>

    <para>Deux commandes sont particuli&egrave;rement utiles pour voir les
      processus sur le syst&egrave;me, &man.ps.1; et &man.top.1;.  La
      commande &man.ps.1; est utilis&eacute;e pour afficher une liste statique
      des processus tournant actuellement, et peut donner leur PID, la
      quantit&eacute; de m&eacute;moire qu'ils utilisent, la ligne de
      commande par l'interm&eacute;diaire de laquelle ils ont
      &eacute;t&eacute; lanc&eacute;s, et ainsi de suite.
      La commande &man.top.1; affiche tous les processus, et actualise
      l'affichage r&eacute;guli&egrave;rement, de sorte que vous puissiez voir
      de fa&ccedil;on int&eacute;ractive ce que fait l'ordinateur.</para>

    <para>Par d&eacute;faut, &man.ps.1; n'affiche que les commandes que vous
      faites tourner et dont vous &ecirc;tes le propri&eacute;taire.  Par
      exemple:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Comme vous pouvez le voir dans cet exemple, la sortie de
      &man.ps.1; est organis&eacute;e en un certain nombre de colonnes.
      <literal>PID</literal> est l'identifiant de processus discut&eacute; plus
      t&ocirc;t.  Les PIDs sont assign&eacute;s &agrave; partir de 1, et
      vont jusqu'&agrave; 99999,
      et puis repassent &agrave; 1 quand le maximum est atteint.
      <literal>TT</literal> donne le terminal sur lequel tourne le
      programme, et peut &ecirc;tre pour le moment ignor&eacute; sans risque.
      <literal>STAT</literal> affiche l'&eacute;tat du programme, peut
      &ecirc;tre &eacute;galement ignor&eacute;.
      <literal>TIME</literal> est la dur&eacute;e d'utilisation du CPU&mdash;ce
      n'est pas n&eacute;cessairement le temps &eacute;coul&eacute; depuis
      que vous avez lanc&eacute; le programme, certains programmes passent
      beaucoup de temps &agrave; attendre que certaines choses se produisent
      avant qu'ils n'aient besoin de d&eacute;penser du temps CPU.
      Et enfin, <literal>COMMAND</literal> est la ligne de commande qui a
      &eacute;t&eacute; utilis&eacute;e lors du lancement du programme.</para>

    <para>&man.ps.1; supporte un certain nombre d'options diff&eacute;rentes
      pour modifier les informations affich&eacute;es.  Un des ensembles
      d'options les plus utiles est <literal>auxww</literal>.
      <option>a</option> affiche l'information au sujet de tous les
      processus tournant, et pas seulement les v&ocirc;tres.
      <option>u</option> donne le nom de l'utilisateur du propri&eacute;taire
      du processus, ainsi que l'utilisation de la m&eacute;moire.
      <option>x</option> affiche des informations sur les processus
      &ldquo;daemon&rdquo;, et <option>ww</option> oblige &man.ps.1; &agrave;
      afficher la ligne de commande compl&egrave;te, plut&ocirc;t que de la
      tronquer quand elle est trop longue pour tenir &agrave;
      l'&eacute;cran.</para>

    <para>La sortie de &man.top.1; est semblable.  Un extrait de session
      ressemble &agrave; ceci:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>La sortie est divis&eacute;e en deux sections.
      L'ent&ecirc;te (les cinq premi&egrave;res lignes) donne le PID du
      dernier processus lanc&eacute;, la charge syst&egrave;me moyenne
      (qui est une mesure de l'occupation du syst&egrave;me), la dur&eacute;e
      de fonctionnement du syst&egrave;me (le temps &eacute;coul&eacute;
      depuis le dernier red&eacute;marrage), et l'heure actuelle.  Les autres
      &eacute;l&eacute;ments de l'ent&ecirc;te concernent le nombre de
      processus en fonctionnement (47 dans notre cas), combien d'espace
      m&eacute;moire et d'espace de pagination sont occup&eacute;s, et
      combien de temps le syst&egrave;me passe dans les diff&eacute;rents
      &eacute;tats du CPU.</para>

    <para>En dessous il y a une s&eacute;rie de colonnes contenant des
      informations semblables &agrave; celles donn&eacute;es par &man.ps.1;.
      Comme pr&eacute;c&eacute;demment vous pouvez lire le PID, le nom
      d'utilisateur, la quantit&eacute; de temps CPU consomm&eacute;e, et
      la commande qui a &eacute;t&eacute; lanc&eacute;e.  &man.top.1; vous
      affiche par d&eacute;faut la quantit&eacute; d'espace m&eacute;moire
      utilis&eacute;e par chaque processus.  Cela est divis&eacute; en deux
      colonnes, une pour la quantit&eacute; totale, et une autre pour la
      quantit&eacute; r&eacute;sidente&mdash;la quantit&eacute; totale
      repr&eacute;sente l'espace m&eacute;moire dont a eu besoin l'application,
      et la quantit&eacute; r&eacute;sidente repr&eacute;sente
      l'espace qui est en fait utilis&eacute; actuellement.  Dans cet exemple
      vous pouvez voir que <application>Netscape</application> a
      exig&eacute; presque 30&nbsp;MO de RAM, mais
      utilise actuellement seulement 9MO.</para>

    <para>&man.top.1; actualise l'affichage toutes les deux secondes;
      cela peut &ecirc;tre modifi&eacute; avec l'option
      <option>s</option>.</para>
  </sect1>

  <sect1>
    <title>Daemons, signaux, et comment tuer un processus</title>

    <para>Quand vous utilisez un &eacute;diteur il est facile de le
      contr&ocirc;ler, de lui dire de charger des fichiers, et ainsi de suite.
      Vous pouvez faire cela parce que l'&eacute;diteur fournit les
      possibilit&eacute;s de le faire, et parce qu'un &eacute;diteur est
      attach&eacute; &agrave; un <firstterm>terminal</firstterm>.
      Certains programmes ne sont pas con&ccedil;us pour fonctionner avec
      un dialogue constant avec l'utilisateur, et donc ils se
      d&eacute;connectent du terminal &agrave; la premi&egrave;re occasion.
      Par exemple, un serveur web passe son temps &agrave; r&eacute;pondre
      aux requ&ecirc;tes web, il n'attend normalement pas d'entr&eacute;e de
      votre part.  Les programmes qui transportent le courrier
      &eacute;lectronique de site en site sont un autre exemple de cette
      classe d'application.</para>

    <para>Nous appelons ces programmes des
      <firstterm>daemons</firstterm> (d&eacute;mons).  Les
      &ldquo;daemons&rdquo; &eacute;taient des personnages de la mythologie
      Grec; ni bon ni mauvais, c'&eacute;taient de petits esprits serviteurs
      qui, g&eacute;n&eacute;ralement, ont &eacute;t&eacute; &agrave; l'origine
      de choses utiles &agrave; l'humanit&eacute;.
      Un peu comme les serveurs web ou de courrier d'aujourd'hui nous
      sont utiles.  C'est pourquoi la mascotte BSD a &eacute;t&eacute;, pendant
      longtemps, un d&eacute;mon &agrave; l'apparence joyeuse portant des
      chaussures de tennis et une fourche.</para>

    <para>Il existe une convention pour nommer les programmes qui
      fonctionnent normalement en tant que daemons qui est d'utiliser
      une terminaison en &ldquo;d&rdquo;.
      <application>BIND</application> est le &ldquo;Berkeley Internet Name
      Daemon&rdquo; (et le programme r&eacute;el qui est ex&eacute;cut&eacute;
      s'appelle <command>named</command>), le programme
      correspondant au serveur web <application>Apache</application> est
      appel&eacute; <command>httpd</command>, le daemon de gestion de la file
      d'attente de l'imprimante est <command>lpd</command>, et ainsi de
      suite.  C'est une convention, mais pas une obligation pure et
      simple; par exemple le daemon principal de gestion du courrier
      &eacute;lectronique pour l'application
      <application>Sendmail</application> est appel&eacute;
      <command>sendmail</command>, et non pas <command>maild</command>,
      comme vous pourriez l'imaginer.</para>

    <para>Parfois vous devrez communiquer avec un processus daemon.
      Ces communications sont appel&eacute;es <firstterm>signaux</firstterm>, et
      vous pouvez communiquez avec un daemon (ou avec tout processus en
      fonctionnement) en lui envoyant un signal.  Il existe un certain
      nombre de signaux diff&eacute;rents que vous pouvez
      envoyer&mdash;certains d'entre eux ont une signification pr&eacute;cise,
      d'autres sont interpr&eacute;t&eacute;s par l'application, et la
      documentation de l'application vous indiquera comment l'application
      interpr&egrave;te ces signaux.  Vous ne pouvez envoyer de signaux
      qu'aux processus dont vous &ecirc;tes le propri&eacute;taire.
      Si vous envoyez un signal &agrave; un
      processus appartenant &agrave; quelqu'un d'autre avec &man.kill.1;
      ou &man.kill.2; vous obtiendrez un refus de permission.  Il existe
      une exception &agrave; cela: l'utilisateur <username>root</username>, qui
      peut envoyer des signaux aux processus de chacun.</para>

    <para>Dans certain cas FreeBSD enverra &eacute;galement aux applications
      des signaux.  Si une application est mal &eacute;crite, et tente
      d'acc&eacute;der &agrave; une partie de m&eacute;moire &agrave;
      laquelle elle n'est pas suppos&eacute;e avoir acc&egrave;s, FreeBSD
      envoie au processus le signal de
      <firstterm>violation de segmentation</firstterm>
      (<literal>SIGSEGV</literal>).  Si une application a utilis&eacute;
      l'appel syst&egrave;me &man.alarm.3; pour &ecirc;tre avertie
      d&egrave;s qu'une p&eacute;riode de temps pr&eacute;cise est
      &eacute;coul&eacute;e alors lui sera envoy&eacute; le signal d'alarme
      (<literal>SIGALRM</literal>), et ainsi de suite.</para>

    <para>Deux signaux peuvent &ecirc;tre utilis&eacute;s pour arr&ecirc;ter
      un processus, <literal>SIGTERM</literal> et <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> est la mani&egrave;re polie de tuer un
      processus; le processus peut <emphasis>attraper</emphasis> le signal,
      r&eacute;aliser que vous d&eacute;sirez qu'il se termine, fermer les
      fichiers de trace qu'il a peut-&ecirc;tre ouvert, et
      g&eacute;n&eacute;ralement
      finir ce qu'il &eacute;tait en train de faire juste avant la demande
      d'arr&ecirc;t.  Dans certains cas un processus peut ignorer un
      <literal>SIGTERM</literal> s'il est au milieu d'une t&acirc;che qui ne
      peut &ecirc;tre interrompue.</para>

    <para><literal>SIGKILL</literal> ne peut &ecirc;tre ignor&eacute; par un
      processus.  C'est le signal &ldquo;Je me fiche de ce que vous
      faites, arr&ecirc;tez imm&eacute;diatement&rdquo;.  Si vous envoyez un
      <literal>SIGKILL</literal> &agrave; un processus alors FreeBSD
      stoppera le processus<footnote>
	<para>Ce n'est pas tout &agrave; fait vrai&mdash;il y a quelques cas
	  o&ugrave; les choses ne peuvent &ecirc;tre interrompues.  Par exemple,
	  si le processus est en train d'essayer de lire un fichier qui
	  est sur un autre ordinateur sur le r&eacute;seau, et que l'autre
	  ordinateur n'est plus accessible pour quelque raison
	  (a &eacute;t&eacute; &eacute;teint, ou le r&eacute;seau a un
	  probl&egrave;me),
	  alors le processus est dit &ldquo;non interruptible&rdquo;.
	  Par la suite le processus entrera en pause, typiquement apr&egrave;s
	  deux minutes.  D&egrave;s que cette pause sera effective le processus
	  sera tu&eacute;.</para>
      </footnote>.</para>

    <para>Les autres signaux que vous pourriez avoir envie d'utiliser
      sont <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, et
      <literal>SIGUSR2</literal>.  Ce sont des signaux d'usage
      g&eacute;n&eacute;ral, et diff&eacute;rentes applications se
      comporteront diff&eacute;remment quand ils
      sont envoy&eacute;s.</para>

    <para>Supposez que vous avez modifi&eacute; le fichier de configuration de
      votre serveur web&mdash;vous voudriez dire &agrave; votre serveur web de
      relire son fichier de configuration.  Vous pourriez arr&ecirc;ter et
      relancer <command>httpd</command>, mais il en r&eacute;sulterait une
      br&egrave;ve p&eacute;riode d'indisponibilit&eacute; de votre serveur
      web, ce qui peut &ecirc;tre ind&eacute;sirable.
      La plupart des daemons sont &eacute;crits pour r&eacute;pondre
      au signal <literal>SIGHUP</literal> en relisant leur fichier de
      configuration.  Donc au lieu de tuer et relancer
      <command>httpd</command> vous lui enverriez le signal
      <literal>SIGHUP</literal>.  Parce qu'il n'y a pas de mani&egrave;re
      standard de r&eacute;pondre &agrave; ces signaux, diff&eacute;rents
      daemons auront diff&eacute;rents comportements, soyez s&ucirc;r
      de ce que vous faites et lisez
      la documentation du daemon en question.</para>

    <para>Les signaux sont envoy&eacute;s en utilisant la commande
      &man.kill.1;, comme cet exemple le montre:</para>

    <procedure>
      <title>Envoyer un signal &agrave; un processus</title>

      <para>cet exemple montre comment envoyer un signal &agrave;
	&man.inetd.8;.  Le fichier de configuration &man.inetd.8; est
	<filename>/etc/inetd.conf</filename>, et &man.inetd.8; relira ce
	fichier de configuration quand un signal
	<literal>SIGHUP</literal> est envoy&eacute;.</para>

      <step>
	<para>Trouvez l'identifiant du processus (PID) auquel vous
	  voulez envoyer le signal.  Faites-le en employant &man.ps.1;
	  et &man.grep.1;.  La commande &man.grep.1; est utilis&eacute;e pour
	  rechercher dans le r&eacute;sultat la cha&icirc;ne de
	  caract&egrave;res que
	  vous sp&eacute;cifiez.  Cette commande est lanc&eacute;e en tant
	  qu'utilisateur normal, et &man.inetd.8; est lanc&eacute; en tant que
	  <username>root</username>, donc les options <option>ax</option>
	  doivent &ecirc;tre pass&eacute;es &agrave; &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Donc le PID d'&man.inetd.8; est 198.  Dans certains cas la
	  commande <literal>grep inetd</literal> pourrait aussi
	  appara&icirc;tre dans le r&eacute;sultat.  C'est &agrave;
	  cause de la fa&ccedil;on dont
	  &man.ps.1; recherche la liste des processus en
	  fonctionnement.</para>
      </step>

      <step>
	<para>Utilisez &man.kill.1; pour envoyer le signal.  Etant donn&eacute;
	  qu'&man.inetd.8; tourne sous les droits de l'utilisateur
	  <username>root</username> vous devez utilisez &man.su.1; pour
	  devenir, en premier lieu, <username>root</username>.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>Comme la plupart des commandes Unix, &man.kill.1; n'affichera
	  rien si la commande est couronn&eacute;e de succ&egrave;s.  Si vous
	  envoyez un signal &agrave; un processus dont vous n'&ecirc;tes pas le
	  propri&eacute;taire alors vous verrez <errorname>kill:
	  <replaceable>PID</replaceable>: Operation not
	  permitted</errorname>.  Si vous avez fait une erreur dans le
	  PID, vous enverrez le signal soit &agrave; un mauvais processus, ce
	  qui peut &ecirc;tre mauvais, soit, si vous &ecirc;tes chanceux, vous
	  enverrez le signal &agrave; un PID qui n'est pas actuellement
	  utilis&eacute;, et vous verrez <errorname>kill:
	  <replaceable>PID</replaceable>: No such
	  process</errorname>.</para>

	<note>
	  <title>Pourquoi utiliser <command>/bin/kill</command>?</title>

	  <para>De nombreux interpr&eacute;teurs de commandes fournissent la
	    commande <command>kill</command> comme commande interne;
	    c'est &agrave; dire, que l'interpr&eacute;teur de commandes enverra
	    directement le signal, plut&ocirc;t que de lancer
	    <filename>/bin/kill</filename>.  Cela peut &ecirc;tre utile,
	    cependant les diff&eacute;rents interpr&eacute;teurs ont une syntaxe
	    diff&eacute;rente pour sp&eacute;cifier le nom du signal &agrave;
	    envoyer.
	    Plut&ocirc;t que de tenter de les apprendre toutes, il peut
	    &ecirc;tre plus simple de juste employer directement la commande
	    <command>/bin/kill
	    <replaceable>...</replaceable></command>.</para>
	</note>
      </step>
    </procedure>

    <para>Envoyer d'autres signaux est tr&egrave;s semblable, substituez juste
      <literal>TERM</literal> ou <literal>KILL</literal> dans la ligne
      de commande si n&eacute;cessaire.</para>

    <important>
      <para>Tuer au hasard des processus sur le syst&egrave;me peut
	&ecirc;tre une mauvaise id&eacute;e.
	En particulier, &man.init.8;, processus &agrave;
	l'identifiant 1, qui est tr&egrave;s particulier.  Lancer la commande
	<command>/bin/kill -s KILL 1</command> est une mani&egrave;re
	rapide d'arr&ecirc;ter votre syst&egrave;me.  V&eacute;rifiez
	<emphasis>toujours</emphasis> &agrave; deux fois les arguments que vous
	utilisez avec &man.kill.1; <emphasis>avant</emphasis> d'appuyer
	sur <keycap>Entr&eacute;e</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Interpr&eacute;teurs de commandes - &ldquo;Shells&rdquo;</title>
    <indexterm><primary>interpr&eacute;teurs de commandes</primary></indexterm>
    <indexterm><primary>ligne de commande</primary></indexterm>

    <para>Sous FreeBSD, beaucoup du travail quotidien est effectu&eacute; sous
      une interface en ligne de commande appel&eacute;e interpr&eacute;teur de
      commandes ou &ldquo;shell&rdquo;.  Le r&ocirc;le principal d'un
      interpr&eacute;teur de commandes est de prendre les commandes sur le
      canal d'entr&eacute;e et de les ex&eacute;cuter.  Beaucoup
      d'interpr&eacute;teurs de commandes ont &eacute;galement des fonctions
      int&eacute;gr&eacute;es pour aider dans les t&acirc;ches quotidiennes
      comme la gestion de fichiers, le m&eacute;canisme de
      remplacement et d'expansion des jokers (&ldquo;file globbing&rdquo;),
      l'&eacute;dition de la ligne de commande, les macros commandes, et les
      variables d'environnement.  FreeBSD est fournit avec un ensemble
      d'interpr&eacute;teurs de commandes, comme <command>sh</command>,
      l'interpr&eacute;teur de commandes Bourne, et <command>tcsh</command>,
      l'interpr&eacute;teur de commandes C-shell am&eacute;lior&eacute;.
      Beaucoup d'autres
      interpr&eacute;teurs de commandes sont disponibles dans le catalogue des
      logiciels port&eacute;s, comme <command>zsh</command> et
      <command>bash</command>.</para>

    <para>Quel interpr&eacute;teur de commandes utilisez-vous?  C'est vraiment
      une question de go&ucirc;t.  Si vous programmez en C vous pourriez vous
      sentir plus &agrave; l'aise avec un interpr&eacute;teur de commandes
      proche du C
      comme <command>tcsh</command>.  Si vous venez du monde Linux ou que
      vous &ecirc;tes nouveau &agrave; l'interface en ligne de commande d'Unix
      vous pourriez essayer <command>bash</command>.  L'id&eacute;e principale
      est que chaque interpr&eacute;teur de commandes &agrave; des
      caract&eacute;ristiques uniques qui peuvent ou ne peuvent pas
      fonctionner avec votre environnement de travail
      pr&eacute;f&eacute;r&eacute;, et que vous avez vraiment le
      choix de l'interpr&eacute;teur de commandes &agrave; utiliser.</para>

    <para>Une des caract&eacute;ristiques communes des interpr&eacute;teurs de
      commandes est de pouvoir compl&eacute;ter les noms de fichiers
      (&ldquo;filename completion&rdquo;).  En tapant les premi&egrave;res
      lettres d'une commande ou d'un fichier, vous pouvez habituellement
      faire compl&eacute;ter automatiquement par l'interpr&eacute;teur de
      commandes le reste de la commande ou du nom du fichier en appuyant sur la
      touche <keycap>Tab</keycap> du clavier.  Voici un exemple.
      Supposez que vous avez deux fichiers appel&eacute;s respectivement
      <filename>foobar</filename> et <filename>foo.bar</filename>.
      Vous voulez effacer <filename>foo.bar</filename>.  Donc ce
      que vous devriez taper sur le clavier est: <command>rm
      fo[<keycap>Tab</keycap>].[<keycap>Tab</keycap>]</command>.</para>

    <para>L'interpr&eacute;teur de commandes devrait afficher <command>rm
      foo[BEEP].bar</command>.</para>

    <para>Le [BEEP] est la sonnerie de la console, c'est l'interpr&eacute;teur
      de commande indiquant qu'il n'est pas en mesure de compl&eacute;ter
      totalement le nom du fichier parce qu'il y a plus d'une
      possibilit&eacute;.  <filename>foobar</filename> et
      <filename>foo.bar</filename> commencent tous les deux par
      <literal>fo</literal>, mais il fut capable de compl&eacute;ter
      jusqu'&agrave; <literal>foo</literal>.  Si vous tapez
      <literal>.</literal>, puis appuyez &agrave; nouveau sur
      <keycap>Tab</keycap>, l'interpr&eacute;teur de
      commandes devrait pouvoir compl&eacute;ter le reste du nom du fichier
      pour vous.</para>
    <indexterm><primary>variables d'environnement</primary></indexterm>

    <para>Une autre caract&eacute;ristique de l'interpr&eacute;teur de
      commandes est l'utilisation de variables d'environnement.  Les variables
      d'environnement sont une paire variable-valeur stock&eacute;es dans
      l'espace m&eacute;moire d'environnement de l'interpr&eacute;teur de
      commandes.  Cet espace peut &ecirc;tre lu par n'importe quel programme
      invoqu&eacute; par l'interpr&eacute;teur de commandes, et contient
      ainsi beaucoup d'&eacute;l&eacute;ments
      de configuration des programmes.  Voici une liste des variables
      d'environnement habituelles et ce qu'elles signifient:</para>
    <indexterm><primary>variables d'environnement</primary></indexterm>

    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Description</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Le nom d'utilisateur de la personne actuellement
	      attach&eacute;e au syst&egrave;me.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>La liste des r&eacute;pertoires, s&eacute;par&eacute;s par
	      deux points, pour la recherche des programmes.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Le nom r&eacute;seau de l'affichage X11 auquel on peut se
	      connecter, si disponible.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Le nom de l'interpr&eacute;teur de commandes actuellement
	      utilis&eacute;.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Le nom du terminal de l'utilisateur.  Utilis&eacute; pour
	      d&eacute;terminer les capacit&eacute;s du terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>L'entr&eacute;e de la base de donn&eacute;es des codes
	      d'&eacute;chappement pour permettre l'ex&eacute;cution de
	      diverses fonctions du terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Type du syst&egrave;me d'exploitation, e.g. FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>L'architecture du CPU sur lequel tourne actuellement
	      le syst&egrave;me.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>L'&eacute;diteur de texte pr&eacute;fer&eacute; de
	      l'utilisateur.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Le visualisateur de page de texte pr&eacute;ferr&eacute; de
	      l'utilisateur.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>La liste des r&eacute;pertoires, s&eacute;par&eacute;s par
	      deux points, pour la recherche des pages de manuel.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>Fixer une variable d'environnement diff&egrave;re
      l&eacute;g&egrave;rement d'un interpr&eacute;teur de commandes
      &agrave; l'autre.  Par exemple,
      dans le style de l'interpr&eacute;teur de commandes de type C-shell comme
      <command>tcsh</command> et <command>csh</command>, vous
      utiliseriez <command>setenv</command> pour fixer le
      contenu d'une variable d'environnement.  Sous les interpr&eacute;teurs de
      commandes Bourne comme <command>sh</command> et
      <command>bash</command>, vous utiliseriez
      <command>export</command> pour configurer vos
      variables d'environnement.  Par exemple, pour fixer ou modifier la
      variable d'environnement <envar>EDITOR</envar>, sous
      <command>csh</command> ou <command>tcsh</command> une commande
      comme la suivante fixera <envar>EDITOR</envar> &agrave;
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Sous les interpr&eacute;teurs de commandes Bourne:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Vous pouvez faire afficher &agrave; la plupart des
      interpr&eacute;teurs de commandes la variable d'environnement
      en pla&ccedil;ant un caract&egrave;re
      <literal>$</literal> juste devant son nom sur la ligne
      de commande.  Par exemple, <command>echo $TERM</command> affichera
      le contenu de <envar>$TERM</envar>, car l'interpr&eacute;teur de commande
      compl&egrave;te <envar>$TERM</envar> et passe la main &agrave;
      <command>echo</command>.</para>

    <para>Les interpr&eacute;teurs de commandes traitent beaucoup de
      caract&egrave;res sp&eacute;ciaux, appel&eacute;s
      m&eacute;tacaract&egrave;res, en tant que repr&eacute;sentation
      particuli&egrave;re des donn&eacute;es.  Le plus commun est le
      caract&egrave;re <literal>*</literal>, qui repr&eacute;sente
      z&eacute;ro ou plusieurs caract&egrave;res dans le nom du fichier.
      Ces m&eacute;tacaract&egrave;res sp&eacute;ciaux peuvent &ecirc;tre
      utilis&eacute;s pour compl&eacute;ter automatiquement le nom des
      fichiers.  Par exemple, taper <command>echo *</command> est presque
      la m&ecirc;me chose
      que taper <command>ls</command> parce que l'interpr&eacute;teur de
      commandes prendra tous les fichiers qui correspondent &agrave;
      <literal>*</literal> et les passera &agrave; <command>echo</command> pour
      les afficher.</para>

    <para>Pour &eacute;viter que l'interpr&eacute;teur de commande
      n'interpr&egrave;te les caract&egrave;res sp&eacute;ciaux, ils peuvent
      &ecirc;tre neutralis&eacute;s en ajoutant un
      caract&egrave;re antislash (<literal>\</literal>) devant.  <command>echo
      $TERM</command> affichera votre type de terminal.  <command>echo
      \$TERM</command> affichera <envar>$TERM</envar> tel quel.</para>

    <sect2 id="changing-shells">
      <title>Changer d'interpr&eacute;teur de commandes</title>

      <para>La m&eacute;thode la plus simple pour changer votre
	interpr&eacute;teur de commandes est d'utiliser la commande
	<command>chsh</command>.  En lan&ccedil;ant <command>chsh</command>
	vous arriverez dans l'&eacute;diteur
	correspondant &agrave; votre variable d'environnement
	<envar>EDITOR</envar>; si elle n'est pas fix&eacute;e, cela sera
	<command>vi</command>.  Modifiez la ligne &ldquo;Shell:&rdquo;
	en cons&eacute;quence.</para>

      <para>Vous pouvez &eacute;galement passer le param&egrave;tre
	<option>-s</option> &agrave; <command>chsh</command>; cela modifiera
	votre interpr&eacute;teur de commandes sans avoir &agrave; utiliser
	un &eacute;diteur.  Par exemple, si
	vous vouliez changer votre interpr&eacute;teur de commandes pour
	<command>bash</command>,
	ce qui suit devrait faire l'affaire:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Utiliser <command>chsh</command> sans param&egrave;tres et modifier
	votre interpr&eacute;teur de commandes directement &agrave; partir
	de l&agrave; devrait &eacute;galement fonctionner.</para>

      <note>
	<para>L'interpr&eacute;teur de commandes que vous d&eacute;sirez
	  utiliser <emphasis>doit</emphasis> &ecirc;tre pr&eacute;sent dans
	  le fichier <filename>/etc/shells</filename>.  Si vous avez
	  install&eacute; l'interpr&eacute;teur de commandes &agrave; partir
	  du <link linkend="ports">catalogue des logiciels port&eacute;s</link>,
	  alors cela a d&ucirc; d&eacute;j&agrave; &ecirc;tre fait pour vous.
	  Si vous avez install&eacute; &agrave;
	  la main l'interpr&eacute;teur de commandes, vous devez alors le
	  faire.</para>

      <para>Par exemple, si vous avez install&eacute; <command>bash</command>
	&agrave; la main et l'avez plac&eacute; dans
	<filename>/usr/local/bin</filename>, vous devrez faire:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Puis relancer <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Editeurs de texte</title>
    <indexterm><primary>&eacute;diteurs de texte</primary></indexterm>
    <indexterm><primary>&eacute;diteurs</primary></indexterm>

    <para>Beaucoup de configurations sous FreeBSD sont faites en &eacute;ditant
      des fichiers textes.  Aussi ce serait une bonne id&eacute;e de se
      familiariser avec un &eacute;diteur de texte.  FreeBSD est fourni avec
      quelques-uns en tant qu'&eacute;l&eacute;ments de syst&egrave;me de base,
      et beaucoup d'autres sont disponibles dans le catalogue des logiciels
      port&eacute;s.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <para>L'&eacute;diteur de plus facile et le plus simple &agrave; apprendre
      est un &eacute;diteur appel&eacute; <application>ee</application>,
      qui signifie l'&eacute;diteur facile (easy editor).  Pour lancer
      <application>ee</application>, on taperait sur la ligne de
      commande <command>ee fichier</command> o&ugrave;
      <literal>fichier</literal> est le nom du fichier qui doit &ecirc;tre
      &eacute;dit&eacute;.  Par exemple, pour &eacute;diter
      <filename>/etc/rc.conf</filename>, tapez <command>ee
      /etc/rc.conf</command>.  Une fois sous <command>ee</command>, toutes
      les commandes pour utiliser les fonctions de l'&eacute;diteur sont
      affich&eacute;es en haut de l'&eacute;cran.  Le caract&egrave;re
      <literal>^</literal>
      repr&eacute;sente la touche <keycap>Ctrl</keycap> sur le clavier, donc
      <literal>^e</literal> repr&eacute;sente la combinaison de touches
      <keycombo
      action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>.
      Pour quitter <application>ee</application>, appuyez sur la touche
      <keycap>Echap</keycap>, ensuite choisissez
      &ldquo;leave editor&rdquo;.  L'&eacute;diteur
      vous demandera s'il doit sauver les changements si le fichier a
      &eacute;t&eacute; modifi&eacute;.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>&eacute;diteurs</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>&eacute;diteurs</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD est &eacute;galement fourni avec des &eacute;diteurs de texte
      plus puissants comme <command>vi</command> en tant
      qu'&eacute;l&eacute;ment du
      syst&egrave;me de base, alors que d'autres &eacute;diteurs, comme
      <command>emacs</command> et <command>vim</command>, en tant
      qu'&eacute;l&eacute;ment du catalogue des logiciels port&eacute;s de
      FreeBSD.  Ces &eacute;diteurs offrent beaucoup plus de
      fonctionnalit&eacute;s et de puissance aux d&eacute;pens d'&ecirc;tre
      un peu plus compliqu&eacute;s &agrave; apprendre.
      Cependant si vous projetez de faire beaucoup d'&eacute;dition de texte,
      l'&eacute;tude d'un &eacute;diteur plus puissant comme
      <command>vim</command> ou
      <command>emacs</command> vous permettra d'&eacute;conomiser beaucoup plus
      de temps &agrave; la longue.</para>
  </sect1>

  <sect1>
    <title>P&eacute;riph&eacute;riques et fichiers sp&eacute;ciaux de
      p&eacute;riph&eacute;rique</title>

    <para>Un p&eacute;riph&eacute;rique est un terme utilis&eacute; la plupart
      du temps pour les activit&eacute;s en rapport avec le mat&eacute;riel
      pr&eacute;sent sur le syst&egrave;me,
      incluant les disques, les imprimantes, les cartes graphiques, et les
      claviers.  Quand FreeBSD d&eacute;marre, la majorit&eacute; de ce
      qu'affiche FreeBSD est la d&eacute;tection des
      p&eacute;riph&eacute;riques.  Vous pouvez &agrave; nouveau
      consulter les messages de d&eacute;marrage en visualisant le fichier
      <filename>/var/run/dmesg.boot</filename>.</para>

    <para>Par exemple, <devicename>acd0</devicename> est le premier
      lecteur de CDROM IDE, tandis que <devicename>kbd0</devicename>
      repr&eacute;sente le clavier.</para>

    <para>La plupart de ces p&eacute;riph&eacute;riques sous un syst&egrave;me
      d'exploitation Unix peuvent &ecirc;tre acc&eacute;d&eacute;s par
      l'interm&eacute;diaire de fichiers appel&eacute;s fichiers
      sp&eacute;ciaux de p&eacute;riph&eacute;rique
      (&ldquo;device node&rdquo;), qui sont situ&eacute;s dans le
      r&eacute;pertoire <filename>/dev</filename>.</para>

    <sect2>
      <title>Cr&eacute;er des fichiers sp&eacute;ciaux de
	p&eacute;riph&eacute;rique</title>
      <para>Quand vous ajoutez un nouveau p&eacute;riph&eacute;rique
	&agrave; votre syst&egrave;me, ou compilez le support pour des
	p&eacute;riph&eacute;riques suppl&eacute;mentaires, vous aurez
	peut &ecirc;tre besoin de cr&eacute;er un ou plusieurs fichiers
	sp&eacute;ciaux de p&eacute;riph&eacute;rique pour les nouveaux
	p&eacute;riph&eacute;riques.</para>

      <sect3>
	<title>MAKEDEV Script</title>
	<para>Sur les syst&egrave;mes sans <literal>DEVFS</literal> (cela concerne toutes les versions de FreeBSD ant&eacute;rieures &agrave; la 5.0), les
	  fichiers sp&eacute;ciaux
	  de p&eacute;riph&eacute;rique doivent &ecirc;tre
	  cr&eacute;&eacute;s &agrave; l'aide de la proc&eacute;dure
	  &man.MAKEDEV.8; comme montr&eacute; ci-dessous:</para>

	<screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV ad1</userinput>
	</screen>

	<para>Cet exemple devrait cr&eacute;er les fichiers sp&eacute;ciaux de
	  p&eacute;riph&eacute;rique corrects pour le second disque IDE
	  quand il est install&eacute;.</para>
      </sect3>

      <sect3>
	<title><literal>DEVFS</literal> (&ldquo;DEVice File System&rdquo; -
	  Syst&egrave;me de fichiers de p&eacute;riph&eacute;rique)</title>

	<para>Le syst&egrave;me de fichiers de p&eacute;riph&eacute;rique, ou
	  <literal>DEVFS</literal>, fournit un acc&egrave;s &agrave; l'espace
	  nom des p&eacute;riph&eacute;riques du noyau dans l'espace nom du
	  syst&egrave;me de fichiers global.  Au lieu d'avoir &agrave;
	  cr&eacute;er et modifier les fichiers sp&eacute;ciaux de
	  p&eacute;riph&eacute;rique, <literal>DEVFS</literal>
	  maintient ce syst&egrave;me de fichiers particulier pour vous.</para>

	<para>Voir la page de manuel de &man.devfs.5; pour plus
	  d'information.</para>

	<para><literal>DEVFS</literal> est utilis&eacute; par d&eacute;faut
	  sous FreeBSD&nbsp;5.0.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="consoles">
    <title>Consoles virtuelles &amp; terminaux</title>
    <indexterm><primary>consoles virtuelles</primary></indexterm>
    <indexterm><primary>terminal</primary></indexterm>

    <para>FreeBSD peut &ecirc;tre utilis&eacute; de diverses fa&ccedil;ons.
      L'une d'elles est en tapant des commandes sur un terminal
      texte.  Une bonne partie de la flexibilit&eacute; et de la puissance
      d'un syst&egrave;me d'exploitation &unix; est directemtent
      disponible sous vos mains en utilisant FreeBSD de cette mani&egrave;re.
      Cette section d&eacute;crit ce que sont les &ldquo;terminaux&rdquo; et
      les &ldquo;consoles&rdquo;, et comment les utiliser sous
      FreeBSD.</para>

    <sect2 id="consoles-intro">
      <title>La console</title>
      <indexterm><primary>console</primary></indexterm>

      <para>Si vous n'avez pas configur&eacute; FreeBSD pour lancer
	automatiquement un environnement graphique au d&eacute;marrage, le
	syst&egrave;me vous pr&eacute;sentera une invite d'ouverture de session
	apr&egrave;s son d&eacute;marrage, juste apr&egrave;s la fin des
	proc&eacute;dures de d&eacute;marrage.  Vous verrez quelque chose
	de similaire &agrave;:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Les messages pourront &ecirc;tre diff&eacute;rents sur votre
	syst&egrave;me, mais cela devrait y ressembler.  Les deux
	derni&egrave;res lignes sont celles qui nous int&eacute;ressent
	actuellement.  La seconde de ces lignes nous donne:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Cette ligne contient quelques &eacute;l&eacute;ments d'information
	sur le syst&egrave;me que vous venez de d&eacute;marrer.  Vous
	&ecirc;tes en train de lire une console &ldquo;FreeBSD&rdquo;,
	tournant sur un processeur Intel ou compatible de la famille
	x86<footnote>
	  <para>C'est ce que signifie <literal>i386</literal>.  Notez
	    que m&ecirc;me si vous faites tourner FreeBSD sur un CPU Intel
	    386, cela sera <literal>i386</literal>.  Ce n'est pas le
	    type de votre microprocesseur, mais
	    &ldquo;l'architecture&rdquo; du microprocesseur qui est
	    donn&eacute;e ici.</para>
	</footnote>.  Le nom de cette machine (chaque machine &unix;
	a un nom) est <hostid>pc3.example.org</hostid>, et vous
	regardez actuellement sa console syst&egrave;me&mdash;le terminal
	<devicename>ttyv0</devicename>.</para>

      <para>Et enfin, la derni&egrave;re ligne est toujours:</para>

      <programlisting>login:</programlisting>

      <para>C'est le moment o&ugrave; vous &ecirc;tes suppos&eacute;
	taper votre &ldquo;nom d'utilisateur&rdquo; pour vous
	attacher au syst&egrave;me FreeBSD.  La section suivante d&eacute;crit
	comment proc&eacute;der.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Ouvrir une session sur un syst&egrave;me FreeBSD</title>

      <para>FreeBSD est un syst&egrave;me multi-utilisateur,
	multi-processeur.  C'est la description formelle qui est
	habituellement donn&eacute;e pour un syst&egrave;me qui peut
	&ecirc;tre utilis&eacute; par diff&eacute;rentes personnes,
	qui ex&eacute;cutent simultan&eacute;ment de nombreux programmes sur une
	machine individuelle/</para>

      <para>Chaque syst&egrave;me multi-utilisateur a besoin d'un moyen pour
	distinguer un &ldquo;utilisateur&rdquo; du reste.  Sous
	FreeBSD (et sous tous les syst&egrave;mes de type &unix;),
	cela est effectu&eacute; en demandant &agrave; chaque utilisateur de
	&ldquo;s'attacher&rdquo; au syst&egrave;me avant d'&ecirc;tre en
	mesure d'ex&eacute;cuter des programmes.  Chaque utilisateur
	poss&egrave;de un nom unique (le nom d'utilisateur) et une cl&eacute;
	secr&egrave;te personnelle (le mot de passe).  FreeBSD demandera ces
	deux &eacute;l&eacute;ments avant d'autoriser un utilisateur &agrave;
	lancer un programme.</para>

      <indexterm><primary>proc&eacute;dures de d&eacute;marrage</primary></indexterm>
      <para>Juste apr&egrave;s que FreeBSD ait d&eacute;marr&eacute; et
	en ait termin&eacute; avec l'ex&eacute;cution des proc&eacute;dures de
	d&eacute;marrage<footnote>
	  <para>Les proc&eacute;dures de d&eacute;marrage sont des programmes
	    qui sont ex&eacute;cut&eacute;s automatiquement pas FreeBSD au
	    d&eacute;marrage.  Leur fonction principale est de configurer le
	    syst&egrave;me pour permettre l'ex&eacute;cution de tout programme,
	    et de d&eacute;marrer tout service que vous avez configur&eacute; pour
	    tourner en t&acirc;che de fond et ex&eacute;cuter des choses
	    utiles.</para>
	</footnote>, il pr&eacute;sentera une invite et demandera un nom
	d'utilisateur valide:</para>

      <screen>login:</screen>

      <para>Pour cet exemple, supposons que votre nom d'utilisateur
	est <username>john</username>.  Tapez
	<username>john</username> &agrave; cette invite puis appuyez sur
	<keycap>Entr&eacute;e</keycap>.  Alors vous devrez &ecirc;tre
	invit&eacute; &agrave; entrer un &ldquo;mot de passe&rdquo;:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Tapez maintenant le mot de passe de <username>john</username>,
	et appuyez sur <keycap>Entr&eacute;e</keycap>.  Le mot de passe
	<emphasis>n'est pas affich&eacute;!</emphasis>  Vous n'avez pas &agrave;
	vous pr&eacute;occuper de cela maintenant.  Il suffit de penser que
	cela est fait pour des raisons de s&eacute;curit&eacute;.</para>

      <para>Si vous avez tap&eacute; correctement votre mot de passe,
	vous devriez &ecirc;tre maintenant attach&eacute;
	au syst&egrave;me et pr&ecirc;t &agrave; essayer toutes les commandes
	disponibles.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Consoles multiples</title>

      <para>Ex&eacute;cuter des commandes &unix; dans une console est bien
	beau, mais FreeBSD peut ex&eacute;cuter plusieurs programmes
	&agrave; la fois.  Avoir une seule console sur laquelle les commandes
	peuvent &ecirc;tre tap&eacute;es serait un peu du gaspillage quand
	un syst&egrave;me d'exploitation comme FreeBSD peut ex&eacute;cuter des
	dizaines de programmes en m&ecirc;me temps.  C'est ici que des
	&ldquo;consoles virtuelles&rdquo; peuvent &ecirc;tre vraiment
	utiles.</para>

      <para>FreeBSD peut &ecirc;tre configur&eacute; pour pr&eacute;senter
	de nombreuses consoles virtuelles.  Vous pouvez basculer
	d'une console virtuelle &agrave; une autre en utilisant une
	combinaison de touches sur votre clavier.  Chaque console
	a son propre canal de sortie, et FreeBSD prend soin de
	rediriger correctement les entr&eacute;es au clavier et la sortie
	vers &eacute;cran quand vous basculez d'une console virtuelle &agrave;
	la suivante.</para>

      <para>Des combinaisons de touches sp&eacute;cifiques ont
	&eacute;t&eacute; r&eacute;serv&eacute;es par FreeBSD pour le
	basculement entre consoles<footnote>
	  <para>Une description assez technique et pr&eacute;cise de tous
	    les d&eacute;tails de la console FreeBSD et des pilotes de
	    clavier peut &ecirc;tre trouv&eacute;e dans les pages de manuel de
	    &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1;
	    et &man.kbdcontrol.1;.  Nous ne nous &eacute;tendrons pas
	    en d&eacute;tails ici, mais le lecteur int&eacute;ress&eacute; peut
	    toujours consulter les pages de manuel pour explication plus
	    d&eacute;taill&eacute;e et plus compl&egrave;te sur le
	    fonctionnement des choses.</para>
	</footnote>.  Vous pouvez utiliser
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>,
	jusqu'&agrave;
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	pour basculer vers une console virtuelle diff&eacute;rente sous
	FreeBSD.</para>

      <para>Quand vous basculez d'une console &agrave; une autre, FreeBSD
	prend soin de sauvegarder et restaurer la sortie d'&eacute;cran.
	Il en r&eacute;sulte l'&ldquo;illusion&rdquo; d'avoir plusieurs
	&eacute;crans et claviers &ldquo;virtuels&rdquo; que vous pouvez
	utiliser pour taper des commandes pour FreeBSD.  Les
	programmes que vous lancez sur une console virtuelle ne
	cessent pas de tourner quand cette console n'est plus visible.
	Ils continuent de s'ex&eacute;cuter quand vous avez
	bascul&eacute; vers une console virtuelle diff&eacute;rente.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title>Le fichier <filename>/etc/ttys</filename></title>

      <para>La configuration par d&eacute;faut de FreeBSD d&eacute;marre avec 8
	consoles virtuelles.  Cependant ce n'est pas un param&eacute;trage
	fixe, et vous pouvez ais&eacute;ment personnaliser votre installation
	pour d&eacute;marrer avec plus ou moins de consoles virtuelles.  Le
	nombre et les param&eacute;trages des consoles virtuelles sont
	configur&eacute;s dans le fichier
	<filename>/etc/ttys</filename>.</para>

      <para>Vous pouvez utiliser le fichier
	<filename>/etc/ttys</filename> pour configurer les consoles
	virtuelles de FreeBSD.  Chaque ligne non-comment&eacute;e dans ce fichier
	(les lignes qui ne d&eacute;butent pas par le caract&egrave;re
	<literal>#</literal>) contient le param&eacute;trage d'un terminal ou
	d'une console virtuelle.  La version par d&eacute;faut de ce
	fichier livr&eacute;e avec FreeBSD configure 9 consoles virtuelles,
	et en active 8.  Ce sont les lignes commen&ccedil;ant avec le terme
	<literal>ttyv</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Pour une description d&eacute;taill&eacute;e de chaque colonne
	de ce fichier et toutes les options que vous pouvez utiliser
	pour configurer les consoles virtuelles, consultez la page de
	manuel &man.ttys.5;.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Console en mode mono-utilisateur</title>

      <para>Une description d&eacute;taill&eacute;e de ce qu'est
	<quote>le mode mono-utilisateur</quote> peut &ecirc;tre
	trouv&eacute;e dans <xref linkend="boot-singleuser">.  Il est
	important de noter qu'il n'y a qu'une console de disponible
	quand vous ex&eacute;cuter FreeBSD en mode mono-utilisateur.  Il n'y
	a aucune console virtuelle de disponible.  Le param&eacute;trage de
	la console en mode mono-utilisateur peut &ecirc;tre
	&eacute;galement trouv&eacute; dans le fichier
	<filename>/etc/ttys</filename>.  Recherchez la ligne qui
	commence avec le mot <literal>console</literal>:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
        <para>Comme l'indiquent les commentaires au-dessus de la ligne
	  <literal>console</literal>, vous pouvez &eacute;diter cette ligne
	  et changer <literal>secure</literal> pour
	  <literal>insecure</literal>.  Si vous faites cela, quand
	  FreeBSD d&eacute;marrera en mode mono-utilisateur, il demandera le
	  mot de passe de <username>root</username>.</para>

	<para><emphasis>Cependant faites attention quand vous modifiez
	  cela pour <literal>insecure</literal>.</emphasis>  Si vous
	  oubliez le mot de passe de <username>root</username>, le
	  d&eacute;marrage en mode mono-utilisateur sera condamn&eacute;.
	  Il est encore possible, mais cela pourra &ecirc;tre relativement
	  compliqu&eacute; pour quelqu'un qui n'est pas &agrave; l'aise avec le
	  processus de d&eacute;marrage de FreeBSD et les programmes entrant
	  en jeu.</para>
      </note>
    </sect2>
  </sect1>

  <sect1>
    <title>Pour plus d'information</title>

    <sect2 id="basics-man">
      <title>Les pages de manuel</title>
      <indexterm><primary>pages de manuel</primary></indexterm>

      <para>La documentation la plus compl&egrave;te sur FreeBSD est sous la
	forme de pages de manuel.  Presque chaque programme sur le
	syst&egrave;me est fournit avec un court manuel de
	r&eacute;f&eacute;rence expliquant l'utilisation de base et les
	diverses options.  Ces manuels peuvent &ecirc;tre visualis&eacute;s
	avec la commande <command>man</command>.
	L'utilisation de la commande <command>man</command> est
	simple:</para>

      <screen>&prompt.user; <userinput>man <replaceable>command</replaceable></userinput></screen>

      <para><literal>command</literal> est le nom de la commande
	&agrave; propos de laquelle vous d&eacute;sirez en savoir plus.
	Par exemple, pour en savoir plus au sujet de la commande
	<command>ls</command> tapez:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Les manuels en ligne sont divis&eacute;s en sections
	num&eacute;rot&eacute;es:</para>

      <orderedlist>
	<listitem>
	  <para>Commandes utilisateur.</para>
	</listitem>

	<listitem>
	  <para>Appels syst&egrave;me et num&eacute;ros d'erreur.</para>
	</listitem>

	<listitem>
	  <para>Fonctions des biblioth&egrave;ques C.</para>
	</listitem>

	<listitem>
	  <para>Pilotes de p&eacute;riph&eacute;rique.</para>
	</listitem>

	<listitem>
	  <para>Formats de fichier.</para>
	</listitem>

	<listitem>
	  <para>Jeux et autres divertissements.</para>
	</listitem>

	<listitem>
	  <para>Information diverse.</para>
	</listitem>

	<listitem>
	  <para>Commandes de maintenance et d'utilisation du
	    syst&egrave;me.</para>
	</listitem>

	<listitem>
	  <para>Information de d&eacute;veloppement du noyau.</para>
	</listitem>
      </orderedlist>

      <para>Dans certains cas, le m&ecirc;me sujet peut appara&icirc;tre
	dans plus d'une section du manuel en ligne.  Par exemple, il existe une
	commande utilisateur <command>chmod</command> et un appel
	syst&egrave;me <function>chmod()</function>.  Dans ce cas, vous pouvez
	pr&eacute;ciser &agrave; la commande <command>man</command> laquelle
	vous d&eacute;sirez en sp&eacute;cifiant la section:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Cela affichera la page de manuel de la commande utilisateur
	<command>chmod</command>.  Les r&eacute;f&eacute;rences &agrave;
	une section particuli&egrave;re du manuel en ligne sont
	traditionnellement plac&eacute;es entre parenth&egrave;ses, ainsi
	&man.chmod.1; se rapporte &agrave; la commande
	utilisateur <command>chmod</command> et &man.chmod.2; se
	rapporte &agrave; l'appel syst&egrave;me.</para>

      <para>C'est parfait si vous connaissez le nom de la commande et
	vous souhaitez simplement savoir comment l'utiliser, mais qu'en
	est-il si vous ne pouvez pas vous rappelez du nom de la
	commande?  Vous pouvez utiliser <command>man</command> pour
	rechercher des mots-cl&eacute;s dans les descriptions de commandes en
	employant l'option <option>-k</option>:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Avec cette commande on vous affichera la liste des commandes
	qui ont le mot-cl&eacute; &ldquo;mail&rdquo; dans leurs descriptions.
	C'est en fait &eacute;quivalent &agrave; l'utilisation de la commande
	<command>apropos</command>.</para>

      <para>Ainsi, vous regardez toutes ces commandes fantaisistes
	contenues dans <filename>/usr/bin</filename> mais vous n'avez
	pas la moindre id&eacute;e de ce quelles font vraiment?  Faites
	simplement:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>ou</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>ce qui fait la m&ecirc;me chose.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>Fichiers GNU Info</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>
      <indexterm><primary>Fondation pour le Logiciel Libre</primary></indexterm>

      <para>FreeBSD inclut beaucoup d'applications et d'utilitaires
	produit par la Fondation pour le Logiciel Libre ( Free Software
	Foundation).  En plus des pages de manuel, ces programmes sont
	fournis avec des documents hypertexte appel&eacute;s fichiers
	<literal>info</literal> qui peuvent &ecirc;tre lus avec la commande
	<command>info</command> ou, si vous avez install&eacute;
	<application>emacs</application>, dans le mode info
	d'<application>emacs</application>.</para>

      <para>Pour utiliser la commande &man.info.1;, tapez simplement:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Pour une br&egrave;ve introduction, tapez <literal>h</literal>.
	Pour une r&eacute;f&eacute;rence rapide sur la commande, tapez
	<literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

