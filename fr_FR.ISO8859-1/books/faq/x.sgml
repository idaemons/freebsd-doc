<!--
	The FreeBSD Documentation Project
	The FreeBSD French Documentation Project
         
        $FreeBSD$ 
        Original revision: n.nn
-->   

  <chapter id="x">
    <title> Le syst&egrave;me X-Windows et les consoles virtuelles </title>

    <sect1>
      <title> Je veux lancer X, comment dois-je faire ?  </title>

      <para>
La mani&egrave;re la plus simple est de sp&eacute;cifier au moment de
l'installation que l'on veut utiliser X.
      </para>

      <para>
Puis, lire la documentation suivante sur l'outil
<ulink url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xf86config"> xf86config </ulink>, qui vous aidera dans la configuration de
XFree86(tm) pour vos cartes graphiques, souris etc...      
	  </para>


      <para>
Vous pouvez aussi regarder du c&ocirc;t&eacute; du serveur Xaccel qui est disponible
pour un prix tr&egrave;s raisonnable/ Voir la section sur
<ulink url="http://www.freebsd.org/cgi/man.cgi?manpath=xig"> Xi Graphics </ulink>pour plus de d&eacute;tails.
	  </para>
  </sect1>

    <sect1>
      <title> Pourquoi ma souris ne marche pas sous X ? <anchor id="x-and-moused">  </title>

      <para>
Si vous utilisez syscons (le driver par d&eacute;faut de la console), 
vous pouvez configurer FreeBSD de telle sorte qu'il puisse supporter un
pointeur de souris sur chacun des &eacute;crans virtuels. Afin d'&eacute;viter des
conflits avec X, les supports syscons un p&eacute;riph&eacute;rique virtuel nomm&eacute;
``<filename>/dev/sysmouse</filename>''.  
Tous les &eacute;v&egrave;nement li&eacute;s &agrave; la souris sont &eacute;crit vers le p&eacute;riph&eacute;rique 
sysmouse, en utilsant le protocole MouseSystems. Si vous voulez utiliser
votre souris sur une console virtuelle  ou plus, 
<emphasis remap="bf">et</emphasis> utiliser X, la configuration suivante
est recommand&eacute;e.

      <programlisting>
/etc/rc.conf:
moused_type=ps/2          # or whatever your actual type is
moused_port=/dev/psm0     # or whatever your real port is
moused_flags=

/etc/XF86Config
Section Pointer
Protocol "MouseSystems"
Device   "/dev/sysmouse"
.....
      </programlisting>
	  </para>

      <para>
Certaines personnes pr&eacute;f&egrave;rent utiliser ``<filename>/dev/mouse</filename>''
sous X. Ppour le faire marcher, ``<filename>/dev/mouse</filename>'' 
devrait &ecirc;tre un lien symbolique pour
<ulink url="http://www.freebsd.org/cgi/man.cgi?sysmouse"> /dev/sysmouse</ulink>
      <programlisting>
 cd /dev
 rm -f mouse
 ln -s sysmouse mouse
      </programlisting>
	  </para>
    </sect1>

    <sect1>
      <title> les menus X Window et les bo&icirc;tes de dialogue ne marchent pas bien!  </title>

      <para>
Essayez de d&eacute;sactiver la touche Num Lock.
	  </para>

      <para>
Si votre touche Num Lock est activ&eacute;e par d&eacute;faut au moment du boot, vous
pouvez ajouter la ligne suivante dans la section
``<emphasis>Keyboard</emphasis>'' du fichier 
        <filename>XF86config</filename>.
	  </para>

      <programlisting>
 Let the server do the NumLock processing.  This should only be
 required when using pre-R6 clients
ServerNumLock
      </programlisting>
    </sect1>

    <sect1>
      <title> Qu'est ce qu'une console virtuelle, et comment puis-je en avoir plus ?  </title>

      <para>
En gros, les consoles virtuelles vous permettent d'avoir plusieurs
sessions simultan&eacute;es sur la m&ecirc;me machine sans faire de trucs compliqu&eacute;s
du genre monter un r&eacute;seau, ou lancer X.
	  </para>

      <para>
Quand le syst&egrave;me d&eacute;marre, il vous affichera une invite de login sur le
moniteur juste apr&egrave;s avoir affich&eacute; les messages du boot. Vous pouvez
taper votre login et votre mot de passe et commencer &agrave; travailler (ou &agrave;
jouer !) sur la premi&egrave;re console virtuelle.
	  </para>

      <para>
A un moment, vous voudrez probablement ouvrir une autre session, par
exemple pour lire la documentation d'un programme que vous &ecirc;tes en train
d'ex&eacute;cuter, ou alors lire le courrier en attendant qu'un transfert FTP
se termine. Fais juste  Alt-F2 (Appuyez en maintenant la touche Alt
puis, pressez F2), et vous trouverez une invite de login vous attendant
sur la seconde ``console virtuelle ''! Quand vous voudrez revenir &agrave; la
session de d&eacute;part, faites Alt-F1.
	  </para>

      <para>
L'installation par d&eacute;faut de FreeBSD a 3 consoles virtuelles activ&eacute;es,
et  Alt-F1, Alt-F2, et d Alt-F3 vous permettra de basculer entre ces
consoles virtuelles.

Pour en activer plus, &eacute;ditez 
<ulink url="http://www.freebsd.org/cgi/man.cgi?ttys">/etc/ttys</ulink>
et ajoutez les entr&eacute;es pour ``<filename>ttyv4</filename>'' 
&agrave; 
``<emphasis remap="tt">ttyvc</emphasis>'' apr&egrave;s les commentaires sur les ``terminaux virtuels'':

      <programlisting>
 Edit the existing entry for ttyv3 in /etc/ttys and change
 "off" to "on".
ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
ttyva   "/usr/libexec/getty Pc"         cons25  on secure
ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
      </programlisting>
	  </para>

      <para>
Utilisez en autant que vous voulez/ Mais plus vous avez de terminaux
virtuels, plus vous utilisez de ressources; cela peut-&ecirc;tre important si
vous avez 8Mo de RAM ou moins. Vous pouvez aussi changer
``<filename>secure</filename>'' to ``<filename> insecure</filename>''.
	  </para>

      <para>
<emphasis remap="bf">NOTE IMPORTANTE</emphasis> si vous 
voulez lancer un serveur X, vous <emphasis remap="bf">DEVEZ</emphasis>
avoir au moins un terminal virtuel non utilis&eacute; (ou d&eacute;sactiv&eacute;)afin qu'il
puisse l'utiliser.
Tout cela pour dire que si vous voulez une invite de prompt pour les tous
les 12 de vos touches Alt-fonctions, pas de chance, vous pourrez le faire
que pour 11 d'entre eux si vous voulez aussi lancer un serveur X sur cette
machine.
	  </para>

      <para>
La meilleure fa&ccedil;on de d&eacute;sactiver une console est de la d&eacute;selectionner.
Par exemple, si vous avez allou&eacute; tous les 12 terminaux mentionn&eacute;
ci-dessus, et que vous voulez lancer X, vous aurez &agrave; changer le r&eacute;glage
pour le terminal virtuel 12 de :

      <programlisting>
ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
      </programlisting>
	  </para>

      <para>&agrave;:

      <programlisting>
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
      </programlisting>
	  </para>

      <para>
Si votre clavier n'a que 10 touches de fonctions, vous pouvez terminer
par :

      <programlisting>
ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
ttyva   "/usr/libexec/getty Pc"         cons25  off secure
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
      </programlisting>
	  </para>

      <para>
(Vous pouvez aussi juste effacer ces lignes)
	  </para>

      <para>
Une fois que vous avez &eacute;dit&eacute;
<ulink url="http://www.freebsd.org/cgi/man.cgi?ttys"> /etc/ttys" </ulink>,
l'&eacute;tape suivante est de s'assurer que vous avez assez de p&eacute;riph&eacute;riques de
terminaux virtuels. 
La plus simple mani&egrave;re de proc&eacute;der est :

      <programlisting>
 cd /dev
 ./MAKEDEV vty12                 # For 12 devices
      </programlisting>
	  </para>

      <para>
Ensuite, la plus simple (et plus propre) mani&egrave;re d'activer la console
virtuelle est de rebooter. Malgr&egrave; tout, si vous voulez vraiment 
ne pas avoir &egrave; rebooter, vous pouvez juste arr&ecirc;ter le syst&egrave;me X Window
et ex&eacute;cuter <emphasis remap="tt">root</emphasis>.

      <programlisting>
kill -HUP 1
      </programlisting>
	  </para>

      <para>
Il est imp&eacute;ratif d'arr&ecirc;ter compl&egrave;tement X Window s'il est en train de
marcher, avant de lancer cette commande. Si vous ne le faite pas, votre
syst&egrave;me, se trouvera probablement suspendu/bloqu&eacute; apr&egrave;s le lancement de
la commande kill.
	  </para>
    </sect1>

    <sect1>
      <title>Comment acc&eacute;der &agrave; mes consoles virtuelles depuis X ? </title>

      <para>
Si la console est actuellement en train d'afficher X Window, vous pouvez
utiliser Ctrl-Alt-F1, etc. pour passer d'une console &agrave; une autre.

Notez cependantm qu'une fois que vous avez bascul&eacute; depuis X Window vers un
terminal virtuel, vous ne pouvez utiliser seulement les touches de fonctions
Alt- pour passer &agrave; un autre terminal virtuel ou revenir &egrave; X Window.
Vous n'avez pas &agrave; maintenir enfonc&eacute; la touche Ctrl. Si vous utilisez la
touche contr&ocirc;le pour revenir a X sur certaines vieilles versions, vous
pouvez retrouver votre console texte bloqu&eacute;e en mode ``control-lock''
Taper la touche contr&ocirc;le &agrave; nouveau pour le d&eacute;bloquer.
	  </para>
  </sect1>

    <sect1>
      <title>Comment d&eacute;marrer XDM au boot ?</title>

      <para>
Il y a deux &eacute;coles de pens&eacute;e &agrave; propos du d&eacute;marrage de 
<ulink url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm" >xdm</ulink>
Une &eacute;cole d&eacute;marre xdm epuis
<ulink url="http://www.freebsd.org/cgi/man.cgi?ttys"> <filename>/etc/ttys</filename></ulink> en utilisant l'exemple fourni.
tandis que l'autre lance simplement xdm depuis
<ulink url="http://www.freebsd.org/cgi/man.cgi?rc" > rc.local</ulink>
depuis un script  <emphasis remap="tt">X.sh</emphasis>
dans <filename>/usr/local/etc/rc.d</filename>.
Les deux approches sont valides, et suivant les situations, une m&eacute;thode
peut marcher et pas l'autre. Dans les deux cas, le r&eacute;sultat est le m&ecirc;me :
X fera appara&icirc;tre une incite de login graphique.
	  </para>

      <para>
La m&eacute;thode du ttys a l'avantage de documenter quel vty X va d&eacute;marrer et
en passant la responsabilit&eacute; de red&eacute;marrer le serveur X au logout pour
s'initialiser. La m&eacute;thode rc.local rend la destruction par un kill de
xdm tr&egrave;s facile si jamais un probl&egrave;me de d&eacute;marrage du serveur X &eacute;tait
rencontr&eacute;.
	  </para>

      <para>
Si <emphasis remap="tt">xdm</emphasis> est charg&eacute; depuis /etc/rc.local,
il peut-&ecirc;tre d&eacute;marr&eacute; avec n'importe quel argument (i.e comme un d&eacute;mon).
	  </para>

      <para>
Une version pr&eacute;c&eacute;dente de la FAQ disait d'ajouter les
<emphasis remap="tt">vt</emphasis> que vous vouliez que X utilise dans le
fichier
      <filename>/usr/X11R6/lib/X11/xdm/Xservers</filename>. Cela n'est pas
n&eacute;cessaire, et X utilisera le premier 
<emphasis remap="tt">vt</emphasis> qu'il trouvera.
	  </para>
  </sect1>

    <sect1>
      <title> Quand je lance xconsole, j'obtiens ``Couldn't open console'' </title>

      <para>Si vous d&eacute;marrez
<ulink url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=X" >X</ulink> 
avec 
<ulink url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=startx" >startx</ulink>, 
les permissions sur /dev/console  ne seront <emphasis remap="tt">pas </emphasis> chang&eacute;, ce qui entra&icirc;nera que
<ulink url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xterm" >xterm -C</ulink> 
et <ulink url= "http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xconsole" >xconsole</ulink> ne marcheront pas.
	  </para>

      <para>
Cela est d&ucirc; &agrave; la mani&egrave;re dont les droits sur la consoles sont 
fix&eacute;s par d&eacute;faut.
Sur un syst&egrave;me multi-utilisateur, on ne veut pas n&eacute;cessairement que
n'importe quel utilisateur ait la possibilit&eacute; d'&eacute;crire sur la console
syst&egrave;me. Pour les utilisateurs qui se logguent directement sur la
machine  avec un VTY, le fichier
<ulink url="http://www.freebsd.org/cgi/man.cgi?fbtab">fbtab</ulink>
est l&agrave; pour r&eacute;soudre ce probl&egrave;me.
	  </para>

      <para>
En pratique, assurez vous d'avoir une ligne d&eacute;comment&eacute; de la forme :

      <programlisting>
/dev/ttyv0 0600 /dev/console
      </programlisting>
	  </para>

      <para>dans<ulink url="http://www.freebsd.org/cgi/man.cgi?fbtab(5)" ><filename>/etc/fbtab</filename></ulink> et cela assurera que quiconque se
logguera sur
      <filename>/dev/ttyv0</filename> obtiendra les droits sur la console.
	  </para>
  </sect1>

    <sect1>
      <title>Ma souris PS/2 ne se comporte pas bien sous X.</title>

      <para>
Votre souris et votre pilote de souris ont d&ucirc; se d&eacute;synchroniser
	  </para>

      <para>
Dans les versions 2.2.5 et avant, passer de X &agrave; un termical virtuel et
revenir &agrave; X ensuite , peuvent les re-synchroniser. Si le probl&egrave;me
appara&icirc;t souvent, vous pouvez ajouter l'option suivante dans votre
fichier de configuration du noyau, et recompiler.

      <programlisting>
options PSM_CHECKSYNC
      </programlisting>
	  </para>

      <para>
voir la section sur 
<ulink url="http://www.freebsd.org/cgi/man.cgi?=make-kernel"> la construction du noyau</ulink>
si vous n'avez aucune exp&eacute;rience dans la recompilation de noyau.
	  </para>

      <para>
Avec cette option, vous aurez moins de chance d'avoir de probl&egrave;me de
synchronisation entre la souris et le pilote. Si, malgr&egrave;s tout, vous aviez
ce probl&egrave;me, cliquez sur un bouton quelconque de la souris en maintenant
la souris jusqu'&agrave; resynchroniser la souris et le  pilote.
	  </para>

      <para>
Notez que malheureusement cette option peut ne pas marcher avec tous les
syst&egrave;mes et vide la fonctionnalit&eacute; ``TAP'' du p&eacute;riph&eacute;rique ALPS GlidePoint
attach&eacute; auport souris PS/2
	  </para>

      <para>
Dans les versions 2.2.6 et plus, la v&eacute;rification de la synchronisation
est un peu mieux faite et est standard avec les pilotes souris PS/2.
Cela devrait m&ecirc;me marcher avec GlidePoint. (comme le code de
v&eacute;rification est devenu une fonctionnalit&eacute; standard, l'option PSM_CHECKSYNC
n'est pas disponible dans ces versions). Malgr&egrave;s il y a des rares
cas o&ugrave; le pilote peut de fa&ccedil;on erron&eacute;e repporter des probl&egrave;mes de
synchronisation, et vous pourrez alors voir le message :

      <programlisting>
psmintr: out of sync (xxxx != yyyy)
      </programlisting>

et voir que votre souris ne marche pas correctement.
	  </para>

      <para>
Si cela arrive, d&eacute;sactiver le mode de v&eacute;rification de la synchronization
en  positionnant le drapeau pour les pilotes de souris PS/2 &agrave; 0x100.
Entrez dans <emphasis>UserConfig</emphasis> en tapant ``<filename>-c</filename>'' option 
&agrave; l'invite du boot.

      <programlisting>
boot: -c
      </programlisting>

Puis en ligne de comande de  <emphasis>UserConfig</emphasis>, tapez :

      <programlisting>
UserConfig>flags psm0 0x100
UserConfig>quit
      </programlisting>
	  </para>
  </sect1>

    <sect1>
      <title>Ma souris PS/2 mouse de MouseSystems ne marche pas</title>

      <para>
Certains ont rapport&eacute;s que certains mod&egrave;les de  souris PS/2 de MouseSystem
ne marchaient que lorsqu'ils &eacute;taient mis en mode ``haute r&eacute;solution''.
D'un autre c&ocirc;t&eacute;, le curseur de souris peut sauter d'une extr&eacute;mit&eacute; de
l'&eacute;cran &agrave; l'autre tr&egrave;s souvent.
	  </para>

      <para>
Malheureusement, il n'y a pas de solution pour les versions 2.0.X et
2.1.X. Dans les versions 2.2 &agrave; 2.2.5, ajouter le patch suivant &agrave;
      <filename>/sys/i386/isa/psm.c</filename> et reconstruisez le noyau. Voir
la section sur 
<ulink url="http://www.freebsd.org/cgi/man.cgi?make-kernel"> la construction d'un noyau</ulink>si
vous n'avez aucune exp&eacute;rience dans la construction des noyaux,

      <programlisting>
diff -u psm.c.orig psm.c
@@ -766,6 +766,8 @@
if (verbose >= 2)
log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
unit, i);
+    set_mouse_resolution(sc->kbdc, PSMD_RES_HIGH);
+
if 0
set_mouse_scaling(sc->kbdc); 	/* 1:1 scaling */
set_mouse_mode(sc->kbdc);		/* stream mode */
      </programlisting>
	  </para>

      <para>
Dans les versions 2.2.6 et plus, sp&eacute;cifier le drqpeau 0x04 au pilote de
souris PS/2 afin de mettre la souris en mode haute r&eacute;solution.
Entrez dans<emphasis>UserConfig</emphasis> en sp&eacute;cifiant l'option
``<filename>-c</filename>'' &agrave; l'invite du boot.

      <programlisting>
boot: -c
      </programlisting>

puis, dans la ligne de commande de<emphasis>UserConfig</emphasis> 
tapez :

      <programlisting>
UserConfig>flags psm0 0x04
UserConfig>quit
      </programlisting>
	  </para>

      <para>Voir les sections pr&eacute;c&eacute;dentes pour les autres causes
possibles de probl&egrave;mes avec la souris.</para>
  </sect1>

   <sect1>
    <title>Lorsque je construis une application X, <emphasis remap="tt">imake</emphasis> dit qu'il ne trouve pas <emphasis remap="tt">Imake.tmpl</emphasis>. O&ugrave; est-t-il ?  </title>

    <para>
Imake.tmpl est une partie du paquetage Imake, un outil de d&eacute;veloppement
standart sous X. Imake.tmpl,tout comme plusieurs fichiers d'en-t&ecirc;te qui sont
requis lors de la construction d'applications X est contenu dans la
distribution de programmes X. Vous pouvez l'installer depuis sysinstall
ou manuellement &agrave; partir des fichiers de distributions X.
	  </para>

  </sect1>

  <sect1>
   <title>Comment puis-je inverser les boutons de la souris ?  </title>

   <para>Lancez la commande 
<emphasis remap="tt">xmodmap -e "pointer = 3 2 1"</emphasis>
depuis votre  .xinitrc ou .xsession.
   </para>
  </sect1>
  </chapter>

