<?xml version="1.0" encoding="ISO8859-1" standalone="no"?>
<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook XML V4.2-Based Extension//EN"
	"../../../share/sgml/freebsd42.dtd" [
<!ENTITY % entities PUBLIC "-//FreeBSD//ENTITIES DocBook FreeBSD Entity Set//FR" "../../share/sgml/entities.ent">
%entities;
]>

<!--
     The FreeBSD Documentation Project
     The FreeBSD French Documentation Project

     $FreeBSD$
     Original revision: 1.39
-->

<article lang="fr">
  <articleinfo>
    <title>Refaire votre monde (avec &ldquo;make world&rdquo;)</title>
    <authorgroup>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
	<affiliation>
	  <address><email>Nik.Clayton@nothing-going-on.demon.co.uk</email></address>
	</affiliation>
      </author>
    </authorgroup>
    <pubdate>10 Juillet 1997</pubdate>

    <releaseinfo>$FreeBSD$</releaseinfo>

  <abstract>
    <para>Ce document présuppose que vous ayez installé une version du code
      source de FreeBSD dans le répertoire <filename>/usr/src</filename>.
      Ce peut être la dernière version de la branche en cours de
      développement -current, &agrave; moins que vous ne restiez simplement &agrave; niveau
      sur la branche -stable. Vous pouvez avoir téléchargé l'instantané le plus
      récent, ou bien rester &agrave; jour en utilisant les mécanismes fournis
      par CVSup ou CTM.</para>

    <para>Dans les deux cas, vous disposez du code source et voulez maintenant
      mettre &agrave; jour votre système.</para>

    <para>Il y a un certain nombre d'étapes &agrave; effectuer pour y arriver,
      et quelques pièges &agrave; éviter en cours de route. Ce document vous
      guide pas &agrave; pas &agrave; chacune de ces étapes.</para>

    <para>Il existe aussi des <link linkend="translations">Traductions</link>
       de ce document dans d'autres langues.</para>
    &trans.a.haby;
  </abstract>
</articleinfo>

<sect1>
  <title>Avertissements préalables</title>
  <note>
    <title>Faites une sauvegarde</title>

    <para>Je n'insisterai jamais assez sur l'importance de faire un sauvegarde
      de votre système <emphasis>avant</emphasis> toute autre chose. Bien qu'il
      soit facile de &ldquo;refaire le monde&rdquo;
      (N.d.T.: recompiler FreeBSD)&nbsp;-&nbsp;si
      vous suivez ces instructions, vous ferez forcément des erreurs &agrave; un moment
      ou &agrave; un autre, sans compter les erreurs des autres dans l'arborescence des
      sources qui empêcheraient votre système de redémarrer.</para>

    <para>Assurez-vous que vous avez bien fait une sauvegarde. Ayez une
      disquette de maintenance &agrave; portée de la main. Je n'ai jamais eu &agrave; les
      utiliser, et, je touche du bois, espère ne jamais devoir m'en servir,
      mais prudence est mère de sûreté.</para>
  </note>

  <note>
    <title>Abonnez-vous &agrave; la bonne liste de diffusion</title>

    <para>Les branches -stable et -current du code de FreeBSD sont, par nature,
      <emphasis>en développement</emphasis>. Les gens qui participent au projet
      FreeBSD sont humains, et des erreurs se produisent parfois.</para>

    <para>Ces erreurs sont parfois bénignes. Votre système affiche simplement
      un nouveau message d'avertissement. Elles peuvent aussi être
      catastrophiques, et empêcher votre système de redémarrer, détruire vos
      systèmes de fichiers (ou pire).</para>

    <para>Quand de tels problèmes se produisent, un avertissement
      &ldquo;heads up&rdquo; est posté sur la liste de diffusion appropriée,
      décrivant le problème et les machines concernées. Un message
      &ldquo;all clear&rdquo; est diffusé quand le problème est
      résolu.</para>

    <para>Si vous restez &agrave; niveau sur -stable ou -current et ne lisez pas
      <email>FreeBSD-stable@FreeBSD.ORG</email> ou
      <email>FreeBSD-current@FreeBSD.ORG</email>, vous allez au devant
      d'ennuis.</para>
  </note>

  <important>
    <para>S'il vous plaît, ne me posez pas de questions que vous devriez poster
      sur les listes -questions, -current, ou -stable. Je n'ai ni le temps
      ni l'environnement nécessaire pour diagnostiquer des problèmes
      spécifiques, et n'ai probablement pas votre réponse. Les membres de
      ces listes de diffusion sont nombreux, expérimentés et serviables, aussi,
      posez leur vos questions. Adressez-moi cependant vos commentaires,
      réponses et corrections<footnote><para>En anglais !</para></footnote>.
      Si vous vous adressez &agrave; moi au sujet de ce
      document, <emphasis>merci</emphasis> de m'indiquer le numéro de version
      qui se trouve en haut de cette page, que je sache &agrave; quelle version vous
      faites référence.</para>

    <para>Ce document est un effort collectif. De nombreuses personnes y ont
      participé, elles sont mentionnées dans les
      <link linkend="contributors">Contributions</link>
      en fin de document.</para>

    <para>Copyright (c) 1997, 1998 Nik Clayton, All rights reserved.</para>

    <para>Vous pouvez redistribuer et utiliser ce document sous forme
      de source (SGML DocBook) ou  'compilé' (HTML, PDF, PostScript, RTF,
      etc..) avec ou sans modifications &agrave; la condition suivante:</para>

    <itemizedlist>
      <listitem>
	<para>Le document redistribué doit inclure la notice de copyright
          ci-dessus et l'avertissement ci-dessous, avant le corps du
          document.</para>
      </listitem>
    </itemizedlist>

    <para>THIS TUTORIAL IS PROVIDED BY NIK CLAYTON &ldquo;AS IS&rdquo; AND ANY
      EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
      PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NIK CLAYTON BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
      DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
      OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
      HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
      STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
      ANY WAY OUT OF THE USE OF THIS TUTORIAL, EVEN IF ADVISED OF THE
      POSSIBILITY OF SUCH DAMAGE.</para>

    <para>CE DOCUMENT EST FOURNI PAR NIK CLAYTON &ldquo;TEL QUEL&rdquo; ET
      AUCUNE GARANTIE EXPRESSE OU IMPLICITE, Y COMPRIS, MAIS NON LIMITEE,
      GARANTIES IMPLICITES DE COMMERCIABILITE ET D'ADEQUATION A UN BUT
      PARTICULIER N'EST DONNEE. EN AUCUN CAS NIK CLAYTON NE
      SAURAIT ETRE TENU RESPONSABLE
      DES DOMMAGES DIRECTS, INDIRECTS, ACCIDENTELS, SPECIAUX OU CONSEQUENTS
      (Y COMPRIS, MAIS SANS LIMITATION, LA FOURNITURE DE BIENS ET SERVICES
      ANNEXES; DEFAUT D'UTILISABILITE, PERTE DE DONNEES OU DE PROFITS; OU
      INTERRUPTION DE TRAVAIL) QUELLE QU'EN SOIT LA CAUSE ET SELON TOUTE
      DEFINITION DE RESPONSABILITE, SOIT PAR CONTRAT, RESPONSABILITE STRICTE,
      OU PREJUDICE (Y COMPRIS NEGLIGENCE OU AUTRES) IMPUTABLE D'UNE FACON
      OU D'UNE AUTRE A L'UTILISATION DE CE DOCUMENT, MEME APRES AVOIR ETE AVISE
      DE LA POSSIBILITE D'UN TEL DOMMAGE.</para>
  </important>
</sect1>

  <sect1>
    <title>Examinez <filename>/etc/make.conf</filename></title>

    <para>Reportez-vous au fichier <filename>/etc/make.conf</filename>.
      Il contient les valeurs par défaut utilisées par la commande
      <command>make</command>, qui sera employée pour la recompilation. Elles sont aussi
      utilisées toutes les fois que vous invoquez <command>make</command>, il est donc
      bon de vous assurer qu'elles comportent les valeurs appropriées &agrave; votre
      système.</para>

    <para>Tout y est, par défaut, en commentaire. Activez les options qui
      vous paraissent utiles. Pour un utilisateur normal (qui ne développe
      pas), il faut probablement utiliser les définitions de CFLAGS et
      NOPROFILE.</para>

    <note>
      <title>Version 2.1.7 et antérieures</title>

      <para>Si votre machine dispose d'une unité de calcul en virgule
        flottante (386DX, 486DX, Pentium et ultérieurs) vous pouvez aussi
        activer l'option HAVE_FPU.</para>

      <para>Cette définition a disparu depuis la version 2.2.2 de
	FreeBSD.</para>
    </note>

    <para>Examinez les autres définitions (COPTFLAGS, NOPORTDOCS et ainsi de
      suite) et décidez de celles qui vous conviennent.</para>
  </sect1>

  <sect1>
    <title>Mettez &agrave; jour le fichier <filename>/etc/group</filename></title>

    <para>Le répertoire <filename>/etc</filename> contient la plupart des
      informations de configuration de votre système, ainsi que ses procédures
      de démarrage. Certaines de ces procédures changent d'une version &agrave; l'autre
      de FreeBSD.</para>

    <para>Certains fichiers de configuration sont aussi utilisés en permanence
      par le système. En particulier, <filename>/etc/group</filename>.</para>

    <para>Il est arrivé que la phase d'installation de &ldquo;make
      world&rdquo; ait besoin que certains utilisateurs et groupes existent.
      Il y a de fortes chances qu'ils n'aient pas été définis avant la mise
      &agrave; jour. C'est une source de problèmes.</para>

    <para>L'exemple le plus récent concerne l'ajout du groupe &ldquo;ppp&rdquo;
      (renommé par la suite &ldquo;network&rdquo;). Les utilisateurs ont vu leur
      mise &agrave; jour avorter &agrave; l'installation du sous-sytème
      <filename>ppp</filename> sous un groupe inexistant (chez eux).</para>

    <para>La solution consiste &agrave; examiner le fichier
      <filename>/usr/src/etc/group</filename> et &agrave; le comparer &agrave; votre propre
      liste de groupes. S'il y a des groupes dans le nouveau fichier qui ne
      sont pas dans votre fichier, copiez-les. De même, vous devez renommer
      tout groupe de votre fichier <filename>/etc/group</filename> qui a le
      même GID, mais un nom différent, qu'un groupe du fichier
      <filename>/usr/src/etc/group</filename>.</para>

    <tip>
      <para>Si vous êtes particulièrement paranoïaque, vous pouvez contrôler
        votre système pour trouver les fichiers appartenant au groupe que vous
        renommez ou supprimez. Une commande du type:

	<informalexample>
	  <screen><prompt>#</prompt> <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>
	</informalexample>

	vous donnera la liste des fichiers appartenant au groupe
        <replaceable>GID</replaceable>
	(qui peut être un nom de groupe ou un identifiant numérique).</para>
    </tip>
  </sect1>

  <sect1>
    <title>Passez en mode mono-utilisateur</title>

    <para>Il vaut mieux recompiler le système en mode mono-utilisateur. En
      dehors du fait que cela ira un peu plus vite, la réinstallation va
      modifier un grand nombre de fichiers systèmes importants, tous les
      binaires de base, les bibliothèques, les fichiers inclus et ainsi de
      suite. Les modifier quand le système est en service (en particulier
      s'il y a des utilisateurs connectés &agrave; ce moment l&agrave;), c'est aller au devant
      de problèmes.</para>

    <para>Cela dit, si vous avez confiance en vous, vous pouvez vous en
     passer.</para>

    <note>
      <title>Version 2.2.5 et ultérieure</title>

      <para>Comme décrit plus bas, la version 2.2.5 et les suivantes de
        FreeBSD séparent la recompilation et l'installation. Vous pouvez
        dès lors <emphasis>compiler</emphasis> le nouveau système en mode
        multi-utilisateurs et passer en mode mono-utilisateur juste pour
	l'installer.</para>
    </note>

    <para>En tant que super-utilisateur, vous pouvez passer la commande:

      <informalexample>
<screen><prompt>#</prompt> <userinput>shutdown now</userinput></screen>
      </informalexample>

      sur un système en fonctionnement, pour passer en mode
      mono-utilisateur.</para>

    <para>Ou bien, redémarrez le système, et, &agrave; l'invite de démarrage, entrez
      l'indicateur <option>-s</option>. Le système redémarrera en mode
      mono-utilisateur. A l'invite de l'interpréteur de commandes, exécutez:

      <informalexample>
<screen><prompt>#</prompt> <userinput>fsck -p</userinput>
<prompt>#</prompt> <userinput>mount -u /</userinput>
<prompt>#</prompt> <userinput>mount -a -t ufs</userinput>
<prompt>#</prompt> <userinput>swapon -a</userinput></screen>
      </informalexample>

      pour effectuer la vérification des systèmes de fichiers, remontez
      <filename>/</filename> en mode lecture/écriture, et monter tous les
      autres systèmes de fichiers UFS listés dans le fichier
      <filename>/etc/fstab</filename>, puis activez la pagination.</para>
  </sect1>

  <sect1>
    <title>Effacez <filename>/usr/obj</filename></title>

    <para>Les composants du système reconstruit sont au fur et &agrave; mesure placés
      dans les sous-répertoires de <filename>/usr/obj</filename> (par défaut).
      Ces répertoires masquent ceux de <filename>/usr/src</filename>.</para>

    <para>Vous pouvez accélérer le travail de &ldquo;make world&rdquo;,
      et peut-être vous éviter quelques maux de tête en supprimant aussi
      le répertoire <filename>/usr/obj</filename>.</para>

    <para>Certains fichiers dans <filename>/usr/obj</filename> sont marqués
      immuables (reportez-vous aux pages de manuel de
      <command>chflags(1)</command> pour plus de détails). Il faut d'abord
      supprimer cet indicateur.</para>

    <para><informalexample>
<screen><prompt>#</prompt> <userinput>cd /usr/obj</userinput>
<prompt>#</prompt> <userinput>chflags -R noschg *</userinput>
<prompt>#</prompt> <userinput>rm -rf *</userinput></screen></informalexample></para>
  </sect1>

  <sect1>
    <title>Recompilez les sources et installez le nouveau système</title>

    <sect2>
      <title>Toutes versions</title>

      <para>Vous devez être dans le répertoire <filename>/usr/src</filename>,
      donc:

	<informalexample>
	  <screen><prompt>#</prompt> <userinput>cd /usr/src</userinput></screen>
	</informalexample>

      (&agrave; moins, bien sûr, que votre code source soit ailleurs, auquel cas vous
       devez aller dans le répertoire correspondant).</para>

      <para>Pour recompiler le système, vous utilisez la commande <citerefentry>
	  <refentrytitle>make</refentrytitle>
	  <manvolnum>1</manvolnum>
	</citerefentry>. Cette commande lit ses instructions dans le fichier
	<filename>Makefile</filename>, qui décrit comment reconstruire les
        modules qui constituent FreeBSD, dans quel ordre,
	et ainsi de suite.</para>

      <para>Le format général de la commande que vous taperez sera:

	<informalexample>
	  <screen><prompt>#</prompt> <userinput>make <option>-<replaceable>x</replaceable></option> <option>-D<replaceable>VARIABLE</replaceable></option> <replaceable>cible</replaceable></userinput></screen>
	</informalexample>
      </para>

      <para>Dans cet exemple, <option>-<replaceable>x</replaceable></option> est
	une option  que vous donnez &agrave; <citerefentry>
	  <refentrytitle>make</refentrytitle>
	  <manvolnum>1</manvolnum>
	</citerefentry>. Reportez-vous aux pages de manuel pour connaître les
	options disponibles.</para>

      <para><option>-D<replaceable>VARIABLE</replaceable></option> transmet une
	variable au fichier <filename>Makefile</filename>. Le comportement de
	<filename>Makefile</filename> est défini par ces variables. Ce sont les
	mêmes variables que l'on trouve dans
	<filename>/etc/make.conf</filename>, et c'est un autre moyen de les
	positionner.</para>

      <para>Par exemple:

	<informalexample>
	  <screen><prompt>#</prompt> <userinput>make -DNOPROFILE=true <replaceable>cible</replaceable></userinput></screen>
	</informalexample>

        est une autre manière de dire qu'il ne faut pas compiler les
        bibliothèques profilées et correspond aux lignes:

	<programlisting>NOPROFILE=    true
#   Avoid compiling profiled librairies
#   Ne pas compiler les bibliothèques profilées
	</programlisting>

	du fichier <filename>/etc/make.conf</filename>.</para>

      <para><replaceable>cible</replaceable> dit &agrave; <citerefentry>
	  <refentrytitle>make</refentrytitle>
	  <manvolnum>1</manvolnum>
	</citerefentry> ce que vous voulez faire. Chaque
	<filename>Makefile</filename> définit un certains nombre de
	&ldquo;cibles&rdquo; différentes, et votre choix de cibles détermine
	ce qui se passe.</para>

        <para>Il y a des cibles définies dans le fichier
        <filename>Makefile</filename> que
        vous n'avez pas &agrave; employer. Ce sont des étapes intermédiaires utilisées
        par le processus de recompilation pour décomposer les étapes en
        sous-étapes.</para>

      <para>La plupart du temps, vous n'aurez pas besoin de donner d'options &agrave;
	<citerefentry>
	  <refentrytitle>make</refentrytitle>
	  <manvolnum>1</manvolnum>
	</citerefentry>, et votre commande sera simplement:

	<informalexample>
	  <screen><prompt>#</prompt> <userinput>make <replaceable>cible</replaceable></userinput></screen>
	</informalexample>
      </para>
    </sect2>

    <sect2>
      <title>Enregistrez le résultat</title>

      <para>C'est une bonne idée d'enregistrer le résultat de
	<citerefentry>
	  <refentrytitle>make</refentrytitle>
	  <manvolnum>1</manvolnum>
	</citerefentry> dans un ficher. Si quelque chose se passe mal, vous
	aurez une trace des messages d'erreur, et la liste complète de ce qui
	a été fait. Même si cela ne vous aide pas &agrave; diagnostiquer ce qui n'a pas
        marché, cela peut aider les autres si vous soumettez votre problème sur
        une des listes de diffusion de FreeBSD.</para>

      <para>La meilleure façon de faire cela est d'utiliser la commande
      <citerefentry><refentrytitle>script</refentrytitle>
	  <manvolnum>1</manvolnum>
	</citerefentry>, avec en paramètre le nom du fichier où enregistrer
	les résultats. Vous devez faire cela juste avant de recompiler le
	système, et taper <userinput>exit</userinput> une fois que c'est
	terminé.</para>

      <informalexample>
	<screen><prompt>#</prompt> <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
<prompt>#</prompt> <userinput>make world</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
<prompt>#</prompt> <userinput>exit</userinput>
Script done, &hellip;
	</screen>
      </informalexample>

      <para>Si vous le faites, <emphasis>n'enregistrez pas</emphasis> les
      résultats dans <filename>/tmp</filename>. Ce répertoire peut être vidé
      au prochain redémarrage du sytème. Il vaut mieux les mettre dans
      <filename>/var/tmp</filename>
	(comme dans l'exemple précédent) ou dans le répertoire utilisateur de
        root.</para>
    </sect2>

    <sect2>
      <title>Version 2.2.2 et antérieure</title>

      <para><filename>/usr/src/Makefile</filename> contient la cible
	&ldquo;world&rdquo;, qui recompile tout le système et
	l'installe.</para>

      <para>Utilisez donc:
	<informalexample>
	  <screen><prompt>#</prompt> <userinput>make world</userinput></screen>
	</informalexample>
      </para>
    </sect2>

    <sect2>
      <title>Version 2.2.5 et ultérieure</title>

      <para>A partir de la version 2.2.5 de FreeBSD (de fait, c'est la première
      version &agrave; avoir été créée sur la branche -current, puis rapatriée dans
      la branche -stable entre les versions 2.2.2 et 2.2.5) la cible
      &ldquo;world&rdquo; a été décomposée en deux: &ldquo;buildworld&rdquo;
      et &ldquo;installworld&rdquo;.</para>

      <para>Comme leurs noms l'indiquent, &ldquo;buildworld&rdquo; reconstruit
      la nouvelle arborescence dans <filename>/usr/obj</filename>, et
	&ldquo;installworld&rdquo; l'installe sur la
	machine.</para>

      <para>C'est très utile pour deux raisons. Tout d'abord, vous pouvez
      recompiler en toute sûreté, sans toucher aux composants du système
      actuel. Le processus est &ldquo;autonome&rdquo;. Vous pouvez donc
      exécuter &ldquo;buildworld&rdquo; sur une machine en mode
      multi-utilisateurs
      sans redouter d'effets fâcheux. Je vous recommande néanmoins de toujours
      exécuter l'étape &ldquo;installworld&rdquo; en mode
      mono-utilisateur.</para>

      <para>En second lieu, cela vous permet d'utiliser des systèmes de fichiers
      montés par NFS pour mettre &agrave; jour les autres machines de votre réseau.
      Si vous avez trois machines, A, B, et C que vous voulez mettre &agrave; jour,
      exécutez <command>make buildworld</command> et
      <command>make installworld</command> sur A. B et C doivent alors monter
      par NFS <filename>/usr/src</filename> et <filename>/usr/obj</filename>
      depuis A, et vous pouvez alors exécuter
      <command>make installworld</command> pour
      installer le système recompilé sur B et C.</para>

      <para>La cible &ldquo;world&rdquo; existe toujours
      et vous pouvez l'utiliser
      exactement comme avec la version 2.2.2.
      <command>make world</command> exécute
      <command>make buildworld</command> suivi de <command>make
      installworld</command>.</para>

      <note>
	<para>Si vous utilisez séparement <command>make buildworld</command> et
	  <command>make installworld</command>, vous devez donner &agrave; chaque fois
          les mêmes paramètres &agrave; <citerefentry>
	    <refentrytitle>make</refentrytitle>
	    <manvolnum>1</manvolnum>
	  </citerefentry>.</para>

	<para>Par exemple, si vous exécutez:

	  <informalexample>
	    <screen><prompt>#</prompt> <userinput>make -DNOPROFILE=true buildworld</userinput></screen>
	  </informalexample>

	  vous devrez ensuite installer les résultats avec:

	  <informalexample>
	    <screen><prompt>#</prompt> <userinput>make -DNOPROFILE=true installworld</userinput></screen>
	  </informalexample>

	  sinon il essayera d'installer les bibliothèques profilées
	  qui n'ont pas été recompilées &agrave; l'étape
          <command>make buildworld</command>.</para>
      </note>
    </sect2>

    <sect2>
      <title>-current et ultérieure</title>

      <para>Si vous êtes sur la branche -current, vous pouvez aussi donner
	l'option <option>-j</option> &agrave; <command>make</command>. Cela permet &agrave;
	<command>make</command> d'exécuter plusieurs programmes
        simultanément.</para>

      <para>C'est particulièrement utile sur une machine avec plusieurs
      processeurs. Néanmoins, comme la compilation est plus gourmande en
      Entrées/Sorties qu'en CPU, c'est aussi
      utile sur une machine mono-processeur.</para>

      <para>Typiquement, sur une machine mono-processeur, vous exécuteriez:

	<informalexample>
	  <screen><prompt>#</prompt> <userinput>make -j4 <replaceable>cible</replaceable></userinput></screen>
	</informalexample>

        pour autoriser
	<citerefentry>
	  <refentrytitle>make</refentrytitle>
	  <manvolnum>1</manvolnum>
	</citerefentry> &agrave; exécuter 4 programmes simultanément.
	Les constatations empiriques postées sur les listes de diffusion
        montrent que c'est en général ce qui apporte le plus de gain en
        performances.</para>

      <para>Si vous avez une machine multi-processeurs et que vous avez
      configuré un noyau SMP, essayez des valeurs entre 6 et 10 et voyez quel
      bénéfice vous en tirez.</para>

      <para>N'oubliez pas que c'est toujours expérimental (au moment où j'écris
      ceci), et que des modifications de l'arborescence des sources rendent
      parfois cette possibilité inutilisable. Si vous n'arrivez pas &agrave; recompiler
      avec ce paramètre, essayez sans avant de signaler votre problème.</para>
    </sect2>

    <sect2>
      <title>Durée</title>

      <para>En supposant que tout ce passe bien, il vous faudra attendre
      entre une heure et demie et une demi-journée.</para>

      <para>En règle générale, un P6 200MHz avec plus de 32MB de RAM
        et des disques SCSI corrects exécutera <command>make world</command>
	en environ une heure et demie. Un P133 32MB prendra 5 &agrave; 6
	heures. Revoyez ces chiffres &agrave; la baisse si vos machines sont
	plus lentes&hellip;</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Mettez &agrave; jour <filename>/etc</filename></title>

    <para>Recompiler le système ne met pas &agrave; jour certains répertoires (en
      particulier, <filename>/etc</filename>, <filename>/var</filename> et
      <filename>/usr</filename>) pour y installer des fichiers de configuration
      nouveaux ou modifiés.
      Il vous faudra le faire &agrave; la main, &agrave; vue, et en utilisant &agrave; bon escient
      la commande <command>diff</command>.</para>

    <para>Vous ne pouvez pas vous contenter de copier les fichiers de
      <filename>/usr/src/etc</filename> dans <filename>/etc</filename> pour
      que cela marche. Certains de ces fichiers doivent d'abord être
      &ldquo;installés&rdquo;.
      En effet le répertoire <filename>/usr/src/etc</filename>
      <emphasis>n'est pas</emphasis> une simple copie de ce que devrait
      contenir votre répertoire<filename>/etc</filename>. De plus, il y a
      des fichiers qui doivent être dans <filename>/etc</filename> et ne
      sont pas dans <filename>/usr/src/etc</filename>.</para>

    <para>La façon la plus simple de procéder est d'installer les fichiers
    dans un nouveau répertoire, puis de passer en revue les différences.</para>

    <note>
      <title>Sauvegardez vos fichiers actuels dans
      <filename>/etc</filename></title>

      <para>Bien qu'en principe rien ne sera modifié automatiquement dans ce
	répertoire, prudence est mère de sûreté. Copiez donc votre répertoire
	<filename>/etc</filename> dans un endroit sûr.
        Quelque chose du genre:</para>

	<informalexample>
        <screen><prompt>#</prompt> <userinput>cp -Rp /etc /etc.old</userinput></screen>
	</informalexample>

	<para>fera l'affaire (<option>-R</option> fait une copie récursive,
	<option>-p</option> conserve la date, les autorisations des fichiers
	 et ainsi de suite).</para>
    </note>

    <para>Vous devez créer un jeu de répertoires provisoires pour y installer
      les fichiers de <filename>/etc</filename> et autres. En général,
      je les mets dans <filename>/var/tmp/root</filename>;
      il y a un certain nombre de sous-répertoires &agrave; créer. Pour ce faire,
      exécutez:

      <informalexample>
	<screen><prompt>#</prompt> <userinput>mkdir /var/tmp/root</userinput>
<prompt>#</prompt> <userinput>cd /usr/src/etc</userinput>
<prompt>#</prompt> <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>
	</informalexample>

      qui va créer l'arborescence nécessaire et y installera les fichiers. Un
      grand nombre des sous-répertoires créés dans
      <filename>/var/tmp/root</filename> seront vides et devront être
      supprimés. La façon la plus simple de le faire est:

      <informalexample>
	<screen><prompt>#</prompt> <userinput>cd /var/tmp/root</userinput>
<prompt>#</prompt> <userinput>find -d . -type d | /usr/bin/perl -lne \
  'opendir(D,$_);@f=readdir(D);rmdir if $#f == 1;closedir(D);'</userinput></screen>
      </informalexample>

      qui fait une recherche en profondeur, examine chaque répertoire, et s'il
      ne contient que 2 fichiers (&ldquo;1&rdquo; n'est pas une faute de frappe
      dans la procédure), i.e. &ldquo;<filename>.</filename>&rdquo; et
      &ldquo;<filename>..</filename>&rdquo; supprime le répertoire.</para>

    <para><filename>/var/tmp/root</filename> contient maintenant tous les
      fichiers &agrave; installer &agrave; l'endroit requis sous
      <filename>/</filename>. Vous devez ensuite examiner chacun de ces
      fichiers pour voir en quoi ils diffèrent de vos propres fichiers.</para>

    <para>Notez que certains des fichiers qui ont été installés dans
      <filename>/var/tmp/root</filename> commencent par un &ldquo;.&rdquo; Au
      moment où j'écris ceci, les seuls fichiers concernés sont les fichiers
      d'initialisation des interpréteurs de commandes dans
      <filename>/var/tmp/root/</filename> et
      <filename>/var/tmp/root/root/</filename>, mais il pourrait y en
      avoir d'autres
      (cela dépend de quand vous lirez ces lignes). Assurez-vous d'utiliser
      <command>ls -a</command> pour ne pas les oublier.</para>

    <para>La manière la plus simple de procéder est d'utiliser la commande
    <command>diff</command> pour comparer deux fichiers.</para>

    <para>Par exemple:

      <informalexample>
	<screen><prompt>#</prompt> <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>
      </informalexample>

      vous indiquera les différences entre votre fichier
      <filename>/etc/shells</filename> et le nouveau fichier
      <filename>/etc/shells</filename>. A partir de l&agrave;, décidez si vous
      allez reporter les modifications que vous y avez apportées ou si vous
      allez simplement recopier le nouveau fichier.</para>

    <para><ulink url="http://www.nothing-going-on.demon.co.uk/FreeBSD/make-world/dircmp.pl"><filename>http://www.nothing-going-on.demon.co.uk/FreeBSD/make-world/dircmp.pl</filename></ulink> est une
    petite procédure Perl (Perl 4.036, qui est installé par défaut &agrave; partir de
    la version 2.0 de FreeBSD) qui compare les fichiers de deux répertoires
    (<filename>/etc</filename> et
      <filename>/var/tmp/root/etc</filename> par défaut) et liste les fichiers
      absents ou différents dans les deux répertoires.</para>

    <tip>
      <title>Donnez au nouveau répertoire
	(<filename>/var/tmp/root</filename>) un nom qui inclue une date, pour
        pouvoir facilement comparer différentes versions</title>

      <para>Si vous recompilez fréquemment votre système, vous devrez aussi
      souvent mettre &agrave; jour <filename>/etc</filename>, ce qui peut devenir
      une vrai corvée.</para>

      <para>Vous pouvez accélérer le processus en gardant une copie du dernier
      jeu de fichiers reportés dans <filename>/etc</filename>. La
      procédure suivante vous suggère comment faire.</para>

      <procedure>
	<step>
	  <para>Recompilez le système comme d'habitude. Au moment de mettre &agrave;
	  jour <filename>/etc</filename> et les autres répertoires, donnez au
	  répertoire cible un nom basé sur la date du jour. Si vous faisiez
          cela le 14 Février 1998, vous pouviez procéder comme suit:</para>

	  <informalexample>
	    <screen><prompt>#</prompt> <userinput>mkdir /var/tmp/root-980214</userinput>
<prompt>#</prompt> <userinput>cd /usr/src/etc</userinput>
<prompt>#</prompt> <userinput>make DESTDIR=/var/tmp/root-980214 \
    distrib-dirs distribution</userinput></screen>
	  </informalexample>
	</step>

	<step>
	  <para>Reportez les modifications depuis ce répertoire comme décrit
	  plus haut.</para>

          <para><emphasis>Ne supprimez pas</emphasis> le répertoire
	    <filename>/var/tmp/root-980214</filename> quand vous aurez
	    terminé.</para>
	</step>

	<step>
	  <para>Quand vous chargerez la version la plus récente des sources et
	    la recompilerez, faites de même. Vous aurez alors un nouveau
	    répertoire,
	    <filename>/var/tmp/root-980221</filename> par exemple
            (si vous faites une mise &agrave; jour chaque semaine).</para>
	</step>

	<step>
	  <para>Vous pouvez maintenant voir les modifications intervenues
	  d'une semaine &agrave; l'autre avec quelque chose comme:

	    <informalexample>
	      <screen><prompt>#</prompt> <userinput>cd /var/tmp</userinput>
<prompt>#</prompt> <userinput>diff -r root-980214 root-980221</userinput></screen>
	    </informalexample>

            qui vous donnera les différences entre tous les fichiers des deux
	    répertoires.</para>

	  <para>Typiquement, il y aura beaucoup moins de différences
	    qu'entre <filename>/var/tmp/root-980221/etc</filename>
	    et <filename>/etc</filename>. Comme il y a beaucoup moins de
	    différences, il est beaucoup plus facile de les reporter dans
	    le répertoire <filename>/etc</filename>.</para>
	</step>

	<step>
	  <para>Vous pouvez maintenant supprimer le plus ancien des deux
	    répertoires <filename>/var/tmp/root-*</filename>:

	    <informalexample>
	      <screen><prompt>#</prompt> <userinput>rm -rf /var/tmp/root-980214</userinput></screen>
	    </informalexample>
	  </para>
	</step>

	<step>
	  <para>Répétez l'opération chaque fois que vous devez reporter
	    des modifications dans <filename>/etc</filename>.</para>
	</step>
      </procedure>

      <para>Vous pouvez utiliser la commande <command>date(1)</command> pour
      automatiser la génération des noms de répertoires. Par exemple:

	<informalexample>
	  <screen><prompt>#</prompt> <userinput>mkdir /var/tmp/root-`date "+%y%m%d"`</userinput></screen>
	</informalexample>

        crée un répertoire dont le nom dépend de l'année, du mois et
	du jour.</para>
    </tip>
  </sect1>

  <sect1>
    <title>Mettez &agrave; jour <filename>/dev</filename></title>

    <note>
      <title>DEVFS</title>

      <para>Si vous utilisez DEVFS ce qui suit ne vous concerne probalement
      pas.</para>
    </note>

    <para>Pour des raisons de sécurité, cette mise &agrave; jour se fait en plusieurs
    étapes.</para>

    <para>Copiez tout d'abord <filename>/var/tmp/root/dev/MAKEDEV</filename>
    dans <filename>/dev</filename>.

      <informalexample>
	<screen><prompt>#</prompt> <userinput>cp /var/tmp/root/dev/MAKEDEV /dev</userinput></screen>
      </informalexample></para>

    <para>Prenez maintenant un instantané de l'état de votre répertoire
    <filename>/dev</filename>. Il doit indiquer
    les propriétaires, les droits et les codes majeur et mineur de chaque
    fichier spécial de périphérique, mais pas leur date de dernière mise &agrave; jour.
    La façon la plus facile de procéder est d'utiliser
    la commande <command>awk</command> pour éliminer les informations inutiles:

      <informalexample>
	<screen><prompt>#</prompt> <userinput>cd /dev</userinput>
<prompt>#</prompt> <userinput>ls -l | awk '{print $1, $2, $3, $4, $5, $6, $NF}' > /var/tmp/dev.out</userinput></screen>
      </informalexample></para>

    <para>Ensuite, recréez tous les fichiers spéciaux de périphériques:.

      <informalexample>
	<screen><prompt>#</prompt> <userinput>sh MAKEDEV all</userinput></screen>
      </informalexample></para>

    <para>Reprenez un instantané de l'état de votre répertoire, cette fois-ci
    dans <filename>/var/tmp/dev2.out</filename>. Comparez maintenant ces deux
      instantanés pour voir si certains fichiers spéciaux de périphériques
      n'ont pas été recréés. Il ne devrait pas en manquer, mais prudence est
      mère de sûreté.

      <informalexample>
	<screen><prompt>#</prompt> <userinput>diff /var/tmp/dev.out /var/tmp/dev2.out</userinput></screen>
      </informalexample></para>

    <para>Il manquera peut-être des descripteurs de partitions,
    il vous faudra alors exécuter des commandes du type :

      <informalexample>
<screen><prompt>#</prompt> <userinput>sh MAKEDEV sd0s1</userinput>
</screen>
      </informalexample>

      pour les recréer. Les détails dépendent de votre installation.</para>
  </sect1>

  <sect1>
    <title>Mettez &agrave; jour <filename>/stand</filename></title>

    <note>
      <para>Cette étape n'est décrite que pour être exhaustif, elle peut être
      omise sans danger.</para>
    </note>

    <para>Pour être exhaustif, vous pouvez aussi mettre &agrave; jour les fichiers de
      <filename>/stand</filename>. Ces fichiers sont des liens physiques sur
      le programme <filename>/stand/sysinstall</filename>. L'édition de liens
      de cet exécutable doit être statique, pour qu'on puisse l'utiliser sans
      qu'aucun autre système de fichiers (et en particulier
      <filename>/usr</filename>) ne soit monté.</para>

    <informalexample>
      <screen><prompt>#</prompt> <userinput>cd /usr/src/release/sysinstall</userinput>
<prompt>#</prompt> <userinput>make all install</userinput></screen>
    </informalexample>

    <note>
      <title>Sources antérieurs au 2 Avril 1998</title>

      <para>Si votre code source date d'avant le 2 Avril 1998, ou que
      la version de votre <filename>Makefile</filename> est inférieure &agrave;
      1.68 (pour FreeBSD-current et les systèmes 3.x) ou &agrave; 1.48.2.21
      (pour les systèmes 2.2.x), vous devrez ajouter l'option
       <userinput>NOSHARED=yes</userinput> comme suit:</para>

    <informalexample>
      <screen><prompt>#</prompt> <userinput>make NOSHARED=yes all install</userinput></screen>
    </informalexample>

    </note>
  </sect1>

  <sect1>
    <title>Compilez et installez un nouveau noyau</title>

    <para>Pour tirer pleinement parti de votre nouveau système, vous devez
      recompiler le noyau. C'est pratiquement indispensable, parce que des
      structures de données peuvent avoir changé, et des programmes
      comme <command>ps</command> et <command>top</command> ne marcheront pas
      tant que le système et le noyau ne seront pas au même niveau
      de version.</para>

    <para>Suivez les instructions du "manuel" pour compiler un nouveau
      noyau. Si vous avez déj&agrave; recompilé un  noyau personnalisé
      examinez en détail le fichier de configuration
      <filename>LINT</filename> pour voir s'il y a de nouvelles options dont vous
      pourriez tirer parti.</para>

      <para>Une version précédente de ce document suggérait de redémarrer
      le système avant de recompiler le noyau. C'est un erreur parce
      que :</para>

    <itemizedlist>
      <listitem><para>Des commandes comme <command>ps</command>, <command>ifconfig</command> and
	  <command>sysctl</command> peuvent ne plus fonctionner. Dans ce cas, votre
	  machine ne peut plus se connecter au réseau.</para></listitem>

      <listitem><para>De même, des utilitaires essentiels comme
      <command>mount</command> peuvent aussi être inutilisables,
      auquel cas <filename>/</filename>, <filename>/usr</filename> et ainsi
      de suite, ne peuvent plus être montés.  Il y a peu de chances
      que cela arrive si vous êtes sur la branche -stable, mais c'est plus
      probable sur la branche -current après des modifications
      importantes.</para></listitem>

      <listitem>
	<para>Les LKMs ("Loadable Kernel Modules"&nbsp;-&nbsp;modules du noyau &agrave; chargement
        dynamique) reconstruits en même temps que &ldquo;world&rdquo;
        peuvent "planter" un noyau plus ancien.</para>
      </listitem>
    </itemizedlist>

    <para>Pour toutes ces raisons, il vaut mieux recompiler et installer un
    nouveau noyau avant de redémarrer.</para>

    <para>Vous devez recompiler le noyau après avoir terminé
      <userinput>make world</userinput> (ou <userinput>make
	installworld</userinput>). Si vous ne le faites pas (peut-être
        voulez-vous vous assurer que le noyau compile avant de mettre &agrave;
        jour le système), vous pourriez avoir des problèmes. Cela parce que
        votre commande <command>config</command> n'est pas &agrave; niveau
        avec les sources du noyau.</para>

    <para>Dans ce cas, exécutez:

      <informalexample>
	<screen><prompt>#</prompt> <userinput>/usr/obj/usr/src/usr.sbin/config <replaceable>NOM_DU_NOYAU</replaceable></userinput></screen>
      </informalexample>

      pour recompiler le noyau avec la nouvelle version de
      <command>config</command>. Cela ne marchera peut-être pas &agrave; tous les
      coups. Il est recommandé d'en finir avec
      <userinput>make world</userinput> (ou
      <userinput>make installworld</userinput>) avant de compiler un nouveau
      noyau.</para>
  </sect1>

  <sect1>
    <title>Redémarrez</title>

    <para>Vous en avez fini. Après avoir vérifié que tout semble être en
      place, vous pouvez maintenant redémarrez votre système. Un simple
      <citerefentry>
	<refentrytitle>fastboot</refentrytitle>
	<manvolnum>8</manvolnum>
      </citerefentry> devrait suffire.</para>

    <informalexample>
      <screen><prompt>#</prompt> <userinput>fastboot</userinput></screen>
    </informalexample>
  </sect1>

  <sect1>
    <title>C'est fini</title>

    <para>Vous devriez maintenant avoir mis &agrave; jour avec succès votre système
      FreeBSD.
      Félicitations.</para>

    <para>Vous aurez peut-être de petits problèmes si des détails vous
      ont échappés. Par
      exemple, il m'est arrivé d'effacer le fichier
      <filename>/etc/magic</filename> au moment de la mise &agrave; jour de
      <filename>/etc</filename>, de ce fait, la commande
      <command>file</command> ne marchait plus. Un petit moment de réflexion
      et j'ai trouvé que:

      <informalexample>
	<screen><prompt>#</prompt> <userinput>cd /usr/src/usr.bin/file</userinput>
<prompt>#</prompt> <userinput>make all install</userinput></screen>
      </informalexample>

      suffisait &agrave; régler ce problème.</para>
  </sect1>

  <sect1>
    <title>Questions?</title>

    <sect2>
      <title>Dois-je refaire le monde &agrave; chaque évolution?</title>

      <para>Il n'y a pas de réponse toute faite &agrave; cette question, tout dépend
	de la nature des évolutions. Je viens juste, par exemple, d'exécuter
        CVSup, et les fichiers suivants ont été modifiés depuis ma dernière
	recompilation:</para>

      <informalexample>
<screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>
      </informalexample>

      <para>Il n'y a pas l&agrave; matière &agrave; ce que je recompile mon système. Je
	vais simplement aller dans les bons sous-répertoires et exécuter
       <command>make all
	  install</command>, et c'est &agrave; peu près tout. Mais s'il y a des évolutions
       importantes, par
	exemple sur <filename>src/lib/libc/stdlib</filename> alors ou je
        referais, le monde, ou je recompilerais au moins toutes les parties
        du système qui sont liées statiquement
	(de même que tout ce que je pourrais avoir ajouté qui serait lié
	statiquement).</para>

        <para>En fin de journée, c'est &agrave; vous de voir.
	Vous préférerez peut-être recompiler votre système tous les quinze
        jours, et laisser les modifications s'empiler pendant ces quinze jours.
	Ou bien vous préférez ne recompiler que ce qui a changé et vous faire
	confiance pour repérer ce qui en dépend.</para>

      <para>Et, bien sûr, cela dépend de la fréquence avec laquelle vous voulez
       faire vos mises &agrave; jour, et de si vous êtes sur la branche -stable ou
       sur la branche -current.</para>
    </sect2>

    <sect2>
      <title>Ma compilation échoue avec de nombreuses erreurs "signal 12"
      (ou tout autre numéro de signal)</title>

      <para>Cela indique généralement un problème matériel. (Re)faire le
      monde est un bon moyen de mettre votre matériel sous pression, et
      mettra souvent en évidence des défaillances de la mémoire vive. Cela se
      manifeste normalement de soi-même: le compilation échoue en recevant
      de mystérieux signaux.</para>

      <para>Vous pouvez vous en assurer si vous relancer la compilation
      et qu'elle échoue en un endroit différent.</para>

      <para>Dans ce cas, vous ne pouvez guère faire autre chose que
      d'intervertir les différents composants de votre matériel pour déterminer
      lequel est en cause.</para>
    </sect2>

    <sect2>
      <title>Puis-je détruire <filename>/usr/obj</filename> après avoir
	fini?</title>

      <para>Tout dépend de comment vous voulez refaire le monde par
	la suite.</para>

      <para><filename>/usr/obj</filename> contient tous les fichiers objets
      générés &agrave; la compilation. Normalement, une des premières étapes de
      &ldquo;make world&rdquo; est de supprimer ce répertoire
      et de repartir &agrave; zéro. Dans ce cas, conserver ce répertoire
	<filename>/usr/obj</filename> après en avoir terminé ne sert pas &agrave;
	grand chose, alors que vous économiseriez pas mal d'espace disque
        (au jour d'aujourd'hui
	environ 150Mo).</para>

      <para>Néanmoins, si vous savez ce que vous faites, vous pouvez faire en
      sorte que &ldquo;make
      world&rdquo; saute cette étape. Les reconstructions ultérieures seront
      beaucoup plus rapides, car la plupart des sources n'auront pas besoin
      d'être recompilés.  Le revers de la médaille est que des
      problèmes de dépendance subtils peuvent se manifester, provoquant
      l'échec de votre recompilation de manière étrange. Cela génère
      fréquemment du bruit sur les listes de diffusion de FreeBSD,
      quand quelqu'un se plaint que sa mise &agrave; jour a échoué, sans réaliser
      qu'il a tenté de brûler les étapes.</para>

      <para>Si vous aimez vivre dangereusement, passez le paramètre
	&ldquo;NOCLEAN&rdquo; &agrave; <command>make</command>, comme suit:

	<informalexample>
	  <screen><prompt>#</prompt> <userinput>make -DNOCLEAN world</userinput></screen>
	</informalexample>
      </para>
    </sect2>

    <sect2>
      <title>Une recompilation interrompue peut-elle être reprise?</title>

      <para>Tout dépend de jusqu'où vous êtes allé avant de rencontrer un
        problème.</para>

      <para><emphasis>En général</emphasis> (mais ce n'est pas une règle
	absolue) &ldquo;make world&rdquo; crée de nouveaux exemplaires
	des utilitaires de base (comme <command>gcc</command>, et
	<command>make</command>) et des bibliothèques système. Ces outils et
	bibliothèques sont ensuite installés. Ils sont ensuite utilisés
	pour se reconstruire eux-mêmes, et installés de nouveau. Le système
	entier (y compris maintenant les outils usuels, comme
        <command>ls</command> ou
	<command>grep</command>) est ensuite recompilé avec les nouveaux
        outils et bibliothèques de base.</para>

      <para>Si vous en êtes &agrave; cette dernière étape, et que vous le savez
      (parce que vous avez consulté les résultats que vous avez enregistrés)
      alors vous pouvez (avec une bonne chance de réussite) faire:

	<informalexample>
	  <screen><emphasis>&hellip; régler le problème &hellip;</emphasis>
<prompt>#</prompt> <userinput>cd /usr/src</userinput>
<prompt>#</prompt> <userinput>make -DNOCLEAN all</userinput>
	  </screen>
	</informalexample>

	qui ne détruira pas les résultats du travail qu'a déj&agrave; effectué
        &ldquo;make world&rdquo;.</para>

      <para>Si vous voyez le message :

<screen>
--------------------------------------------------------------
 Building everything..
--------------------------------------------------------------
</screen>

	dans les comptes-rendus de &ldquo;make world&rdquo;, cette façon de
	procéder est probablement sûre.</para>

      <para>Si vous ne voyez pas ce message, ou doutez de vous, alors prudence
	est mère de sûreté, et il vaut mieux tout reprendre depuis le
	début.</para>
    </sect2>

    <sect2>
      <title>Puis-je utiliser une seule machine de <emphasis>référence</emphasis> pour
	mettre &agrave; jour plusieurs machines (NFS)?</title>

      <para>On pose souvent la question sur les listes de diffusion de FreeBSD
        de savoir s'il est possible de tout compiler sur une seule machine
	puis d'installer les résultats de cette compilation sur d'autres
	machines du réseau avec <command>make install</command>.</para>

      <para>C'est quelque chose que je n'ai jamais fait, aussi les indications
      qui suivent m'ont-elles été données par d'autres ou déduites des
      <filename>Makefile</filename>s.</para>

      <para>La marche exacte &agrave; suivre dépend de votre version de FreeBSD.</para>

      <note>
	<para>Vous devrez encore mettre &agrave; jour <filename>/etc</filename> et
	  <filename>/dev</filename> sur les machines cibles après cette
	  étape.</para>
      </note>

      <sect3>
	<title>Version 2.1.7 et antérieures</title>

	<para>Dans un message adressé &agrave; questions@freebsd.org,
        Antonio Bemfica a suggéré la méthode suivante:</para>

<screen>
Date: Thu, 20 Feb 1997 14:05:01 -0400 (AST)
From: Antonio Bemfica &lt;bemfica@militzer.me.tuns.ca&gt;
To: freebsd-questions@freebsd.org
Message-ID: &lt;Pine.BSI.3.94.970220135725.245C-100000@militzer.me.tuns.ca&gt;

Josef Karthauser a demandé:

&gt; Quelqu'un a-t-il la bonne méthode pour mettre &agrave; jour
&gt; les machines d'un réseau?

D'abord <command>make world</command>, etc... sur votre machine de référence
Ensuite, montez <filename>/</filename> and <filename>/usr</filename> sur la machine distante:

machine_de_référence% mount machine_distante:/    /mnt
machine_de_référence% mount machine_distante:/usr /mnt/usr

Ensuite, faites <command>make install</command> avec <filename>/mnt</filename> comme cible:

machine_de_référence% make install DESTDIR=/mnt

Répétez cela pour chaque machine de votre réseau.
Cela marche très bien dans mon cas.

Antonio
</screen>

	<para>Ce mécanisme ne fonctionne (autant que je sache) que si
	  vous pouvez écrire sur <filename>/usr/src</filename> sur le serveur
          NFS, car ce devait être la cible d'&ldquo;install&rdquo; avec la
          version 2.1.7 et les précédentes.</para>
      </sect3>

      <sect3>
	<title>Version 2.2.0 and ultérieures</title>

	<para>Entre les versions 2.1.7 et 2.2.0 la cible
        &ldquo;reinstall&rdquo; a été introduite. Vous pouvez utiliser
        la méthode décrite ci-dessus pour
	  la version 2.1.7, en remplaçant &ldquo;install&rdquo; par
	  &ldquo;reinstall&rdquo;.</para>

	<para>Cela  <emphasis>ne demande plus</emphasis> de droits d'écriture
	  sur le répertoire <filename>/usr/src</filename> du serveur NFS.</para>
	<note>
	  <para>Un bogue est apparu avec cette cible entre les versions
	    1.68 et 1.107 du <filename>Makefile</filename>, qui impliquait
            qu'il <emphasis>fallait</emphasis>
	    avoir les droits d'écriture. Ce bogue a été corrigé avant la
	    diffusion de la version 2.2.0 de FreeBSD, mais peut encore poser
	    problème si vous avez un vieux serveur sous -stable de cette
	    époque.</para>
	</note>
      </sect3>

      <sect3>
	<title>Version 2.2.5 et ultérieure</title>

	<para>Comme décrit plus haut, les cibles &ldquo;buildworld&rdquo; et
	  &ldquo;installworld&rdquo; peuvent être employées pour recompiler
	  sur une machine, puis monter par NFS
	  <filename>/usr/src</filename> et <filename>/usr/obj</filename> sur
	  la machine distante et y installer le nouveau système.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Comment puis-je accélérer <command>make world</command>?</title>

      <itemizedlist>
	<listitem>
	  <para>Passez en mode mono-utilisateur.</para>
	</listitem>

	<listitem>
	  <para>Mettez les répertoires <filename>/usr/src</filename> et
	    <filename>/usr/obj</filename> sur des systèmes de fichiers
	    et des disques différents. Si possible, installez ces disques
	    sur des contrôleurs différents.</para>
	</listitem>

	<listitem>
	  <para>Mieux encore, mettez ces systèmes de fichiers sur
	    plusieurs disques et utilisez &ldquo;ccd&rdquo;
            ("concatenated disk driver" = pilote de disques concaténés).</para>
	</listitem>

	<listitem>
	  <para>Ne compilez pas les bibliothèques profilées
          (mettez &ldquo;NOPROFILE=true&rdquo; dans
	    <filename>/etc/make.conf</filename>). Vous n'en avez certainement
	    pas besoin.</para>
	</listitem>

	<listitem>
	  <para>Dans <filename>/etc/make.conf</filename>, positionnez aussi
	    &ldquo;CFLAGS&rdquo; &agrave; quelque chose comme &ldquo;-O -pipe&rdquo;.
	    L'optimisation &ldquo;-O2&rdquo; est bien plus lente, et la
	    différence d'optimisation entre &ldquo;-O&rdquo; et
	    &ldquo;-O2&rdquo; est en général négligeable. &ldquo;-pipe&rdquo;
	    dit au compilateur d'utiliser des tuyaux (&ldquo;pipes&rdquo;)
            &agrave; la place de fichiers, ce qui économise des accès disque
	    (mais utilise plus de mémoire).</para>
	</listitem>

	<listitem>
	  <para>Donnez l'option <option>-j&lt;n&gt;</option> au compilateur
          (Si vous avez une version suffisamment récente de FreeBSD)
	  pour exécuter plusieurs programmes en parallèle. Cela améliore
          les choses, que vous ayez une machine mono- ou
          multi-processeurs. </para>
	</listitem>

	<listitem><para>Le système de fichiers qui contient
        <filename>/usr/src</filename> peut être monté (ou remonté) avec l'option
	&ldquo;noatime&rdquo;. De cette manière, les dates de dernier accès
	aux fichiers ne sont pas enregistrées sur disque. Vous n'avez de toute
        façon probablement pas besoin de cette information.

	    <note>
	      <para>&ldquo;noatime&rdquo; existe &agrave; partir de la version
               2.2.0.</para>
	    </note>

	    <informalexample>
	      <screen><prompt>#</prompt> <userinput>mount -u -o noatime /usr/src</userinput></screen>
	    </informalexample>

	  <note>
	    <para>Cet exemple suppose que <filename>/usr/src</filename>
             constitue &agrave; lui seul un système de fichiers. Si ce n'est
	      pas le cas (s'il fait partie de
	      <filename>/usr</filename> par exemple) vous devez indiquez
	      le point de montage de ce système de fichiers, et non
	      <filename>/usr/src</filename>.</para>
	  </note></para>
	</listitem>

	<listitem><para>Le système de fichiers où se trouve
            <filename>/usr/obj</filename>
	    peut être monté (ou remonté) avec l'option &ldquo;async&rdquo;.
	    Les écritures sur disque se font alors de façon asynchrone. En
	    d'autres termes, le programme reprend immédiatement la main,
            mais l'écriture se fait quelques secondes après. Les accès
	    disque sont ainsi groupés, et le gain en performances est
            spectaculaire.</para>

	  <note>
	    <para>Rappelez-vous que cette option rend votre système de
	      fichiers plus fragile. Avec cette option, les risques sont accrus
              qu'en cas de coupure d'alimentation, le système de fichiers soit
              irrécupérable quand la machine redémarrera.</para>

	    <para>S'il n'y a que <filename>/usr/obj</filename> sur ce système
	      de fichiers, ce n'est pas un problème. S'il contient des
              informations
	      plus sensibles, assurez-vous que vos sauvegardes soient &agrave; jour
	      avant d'activer cette option.</para>
	  </note>

	  <para><informalexample>
	      <screen><prompt>#</prompt> <userinput>mount -u -o async /usr/obj</userinput></screen>
	    </informalexample>

	    <note>
	      <para>Comme auparavant, si <filename>/usr/obj</filename> ne
                constitue pas un système de fichiers en soit,
		remplacez-le dans l'exemple par le nom du point
		de montage qui convient.</para>
	    </note></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="translations">
    <title>Traductions</title>

    <sect2>
      <title>Document original</title>
      <para>L'original de ce document se trouve sur
      <ulink url="http://www.nothing-going-on.demon.co.uk/FreeBSD/make-world/make-world.html">http://www.nothing-going-on.demon.co.uk/FreeBSD/make-world/make-world.html</ulink>.</para>
    </sect2>
    <sect2>
      <title>Japonais</title>

      <para>MAEKAWA Masahide a traduit ce document en
	Japonais. Sa traduction est disponible &agrave; l'adresse <ulink
	  url="http://www.rr.iij4u.or.jp/~bishop/FreeBSD/mw.html">http://www.rr.iij4u.or.jp/~bishop/FreeBSD/mw.html</ulink>.</para>
    </sect2>
  </sect1>

  <sect1 id="contributors">
    <title>Contributions</title>

    <para>Les personnes suivantes ont contribué d'une façon ou d'une autre &agrave; la
      rédaction de ce document. Soit directement en suggérant des modifications
      ou des améliorations ou en signalant des erreurs, soit par leurs messages
      sur les listes de diffusion de FreeBSD, où j'ai puisé sans scrupule de
      l'information. Mes remerciements &agrave; tous.</para>

    <itemizedlist>
      <listitem>
	<para>Antonio Bemfica, <ulink url="mailto:bemfica@militzer.me.tuns.ca">bemfica@militzer.me.tuns.ca</ulink></para>
      </listitem>

      <listitem>
	<para>Sue Blake, <ulink url="mailto:sue@welearn.com.au">sue@welearn.com.au</ulink></para>
      </listitem>

      <listitem>
	<para>Brian Haskin, <ulink url="mailto:haskin@ptway.com">haskin@ptway.com</ulink></para>
      </listitem>
      <listitem>
	<para>Kees Jan Koster, <ulink url="mailto:kjkoster@kjkoster.org">kjkoster@kjkoster.org</ulink></para>
      </listitem>

      <listitem>
	<para>A Joseph Kosy, <ulink url="mailto:koshy@india.hp.com">koshy@india.hp.com</ulink></para>
      </listitem>

      <listitem>
	<para>Greg Lehey, <ulink url="mailto:grog@lemis.com">grog@lemis.com</ulink></para>
      </listitem>

      <listitem>
	<para>Wes Peters, <ulink
	    url="mailto:softweyr@xmission.com">softweyr@xmission.com</ulink></para>
      </listitem>

      <listitem>
	<para>Joseph Stein, <ulink url="mailto:joes@wstein.com">joes@wstein.com</ulink></para>
      </listitem>

      <listitem>
	<para>Studded, <ulink url="mailto:studded@dal.net">studded@dal.net</ulink></para>
      </listitem>

      <listitem>
	<para>Axel Thimm <ulink url="mailto:Axel.Thimm@physik.fu-berlin.de">Axel.Thimm@physik.fu-berlin.de</ulink></para>
      </listitem>

      <listitem>
	<para>Matthew Thyer <ulink url="mailto:Matthew.Thyer@dsto.defence.gov.au">Matthew.Thyer@dsto.defence.gov.au</ulink></para>
      </listitem>
    </itemizedlist>
  </sect1>
</article>
