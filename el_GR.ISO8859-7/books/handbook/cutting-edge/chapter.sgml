<!--

  Το Εγχειρίδιο του FreeBSD: Η Κόψη του Ξυραφιού

  The FreeBSD Greek Documentation Project

  $FreeBSD$

  %SOURCE%	en_US.ISO8859-1/books/handbook/cutting-edge/chapter.sgml
  %SRCID%	1.231

-->

<chapter id="cutting-edge">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Αναδομήθηκε, αναδιοργανώθηκε, και τμήματα του ανανεώθηκαν
	  από τον </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>

    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Αρχική συνεισφορά από τους </contrib>
      </author>

      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>

      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>

      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>
    <!-- with feedback from various others -->
  </chapterinfo>

  <title>Η Κόψη του Ξυραφιού</title>

  <sect1 id="cutting-edge-synopsis">
    <title>Σύνοψη</title>

    <para>Το &os; βρίσκεται υπό συνεχή εξέλιξη μεταξύ των επίσημων εκδόσεων
      του.  Για όποιον θέλει να βρίσκεται στην κόψη του ξυραφιού, υπάρχουν
      διάφοροι μηχανισμοί που εξασφαλίζουν με εύκολο τρόπο την ανανέωση ενός
      συστήματος με τις τελευταίες εξελίξεις.  Σας προειδοποιούμε&mdash;η
      κόψη του ξυραφιού δεν είναι για τον καθένα!  Το κεφάλαιο αυτό θα σας
      βοηθήσει να αποφασίσετε αν θέλετε να παρακολουθείτε το σύστημα
      ανάπτυξης, ή αν θα προτιμήσετε να παραμείνετε σε μια από τις παγιωμένες
      εκδόσεις.</para>

    <para>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</para>

    <itemizedlist>
      <listitem>
	<para>Τη διαφορά μεταξύ των δύο κλάδων που βρίσκονται σε εξέλιξη: του
	  &os.stable; και του &os.current;.</para>
      </listitem>

      <listitem>
	<para>Πως να διατηρείτε το σύστημα σας ανανεωμένο με τα
	  <application>CVSup</application>,
	  <application>CVS</application>, ή
	  <application>CTM</application>.</para>
      </listitem>

      <listitem>
	<para>Πως να ξαναφτιάξετε και να επανεγκαταστήσετε ολόκληρο
	  το βασικό σύστημα με την <command>make buildworld</command>
	  (κλπ).</para>
      </listitem>
    </itemizedlist>

    <para>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</para>

    <itemizedlist>
      <listitem>
	<para>Να ρυθμίσετε σωστά τη σύνδεση σας στο δίκτυο (<xref
	    linkend="advanced-networking">).</para>
      </listitem>

      <listitem>
	<para>Να γνωρίζετε πως να εγκαταστήσετε πρόσθετο λογισμικό
	  τρίτου κατασκευαστή (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Στο κεφάλαιο αυτό γίνεται συχνά χρήση της εντολής
	<command>cvsup</command> για την ανάκτηση ή ενημέρωση των αρχείων
	πηγαίου κώδικα του &os;.  Για να την χρησιμοποιήσετε, θα πρέπει να
	εγκαταστήσετε ένα πακέτο ή port όπως το
	<filename role="package">net/cvsup-without-gui</filename>.
	Αν χρησιμοποιείτε &os;&nbsp;6.2-RELEASE ή νεώτερο, μπορείτε να
	αντικαταστήσετε αυτή την εντολή με την &man.csup.1; η οποία ανήκει
	πλέον στο βασικό σύστημα.</para>
    </note>
  </sect1>

  <sect1 id="current-stable">
    <title>&os.current; και &os.stable;</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Υπάρχουν δύο κλάδοι ανάπτυξης στο &os;, το &os.current; και το
      &os.stable;.  Στην ενότητα αυτή, θα εξηγήσουμε κάποια πράγματα σχετικά
      με αυτούς τους κλάδους, και θα περιγράψουμε πως μπορείτε να διατηρήσετε
      το σύστημα σας ενημερωμένο σε κάποιον από αυτούς.  Θα μιλήσουμε αρχικά
      για το &os.current; και έπειτα για το &os.stable;.</para>

    <sect2 id="current">
      <title>Παρακολουθώντας το &os.current;</title>

      <para>Καθώς διαβάζετε αυτό το κείμενο, να έχετε υπόψιν σας ότι το
	&os.current; είναι πράγματι η <quote>κόψη του ξυραφιού</quote> στην
	ανάπτυξη του &os;.  Οι χρήστες του &os.current; αναμένεται να έχουν
	αυξημένες τεχνικές γνώσεις, και να είναι ικανοί να επιλύουν δύσκολα
	προβλήματα του συστήματος τους, χωρίς βοήθεια.  Αν είστε καινούριος
	στο &os;, μάλλον θα πρέπει να το ξανασκεφτείτε πριν το
	εγκαταστήσετε.</para>

      <sect3>
	<title>Τι Είναι το &os.current;;</title>
	<indexterm><primary>snapshot</primary></indexterm>

	<para>Το &os.current; αποτελείται από τον πλέον πρόσφατο λειτουργικό
	  πηγαίο κώδικα του &os;.  Περιλαμβάνει αλλαγές που βρίσκονται σε
	  εξέλιξη, πειραματικές αλλαγές, και μηχανισμούς μετάβασης οι οποίοι
	  δεν είναι σίγουρο ότι θα περιλαμβάνονται στην επόμενη επίσημη
	  έκδοση του λογισμικού.  Αν και πολλά μέλη της ομάδας ανάπτυξης του
	  &os; μεταγλωττίζουν καθημερινά τον πηγαίο κώδικα του &os.current;,
	  υπάρχουν χρονικές περίοδοι που η μεταγλώττιση του είναι αδύνατη.
	  Τα προβλήματα αυτά γενικά επιλύονται όσο πιο γρήγορα γίνεται, αλλά
	  το αν το &os.current; θα σας φέρει την καταστροφή ή κάποιο
	  πολυπόθητο χαρακτηριστικό, είναι περισσότερο θέμα της χρονικής
	  στιγμής που θα επιλέξετε να ανακτήσετε τον πηγαίο κώδικα!</para>
      </sect3>

      <sect3>
	<title>Ποιος Χρειάζεται το &os.current;;</title>

	<para>Το &os.current; διατίθεται και ενδιαφέρει κυρίως τις παρακάτω
	  τρεις ομάδες:</para>

	<orderedlist>
	  <listitem>
	    <para>Μέλη της κοινότητας του &os; που δουλεύουν ενεργά σε κάποιο
	      τμήμα του πηγαίου κώδικα, και για τους οποίους η παρακολούθηση
	      του &os.current; είναι απόλυτα απαραίτητη.</para>
	  </listitem>

	  <listitem>
	    <para>Μέλη της κοινότητας του &os; που είναι ενεργοί testers
	      και είναι πρόθυμοι να αναλώσουν το χρόνο τους για να λύσουν
	      προβλήματα, ώστε να εξασφαλίσουν ότι το &os.current;
	      θα παραμείνει όσο το δυνατόν πιο σωστό.  Συνήθως, τα μέλη αυτά
	      κάνουν προτάσεις για τοπικές αλλαγές και για την γενική
	      κατεύθυνση του &os;, και στέλνουν patches για την
	      πραγματοποίηση τους.</para>
	  </listitem>

	  <listitem>
	    <para>Αυτοί που απλώς θέλουν να βλέπουν τις τελευταίες
	      ενημερώσεις, ή να χρησιμοποιούν τον τελευταίο πηγαίο κώδικα ως
	      αναφορά (π.χ. για <emphasis>μελέτη</emphasis> και όχι για
	      εκτέλεση).  Μέλη αυτής της ομάδας μπορεί επίσης περιστασιακά να
	      συνεισφέρουν σχόλια ή κώδικα.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Τι <emphasis>Δεν</emphasis> Είναι το &os.current;;</title>

	<orderedlist>
	  <listitem>
	    <para>Δεν είναι ένας γρήγορος τρόπος να πάρετε κώδικα ο
	      οποίος δεν έχει κυκλοφορήσει ακόμα σε κάποια έκδοση, με την
	      ελπίδα ότι περιέχει κάποια νέα εκπληκτική δυνατότητα και
	      θέλετε να είστε ο πρώτος που τη χρησιμοποιεί.  Αν είστε
	      πράγματι ο πρώτος που την χρησιμοποιεί, θα είστε επίσης και ο
	      πρώτος που θα συναντήσετε τα νέα προβλήματα και bugs.</para>
	  </listitem>

	  <listitem>
	    <para>Δεν είναι ένας γρήγορος τρόπος για να ανακτήσετε
	      διορθώσεις προβλημάτων.  Κάθε νέα έκδοση του &os.current;
	      μπορεί να εισάγει τόσα νέα bugs όσα και αυτά που
	      διορθώνει.</para>
	  </listitem>

	  <listitem>
	    <para>Το &os.current; δεν αποτελεί
	      <quote>επίσημα υποστηριζόμενο</quote> κώδικα.  Αν και
	      καταβάλλουμε κάθε δυνατή προσπάθεια να βοηθήσουμε όσους
	      ανήκουν <quote>πραγματικά</quote> σε κάποια από τις τρεις
	      ομάδες που αναφέραμε, ωστόσο <emphasis>δεν έχουμε το
	      χρόνο</emphasis> να παρέχουμε τεχνική υποστήριξη.  Αυτό δεν
	      συμβαίνει επειδή είμαστε κακοήθεις και δύσκολοι και δεν θέλουμε
	      να βοηθάμε τους ανθρώπους (δεν θα είχαμε καν δημιουργήσει το
	      &os; αν σκεφτόμασταν έτσι).  Πολύ απλά, δεν μπορούμε να
	      απαντάμε εκατοντάδες μηνύματα την ημέρα και
	      <emphasis>ταυτόχρονα</emphasis> να δουλεύουμε στο &os;! Αν
	      δώσετε σε οποιοδήποτε μέλος της ομάδας ανάπτυξης την επιλογή
	      να απαντάει σε πολλές ερωτήσεις σχετικά με πειραματικό κώδικα
	      ή να δουλεύει για τη βελτίωση του &os;, θα επιλέξει σίγουρα το
	      δεύτερο.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Χρησιμοποιώντας το &os.current;</title>

	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>using</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Γραφτείτε στις λίστες &a.current.name; και
	      &a.svn-src-head.name;.  Δεν είναι απλώς καλή ιδέα, είναι
	      <emphasis>βασικό</emphasis> να το κάνετε.  Αν δεν είστε
	      γραμμένος στη λίστα <emphasis>&a.current.name;</emphasis>, δεν
	      θα βλέπετε τα σχόλια σχετικά με την τρέχουσα κατάσταση του
	      συστήματος από όσους το χρησιμοποιούν, και έτσι πιθανώς θα
	      καταλήξετε να αντιμετωπίζετε πολλά προβλήματα που άλλοι έχουν
	      ήδη ανακαλύψει και λύσει.  Ακόμα πιο σημαντικό είναι ότι θα
	      χάνετε σημαντικές ανακοινώσεις, οι οποίες μπορεί να είναι
	      κρίσιμες για την διατήρηση του συστήματος σας σε υγιή
	      κατάσταση.</para>

	    <para>Η λίστα &a.svn-src-head.name; θα σας επιτρέψει να βλέπετε
	      τις καταχωρήσεις στο commit log για κάθε αλλαγή που γίνεται,
	      καθώς και πληροφορίες για πιθανές παρενέργειες που μπορεί να
	      έχει.</para>

	    <para>Για να γραφτείτε σε αυτές, ή σε οποιεσδήποτε από τις
	      υπάρχουσες λίστες, επισκεφθείτε την τοποθεσία
	      &a.mailman.lists.link; και επιλέξτε τη λίστα στην οποία θέλετε
	      να γίνετε συνδρομητής.  Οδηγίες για την υπόλοιπη διαδικασία
	      θα βρείτε επιτόπου.  Αν σας ενδιαφέρει να παρακολουθείτε τις
	      αλλαγές σε όλο το δέντρο πηγαίου κώδικα, σας συνιστούμε να
	      εγγραφείτε στη λίστα &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>Ανακτήστε τον πηγαίο κώδικα από ένα
	      <link linkend="mirrors">mirror site</link> του &os;.  Αυτό
	      μπορεί να γίνει με δύο τρόπους:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
		<primary>-CURRENT</primary>
		<secondary>Syncing with <application>CVSup</application></secondary>
	      </indexterm>

	      <listitem>
		<para>Χρησιμοποιήστε το πρόγραμμα <link
		    linkend="cvsup">cvsup</link> σε συνδυασμό με το
		  <filename>supfile</filename> με την ονομασία
		  <filename>standard-supfile</filename> το οποίο θα βρείτε
		  στον κατάλογο
		  <filename>/usr/share/examples/cvsup</filename>.
		  Αυτή είναι και η πλέον συνιστώμενη μέθοδος, καθώς σας
		  επιτρέπει να ανακτήσετε όλη τη συλλογή με μια κίνηση, και
		  στις επόμενες ανανεώσεις θα παίρνετε μόνο τις αλλαγές.
		  Πολλοί χρήστες εκτελούν το <command>cvsup</command> μέσω
		  του <command>cron</command> ώστε να κρατάνε τον πηγαίο
		  κώδικα του συστήματος τους πάντα ανανεωμένο αυτόματα.  Θα
		  πρέπει να προσαρμόσετε το υπόδειγμα του
		  <filename>supfile</filename> που δίνουμε παραπάνω, και να
		  ρυθμίσετε το <link linkend="cvsup">cvsup</link> για το
		  περιβάλλον σας.</para>

		<note>
		  <para>Το υπόδειγμα του αρχείου
		    <filename>standard-supfile</filename> προορίζεται για
		    χρήση με κάποιο συγκεκριμένο κλάδο ασφάλειας (security
		    branch) του &os;, και όχι με το &os.current;.  Θα πρέπει
		    να επεξεργαστείτε το αρχείο και να αντικαταστήσετε την
		    παρακάτω γραμμή:</para>

		  <programlisting>*default release=cvs tag=RELENG_<replaceable>X</replaceable>_<replaceable>Y</replaceable></programlisting>

		  <para>με την ακόλουθη:</para>

		  <programlisting>*default release=cvs tag=.</programlisting>

		  <para>Για περισσότερες πληροφορίες σχετικά με τα tags που
		    μπορείτε να χρησιμοποιήσετε, παρακαλούμε διαβάστε στο
		    Εγχειρίδιο την ενότητα <link
		      linkend="cvs-tags">Ετικέτες (Tags) για το CVS</link>.</para>
		</note>
	      </listitem>

	      <indexterm>
		<primary>-CURRENT</primary>
		<secondary>Syncing with CTM</secondary>
	      </indexterm>
	      <listitem>
		<para>Χρησιμοποιήστε την υπηρεσία <application><link
		  linkend="ctm">CTM</link></application>.  Αν έχετε πολύ κακή
		  συνδεσιμότητα (υψηλό κόστος σύνδεσης ή πρόσβαση μόνο μέσω
		  email) το <application>CTM</application> αποτελεί για σας
		  μια εναλλακτική λύση.  Μπορεί ωστόσο να σας δημιουργήσει
		  διάφορα προβλήματα και να καταλήξετε με χαλασμένα αρχεία.
		  Για το λόγο αυτό, το <application>CTM</application>
		  χρησιμοποιείται σπάνια, κάτι το οποίο αυξάνει ακόμα
		  περισσότερο την πιθανότητα να μη δουλεύει σωστά για μεγάλα
		  χρονικά διαστήματα.  Σας συνιστούμε να χρησιμοποιήσετε το
		  <application><link linkend="cvsup">CVSup</link></application>
		  αν διαθέτετε modem 9600&nbsp;bps ή ταχύτερο.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Αν σκοπεύετε να ανακτήσετε τον πηγαίο κώδικα για κανονική
	      χρήση (εκτέλεση) και όχι απλώς για να τον δείτε, τότε
	      ανακτήστε <emphasis>ολόκληρο</emphasis> το &os.current; και όχι
	      κάποια επιλεγμένα τμήματα.  Σε διαφορετική περίπτωση, είναι
	      αρκετά πιθανό να συναντήσετε προβλήματα, καθώς πολλά κομμάτια
	      του κώδικα εξαρτώνται από ανανεώσεις σε άλλα, και δεν μπορούν
	      να μεταγλωττιστούν αυτόνομα.</para>

	  <indexterm>
	    <primary>-CURRENT</primary>
	    <secondary>compiling</secondary>
	  </indexterm>
	    <para>Πριν μεταγλωττίσετε το &os.current;, διαβάστε προσεκτικά το
	      <filename>Makefile</filename> στον κατάλογο
	      <filename>/usr/src</filename>.  Θα πρέπει να <link
		linkend="makeworld">μεταγλωττίσετε τον πυρήνα και όλο το
		βασικό σύστημα (world)</link> την πρώτη φορά, ως μέρος της
	      διαδικασίας αναβάθμισης.  Διαβάζοντας την &a.current;
	      και το <filename>/usr/src/UPDATING</filename> θα είστε
	      ενημερωμένοι για νέες διαδικασίες όσο αφορά την εκκίνηση στο νέο
	      σας σύστημα.  Οι διαδικασίες αυτές είναι συχνά απαραίτητες όσο
	      πλησιάζουμε σε μια νέα επίσημη έκδοση.</para>
	  </listitem>

	  <listitem>
	    <para>Γίνετε ενεργό μέλος! Αν χρησιμοποιείτε το &os.current;,
	      θέλουμε να ξέρουμε τη γνώμη σας για αυτό, ειδικά αν έχετε
	      προτάσεις για βελτιώσεις ή διορθώσεις λαθών.  Προτάσεις που
	      συνοδεύονται και από κώδικα γίνονται δεκτές με
	      ενθουσιασμό!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>Χρησιμοποιώντας το &os;-STABLE</title>

      <sect3>
	<title>Τι Είναι το &os.stable;;</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>Το &os.stable; είναι ένας κλάδος ανάπτυξης από τον οποίο
	  προκύπτουν οι <quote>μεγάλες</quote> (major) εκδόσεις.  Οι αλλαγές
	  εισάγονται σε αυτό τον κλάδο με διαφορετικό ρυθμό, και με τη γενική
	  παραδοχή ότι έχουν πρώτα περάσει από το &os.current; για δοκιμή.
	  Ωστόσο, <emphasis>δεν παύει</emphasis> να είναι ένας κλάδος
	  ανάπτυξης, και αυτό σημαίνει ότι ο κώδικας του &os.stable; μπορεί
	  μια δεδομένη χρονική στιγμή να είναι ακατάλληλος για συγκεκριμένες
	  εφαρμογές.  Πρόκειται για μια ακόμα γραμμή ανάπτυξης για τους
	  προγραμματιστές, και δεν είναι απαραίτητα κατάλληλη για τους
	  τελικούς χρήστες.</para>
      </sect3>

      <sect3>
	<title>Ποιος Χρειάζεται το &os.stable;;</title>

	<para>Αν σας ενδιαφέρει να παρακολουθείτε ή να συμβάλλετε στην
	  ανάπτυξη του &os;, και ειδικά όσο αφορά την επόμενη επίσημη
	  έκδοση του από τον ίδιο κλάδο (point release), είναι καλή ιδέα να
	  παρακολουθείτε το &os.stable;.</para>

	<para>Αν και είναι αλήθεια ότι οι διορθώσεις ασφάλειας γίνονται και
	  στον κλάδο &os.stable;, ωστόσο <emphasis>δεν χρειάζεται</emphasis>
	  να παρακολουθείτε το &os.stable; μόνο για αυτό το λόγο.  Κάθε
	  αναφορά προβλήματος ασφάλειας του &os; εξηγεί πως να διορθώσετε το
	  πρόβλημα για κάθε επίσημη έκδοση η οποία επηρεάζεται από αυτό
	  <footnote><para>Αυτό βέβαια δεν είναι απόλυτα αληθινό.  Δεν μπορούμε
	    να συνεχίσουμε να υποστηρίζουμε τις παλιές εκδόσεις του &os; για
	    πάντα, αν και τις υποστηρίζουμε για πολλά χρόνια.  Για πλήρη
	    περιγραφή της τρέχουσας πολιτικής όσο αφορά την ασφάλεια των
	    παλιών εκδόσεων του &os;, δείτε <ulink
	      url="&url.base;/security/">http://www.FreeBSD.org/security/</ulink>.</para>
	  </footnote>,
	  και η παρακολούθηση ενός κλάδου ανάπτυξης μόνο για λόγους
	  ασφαλείας, πιθανόν να φέρει επίσης και άλλες ανεπιθύμητες αλλαγές
	  μαζί της.</para>

	<para>Αν και καταβάλλουμε κάθε δυνατή προσπάθεια ώστε να εξασφαλίσουμε
	  ότι ο κλάδος &os.stable; μπορεί να μεταγλωττιστεί και να εκτελεστεί
	  σε κάθε δεδομένη χρονική στιγμή, δεν μπορούμε ωστόσο να το
	  εγγυηθούμε.  Επιπρόσθετα, αν και ο κώδικας αναπτύσσεται στο
	  &os.current; πριν περάσει στο &os.stable;, ο κόσμος που εκτελεί το
	  &os.stable; είναι περισσότερος, και έτσι είναι αναπόφευκτο να
	  ανακαλύπτονται πιο πολλά σφάλματα και ακραίες περιπτώσεις στο
	  &os.stable; τα οποία δεν έχουν γίνει εμφανή στο &os.current;.</para>

	<para>Για τους λόγους αυτούς, <emphasis>δεν</emphasis> συνιστούμε να
	  παρακολουθείτε τυφλά το &os.stable;, και ειδικότερα είναι σημαντικό
	  να μην αναβαθμίζετε σε αυτό εξυπηρετητές σε περιβάλλοντα παραγωγής,
	  χωρίς να έχετε πρώτα ελέγξει αναλυτικά τον κώδικα στο δικό σας
	  περιβάλλον ανάπτυξης.</para>

	<para>Αν δεν διαθέτετε τους πόρους για να το κάνετε αυτό, σας
	  συνιστούμε να χρησιμοποιείτε την τελευταία επίσημη έκδοση του &os;,
	  και να αναβαθμίζεστε από τη μια έκδοση στην επόμενη μέσω του
	  μηχανισμού δυαδικών ενημερώσεων.</para>
      </sect3>

      <sect3>
	<title>Χρησιμοποιώντας το &os.stable;</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>using</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Γραφτείτε συνδρομητής στη λίστα &a.stable.name;.  Θα είστε
	      έτσι ενημερωμένοι για εξαρτήσεις μεταγλώττισης που ίσως
	      εμφανιστούν στο &os.stable;, ή για άλλα προβλήματα που χρήζουν
	      ειδικής προσοχής.  Στη λίστα αυτή θα βρίσκετε επίσης
	      ανακοινώσεις από μέλη της ομάδας ανάπτυξης, όταν πρόκειται να
	      συμπεριληφθεί κάποια αμφιλεγόμενη ανανέωση ή διόρθωση, δίνοντας
	      έτσι στους χρήστες την ευκαιρία να εκφέρουν γνώμη σχετικά με τα
	      προβλήματα που θα προκαλέσει η προτεινόμενη αλλαγή.</para>

	    <para>Θα πρέπει να εγγραφείτε στην κατάλληλη λίστα
	      <application>SVN</application> ανάλογα με τον κλάδο που
	      παρακολουθείτε.  Για παράδειγμα, αν παρακολουθείτε τον κλάδο
	      7-STABLE, η κατάλληλη λίστα είναι η &a.svn-src-stable-7.name;.
	      Αυτό θα σας επιτρέψει να βλέπετε τις
	      καταχωρήσεις στο commit log για κάθε αλλαγή που γίνεται, καθώς
	      και πληροφορίες για πιθανές παρενέργειες που μπορεί να
	      έχει.</para>

	    <para>Για να γραφτείτε σε αυτές, ή σε οποιεσδήποτε από τις
	      υπάρχουσες λίστες, επισκεφθείτε την τοποθεσία
	      &a.mailman.lists.link; και επιλέξτε τη λίστα στην οποία θέλετε
	      να γίνετε συνδρομητής.  Οδηγίες για την υπόλοιπη διαδικασία
	      θα βρείτε επιτόπου.  Αν σας ενδιαφέρει να παρακολουθείτε τις
	      αλλαγές σε όλο το δέντρο πηγαίου κώδικα, σας συνιστούμε να
	      εγγραφείτε στη λίστα &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>Αν πρόκειται να εγκαταστήσετε ένα νέο σύστημα με σκοπό να
	      εκτελείτε τα μηνιαία snapshot του &os.stable;, παρακαλούμε να
	      ελέγξετε την τοποθεσία <ulink
		url="&url.base;/snapshots/">Snapshots</ulink> για
	      περισσότερες πληροφορίες.  Εναλλακτικά, είναι δυνατόν να
	      εγκαταστήσετε το πιο πρόσφατο &os.stable; από κάποιο
	      <link linkend="mirrors">mirror site</link> ακολουθώντας τις
	      παρακάτω οδηγίες ώστε να αναβαθμίσετε το σύστημα σας στην πλέον
	      πρόσφατη έκδοση πηγαίου κώδικα του &os.stable;.</para>

	    <para>Αν διαθέτετε ήδη κάποια προηγούμενη έκδοση του &os; και
	      επιθυμείτε να αναβαθμιστείτε μέσω του πηγαίου κώδικα, μπορείτε
	      εύκολα να χρησιμοποιήσετε κάποιο <link
		linkend="mirrors">mirror site</link> του &os;.  Υπάρχουν δύο
	      τρόποι για να γίνει αυτό:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
		<primary>-STABLE</primary>
		<secondary>syncing with <application>CVSup</application></secondary>
	      </indexterm>
	      <listitem>

		<para>Χρησιμοποιήστε το πρόγραμμα <link
		    linkend="cvsup">cvsup</link> σε συνδυασμό με το
		  <filename>supfile</filename> με την ονομασία
		  <filename>stable-supfile</filename> το οποίο θα βρείτε
		  στον κατάλογο
		  <filename>/usr/share/examples/cvsup</filename>.
		  Αυτή είναι και η πλέον συνιστώμενη μέθοδος, καθώς σας
		  επιτρέπει να ανακτήσετε όλη τη συλλογή με μια κίνηση, και
		  στις επόμενες ανανεώσεις θα παίρνετε μόνο τις αλλαγές.
		  Πολλοί χρήστες εκτελούν το <command>cvsup</command> μέσω
		  του <command>cron</command> ώστε να κρατάνε τον πηγαίο
		  κώδικα του συστήματος τους πάντα ανανεωμένο αυτόματα.  Θα
		  πρέπει να προσαρμόσετε το υπόδειγμα του
		  <filename>supfile</filename> που δίνουμε παραπάνω, και να
		  ρυθμίσετε το <link linkend="cvsup">cvsup</link> για το
		  περιβάλλον σας.</para>
	      </listitem>

	      <indexterm>
		<primary>-STABLE</primary>
		<secondary>syncing with CTM</secondary>
	      </indexterm>
	      <listitem>
		<para>Χρησιμοποιήστε την υπηρεσία <application><link
		  linkend="ctm">CTM</link></application>.  Αν δεν έχετε
		  γρήγορη και φτηνή σύνδεση με το Internet, αυτή είναι η
		  συνιστώμενη μέθοδος.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Ουσιαστικά, αν χρειάζεστε γρήγορη και κατά απαίτηση
	      πρόσβαση στον πηγαίο κώδικα, και το εύρος ζώνης της σύνδεσης
	      δεν αποτελεί πρόβλημα, χρησιμοποιήστε το
	      <command>cvsup</command> ή το <command>ftp</command>.
	      Διαφορετικά, χρησιμοποιήστε το
	      <application>CTM</application>.</para>
	  </listitem>

	  <indexterm>
	    <primary>-STABLE</primary>
	    <secondary>compiling</secondary>
	  </indexterm>
	  <listitem>
	    <para>Πριν μεταγλωττίσετε το &os.stable;, διαβάστε προσεκτικά το
	      <filename>Makefile</filename> στον κατάλογο
	      <filename>/usr/src</filename>.  Θα πρέπει να <link
		linkend="makeworld">μεταγλωττίσετε τον πυρήνα και όλο το
		βασικό σύστημα (world)</link> την πρώτη φορά, ως μέρος της
	      διαδικασίας αναβάθμισης.  Διαβάζοντας την &a.stable;
	      και το <filename>/usr/src/UPDATING</filename> θα είστε
	      ενημερωμένοι για νέες διαδικασίες όσο αφορά την εκκίνηση στο νέο
	      σας σύστημα.  Οι διαδικασίες αυτές είναι συχνά απαραίτητες όσο
	      πλησιάζουμε σε μια νέα επίσημη έκδοση.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Συγχρονίζοντας τον Πηγαίο σας Κώδικα</title>

    <para>Υπάρχουν διάφοροι τρόποι να χρησιμοποιήσετε μια σύνδεση Internet
      (ή email) για να ενημερώνετε οποιοδήποτε τμήμα πηγαίου
      κώδικα του &os;&nbsp;Project σας ενδιαφέρει, ή και όλα αν το
      επιθυμείτε.  Οι βασικές υπηρεσίες που προσφέρουμε είναι το
      <link linkend="anoncvs">Ανώνυμο CVS</link>, το
      <link linkend="cvsup">CVSup</link>, και το <link
	linkend="ctm">CTM</link>.</para>

    <warning>
      <para>Αν και είναι δυνατόν να ενημερώσετε μόνο κάποια τμήματα του
	δέντρου πηγαίου κώδικα, η μόνη διαδικασία ενημέρωσης που
	υποστηρίζεται αφορά την ενημέρωση ολόκληρου του δέντρου.  Μετά την
	ενημέρωση, θα πρέπει να μεταγλωττίσετε ξανά τόσο το userland (δηλ. τα
	προγράμματα που εκτελούνται στην περιοχή χρήστη, όπως αυτά που
	βρίσκονται στους καταλόγους <filename>/bin</filename> και
	<filename>/sbin</filename>) όσο και τον πηγαίο κώδικα του πυρήνα.
	Αν ενημερώσετε μόνο ένα τμήμα του πηγαίου κώδικα, μόνο τον πυρήνα ή
	μόνο το userland, θα αντιμετωπίσετε προβλήματα.  Τα προβλήματα αυτά
	μπορεί να κυμαίνονται από σφάλματα μεταγλώττισης μέχρι kernel panic
	και καταστροφή δεδομένων.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonymous</secondary>
    </indexterm>

    <para>Το <application>Ανώνυμο CVS</application> και το
      <application>CVSup</application> χρησιμοποιούν τη μέθοδο
      <emphasis>pull</emphasis> για την ενημέρωση του πηγαίου κώδικα.  Στην
      περίπτωση του <application>CVSup</application>, ο χρήστης (η κάποιο
      script που εκτελείται μέσω <command>cron</command>) εκτελεί το πρόγραμμα
      <command>cvsup</command> το οποίο αλληλεπιδρά με ένα αντίστοιχο
      εξυπηρετητή <command>cvsupd</command> ώστε να ενημερώσει τα σχετικά
      αρχεία.  Οι ενημερώσεις που λαμβάνετε είναι πάντοτε οι τελευταίες
      διαθέσιμες, και θα τις λάβετε μόνο όταν τις ζητήσετε.  Μπορείτε εύκολα
      να περιορίσετε τις ενημερώσεις σε συγκεκριμένα αρχεία ή καταλόγους τα
      οποία σας ενδιαφέρουν.  Οι ενημερώσεις δημιουργούνται δυναμικά από τον
      εξυπηρετητή, ανάλογα με το τι έχετε εγκατεστημένο και τι επιθυμείτε να
      λάβετε.  Το <application>Ανώνυμο CVS</application> είναι κάπως πιο
      απλοϊκό από το <application>CVSup</application>, δεδομένου ότι είναι
      απλώς μια επέκταση του <application>CVS</application> που επιτρέπει την
      ανάκτηση αλλαγών απευθείας από κάποιο απομακρυσμένο CVS repository.  Το
      <application>CVSup</application> είναι αρκετά πιο αποτελεσματικό σε
      αυτόν το τομέα, αλλά το <application>Ανώνυμο CVS</application> είναι
      απλούστερο στη χρήση.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para>Από την άλλη μεριά, το <application>CTM</application> δεν συγκρίνει
      άμεσα τον πηγαίο κώδικα που έχετε με αυτόν που υπάρχει στον κεντρικό
      εξυπηρετητή ώστε να ανακτήσει μόνο τις αλλαγές.  Αντίθετα, στο κεντρικό
      μηχάνημα CTM, εκτελείται αρκετές φορές την ημέρα ένα script.  Το script
      αυτό αναγνωρίζει τις αλλαγές στα αρχεία σε σχέση με την προηγούμενη
      εκτέλεση του, και έπειτα πακετάρει και συμπιέζει τις αλλαγές με τρόπο
      κατάλληλο για αποστολή μέσω email (μόνο εκτυπώσιμοι ASCII χαρακτήρες).
      Σε κάθε τέτοιο πακέτο αλλαγών αντιστοιχίζεται ένας μοναδιαίος αριθμός
      ακολουθίας (sequence number) που το αναγνωρίζει.  Μετά τη λήψη τους,
      μπορείτε να δώσετε αυτά τα αρχεία διαφορών του
      <application>CTM</application> (<quote>CTM deltas</quote>) στο βοηθητικό
      πρόγραμμα &man.ctm.rmail.1; το οποίο αυτόματα θα τα αποκωδικοποιήσει,
      θα τα επαληθεύσει, και θα εφαρμόσει τις αλλαγές στο αντίγραφο πηγαίου
      κώδικα του χρήστη.  Η διαδικασία αυτή είναι πολύ πιο αποδοτική από το
      <application>CVSup</application>, και επιβαρύνει λιγότερο τους
      εξυπηρετητές μας, καθώς είναι μια διαδικασία τύπου
      <emphasis>push</emphasis> αντί για <emphasis>pull</emphasis>.</para>

    <para>Υπάρχουν φυσικά κάποια σημεία που υστερεί.  Αν από λάθος διαγράψετε
      κάποια τμήματα του πηγαίου σας κώδικα, το
      <application>CVSup</application> θα ανιχνεύσει και θα διορθώσει αυτόματα
      τη βλάβη για σας.  Το <application>CTM</application> δεν θα το κάνει
      αυτό, και αν σβήσετε κάποιο τμήμα του δέντρου σας (και δεν έχετε
      αντίγραφο ασφαλείας) θα πρέπει να ξεκινήσετε από την αρχή (από το πιο
      πρόσφατο CVS <quote>base delta</quote>) και να το ξανακτίσετε από την
      αρχή με το <application>CTM</application>.  Με το
      <application>Ανώνυμο CVS</application>, μπορείτε απλώς να διαγράψετε
      τα προβληματικά αρχεία και να συγχρονίσετε ξανά τον πηγαίο σας
      κώδικα.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>Μεταγλωττίζοντας το Βασικό Σύστημα (<quote>world</quote>)</title>

    <indexterm>
      <primary>Rebuilding <quote>world</quote></primary>
    </indexterm>
    <para>Έχοντας συγχρονίσει το τοπικό σας δέντρο πηγαίου κώδικα σε κάποια
      συγκεκριμένη έκδοση του &os; (&os.stable;, &os.current;, κ.ο.κ.),
      μπορείτε έπειτα να το χρησιμοποιήσετε για να μεταγλωττίσετε το
      σύστημα σας από την αρχή.</para>

    <warning>
      <title>Δημιουργήστε Ένα Αντίγραφο Ασφαλείας</title>

      <para>Δεν μπορούμε παρά να τονίσουμε πόσο σημαντικό είναι να
	δημιουργήσετε ένα αντίγραφο ασφαλείας του συστήματος σας
	<emphasis>πριν</emphasis> ξεκινήσετε αυτή τη διαδικασία.  Αν και η
	μεταγλώττιση του βασικού συστήματος είναι (όσο τουλάχιστον ακολουθείτε
	αυτές τις οδηγίες) μια σχετικά απλή διαδικασία, αναμφίβολα θα υπάρξουν
	και περιπτώσεις που λάθη δικά σας, ή άλλων (στο δέντρο πηγαίου
	κώδικα), θα σας οδηγήσουν σε ένα σύστημα που δεν θα μπορεί να
	εκκινήσει.</para>

      <para>Βεβαιωθείτε ότι έχετε ενημερωμένο αντίγραφο ασφαλείας.  Καλό θα
	είναι να έχετε επίσης πρόχειρη μια δισκέτα fixit ή ένα CD εκκίνησης.
	Ίσως να μην χρειαστεί ποτέ να τα χρησιμοποιήσετε, αλλά καλύτερα να
	είστε ασφαλής παρά να το μετανοιώνετε αργότερα!</para>
    </warning>

    <warning>
      <title>Γίνετε Συνδρομητής στη Σωστή Λίστα Ηλ. Ταχυδρομείου</title>

      <indexterm><primary>mailing list</primary></indexterm>
      <para>Από τη φύση τους, οι κλάδοι &os.stable; και &os.current;
	βρίσκονται σε συνεχή <emphasis>ανάπτυξη</emphasis>.  Όσοι συνεισφέρουν
	στο &os; είναι απλώς άνθρωποι, και περιστασιακά λάθη απλώς
	συμβαίνουν.</para>

      <para>Ορισμένες φορές τα λάθη αυτά είναι μάλλον ακίνδυνα, και το μόνο
	που κάνουν είναι να εμφανίζουν μερικές διαγνωστικές προειδοποιήσεις
	στο σύστημα σας.  Ή μπορεί η αλλαγή να είναι καταστροφική, και να
	οδηγήσει το σύστημα σας σε αδυναμία εκκίνησης ή ακόμα και να
	καταστρέψει τα συστήματα αρχείων σας (ή και ακόμα χειρότερες
	συνέπειες).</para>

      <para>Αν συμβούν τέτοια προβλήματα, σύντομα θα εμφανιστεί ένα μήνυμα
	τύπου <quote>heads up</quote> στις σχετικές λίστες ταχυδρομείου, το
	οποίο θα εξηγεί το πρόβλημα και ποια συστήματα επηρεάζει.  Όταν το
	πρόβλημα λυθεί, θα γίνει μια αντίστοιχη <quote>all clear</quote>
	ανακοίνωση.</para>

      <para>Αν προσπαθείτε να ακολουθήσετε το &os.stable; ή το &os.current;,
	και δεν διαβάζετε τις αντίστοιχες λίστες &a.stable.name; και
	&a.current.name;, ψάχνετε για μπελάδες.</para>
    </warning>

    <warning>
      <title>Μην Χρησιμοποιήσετε την εντολή
	<command>make world</command></title>

      <para>Μεγάλο μέρος της παλαιότερης τεκμηρίωσης, συνιστά τη χρήση της
	εντολής <command>make world</command>.  Αν την χρησιμοποιήσετε, θα
	παραλειφθούν ορισμένα σημαντικά βήματα της διαδικασίας.
	Χρησιμοποιήστε τη μόνο αν είστε απόλυτα σίγουροι για αυτό που κάνετε.
	Για τις περισσότερες περιπτώσεις, η εντολή
	<command>make world</command> είναι λανθασμένη, και αντί για αυτή
	θα πρέπει να ακολουθήσετε τη διαδικασία που περιγράφουμε
	παρακάτω.</para>
    </warning>

    <sect2>
      <title>Ο Κανονικός Τρόπος να Ενημερώσετε το Σύστημα σας</title>

      <para>Πριν ενημερώσετε το σύστημα σας, θα πρέπει να ελέγξετε το
	<filename>/usr/src/UPDATING</filename> για τυχόν βήματα που θα πρέπει
	να εκτελέσετε πριν την εκκίνηση της μεταγλώττισης.  Τα βήματα αυτά
	εξαρτώνται από την έκδοση του πηγαίου κώδικα που πρόκειται να
	χρησιμοποιήσετε.  Έπειτα, ακολουθήστε την παρακάτω διαδικασία:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para>Υπάρχουν κάποιες μάλλον σπάνιες περιπτώσεις, που απαιτείται
	  μια επιπλέον εκτέλεση του <command>mergemaster -p</command> πριν
	  το βήμα <maketarget>buildworld</maketarget>.  Οι περιπτώσεις αυτές
	  περιγράφονται στο <filename>UPDATING</filename>.  Σε γενικές
	  γραμμές πάντως, μπορείτε με ασφάλεια να παραλείψετε αυτό το βήμα,
	  αν δεν αναβαθμίζετε το σύστημα σας μεταξύ πολλαπλών εκδόσεων του
	  &os;.</para>
      </note>

      <para>Μετά την επιτυχή ολοκλήρωση του
	<maketarget>installkernel</maketarget>, θα πρέπει να επανεκκινήσετε
	σε κατάσταση ενός χρήστη (π.χ. χρησιμοποιώντας την εντολή
	<command>boot -s</command> στην προτροπή του φορτωτή εκκίνησης).
	Έπειτα εκτελέστε:</para>

      <screen>&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Διαβάστε τις Επιπλέον Εξηγήσεις</title>

	<para>Η διαδικασία που περιγράψαμε παραπάνω είναι μια απλή περίληψη
	  για να σας βοηθήσει να ξεκινήσετε.  Θα πρέπει ωστόσο να διαβάσετε
	  τις παρακάτω ενότητες για να κατανοήσετε πλήρως κάθε βήμα, ειδικά
	  αν θέλετε να χρησιμοποιήσετε δικό σας προσαρμοσμένο πυρήνα.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Διαβάστε το <filename>/usr/src/UPDATING</filename></title>

      <para>Πριν κάνετε οτιδήποτε άλλο, διαβάστε το
	<filename>/usr/src/UPDATING</filename> (ή το αντίστοιχο αρχείο, αν
	έχετε αποθηκεύσει τον πηγαίο κώδικα σε άλλο κατάλογο).  Το αρχείο
	αυτό περιέχει σημαντικές πληροφορίες σχετικά με προβλήματα που μπορεί
	να συναντήσετε ή ίσως να καθορίζει τη σειρά με την οποία πρέπει να
	εκτελεστούν κάποιες εντολές.  Αν το αρχείο
	<filename>UPDATING</filename> έρχεται σε σύγκρουση με κάτι που
	διαβάσατε εδώ, προτεραιότητα έχει το αρχείο
	<filename>UPDATING</filename>.</para>

      <important>
	<para>Η ανάγνωση του αρχείου <filename>UPDATING</filename> δεν είναι
	  αποδεκτό υποκατάστατο της συνδρομής στη σωστή λίστα ηλεκτρονικού
	  ταχυδρομείου, όπως περιγράψαμε προηγουμένως.  Οι δύο απαιτήσεις
	  είναι συμπληρωματικές, δεν αλληλοαναιρούνται.</para>
      </important>
    </sect2>

    <sect2>
      <title>Ελέγξτε το <filename>/etc/make.conf</filename></title>
      <indexterm>
	<primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Εξετάστε τα αρχεία
	<filename>/usr/share/examples/etc/make.conf</filename>
	και
	<filename>/etc/make.conf</filename>.  Το πρώτο περιέχει κάποιες
	προεπιλεγμένες μεταβλητές (defines), οι περισσότερες από τις οποίες
	είναι ως σχόλια.  Για να τα χρησιμοποιήσετε όταν μεταγλωττίζετε το
	σύστημα σας, προσθέστε τα στο <filename>/etc/make.conf</filename>.
	Να έχετε υπόψη σας, πως οτιδήποτε προσθέτετε στο αρχείο
	<filename>/etc/make.conf</filename> χρησιμοποιείτε επίσης κάθε φορά
	που εκτελείτε την εντολή <command>make</command>, έτσι είναι γενικά
	καλή ιδέα να βάλετε τιμές που είναι λογικές για το
	σύστημα σας.</para>

      <para>Ένας τυπικός χρήστης θα θέλει πιθανώς να αντιγράψει τις γραμμές
	<makevar>CFLAGS</makevar> και
	<makevar>NO_PROFILE</makevar> από το αρχείο
	<filename>/usr/share/examples/etc/make.conf</filename>
	στο
	<filename>/etc/make.conf</filename> αφαιρώντας ταυτόχρονα και το
	σύμβολο του σχολίου.</para>

      <para>Εξετάστε και τις άλλες μεταβλητές (<makevar>COPTFLAGS</makevar>,
	<makevar>NOPORTDOCS</makevar> κ.ο.κ.) και αποφασίστε αν σχετίζονται
	με το επιθυμητό για σας αποτέλεσμα.</para>
    </sect2>

    <sect2>
      <title>Ενημερώστε τα Αρχεία στο <filename>/etc</filename></title>

      <para>Ο κατάλογος <filename>/etc</filename> περιέχει μεγάλο μέρος των
	πληροφοριών ρύθμισης του συστήματος σας, όπως επίσης και scripts που
	εκτελούνται κατά την εκκίνηση του συστήματος.  Μερικά από τα scripts
	αυτά αλλάζουν από έκδοση σε έκδοση του &os;.</para>

      <para>Ορισμένα από τα αρχεία ρυθμίσεων χρησιμοποιούνται επίσης κατά την
	καθημερινή χρήση του συστήματος.  Το <filename>/etc/group</filename>
	είναι ένα από αυτά.</para>

      <para>Έχουν υπάρξει περιπτώσεις στο παρελθόν, όπου το
	<command>make installworld</command> ανέμενε από πριν την ύπαρξη
	συγκεκριμένων ονομάτων χρηστών (usernames) ή ομάδων (groups).  Κατά
	τη διαδικασία της αναβάθμισης ήταν αρκετά πιθανό αυτοί οι χρήστες ή
	ομάδες να μην υπήρχαν.  Αυτό δημιουργούσε προβλήματα στην
	διαδικασία.  Σε κάποιες περιπτώσεις, το
	<command>make buildworld</command> θα ελέγξει αν υπάρχουν αυτοί οι
	χρήστες ή ομάδες.</para>

      <para>Μια τέτοια περίπτωση παρουσιάστηκε όταν προστέθηκε ο χρήστης
	<username>smmsp</username>.  Η διαδικασία αναβάθμισης αποτύγχανε σε
	πολλούς χρήστες, τη στιγμή που το &man.mtree.8; προσπαθούσε να
	δημιουργήσει τον κατάλογο
	<filename>/var/spool/clientmqueue</filename>.</para>

      <para>Η λύση είναι να εκτελέσετε το &man.mergemaster.8; σε κατάσταση
	προ-εγκατάστασης, δίνοντας την επιλογή <option>-p</option>.  Αυτή
	θα συγκρίνει μόνο τα αρχεία που είναι απαραίτητα για την επιτυχία
	εκτέλεσης του <maketarget>buildworld</maketarget> ή του
	<maketarget>installworld</maketarget>.  Αν η έκδοση του
	<command>mergemaster</command> που έχετε είναι παλιά και δεν
	υποστηρίζει το <option>-p</option>, χρησιμοποιήστε την νέα έκδοση
	από το δέντρο του πηγαίου κώδικα όταν την εκτελέσετε για πρώτη
	φορά:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Αν αισθάνεστε ιδιαίτερα παρανοϊκός, μπορείτε να ελέγξετε το
	  σύστημα σας για να δείτε ποια αρχεία ανήκουν στην ομάδα που
	  μετονομάζετε ή διαγράφετε:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>Η παραπάνω εντολή θα σας δείξει όλα τα αρχεία τα οποία ανήκουν
	  στην ομάδα <replaceable>GID</replaceable> (μπορείτε να δώσετε όνομα
	  ή αριθμητικό αναγνωριστικό της ομάδας).</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Μεταβείτε σε Κατάσταση Ενός Χρήστη</title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>Ίσως προτιμάτε να μεταγλωττίσετε το σύστημα σε κατάσταση ενός
	χρήστη.  Εκτός από το προφανές πλεονέκτημα της ελαφρά μεγαλύτερης
	ταχύτητας, η επανεγκατάσταση του συστήματος θα επηρεάσει πολλά
	σημαντικά αρχεία του συστήματος, όλα τα εκτελέσιμα αρχεία του βασικού
	συστήματος, τις βιβλιοθήκες, τα αρχεία include κ.α.  Αν τα αλλάξετε
	αυτά σε ένα σύστημα που βρίσκεται σε κανονική λειτουργία (και ειδικά
	αν υπάρχουν ενεργοί χρήστες την δεδομένη στιγμή), ψάχνετε για
	μπελάδες.</para>

      <indexterm><primary>multi-user mode</primary></indexterm>
      <para>Μια άλλη μέθοδος είναι να μεταγλωττίσετε το σύστημα σε κατάσταση
	κανονικής λειτουργίας, αλλά να μεταβείτε σε κατάσταση ενός χρήστη για
	την εγκατάσταση.  Αν θέλετε να το κάνετε με αυτό τον τρόπο, απλώς
	μην εκτελέσετε τα ακόλουθα βήματα μέχρι το τέλος της μεταγλώττισης.
	Μπορείτε να αναβάλλετε τη μετάβαση σε κατάσταση ενός χρήστη μέχρι
	να είστε έτοιμοι για το <maketarget>installkernel</maketarget> ή
	<maketarget>installworld</maketarget>.</para>

      <para>Ως υπερχρήστης μπορείτε να εκτελέσετε:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>σε ένα σύστημα σε κανονική λειτουργία για να μεταβείτε σε
	κατάσταση ενός χρήστη.</para>

      <para>Εναλλακτικά, επανεκκινήστε το σύστημα και στην προτροπή του
	φορτωτή εκκίνησης, επιλέξτε <quote>single user</quote>.  Το σύστημα
	θα ξεκινήσει σε κατάσταση ενός χρήστη.  Στην προτροπή της γραμμής
	εντολών θα πρέπει να γράψετε:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Θα γίνει έλεγχος στα συστήματα αρχείων, και προσάρτηση του
	<filename>/</filename> με δυνατότητα ανάγνωσης/εγγραφής.  Έπειτα θα
	προσαρτηθούν όλα τα άλλα συστήματα αρχείων UFS τα οποία αναφέρονται
	στο <filename>/etc/fstab</filename>, και θα ενεργοποιηθεί το
	swap.</para>

	<note>
	  <para>Αν το CMOS ρολόι του υπολογιστή σας είναι ρυθμισμένο σε
	    τοπική ώρα και όχι σε GMT (αυτό είναι αλήθεια αν η έξοδος της
	    εντολής &man.date.1; δεν δείχνει σωστή ημερομηνία και ώρα), ίσως
	    χρειαστεί να εκτελέσετε επίσης την παρακάτω εντολή:</para>

	  <screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	  <para>Με αυτό τον τρόπο θα βεβαιωθείτε ότι οι τοπικές σας ρυθμίσεις
	    ώρας έχουν ρυθμιστεί σωστά.  Διαφορετικά, μπορεί να συναντήσετε
	    προβλήματα αργότερα.</para>
	</note>
    </sect2>

    <sect2>
      <title>Διαγράψτε το <filename>/usr/obj</filename></title>

      <para>Καθώς γίνεται η επαναμεταγλώττιση, τμήματα του συστήματος
	τοποθετούνται από προεπιλογή σε υποκαταλόγους του
	<filename>/usr/obj</filename>.  Οι υποκατάλογοι αυτοί αντιγράφουν τη
	δομή που ακολουθείται στο <filename>/usr/src</filename>.</para>

      <para>Μπορείτε να επιταχύνετε τη διαδικασία του
	<command>make buildworld</command> και επίσης να γλυτώσετε από κάποια
	πιθανά προβλήματα, αν διαγράψετε και αυτό τον κατάλογο.</para>

      <para>Κάποια αρχεία σε υποκαταλόγους του <filename>/usr/obj</filename>
	μπορεί να έχουν χαρακτηριστεί ως immutable μέσω του αντίστοιχου flag
	(για περισσότερες λεπτομέρειες δείτε το &man.chflags.1;).  Πριν
	διαγράψετε αυτά τα αρχεία, θα πρέπει πρώτα να καταργήσετε αυτό το
	flag.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 id="cutting-edge-compilebase">
      <title>Επαναμεταγλωττίστε το Βασικό Σύστημα</title>

      <sect3>
	<title>Αποθηκεύστε την Έξοδο</title>

	<para>Καθώς εκτελείται η &man.make.1;, είναι καλή ιδέα η έξοδος της
	  να αποθηκεύεται σε κάποιο άλλο αρχείο.  Αν κάτι πάει στραβά, θα
	  έχετε ένα αντίγραφο του μηνύματος λάθους.  Αν και αυτό ίσως δεν σας
	  βοηθήσει να βρείτε τι πήγε στραβά, μπορεί να διευκολύνει άλλους αν
	  στείλετε το μήνυμα σας σε μια από τις λίστες ηλεκτρονικού
	  ταχυδρομείου του &os;.</para>

	<para>Ο ευκολότερος τρόπος για να γίνει αυτό, είναι χρησιμοποιώντας
	  την εντολή &man.script.1; με μια παράμετρο που να καθορίζει το όνομα
	  του αρχείου στο οποίο θα αποθηκευτεί η έξοδος.  Θα πρέπει να
	  το εκτελέσετε αμέσως πριν ξεκινήσετε την μεταγλώττιση του βασικού
	  συστήματος, και να γράψετε <userinput>exit</userinput> μόλις
	  η διαδικασία ολοκληρωθεί.</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; μεταγλώττιση, μεταγλώττιση, μεταγλώττιση &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Αν αποφασίσετε να αποθηκεύσετε την έξοδο,
	  <emphasis>μη χρησιμοποιήσετε</emphasis> για αυτό το σκοπό τον
	  κατάλογο <filename>/tmp</filename>.  Τα περιεχόμενα αυτού του
	  καταλόγου πιθανώς να διαγραφούν την επόμενη φορά που θα εκκινήσετε
	  το σύστημα σας.  Ένας καλύτερος κατάλογος για την αποθήκευση του
	  είναι ο <filename>/var/tmp</filename> (όπως στο προηγούμενο
	  παράδειγμα) ή ο προσωπικός κατάλογος του
	  <username>root</username>.</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>Μεταγλωττίστε το Βασικό Σύστημα</title>

	<para>Θα πρέπει να βρίσκεστε στον κατάλογο
	  <filename>/usr/src</filename>:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(εκτός αν φυσικά έχετε αποθηκεύσει τον πηγαίο κώδικα σε κάποιο
	  άλλο κατάλογο, οπότε απλώς μετακινηθείτε σε αυτόν).</para>
	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Για να επαναμεταγλωττίσετε το βασικό σύστημα, χρησιμοποιήστε
	  την εντολή &man.make.1;.  Η εντολή αυτή διαβάζει τις σχετικές
	  οδηγίες από το αρχείο <filename>Makefile</filename>, το οποίο
	  περιγράφει με ποιο τρόπο πρέπει να μεταγλωττιστούν τα προγράμματα
	  από τα οποία αποτελείται το &os;, τη σειρά με την οποία πρέπει να
	  γίνει η μεταγλώττιση κ.ο.κ.</para>

	<para>Η γενική μορφή της εντολής που θα πληκτρολογήσετε είναι η
	  παρακάτω:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

	<para>Στο παράδειγμα αυτό, το
	  <option>-<replaceable>x</replaceable></option> αντιπροσωπεύει μια
	  επιλογή που θέλετε να δώσετε στην &man.make.1;.  Δείτε την σελίδα
	  manual του &man.make.1; για παραδείγματα δυνατών επιλογών.</para>

	<para>Η επιλογή <option>-D<replaceable>VARIABLE</replaceable></option>
	  περνάει μια μεταβλητή στο <filename>Makefile</filename>.
	  Η συμπεριφορά του <filename>Makefile</filename> ελέγχεται από
	  τέτοιου είδους μεταβλητές.  Πρόκειται για τις ίδιες μεταβλητές που
	  καθορίζονται και στο <filename>/etc/make.conf</filename>, και αυτός
	  είναι ένας ακόμα τρόπος καθορισμού τους.</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>target</replaceable></userinput></screen>

	<para>Το παραπάνω δείχνει ένα επιπλέον τρόπο να καθορίσετε ότι δεν
	  θέλετε να μεταγλωττιστούν οι βιβλιοθήκες με πληροφορίες profiling,
	  και αντιστοιχεί με την παρακάτω γραμμή στο
	  <filename>/etc/make.conf</filename>:</para>

	<programlisting>NO_PROFILE=    true 	#    Avoid compiling profiled libraries</programlisting>

	<para>Το <replaceable>target</replaceable> δηλώνει στο &man.make.1;
	  τι θέλετε να κάνετε.  Σε κάθε <filename>Makefile</filename> ορίζεται
	  ένας αριθμός διαφορετικών <quote>targets</quote>, και η επιλογή που
	  θα κάνετε, καθορίζει τι ακριβώς θα γίνει.</para>

	<para>Κάποια από τα targets που καθορίζονται στο
	  <filename>Makefile</filename>, δεν προορίζονται για άμεση εκτέλεση
	  από το χρήστη.  Αντί για αυτό, χρησιμοποιούνται από τη διαδικασία
	  μεταγλώττισης για να μοιραστεί ο αριθμός των βημάτων που απαιτούνται
	  για τη μεταγλώττιση του συστήματος, σε ένα αριθμό
	  υπo-βημάτων.</para>

	<para>Στις περισσότερες περιπτώσεις δεν θα χρειαστεί να δώσετε καμία
	  παράμετρο στο &man.make.1;, και έτσι η εντολή σας θα μοιάζει με την
	  παρακάτω:</para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>

	<para>Όπου το <replaceable>target</replaceable> θα είναι μια από τις
	  πολλές επιλογές μεταγλώττισης.  Το πρώτο target θα πρέπει πάντα να
	  είναι το <makevar>buildworld</makevar>.</para>

	<para>Όπως εννοείται και από το όνομα, το
	  <maketarget>buildworld</maketarget> μεταγλωττίζει ένα πλήρες δέντρο
	  μέσα στον κατάλογο <filename>/usr/obj</filename>, ενώ το
	  <maketarget>installworld</maketarget>, εγκαθιστά αυτό το δέντρο στο
	  τρέχον μηχάνημα.</para>

	<para>Η ύπαρξη διαφορετικών επιλογών, είναι χρήσιμη για δύο λόγους.
	  Πρώτα από όλα, σας επιτρέπει να εκτελέσετε τη διαδικασία
	  μεταγλώττισης με ασφάλεια, γνωρίζοντας ότι δεν πρόκειται να
	  επηρεαστεί κανένα τμήμα του τρέχοντος συστήματος σας.  Η διαδικασία
	  μεταγλώττισης είναι <quote>self hosted</quote>, απομονωμένη από την
	  υπόλοιπη λειτουργία του μηχανήματος.  Μπορείτε έτσι να εκτελέσετε
	  το <maketarget>buildworld</maketarget> σε ένα μηχάνημα που βρίσκεται
	  σε κανονική λειτουργία (πολλαπλών χρηστών) χωρίς να υπάρχει φόβος
	  παρενεργειών.  Ωστόσο, συνίσταται να εκτελέσετε το
	  <maketarget>installworld</maketarget> σε κατάσταση λειτουργίας
	  ενός χρήστη.</para>

	<para>Ο δεύτερος λόγος είναι ότι σας επιτρέπει να χρησιμοποιήσετε
	  προσαρτήσεις NFS για να αναβαθμίσετε πολλά μηχανήματα του δικτύου
	  σας.  Αν έχετε τρία μηχανήματα, τα
	  <hostid>A</hostid>, <hostid>B</hostid> και <hostid>C</hostid>
	  τα οποία θέλετε να αναβαθμίσετε, εκτελέστε το
	  <command>make buildworld</command> και το
	  <command>make installworld</command> στο μηχάνημα
	  <hostid>A</hostid>.  Το <hostid>B</hostid> και το
	  <hostid>C</hostid> μπορούν να προσαρτήσουν τον κατάλογο
	  <filename>/usr/src</filename> και τον
	  <filename>/usr/obj</filename> από τον <hostid>A</hostid> μέσω NFS,
	  και έπειτα μπορείτε να εκτελέσετε το
	  <command>make installworld</command> για να εγκαταστήσετε το
	  έτοιμο πλέον σύστημα στον <hostid>B</hostid> και
	  <hostid>C</hostid>.</para>

	<para>Αν και υπάρχει ακόμα το target <maketarget>world</maketarget>,
	  δεν συνίσταται πλέον η χρήση του.</para>

	<para>Εκτελέστε την εντολή:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Μπορείτε να καθορίσετε την επιλογή <option>-j</option> στην
	  <command>make</command> ώστε να εκτελεστεί σε πολλαπλές διεργασίες.
	  Αυτό είναι περισσότερο χρήσιμο σε μηχανήματα με πολλούς
	  επεξεργαστές, ωστόσο καθώς το μεγαλύτερο μέρος της διαδικασίας
	  μεταγλώττισης καθυστερεί εξαιτίας του σκληρού δίσκου (IO bound)
	  και όχι της CPU, μπορεί να σας φανεί χρήσιμο ακόμα και σε μηχανήματα
	  με ένα επεξεργαστή.</para>

	<para>Σε ένα τυπικό μηχάνημα με μια CPU, θα μπορούσατε να
	  δώσετε:</para>

	  <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>Με την παραπάνω εντολή, το &man.make.1; θα χρησιμοποιεί μέχρι
	  4 διεργασίες κάθε χρονική στιγμή.  Από την εμπειρία που έχουμε
	  και από ότι αναφέρουν οι χρήστες στις λίστες, φαίνεται ότι η
	  ρύθμιση αυτή δίνει γενικά την καλύτερη απόδοση.</para>

	<para>Αν έχετε μηχάνημα με πολλούς επεξεργαστές, και χρησιμοποιείτε
	  πυρήνα με δυνατότητα SMP, δοκιμάστε τιμές μεταξύ του 6 και του 10
	  για να δείτε ποια επιταχύνει καλύτερα το αποτέλεσμα.</para>
      </sect3>

      <sect3>
	<title>Χρόνος Μεταγλώττισης</title>
	<indexterm>
	  <primary>rebuilding <quote>world</quote></primary>
	  <secondary>timings</secondary>
	</indexterm>

	<para>Ο χρόνος που απαιτείται για την μεταγλώττιση επηρεάζεται από
	  πολλούς παράγοντες.  Ωστόσο, σε σύγχρονα μηχανήματα η διαδικασία
	  δεν κρατάει συνήθως παραπάνω από μία ή δύο ώρες, όταν γίνεται
	  μεταγλώττιση του δέντρου &os.stable;, και μάλιστα χωρίς να
	  χρειάζεται να γίνουν ειδικές ρυθμίσεις ή κόλπα.  Το δέντρο
	  &os.current; χρειάζεται γενικά λίγο περισσότερο χρόνο για να
	  μεταγλωττιστεί.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Μεταγλωττίστε και Εγκαταστήστε Νέο Πυρήνα</title>
      <indexterm>
	<primary>kernel</primary>
	<secondary>compiling</secondary>
      </indexterm>

      <para>Για να εκμεταλλευθείτε πλήρως το νέο σας σύστημα, θα πρέπει να
	επαναμεταγλωττίσετε τον πυρήνα.  Αυτό είναι πρακτικά αναγκαίο, καθώς
	κάποιες δομές στη μνήμη πιθανώς να έχουν αλλάξει, και έτσι
	προγράμματα όπως τα &man.ps.1; και &man.top.1; δεν θα λειτουργούν
	σωστά μέχρι να συγχρονίσετε τον πυρήνα με την έκδοση πηγαίου
	κώδικα του βασικού συστήματος.</para>

      <para>Ο απλούστερος και πλέον ασφαλής τρόπος, είναι να μεταγλωττίσετε
	και να εγκαταστήσετε ένα πυρήνα βασισμένο στον
	<filename>GENERIC</filename>.  Αν και ο <filename>GENERIC</filename>
	μπορεί να μην περιέχει όλες τις απαραίτητες συσκευές για το σύστημα
	σας, θα πρέπει να περιέχει ότι χρειάζεται ώστε να ξεκινήσετε ξανά
	το σύστημα σας σε κατάσταση λειτουργίας ενός χρήστη.  Αυτό είναι ένα
	καλό τεστ σωστής λειτουργίας του συστήματος.  Μετά την εκκίνηση με
	τον <filename>GENERIC</filename>, και αφού επαληθεύσετε τη σωστή
	λειτουργία του συστήματος, μπορείτε να μεταγλωττίσετε ένα νέο
	πυρήνα βασισμένο στο δικό σας προσαρμοσμένο αρχείο ρυθμίσεων.</para>

      <para>Στο &os; είναι σημαντικό να εκτελέσετε το <link
	linkend="make-buildworld">build world</link> πριν μεταγλωττίσετε νέο
	πυρήνα.</para>

      <note><para>Αν θέλετε να μεταγλωττίσετε νέο πυρήνα, και έχετε ήδη ένα
	αρχείο με προσαρμοσμένες ρυθμίσεις, χρησιμοποιήστε απλώς την επιλογή
	<literal>KERNCONF=<replaceable>MYKERNEL</replaceable></literal>
	με τον τρόπο που φαίνεται παρακάτω:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </note>

      <para>Σημειώστε ότι αν έχετε ανεβάσει την τιμή του
	<literal>kern.securelevel</literal> πάνω από το 1,
	<emphasis>και</emphasis> έχετε θέσει το flag
	<literal>noschg</literal> ή κάποιο αντίστοιχο στο εκτελέσιμο αρχείο
	του πυρήνα, μάλλον θα χρειαστεί να μεταβείτε σε κατάσταση λειτουργίας
	ενός χρήστη για να χρησιμοποιήσετε το
	<maketarget>installkernel</maketarget>.  Διαφορετικά, μπορείτε να
	εκτελέσετε και τις δύο αυτές εντολές από την κανονική κατάσταση
	λειτουργίας (πολλών χρηστών) χωρίς να δημιουργηθούν προβλήματα.
	Δείτε τη σελίδα manual του &man.init.8; για λεπτομέρειες σχετικά με
	τη ρύθμιση <literal>kern.securelevel</literal> και τη σελίδα
	του &man.chflags.1; για λεπτομέρειες σχετικά με τα διάφορα flags
	που χρησιμοποιούνται σε αρχεία.</para>
    </sect2>

    <sect2>
      <title>Επανεκκινήστε σε Κατάσταση Λειτουργίας Ενός Χρήστη</title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>Θα πρέπει να επανεκκινήσετε σε κατάσταση λειτουργίας ενός χρήστη
	για να επαληθεύσετε τη λειτουργία του νέου πυρήνα.  Για το σκοπό
	αυτό, χρησιμοποιήστε τις οδηγίες που είδαμε στο
	<xref linkend="makeworld-singleuser">.</para>
    </sect2>

    <sect2 id="make-installworld">
      <title>Εγκαταστήστε τα Νέα Εκτελέσιμα του Συστήματος</title>

      <para>Αν μεταγλωττίζατε μια αρκετά πρόσφατη έκδοση του &os;, η οποία
	διαθέτει το target <command>make buildworld</command>, θα πρέπει
	τώρα να χρησιμοποιήσετε το <maketarget>installworld</maketarget>
	για να εγκαταστήσετε τα νέα εκτελέσιμα του συστήματος.</para>

      <para>Εκτελέστε τις παρακάτω εντολές:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Αν έχετε καθορίσει μεταβλητές στη γραμμή εντολών του
	  <command>make buildworld</command> θα πρέπει να καθορίσετε τις
	  ίδιες μεταβλητές και στην γραμμή εντολών του
	  <command>make installworld</command>.  Αυτό δεν είναι απαραίτητα
	  αλήθεια για άλλες επιλογές.  Για παράδειγμα, η επιλογή
	  <option>-j</option> δεν πρέπει ποτέ να χρησιμοποιείτε με το
	  <maketarget>installworld</maketarget>.</para>

	<para>Για παράδειγμα αν εκτελέσετε:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>Θα πρέπει να εγκαταστήσετε το αποτέλεσμα χρησιμοποιώντας:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>διαφορετικά το &man.make.1; θα προσπαθήσει να εγκαταστήσει
	  βιβλιοθήκες με profiling, τις οποίες όμως δεν μεταγλωττίσατε κατά
	  τη διάρκεια της φάσης <command>make buildworld</command>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Ενημερώστε Όσα Αρχεία δεν Ενημερώθηκαν από το
	<command>make installworld</command></title>

      <para>Η επαναμεταγλώττιση του βασικού συστήματος δεν θα ενημερώσει
	ορισμένους καταλόγους (ειδικότερα τους
	<filename>/etc</filename>, <filename>/var</filename> και
	<filename>/usr</filename>) με τα νέα ή αλλαγμένα αρχεία
	ρυθμίσεων.</para>

      <para>Ο απλούστερος τρόπος για να ενημερώσετε τα αρχεία αυτά είναι να
	χρησιμοποιήσετε το &man.mergemaster.8;, αν και μπορείτε να το κάνετε
	και χειροκίνητα αν προτιμάτε.  Άσχετα από τον τρόπο που θα
	προτιμήσετε, βεβαιωθείτε ότι έχετε πάρει αντίγραφο ασφαλείας του
	<filename>/etc</filename> σε περίπτωση που κάτι πάει στραβά.</para>

    <sect3 id="mergemaster">
      <sect3info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Συνεισφορά του </contrib>
	  </author>
	</authorgroup>
      </sect3info>

      <title><command>mergemaster</command></title>
      <indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>Το βοηθητικό πρόγραμμα &man.mergemaster.8; είναι ένα Bourne
	script το οποίο θα σας βοηθήσει να καθορίσετε τις διαφορές μεταξύ
	των εγκατεστημένων στο <filename>/etc</filename> αρχείων ρυθμίσεων,
	και των αντίστοιχων στο δέντρο πηγαίου κώδικα στο
	<filename>/usr/src/etc</filename>.  Αυτή είναι και η συνιστώμενη
	λύση για να ενημερώσετε τα αρχεία ρυθμίσεων του συστήματος με τυχόν
	αλλαγές που έχουν γίνει στον νέο πηγαίο κώδικα.</para>

      <para>Για να ξεκινήσετε, απλώς γράψτε <command>mergemaster</command>
	στην προτροπή της γραμμής εντολών και παρακολουθήστε την καθώς
	λειτουργεί.  Το <command>mergemaster</command> θα δημιουργήσει ένα
	προσωρινό περιβάλλον root, από το <filename>/</filename> και κάτω,
	και θα το γεμίσει με διάφορα αρχεία ρυθμίσεων του συστήματος.  Έπειτα
	θα γίνει σύγκριση αυτών των αρχείων με τα αντίστοιχα που βρίσκονται
	ήδη εγκατεστημένα στο σύστημα σας.  Στο σημείο αυτό, θα σας δείξει
	τα αρχεία που διαφέρουν με μορφή &man.diff.1;, όπου οι γραμμές που
	έχουν τροποποιηθεί ή είναι νέες θα φαίνονται με ένα
	<option>+</option>, ενώ με το <option>-</option> θα φαίνονται οι
	γραμμές που είτε αφαιρούνται εντελώς ή που αντικαθίστανται από μια
	νέα γραμμή.  Δείτε τη σελίδα manual του &man.diff.1; για περισσότερες
	πληροφορίες σχετικά με τη σύνταξη του &man.diff.1; και για τον τρόπο
	με τον οποίο φαίνονται οι διαφορές μεταξύ των αρχείων.</para>

      <para>Το &man.mergemaster.8; θα σας δείξει έπειτα κάθε αρχείο που
	παρουσιάζει διαφορές, και στο σημείο αυτό θα έχετε την δυνατότητα
	είτε να διαγράψετε το νέο αρχείο (το οποίο αναφέρεται ως προσωρινό
	αρχείο), είτε να εγκαταστήσετε το προσωρινό αρχείο χωρίς να κάνετε
	σε αυτό καμιά αλλαγή, είτε να συγχωνεύσετε τις αλλαγές των δύο
	αρχείων, ή τέλος να ξαναδείτε τις διαφορές μέσω της
	&man.diff.1;.</para>

      <para>Αν επιλέξετε να διαγράψετε το προσωρινό αρχείο, το
	&man.mergemaster.8; θα καταλάβει ότι επιθυμείτε να διατηρήσετε το
	τρέχον αρχείο σας χωρίς αλλαγές, και να διαγράψετε τη νέα έκδοση.
	Η επιλογή αυτή γενικά δεν συνίσταται, εκτός αν δεν βλέπετε κανένα
	λόγο να αλλάξετε το τρέχον αρχείο.  Μπορείτε να δείτε βοήθεια
	οποιαδήποτε στιγμή κατά τη διάρκεια της διαδικασίας, πληκτρολογώντας
	<keycap>?</keycap> στην προτροπή του &man.mergemaster.8;.  Αν
	αποφασίσετε να παραλείψετε κάποιο αρχείο, αυτό θα εμφανιστεί
	ξανά μετά το τέλος όλων των άλλων αρχείων.</para>

      <para>Αν επιλέξετε να εγκαταστήσετε το προσωρινό αρχείο χωρίς αλλαγές,
	αυτό θα αντικαταστήσει το ήδη εγκατεστημένο σας αρχείο.  Αυτή είναι
	και η καλύτερη επιλογή για τα αρχεία τα οποία δεν έχετε αλλάξει
	εσείς χειροκίνητα.</para>

      <para>Αν επιλέξετε να συγχωνεύσετε τα δύο αρχεία, θα εμφανιστεί ένας
	επεξεργαστής κειμένου με τα περιεχόμενα και των δύο αρχείων.
	Μπορείτε τώρα να τα συγχωνεύσετε παρατηρώντας ταυτόχρονα και τα δύο
	αρχεία δίπλα-δίπλα, και επιλέγοντας τμήματα και από τα δύο για να
	δημιουργήσετε την τελική έκδοση.  Κατά τη σύγκριση αυτή, μπορείτε να
	χρησιμοποιήσετε το πλήκτρο <keycap>l</keycap> για να επιλέξετε τα
	περιεχόμενα που φαίνονται στην αριστερή πλευρά, ή το
	<keycap>r</keycap> για τα αντίστοιχα περιεχόμενα στη δεξιά.
	Το τελικό αποτέλεσμα θα είναι ένα αρχείο που θα αποτελείται από
	τμήματα και των δύο αρχείων, και το οποίο μπορείτε να εγκαταστήσετε.
	Η επιλογή αυτή χρησιμοποιείται συνήθως για αρχεία των οποίων το
	περιεχόμενο έχει μεταβληθεί από το χρήστη.</para>

      <para>Αν επιλέξετε να δείτε ξανά τις διαφορές μέσω της &man.diff.1;,
	αυτές θα εμφανιστούν ακριβώς όπως έγινε και πριν
	σας ρωτήσει το &man.mergemaster.8; να επιλέξετε τι θέλετε να κάνετε
	με το αρχείο.</para>

      <para>Μόλις ολοκληρωθεί η λειτουργία του &man.mergemaster.8; στα αρχεία
	συστήματος, θα σας ρωτήσει για άλλες επιλογές.
	Το &man.mergemaster.8; ίσως σας ρωτήσει αν θέλετε να αναδημιουργήσετε
	το αρχείο των κωδικών (password file), και θα τελειώσει δίνοντας σας
	την επιλογή να διαγράψετε τυχόν προσωρινά αρχεία που δημιουργήθηκαν
	κατά την διαδικασία.</para>
      </sect3>

      <sect3>
	<title>Χειροκίνητη Ενημέρωση</title>

      <para>Αν επιθυμείτε να κάνετε την ενημέρωση χειροκίνητα, δεν μπορείτε
	απλώς να αντιγράψετε τα αρχεία από τον κατάλογο
	<filename>/usr/src/etc</filename> στον <filename>/etc</filename> και
	να περιμένετε ότι το σύστημα σας θα λειτουργήσει σωστά.  Κάποια από
	αυτά τα αρχεία θα πρέπει να <quote>εγκατασταθούν</quote> πρώτα.  Αυτό
	συμβαίνει επειδή ο κατάλογος <filename>/usr/src/etc</filename>
	<emphasis>δεν είναι</emphasis> κανονικό αντίγραφο του
	<filename>/etc</filename>.  Επιπρόσθετα, υπάρχουν αρχεία τα οποία
	πρέπει να βρίσκονται στον κατάλογο <filename>/etc</filename>, αλλά
	δεν υπάρχουν στον <filename>/usr/src/etc</filename>.</para>

      <para>Αν χρησιμοποιείτε το &man.mergemaster.8; (όπως και συνίσταται),
	μπορείτε να διαβάσετε κατευθείαν την <link
	  linkend="cutting-edge-rebooting">επόμενη ενότητα</link>.</para>

      <para>Ο απλούστερος τρόπος να το κάνετε αυτό χειροκίνητα, είναι να
	εγκαταστήσετε τα αρχεία σε ένα νέο κατάλογο, και έπειτα να τα
	εξετάσετε ένα-ένα ψάχνοντας για τις αλλαγές.</para>

      <warning>
	<title>Κρατήστε Ένα Αντίγραφο Ασφαλείας του Καταλόγου
	  <filename>/etc</filename></title>

	<para>Αν και θεωρητικά, τίποτα δεν πρόκειται να πειράξει αυτό τον
	  κατάλογο αυτόματα, είναι πάντα καλύτερα να είμαστε σίγουροι.
	  Για το λόγο αυτό, αντιγράψτε τον υπάρχοντα κατάλογο
	  <filename>/etc</filename> σε κάποιο ασφαλές μέρος.  Χρησιμοποιήστε
	  μια εντολή όπως η παρακάτω:</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para>Η επιλογή <option>-R</option> πραγματοποιεί αναδρομική
	  αντιγραφή, ενώ η <option>-p</option> διατηρεί τα δικαιώματα, την
	  ιδιοκτησία, τις ημερομηνίες των αρχείων, κ.ο.κ.</para>
      </warning>

      <para>θα πρέπει να δημιουργήσετε μια ψευτο-δομή καταλόγων για να
	εγκαταστήσετε το νέο κατάλογο <filename>/etc</filename> και άλλα
	αρχεία.  Μια λογική επιλογή είναι ο κατάλογος
	<filename>/var/tmp/root</filename>, και κάτω από αυτόν, θα πρέπει
	επίσης να δημιουργήσετε και μια ολόκληρη σειρά από τους υποκαταλόγους
	που απαιτούνται.</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>Οι παραπάνω εντολές θα δημιουργήσουν την απαιτούμενη δομή
	καταλόγων και θα εγκαταστήσουν τα αρχεία.  Μεγάλο μέρος των
	υποκαταλόγων που έχουν δημιουργηθεί κάτω από τον
	<filename>/var/tmp/root</filename> είναι άδειοι, και πρέπει να
	διαγραφούν.  Ο απλούστερος τρόπος για να γίνει αυτό, φαίνεται
	παρακάτω:</para>

      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

      <para>Αυτό θα διαγράψει όλους τους άδειους υποκαταλόγους.  (Η έξοδος
	σφάλματος ανακατευθύνεται στο <filename>/dev/null</filename> ώστε
	να μην εμφανίζονται στην οθόνη προειδοποιήσεις για καταλόγους που
	δεν είναι άδειοι.)</para>

      <para>Τώρα, ο <filename>/var/tmp/root</filename> περιέχει όλα τα αρχεία
	που θα πρέπει να τοποθετηθούν σε κατάλληλες θέσεις κάτω από τον
	<filename>/</filename>.  Θα πρέπει τώρα να διατρέξετε καθένα από
	αυτά τα αρχεία, και να καθορίσετε πως καθένα από αυτά διαφέρει από
	το αντίστοιχο υπάρχον (εγκατεστημένο) αρχείο.</para>

      <para>Σημειώστε ότι κάποια από τα αρχεία τα οποία έχουν
	εγκατασταθεί στον <filename>/var/tmp/root</filename> έχουν μια
	αρχική <quote>.</quote>.  Τη στιγμή που γράφονται αυτές οι γραμμές,
	τα μόνα αρχεία στα οποία συμβαίνει αυτό είναι τα αρχεία εκκίνησης
	του κελύφους στον κατάλογο <filename>/var/tmp/root/</filename> και
	<filename>/var/tmp/root/root/</filename>, αν και μπορεί να υπάρχουν
	και άλλα (ανάλογα με το πότε διαβάζετε το κείμενο).  Βεβαιωθείτε ότι
	χρησιμοποιείτε την εντολή <command>ls -a</command> για να τα δείτε
	όλα.</para>

      <para>Ο απλούστερος τρόπος για να συγκρίνετε δύο αρχεία, είναι να
	χρησιμοποιήσετε την εντολή &man.diff.1;:</para>

      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

      <para>Η παραπάνω εντολή θα σας δείξει τις διαφορές μεταξύ του αρχείου
	<filename>/etc/shells</filename> και του νέου αρχείου
	<filename>/var/tmp/root/etc/shells</filename>.  Χρησιμοποιήστε τις
	διαφορές αυτές για να αποφασίσετε αν θα πρέπει να συγχωνεύσετε τις
	αλλαγές που έχετε κάνει, ή απλώς να αντιγράψετε το παλιό σας αρχείο
	πάνω από το νέο.</para>

      <tip>
	<title>Προσθέστε την Ημερομηνία στο Όνομα του Νέου Root Καταλόγου,
	  (<filename>/var/tmp/root</filename>) Ώστε να Μπορείτε Εύκολα να
	  Συγκρίνετε Διαφορετικές Εκδόσεις Μεταξύ τους</title>

	<para>Αν μεταγλωττίζετε συχνά το βασικό σύστημα, θα πρέπει επίσης
	  να ενημερώνετε συχνά τον κατάλογο <filename>/etc</filename>, το
	  οποίο μπορεί να είναι ενοχλητικό.</para>

	<para>Μπορείτε να επιταχύνετε αυτή τη διαδικασία, τηρώντας ένα
	  αντίγραφο του τελευταίου σετ αλλαγμένων αρχείων τα οποία
	  συγχωνεύσατε στον κατάλογο <filename>/etc</filename>.  Η παρακάτω
	  διαδικασία θα σας δώσει μια ιδέα για το πως μπορεί να
	  γίνει αυτό:</para>

	<procedure>
	  <step>
	    <para>Μεταγλωττίστε το βασικό σύστημα όπως κάνετε συνήθως.  Όταν
	      θέλετε να ενημερώσετε τον <filename>/etc</filename> και τους
	      άλλους καταλόγους, δώστε στον κατάλογο προορισμού ένα όνομα
	      βασισμένο στην τρέχουσα ημερομηνία.  Αν το κάνατε αυτό
	      στις 14 Φεβρουαρίου 1998, θα γράφατε κάτι σαν το
	      παρακάτω:</para>

	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>

	  <step>
	    <para>Συγχωνεύστε τις αλλαγές από αυτό τον κατάλογο, με τον τρόπο
	      που περιγράψαμε παραπάνω.</para>

	    <para><emphasis>Μην διαγράψετε</emphasis> τον κατάλογο
	      <filename>/var/tmp/root-19980214</filename> όταν τελειώσετε
	      με την παραπάνω διαδικασία.</para>
	  </step>

	  <step>
	    <para>Όταν κατεβάσετε την τελευταία έκδοση του πηγαίου κώδικα και
	      τον μεταγλωττίσετε ξανά, ακολουθήστε το βήμα 1.  Αυτό θα σας
	      δώσει ένα κατάλογο που μπορεί να ονομάζεται
	      <filename>/var/tmp/root-19980221</filename> (αν ανάμεσα στις
	      δύο μεταγλωττίσεις παρεμβάλλεται διάστημα μιας
	      εβδομάδας).</para>
	  </step>

	  <step>
	    <para>Μπορείτε τώρα να δείτε τις διαφορές που υπάρχουν ανάμεσα
	      στις δύο εβδομάδες, χρησιμοποιώντας την εντολή
	      &man.diff.1; σε αναδρομική λειτουργία για να δημιουργήσετε τις
	      διαφορές μεταξύ των δύο καταλόγων:</para>

	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	    <para>Τυπικά, αυτό το σετ αλλαγών θα είναι πολύ μικρότερο από
	      αυτό μεταξύ του <filename>/var/tmp/root-19980221/etc</filename>
	      και του <filename>/etc</filename>.  Καθώς αυτό το σετ αλλαγών
	      είναι μικρότερο, είναι και πιο εύκολο να εφαρμόσετε αυτές
	      τις αλλαγές στον κατάλογο <filename>/etc</filename>.</para>
	  </step>

	  <step>
	    <para>Μπορείτε τώρα να διαγράψετε τον παλιότερο από τους δύο
	      καταλόγους <filename>/var/tmp/root-*</filename>:</para>

	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>

	  <step>
	    <para>Επαναλάβετε αυτή τη διαδικασία κάθε φορά που θέλετε να
	      συγχωνεύσετε τις αλλαγές στον κατάλογο
	      <filename>/etc</filename>.</para>
	  </step>
	</procedure>

	<para>Μπορείτε επίσης να χρησιμοποιήσετε την εντολή &man.date.1; για
	  να αυτοματοποιήσετε την δημιουργία των ονομάτων καταλόγων:</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
      </sect3>
    </sect2>

    <sect2 id="cutting-edge-rebooting">
      <title>Επανεκκίνηση</title>

      <para>Η διαδικασία έχει πλέον ολοκληρωθεί.  Αφού επαληθεύσετε ότι όλα
	βρίσκονται στις σωστές θέσεις, μπορείτε να επανεκκινήσετε το σύστημα.
	Μια απλή εντολή &man.shutdown.8; είναι επαρκής:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Ολοκλήρωση</title>

      <para>Έχετε πλέον αναβαθμίσει το &os; σύστημα σας.  Συγχαρητήρια.</para>

      <para>Αν τα πράγματα δεν πήγαν εντελώς σωστά, είναι εύκολο να
	μεταγλωττίσετε ξανά οποιοδήποτε τμήμα του συστήματος.
	Για παράδειγμα, αν διαγράψετε κατά λάθος το
	<filename>/etc/magic</filename> ως μέρος μιας αναβάθμισης ή
	συγχώνευσης του <filename>/etc</filename>, η εντολή &man.file.1;
	θα σταματήσει να λειτουργεί.  Στην περίπτωση αυτή, η διόρθωση είναι
	να εκτελέσετε:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Ερωτήσεις</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Πρέπει να μεταγλωττίσω ξανά ολόκληρο το βασικό σύστημα σε
	      κάθε αλλαγή;</para>
	  </question>

	  <answer>
	    <para>Δεν υπάρχει εύκολη απάντηση σε αυτό το ερώτημα, καθώς
	      εξαρτάται από τη φύση της αλλαγής.  Για παράδειγμα, αν
	      εκτελέσετε το <application>CVSup</application>, και δείτε ότι
	      ενημερώθηκαν τα παρακάτω αρχεία:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>Το πιθανότερο είναι ότι δεν χρειάζεται να μεταγλωττίσετε
	      ξανά όλο το βασικό σύστημα.  Μπορείτε απλώς να μεταβείτε στους
	      σχετικούς υποκαταλόγους και να εκτελέσετε το
	      <command>make all install</command>, και θα έχετε τελειώσει.
	      Αν όμως υπάρχει κάποια σημαντική αλλαγή, για παράδειγμα το
	      <filename>src/lib/libc/stdlib</filename>, θα πρέπει είτε να
	      επαναμεταγλωττίσετε το βασικό σύστημα, ή τουλάχιστον αυτά τα
	      κομμάτια τα οποία είναι στατικά συνδεδεμένα (όπως και οτιδήποτε
	      άλλο έχετε προσθέσει εσείς και το οποίο είναι στατικά
	      συνδεδεμένο).</para>

	    <para>Τελικά, η απόφαση είναι δική σας.  Μπορεί να είστε
	      ικανοποιημένος αν μεταγλωττίζετε το βασικό σύστημα κάθε δύο
	      βδομάδες, αφήνοντας τις αλλαγές να συγκεντρωθούν στη διάρκεια
	      αυτού του διαστήματος.  Ή μπορεί να θέλετε να μεταγλωττίσετε
	      μόνο τις αλλαγές, αν έχετε την πεποίθηση ότι μπορείτε να
	      εντοπίσετε όλες τις εξαρτήσεις τους.</para>

	    <para>Και φυσικά, όλα αυτά εξαρτώνται από το πόσο συχνά θέλετε να
	      ενημερώνετε το σύστημα σας, και από το αν ακολουθείτε το
	      &os.stable; ή το &os.current;.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Η μεταγλώττιση μου απέτυχε με πλήθος μηνυμάτων signal 11
	      (ή λάθη με άλλα σήματα).  Τι έχει συμβεί;</para>
	  </question>
	  <indexterm><primary>signal 11</primary></indexterm>

	  <answer>
	    <para>Αυτό συνήθως δείχνει προβλήματα υλικού.  Η διαδικασία
	      μεταγλώττισης του βασικού συστήματος είναι ένας αποτελεσματικός
	      τρόπος να δοκιμάσετε το υλικό σας στα όρια του, και συχνά θα
	      δείξει προβλήματα που σχετίζονται με τη μνήμη.  Το πιο σύνηθες
	      σύμπτωμα, είναι η απότομη διακοπή της μεταγλώττισης, με τον
	      μεταγλωττιστή να φαίνεται ότι έχει λάβει κάποιο μυστηριώδες
	      σήμα.</para>

	    <para>Ένα σίγουρο σημάδι για το παραπάνω, είναι να επανεκκινήσετε
	      τη διαδικασία, και αυτή να σταματήσει σε διαφορετικό
	      σημείο.</para>

	    <para>Στην περίπτωση αυτή, δεν υπάρχουν και πολλά που μπορείτε να
	      κάνετε, εκτός από το να αρχίσετε να αλλάζετε εξαρτήματα στο
	      μηχάνημα σας μέχρι να βρείτε αυτό που είναι υπαίτιο.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Μπορώ να διαγράψω το <filename>/usr/obj</filename> όταν
	      τελειώσω;</para>
	  </question>

	  <answer>
	    <para>Η σύντομη απάντηση είναι ναι.</para>

	    <para>Το <filename>/usr/obj</filename> περιέχει όλα τα
	      αντικειμενικά αρχεία που παράγονται κατά τη διάρκεια της
	      μεταγλώττισης.  Συνήθως, ένα από τα πρώτα βήματα στην
	      διαδικασία <command>make buildworld</command> είναι η διαγραφή
	      αυτού του καταλόγου και η αναδημιουργία του.  Στην περίπτωση
	      αυτή, το να κρατήσετε τον κατάλογο
	      <filename>/usr/obj</filename> αφού έχετε τελειώσει, δεν έχει
	      και πολύ νόημα, ενώ αν τον σβήσετε θα κερδίσετε ένα μεγάλο
	      κομμάτι ελεύθερου χώρου (την παρούσα στιγμή περίπου
	      340&nbsp;MB).</para>

	    <para>Όμως, αν ξέρετε τι κάνετε, μπορείτε να οδηγήσετε το
	      <command>make buildworld</command> να παραλείψει αυτό το βήμα.
	      Αυτό θα επιταχύνει ιδιαίτερα τις νέες μεταγλωττίσεις, καθώς
	      τα περισσότερα τμήματα του πηγαίου κώδικα δεν θα χρειάζονται
	      ξανά μεταγλώττιση.  Το μειονέκτημα είναι ότι ορισμένες φορές
	      εμφανίζονται προβλήματα που έχουν σχέση με όχι και τόσο
	      εμφανείς εξαρτήσεις, και μπορεί να οδηγήσουν σε μυστηριώδη
	      αποτυχία της μεταγλώττισης.  Τέτοια προβλήματα συχνά δημιουργούν
	      <quote>θόρυβο</quote> στις λίστες του &os;, όταν κάποιος χρήστης
	      παραπονιέται ότι η μεταγλώττιση του αποτυγχάνει, χωρίς να
	      αντιλαμβάνεται ότι αυτό οφείλεται στην προσπάθεια του να
	      συντομεύσει την διαδικασία.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Μπορώ να συνεχίσω μια μεταγλώττιση που διέκοψα;</para>
	  </question>

	  <answer>
	    <para>Αυτό εξαρτάται από το πόσο έχετε προχωρήσει στη διαδικασία
	      μέχρι τη στιγμή που βρήκατε το πρόβλημα.</para>

	    <para><emphasis>Σε γενικές γραμμές</emphasis> (και αυτός δεν
	      είναι κανόνας που ισχύει πάντα), η διεργασία του
	      <command>make buildworld</command> μεταγλωττίζει νέα αντίγραφα
	      βασικών εργαλείων (όπως τα &man.gcc.1;, και &man.make.1;) καθώς
	      και των βιβλιοθηκών συστήματος.  Έπειτα εγκαθιστώνται αυτά
	      τα εργαλεία και οι βιβλιοθήκες.  Τα νέα εργαλεία και
	      βιβλιοθήκες χρησιμοποιούνται έπειτα για να επαναμεταγλωττίσουν
	      τους εαυτούς τους, και εγκαθίστανται ξανά.  Ολόκληρο το σύστημα
	      (το οποίο τώρα περιλαμβάνει και τα συνηθισμένα προγράμματα
	      χρήστη όπως το &man.ls.1; ή το &man.grep.1;)
	      επαναμεταγλωττίζεται χρησιμοποιώντας τα νέα αρχεία του
	      συστήματος.</para>

	    <para>Αν βρίσκεστε στο τελευταίο στάδιο, το οποίο θα το γνωρίζετε
	      κοιτάζοντας την έξοδο που έχετε αποθηκεύσει, είναι σχετικά
	      ασφαλές να κάνετε:</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Με τον τρόπο αυτό δεν θα αναιρέσετε την εργασία που έχει
	      γίνει από το προηγούμενο
	      <command>make buildworld</command>.</para>

	    <para>Αν δείτε το μήνυμα:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>στην έξοδο της εντολής <command>make buildworld</command>,
	      τότε είναι μάλλον ασφαλές να προχωρήσετε με αυτό τον
	      τρόπο.</para>

	    <para>Αν δεν δείτε αυτό το μήνυμα, ή αν δεν είστε σίγουρος, τότε
	      είναι καλύτερα να κάνετε πλήρη μεταγλώττιση παρά να μετανιώνετε
	      αργότερα.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Πως μπορώ να επιταχύνω τη μεταγλώττιση του βασικού
	      συστήματος;</para>
	  </question>

	  <answer>
	    <itemizedlist>
	      <listitem>
		<para>Εκτελέστε την σε κατάσταση ενός χρήστη.</para>
	      </listitem>

	      <listitem>
		<para>Βάλτε τους καταλόγους <filename>/usr/src</filename>
		  και <filename>/usr/obj</filename> σε διαφορετικά συστήματα
		  αρχείων τα οποία βρίσκονται και σε διαφορετικούς φυσικούς
		  δίσκους.  Αν είναι δυνατόν, βάλτε αυτούς τους δίσκους σε
		  χωριστούς ελεγκτές.</para>
	      </listitem>

	      <listitem>
		<para>Ακόμα καλύτερα, μοιράστε αυτά τα συστήματα αρχείων
		  σε πολλαπλούς δίσκους, χρησιμοποιώντας το πρόγραμμα
		  οδήγησης &man.ccd.4; (concatenated disk driver, οδήγησης
		  συνενωμένων δίσκων).</para>
	      </listitem>

	      <listitem>
		<para>Απενεργοποιήστε το profiling (θέστε την μεταβλητή
		  <quote>NO_PROFILE=true</quote> στο
		  <filename>/etc/make.conf</filename>).  Είναι σχεδόν σίγουρο
		  ότι δεν το χρειάζεστε.</para>
	      </listitem>

	      <listitem>
		<para>Στο αρχείο <filename>/etc/make.conf</filename>, θέστε
		  το <makevar>CFLAGS</makevar> σε κάτι όπως
		  <option>-O -pipe</option>.  Η βελτιστοποίηση
		  <option>-O2</option> χρειάζεται αρκετά περισσότερο χρόνο,
		  και η διαφορά απόδοσης μεταξύ
		  <option>-O</option> και <option>-O2</option> είναι συνήθως
		  αμελητέα.  Το <option>-pipe</option> επιτρέπει στον
		  μεταγλωττιστή να χρησιμοποιήσει pipes για επικοινωνία αντί
		  για προσωρινά αρχεία.  Αυτό καταναλώνει περισσότερη μνήμη,
		  αλλά χρησιμοποιεί λιγότερο το σκληρό δίσκο.</para>
	      </listitem>

	      <listitem>
		<para>Χρησιμοποιήστε την επιλογή
		  <option>-j<replaceable>n</replaceable></option> στο
		  &man.make.1; ώστε να εκτελούνται παράλληλα πολλαπλές
		  διεργασίες μεταγλώττισης.  Αυτό συνήθως βοηθάει ακόμα και
		  σε περίπτωση που έχετε μηχάνημα με ένα επεξεργαστή.</para>
	      </listitem>

	      <listitem>
		<para>Μπορείτε να προσαρτήσετε (ή να επαναπροσαρτήσετε) το
		  σύστημα αρχείων στο οποίο είναι αποθηκευμένο το
		  <filename>/usr/src</filename> με την επιλογή
		  <option>noatime</option>.  Αυτό αποτρέπει την καταγραφή
		  ημερομηνίας / ώρας πρόσβασης στο σύστημα αρχείων.  Κατά πάσα
		  πιθανότητα, δεν χρειάζεστε αυτή την πληροφορία έτσι και
		  αλλιώς.</para>

		  <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		  <warning>
		    <para>Το παράδειγμα προϋποθέτει ότι έχετε το
		      <filename>/usr/src</filename> στο δικό του σύστημα
		      αρχείων.  Αν αυτό δεν συμβαίνει (αν είναι μέρος του
		      <filename>/usr</filename> για παράδειγμα) θα χρειαστεί
		      να χρησιμοποιήσετε αυτό το σημείο προσάρτησης, και όχι
		      το <filename>/usr/src</filename>.</para>
		  </warning>
	      </listitem>

	      <listitem>
		<para>Μπορείτε να προσαρτήσετε (ή να επαναπροσαρτήσετε) το
		  σύστημα αρχείων που περιέχει το
		  <filename>/usr/obj</filename> με την επιλογή
		  <option>async</option>.  Με τον τρόπο αυτό, οι εγγραφές στο
		  δίσκο θα γίνονται ασύγχρονα.  Με άλλα λόγια, οι εγγραφές
		  φαίνεται ότι ολοκληρώνονται άμεσα, ενώ η πραγματική εγγραφή
		  στο δίσκο γίνεται λίγα δευτερόλεπτα αργότερα.  Αυτό
		  επιτρέπει την ομαδοποίηση των εγγραφών, το οποίο μπορεί να
		  προσφέρει δραματική βελτίωση απόδοσης.</para>

		<warning>
		  <para>Να έχετε υπόψιν σας ότι αυτή η επιλογή μπορεί να
		    κάνει το σύστημα αρχείων σας πολύ πιο ευαίσθητο.  Με την
		    επιλογή αυτή, υπάρχει αυξημένη πιθανότητα το σύστημα
		    αρχείων να βρεθεί σε μη
		    επισκευάσιμη κατάσταση αν υπάρξει διακοπή
		    ρεύματος.</para>

		  <para>Αν το σύστημα αρχείων περιέχει μόνο το
		    <filename>/usr/obj</filename>, το παραπάνω δεν είναι
		    πρόβλημα.  Αν ωστόσο έχετε και άλλα πολύτιμα δεδομένα
		    στο ίδιο σύστημα αρχείων, σιγουρευτείτε ότι έχετε
		    ενημερωμένα αντίγραφα ασφαλείας πριν ενεργοποιήσετε αυτή
		    την επιλογή.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Όπως και προηγουμένως, αν το
		    <filename>/usr/obj</filename> δεν είναι σύστημα αρχείων
		    από μόνο του, αντικαταστήστε το στο παράδειγμα με το
		    όνομα του πραγματικού σημείου προσάρτησης.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Τι να κάνω αν κάτι πάει στραβά;</para>
	  </question>

	  <answer>
	    <para>Σιγουρευτείτε ότι το περιβάλλον σας δεν έχει υπολείμματα
	      από προηγούμενες μεταγλωττίσεις.  Αυτό είναι αρκετά απλό.</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Ναι, θα πρέπει να εκτελέσετε το
	      <command>make cleandir</command> δύο φορές.</para>

	    <para>Επανεκκινήστε έπειτα όλη τη διαδικασία, ξεκινώντας με το
	      <command>make buildworld</command>.</para>

	    <para>Αν έχετε ακόμα προβλήματα, στείλτε το μήνυμα λάθους και την
	      έξοδο του <command>uname -a</command> στην &a.questions;.  Να
	      είστε προετοιμασμένοι να απαντήσετε επιπλέον ερωτήσεις σχετικά
	      με την εγκατάσταση σας!</para>
	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Συνεισφορά του </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Διαδικασία για Πολλαπλά Μηχανήματα</title>
    <indexterm>
      <primary>NFS</primary>
      <secondary>installing multiple machines</secondary>
    </indexterm>

    <para>Αν έχετε πολλαπλά μηχανήματα στα οποία πρόκειται να χρησιμοποιήσετε
      το ίδιο δέντρο πηγαίου κώδικα, είναι σπατάλη πόρων (δίσκου, δικτύου και
      επεξεργαστή) να επαναλαμβάνετε σε όλα τη διαδικασία ανάκτησης και
      μεταγλώττισης.  Η λύση είναι να ορίσετε ένα μηχάνημα να εκτελεί το
      μεγαλύτερο μέρος της εργασίας, ενώ τα υπόλοιπα θα μπορούν να την
      ανακτούν μέσω NFS.  Στην ενότητα αυτή θα παρουσιάσουμε ένα τρόπο με
      τον οποίο μπορεί να γίνει αυτό.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Προκαταρκτικά</title>

      <para>Πρώτα από όλα, αναγνωρίστε το σετ των μηχανημάτων στα οποία
	σκοπεύετε να χρησιμοποιήσετε τα ίδια εκτελέσιμα.  Θα ονομάσουμε αυτή
	την ομάδα <emphasis>σετ μεταγλώττισης</emphasis>.  Κάθε μηχάνημα
	μπορεί να έχει δικό του προσαρμοσμένο πυρήνα, αλλά θα έχουν όλα τα
	ίδια εκτελέσιμα userland.  Από το σετ αυτό, επιλέξτε ένα μηχάνημα το
	οποίο θα γίνει το <emphasis>μηχάνημα μεταγλώττισης</emphasis>.
	Θα είναι το μηχάνημα στο οποίο θα μεταγλωττίζεται το βασικό σύστημα
	και ο πυρήνας.  Το ιδανικό είναι να επιλέξετε ένα γρήγορο μηχάνημα,
	στο οποίο να υπάρχει αρκετός ελεύθερος χρόνος στον επεξεργαστή για να
	εκτελεί τα <command>make buildworld</command> και
	<command>make buildkernel</command>.  Θα πρέπει επίσης να επιλέξετε
	ένα <emphasis>μηχάνημα δοκιμών</emphasis> στο οποίο θα δοκιμάζετε τις
	ενημερώσεις λογισμικού πριν τις μεταφέρετε στην παραγωγή.  Μπορεί να
	είναι και το ίδιο το μηχάνημα μεταγλώττισης, αλλά αυτό δεν είναι
	απαραίτητο.</para>

      <para>Όλα τα μηχανήματα στο σετ μεταγλώττισης χρειάζεται να
	προσαρτήσουν το <filename>/usr/obj</filename> και το
	<filename>/usr/src</filename> από το ίδιο μηχάνημα, και στο ίδιο
	σημείο προσάρτησης.  Το ιδανικό είναι αυτά τα δύο συστήματα αρχείων
	να βρίσκονται σε διαφορετικό φυσικό δίσκο στο μηχάνημα μεταγλώττισης,
	αλλά μπορείτε να τα προσαρτήσετε μέσω NFS ακόμα και σε αυτό το
	μηχάνημα.  Αν έχετε πολλαπλά σετ μεταγλώττισης, το
	<filename>/usr/src</filename> θα πρέπει να βρίσκεται σε ένα από τα
	μηχανήματα μεταγλώττισης, και να προσαρτάται στα υπόλοιπα μέσω
	NFS.</para>

      <para>Τέλος, βεβαιωθείτε ότι τα αρχεία
	<filename>/etc/make.conf</filename> και
	<filename>/etc/src.conf</filename> σε όλα τα μηχανήματα του σετ
	μεταγλώττισης, είναι ίδια με τα αντίστοιχα στο μηχάνημα μεταγλώττισης.
	Αυτό σημαίνει ότι το μηχάνημα μεταγλώττισης θα πρέπει να
	μεταγλωττίζει όλα τα τμήματα του βασικού συστήματος τα οποία θα
	εγκατασταθούν σε κάθε μηχάνημα του σετ.  Επίσης, σε κάθε μηχάνημα
	στο σετ μεταγλώττισης θα πρέπει να οριστεί το όνομα του δικού του
	προσαρμοσμένου πυρήνα μέσω της μεταβλητής
	<makevar>KERNCONF</makevar> στο <filename>/etc/make.conf</filename>,
	ενώ και το μηχάνημα μεταγλώττισης θα πρέπει να έχει μια λίστα όλων
	των άλλων στο <makevar>KERNCONF</makevar>, ξεκινώντας από το δικό
	του.  Το μηχάνημα μεταγλώττισης, θα πρέπει να έχει τα αρχεία ρύθμισης
	του πυρήνα όλων των άλλων μηχανημάτων στον κατάλογο
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
	αν πρόκειται να μεταγλωττίζει τους πυρήνες τους.</para>
    </sect2>

    <sect2>
      <title>Το Βασικό Σύστημα</title>

      <para>Έχοντας πραγματοποιήσει όλα τα παραπάνω, είστε έτοιμος να
	μεταγλωττίσετε τα πάντα.  Μεταγλωττίστε τον πυρήνα και το βασικό
	σύστημα όπως περιγράψαμε στο <xref linkend="make-buildworld">
	χρησιμοποιώντας το μηχάνημα μεταγλώττισης, αλλά μην εγκαταστήσετε
	τίποτα.  Μετά το τέλος της μεταγλώττισης, χρησιμοποιήστε το μηχάνημα
	δοκιμών και εγκαταστήστε τον πυρήνα που μόλις δημιουργήσατε.  Αν το
	μηχάνημα αυτό προσαρτά το <filename>/usr/src</filename> και το
	<filename>/usr/obj</filename> μέσω NFS, όταν το επανεκκινήσετε σε
	κατάσταση ενός χρήστη, θα χρειαστεί να ενεργοποιήσετε το δίκτυο και
	να τα προσαρτήσετε.  Ο ευκολότερος τρόπος για αυτό, είναι να
	εκκινήσετε σε κατάσταση πολλαπλών χρηστών και έπειτα να εκτελέσετε
	<command>shutdown now</command> για να μεταβείτε σε κατάσταση ενός
	χρήστη.  Μόλις γίνει αυτό, μπορείτε να εγκαταστήσετε τον νέο πυρήνα
	και το βασικό σύστημα, και να εκτελέσετε το
	<command>mergemaster</command> όπως θα κάνατε συνήθως.  Όταν
	τελειώσετε, επανεκκινήστε αυτό το μηχάνημα στην κανονική λειτουργία
	πολλαπλών χρηστών.</para>

      <para>Όταν βεβαιωθείτε ότι όλα λειτουργούν σωστά στο μηχάνημα δοκιμών,
	χρησιμοποιήστε την ίδια διαδικασία για να εγκαταστήσετε το νέο
	λογισμικό σε κάθε ένα από τα υπόλοιπα μηχανήματα του σετ
	μεταγλώττισης.</para>
    </sect2>

    <sect2>
      <title>Ports</title>

      <para>Μπορείτε να χρησιμοποιήσετε τις ίδιες ιδέες και για το δέντρο
	των ports.  Το πρώτο κρίσιμο βήμα είναι να προσαρτήσετε το
	<filename>/usr/ports</filename> από το ίδιο μηχάνημα, σε όλα τα
	μηχανήματα του σετ μεταγλώττισης.  Μπορείτε έπειτα να ρυθμίσετε το
	<filename>/etc/make.conf</filename> ώστε να διαμοιράζονται τα
	distfiles.  Θα πρέπει να θέσετε το <makevar>DISTDIR</makevar> σε ένα
	κοινόχρηστο κατάλογο, στον οποίο θα δώσετε δικαιώματα εγγραφής σε
	οποιοδήποτε χρήστη έχετε δηλώσει ως <username>root</username> στο
	NFS.  Σε κάθε μηχάνημα θα πρέπει επίσης να οριστεί η μεταβλητή
	<makevar>WRKDIRPREFIX</makevar> ώστε να δείχνει σε ένα τοπικό
	κατάλογο.  Τέλος, αν σκοπεύετε να μεταγλωττίζετε και να διανέμετε
	έτοιμα πακέτα, θα πρέπει να θέσετε την μεταβλητή
	<makevar>PACKAGES</makevar> σε ένα κατάλογο, όπως κάνατε και με την
	<makevar>DISTDIR</makevar>.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     coding: iso-8859-7
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
