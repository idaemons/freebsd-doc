<!--

  Το Εγχειρίδιο του FreeBSD: Ενημέρωση και Αναβάθμιση του FreeBSD

  The FreeBSD Greek Documentation Project

  $FreeBSD$

  %SOURCE%	en_US.ISO8859-1/books/handbook/cutting-edge/chapter.sgml
  %SRCID%	1.235

-->

<chapter id="updating-upgrading">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Αναδομήθηκε, αναδιοργανώθηκε, και τμήματα του ανανεώθηκαν
	  από τον </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>

    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Αρχική συνεισφορά από τους </contrib>
      </author>

      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>

      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>

      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>
    <!-- with feedback from various others -->
  </chapterinfo>

  <title>Ενημέρωση και Αναβάθμιση του &os;</title>

  <sect1 id="updating-upgrading-synopsis">
    <title>Σύνοψη</title>

    <para>Το &os; βρίσκεται υπό συνεχή εξέλιξη μεταξύ των επίσημων εκδόσεων
      του.  Μερικοί άνθρωποι προτιμούν να χρησιμοποιούν τις επίσημες εκδόσεις,
      ενώ άλλοι προτιμούν να κρατούν το σύστημα τους ενημερωμένο με τις
      τελευταίες εξελίξεις.  Ωστόσο, ακόμα και οι επίσημες εκδόσεις
      ενημερώνονται συχνά με διορθώσεις κρίσιμων σφαλμάτων και ασφαλείας.
      Όποια έκδοση και να χρησιμοποιήσετε, το &os; παρέχει όλα τα
      απαραίτητα εργαλεία για να κρατήσετε το σύστημα σας ενημερωμένο, και
      επίσης σας επιτρέπει να αναβαθμιστείτε εύκολα σε κάποια επόμενη
      έκδοση.  Το κεφάλαιο αυτό θα σας βοηθήσει να αποφασίσετε αν θέλετε να
      παρακολουθείτε το σύστημα ανάπτυξης, ή αν θα προτιμήσετε να παραμείνετε
      σε μια από τις παγιωμένες εκδόσεις.  Θα παρουσιάσουμε επίσης τα βασικά
      εργαλεία που απαιτούνται για την ενημέρωση και αναβάθμιση του
      συστήματος.</para>

    <para>Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:</para>

    <itemizedlist>

      <listitem>
	<para>Ποια βοηθητικά προγράμματα μπορείτε να χρησιμοποιήσετε για να
	  ενημερώσετε το σύστημα και την Συλλογή των Ports.</para>
      </listitem>

      <listitem>
	<para>Πως να διατηρείτε το σύστημα σας ενημερωμένο με τα προγράμματα
	  <application>freebsd-update</application>
	  <application>CVSup</application>,
	  <application>CVS</application>, ή
	  <application>CTM</application>.</para>
      </listitem>

      <listitem>
	<para>Πως να συγκρίνετε την κατάσταση ενός εγκατεστημένου συστήματος,
	  με αναφορά ένα γνωστό και εγγυημένα σωστό σύστημα.</para>
      </listitem>

      <listitem>
	<para>Τη διαφορά μεταξύ των δύο κλάδων που βρίσκονται σε εξέλιξη: του
	  &os.stable; και του &os.current;.</para>
      </listitem>

      <listitem>
	<para>Πως να ξαναφτιάξετε και να επανεγκαταστήσετε ολόκληρο
	  το βασικό σύστημα με την <command>make buildworld</command>
	  (κλπ).</para>
      </listitem>
    </itemizedlist>

    <para>Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:</para>

    <itemizedlist>
      <listitem>
	<para>Να ρυθμίσετε σωστά τη σύνδεση σας στο δίκτυο (<xref
	    linkend="advanced-networking">).</para>
      </listitem>

      <listitem>
	<para>Να γνωρίζετε πως να εγκαταστήσετε πρόσθετο λογισμικό
	  τρίτου κατασκευαστή (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Στο κεφάλαιο αυτό γίνεται συχνά χρήση της εντολής
	<command>cvsup</command> για την ανάκτηση ή ενημέρωση των αρχείων
	πηγαίου κώδικα του &os;.  Για να την χρησιμοποιήσετε, θα πρέπει να
	εγκαταστήσετε ένα πακέτο ή port όπως το
	<filename role="package">net/cvsup-without-gui</filename>.
	Αν χρησιμοποιείτε &os;&nbsp;6.2-RELEASE ή νεώτερο, μπορείτε να
	αντικαταστήσετε αυτή την εντολή με την &man.csup.1; η οποία ανήκει
	πλέον στο βασικό σύστημα.</para>
    </note>
  </sect1>

  <sect1 id="updating-upgrading-freebsdupdate">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Γράφηκε από τον </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Colin</firstname>
	  <surname>Percival</surname>
	  <contrib>Βασίστηκε σε σημειώσεις που παρείχε ο </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Ενημερώνοντας το &os;</title>

    <indexterm><primary>Updating and Upgrading FreeBSD</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>Η εφαρμογή ενημερώσεων ασφαλείας αποτελεί ένα σημαντικό τμήμα της
      συντήρησης λογισμικού, ειδικά όταν πρόκειται για το λειτουργικό σύστημα.
      Για μεγάλο διάστημα, η διαδικασία αυτή δεν ήταν εύκολη στο &os;.
      Έπρεπε να εφαρμοστούν patches στον πηγαίο κώδικα, να γίνει μεταγλώττιση
      του από την αρχή, και να εγκατασταθούν ξανά τα νέα εκτελέσιμα.</para>

    <para>Αυτό δεν είναι πλέον αναγκαίο, καθώς το &os; διαθέτει τώρα ένα
      βοηθητικό πρόγραμμα, το <command>freebsd-update</command>.  Το πρόγραμμα
      παρέχει δύο διαφορετικές λειτουργίες.  Η πρώτη είναι η δυνατότητα
      δυαδικής (binary) ενημέρωσης του βασικού συστήματος με τις τελευταίες
      διορθώσεις ασφάλειας και λαθών, χωρίς να χρειάζεται ξανά μεταγλώττιση
      και εγκατάσταση.  Η δεύτερη είναι η δυνατότητα αναβάθμισης του
      συστήματος σε μια νέα μικρή ή μεγάλη επίσημη έκδοση (release).</para>

    <note>
      <para>Δυαδικές διορθώσεις λαθών και ασφάλειας, διατίθενται για όλες
	τις αρχιτεκτονικές και εκδόσεις που υποστηρίζονται από την ομάδα
	ασφάλειας.  Ωστόσο, ορισμένα χαρακτηριστικά όπως η δυνατότητα
	αναβάθμισης του λειτουργικού σε μια νέα έκδοση, απαιτούν την
	τελευταία έκδοση του &man.freebsd-update.8; και του &os;&nbsp;6.3.
	Πριν προχωρήσετε στην αναβάθμιση σε μια νέα έκδοση, θα πρέπει να
	διαβάσετε τις σχετικές με αυτήν ανακοινώσεις, καθώς μπορεί να
	περιέχουν σημαντικές πληροφορίες.  Μπορείτε να δείτε τις
	ανακοινώσεις εκδόσεων στην παρακάτω τοποθεσία:
	<ulink url="http://www.FreeBSD.org/releases/"></ulink>.</para>
    </note>

    <para>Αν υπάρχει κάποιο <command>crontab</command> που χρησιμοποιεί τις
      δυνατότητες του <command>freebsd-update</command>, θα πρέπει να
      απενεργοποιηθεί πριν ξεκινήσει η παρακάτω διαδικασία.  Μπορείτε να
      εγκαταστήσετε την τελευταία έκδοση του
      <command>freebsd-update</command> κατεβάζοντας το συμπιεσμένο πακέτο
      από το παραπάνω <acronym>URL</acronym> και εκτελώντας τις παρακάτω
      εντολές:</para>

    <screen>&prompt.root; <userinput>gunzip -c freebsd-update-upgrade.tgz | tar xvf -</userinput>
&prompt.root; <userinput>mv freebsd-update.sh /usr/sbin/freebsd-update</userinput>
&prompt.root; <userinput>mv freebsd-update.conf /etc</userinput></screen>

    <para>Δεν απαιτείται να κατεβάσετε την τελευταία έκδοση, αν χρησιμοποιείτε
      κάποια από τις τρέχουσες εκδόσεις του &os;.</para>

    <sect2>
      <title>Το Αρχείο Ρυθμίσεων</title>

      <para>Κάποιοι χρήστες ίσως θέλουν να αλλάξουν το αρχείο ρυθμίσεων, ώστε
	να έχουν καλύτερο έλεγχο της διαδικασίας.  Οι επιλογές είναι γενικά
	αρκετά καλά τεκμηριωμένες, αλλά οι παρακάτω ίσως να χρειάζονται
	κάποιες επιπλέον επεξηγήσεις:</para>

      <programlisting># Components of the base system which should be kept updated.
Components src world kernel</programlisting>

      <para>Αυτή η παράμετρος ελέγχει ποια τμήματα του &os; θα διατηρούνται
	ενημερωμένα.  Η προεπιλογή είναι να ενημερώνεται ο πηγαίος κώδικας,
	όλο το βασικό σύστημα, και ο πυρήνας.  Τα τμήματα είναι τα ίδια
	που διατίθενται και κατά την εγκατάσταση, για παράδειγμα αν βάλετε
	την επιλογή <quote>world/games</quote> θα εγκαθίστανται ενημερώσεις
	για τα παιχνίδια.  Αν βάλετε <quote>src/bin</quote> θα επιτρέψετε
	την ενημέρωση του πηγαίου κώδικα του καταλόγου
	<filename class="directory">src/bin</filename>.</para>

      <para>Η καλύτερη επιλογή είναι να αφήσετε εδώ την προεπιλεγμένη τιμή,
	καθώς αν την αλλάξετε ώστε να περιέχει συγκεκριμένα μόνο τμήματα,
	θα αναγκαστείτε να αναφέρετε χωριστά μέσα στο αρχείο ρυθμίσεων κάθε
	τμήμα που θέλετε να ενημερώνεται.  Αυτό ίσως έχει καταστροφικά
	αποτελέσματα, καθώς είναι πιθανό ο πηγαίος κώδικας και τα εκτελέσιμα
	προγράμματα να μην είναι πλέον σε συγχρονισμό μεταξύ τους.</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths</programlisting>

      <para>Προσθέστε διαδρομές σε καταλόγους, όπως
	<filename class="directory">/bin</filename> ή
	<filename class="directory">/sbin</filename> για να αφήσετε
	απείραχτους τους συγκεκριμένους καταλόγους κατά την διαδικασία
	ενημέρωσης.  Η επιλογή αυτή μπορεί να χρησιμοποιηθεί για να αποτρέψει
	το <command>freebsd-update</command> να γράψει πάνω σε πιθανόν
	δικές σας τοπικές αλλαγές.</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Η επιλογή αυτή θα ενημερώσει τα αρχεία ρυθμίσεων στους καταλόγους
	που καθορίζονται, μόνο αν αυτά δεν έχουν μεταβληθεί από το χρήστη.
	Αν υπάρχουν τοπικές αλλαγές, δεν θα γίνει ενημέρωση.  Υπάρχει μια
	ακόμα επιλογή, η <literal>KeepModifiedMetadata</literal>, η οποία
	οδηγεί το <command>freebsd-update</command> να αποθηκεύσει τις αλλαγές
	μεταξύ των δύο εκδόσεων κατά τη διάρκεια της συγχώνευσης
	(merge).</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para>Πρόκειται για τη λίστα των καταλόγων που περιέχουν αρχεία
	ρυθμίσεων, και στα οποία το <command>freebsd-update</command> θα
	επιχειρεί την διαδικασία συγχώνευσης αλλαγών.  Η διαδικασία
	συγχώνευσης γίνεται με μια σειρά από patches τύπου &man.diff.1;
	παρόμοια με το &man.mergemaster.8; αλλά με λιγότερες επιλογές.  Οι
	συγχωνεύσεις είτε γίνονται δεκτές, είτε προκαλούν το άνοιγμα κάποιου
	συντάκτη κειμένου, διαφορετικά η εκτέλεση του
	<command>freebsd-update</command> ακυρώνεται.  Αν δεν είστε
	σίγουρος, κρατήστε αντίγραφο ασφαλείας του καταλόγου
	<filename class="directory">/etc</filename> και απλώς δεχθείτε τις
	αλλαγές.  Δείτε το <xref linkend="mergemaster"> για
	περισσότερες πληροφορίες σχετικά με την εντολή
	<command>mergemaster</command>.</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>Στον κατάλογο αυτό φυλάσσονται όλα τα patches και τα προσωρινά
	αρχεία.  Σε περιπτώσεις όπου ο χρήστης εκτελεί αναβάθμιση σε μια
	νεότερη έκδοση του &os;, θα πρέπει να διαθέτει τουλάχιστον ένα
	gigabyte ελεύθερου χώρου.</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>Αν θέσετε την παραπάνω επιλογή στο <literal>yes</literal>,
	το <command>freebsd-update</command> θα υποθέσει ότι η λίστα
	<literal>Components</literal> είναι πλήρης και δεν θα επιχειρήσει
	να προχωρήσει σε αλλαγές εκτός λίστας.  Ουσιαστικά, το
	<command>freebsd-update</command> θα προσπαθήσει να ενημερώσει κάθε
	αρχείο που ανήκει στη λίστα <literal>Components</literal>.</para>
    </sect2>

    <sect2>
      <title>Patches Σχετικά με την Ασφάλεια</title>

      <para>Τα patches που σχετίζονται με την ασφάλεια, αποθηκεύονται σε
	ένα απομακρυσμένο μηχάνημα και μπορούν να μεταφορτωθούν και να
	εγκατασταθούν με την ακόλουθη εντολή:</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Αν με την παραπάνω εντολή εγκατασταθούν ενημερώσεις στον πυρήνα,
	θα χρειαστεί να επανεκκινήσετε το σύστημα.  Αν όλα πάνε καλά, το
	σύστημα θα είναι πλέον ενημερωμένο και μπορείτε να εκτελείτε το
	<command>freebsd-update</command> αυτόματα με την βοήθεια του
	&man.cron.8;.  Μια απλή καταχώριση στο αρχείο
	<filename>/etc/crontab</filename> είναι επαρκής για αυτό
	το σκοπό:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>Η παραπάνω καταχώριση ορίζει ότι το
	<command>freebsd-update</command> θα εκτελείται μια φορά την ημέρα.
	Με τον τρόπο αυτό, και όταν η εκτέλεση είναι μέσω της επιλογής
	<option>cron</option>, το <command>freebsd-update</command> απλώς
	θα ελέγχει για ενημερώσεις.  Αν υπάρχουν, η εφαρμογή θα τις
	κατεβάζει, αλλά δεν θα τις εγκαθιστά.  Θα στέλνει όμως ένα email
	στο χρήστη <username>root</username> ώστε να τις εγκαταστήσει
	χειροκίνητα.</para>

      <para>Αν οτιδήποτε πάει στραβά, το <command>freebsd-update</command>
	έχει την ικανότητα να επιστρέφει στην προηγούμενη σταθερή κατάσταση,
	αναιρώντας το τελευταίο σετ αλλαγών με την ακόλουθη εντολή:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>Με την ολοκλήρωση της εντολής, θα πρέπει να επανεκκινήσετε το
	σύστημα αν έχουν γίνει αλλαγές στον πυρήνα ή σε κάποιο από τα
	αρθρώματα του.  Αυτό θα επιτρέψει στο &os; να φορτώσει τα νέα
	εκτελέσιμα στη μνήμη.</para>

      <para>Το βοηθητικό πρόγραμμα <command>freebsd-update</command> μπορεί
	να ενημερώσει αυτόματα μόνο τον πυρήνα <literal>GENERIC</literal>.
	Αν χρησιμοποιείται προσαρμοσμένος πυρήνας, θα πρέπει να
	μεταγλωττιστεί ξανά, όταν το <command>freebsd-update</command>
	τελειώσει με την εγκατάσταση των υπόλοιπων ενημερώσεων.  Ωστόσο, το
	<command>freebsd-update</command> θα ανιχνεύσει και θα ενημερώσει
	τον πυρήνα <literal>GENERIC</literal> στο <filename
	  class="directory">/boot/GENERIC</filename> (αν υπάρχει), ακόμα
	και αν δεν είναι ο ενεργός πυρήνας του συστήματος (αυτός που
	εκτελείται τη συγκεκριμένη στιγμή).</para>

      <note>
	<para>Είναι γενικά καλή ιδέα να έχετε πάντα ένα αντίγραφο του
	  πυρήνα <literal>GENERIC</literal> στον κατάλογο <filename
	    class="directory">/boot/GENERIC</filename>.  Θα σας βοηθήσει στην
	  διάγνωση διάφορων προβλημάτων, καθώς και στην αναβάθμιση σε επόμενες
	  εκδόσεις του &os;, μέσω του <command>freebsd-update</command>.
	  Η διαδικασία αυτή περιγράφεται στο
	  <xref linkend="freebsdupdate-upgrade">.</para>
      </note>

      <para>Αν δεν έχουν γίνει αλλαγές στις προεπιλεγμένες ρυθμίσεις στο
	αρχείο <filename>/etc/freebsd-update.conf</filename>, το
	<command>freebsd-update</command> θα εγκαταστήσει τα ανανεωμένα αρχεία
	πηγαίου κώδικα μαζί με τις υπόλοιπες ενημερώσεις.  Μπορείτε έπειτα να
	προχωρήσετε στη μεταγλώττιση και εγκατάσταση νέου προσαρμοσμένου
	πυρήνα, με το συνήθη τρόπο.</para>

      <note>
	<para>Οι ενημερώσεις που διανέμονται μέσω του
	  <command>freebsd-update</command> δεν περιλαμβάνουν πάντοτε αλλαγές
	  στον πυρήνα.  Δεν είναι απαραίτητο να επαναμεταγλωττίσετε τον
	  προσαρμοσμένο πυρήνα σας, αν η εκτέλεση του
	  <command>freebsd-update install</command> δεν επέφερε αλλαγές στα
	  αρχεία πηγαίου κώδικα του πυρήνα.  Ωστόσο, το
	  <command>freebsd-update</command> ενημερώνει πάντοτε το αρχείο
	  <filename>/usr/src/sys/conf/newvers.sh</filename>.  Το αρχείο αυτό
	  περιέχει το τρέχον επίπεδο ενημερώσεων (patch level) το οποίο και
	  αναφέρεται ως αριθμός <literal>-p</literal> από εντολές όπως η
	  <command>uname -r</command>.  Μεταγλωττίζοντας ξανά τον
	  προσαρμοσμένο πυρήνα σας (ακόμα και αν δεν υπάρχουν άλλες αλλαγές)
	  θα δώσετε τη δυνατότητα στην &man.uname.1; να αναφέρει με ακρίβεια
	  το επίπεδο ενημερώσεων.  Αυτό μπορεί να είναι ιδιαίτερα χρήσιμο
	  όταν συντηρείτε πολλαπλά συστήματα, καθώς σας επιτρέπει να
	  αξιολογήσετε με μια ματιά τι ενημερώσεις έχουν εγκατασταθεί στο
	  καθένα.</para>
      </note>
    </sect2>

    <sect2 id="freebsdupdate-upgrade">
      <title>Αναβαθμίσεις σε Μικρές και Μεγάλες Εκδόσεις</title>

      <para>Η διαδικασία αυτή θα απομακρύνει τα παλιά αρχεία αντικειμενικού
	κώδικα (object files) καθώς και τις παλιές βιβλιοθήκες, κάνοντας
	τις περισσότερες εφαρμογές τρίτων κατασκευαστών να μη λειτουργούν.
	Σας συνιστούμε είτε να απεγκαταστήσετε όλα τα εγκατεστημένα ports και
	να τα εγκαταστήσετε ξανά, ή να τα αναβαθμίσετε αργότερα,
	χρησιμοποιώντας το βοηθητικό πρόγραμμα
	<filename role="package">ports-mgmt/portupgrade</filename>.
	Οι περισσότεροι χρήστες θα θέλουν να κάνουν μια δοκιμαστική
	μεταγλώττιση χρησιμοποιώντας την ακόλουθη εντολή:</para>

      <screen>&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Με αυτό τον τρόπο εξασφαλίζεται ότι τα πάντα θα επανεγκατασταθούν
	σωστά.  Σημειώστε ότι αν θέσετε την μεταβλητή περιβάλλοντος
	<makevar>BATCH</makevar> στην τιμή <literal>yes</literal>, όλες οι
	πιθανές ερωτήσεις που θα εμφανιστούν κατά τη διαδικασία, θα
	απαντηθούν αυτόματα με <literal>yes</literal>.  Έτσι δεν υπάρχει πλέον
	ανάγκη για παρέμβαση του χρήστη κατά τη διάρκεια της διαδικασίας
	μεταγλώττισης.</para>

      <para>Αν χρησιμοποιείται προσαρμοσμένος πυρήνας, η διαδικασία
	αναβάθμισης είναι ελαφρά πιο πολύπλοκη.  Θα χρειαστείτε ένα αντίγραφο
	του πυρήνα <literal>GENERIC</literal> στον κατάλογο <filename
	  class="directory">/boot/GENERIC</filename>.  Αν δεν υπάρχει ήδη ο
	πυρήνας <literal>GENERIC</literal> στο σύστημα σας, μπορείτε να τον
	ανακτήσετε χρησιμοποιώντας μια από τις παρακάτω μεθόδους:</para>

      <itemizedlist>
	<listitem>
	  <para>Αν έχετε μεταγλωττίσει προσαρμοσμένο πυρήνα μόνο μια φορά, ο
	    πυρήνας στον κατάλογο <filename
	      class="directory">/boot/kernel.old</filename> είναι στην
	    πραγματικότητα ο <literal>GENERIC</literal>.  Απλώς μετονομάστε
	    τον κατάλογο σε <filename
	      class="directory">/boot/GENERIC</filename>.</para>
	</listitem>

	<listitem>
	  <para>Αν έχετε φυσική πρόσβαση στο μηχάνημα, μπορείτε να
	    εγκαταστήσετε ένα αντίγραφο του πυρήνα <literal>GENERIC</literal>
	    από το CD-ROM της εγκατάστασης.  Τοποθετήστε το CD-ROM στον οδηγό
	    και χρησιμοποιήστε τις παρακάτω εντολές:</para>

	  <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/<replaceable>X.Y-RELEASE</replaceable>/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

	  <para>Αντικαταστήστε το <filename
	      class="directory"><replaceable>X.Y-RELEASE</replaceable></filename>
	    με τους πραγματικούς αριθμούς της έκδοσης που χρησιμοποιείτε.
	    Ο πυρήνας <literal>GENERIC</literal> θα εγκατασταθεί από
	    προεπιλογή στον κατάλογο <filename
	      class="directory">/boot/GENERIC</filename>.</para>
	</listitem>

	<listitem>
	  <para>Αν δεν έχετε κάποια από τις παραπάνω επιλογές, μπορείτε να
	    μεταγλωττίσετε και να εγκαταστήσετε τον πυρήνα
	    <literal>GENERIC</literal> μέσω του πηγαίου κώδικα:</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

	  <para>Για να αναγνωριστεί αυτός ο πυρήνας ως
	    <literal>GENERIC</literal> από το
	    <command>freebsd-update</command>, δεν θα πρέπει να έχουν γίνει
	    αλλαγές στο αρχείο ρυθμίσεων του <literal>GENERIC</literal>.
	    Συνίσταται επίσης η μεταγλώττιση να γίνει χωρίς άλλες
	    εξειδικευμένες ρυθμίσεις (κατά προτίμηση με κενό το
	    <filename>/etc/make.conf</filename>).</para>
	</listitem>
      </itemizedlist>

      <para>Δεν χρειάζεται τη δεδομένη στιγμή να επανεκκινήσετε με τον πυρήνα
	<literal>GENERIC</literal>.</para>

      <para>Είναι δυνατές οι αναβαθμίσεις τόσο σε μικρές όσο και σε μεγάλες
	εκδόσεις, δίνοντας στην εντολή <command>freebsd-update</command> τον
	επιθυμητό αριθμό έκδοσης.  Για παράδειγμα, η ακόλουθη εντολή θα
	αναβαθμίσει το σύστημα σε &os;&nbsp;6.4:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 6.4-RELEASE upgrade</userinput></screen>

      <para>Μετά τη λήψη της εντολής, το
	<command>freebsd-update</command> θα αξιολογήσει την κατάσταση του
	συστήματος και του αρχείου ρυθμίσεων του, σε μια απόπειρα να μαζέψει
	τις απαραίτητες πληροφορίες για την αναβάθμιση του συστήματος.
	Οι πληροφορίες που ανιχνεύθηκαν θα εμφανιστούν στην οθόνη με τη μορφή
	μιας λίστας εγκατεστημένων προγραμμάτων.  Για παράδειγμα:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 6.3-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

      <para>Στο σημείο αυτό, το <command>freebsd-update</command> θα
	κατεβάσει όλα τα αρχεία που απαιτούνται για την αναβάθμιση.  Σε
	μερικές περιπτώσεις, ο χρήστης θα κληθεί να απαντήσει σε ερωτήσεις
	σχετικά με το τι θα εγκατασταθεί ή πως πρέπει να προχωρήσει η
	διαδικασία.</para>

      <para>Όταν χρησιμοποιείται προσαρμοσμένος πυρήνας, το παραπάνω βήμα
	θα προκαλέσει την εμφάνιση της παρακάτω προειδοποίησης:</para>

      <screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 6.3-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>Μπορείτε να αγνοήσετε αυτή την προειδοποίηση.  Θα χρησιμοποιήσουμε
	τον ενημερωμένο πυρήνα <literal>GENERIC</literal> ως ενδιάμεσο βήμα
	στη διαδικασία αναβάθμισης.</para>

      <para>Αφού μεταφορτωθούν όλα τα patches στο τοπικό σύστημα, θα γίνει
	και η εφαρμογή τους.  Η διαδικασία αυτή ίσως πάρει λίγο χρόνο,
	ανάλογα με την ταχύτητα και το φορτίο του μηχανήματος.  Έπειτα θα
	γίνει η συγχώνευση των αρχείων ρυθμίσεων.  Αυτό το μέρος της
	διαδικασίας απαιτεί παρέμβαση του χρήστη, καθώς σε κάποια αρχεία θα
	χρειαστεί η συγχώνευση να γίνει χειροκίνητα με τη βοήθεια κάποιου
	συντάκτη κειμένου.  Ο χρήστης θα ενημερώνεται για το αποτέλεσμα κάθε
	επιτυχημένης συγχώνευσης καθώς εξελίσσεται η διαδικασία.  Σε
	περίπτωση αποτυχημένης συγχώνευσης (ή αγνόησης της), η διαδικασία
	αναβάθμισης θα διακοπεί.  Ενδεχομένως να θέλετε να κρατήσετε αντίγραφο
	ασφαλείας του καταλόγου <filename class="directory">/etc</filename>
	και να συγχωνεύσετε αργότερα (χειροκίνητα) κάποια σημαντικά αρχεία,
	όπως το <filename>master.passwd</filename> ή το
	<filename>group</filename>.</para>

      <note>
	<para>Στο σημείο αυτό δεν έχει γίνει ακόμα καμιά αλλαγή στο σύστημα,
	  καθώς όλη η διαδικασία της αναβάθμισης και συγχώνευσης γίνεται σε
	  διαφορετικό κατάλογο.  Όταν εφαρμοστούν επιτυχώς όλα τα patches
	  και ολοκληρωθεί με επιτυχία η διαδικασία της συγχώνευσης όλων των
	  αρχείων ρύθμισης, ο χρήστης θα πρέπει να επιβεβαιώσει την τελική
	  εγκατάσταση.</para>
      </note>

      <para>Με το τέλος αυτής τη διαδικασίας, η αναβάθμιση μπορεί να
	οριστικοποιηθεί στο δίσκο, με τη χρήση της ακόλουθης εντολής:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Στην πρώτη φάση, θα αλλαχθεί ο πυρήνας και τα σχετικά αρθρώματα.
	Στο σημείο αυτό, θα πρέπει να γίνει επανεκκίνηση του μηχανήματος.
	Σε μηχάνημα με προσαρμοσμένο πυρήνα, χρησιμοποιήστε την εντολή
	&man.nextboot.8; ώστε να θέσετε τον πυρήνα για την επόμενη εκκίνηση
	στον <filename class="directory">/boot/GENERIC</filename> (ο οποίος
	έχει ήδη αναβαθμιστεί):</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
	<para>Πριν επανεκκινήσετε με τον πυρήνα <literal>GENERIC</literal>,
	  βεβαιωθείτε ότι περιέχει όλα τα προγράμματα οδήγησης που απαιτούνται
	  για την επιτυχή εκκίνηση του συστήματος σας (και τη λειτουργία του
	  δικτύου, αν αναβαθμίζετε κάποιο απομακρυσμένο μηχάνημα).
	  Ειδικότερα, αν ο προηγούμενος προσαρμοσμένος πυρήνας περιείχε
	  λειτουργίες που συνήθως παρέχονται από αρθρώματα (modules),
	  βεβαιωθείτε ότι φροντίσατε να φορτωθούν προσωρινά στον πυρήνα
	  <literal>GENERIC</literal> χρησιμοποιώντας τις δυνατότητες του
	  αρχείου <filename>/boot/loader.conf</filename>.  Ίσως επίσης να
	  θέλετε να απενεργοποιήσετε υπηρεσίες, προσαρτήσεις δίσκων και
	  δικτύου κ.λ.π. που δεν είναι απαραίτητες, μέχρι την ολοκλήρωση της
	  διαδικασίας αναβάθμισης.</para>
      </warning>

      <para>Μπορείτε να χρησιμοποιήσετε την ακόλουθη εντολή για να
	επανεκκινήσετε το μηχάνημα με τον νέο πυρήνα:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>Μόλις το σύστημα επανέλθει σε λειτουργία, θα πρέπει να εκτελέσετε
	ξανά το <command>freebsd-update</command>.  Η προηγούμενη λειτουργία
	έχει αποθηκευθεί, και έτσι το <command>freebsd-update</command> δεν θα
	ξεκινήσει από την αρχή, αλλά θα απομακρύνει όλες τις παλιές
	κοινόχρηστες βιβλιοθήκες και τα αρχεία αντικειμενικού κώδικα.  Για να
	συνεχίσετε σε αυτό το στάδιο, δώστε την ακόλουθη εντολή:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>Ανάλογα με το αν υπήρξαν αλλαγές στους αριθμούς εκδόσεων των
	  βιβλιοθηκών, ίσως να υπάρχουν μόνο δύο φάσεις εγκατάστασης αντί για
	  τρεις.</para>
      </note>

      <para>Όλο το λογισμικό τρίτου κατασκευαστή θα πρέπει τώρα να
	μεταγλωττιστεί και να επανεγκατασταθεί από την αρχή.  Αυτό απαιτείται
	καθώς το εγκατεστημένο λογισμικό ίσως εξαρτάται από βιβλιοθήκες οι
	οποίες αφαιρέθηκαν κατά τη διαδικασία της αναβάθμισης.  Μπορείτε να
	χρησιμοποιήσετε την εντολή
	<filename role="package">ports-mgmt/portupgrade</filename>
	για να αυτοματοποιήσετε αυτή τη διαδικασία.  Για να ξεκινήσετε, δώστε
	τις παρακάτω εντολές:</para>

      <screen>&prompt.root; <userinput>portupgrade -f ruby</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db</userinput>
&prompt.root; <userinput>portupgrade -f ruby18-bdb</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db</userinput>
&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Μόλις ολοκληρωθεί το παραπάνω, ολοκληρώστε τη διαδικασία
	αναβάθμισης με μια τελευταία κλήση της εντολής
	<command>freebsd-update</command>.  Δώστε την παρακάτω εντολή για να
	ολοκληρώσετε οτιδήποτε έχει απομείνει στη διαδικασία
	αναβάθμισης:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Αν χρησιμοποιούσατε προσωρινά τον πυρήνα
	<literal>GENERIC</literal>,  αυτή είναι η κατάλληλη στιγμή για να
	μεταγλωττίσετε και να εγκαταστήσετε νέο προσαρμοσμένο πυρήνα, με το
	συνήθη τρόπο.</para>

      <para>Επανεκκινήστε το μηχάνημα σας στην νέα έκδοση του &os;.
	Η διαδικασία έχει ολοκληρωθεί.</para>
    </sect2>

    <sect2>
      <title>Σύγκριση Κατάστασης του Συστήματος</title>

      <para>Το βοηθητικό πρόγραμμα <command>freebsd-update</command> μπορεί να
	χρησιμοποιηθεί για να ελέγξετε την κατάσταση της εγκατεστημένης
	έκδοσης του &os; σε σχέση με μια γνωστή και σωστή εγκατάσταση.
	Η επιλογή αυτή συγκρίνει και αξιολογεί την τρέχουσα έκδοση των
	προγραμμάτων συστήματος, των βιβλιοθηκών και των αρχείων ρύθμισης.
	Για να ξεκινήσετε τη σύγκριση, δώστε την ακόλουθη εντολή:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <warning>
	<para>Αν και το όνομα της εντολής είναι <acronym>IDS</acronym>, δεν
	  θα πρέπει σε καμιά περίπτωση να θεωρηθεί υποκατάστατο ενός
	  συστήματος ανίχνευσης εισβολέα (intrusion detection system) όπως
	  είναι για παράδειγμα το
	  <filename role="package">security/snort</filename>.
	  Καθώς το <command>freebsd-update</command> αποθηκεύει τα δεδομένα
	  του στο δίσκο, υπάρχει πάντα η πιθανότητα να έχει γίνει αλλοίωση
	  τους.  Αν και η πιθανότητα αυτή μπορεί να μειωθεί χρησιμοποιώντας
	  τη ρύθμιση <varname>kern.securelevel</varname> και αποθηκεύοντας
	  τα δεδομένα της εντολής <command>freebsd-update</command> σε ένα
	  σύστημα αρχείων μόνο για ανάγνωση, μια ακόμα καλύτερη λύση θα ήταν
	  να συγκρίνετε το σύστημα με κάποιο δίσκο που θεωρείτε σίγουρα
	  ασφαλή.  Μπορείτε να χρησιμοποιήσετε ένα δίσκο
	  <acronym>DVD</acronym> ή ένα εξωτερικό δίσκο <acronym>USB</acronym>
	  που φυλάσσετε σε ασφαλή τοποθεσία.</para>
      </warning>

      <para>Θα γίνει τώρα μια επιθεώρηση του συστήματος και θα εκτυπωθεί
	μια λίστα από αρχεία και τιμές hash του τύπου &man.sha256.1;,
	τόσο για το εγκατεστημένο όσο και για το γνωστό σύστημα.  Επειδή
	πρόκειται για μεγάλη λίστα, την ανακατευθύνουμε στο αρχείο
	<filename>outfile.ids</filename>.  Στην οθόνη το κείμενο θα κυλούσε
	πολύ γρήγορα, και σύντομα θα γέμιζε την προσωρινή μνήμη απεικόνισης
	της κονσόλας.</para>

      <para>Οι γραμμές αυτές έχουν γενικά μεγάλο μήκος, αλλά είναι εύκολο
	να επεξεργαστούμε την έξοδο.  Για παράδειγμα, για να δείτε μια λίστα
	όλων των αρχείων που διαφέρουν από αυτά της επίσημης έκδοσης, δώστε
	την ακόλουθη εντολή:</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>Τα παραπάνω είναι μόνο ένα μέρος της εξόδου, υπάρχουν ακόμα
	πολλά διαφορετικά αρχεία.  Κάποια από αυτά τα αρχεία είναι φυσιολογικό
	να έχουν τροποποιηθεί.  Για παράδειγμα, το
	<filename>/etc/passwd</filename> έχει τροποποιηθεί, καθώς έχουν
	προστεθεί χρήστες στο σύστημα.  Σε μερικές περιπτώσεις, μπορεί να
	υπάρχουν και άλλα αρχεία, όπως π.χ. αρθρώματα πυρήνα τα οποία
	διαφέρουν αφού έχουν ενημερωθεί μέσω της
	<command>freebsd-update</command>.  Για να εξαιρέσετε συγκεκριμένα
	αρχεία ή καταλόγους, προσθέστε τα στην επιλογή
	<literal>IDSIgnorePaths</literal> στο αρχείο ρυθμίσεων
	<filename>/etc/freebsd-update.conf</filename>.</para>

      <para>Εκτός από την χρήση που αναφέραμε προηγουμένως, το σύστημα αυτό
	μπορεί να χρησιμοποιηθεί και ως τμήμα μιας λεπτομερούς διαδικασίας
	αναβάθμισης.</para>
    </sect2>
  </sect1>

  <sect1 id="updating-upgrading-portsnap">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Γράφηκε από τον </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Colin</firstname>
	  <surname>Percival</surname>
	  <contrib>Βασισμένο σε σημειώσεις που παρείχε ο </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Portsnap: Ένα Εργαλείο Ενημέρωσης της Συλλογής των Ports</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Το βασικό σύστημα του &os; περιλαμβάνει επίσης ένα βοηθητικό
      πρόγραμμα για την ενημέρωση της Συλλογής των Ports.  Πρόκειται για το
      &man.portsnap.8;.  Όταν το εκτελέσετε, θα συνδεθεί σε ένα απομακρυσμένο
      διακομιστή, θα επαληθεύσει το κλειδί του πηγαίου κώδικα, και θα
      κατεβάσει ένα νέο αντίγραφο της Συλλογής των Ports.  Το κλειδί
      χρησιμοποιείται για να επαληθεύσει την ακεραιότητα όλων των αρχείων
      που μεταφορτώνονται, εξασφαλίζοντας ότι δεν έχουν αλλοιωθεί κατά
      την μεταφορά.  Για να κατεβάσετε τα τελευταία αρχεία της Συλλογής των
      Ports, εκτελέστε την ακόλουθη εντολή:</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 3 mirrors found.
Fetching snapshot tag from portsnap1.FreeBSD.org... done.
Fetching snapshot metadata... done.
Updating from Wed Aug  6 18:00:22 EDT 2008 to Sat Aug 30 20:24:11 EDT 2008.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>Το παραπάνω παράδειγμα δείχνει ότι το &man.portsnap.8;
      βρήκε και επαλήθευσε αρκετά patches τα οποία πρέπει να εφαρμοστούν
      στο υπάρχον δέντρο των ports.  Αυτό δείχνει επίσης ότι το πρόγραμμα
      έχει εκτελεστεί κατά το παρελθόν.  Αν αυτή ήταν η πρώτη φορά που
      εκτελούνταν, θα γίνονταν απλώς κατέβασμα της συλλογής.</para>

    <para>Όταν το &man.portsnap.8; εκτελέσει επιτυχώς της λειτουργία
      <command>fetch</command>, η Συλλογή των Ports και τα
      αντίστοιχα patches έχουν αποθηκευθεί στο τοπικό σύστημα και έχει γίνει
      η επαλήθευση τους.  Τα ενημερωμένα αρχεία μπορούν να εγκατασταθούν
      γράφοντας:</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>Η διαδικασία έχει πλέον ολοκληρωθεί, και μπορείτε να εγκαταστήσετε
      ή να αναβαθμίσετε εφαρμογές χρησιμοποιώντας την ενημερωμένη Συλλογή των
      Ports.</para>
  </sect1>

  <sect1 id="current-stable">
    <title>Παρακολούθηση Ενός Κλάδου Ανάπτυξης</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Υπάρχουν δύο κλάδοι ανάπτυξης στο &os;, το &os.current; και το
      &os.stable;.  Στην ενότητα αυτή, θα εξηγήσουμε κάποια πράγματα σχετικά
      με αυτούς τους κλάδους, και θα περιγράψουμε πως μπορείτε να διατηρήσετε
      το σύστημα σας ενημερωμένο σε κάποιον από αυτούς.  Θα μιλήσουμε αρχικά
      για το &os.current; και έπειτα για το &os.stable;.</para>

    <sect2 id="current">
      <title>Παρακολουθώντας το &os.current;</title>

      <para>Καθώς διαβάζετε αυτό το κείμενο, να έχετε υπόψιν σας ότι το
	&os.current; είναι πράγματι η <quote>κόψη του ξυραφιού</quote> στην
	ανάπτυξη του &os;.  Οι χρήστες του &os.current; αναμένεται να έχουν
	αυξημένες τεχνικές γνώσεις, και να είναι ικανοί να επιλύουν δύσκολα
	προβλήματα του συστήματος τους, χωρίς βοήθεια.  Αν είστε καινούριος
	στο &os;, μάλλον θα πρέπει να το ξανασκεφτείτε πριν το
	εγκαταστήσετε.</para>

      <sect3>
	<title>Τι Είναι το &os.current;;</title>
	<indexterm><primary>snapshot</primary></indexterm>

	<para>Το &os.current; αποτελείται από τον πλέον πρόσφατο λειτουργικό
	  πηγαίο κώδικα του &os;.  Περιλαμβάνει αλλαγές που βρίσκονται σε
	  εξέλιξη, πειραματικές αλλαγές, και μηχανισμούς μετάβασης οι οποίοι
	  δεν είναι σίγουρο ότι θα περιλαμβάνονται στην επόμενη επίσημη
	  έκδοση του λογισμικού.  Αν και πολλά μέλη της ομάδας ανάπτυξης του
	  &os; μεταγλωττίζουν καθημερινά τον πηγαίο κώδικα του &os.current;,
	  υπάρχουν χρονικές περίοδοι που η μεταγλώττιση του είναι αδύνατη.
	  Τα προβλήματα αυτά γενικά επιλύονται όσο πιο γρήγορα γίνεται, αλλά
	  το αν το &os.current; θα σας φέρει την καταστροφή ή κάποιο
	  πολυπόθητο χαρακτηριστικό, είναι περισσότερο θέμα της χρονικής
	  στιγμής που θα επιλέξετε να ανακτήσετε τον πηγαίο κώδικα!</para>
      </sect3>

      <sect3>
	<title>Ποιος Χρειάζεται το &os.current;;</title>

	<para>Το &os.current; διατίθεται και ενδιαφέρει κυρίως τις παρακάτω
	  τρεις ομάδες:</para>

	<orderedlist>
	  <listitem>
	    <para>Μέλη της κοινότητας του &os; που δουλεύουν ενεργά σε κάποιο
	      τμήμα του πηγαίου κώδικα, και για τους οποίους η παρακολούθηση
	      του &os.current; είναι απόλυτα απαραίτητη.</para>
	  </listitem>

	  <listitem>
	    <para>Μέλη της κοινότητας του &os; που είναι ενεργοί testers
	      και είναι πρόθυμοι να αναλώσουν το χρόνο τους για να λύσουν
	      προβλήματα, ώστε να εξασφαλίσουν ότι το &os.current;
	      θα παραμείνει όσο το δυνατόν πιο σωστό.  Συνήθως, τα μέλη αυτά
	      κάνουν προτάσεις για τοπικές αλλαγές και για την γενική
	      κατεύθυνση του &os;, και στέλνουν patches για την
	      πραγματοποίηση τους.</para>
	  </listitem>

	  <listitem>
	    <para>Αυτοί που απλώς θέλουν να βλέπουν τις τελευταίες
	      ενημερώσεις, ή να χρησιμοποιούν τον τελευταίο πηγαίο κώδικα ως
	      αναφορά (π.χ. για <emphasis>μελέτη</emphasis> και όχι για
	      εκτέλεση).  Μέλη αυτής της ομάδας μπορεί επίσης περιστασιακά να
	      συνεισφέρουν σχόλια ή κώδικα.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Τι <emphasis>Δεν</emphasis> Είναι το &os.current;;</title>

	<orderedlist>
	  <listitem>
	    <para>Δεν είναι ένας γρήγορος τρόπος να πάρετε κώδικα ο
	      οποίος δεν έχει κυκλοφορήσει ακόμα σε κάποια έκδοση, με την
	      ελπίδα ότι περιέχει κάποια νέα εκπληκτική δυνατότητα και
	      θέλετε να είστε ο πρώτος που τη χρησιμοποιεί.  Αν είστε
	      πράγματι ο πρώτος που την χρησιμοποιεί, θα είστε επίσης και ο
	      πρώτος που θα συναντήσετε τα νέα προβλήματα και bugs.</para>
	  </listitem>

	  <listitem>
	    <para>Δεν είναι ένας γρήγορος τρόπος για να ανακτήσετε
	      διορθώσεις προβλημάτων.  Κάθε νέα έκδοση του &os.current;
	      μπορεί να εισάγει τόσα νέα bugs όσα και αυτά που
	      διορθώνει.</para>
	  </listitem>

	  <listitem>
	    <para>Το &os.current; δεν αποτελεί
	      <quote>επίσημα υποστηριζόμενο</quote> κώδικα.  Αν και
	      καταβάλλουμε κάθε δυνατή προσπάθεια να βοηθήσουμε όσους
	      ανήκουν <quote>πραγματικά</quote> σε κάποια από τις τρεις
	      ομάδες που αναφέραμε, ωστόσο <emphasis>δεν έχουμε το
	      χρόνο</emphasis> να παρέχουμε τεχνική υποστήριξη.  Αυτό δεν
	      συμβαίνει επειδή είμαστε κακοήθεις και δύσκολοι και δεν θέλουμε
	      να βοηθάμε τους ανθρώπους (δεν θα είχαμε καν δημιουργήσει το
	      &os; αν σκεφτόμασταν έτσι).  Πολύ απλά, δεν μπορούμε να
	      απαντάμε εκατοντάδες μηνύματα την ημέρα και
	      <emphasis>ταυτόχρονα</emphasis> να δουλεύουμε στο &os;! Αν
	      δώσετε σε οποιοδήποτε μέλος της ομάδας ανάπτυξης την επιλογή
	      να απαντάει σε πολλές ερωτήσεις σχετικά με πειραματικό κώδικα
	      ή να δουλεύει για τη βελτίωση του &os;, θα επιλέξει σίγουρα το
	      δεύτερο.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Χρησιμοποιώντας το &os.current;</title>

	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>using</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Γραφτείτε στις λίστες &a.current.name; και
	      &a.svn-src-head.name;.  Δεν είναι απλώς καλή ιδέα, είναι
	      <emphasis>βασικό</emphasis> να το κάνετε.  Αν δεν είστε
	      γραμμένος στη λίστα <emphasis>&a.current.name;</emphasis>, δεν
	      θα βλέπετε τα σχόλια σχετικά με την τρέχουσα κατάσταση του
	      συστήματος από όσους το χρησιμοποιούν, και έτσι πιθανώς θα
	      καταλήξετε να αντιμετωπίζετε πολλά προβλήματα που άλλοι έχουν
	      ήδη ανακαλύψει και λύσει.  Ακόμα πιο σημαντικό είναι ότι θα
	      χάνετε σημαντικές ανακοινώσεις, οι οποίες μπορεί να είναι
	      κρίσιμες για την διατήρηση του συστήματος σας σε υγιή
	      κατάσταση.</para>

	    <para>Η λίστα &a.svn-src-head.name; θα σας επιτρέψει να βλέπετε
	      τις καταχωρήσεις στο commit log για κάθε αλλαγή που γίνεται,
	      καθώς και πληροφορίες για πιθανές παρενέργειες που μπορεί να
	      έχει.</para>

	    <para>Για να γραφτείτε σε αυτές, ή σε οποιεσδήποτε από τις
	      υπάρχουσες λίστες, επισκεφθείτε την τοποθεσία
	      &a.mailman.lists.link; και επιλέξτε τη λίστα στην οποία θέλετε
	      να γίνετε συνδρομητής.  Οδηγίες για την υπόλοιπη διαδικασία
	      θα βρείτε επιτόπου.  Αν σας ενδιαφέρει να παρακολουθείτε τις
	      αλλαγές σε όλο το δέντρο πηγαίου κώδικα, σας συνιστούμε να
	      εγγραφείτε στη λίστα &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>Ανακτήστε τον πηγαίο κώδικα από ένα
	      <link linkend="mirrors">mirror site</link> του &os;.  Αυτό
	      μπορεί να γίνει με δύο τρόπους:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
		<primary>-CURRENT</primary>
		<secondary>Syncing with <application>CVSup</application></secondary>
	      </indexterm>

	      <listitem>
		<para>Χρησιμοποιήστε το πρόγραμμα <link
		    linkend="cvsup">cvsup</link> σε συνδυασμό με το
		  <filename>supfile</filename> με την ονομασία
		  <filename>standard-supfile</filename> το οποίο θα βρείτε
		  στον κατάλογο
		  <filename>/usr/share/examples/cvsup</filename>.
		  Αυτή είναι και η πλέον συνιστώμενη μέθοδος, καθώς σας
		  επιτρέπει να ανακτήσετε όλη τη συλλογή με μια κίνηση, και
		  στις επόμενες ανανεώσεις θα παίρνετε μόνο τις αλλαγές.
		  Πολλοί χρήστες εκτελούν το <command>cvsup</command> μέσω
		  του <command>cron</command> ώστε να κρατάνε τον πηγαίο
		  κώδικα του συστήματος τους πάντα ανανεωμένο αυτόματα.  Θα
		  πρέπει να προσαρμόσετε το υπόδειγμα του
		  <filename>supfile</filename> που δίνουμε παραπάνω, και να
		  ρυθμίσετε το <link linkend="cvsup">cvsup</link> για το
		  περιβάλλον σας.</para>

		<note>
		  <para>Το υπόδειγμα του αρχείου
		    <filename>standard-supfile</filename> προορίζεται για
		    χρήση με κάποιο συγκεκριμένο κλάδο ασφάλειας (security
		    branch) του &os;, και όχι με το &os.current;.  Θα πρέπει
		    να επεξεργαστείτε το αρχείο και να αντικαταστήσετε την
		    παρακάτω γραμμή:</para>

		  <programlisting>*default release=cvs tag=RELENG_<replaceable>X</replaceable>_<replaceable>Y</replaceable></programlisting>

		  <para>με την ακόλουθη:</para>

		  <programlisting>*default release=cvs tag=.</programlisting>

		  <para>Για περισσότερες πληροφορίες σχετικά με τα tags που
		    μπορείτε να χρησιμοποιήσετε, παρακαλούμε διαβάστε στο
		    Εγχειρίδιο την ενότητα <link
		      linkend="cvs-tags">Ετικέτες (Tags) για το CVS</link>.</para>
		</note>
	      </listitem>

	      <indexterm>
		<primary>-CURRENT</primary>
		<secondary>Syncing with CTM</secondary>
	      </indexterm>
	      <listitem>
		<para>Χρησιμοποιήστε την υπηρεσία <application><link
		  linkend="ctm">CTM</link></application>.  Αν έχετε πολύ κακή
		  συνδεσιμότητα (υψηλό κόστος σύνδεσης ή πρόσβαση μόνο μέσω
		  email) το <application>CTM</application> αποτελεί για σας
		  μια εναλλακτική λύση.  Μπορεί ωστόσο να σας δημιουργήσει
		  διάφορα προβλήματα και να καταλήξετε με χαλασμένα αρχεία.
		  Για το λόγο αυτό, το <application>CTM</application>
		  χρησιμοποιείται σπάνια, κάτι το οποίο αυξάνει ακόμα
		  περισσότερο την πιθανότητα να μη δουλεύει σωστά για μεγάλα
		  χρονικά διαστήματα.  Σας συνιστούμε να χρησιμοποιήσετε το
		  <application><link linkend="cvsup">CVSup</link></application>
		  αν διαθέτετε modem 9600&nbsp;bps ή ταχύτερο.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Αν σκοπεύετε να ανακτήσετε τον πηγαίο κώδικα για κανονική
	      χρήση (εκτέλεση) και όχι απλώς για να τον δείτε, τότε
	      ανακτήστε <emphasis>ολόκληρο</emphasis> το &os.current; και όχι
	      κάποια επιλεγμένα τμήματα.  Σε διαφορετική περίπτωση, είναι
	      αρκετά πιθανό να συναντήσετε προβλήματα, καθώς πολλά κομμάτια
	      του κώδικα εξαρτώνται από ανανεώσεις σε άλλα, και δεν μπορούν
	      να μεταγλωττιστούν αυτόνομα.</para>

	  <indexterm>
	    <primary>-CURRENT</primary>
	    <secondary>compiling</secondary>
	  </indexterm>
	    <para>Πριν μεταγλωττίσετε το &os.current;, διαβάστε προσεκτικά το
	      <filename>Makefile</filename> στον κατάλογο
	      <filename>/usr/src</filename>.  Θα πρέπει να <link
		linkend="makeworld">μεταγλωττίσετε τον πυρήνα και όλο το
		βασικό σύστημα (world)</link> την πρώτη φορά, ως μέρος της
	      διαδικασίας αναβάθμισης.  Διαβάζοντας την &a.current;
	      και το <filename>/usr/src/UPDATING</filename> θα είστε
	      ενημερωμένοι για νέες διαδικασίες όσο αφορά την εκκίνηση στο νέο
	      σας σύστημα.  Οι διαδικασίες αυτές είναι συχνά απαραίτητες όσο
	      πλησιάζουμε σε μια νέα επίσημη έκδοση.</para>
	  </listitem>

	  <listitem>
	    <para>Γίνετε ενεργό μέλος! Αν χρησιμοποιείτε το &os.current;,
	      θέλουμε να ξέρουμε τη γνώμη σας για αυτό, ειδικά αν έχετε
	      προτάσεις για βελτιώσεις ή διορθώσεις λαθών.  Προτάσεις που
	      συνοδεύονται και από κώδικα γίνονται δεκτές με
	      ενθουσιασμό!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>Χρησιμοποιώντας το &os;-STABLE</title>

      <sect3>
	<title>Τι Είναι το &os.stable;;</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>Το &os.stable; είναι ένας κλάδος ανάπτυξης από τον οποίο
	  προκύπτουν οι <quote>μεγάλες</quote> (major) εκδόσεις.  Οι αλλαγές
	  εισάγονται σε αυτό τον κλάδο με διαφορετικό ρυθμό, και με τη γενική
	  παραδοχή ότι έχουν πρώτα περάσει από το &os.current; για δοκιμή.
	  Ωστόσο, <emphasis>δεν παύει</emphasis> να είναι ένας κλάδος
	  ανάπτυξης, και αυτό σημαίνει ότι ο κώδικας του &os.stable; μπορεί
	  μια δεδομένη χρονική στιγμή να είναι ακατάλληλος για συγκεκριμένες
	  εφαρμογές.  Πρόκειται για μια ακόμα γραμμή ανάπτυξης για τους
	  προγραμματιστές, και δεν είναι απαραίτητα κατάλληλη για τους
	  τελικούς χρήστες.</para>
      </sect3>

      <sect3>
	<title>Ποιος Χρειάζεται το &os.stable;;</title>

	<para>Αν σας ενδιαφέρει να παρακολουθείτε ή να συμβάλλετε στην
	  ανάπτυξη του &os;, και ειδικά όσο αφορά την επόμενη επίσημη
	  έκδοση του από τον ίδιο κλάδο (point release), είναι καλή ιδέα να
	  παρακολουθείτε το &os.stable;.</para>

	<para>Αν και είναι αλήθεια ότι οι διορθώσεις ασφάλειας γίνονται και
	  στον κλάδο &os.stable;, ωστόσο <emphasis>δεν χρειάζεται</emphasis>
	  να παρακολουθείτε το &os.stable; μόνο για αυτό το λόγο.  Κάθε
	  αναφορά προβλήματος ασφάλειας του &os; εξηγεί πως να διορθώσετε το
	  πρόβλημα για κάθε επίσημη έκδοση η οποία επηρεάζεται από αυτό
	  <footnote><para>Αυτό βέβαια δεν είναι απόλυτα αληθινό.  Δεν μπορούμε
	    να συνεχίσουμε να υποστηρίζουμε τις παλιές εκδόσεις του &os; για
	    πάντα, αν και τις υποστηρίζουμε για πολλά χρόνια.  Για πλήρη
	    περιγραφή της τρέχουσας πολιτικής όσο αφορά την ασφάλεια των
	    παλιών εκδόσεων του &os;, δείτε <ulink
	      url="&url.base;/security/">http://www.FreeBSD.org/security/</ulink>.</para>
	  </footnote>,
	  και η παρακολούθηση ενός κλάδου ανάπτυξης μόνο για λόγους
	  ασφαλείας, πιθανόν να φέρει επίσης και άλλες ανεπιθύμητες αλλαγές
	  μαζί της.</para>

	<para>Αν και καταβάλλουμε κάθε δυνατή προσπάθεια ώστε να εξασφαλίσουμε
	  ότι ο κλάδος &os.stable; μπορεί να μεταγλωττιστεί και να εκτελεστεί
	  σε κάθε δεδομένη χρονική στιγμή, δεν μπορούμε ωστόσο να το
	  εγγυηθούμε.  Επιπρόσθετα, αν και ο κώδικας αναπτύσσεται στο
	  &os.current; πριν περάσει στο &os.stable;, ο κόσμος που εκτελεί το
	  &os.stable; είναι περισσότερος, και έτσι είναι αναπόφευκτο να
	  ανακαλύπτονται πιο πολλά σφάλματα και ακραίες περιπτώσεις στο
	  &os.stable; τα οποία δεν έχουν γίνει εμφανή στο &os.current;.</para>

	<para>Για τους λόγους αυτούς, <emphasis>δεν</emphasis> συνιστούμε να
	  παρακολουθείτε τυφλά το &os.stable;, και ειδικότερα είναι σημαντικό
	  να μην αναβαθμίζετε σε αυτό εξυπηρετητές σε περιβάλλοντα παραγωγής,
	  χωρίς να έχετε πρώτα ελέγξει αναλυτικά τον κώδικα στο δικό σας
	  περιβάλλον ανάπτυξης.</para>

	<para>Αν δεν διαθέτετε τους πόρους για να το κάνετε αυτό, σας
	  συνιστούμε να χρησιμοποιείτε την τελευταία επίσημη έκδοση του &os;,
	  και να αναβαθμίζεστε από τη μια έκδοση στην επόμενη μέσω του
	  μηχανισμού δυαδικών ενημερώσεων.</para>
      </sect3>

      <sect3>
	<title>Χρησιμοποιώντας το &os.stable;</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>using</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Γραφτείτε συνδρομητής στη λίστα &a.stable.name;.  Θα είστε
	      έτσι ενημερωμένοι για εξαρτήσεις μεταγλώττισης που ίσως
	      εμφανιστούν στο &os.stable;, ή για άλλα προβλήματα που χρήζουν
	      ειδικής προσοχής.  Στη λίστα αυτή θα βρίσκετε επίσης
	      ανακοινώσεις από μέλη της ομάδας ανάπτυξης, όταν πρόκειται να
	      συμπεριληφθεί κάποια αμφιλεγόμενη ανανέωση ή διόρθωση, δίνοντας
	      έτσι στους χρήστες την ευκαιρία να εκφέρουν γνώμη σχετικά με τα
	      προβλήματα που θα προκαλέσει η προτεινόμενη αλλαγή.</para>

	    <para>Θα πρέπει να εγγραφείτε στην κατάλληλη λίστα
	      <application>SVN</application> ανάλογα με τον κλάδο που
	      παρακολουθείτε.  Για παράδειγμα, αν παρακολουθείτε τον κλάδο
	      7-STABLE, η κατάλληλη λίστα είναι η &a.svn-src-stable-7.name;.
	      Αυτό θα σας επιτρέψει να βλέπετε τις
	      καταχωρήσεις στο commit log για κάθε αλλαγή που γίνεται, καθώς
	      και πληροφορίες για πιθανές παρενέργειες που μπορεί να
	      έχει.</para>

	    <para>Για να γραφτείτε σε αυτές, ή σε οποιεσδήποτε από τις
	      υπάρχουσες λίστες, επισκεφθείτε την τοποθεσία
	      &a.mailman.lists.link; και επιλέξτε τη λίστα στην οποία θέλετε
	      να γίνετε συνδρομητής.  Οδηγίες για την υπόλοιπη διαδικασία
	      θα βρείτε επιτόπου.  Αν σας ενδιαφέρει να παρακολουθείτε τις
	      αλλαγές σε όλο το δέντρο πηγαίου κώδικα, σας συνιστούμε να
	      εγγραφείτε στη λίστα &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>Αν πρόκειται να εγκαταστήσετε ένα νέο σύστημα με σκοπό να
	      εκτελείτε τα μηνιαία snapshot του &os.stable;, παρακαλούμε να
	      ελέγξετε την τοποθεσία <ulink
		url="&url.base;/snapshots/">Snapshots</ulink> για
	      περισσότερες πληροφορίες.  Εναλλακτικά, είναι δυνατόν να
	      εγκαταστήσετε το πιο πρόσφατο &os.stable; από κάποιο
	      <link linkend="mirrors">mirror site</link> ακολουθώντας τις
	      παρακάτω οδηγίες ώστε να αναβαθμίσετε το σύστημα σας στην πλέον
	      πρόσφατη έκδοση πηγαίου κώδικα του &os.stable;.</para>

	    <para>Αν διαθέτετε ήδη κάποια προηγούμενη έκδοση του &os; και
	      επιθυμείτε να αναβαθμιστείτε μέσω του πηγαίου κώδικα, μπορείτε
	      εύκολα να χρησιμοποιήσετε κάποιο <link
		linkend="mirrors">mirror site</link> του &os;.  Υπάρχουν δύο
	      τρόποι για να γίνει αυτό:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
		<primary>-STABLE</primary>
		<secondary>syncing with <application>CVSup</application></secondary>
	      </indexterm>
	      <listitem>

		<para>Χρησιμοποιήστε το πρόγραμμα <link
		    linkend="cvsup">cvsup</link> σε συνδυασμό με το
		  <filename>supfile</filename> με την ονομασία
		  <filename>stable-supfile</filename> το οποίο θα βρείτε
		  στον κατάλογο
		  <filename>/usr/share/examples/cvsup</filename>.
		  Αυτή είναι και η πλέον συνιστώμενη μέθοδος, καθώς σας
		  επιτρέπει να ανακτήσετε όλη τη συλλογή με μια κίνηση, και
		  στις επόμενες ανανεώσεις θα παίρνετε μόνο τις αλλαγές.
		  Πολλοί χρήστες εκτελούν το <command>cvsup</command> μέσω
		  του <command>cron</command> ώστε να κρατάνε τον πηγαίο
		  κώδικα του συστήματος τους πάντα ανανεωμένο αυτόματα.  Θα
		  πρέπει να προσαρμόσετε το υπόδειγμα του
		  <filename>supfile</filename> που δίνουμε παραπάνω, και να
		  ρυθμίσετε το <link linkend="cvsup">cvsup</link> για το
		  περιβάλλον σας.</para>
	      </listitem>

	      <indexterm>
		<primary>-STABLE</primary>
		<secondary>syncing with CTM</secondary>
	      </indexterm>
	      <listitem>
		<para>Χρησιμοποιήστε την υπηρεσία <application><link
		  linkend="ctm">CTM</link></application>.  Αν δεν έχετε
		  γρήγορη και φτηνή σύνδεση με το Internet, αυτή είναι η
		  συνιστώμενη μέθοδος.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Ουσιαστικά, αν χρειάζεστε γρήγορη και κατά απαίτηση
	      πρόσβαση στον πηγαίο κώδικα, και το εύρος ζώνης της σύνδεσης
	      δεν αποτελεί πρόβλημα, χρησιμοποιήστε το
	      <command>cvsup</command> ή το <command>ftp</command>.
	      Διαφορετικά, χρησιμοποιήστε το
	      <application>CTM</application>.</para>
	  </listitem>

	  <indexterm>
	    <primary>-STABLE</primary>
	    <secondary>compiling</secondary>
	  </indexterm>
	  <listitem>
	    <para>Πριν μεταγλωττίσετε το &os.stable;, διαβάστε προσεκτικά το
	      <filename>Makefile</filename> στον κατάλογο
	      <filename>/usr/src</filename>.  Θα πρέπει να <link
		linkend="makeworld">μεταγλωττίσετε τον πυρήνα και όλο το
		βασικό σύστημα (world)</link> την πρώτη φορά, ως μέρος της
	      διαδικασίας αναβάθμισης.  Διαβάζοντας την &a.stable;
	      και το <filename>/usr/src/UPDATING</filename> θα είστε
	      ενημερωμένοι για νέες διαδικασίες όσο αφορά την εκκίνηση στο νέο
	      σας σύστημα.  Οι διαδικασίες αυτές είναι συχνά απαραίτητες όσο
	      πλησιάζουμε σε μια νέα επίσημη έκδοση.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Συγχρονίζοντας τον Πηγαίο σας Κώδικα</title>

    <para>Υπάρχουν διάφοροι τρόποι να χρησιμοποιήσετε μια σύνδεση Internet
      (ή email) για να ενημερώνετε οποιοδήποτε τμήμα πηγαίου
      κώδικα του &os;&nbsp;Project σας ενδιαφέρει, ή και όλα αν το
      επιθυμείτε.  Οι βασικές υπηρεσίες που προσφέρουμε είναι το
      <link linkend="anoncvs">Ανώνυμο CVS</link>, το
      <link linkend="cvsup">CVSup</link>, και το <link
	linkend="ctm">CTM</link>.</para>

    <warning>
      <para>Αν και είναι δυνατόν να ενημερώσετε μόνο κάποια τμήματα του
	δέντρου πηγαίου κώδικα, η μόνη διαδικασία ενημέρωσης που
	υποστηρίζεται αφορά την ενημέρωση ολόκληρου του δέντρου.  Μετά την
	ενημέρωση, θα πρέπει να μεταγλωττίσετε ξανά τόσο το userland (δηλ. τα
	προγράμματα που εκτελούνται στην περιοχή χρήστη, όπως αυτά που
	βρίσκονται στους καταλόγους <filename>/bin</filename> και
	<filename>/sbin</filename>) όσο και τον πηγαίο κώδικα του πυρήνα.
	Αν ενημερώσετε μόνο ένα τμήμα του πηγαίου κώδικα, μόνο τον πυρήνα ή
	μόνο το userland, θα αντιμετωπίσετε προβλήματα.  Τα προβλήματα αυτά
	μπορεί να κυμαίνονται από σφάλματα μεταγλώττισης μέχρι kernel panic
	και καταστροφή δεδομένων.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonymous</secondary>
    </indexterm>

    <para>Το <application>Ανώνυμο CVS</application> και το
      <application>CVSup</application> χρησιμοποιούν τη μέθοδο
      <emphasis>pull</emphasis> για την ενημέρωση του πηγαίου κώδικα.  Στην
      περίπτωση του <application>CVSup</application>, ο χρήστης (η κάποιο
      script που εκτελείται μέσω <command>cron</command>) εκτελεί το πρόγραμμα
      <command>cvsup</command> το οποίο αλληλεπιδρά με ένα αντίστοιχο
      εξυπηρετητή <command>cvsupd</command> ώστε να ενημερώσει τα σχετικά
      αρχεία.  Οι ενημερώσεις που λαμβάνετε είναι πάντοτε οι τελευταίες
      διαθέσιμες, και θα τις λάβετε μόνο όταν τις ζητήσετε.  Μπορείτε εύκολα
      να περιορίσετε τις ενημερώσεις σε συγκεκριμένα αρχεία ή καταλόγους τα
      οποία σας ενδιαφέρουν.  Οι ενημερώσεις δημιουργούνται δυναμικά από τον
      εξυπηρετητή, ανάλογα με το τι έχετε εγκατεστημένο και τι επιθυμείτε να
      λάβετε.  Το <application>Ανώνυμο CVS</application> είναι κάπως πιο
      απλοϊκό από το <application>CVSup</application>, δεδομένου ότι είναι
      απλώς μια επέκταση του <application>CVS</application> που επιτρέπει την
      ανάκτηση αλλαγών απευθείας από κάποιο απομακρυσμένο CVS repository.  Το
      <application>CVSup</application> είναι αρκετά πιο αποτελεσματικό σε
      αυτόν το τομέα, αλλά το <application>Ανώνυμο CVS</application> είναι
      απλούστερο στη χρήση.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para>Από την άλλη μεριά, το <application>CTM</application> δεν συγκρίνει
      άμεσα τον πηγαίο κώδικα που έχετε με αυτόν που υπάρχει στον κεντρικό
      εξυπηρετητή ώστε να ανακτήσει μόνο τις αλλαγές.  Αντίθετα, στο κεντρικό
      μηχάνημα CTM, εκτελείται αρκετές φορές την ημέρα ένα script.  Το script
      αυτό αναγνωρίζει τις αλλαγές στα αρχεία σε σχέση με την προηγούμενη
      εκτέλεση του, και έπειτα πακετάρει και συμπιέζει τις αλλαγές με τρόπο
      κατάλληλο για αποστολή μέσω email (μόνο εκτυπώσιμοι ASCII χαρακτήρες).
      Σε κάθε τέτοιο πακέτο αλλαγών αντιστοιχίζεται ένας μοναδιαίος αριθμός
      ακολουθίας (sequence number) που το αναγνωρίζει.  Μετά τη λήψη τους,
      μπορείτε να δώσετε αυτά τα αρχεία διαφορών του
      <application>CTM</application> (<quote>CTM deltas</quote>) στο βοηθητικό
      πρόγραμμα &man.ctm.rmail.1; το οποίο αυτόματα θα τα αποκωδικοποιήσει,
      θα τα επαληθεύσει, και θα εφαρμόσει τις αλλαγές στο αντίγραφο πηγαίου
      κώδικα του χρήστη.  Η διαδικασία αυτή είναι πολύ πιο αποδοτική από το
      <application>CVSup</application>, και επιβαρύνει λιγότερο τους
      εξυπηρετητές μας, καθώς είναι μια διαδικασία τύπου
      <emphasis>push</emphasis> αντί για <emphasis>pull</emphasis>.</para>

    <para>Υπάρχουν φυσικά κάποια σημεία που υστερεί.  Αν από λάθος διαγράψετε
      κάποια τμήματα του πηγαίου σας κώδικα, το
      <application>CVSup</application> θα ανιχνεύσει και θα διορθώσει αυτόματα
      τη βλάβη για σας.  Το <application>CTM</application> δεν θα το κάνει
      αυτό, και αν σβήσετε κάποιο τμήμα του δέντρου σας (και δεν έχετε
      αντίγραφο ασφαλείας) θα πρέπει να ξεκινήσετε από την αρχή (από το πιο
      πρόσφατο CVS <quote>base delta</quote>) και να το ξανακτίσετε από την
      αρχή με το <application>CTM</application>.  Με το
      <application>Ανώνυμο CVS</application>, μπορείτε απλώς να διαγράψετε
      τα προβληματικά αρχεία και να συγχρονίσετε ξανά τον πηγαίο σας
      κώδικα.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>Μεταγλωττίζοντας το Βασικό Σύστημα (<quote>world</quote>)</title>

    <indexterm>
      <primary>Rebuilding <quote>world</quote></primary>
    </indexterm>
    <para>Έχοντας συγχρονίσει το τοπικό σας δέντρο πηγαίου κώδικα σε κάποια
      συγκεκριμένη έκδοση του &os; (&os.stable;, &os.current;, κ.ο.κ.),
      μπορείτε έπειτα να το χρησιμοποιήσετε για να μεταγλωττίσετε το
      σύστημα σας από την αρχή.</para>

    <warning>
      <title>Δημιουργήστε Ένα Αντίγραφο Ασφαλείας</title>

      <para>Δεν μπορούμε παρά να τονίσουμε πόσο σημαντικό είναι να
	δημιουργήσετε ένα αντίγραφο ασφαλείας του συστήματος σας
	<emphasis>πριν</emphasis> ξεκινήσετε αυτή τη διαδικασία.  Αν και η
	μεταγλώττιση του βασικού συστήματος είναι (όσο τουλάχιστον ακολουθείτε
	αυτές τις οδηγίες) μια σχετικά απλή διαδικασία, αναμφίβολα θα υπάρξουν
	και περιπτώσεις που λάθη δικά σας, ή άλλων (στο δέντρο πηγαίου
	κώδικα), θα σας οδηγήσουν σε ένα σύστημα που δεν θα μπορεί να
	εκκινήσει.</para>

      <para>Βεβαιωθείτε ότι έχετε ενημερωμένο αντίγραφο ασφαλείας.  Καλό θα
	είναι να έχετε επίσης πρόχειρη μια δισκέτα fixit ή ένα CD εκκίνησης.
	Ίσως να μην χρειαστεί ποτέ να τα χρησιμοποιήσετε, αλλά καλύτερα να
	είστε ασφαλής παρά να το μετανοιώνετε αργότερα!</para>
    </warning>

    <warning>
      <title>Γίνετε Συνδρομητής στη Σωστή Λίστα Ηλ. Ταχυδρομείου</title>

      <indexterm><primary>mailing list</primary></indexterm>
      <para>Από τη φύση τους, οι κλάδοι &os.stable; και &os.current;
	βρίσκονται σε συνεχή <emphasis>ανάπτυξη</emphasis>.  Όσοι συνεισφέρουν
	στο &os; είναι απλώς άνθρωποι, και περιστασιακά λάθη απλώς
	συμβαίνουν.</para>

      <para>Ορισμένες φορές τα λάθη αυτά είναι μάλλον ακίνδυνα, και το μόνο
	που κάνουν είναι να εμφανίζουν μερικές διαγνωστικές προειδοποιήσεις
	στο σύστημα σας.  Ή μπορεί η αλλαγή να είναι καταστροφική, και να
	οδηγήσει το σύστημα σας σε αδυναμία εκκίνησης ή ακόμα και να
	καταστρέψει τα συστήματα αρχείων σας (ή και ακόμα χειρότερες
	συνέπειες).</para>

      <para>Αν συμβούν τέτοια προβλήματα, σύντομα θα εμφανιστεί ένα μήνυμα
	τύπου <quote>heads up</quote> στις σχετικές λίστες ταχυδρομείου, το
	οποίο θα εξηγεί το πρόβλημα και ποια συστήματα επηρεάζει.  Όταν το
	πρόβλημα λυθεί, θα γίνει μια αντίστοιχη <quote>all clear</quote>
	ανακοίνωση.</para>

      <para>Αν προσπαθείτε να ακολουθήσετε το &os.stable; ή το &os.current;,
	και δεν διαβάζετε τις αντίστοιχες λίστες &a.stable.name; και
	&a.current.name;, ψάχνετε για μπελάδες.</para>
    </warning>

    <warning>
      <title>Μην Χρησιμοποιήσετε την εντολή
	<command>make world</command></title>

      <para>Μεγάλο μέρος της παλαιότερης τεκμηρίωσης, συνιστά τη χρήση της
	εντολής <command>make world</command>.  Αν την χρησιμοποιήσετε, θα
	παραλειφθούν ορισμένα σημαντικά βήματα της διαδικασίας.
	Χρησιμοποιήστε τη μόνο αν είστε απόλυτα σίγουροι για αυτό που κάνετε.
	Για τις περισσότερες περιπτώσεις, η εντολή
	<command>make world</command> είναι λανθασμένη, και αντί για αυτή
	θα πρέπει να ακολουθήσετε τη διαδικασία που περιγράφουμε
	παρακάτω.</para>
    </warning>

    <sect2>
      <title>Ο Κανονικός Τρόπος να Ενημερώσετε το Σύστημα σας</title>

      <para>Πριν ενημερώσετε το σύστημα σας, θα πρέπει να ελέγξετε το
	<filename>/usr/src/UPDATING</filename> για τυχόν βήματα που θα πρέπει
	να εκτελέσετε πριν την εκκίνηση της μεταγλώττισης.  Τα βήματα αυτά
	εξαρτώνται από την έκδοση του πηγαίου κώδικα που πρόκειται να
	χρησιμοποιήσετε.  Έπειτα, ακολουθήστε την παρακάτω διαδικασία:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para>Υπάρχουν κάποιες μάλλον σπάνιες περιπτώσεις, που απαιτείται
	  μια επιπλέον εκτέλεση του <command>mergemaster -p</command> πριν
	  το βήμα <maketarget>buildworld</maketarget>.  Οι περιπτώσεις αυτές
	  περιγράφονται στο <filename>UPDATING</filename>.  Σε γενικές
	  γραμμές πάντως, μπορείτε με ασφάλεια να παραλείψετε αυτό το βήμα,
	  αν δεν αναβαθμίζετε το σύστημα σας μεταξύ πολλαπλών εκδόσεων του
	  &os;.</para>
      </note>

      <para>Μετά την επιτυχή ολοκλήρωση του
	<maketarget>installkernel</maketarget>, θα πρέπει να επανεκκινήσετε
	σε κατάσταση ενός χρήστη (π.χ. χρησιμοποιώντας την εντολή
	<command>boot -s</command> στην προτροπή του φορτωτή εκκίνησης).
	Έπειτα εκτελέστε:</para>

      <screen>&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Διαβάστε τις Επιπλέον Εξηγήσεις</title>

	<para>Η διαδικασία που περιγράψαμε παραπάνω είναι μια απλή περίληψη
	  για να σας βοηθήσει να ξεκινήσετε.  Θα πρέπει ωστόσο να διαβάσετε
	  τις παρακάτω ενότητες για να κατανοήσετε πλήρως κάθε βήμα, ειδικά
	  αν θέλετε να χρησιμοποιήσετε δικό σας προσαρμοσμένο πυρήνα.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Διαβάστε το <filename>/usr/src/UPDATING</filename></title>

      <para>Πριν κάνετε οτιδήποτε άλλο, διαβάστε το
	<filename>/usr/src/UPDATING</filename> (ή το αντίστοιχο αρχείο, αν
	έχετε αποθηκεύσει τον πηγαίο κώδικα σε άλλο κατάλογο).  Το αρχείο
	αυτό περιέχει σημαντικές πληροφορίες σχετικά με προβλήματα που μπορεί
	να συναντήσετε ή ίσως να καθορίζει τη σειρά με την οποία πρέπει να
	εκτελεστούν κάποιες εντολές.  Αν το αρχείο
	<filename>UPDATING</filename> έρχεται σε σύγκρουση με κάτι που
	διαβάσατε εδώ, προτεραιότητα έχει το αρχείο
	<filename>UPDATING</filename>.</para>

      <important>
	<para>Η ανάγνωση του αρχείου <filename>UPDATING</filename> δεν είναι
	  αποδεκτό υποκατάστατο της συνδρομής στη σωστή λίστα ηλεκτρονικού
	  ταχυδρομείου, όπως περιγράψαμε προηγουμένως.  Οι δύο απαιτήσεις
	  είναι συμπληρωματικές, δεν αλληλοαναιρούνται.</para>
      </important>
    </sect2>

    <sect2>
      <title>Ελέγξτε το <filename>/etc/make.conf</filename></title>
      <indexterm>
	<primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Εξετάστε τα αρχεία
	<filename>/usr/share/examples/etc/make.conf</filename>
	και
	<filename>/etc/make.conf</filename>.  Το πρώτο περιέχει κάποιες
	προεπιλεγμένες μεταβλητές (defines), οι περισσότερες από τις οποίες
	είναι ως σχόλια.  Για να τα χρησιμοποιήσετε όταν μεταγλωττίζετε το
	σύστημα σας, προσθέστε τα στο <filename>/etc/make.conf</filename>.
	Να έχετε υπόψη σας, πως οτιδήποτε προσθέτετε στο αρχείο
	<filename>/etc/make.conf</filename> χρησιμοποιείτε επίσης κάθε φορά
	που εκτελείτε την εντολή <command>make</command>, έτσι είναι γενικά
	καλή ιδέα να βάλετε τιμές που είναι λογικές για το
	σύστημα σας.</para>

      <para>Ένας τυπικός χρήστης θα θέλει πιθανώς να αντιγράψει τις γραμμές
	<makevar>CFLAGS</makevar> και
	<makevar>NO_PROFILE</makevar> από το αρχείο
	<filename>/usr/share/examples/etc/make.conf</filename>
	στο
	<filename>/etc/make.conf</filename> αφαιρώντας ταυτόχρονα και το
	σύμβολο του σχολίου.</para>

      <para>Εξετάστε και τις άλλες μεταβλητές (<makevar>COPTFLAGS</makevar>,
	<makevar>NOPORTDOCS</makevar> κ.ο.κ.) και αποφασίστε αν σχετίζονται
	με το επιθυμητό για σας αποτέλεσμα.</para>
    </sect2>

    <sect2>
      <title>Ενημερώστε τα Αρχεία στο <filename>/etc</filename></title>

      <para>Ο κατάλογος <filename>/etc</filename> περιέχει μεγάλο μέρος των
	πληροφοριών ρύθμισης του συστήματος σας, όπως επίσης και scripts που
	εκτελούνται κατά την εκκίνηση του συστήματος.  Μερικά από τα scripts
	αυτά αλλάζουν από έκδοση σε έκδοση του &os;.</para>

      <para>Ορισμένα από τα αρχεία ρυθμίσεων χρησιμοποιούνται επίσης κατά την
	καθημερινή χρήση του συστήματος.  Το <filename>/etc/group</filename>
	είναι ένα από αυτά.</para>

      <para>Έχουν υπάρξει περιπτώσεις στο παρελθόν, όπου το
	<command>make installworld</command> ανέμενε από πριν την ύπαρξη
	συγκεκριμένων ονομάτων χρηστών (usernames) ή ομάδων (groups).  Κατά
	τη διαδικασία της αναβάθμισης ήταν αρκετά πιθανό αυτοί οι χρήστες ή
	ομάδες να μην υπήρχαν.  Αυτό δημιουργούσε προβλήματα στην
	διαδικασία.  Σε κάποιες περιπτώσεις, το
	<command>make buildworld</command> θα ελέγξει αν υπάρχουν αυτοί οι
	χρήστες ή ομάδες.</para>

      <para>Μια τέτοια περίπτωση παρουσιάστηκε όταν προστέθηκε ο χρήστης
	<username>smmsp</username>.  Η διαδικασία αναβάθμισης αποτύγχανε σε
	πολλούς χρήστες, τη στιγμή που το &man.mtree.8; προσπαθούσε να
	δημιουργήσει τον κατάλογο
	<filename>/var/spool/clientmqueue</filename>.</para>

      <para>Η λύση είναι να εκτελέσετε το &man.mergemaster.8; σε κατάσταση
	προ-εγκατάστασης, δίνοντας την επιλογή <option>-p</option>.  Αυτή
	θα συγκρίνει μόνο τα αρχεία που είναι απαραίτητα για την επιτυχία
	εκτέλεσης του <maketarget>buildworld</maketarget> ή του
	<maketarget>installworld</maketarget>.  Αν η έκδοση του
	<command>mergemaster</command> που έχετε είναι παλιά και δεν
	υποστηρίζει το <option>-p</option>, χρησιμοποιήστε την νέα έκδοση
	από το δέντρο του πηγαίου κώδικα όταν την εκτελέσετε για πρώτη
	φορά:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Αν αισθάνεστε ιδιαίτερα παρανοϊκός, μπορείτε να ελέγξετε το
	  σύστημα σας για να δείτε ποια αρχεία ανήκουν στην ομάδα που
	  μετονομάζετε ή διαγράφετε:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>Η παραπάνω εντολή θα σας δείξει όλα τα αρχεία τα οποία ανήκουν
	  στην ομάδα <replaceable>GID</replaceable> (μπορείτε να δώσετε όνομα
	  ή αριθμητικό αναγνωριστικό της ομάδας).</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Μεταβείτε σε Κατάσταση Ενός Χρήστη</title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>Ίσως προτιμάτε να μεταγλωττίσετε το σύστημα σε κατάσταση ενός
	χρήστη.  Εκτός από το προφανές πλεονέκτημα της ελαφρά μεγαλύτερης
	ταχύτητας, η επανεγκατάσταση του συστήματος θα επηρεάσει πολλά
	σημαντικά αρχεία του συστήματος, όλα τα εκτελέσιμα αρχεία του βασικού
	συστήματος, τις βιβλιοθήκες, τα αρχεία include κ.α.  Αν τα αλλάξετε
	αυτά σε ένα σύστημα που βρίσκεται σε κανονική λειτουργία (και ειδικά
	αν υπάρχουν ενεργοί χρήστες την δεδομένη στιγμή), ψάχνετε για
	μπελάδες.</para>

      <indexterm><primary>multi-user mode</primary></indexterm>
      <para>Μια άλλη μέθοδος είναι να μεταγλωττίσετε το σύστημα σε κατάσταση
	κανονικής λειτουργίας, αλλά να μεταβείτε σε κατάσταση ενός χρήστη για
	την εγκατάσταση.  Αν θέλετε να το κάνετε με αυτό τον τρόπο, απλώς
	μην εκτελέσετε τα ακόλουθα βήματα μέχρι το τέλος της μεταγλώττισης.
	Μπορείτε να αναβάλλετε τη μετάβαση σε κατάσταση ενός χρήστη μέχρι
	να είστε έτοιμοι για το <maketarget>installkernel</maketarget> ή
	<maketarget>installworld</maketarget>.</para>

      <para>Ως υπερχρήστης μπορείτε να εκτελέσετε:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>σε ένα σύστημα σε κανονική λειτουργία για να μεταβείτε σε
	κατάσταση ενός χρήστη.</para>

      <para>Εναλλακτικά, επανεκκινήστε το σύστημα και στην προτροπή του
	φορτωτή εκκίνησης, επιλέξτε <quote>single user</quote>.  Το σύστημα
	θα ξεκινήσει σε κατάσταση ενός χρήστη.  Στην προτροπή της γραμμής
	εντολών θα πρέπει να γράψετε:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Θα γίνει έλεγχος στα συστήματα αρχείων, και προσάρτηση του
	<filename>/</filename> με δυνατότητα ανάγνωσης/εγγραφής.  Έπειτα θα
	προσαρτηθούν όλα τα άλλα συστήματα αρχείων UFS τα οποία αναφέρονται
	στο <filename>/etc/fstab</filename>, και θα ενεργοποιηθεί το
	swap.</para>

	<note>
	  <para>Αν το CMOS ρολόι του υπολογιστή σας είναι ρυθμισμένο σε
	    τοπική ώρα και όχι σε GMT (αυτό είναι αλήθεια αν η έξοδος της
	    εντολής &man.date.1; δεν δείχνει σωστή ημερομηνία και ώρα), ίσως
	    χρειαστεί να εκτελέσετε επίσης την παρακάτω εντολή:</para>

	  <screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	  <para>Με αυτό τον τρόπο θα βεβαιωθείτε ότι οι τοπικές σας ρυθμίσεις
	    ώρας έχουν ρυθμιστεί σωστά.  Διαφορετικά, μπορεί να συναντήσετε
	    προβλήματα αργότερα.</para>
	</note>
    </sect2>

    <sect2>
      <title>Διαγράψτε το <filename>/usr/obj</filename></title>

      <para>Καθώς γίνεται η επαναμεταγλώττιση, τμήματα του συστήματος
	τοποθετούνται από προεπιλογή σε υποκαταλόγους του
	<filename>/usr/obj</filename>.  Οι υποκατάλογοι αυτοί αντιγράφουν τη
	δομή που ακολουθείται στο <filename>/usr/src</filename>.</para>

      <para>Μπορείτε να επιταχύνετε τη διαδικασία του
	<command>make buildworld</command> και επίσης να γλυτώσετε από κάποια
	πιθανά προβλήματα, αν διαγράψετε και αυτό τον κατάλογο.</para>

      <para>Κάποια αρχεία σε υποκαταλόγους του <filename>/usr/obj</filename>
	μπορεί να έχουν χαρακτηριστεί ως immutable μέσω του αντίστοιχου flag
	(για περισσότερες λεπτομέρειες δείτε το &man.chflags.1;).  Πριν
	διαγράψετε αυτά τα αρχεία, θα πρέπει πρώτα να καταργήσετε αυτό το
	flag.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 id="updating-upgrading-compilebase">
      <title>Επαναμεταγλωττίστε το Βασικό Σύστημα</title>

      <sect3>
	<title>Αποθηκεύστε την Έξοδο</title>

	<para>Καθώς εκτελείται η &man.make.1;, είναι καλή ιδέα η έξοδος της
	  να αποθηκεύεται σε κάποιο άλλο αρχείο.  Αν κάτι πάει στραβά, θα
	  έχετε ένα αντίγραφο του μηνύματος λάθους.  Αν και αυτό ίσως δεν σας
	  βοηθήσει να βρείτε τι πήγε στραβά, μπορεί να διευκολύνει άλλους αν
	  στείλετε το μήνυμα σας σε μια από τις λίστες ηλεκτρονικού
	  ταχυδρομείου του &os;.</para>

	<para>Ο ευκολότερος τρόπος για να γίνει αυτό, είναι χρησιμοποιώντας
	  την εντολή &man.script.1; με μια παράμετρο που να καθορίζει το όνομα
	  του αρχείου στο οποίο θα αποθηκευτεί η έξοδος.  Θα πρέπει να
	  το εκτελέσετε αμέσως πριν ξεκινήσετε την μεταγλώττιση του βασικού
	  συστήματος, και να γράψετε <userinput>exit</userinput> μόλις
	  η διαδικασία ολοκληρωθεί.</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; μεταγλώττιση, μεταγλώττιση, μεταγλώττιση &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Αν αποφασίσετε να αποθηκεύσετε την έξοδο,
	  <emphasis>μη χρησιμοποιήσετε</emphasis> για αυτό το σκοπό τον
	  κατάλογο <filename>/tmp</filename>.  Τα περιεχόμενα αυτού του
	  καταλόγου πιθανώς να διαγραφούν την επόμενη φορά που θα εκκινήσετε
	  το σύστημα σας.  Ένας καλύτερος κατάλογος για την αποθήκευση του
	  είναι ο <filename>/var/tmp</filename> (όπως στο προηγούμενο
	  παράδειγμα) ή ο προσωπικός κατάλογος του
	  <username>root</username>.</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>Μεταγλωττίστε το Βασικό Σύστημα</title>

	<para>Θα πρέπει να βρίσκεστε στον κατάλογο
	  <filename>/usr/src</filename>:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<para>(εκτός αν φυσικά έχετε αποθηκεύσει τον πηγαίο κώδικα σε κάποιο
	  άλλο κατάλογο, οπότε απλώς μετακινηθείτε σε αυτόν).</para>
	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Για να επαναμεταγλωττίσετε το βασικό σύστημα, χρησιμοποιήστε
	  την εντολή &man.make.1;.  Η εντολή αυτή διαβάζει τις σχετικές
	  οδηγίες από το αρχείο <filename>Makefile</filename>, το οποίο
	  περιγράφει με ποιο τρόπο πρέπει να μεταγλωττιστούν τα προγράμματα
	  από τα οποία αποτελείται το &os;, τη σειρά με την οποία πρέπει να
	  γίνει η μεταγλώττιση κ.ο.κ.</para>

	<para>Η γενική μορφή της εντολής που θα πληκτρολογήσετε είναι η
	  παρακάτω:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

	<para>Στο παράδειγμα αυτό, το
	  <option>-<replaceable>x</replaceable></option> αντιπροσωπεύει μια
	  επιλογή που θέλετε να δώσετε στην &man.make.1;.  Δείτε την σελίδα
	  manual του &man.make.1; για παραδείγματα δυνατών επιλογών.</para>

	<para>Η επιλογή <option>-D<replaceable>VARIABLE</replaceable></option>
	  περνάει μια μεταβλητή στο <filename>Makefile</filename>.
	  Η συμπεριφορά του <filename>Makefile</filename> ελέγχεται από
	  τέτοιου είδους μεταβλητές.  Πρόκειται για τις ίδιες μεταβλητές που
	  καθορίζονται και στο <filename>/etc/make.conf</filename>, και αυτός
	  είναι ένας ακόμα τρόπος καθορισμού τους.</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>target</replaceable></userinput></screen>

	<para>Το παραπάνω δείχνει ένα επιπλέον τρόπο να καθορίσετε ότι δεν
	  θέλετε να μεταγλωττιστούν οι βιβλιοθήκες με πληροφορίες profiling,
	  και αντιστοιχεί με την παρακάτω γραμμή στο
	  <filename>/etc/make.conf</filename>:</para>

	<programlisting>NO_PROFILE=    true 	#    Avoid compiling profiled libraries</programlisting>

	<para>Το <replaceable>target</replaceable> δηλώνει στο &man.make.1;
	  τι θέλετε να κάνετε.  Σε κάθε <filename>Makefile</filename> ορίζεται
	  ένας αριθμός διαφορετικών <quote>targets</quote>, και η επιλογή που
	  θα κάνετε, καθορίζει τι ακριβώς θα γίνει.</para>

	<para>Κάποια από τα targets που καθορίζονται στο
	  <filename>Makefile</filename>, δεν προορίζονται για άμεση εκτέλεση
	  από το χρήστη.  Αντί για αυτό, χρησιμοποιούνται από τη διαδικασία
	  μεταγλώττισης για να μοιραστεί ο αριθμός των βημάτων που απαιτούνται
	  για τη μεταγλώττιση του συστήματος, σε ένα αριθμό
	  υπo-βημάτων.</para>

	<para>Στις περισσότερες περιπτώσεις δεν θα χρειαστεί να δώσετε καμία
	  παράμετρο στο &man.make.1;, και έτσι η εντολή σας θα μοιάζει με την
	  παρακάτω:</para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>

	<para>Όπου το <replaceable>target</replaceable> θα είναι μια από τις
	  πολλές επιλογές μεταγλώττισης.  Το πρώτο target θα πρέπει πάντα να
	  είναι το <makevar>buildworld</makevar>.</para>

	<para>Όπως εννοείται και από το όνομα, το
	  <maketarget>buildworld</maketarget> μεταγλωττίζει ένα πλήρες δέντρο
	  μέσα στον κατάλογο <filename>/usr/obj</filename>, ενώ το
	  <maketarget>installworld</maketarget>, εγκαθιστά αυτό το δέντρο στο
	  τρέχον μηχάνημα.</para>

	<para>Η ύπαρξη διαφορετικών επιλογών, είναι χρήσιμη για δύο λόγους.
	  Πρώτα από όλα, σας επιτρέπει να εκτελέσετε τη διαδικασία
	  μεταγλώττισης με ασφάλεια, γνωρίζοντας ότι δεν πρόκειται να
	  επηρεαστεί κανένα τμήμα του τρέχοντος συστήματος σας.  Η διαδικασία
	  μεταγλώττισης είναι <quote>self hosted</quote>, απομονωμένη από την
	  υπόλοιπη λειτουργία του μηχανήματος.  Μπορείτε έτσι να εκτελέσετε
	  το <maketarget>buildworld</maketarget> σε ένα μηχάνημα που βρίσκεται
	  σε κανονική λειτουργία (πολλαπλών χρηστών) χωρίς να υπάρχει φόβος
	  παρενεργειών.  Ωστόσο, συνίσταται να εκτελέσετε το
	  <maketarget>installworld</maketarget> σε κατάσταση λειτουργίας
	  ενός χρήστη.</para>

	<para>Ο δεύτερος λόγος είναι ότι σας επιτρέπει να χρησιμοποιήσετε
	  προσαρτήσεις NFS για να αναβαθμίσετε πολλά μηχανήματα του δικτύου
	  σας.  Αν έχετε τρία μηχανήματα, τα
	  <hostid>A</hostid>, <hostid>B</hostid> και <hostid>C</hostid>
	  τα οποία θέλετε να αναβαθμίσετε, εκτελέστε το
	  <command>make buildworld</command> και το
	  <command>make installworld</command> στο μηχάνημα
	  <hostid>A</hostid>.  Το <hostid>B</hostid> και το
	  <hostid>C</hostid> μπορούν να προσαρτήσουν τον κατάλογο
	  <filename>/usr/src</filename> και τον
	  <filename>/usr/obj</filename> από τον <hostid>A</hostid> μέσω NFS,
	  και έπειτα μπορείτε να εκτελέσετε το
	  <command>make installworld</command> για να εγκαταστήσετε το
	  έτοιμο πλέον σύστημα στον <hostid>B</hostid> και
	  <hostid>C</hostid>.</para>

	<para>Αν και υπάρχει ακόμα το target <maketarget>world</maketarget>,
	  δεν συνίσταται πλέον η χρήση του.</para>

	<para>Εκτελέστε την εντολή:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Μπορείτε να καθορίσετε την επιλογή <option>-j</option> στην
	  <command>make</command> ώστε να εκτελεστεί σε πολλαπλές διεργασίες.
	  Αυτό είναι περισσότερο χρήσιμο σε μηχανήματα με πολλούς
	  επεξεργαστές, ωστόσο καθώς το μεγαλύτερο μέρος της διαδικασίας
	  μεταγλώττισης καθυστερεί εξαιτίας του σκληρού δίσκου (IO bound)
	  και όχι της CPU, μπορεί να σας φανεί χρήσιμο ακόμα και σε μηχανήματα
	  με ένα επεξεργαστή.</para>

	<para>Σε ένα τυπικό μηχάνημα με μια CPU, θα μπορούσατε να
	  δώσετε:</para>

	  <screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>Με την παραπάνω εντολή, το &man.make.1; θα χρησιμοποιεί μέχρι
	  4 διεργασίες κάθε χρονική στιγμή.  Από την εμπειρία που έχουμε
	  και από ότι αναφέρουν οι χρήστες στις λίστες, φαίνεται ότι η
	  ρύθμιση αυτή δίνει γενικά την καλύτερη απόδοση.</para>

	<para>Αν έχετε μηχάνημα με πολλούς επεξεργαστές, και χρησιμοποιείτε
	  πυρήνα με δυνατότητα SMP, δοκιμάστε τιμές μεταξύ του 6 και του 10
	  για να δείτε ποια επιταχύνει καλύτερα το αποτέλεσμα.</para>
      </sect3>

      <sect3>
	<title>Χρόνος Μεταγλώττισης</title>
	<indexterm>
	  <primary>rebuilding <quote>world</quote></primary>
	  <secondary>timings</secondary>
	</indexterm>

	<para>Ο χρόνος που απαιτείται για την μεταγλώττιση επηρεάζεται από
	  πολλούς παράγοντες.  Ωστόσο, σε σύγχρονα μηχανήματα η διαδικασία
	  δεν κρατάει συνήθως παραπάνω από μία ή δύο ώρες, όταν γίνεται
	  μεταγλώττιση του δέντρου &os.stable;, και μάλιστα χωρίς να
	  χρειάζεται να γίνουν ειδικές ρυθμίσεις ή κόλπα.  Το δέντρο
	  &os.current; χρειάζεται γενικά λίγο περισσότερο χρόνο για να
	  μεταγλωττιστεί.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Μεταγλωττίστε και Εγκαταστήστε Νέο Πυρήνα</title>
      <indexterm>
	<primary>kernel</primary>
	<secondary>compiling</secondary>
      </indexterm>

      <para>Για να εκμεταλλευθείτε πλήρως το νέο σας σύστημα, θα πρέπει να
	επαναμεταγλωττίσετε τον πυρήνα.  Αυτό είναι πρακτικά αναγκαίο, καθώς
	κάποιες δομές στη μνήμη πιθανώς να έχουν αλλάξει, και έτσι
	προγράμματα όπως τα &man.ps.1; και &man.top.1; δεν θα λειτουργούν
	σωστά μέχρι να συγχρονίσετε τον πυρήνα με την έκδοση πηγαίου
	κώδικα του βασικού συστήματος.</para>

      <para>Ο απλούστερος και πλέον ασφαλής τρόπος, είναι να μεταγλωττίσετε
	και να εγκαταστήσετε ένα πυρήνα βασισμένο στον
	<filename>GENERIC</filename>.  Αν και ο <filename>GENERIC</filename>
	μπορεί να μην περιέχει όλες τις απαραίτητες συσκευές για το σύστημα
	σας, θα πρέπει να περιέχει ότι χρειάζεται ώστε να ξεκινήσετε ξανά
	το σύστημα σας σε κατάσταση λειτουργίας ενός χρήστη.  Αυτό είναι ένα
	καλό τεστ σωστής λειτουργίας του συστήματος.  Μετά την εκκίνηση με
	τον <filename>GENERIC</filename>, και αφού επαληθεύσετε τη σωστή
	λειτουργία του συστήματος, μπορείτε να μεταγλωττίσετε ένα νέο
	πυρήνα βασισμένο στο δικό σας προσαρμοσμένο αρχείο ρυθμίσεων.</para>

      <para>Στο &os; είναι σημαντικό να εκτελέσετε το <link
	linkend="make-buildworld">build world</link> πριν μεταγλωττίσετε νέο
	πυρήνα.</para>

      <note><para>Αν θέλετε να μεταγλωττίσετε νέο πυρήνα, και έχετε ήδη ένα
	αρχείο με προσαρμοσμένες ρυθμίσεις, χρησιμοποιήστε απλώς την επιλογή
	<literal>KERNCONF=<replaceable>MYKERNEL</replaceable></literal>
	με τον τρόπο που φαίνεται παρακάτω:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </note>

      <para>Σημειώστε ότι αν έχετε ανεβάσει την τιμή του
	<literal>kern.securelevel</literal> πάνω από το 1,
	<emphasis>και</emphasis> έχετε θέσει το flag
	<literal>noschg</literal> ή κάποιο αντίστοιχο στο εκτελέσιμο αρχείο
	του πυρήνα, μάλλον θα χρειαστεί να μεταβείτε σε κατάσταση λειτουργίας
	ενός χρήστη για να χρησιμοποιήσετε το
	<maketarget>installkernel</maketarget>.  Διαφορετικά, μπορείτε να
	εκτελέσετε και τις δύο αυτές εντολές από την κανονική κατάσταση
	λειτουργίας (πολλών χρηστών) χωρίς να δημιουργηθούν προβλήματα.
	Δείτε τη σελίδα manual του &man.init.8; για λεπτομέρειες σχετικά με
	τη ρύθμιση <literal>kern.securelevel</literal> και τη σελίδα
	του &man.chflags.1; για λεπτομέρειες σχετικά με τα διάφορα flags
	που χρησιμοποιούνται σε αρχεία.</para>
    </sect2>

    <sect2>
      <title>Επανεκκινήστε σε Κατάσταση Λειτουργίας Ενός Χρήστη</title>
      <indexterm><primary>single-user mode</primary></indexterm>

      <para>Θα πρέπει να επανεκκινήσετε σε κατάσταση λειτουργίας ενός χρήστη
	για να επαληθεύσετε τη λειτουργία του νέου πυρήνα.  Για το σκοπό
	αυτό, χρησιμοποιήστε τις οδηγίες που είδαμε στο
	<xref linkend="makeworld-singleuser">.</para>
    </sect2>

    <sect2 id="make-installworld">
      <title>Εγκαταστήστε τα Νέα Εκτελέσιμα του Συστήματος</title>

      <para>Αν μεταγλωττίζατε μια αρκετά πρόσφατη έκδοση του &os;, η οποία
	διαθέτει το target <command>make buildworld</command>, θα πρέπει
	τώρα να χρησιμοποιήσετε το <maketarget>installworld</maketarget>
	για να εγκαταστήσετε τα νέα εκτελέσιμα του συστήματος.</para>

      <para>Εκτελέστε τις παρακάτω εντολές:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Αν έχετε καθορίσει μεταβλητές στη γραμμή εντολών του
	  <command>make buildworld</command> θα πρέπει να καθορίσετε τις
	  ίδιες μεταβλητές και στην γραμμή εντολών του
	  <command>make installworld</command>.  Αυτό δεν είναι απαραίτητα
	  αλήθεια για άλλες επιλογές.  Για παράδειγμα, η επιλογή
	  <option>-j</option> δεν πρέπει ποτέ να χρησιμοποιείτε με το
	  <maketarget>installworld</maketarget>.</para>

	<para>Για παράδειγμα αν εκτελέσετε:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>Θα πρέπει να εγκαταστήσετε το αποτέλεσμα χρησιμοποιώντας:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>διαφορετικά το &man.make.1; θα προσπαθήσει να εγκαταστήσει
	  βιβλιοθήκες με profiling, τις οποίες όμως δεν μεταγλωττίσατε κατά
	  τη διάρκεια της φάσης <command>make buildworld</command>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Ενημερώστε Όσα Αρχεία δεν Ενημερώθηκαν από το
	<command>make installworld</command></title>

      <para>Η επαναμεταγλώττιση του βασικού συστήματος δεν θα ενημερώσει
	ορισμένους καταλόγους (ειδικότερα τους
	<filename>/etc</filename>, <filename>/var</filename> και
	<filename>/usr</filename>) με τα νέα ή αλλαγμένα αρχεία
	ρυθμίσεων.</para>

      <para>Ο απλούστερος τρόπος για να ενημερώσετε τα αρχεία αυτά είναι να
	χρησιμοποιήσετε το &man.mergemaster.8;, αν και μπορείτε να το κάνετε
	και χειροκίνητα αν προτιμάτε.  Άσχετα από τον τρόπο που θα
	προτιμήσετε, βεβαιωθείτε ότι έχετε πάρει αντίγραφο ασφαλείας του
	<filename>/etc</filename> σε περίπτωση που κάτι πάει στραβά.</para>

    <sect3 id="mergemaster">
      <sect3info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Συνεισφορά του </contrib>
	  </author>
	</authorgroup>
      </sect3info>

      <title><command>mergemaster</command></title>
      <indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>Το βοηθητικό πρόγραμμα &man.mergemaster.8; είναι ένα Bourne
	script το οποίο θα σας βοηθήσει να καθορίσετε τις διαφορές μεταξύ
	των εγκατεστημένων στο <filename>/etc</filename> αρχείων ρυθμίσεων,
	και των αντίστοιχων στο δέντρο πηγαίου κώδικα στο
	<filename>/usr/src/etc</filename>.  Αυτή είναι και η συνιστώμενη
	λύση για να ενημερώσετε τα αρχεία ρυθμίσεων του συστήματος με τυχόν
	αλλαγές που έχουν γίνει στον νέο πηγαίο κώδικα.</para>

      <para>Για να ξεκινήσετε, απλώς γράψτε <command>mergemaster</command>
	στην προτροπή της γραμμής εντολών και παρακολουθήστε την καθώς
	λειτουργεί.  Το <command>mergemaster</command> θα δημιουργήσει ένα
	προσωρινό περιβάλλον root, από το <filename>/</filename> και κάτω,
	και θα το γεμίσει με διάφορα αρχεία ρυθμίσεων του συστήματος.  Έπειτα
	θα γίνει σύγκριση αυτών των αρχείων με τα αντίστοιχα που βρίσκονται
	ήδη εγκατεστημένα στο σύστημα σας.  Στο σημείο αυτό, θα σας δείξει
	τα αρχεία που διαφέρουν με μορφή &man.diff.1;, όπου οι γραμμές που
	έχουν τροποποιηθεί ή είναι νέες θα φαίνονται με ένα
	<option>+</option>, ενώ με το <option>-</option> θα φαίνονται οι
	γραμμές που είτε αφαιρούνται εντελώς ή που αντικαθίστανται από μια
	νέα γραμμή.  Δείτε τη σελίδα manual του &man.diff.1; για περισσότερες
	πληροφορίες σχετικά με τη σύνταξη του &man.diff.1; και για τον τρόπο
	με τον οποίο φαίνονται οι διαφορές μεταξύ των αρχείων.</para>

      <para>Το &man.mergemaster.8; θα σας δείξει έπειτα κάθε αρχείο που
	παρουσιάζει διαφορές, και στο σημείο αυτό θα έχετε την δυνατότητα
	είτε να διαγράψετε το νέο αρχείο (το οποίο αναφέρεται ως προσωρινό
	αρχείο), είτε να εγκαταστήσετε το προσωρινό αρχείο χωρίς να κάνετε
	σε αυτό καμιά αλλαγή, είτε να συγχωνεύσετε τις αλλαγές των δύο
	αρχείων, ή τέλος να ξαναδείτε τις διαφορές μέσω της
	&man.diff.1;.</para>

      <para>Αν επιλέξετε να διαγράψετε το προσωρινό αρχείο, το
	&man.mergemaster.8; θα καταλάβει ότι επιθυμείτε να διατηρήσετε το
	τρέχον αρχείο σας χωρίς αλλαγές, και να διαγράψετε τη νέα έκδοση.
	Η επιλογή αυτή γενικά δεν συνίσταται, εκτός αν δεν βλέπετε κανένα
	λόγο να αλλάξετε το τρέχον αρχείο.  Μπορείτε να δείτε βοήθεια
	οποιαδήποτε στιγμή κατά τη διάρκεια της διαδικασίας, πληκτρολογώντας
	<keycap>?</keycap> στην προτροπή του &man.mergemaster.8;.  Αν
	αποφασίσετε να παραλείψετε κάποιο αρχείο, αυτό θα εμφανιστεί
	ξανά μετά το τέλος όλων των άλλων αρχείων.</para>

      <para>Αν επιλέξετε να εγκαταστήσετε το προσωρινό αρχείο χωρίς αλλαγές,
	αυτό θα αντικαταστήσει το ήδη εγκατεστημένο σας αρχείο.  Αυτή είναι
	και η καλύτερη επιλογή για τα αρχεία τα οποία δεν έχετε αλλάξει
	εσείς χειροκίνητα.</para>

      <para>Αν επιλέξετε να συγχωνεύσετε τα δύο αρχεία, θα εμφανιστεί ένας
	επεξεργαστής κειμένου με τα περιεχόμενα και των δύο αρχείων.
	Μπορείτε τώρα να τα συγχωνεύσετε παρατηρώντας ταυτόχρονα και τα δύο
	αρχεία δίπλα-δίπλα, και επιλέγοντας τμήματα και από τα δύο για να
	δημιουργήσετε την τελική έκδοση.  Κατά τη σύγκριση αυτή, μπορείτε να
	χρησιμοποιήσετε το πλήκτρο <keycap>l</keycap> για να επιλέξετε τα
	περιεχόμενα που φαίνονται στην αριστερή πλευρά, ή το
	<keycap>r</keycap> για τα αντίστοιχα περιεχόμενα στη δεξιά.
	Το τελικό αποτέλεσμα θα είναι ένα αρχείο που θα αποτελείται από
	τμήματα και των δύο αρχείων, και το οποίο μπορείτε να εγκαταστήσετε.
	Η επιλογή αυτή χρησιμοποιείται συνήθως για αρχεία των οποίων το
	περιεχόμενο έχει μεταβληθεί από το χρήστη.</para>

      <para>Αν επιλέξετε να δείτε ξανά τις διαφορές μέσω της &man.diff.1;,
	αυτές θα εμφανιστούν ακριβώς όπως έγινε και πριν
	σας ρωτήσει το &man.mergemaster.8; να επιλέξετε τι θέλετε να κάνετε
	με το αρχείο.</para>

      <para>Μόλις ολοκληρωθεί η λειτουργία του &man.mergemaster.8; στα αρχεία
	συστήματος, θα σας ρωτήσει για άλλες επιλογές.
	Το &man.mergemaster.8; ίσως σας ρωτήσει αν θέλετε να αναδημιουργήσετε
	το αρχείο των κωδικών (password file), και θα τελειώσει δίνοντας σας
	την επιλογή να διαγράψετε τυχόν προσωρινά αρχεία που δημιουργήθηκαν
	κατά την διαδικασία.</para>
      </sect3>

      <sect3>
	<title>Χειροκίνητη Ενημέρωση</title>

      <para>Αν επιθυμείτε να κάνετε την ενημέρωση χειροκίνητα, δεν μπορείτε
	απλώς να αντιγράψετε τα αρχεία από τον κατάλογο
	<filename>/usr/src/etc</filename> στον <filename>/etc</filename> και
	να περιμένετε ότι το σύστημα σας θα λειτουργήσει σωστά.  Κάποια από
	αυτά τα αρχεία θα πρέπει να <quote>εγκατασταθούν</quote> πρώτα.  Αυτό
	συμβαίνει επειδή ο κατάλογος <filename>/usr/src/etc</filename>
	<emphasis>δεν είναι</emphasis> κανονικό αντίγραφο του
	<filename>/etc</filename>.  Επιπρόσθετα, υπάρχουν αρχεία τα οποία
	πρέπει να βρίσκονται στον κατάλογο <filename>/etc</filename>, αλλά
	δεν υπάρχουν στον <filename>/usr/src/etc</filename>.</para>

      <para>Αν χρησιμοποιείτε το &man.mergemaster.8; (όπως και συνίσταται),
	μπορείτε να διαβάσετε κατευθείαν την <link
	  linkend="updating-upgrading-rebooting">επόμενη ενότητα</link>.</para>

      <para>Ο απλούστερος τρόπος να το κάνετε αυτό χειροκίνητα, είναι να
	εγκαταστήσετε τα αρχεία σε ένα νέο κατάλογο, και έπειτα να τα
	εξετάσετε ένα-ένα ψάχνοντας για τις αλλαγές.</para>

      <warning>
	<title>Κρατήστε Ένα Αντίγραφο Ασφαλείας του Καταλόγου
	  <filename>/etc</filename></title>

	<para>Αν και θεωρητικά, τίποτα δεν πρόκειται να πειράξει αυτό τον
	  κατάλογο αυτόματα, είναι πάντα καλύτερα να είμαστε σίγουροι.
	  Για το λόγο αυτό, αντιγράψτε τον υπάρχοντα κατάλογο
	  <filename>/etc</filename> σε κάποιο ασφαλές μέρος.  Χρησιμοποιήστε
	  μια εντολή όπως η παρακάτω:</para>

	<screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	<para>Η επιλογή <option>-R</option> πραγματοποιεί αναδρομική
	  αντιγραφή, ενώ η <option>-p</option> διατηρεί τα δικαιώματα, την
	  ιδιοκτησία, τις ημερομηνίες των αρχείων, κ.ο.κ.</para>
      </warning>

      <para>θα πρέπει να δημιουργήσετε μια ψευτο-δομή καταλόγων για να
	εγκαταστήσετε το νέο κατάλογο <filename>/etc</filename> και άλλα
	αρχεία.  Μια λογική επιλογή είναι ο κατάλογος
	<filename>/var/tmp/root</filename>, και κάτω από αυτόν, θα πρέπει
	επίσης να δημιουργήσετε και μια ολόκληρη σειρά από τους υποκαταλόγους
	που απαιτούνται.</para>

      <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

      <para>Οι παραπάνω εντολές θα δημιουργήσουν την απαιτούμενη δομή
	καταλόγων και θα εγκαταστήσουν τα αρχεία.  Μεγάλο μέρος των
	υποκαταλόγων που έχουν δημιουργηθεί κάτω από τον
	<filename>/var/tmp/root</filename> είναι άδειοι, και πρέπει να
	διαγραφούν.  Ο απλούστερος τρόπος για να γίνει αυτό, φαίνεται
	παρακάτω:</para>

      <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

      <para>Αυτό θα διαγράψει όλους τους άδειους υποκαταλόγους.  (Η έξοδος
	σφάλματος ανακατευθύνεται στο <filename>/dev/null</filename> ώστε
	να μην εμφανίζονται στην οθόνη προειδοποιήσεις για καταλόγους που
	δεν είναι άδειοι.)</para>

      <para>Τώρα, ο <filename>/var/tmp/root</filename> περιέχει όλα τα αρχεία
	που θα πρέπει να τοποθετηθούν σε κατάλληλες θέσεις κάτω από τον
	<filename>/</filename>.  Θα πρέπει τώρα να διατρέξετε καθένα από
	αυτά τα αρχεία, και να καθορίσετε πως καθένα από αυτά διαφέρει από
	το αντίστοιχο υπάρχον (εγκατεστημένο) αρχείο.</para>

      <para>Σημειώστε ότι κάποια από τα αρχεία τα οποία έχουν
	εγκατασταθεί στον <filename>/var/tmp/root</filename> έχουν μια
	αρχική <quote>.</quote>.  Τη στιγμή που γράφονται αυτές οι γραμμές,
	τα μόνα αρχεία στα οποία συμβαίνει αυτό είναι τα αρχεία εκκίνησης
	του κελύφους στον κατάλογο <filename>/var/tmp/root/</filename> και
	<filename>/var/tmp/root/root/</filename>, αν και μπορεί να υπάρχουν
	και άλλα (ανάλογα με το πότε διαβάζετε το κείμενο).  Βεβαιωθείτε ότι
	χρησιμοποιείτε την εντολή <command>ls -a</command> για να τα δείτε
	όλα.</para>

      <para>Ο απλούστερος τρόπος για να συγκρίνετε δύο αρχεία, είναι να
	χρησιμοποιήσετε την εντολή &man.diff.1;:</para>

      <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

      <para>Η παραπάνω εντολή θα σας δείξει τις διαφορές μεταξύ του αρχείου
	<filename>/etc/shells</filename> και του νέου αρχείου
	<filename>/var/tmp/root/etc/shells</filename>.  Χρησιμοποιήστε τις
	διαφορές αυτές για να αποφασίσετε αν θα πρέπει να συγχωνεύσετε τις
	αλλαγές που έχετε κάνει, ή απλώς να αντιγράψετε το παλιό σας αρχείο
	πάνω από το νέο.</para>

      <tip>
	<title>Προσθέστε την Ημερομηνία στο Όνομα του Νέου Root Καταλόγου,
	  (<filename>/var/tmp/root</filename>) Ώστε να Μπορείτε Εύκολα να
	  Συγκρίνετε Διαφορετικές Εκδόσεις Μεταξύ τους</title>

	<para>Αν μεταγλωττίζετε συχνά το βασικό σύστημα, θα πρέπει επίσης
	  να ενημερώνετε συχνά τον κατάλογο <filename>/etc</filename>, το
	  οποίο μπορεί να είναι ενοχλητικό.</para>

	<para>Μπορείτε να επιταχύνετε αυτή τη διαδικασία, τηρώντας ένα
	  αντίγραφο του τελευταίου σετ αλλαγμένων αρχείων τα οποία
	  συγχωνεύσατε στον κατάλογο <filename>/etc</filename>.  Η παρακάτω
	  διαδικασία θα σας δώσει μια ιδέα για το πως μπορεί να
	  γίνει αυτό:</para>

	<procedure>
	  <step>
	    <para>Μεταγλωττίστε το βασικό σύστημα όπως κάνετε συνήθως.  Όταν
	      θέλετε να ενημερώσετε τον <filename>/etc</filename> και τους
	      άλλους καταλόγους, δώστε στον κατάλογο προορισμού ένα όνομα
	      βασισμένο στην τρέχουσα ημερομηνία.  Αν το κάνατε αυτό
	      στις 14 Φεβρουαρίου 1998, θα γράφατε κάτι σαν το
	      παρακάτω:</para>

	    <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	  </step>

	  <step>
	    <para>Συγχωνεύστε τις αλλαγές από αυτό τον κατάλογο, με τον τρόπο
	      που περιγράψαμε παραπάνω.</para>

	    <para><emphasis>Μην διαγράψετε</emphasis> τον κατάλογο
	      <filename>/var/tmp/root-19980214</filename> όταν τελειώσετε
	      με την παραπάνω διαδικασία.</para>
	  </step>

	  <step>
	    <para>Όταν κατεβάσετε την τελευταία έκδοση του πηγαίου κώδικα και
	      τον μεταγλωττίσετε ξανά, ακολουθήστε το βήμα 1.  Αυτό θα σας
	      δώσει ένα κατάλογο που μπορεί να ονομάζεται
	      <filename>/var/tmp/root-19980221</filename> (αν ανάμεσα στις
	      δύο μεταγλωττίσεις παρεμβάλλεται διάστημα μιας
	      εβδομάδας).</para>
	  </step>

	  <step>
	    <para>Μπορείτε τώρα να δείτε τις διαφορές που υπάρχουν ανάμεσα
	      στις δύο εβδομάδες, χρησιμοποιώντας την εντολή
	      &man.diff.1; σε αναδρομική λειτουργία για να δημιουργήσετε τις
	      διαφορές μεταξύ των δύο καταλόγων:</para>

	    <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	    <para>Τυπικά, αυτό το σετ αλλαγών θα είναι πολύ μικρότερο από
	      αυτό μεταξύ του <filename>/var/tmp/root-19980221/etc</filename>
	      και του <filename>/etc</filename>.  Καθώς αυτό το σετ αλλαγών
	      είναι μικρότερο, είναι και πιο εύκολο να εφαρμόσετε αυτές
	      τις αλλαγές στον κατάλογο <filename>/etc</filename>.</para>
	  </step>

	  <step>
	    <para>Μπορείτε τώρα να διαγράψετε τον παλιότερο από τους δύο
	      καταλόγους <filename>/var/tmp/root-*</filename>:</para>

	    <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	  </step>

	  <step>
	    <para>Επαναλάβετε αυτή τη διαδικασία κάθε φορά που θέλετε να
	      συγχωνεύσετε τις αλλαγές στον κατάλογο
	      <filename>/etc</filename>.</para>
	  </step>
	</procedure>

	<para>Μπορείτε επίσης να χρησιμοποιήσετε την εντολή &man.date.1; για
	  να αυτοματοποιήσετε την δημιουργία των ονομάτων καταλόγων:</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
      </tip>
      </sect3>
    </sect2>

    <sect2 id="updating-upgrading-rebooting">
      <title>Επανεκκίνηση</title>

      <para>Η διαδικασία έχει πλέον ολοκληρωθεί.  Αφού επαληθεύσετε ότι όλα
	βρίσκονται στις σωστές θέσεις, μπορείτε να επανεκκινήσετε το σύστημα.
	Μια απλή εντολή &man.shutdown.8; είναι επαρκής:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Ολοκλήρωση</title>

      <para>Έχετε πλέον αναβαθμίσει το &os; σύστημα σας.  Συγχαρητήρια.</para>

      <para>Αν τα πράγματα δεν πήγαν εντελώς σωστά, είναι εύκολο να
	μεταγλωττίσετε ξανά οποιοδήποτε τμήμα του συστήματος.
	Για παράδειγμα, αν διαγράψετε κατά λάθος το
	<filename>/etc/magic</filename> ως μέρος μιας αναβάθμισης ή
	συγχώνευσης του <filename>/etc</filename>, η εντολή &man.file.1;
	θα σταματήσει να λειτουργεί.  Στην περίπτωση αυτή, η διόρθωση είναι
	να εκτελέσετε:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Ερωτήσεις</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Πρέπει να μεταγλωττίσω ξανά ολόκληρο το βασικό σύστημα σε
	      κάθε αλλαγή;</para>
	  </question>

	  <answer>
	    <para>Δεν υπάρχει εύκολη απάντηση σε αυτό το ερώτημα, καθώς
	      εξαρτάται από τη φύση της αλλαγής.  Για παράδειγμα, αν
	      εκτελέσετε το <application>CVSup</application>, και δείτε ότι
	      ενημερώθηκαν τα παρακάτω αρχεία:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>Το πιθανότερο είναι ότι δεν χρειάζεται να μεταγλωττίσετε
	      ξανά όλο το βασικό σύστημα.  Μπορείτε απλώς να μεταβείτε στους
	      σχετικούς υποκαταλόγους και να εκτελέσετε το
	      <command>make all install</command>, και θα έχετε τελειώσει.
	      Αν όμως υπάρχει κάποια σημαντική αλλαγή, για παράδειγμα το
	      <filename>src/lib/libc/stdlib</filename>, θα πρέπει είτε να
	      επαναμεταγλωττίσετε το βασικό σύστημα, ή τουλάχιστον αυτά τα
	      κομμάτια τα οποία είναι στατικά συνδεδεμένα (όπως και οτιδήποτε
	      άλλο έχετε προσθέσει εσείς και το οποίο είναι στατικά
	      συνδεδεμένο).</para>

	    <para>Τελικά, η απόφαση είναι δική σας.  Μπορεί να είστε
	      ικανοποιημένος αν μεταγλωττίζετε το βασικό σύστημα κάθε δύο
	      βδομάδες, αφήνοντας τις αλλαγές να συγκεντρωθούν στη διάρκεια
	      αυτού του διαστήματος.  Ή μπορεί να θέλετε να μεταγλωττίσετε
	      μόνο τις αλλαγές, αν έχετε την πεποίθηση ότι μπορείτε να
	      εντοπίσετε όλες τις εξαρτήσεις τους.</para>

	    <para>Και φυσικά, όλα αυτά εξαρτώνται από το πόσο συχνά θέλετε να
	      ενημερώνετε το σύστημα σας, και από το αν ακολουθείτε το
	      &os.stable; ή το &os.current;.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Η μεταγλώττιση μου απέτυχε με πλήθος μηνυμάτων signal 11
	      (ή λάθη με άλλα σήματα).  Τι έχει συμβεί;</para>
	  </question>
	  <indexterm><primary>signal 11</primary></indexterm>

	  <answer>
	    <para>Αυτό συνήθως δείχνει προβλήματα υλικού.  Η διαδικασία
	      μεταγλώττισης του βασικού συστήματος είναι ένας αποτελεσματικός
	      τρόπος να δοκιμάσετε το υλικό σας στα όρια του, και συχνά θα
	      δείξει προβλήματα που σχετίζονται με τη μνήμη.  Το πιο σύνηθες
	      σύμπτωμα, είναι η απότομη διακοπή της μεταγλώττισης, με τον
	      μεταγλωττιστή να φαίνεται ότι έχει λάβει κάποιο μυστηριώδες
	      σήμα.</para>

	    <para>Ένα σίγουρο σημάδι για το παραπάνω, είναι να επανεκκινήσετε
	      τη διαδικασία, και αυτή να σταματήσει σε διαφορετικό
	      σημείο.</para>

	    <para>Στην περίπτωση αυτή, δεν υπάρχουν και πολλά που μπορείτε να
	      κάνετε, εκτός από το να αρχίσετε να αλλάζετε εξαρτήματα στο
	      μηχάνημα σας μέχρι να βρείτε αυτό που είναι υπαίτιο.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Μπορώ να διαγράψω το <filename>/usr/obj</filename> όταν
	      τελειώσω;</para>
	  </question>

	  <answer>
	    <para>Η σύντομη απάντηση είναι ναι.</para>

	    <para>Το <filename>/usr/obj</filename> περιέχει όλα τα
	      αντικειμενικά αρχεία που παράγονται κατά τη διάρκεια της
	      μεταγλώττισης.  Συνήθως, ένα από τα πρώτα βήματα στην
	      διαδικασία <command>make buildworld</command> είναι η διαγραφή
	      αυτού του καταλόγου και η αναδημιουργία του.  Στην περίπτωση
	      αυτή, το να κρατήσετε τον κατάλογο
	      <filename>/usr/obj</filename> αφού έχετε τελειώσει, δεν έχει
	      και πολύ νόημα, ενώ αν τον σβήσετε θα κερδίσετε ένα μεγάλο
	      κομμάτι ελεύθερου χώρου (την παρούσα στιγμή περίπου
	      340&nbsp;MB).</para>

	    <para>Όμως, αν ξέρετε τι κάνετε, μπορείτε να οδηγήσετε το
	      <command>make buildworld</command> να παραλείψει αυτό το βήμα.
	      Αυτό θα επιταχύνει ιδιαίτερα τις νέες μεταγλωττίσεις, καθώς
	      τα περισσότερα τμήματα του πηγαίου κώδικα δεν θα χρειάζονται
	      ξανά μεταγλώττιση.  Το μειονέκτημα είναι ότι ορισμένες φορές
	      εμφανίζονται προβλήματα που έχουν σχέση με όχι και τόσο
	      εμφανείς εξαρτήσεις, και μπορεί να οδηγήσουν σε μυστηριώδη
	      αποτυχία της μεταγλώττισης.  Τέτοια προβλήματα συχνά δημιουργούν
	      <quote>θόρυβο</quote> στις λίστες του &os;, όταν κάποιος χρήστης
	      παραπονιέται ότι η μεταγλώττιση του αποτυγχάνει, χωρίς να
	      αντιλαμβάνεται ότι αυτό οφείλεται στην προσπάθεια του να
	      συντομεύσει την διαδικασία.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Μπορώ να συνεχίσω μια μεταγλώττιση που διέκοψα;</para>
	  </question>

	  <answer>
	    <para>Αυτό εξαρτάται από το πόσο έχετε προχωρήσει στη διαδικασία
	      μέχρι τη στιγμή που βρήκατε το πρόβλημα.</para>

	    <para><emphasis>Σε γενικές γραμμές</emphasis> (και αυτός δεν
	      είναι κανόνας που ισχύει πάντα), η διεργασία του
	      <command>make buildworld</command> μεταγλωττίζει νέα αντίγραφα
	      βασικών εργαλείων (όπως τα &man.gcc.1;, και &man.make.1;) καθώς
	      και των βιβλιοθηκών συστήματος.  Έπειτα εγκαθιστώνται αυτά
	      τα εργαλεία και οι βιβλιοθήκες.  Τα νέα εργαλεία και
	      βιβλιοθήκες χρησιμοποιούνται έπειτα για να επαναμεταγλωττίσουν
	      τους εαυτούς τους, και εγκαθίστανται ξανά.  Ολόκληρο το σύστημα
	      (το οποίο τώρα περιλαμβάνει και τα συνηθισμένα προγράμματα
	      χρήστη όπως το &man.ls.1; ή το &man.grep.1;)
	      επαναμεταγλωττίζεται χρησιμοποιώντας τα νέα αρχεία του
	      συστήματος.</para>

	    <para>Αν βρίσκεστε στο τελευταίο στάδιο, το οποίο θα το γνωρίζετε
	      κοιτάζοντας την έξοδο που έχετε αποθηκεύσει, είναι σχετικά
	      ασφαλές να κάνετε:</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Με τον τρόπο αυτό δεν θα αναιρέσετε την εργασία που έχει
	      γίνει από το προηγούμενο
	      <command>make buildworld</command>.</para>

	    <para>Αν δείτε το μήνυμα:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>στην έξοδο της εντολής <command>make buildworld</command>,
	      τότε είναι μάλλον ασφαλές να προχωρήσετε με αυτό τον
	      τρόπο.</para>

	    <para>Αν δεν δείτε αυτό το μήνυμα, ή αν δεν είστε σίγουρος, τότε
	      είναι καλύτερα να κάνετε πλήρη μεταγλώττιση παρά να μετανιώνετε
	      αργότερα.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Πως μπορώ να επιταχύνω τη μεταγλώττιση του βασικού
	      συστήματος;</para>
	  </question>

	  <answer>
	    <itemizedlist>
	      <listitem>
		<para>Εκτελέστε την σε κατάσταση ενός χρήστη.</para>
	      </listitem>

	      <listitem>
		<para>Βάλτε τους καταλόγους <filename>/usr/src</filename>
		  και <filename>/usr/obj</filename> σε διαφορετικά συστήματα
		  αρχείων τα οποία βρίσκονται και σε διαφορετικούς φυσικούς
		  δίσκους.  Αν είναι δυνατόν, βάλτε αυτούς τους δίσκους σε
		  χωριστούς ελεγκτές.</para>
	      </listitem>

	      <listitem>
		<para>Ακόμα καλύτερα, μοιράστε αυτά τα συστήματα αρχείων
		  σε πολλαπλούς δίσκους, χρησιμοποιώντας το πρόγραμμα
		  οδήγησης &man.ccd.4; (concatenated disk driver, οδήγησης
		  συνενωμένων δίσκων).</para>
	      </listitem>

	      <listitem>
		<para>Απενεργοποιήστε το profiling (θέστε την μεταβλητή
		  <quote>NO_PROFILE=true</quote> στο
		  <filename>/etc/make.conf</filename>).  Είναι σχεδόν σίγουρο
		  ότι δεν το χρειάζεστε.</para>
	      </listitem>

	      <listitem>
		<para>Στο αρχείο <filename>/etc/make.conf</filename>, θέστε
		  το <makevar>CFLAGS</makevar> σε κάτι όπως
		  <option>-O -pipe</option>.  Η βελτιστοποίηση
		  <option>-O2</option> χρειάζεται αρκετά περισσότερο χρόνο,
		  και η διαφορά απόδοσης μεταξύ
		  <option>-O</option> και <option>-O2</option> είναι συνήθως
		  αμελητέα.  Το <option>-pipe</option> επιτρέπει στον
		  μεταγλωττιστή να χρησιμοποιήσει pipes για επικοινωνία αντί
		  για προσωρινά αρχεία.  Αυτό καταναλώνει περισσότερη μνήμη,
		  αλλά χρησιμοποιεί λιγότερο το σκληρό δίσκο.</para>
	      </listitem>

	      <listitem>
		<para>Χρησιμοποιήστε την επιλογή
		  <option>-j<replaceable>n</replaceable></option> στο
		  &man.make.1; ώστε να εκτελούνται παράλληλα πολλαπλές
		  διεργασίες μεταγλώττισης.  Αυτό συνήθως βοηθάει ακόμα και
		  σε περίπτωση που έχετε μηχάνημα με ένα επεξεργαστή.</para>
	      </listitem>

	      <listitem>
		<para>Μπορείτε να προσαρτήσετε (ή να επαναπροσαρτήσετε) το
		  σύστημα αρχείων στο οποίο είναι αποθηκευμένο το
		  <filename>/usr/src</filename> με την επιλογή
		  <option>noatime</option>.  Αυτό αποτρέπει την καταγραφή
		  ημερομηνίας / ώρας πρόσβασης στο σύστημα αρχείων.  Κατά πάσα
		  πιθανότητα, δεν χρειάζεστε αυτή την πληροφορία έτσι και
		  αλλιώς.</para>

		  <screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		  <warning>
		    <para>Το παράδειγμα προϋποθέτει ότι έχετε το
		      <filename>/usr/src</filename> στο δικό του σύστημα
		      αρχείων.  Αν αυτό δεν συμβαίνει (αν είναι μέρος του
		      <filename>/usr</filename> για παράδειγμα) θα χρειαστεί
		      να χρησιμοποιήσετε αυτό το σημείο προσάρτησης, και όχι
		      το <filename>/usr/src</filename>.</para>
		  </warning>
	      </listitem>

	      <listitem>
		<para>Μπορείτε να προσαρτήσετε (ή να επαναπροσαρτήσετε) το
		  σύστημα αρχείων που περιέχει το
		  <filename>/usr/obj</filename> με την επιλογή
		  <option>async</option>.  Με τον τρόπο αυτό, οι εγγραφές στο
		  δίσκο θα γίνονται ασύγχρονα.  Με άλλα λόγια, οι εγγραφές
		  φαίνεται ότι ολοκληρώνονται άμεσα, ενώ η πραγματική εγγραφή
		  στο δίσκο γίνεται λίγα δευτερόλεπτα αργότερα.  Αυτό
		  επιτρέπει την ομαδοποίηση των εγγραφών, το οποίο μπορεί να
		  προσφέρει δραματική βελτίωση απόδοσης.</para>

		<warning>
		  <para>Να έχετε υπόψιν σας ότι αυτή η επιλογή μπορεί να
		    κάνει το σύστημα αρχείων σας πολύ πιο ευαίσθητο.  Με την
		    επιλογή αυτή, υπάρχει αυξημένη πιθανότητα το σύστημα
		    αρχείων να βρεθεί σε μη
		    επισκευάσιμη κατάσταση αν υπάρξει διακοπή
		    ρεύματος.</para>

		  <para>Αν το σύστημα αρχείων περιέχει μόνο το
		    <filename>/usr/obj</filename>, το παραπάνω δεν είναι
		    πρόβλημα.  Αν ωστόσο έχετε και άλλα πολύτιμα δεδομένα
		    στο ίδιο σύστημα αρχείων, σιγουρευτείτε ότι έχετε
		    ενημερωμένα αντίγραφα ασφαλείας πριν ενεργοποιήσετε αυτή
		    την επιλογή.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Όπως και προηγουμένως, αν το
		    <filename>/usr/obj</filename> δεν είναι σύστημα αρχείων
		    από μόνο του, αντικαταστήστε το στο παράδειγμα με το
		    όνομα του πραγματικού σημείου προσάρτησης.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Τι να κάνω αν κάτι πάει στραβά;</para>
	  </question>

	  <answer>
	    <para>Σιγουρευτείτε ότι το περιβάλλον σας δεν έχει υπολείμματα
	      από προηγούμενες μεταγλωττίσεις.  Αυτό είναι αρκετά απλό.</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Ναι, θα πρέπει να εκτελέσετε το
	      <command>make cleandir</command> δύο φορές.</para>

	    <para>Επανεκκινήστε έπειτα όλη τη διαδικασία, ξεκινώντας με το
	      <command>make buildworld</command>.</para>

	    <para>Αν έχετε ακόμα προβλήματα, στείλτε το μήνυμα λάθους και την
	      έξοδο του <command>uname -a</command> στην &a.questions;.  Να
	      είστε προετοιμασμένοι να απαντήσετε επιπλέον ερωτήσεις σχετικά
	      με την εγκατάσταση σας!</para>
	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Συνεισφορά του </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Διαδικασία για Πολλαπλά Μηχανήματα</title>
    <indexterm>
      <primary>NFS</primary>
      <secondary>installing multiple machines</secondary>
    </indexterm>

    <para>Αν έχετε πολλαπλά μηχανήματα στα οποία πρόκειται να χρησιμοποιήσετε
      το ίδιο δέντρο πηγαίου κώδικα, είναι σπατάλη πόρων (δίσκου, δικτύου και
      επεξεργαστή) να επαναλαμβάνετε σε όλα τη διαδικασία ανάκτησης και
      μεταγλώττισης.  Η λύση είναι να ορίσετε ένα μηχάνημα να εκτελεί το
      μεγαλύτερο μέρος της εργασίας, ενώ τα υπόλοιπα θα μπορούν να την
      ανακτούν μέσω NFS.  Στην ενότητα αυτή θα παρουσιάσουμε ένα τρόπο με
      τον οποίο μπορεί να γίνει αυτό.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Προκαταρκτικά</title>

      <para>Πρώτα από όλα, αναγνωρίστε το σετ των μηχανημάτων στα οποία
	σκοπεύετε να χρησιμοποιήσετε τα ίδια εκτελέσιμα.  Θα ονομάσουμε αυτή
	την ομάδα <emphasis>σετ μεταγλώττισης</emphasis>.  Κάθε μηχάνημα
	μπορεί να έχει δικό του προσαρμοσμένο πυρήνα, αλλά θα έχουν όλα τα
	ίδια εκτελέσιμα userland.  Από το σετ αυτό, επιλέξτε ένα μηχάνημα το
	οποίο θα γίνει το <emphasis>μηχάνημα μεταγλώττισης</emphasis>.
	Θα είναι το μηχάνημα στο οποίο θα μεταγλωττίζεται το βασικό σύστημα
	και ο πυρήνας.  Το ιδανικό είναι να επιλέξετε ένα γρήγορο μηχάνημα,
	στο οποίο να υπάρχει αρκετός ελεύθερος χρόνος στον επεξεργαστή για να
	εκτελεί τα <command>make buildworld</command> και
	<command>make buildkernel</command>.  Θα πρέπει επίσης να επιλέξετε
	ένα <emphasis>μηχάνημα δοκιμών</emphasis> στο οποίο θα δοκιμάζετε τις
	ενημερώσεις λογισμικού πριν τις μεταφέρετε στην παραγωγή.  Μπορεί να
	είναι και το ίδιο το μηχάνημα μεταγλώττισης, αλλά αυτό δεν είναι
	απαραίτητο.</para>

      <para>Όλα τα μηχανήματα στο σετ μεταγλώττισης χρειάζεται να
	προσαρτήσουν το <filename>/usr/obj</filename> και το
	<filename>/usr/src</filename> από το ίδιο μηχάνημα, και στο ίδιο
	σημείο προσάρτησης.  Το ιδανικό είναι αυτά τα δύο συστήματα αρχείων
	να βρίσκονται σε διαφορετικό φυσικό δίσκο στο μηχάνημα μεταγλώττισης,
	αλλά μπορείτε να τα προσαρτήσετε μέσω NFS ακόμα και σε αυτό το
	μηχάνημα.  Αν έχετε πολλαπλά σετ μεταγλώττισης, το
	<filename>/usr/src</filename> θα πρέπει να βρίσκεται σε ένα από τα
	μηχανήματα μεταγλώττισης, και να προσαρτάται στα υπόλοιπα μέσω
	NFS.</para>

      <para>Τέλος, βεβαιωθείτε ότι τα αρχεία
	<filename>/etc/make.conf</filename> και
	<filename>/etc/src.conf</filename> σε όλα τα μηχανήματα του σετ
	μεταγλώττισης, είναι ίδια με τα αντίστοιχα στο μηχάνημα μεταγλώττισης.
	Αυτό σημαίνει ότι το μηχάνημα μεταγλώττισης θα πρέπει να
	μεταγλωττίζει όλα τα τμήματα του βασικού συστήματος τα οποία θα
	εγκατασταθούν σε κάθε μηχάνημα του σετ.  Επίσης, σε κάθε μηχάνημα
	στο σετ μεταγλώττισης θα πρέπει να οριστεί το όνομα του δικού του
	προσαρμοσμένου πυρήνα μέσω της μεταβλητής
	<makevar>KERNCONF</makevar> στο <filename>/etc/make.conf</filename>,
	ενώ και το μηχάνημα μεταγλώττισης θα πρέπει να έχει μια λίστα όλων
	των άλλων στο <makevar>KERNCONF</makevar>, ξεκινώντας από το δικό
	του.  Το μηχάνημα μεταγλώττισης, θα πρέπει να έχει τα αρχεία ρύθμισης
	του πυρήνα όλων των άλλων μηχανημάτων στον κατάλογο
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
	αν πρόκειται να μεταγλωττίζει τους πυρήνες τους.</para>
    </sect2>

    <sect2>
      <title>Το Βασικό Σύστημα</title>

      <para>Έχοντας πραγματοποιήσει όλα τα παραπάνω, είστε έτοιμος να
	μεταγλωττίσετε τα πάντα.  Μεταγλωττίστε τον πυρήνα και το βασικό
	σύστημα όπως περιγράψαμε στο <xref linkend="make-buildworld">
	χρησιμοποιώντας το μηχάνημα μεταγλώττισης, αλλά μην εγκαταστήσετε
	τίποτα.  Μετά το τέλος της μεταγλώττισης, χρησιμοποιήστε το μηχάνημα
	δοκιμών και εγκαταστήστε τον πυρήνα που μόλις δημιουργήσατε.  Αν το
	μηχάνημα αυτό προσαρτά το <filename>/usr/src</filename> και το
	<filename>/usr/obj</filename> μέσω NFS, όταν το επανεκκινήσετε σε
	κατάσταση ενός χρήστη, θα χρειαστεί να ενεργοποιήσετε το δίκτυο και
	να τα προσαρτήσετε.  Ο ευκολότερος τρόπος για αυτό, είναι να
	εκκινήσετε σε κατάσταση πολλαπλών χρηστών και έπειτα να εκτελέσετε
	<command>shutdown now</command> για να μεταβείτε σε κατάσταση ενός
	χρήστη.  Μόλις γίνει αυτό, μπορείτε να εγκαταστήσετε τον νέο πυρήνα
	και το βασικό σύστημα, και να εκτελέσετε το
	<command>mergemaster</command> όπως θα κάνατε συνήθως.  Όταν
	τελειώσετε, επανεκκινήστε αυτό το μηχάνημα στην κανονική λειτουργία
	πολλαπλών χρηστών.</para>

      <para>Όταν βεβαιωθείτε ότι όλα λειτουργούν σωστά στο μηχάνημα δοκιμών,
	χρησιμοποιήστε την ίδια διαδικασία για να εγκαταστήσετε το νέο
	λογισμικό σε κάθε ένα από τα υπόλοιπα μηχανήματα του σετ
	μεταγλώττισης.</para>
    </sect2>

    <sect2>
      <title>Ports</title>

      <para>Μπορείτε να χρησιμοποιήσετε τις ίδιες ιδέες και για το δέντρο
	των ports.  Το πρώτο κρίσιμο βήμα είναι να προσαρτήσετε το
	<filename>/usr/ports</filename> από το ίδιο μηχάνημα, σε όλα τα
	μηχανήματα του σετ μεταγλώττισης.  Μπορείτε έπειτα να ρυθμίσετε το
	<filename>/etc/make.conf</filename> ώστε να διαμοιράζονται τα
	distfiles.  Θα πρέπει να θέσετε το <makevar>DISTDIR</makevar> σε ένα
	κοινόχρηστο κατάλογο, στον οποίο θα δώσετε δικαιώματα εγγραφής σε
	οποιοδήποτε χρήστη έχετε δηλώσει ως <username>root</username> στο
	NFS.  Σε κάθε μηχάνημα θα πρέπει επίσης να οριστεί η μεταβλητή
	<makevar>WRKDIRPREFIX</makevar> ώστε να δείχνει σε ένα τοπικό
	κατάλογο.  Τέλος, αν σκοπεύετε να μεταγλωττίζετε και να διανέμετε
	έτοιμα πακέτα, θα πρέπει να θέσετε την μεταβλητή
	<makevar>PACKAGES</makevar> σε ένα κατάλογο, όπως κάνατε και με την
	<makevar>DISTDIR</makevar>.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     coding: iso-8859-7
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
