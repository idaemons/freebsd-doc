<!-- $Id: admin.sgml,v 1.7 1999-04-18 18:40:45 jesusr Exp $ -->
<!-- The FreeBSD Documentation Spanish Project -->
  <sect>
    <heading>Administraci&oacute;n de sistema<label id="admin"></heading>

    <sect1>
      <heading>&iquest;D&oacute;nde est&aacute;n los ficheros de configuraci&oacute;n de arranque del sistema?</heading>

      <p>De la versi&oacute;n 2.0.5R a la 2.2.1R, el fichero principal de
      configuraci&oacute;n es <tt>/etc/sysconfig</tt>. Todas las opciones son
      especificadas en este fichero y otros como <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rc" name="/etc/rc"> y
      <tt>/etc/netstart</tt>.

      <p>Mira en el fichero <tt>/etc/sysconfig</tt> y cambia los valores
      para tu sistema. Este fichero est&aacute; comentado para ayudar en la
      configuraci&oacute;n

      <p>En versiones posteriores a la 2.2.1 y 3.0 el fichero
      <tt>/etc/sysconfig</tt> fue renombrado como <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)" name="rc.conf">.
      La sintaxis tambi&eacute;n fue retocada para ser mas descriptiva. El 
      fichero <tt>/etc/netstart</tt> tambi&eacute;n fue renombrado como
      <tt>/etc/rc.network</tt> para que todos los ficheros de 
      configuraci&oacute;n puedan ser copiados con el comando <tt>
      <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?cp" name="cp"> /usr/src/etc/rc*
      /etc</tt>.

      <p><tt>/etc/rc.local</tt> existe como siempre y deber&iacute;a ser usado
      para arrancar servicios locales adicionales como <htmlurl
      url="http://www.freebsd.org/cgi/ports.cgi?^inn" name="INN"> o
      programas propios.

      <p>El fichero <tt>/etc/rc.serial</tt> es para la inicializaci&oacute;n
      de puertos serie.

      <p>El fichero <tt>/etc/rc.i386</tt> es para especificaciones propias
      de Intel, como la emulaci&oacute;n iBCS2 o la configuraci&oacute;n de la
      c&oacute;nsola del sistema.

      <p>A partir de la versi&oacute;n 2.1.0R, tambi&eacute;n puedes tener un 
      directorio en el que instalar ficheros de arranque locales especificado en
      <tt>/etc/sysconfig</tt> (o <tt>/etc/rc.conf</tt>):

      <verb>
        # Localizaci&oacute;n de los ficheros de arranque locales.
        local_startup=/usr/local/etc/rc.local.d
      </verb>

      <p>Cada fichero acabado en <tt/.sh/ ser&aacute; ejecutado en orden
      alfab&eacute;tico.

      <p>Si quieres asegurarte de un cierto orden en la ejecuci&oacute;n sin 
      tener que cambiar todos los nombres de los ficheros, puedes usar un 
      esquema similar al siguiente con d&iacute;gitos al principio del nombre 
      de cada fichero:

      <verb>
        10news.sh
        15httpd.sh
        20ssh.sh
      </verb>

      <p>Puede ser visto como "malo" (o SysV :-)) pero nos provee de un
      esquema regular para programas a&ntilde;adidos localmente sin tener que
      hacer ediciones complicadas del fichero <tt>/etc/rc.local</tt>.
      Muchos de los ports/packages asumen que <tt>/usr/local/etc/rc.d</tt>
      es un directorio de arranque local.

    <sect1>
      <heading>&iquest;C&oacute;mo a&ntilde;ado un usuario facilmente?</heading>

      <p>Usa el comando <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?adduser"
      name="adduser">.

      <p>Hay otro package llamado <tt/new-account/ escrito en Perl por
      Ollivier Robert. Pregunta a <tt>&lt;roberto@FreeBSD.ORG&gt;</tt>
      sobre &eacute;l. En estos momentos est&aacute; en desarrollo.

      <p>Para borrar a un usuario, usa el comando <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rmuser" name="rmuser">.

    <sect1>
      <heading>&iquest;C&oacute;mo puedo a&ntilde;adir mi nuevo disco a FreeBSD?</heading>

      <p>La manera m&aacute;s f&aacute;cil de hacer esto es desde el programa de
      instalaci&oacute;n. Puedes arrancar el programa de instalaci&aacute;n 
      ejecutando <tt>/stand/sysinstall</tt> como root.

      <p>Alternativamente, si todav&iacute;a tienes el floppy de 
      instalaci&oacute;n, puedes arrancar desde &eacute;l y usar el editor de 
      etiquetas y particiones.

      <p><label id="2_1-disklabel-fix">Si lo anterior no te funciona o
      si eres masoquista total a quien le gustan los interfaces arcanos
      as&iacute; es como usar el programa
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel"> manualmente:

      <p><em>CUIDADO: Debes leer y entender perfectamente lo que est&aacute;s
      haciendo!. Los comandos aqu&iacute; descritos pueden BORRAR tu sistema.
      Procede con precauci&oacute;n!. Recuerda, un BACKUP es tu amigo</em>.

      <p><tt/sysinstall/ insistir&aacute; en montar algo en / en el editor de
      etiquetas de disco. Tendr&aacute;s que ejecutar manualmente
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel" 
      name="disklabel"> antes de poder ejecutar
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?newfs" name="newfs">/.
      Esto significa que tendr&aacute;s que hacer tu mismo los c&aacute;lculos 
      para las particiones. Mira si puedes obtener informaci&oacute;n del 
      disco con <tt>disklabel -r &lt;diskname&gt;</tt> por ejemplo
      <tt>disklabel -r /dev/rwd0s2</tt> asumiendo que tu nuevo disco es
      wd0, el primer disco IDE, y FreeBSD es el segundo slice (s2). 
      Deber&iacute;as ver algo como esto:-


      <verb>
        # /dev/rwd0s2:
        type: ESDI
        disk: wd0s2
        label:
        flags:
        bytes/sector: 512
        sectors/track: 63
        tracks/cylinder: 64
        sectors/cylinder: 4032
        cylinders: 610
        sectors/unit: 2459520
        rpm: 3600
        interleave: 1
        trackskew: 0
        cylinderskew: 0
        headswitch: 0           # milliseconds
        track-to-track seek: 0  # milliseconds
        drivedata: 0

        8 partitions:
        #        size   offset    fstype   [fsize bsize bps/cpg]
          c:  2459520        0    unused        0     0         # (Cyl. 0 - 609)
          e:  2459520        0    4.2BSD        0     0     0   # (Cyl. 0 - 609)
      </verb>

      <p>Aegurate que el tama&ntilde;o es correcto, en este caso, 2459520
      sectores x 512 bytes/sector / 2**20 (1 Megabyte) = 1200 MB. El resto
      de datos (b/s, t/c, s/c, interleave, etc.) deber&iacute;an funcionar con
      los que salen por defecto con <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel">, pero mira <ref id="ESDI" name="esta nota"> para
      discos antiguos. fsize es el <ref id="fsize" name="tama&ntilde;o de
      fragmento"> del sistema de ficheros y bsize es el
      <ref id="bsize" name="tama&ntilde;o de bloque">. 'c' es la 
      partici&oacute;n que ocupa FreeBSD (o el disco completo en caso de una 
      &uacute;nica partici&oacute;n para FreeBSD), y debe quedar como esta. 
      <em>No deberia ser usada para un sistema de ficheros</em>. La 
      partici&oacute;n 'c' es m&aacute;gica en que es reconocida y usada por 
      el kernel aunque no exista ninguna etiqueta en ella.

      <p>En el caso trivial de querer usar todo el sistema de ficheros
      para FreeBSD, la entrada para el campo "e" tiene que ser corregida
      poniendo fsize a 1023 y bsize a 8192 (8 fragmentos/bloque), los
      cuales son razonables. La entrada correcta para "e" seria:

      <verb>
        e:  2459520        0    4.2BSD     1024  8192
      </verb>

      <p>Ahora el caso mas complicado, donde queremos 2 particiones para
      2 sistemas de ficheros. Siguiendo la <ref id="fsname"
      name="convenci&oacute;n de nombres BSD">, las particiones ser&aacute;n
      <tt /wd0s2e/ y <tt /wd0s2f/. Sup&oacute;n que tenemos 1200MB y
      asignamos 300 para "e" y los restantes 900 para "f". Los datos de
      las particiones ser&iacute;an:

      <verb>
        8 partitions:
        #        size   offset    fstype   [fsize bsize bps/cpg]
        c:  2459520        0    unused        0     0         # (Cyl. 0 - 609)
        e:   614400        0    4.2BSD     1024  8192
        f:  1843200   614400    4.2BSD     1024  8192
      </verb>

      <p><bf /Nota:/ Puedes editar directamente el "disklabel" con
      ''<tt>disklabel -e wd0s2</tt>''. Para m&aacute;s informaci&oacute;n mira 
      en <htmlurl url="http://www.freebsd.org/cgi/man.cgi?disklabel"
      name="disklabel">.

      <p>Si tienes la versi&oacute;n 2.1.5 o superior, y quieres dedicar
      enteramente el disco para FreeBSD sin compartirlo con otros
      sistemas operativos, se pueden reducir las operaciones a
      realizar de la siguiente manera:

      <verb>
        # dd if=/dev/zero of=/dev/rwd0 count=100
        # disklabel -Brw wd0 auto
        # disklabel -e wd0
      </verb>

      <p>El primer comando <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?dd" name="dd"> asegura que
      no hay basura en el inicio del disco que pueda confundir al kernel.
      Lo siguiente a realizar es una generaci&oacute;n autom&aacute;tica de 
      etiqueta usando los procesos por defecto ejecutados en el arranque del
      sistema. La edici&oacute;n de la etiqueta continua de la manera descrita
      anteriormente.

      <p>Has acabado!. Ahora debes inicializar el sistema de ficheros
      con algo como:

      <verb>
        newfs -d0 /dev/rwd0s2e
        newfs -d0 /dev/rwd0s2f
      </verb>

      <p>Dependiendo del nombre del disco y la partici&oacute;n, quiz&aacute;s 
      sea requerida la ejecuci&oacute;n del script <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?MAKEDEV" name="/dev/MAKEDEV">
      para la creaci&oacute;n de los dispositivos.

      <p>Y montar tus nuevos discos/particiones (mira el comando
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?mount" name="mount">)

      <verb>
        mount /dev/wd0s2e /mnt/foo
        mount /dev/wd0s2f /mnt/bar
      </verb>

      <p>Deber&iacute;as editar el fichero <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?fstab(5)" name="/etc/fstab">
      para montar automaticamente los discos/particiones al arrancar el
      sistema.

      <p><bf /Glosario:/

      <descrip>
        <tag><label id="fsize"><bf>Fragment Size (fsize)</bf></tag>
        Unidad b&aacute;sica de almacenamiento para <tt /ffs/.
        M. McKusick, W. Joy, S. Leffler, and R. Fabry,
        "A Fast File System for  UNIX",
        ACM Transactions on Computer Systems 2, 3, pp 181-197, August
        1984, (reprinted in the BSD System Manager's Manual, SMM:5) o
        <url url="file:/usr/share/doc/smm/05.fastfs/paper.ascii.gz"
        name="/usr/share/doc/smm/05.fastfs/paper.ascii.gz"> en tu sistema.

        <tag><label id="bsize"><bf>Block Size (bsize)</bf></tag>
        Un bloque se compone de uno o mas fragmentos. Mira la referencia
        correspondiente en:
        <url url="file:/usr/include/sys/disklabel.h"
        name="&lt;sys/disklabel.h&gt;">

        <tag><label id="ESDI">
        <bf>Disklabel Characteristics for Older Disks (ESDI)</bf></tag>
        Necesitar&aacute;s dar m&aacute;s informaci&oacute;n a<htmlurl 
        url="http://www.freebsd.org/cgi/man.cgi?disklabel"
        name="disklabel"> 
        si quieres usar un "disco verdadero". Necesitar&aacute;s saber la
        geometr&iacute;a uniforme, cabezales reales, sectores y cilindros, como
        en los discos ESDI antiguos. Toda esta informaci&oacute;n 
        deber&iacute;a ser facilmente localizable en la cubierta del propio 
        disco, manual, etc.

        <tag><label id="fsname">
        <bf>Nombres del sistema de ficheros BSD</bf></tag>
        La partici&oacute;n 'a', por convenci&oacute;n, est&aacute; reservada 
        para particiones 'bootables' y la partici&oacute;n 'b' para swap. Las 
        particiones regulares deben empezar en la 'd'. La partici&oacute;n 'e' 
        corresponde a la primera partici&oacute;n no bootable y a usar como 
        sistema de ficheros.

        <tag><label id="swap">
        <bf>Warning referente al espacio de swap</bf></tag>
        El espacio requerido por la tabla de partici&oacute;n de BSD est&aacute;
        permitido en el sistema de ficheros. No empieces la partici&oacute;n
        swap en el cilindro 0.
      </descrip>

    <sect1>
      <heading>Tengo un nuevo disco removible, &iquest;como lo uso?</heading>

      <p>Se trate de un disco removible como un ZIP o EA (o un floppy,
      si quieres usarlo de esta manera), o un nuevo disco duro, una vez
      instalado y reconocido por el sistema, y tengas tu
      cartridge/floppy/etc en su interior, las cosas son como para la
      mayor&iacute;a de dispositivos.

      <p><label id="disklabel">(esta secci&oacute;n esta basada en <url
      url="http://vinyl.quickweb.com/mark/FreeBSD/ZIP-FAQ.html"
      name="Mark Mayo's ZIP FAQ">)

      <p>Si es un disco ZIP o floppy, y est&aacute; formateado en DOS, puedes
      usar el comando:

      <verb>
        mount -t msdos /dev/fd0c /floppy
      </verb>

      <p>Si es un floppy, o este:

      <verb>
        mount -t msdos /dev/sd2s4 /zip
      </verb>

      <p>para un disco ZIP con la configuraci&oacute;n de f&aacute;brica.

      <p>Para otros discos, mira como configurarlos usando <tt/fdisk/ o
      <tt>/stand/sysinstall</tt>.

      <p>El resto de ejemplos ser&aacute;n para un disco ZIP en sd2, el tercer
      disco SCSI.

      <p>A no ser que se trate de un floppy o disco removible, lo que
      planeas compartir con otros usuarios, es aconsejable convertir
      el formato de ficheros a BSD. Obtendr&aacute;s nombre de ficheros largos,
      como m&iacute;nimo doblar&aacute;s la velocidad de acceso del disco, y 
      mucha m&aacute;s estabilidad. Antes, necesitas rehacer las particiones. 
      Puedes usar el comando 
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fdisk"
      name="fdisk"> o la utilidad <tt>/stand/sysinstall</tt>. Si es un
      disco peque&ntilde;o que quieres dedicar enteramente a FreeBSD, solo
      tienes que eliminar la FAT y tabla de particiones, y usar el sistema
      de particiones de FreeBSD:

      <verb>
        dd if=/dev/zero of=/dev/rsd2 count=2
        disklabel -Brw sd2 auto
      </verb>

      <p>Puedes usar el comando disklabel (mas informaci&oacute;n en
      <ref id="2_1-disklabel-fix" name="esta nota">) o
      <tt>/stand/sysinstall</tt> para crear m&uacute;ltiples particiones BSD.

      <p>Finalmente, crea un nuevo sistema de ficheros:

      <verb>
        newfs /dev/rsd2c
      </verb>

      <p>y montalo:

      <verb>
        mount /dev/sd2c /zip
      </verb>

      <p>Ser&iacute;a una buena idea a&ntilde;adir una l&iacute;nea como esta 
      en el fichero
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fstab"
      name="/etc/fstab"> para que solo tengas que teclear "mount /zip"
      las siguientes veces.

      <verb>
        /dev/sd2c /zip ffs rw,noauto 0 0
      </verb>

    <sect1>
      <heading>&iquest;C&oacute;mo monto una partici&oacute;n secundaria DOS?</heading>

      <p>Las particiones DOS secundarias se encuentran despu&eacute;s de TODAS
      las particiones primarias. Por ejemplo, si tienes una partici&oacute;n
      "E" como la segunda partici&oacute;n DOS en el segundo disco SCSI, 
      necesitas crear los ficheros especiales para el dispositivo 5 en /dev, y 
      despu&eacute;s montar /dev/sd1s5:

      <verb>
        # cd /dev
        # ./MAKEDEV sd1s5
        # mount -t msdos /dev/sd1s5 /dos/e
      </verb>

    <sect1>
      <heading>&iquest;Puedo montar otros sistemas de ficheros bajo FreeBSD?</heading>

      <p><bf/Digital UNIX/ UFS CDROMs pueden ser montados directamente
      en FreeBSD. Montar particiones de disco de Digital UNIX y otros
      sistemas que soportan UFS puede ser mas complejo, dependiendo de los
      detalles de la partici&oacute;n de disco del sistema operativo en 
      cuesti&oacute;n.

      <p><bf/ Linux/: 2.2 y posteriores soportan particiones <bf/ext2fs/.
      Mira <htmlurl url="http://www.freebsd.org/cgi/man.cgi?mount_ext2fs"
      name="mount_ext2fs"> para mas informaci&oacute;n.

      <p><bf/ NT/: Existe un driver de solo lectura de NTFS para FreeBSD. Para 
      m&aacute;s informaci&oacute;n, mira este tutorial de Mark Ovens en
      <htmlurl url="http://www.users.globalnet.co.uk/~markov/ntfs_install.html"
      name="http://www.users.globalnet.co.uk/~markov/ntfs_install.html">.

    <sect1>
      <heading>&iquest;C&oacute;mo puedo usar el "NT loader" para arrancar FreeBSD?</heading>

      <p>La idea general es que copies el primer sector de la partici&oacute;n
      root nativa de FreeBSD en un fichero en la partici&oacute;n DOS/NT.
      Asumiento que nombras a ese fichero como <tt>c:&bsol;bootsect.bsd</tt>
      puedes editar el fichero <tt>c:&bsol;boot.ini</tt> para conseguir
      algo como esto:

      <verb>
        [boot loader]
        timeout=30
        default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
        [operating systems]
        multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
        C:\BOOTSECT.BSD="FreeBSD"
        C:\="DOS"
      </verb>

      <p>Este proceso asume que DOS, NT, FreeBSD o cualquier otro sistema
      ha sido instalado en sus respectivas particiones en el mismo disco.
      En nuestro caso, DOS y NT est&aacute;n en la primera partici&oacute;n 
      y FreeBSD en la segunda. Instalamos FreeBSD para arrancarlo desde su 
      partici&oacute;n nativa y no desde el disco MBR.

      <p>Monta un floppy formateado en DOS bajo la partici&oacute;n <tt>/mnt</tt>.

      <verb>
        dd if=/dev/rsd0a of=/mnt/bootsect.bsd bs=512 count=1
      </verb>

      <p>Rearranca en DOS o NT. Copia el fichero <tt/bootsect.bsd/ y/o el
      fichero <tt/bootsect.lnx/ del floppy a <tt/C:&bsol;/. Modifica los
      atributos a <tt/boot.ini/ con:

      <verb>
        attrib -s -r c:\boot.ini
      </verb>

      <p>Edita y a&ntilde;ade las l&iacute;neas apropiadas del boot.ini mostrado
      enteriormente de ejemplo, y vuelve a poner los atributos originales:

      <verb>
        attrib -r -s c:\boot.ini
      </verb>

      <p>Si FreeBSD est&aacute; arrancando desde el MBR, restauralo desde el
      comando <tt/fdisk/ despu&eacute;s de reconfigurarlos para arrancar desde
      sus particiones nativas.

    <sect1>
      <heading>
        &iquest;C&oacute;mo arranco FreeBSD y Linux desde LILO?
      </heading>
      
      <p>Si tienes FreeBSD y Linux en el mismo disco, solo tienes que seguir
      las instrucciones de instalaci&oacute;n de LILO para arrancar un sistema
      operativo no Linux. Brevemente, son estas:

      <p>Arranca Linux, y a&ntilde;ade las siguientes l&iacute;neas en el 
      fichero
      <tt>/etc/lilo.conf</tt>:
      <verb>
      other=/dev/hda2
              table=/dev/hda
              label=FreeBSD
      </verb> 
      (Asumiendo que tu partici&oacute;n FreeBSD es conocida por Linux como
      <tt>/dev/hda2</tt>). A continuaci&oacute;n, ejecuta <tt>lilo</tt> como 
      root y ya deber&iacute;a estar.

      <p>Si FreeBSD est&aacute; en otro disco, necesitas a&ntilde;adir 
      ``<tt>loader=/boot/chain.b</tt>'' al fichero <tt>lilo.conf</tt>. Por
      ejemplo:
      <verb>
      other=/dev/sdb4
              table=/dev/sdb
              loader=/boot/chain.b
              label=FreeBSD
      </verb> 

      <p>En algunos casos necesitar&aacute;s especificar el n&uacute;mero de 
      disco en BIOS para que el cargador del boot funcione correctamente desde 
      el segundo disco. Por ejemplo, si tu disco SCSI con FreeBSD es visto por 
      la BIOS como disco 1, en el prompt del cargador de arranque 
      necesitar&aacute;s especificar:
      <verb>
      Boot: 1:sd(0,a)/kernel
      </verb>

      <p>En FreeBSD 2.2.5 y posteriores, puedes configurar <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?boot(8)" name="boot(8)">
      para que haga esto automaticamente.

     <p>El <htmlurl
     url="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html"
      name="Linux+FreeBSD mini-HOWTO"> es una buena referencia para
      las opciones de interoperabilidad entre FreeBSD y Linux.

    <sect1>
      <heading>
        &iquest;C&oacute;mo arranco FreeBSD y Linux usando BootEasy?
      </heading>
  
      <p>Instala el LILO al inicio de la partici&oacute;n de arranque del 
      Linux en lugar de hacerlo en el "Master Boot Record". As&iacute; 
      podr&aacute;s arrancar el LILO desde BootEasy.

      <p>Si estas usando Windows-95 y Linux, tambi&eacute;n es recomendable 
      hacer esto para simplificar el arranque de Linux en caso de que sea 
      necesaria una reinstalaci&oacute;n del Windows-95 (ya que no quiere 
      convivir con otros sistemas operativos en el mismo Master Boot Record).

    <sect1>
      <heading>
        &iquest;Puede un disco "dedicado" provocar problemas?
      </heading>

      <p><label id="dedicate">El proceso de instalaci&oacute;n nos permite 
      elegir dos m&eacute;todos diferentes de particionar un disco. El sistema 
      por defecto hace que el disco sea compatible con otros sistemas 
      operativos en la misma m&aacute;quina, usando las tablas de entrada de 
      fdisk (llamadas "slices" en FreeBSD). Opcionalmente, podemos instalar un
      boot-selector que nos permite seleccionar el sistema operativo con
      el que queremos arrancar.

      <p>Mientras este es el caso m&aacute;s com&&uacute;n para gente 
      proveniente del mundo de PC, para la gente proveniente del mundo Unix y 
      quienes quieren instalar una m&aacute;quina para funcionar con FreeBSD y 
      solo FreeBSD, es m&aacute;s habitual usar el sistema de reservar todo el
      espacio del disco para un solo sistema operativo.
      Si seleccionas "A)ll FreeBSD" en el editor de fdisk de la utilidad
      sysinstall, y respondes la siguiente pregunta con "No", usar&aacute;s
      este &uacute;ltimo sistema. Ten en cuenta que usando este sistema no te
      permitir&aacute; la instalaci&oacute;n de ning&uacute;n otro sistema 
      operativo o selector de arranque (boot manager).

      <p>Entonces, por que se llama "peligroso"?. Un disco en este modo
      no contiene lo que las utilidades normales de un PC considerar&iacute;an
      una tabla de partici&oacute;n de ficheros v&aacute;lida. Dependiendo del 
      dise&ntilde;o de estas aplicaciones, puede que da&ntilde;en el sector de 
      arranque una vez entren en contacto con el disco. Por lo menos una 
      BIOS Award usada por m&aacute;quinas HP Netservers (pero no s&oacute;lo 
      por ellos) es concocida por ignorar los disco duros que no contengan lo 
      que la BIOS entiende por una tabla de ficheros v&aacute;lida.

      <p>Para volver un disco "peligrosamente dedicado" a formato
      estandard de PC, hay b&aacute;sicamente dos opciones. La primera es,
      escribes suficientes bytes NULL sobre el MBR para hacer que
      las siguientes instalaciones crean que est&aacute;n en un disco s&iacute;n
      usar. Puedes hacer esto as&iacute;:

      <verb>
        dd if=/dev/zero of=/dev/rsd0 count=15
      </verb>

      <p>Alternativamente, puedes hacer:

      <verb>
        fdisk /mbr
      </verb>

      <p>que instalar&aacute; un nuevo master boot record.

    <sect1>
      <heading>&iquest;C&oacute;mo puedo a&ntilde;adir m&aacute;s espacio de swap?</heading>

      <p>La mejor manera es incrementar el tama&ntilde;o de tu partici&oacute;n
      de swap, o usar esta excusa para a&ntilde;adir un otro disco nuevo (mira
      <ref id="swap" name="esta nota"> si lo haces).

      <p>A&ntilde;adir swap en discos separados hace las cosas m&aacute;s 
      r&aacute;pidas que simplemente a&ntilde;adir swap en el mismo disco. 
      Como ejemplo, si est&aacute;s compilando c&oacute;digo fuente en un 
      disco, y el swap est&aacute; en otro disco, es mucho m&aacute;s 
      r&aacute;pido que si el swap y la compilaci&oacute;n se realizaran en el 
      mismo disco. Esto es cierto espec&iacute;ficamente para discos SCSI.

      <p>Los discos IDE no son capaces de permitir el acceso a ambos discos
      en el mismo canal al mismo tiempo (FreeBSD no soporta el modo 4, ya
      que todas las I/O de discos IDE son "programadas").

      <p>Es realmente muy mala idea instalar el swap sobre NFS a no ser que
      trabajes en una red muy r&aacute;pida con un muy buen servidor.

      <p>Aqu&iacute; hay un ejemplo para un fichero de swap de 64Mb
      <tt>/usr/swap0</tt>, piensa que puedes usar el nombre que quieras).

      <p>Asegurate que el kernel est&aacute; compilado con la l&iacute;nea

      <verb>
        pseudo-device   vn 1   #Vnode driver (turns a file into a device)
      </verb>

      <p>en tu fichero de configuraci&oacute;n. El kernel GENERIC la contiene. 

      <enum>
        <item>crea un vn-device

        <verb>
          cd /dev
          sh ./MAKEDEV vn0
        </verb>

        <item>crea un swapfile (<tt>/usr/swap0</tt>)

        <verb>
          dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
        </verb>

        <item>activa el fichero de swap en <tt>/etc/rc.conf</tt>

        <verb>
          swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
        </verb>

        <item>rebota la m&aacute;quina.
      </enum>

      <p>Para activar el fichero de swap inmediatamente teclea

      <verb>
        vnconfig -ce /dev/vn0c /usr/swap0 swap
      </verb>

    <sect1>
      <heading>Tengo problemas para poner en marcha mi impresora.</heading>

      <p>Por favor, revisa la secci&oacute;n de impresoras del manual. Cubre la
      mayor&iacute;a de posibles problemas. P&aacute;sate por
      <url url="../../handbook/printing.html" name="esta secci&oacute;n.">

    <sect1>
      <heading>Mi teclado no coincide con los car&aacute;cteres de pantalla.</heading>

      <p>El programa de control de teclado tiene una opci&oacute;n para cargar
      el mapa de teclado. En el directorio <tt>/usr/share/syscons/keymaps</tt>
      hay diferentes ficheros de mapas de teclado. Selecciona el que
      corresponde a tu sistema y c&aacute;rgalo.

      <verb>
        kbdcontrol -l uk.iso
      </verb>

      <p>Tanto el directorio <tt>/usr/share/syscons/keymaps</tt> como la
      extensi&oacute;n <tt/.kbd/ son asumidas por la orden
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?kbdcontrol"
      name="kbdcontrol">.

      <p>Esto puede ser configurado en <tt>/etc/sysconfig</tt> (o <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?rc.conf(5)" name="rc.conf">).
      Mira los comentarios correspondientes en el propio fichero.

      <p>En la versi&oacute;n 2.0.5R y posteriores, todo lo referente a fuentes,
      teclado, etc est&aacute; en <tt>/usr/share/examples/syscons</tt>.

      <p>Actualmente se soportan los siguientes mapas de teclado:

      <itemize>
        <!-- generate by `kbdmap -p' -->
        <item>Belgian ISO-8859-1 
        <item>Brazilian 275 keyboard Codepage 850 
        <item>Brazilian 275 keyboard ISO-8859-1 
        <item>Danish Codepage 865 
        <item>Danish ISO-8859-1 
        <item>French ISO-8859-1 
        <item>German Codepage 850 
        <item>German ISO-8859-1 
        <item>Italian ISO-8859-1 
        <item>Japanese 106 
        <item>Japanese 106x 
        <item>Latin American 
        <item>Norwegian ISO-8859-1 
        <item>Polish ISO-8859-2 (programmer's) 
        <item>Russian Codepage 866 (alternative) 
        <item>Russian koi8-r (shift) 
        <item>Russian koi8-r 
        <item>Spanish ISO-8859-1 
        <item>Swedish Codepage 850 
        <item>Swedish ISO-8859-1 
        <item>Swiss-German ISO-8859-1 
        <item>United Kingdom Codepage 850 
        <item>United Kingdom ISO-8859-1 
        <item>United States of America ISO-8859-1 
        <item>United States of America dvorak 
        <item>United States of America dvorakx 
      </itemize>

    <sect1>
      <heading>Las cuotas de usuario no funcionan correctamente.</heading>

      <p>
      <enum>
        <item>No actives las cuotas en '/',

        <item>Pon el fichero de cuotas en el sistema de ficheros en el que
        se vayan a forzar las cuotas de usuario:

        <verb>
          FS      QUOTA FILE
          /usr    /usr/admin/quotas
          /home   /home/admin/quotas
          ...
        </verb>
      </enum>

    <sect1>
      <heading>Mi ccd no funciona correctamente</heading>

      <p>El s&iacute;ntoma es:

      <verb>
        # ccdconfig -C
        ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format
        #
      </verb>

      <p>Esto actualmente ocurre cuando est&aacute;s intentando concatenar las
      particiones c'. El driver ccd requiere que la partici&oacute;n sea del
      tipo FS_BSDFFS. Edita la etiqueta del disco (disklabel) que est&aacute;s
      intentando concatenar y cambia el tipo de partici&oacute;n a '4.2BSD'.

    <sect1>
      <heading>&iquest;Porqu&eacute; no puedo editar el disklabel en mi ccd?</heading>

      <p>El s&iacute;ntoma es:

      <verb>
        # disklabel ccd0
        (it prints something sensible here, so let's try to edit it)
        # disklabel -e ccd0
        (edit, save, quit)
        disklabel: ioctl DIOCWDINFO: No disk label on disk;
        use "disklabel -r" to install initial label
        #
      </verb>

      <p>Esto es porque el disklabel retornado por el ccd es actualmente
      uno que no corresponde con el real. Puedes resolver este problema
      escribiendo expl&iacute;citamente:

      <verb>
        # disklabel ccd0 > /tmp/disklabel.tmp
        # disklabel -Rr ccd0 /tmp/disklabel.tmp
        # disklabel -e ccd0
        (this will work now)
      </verb>

    <sect1>
      <heading>&iquest;Soporta FreeBSD primitivas IPC System V?</heading>

      <p>S&iacute;, FreeBSD las soporta. Estas incluyen memoria compartida,
      mensajes y sem&aacute;foros. Necesitas a&ntilde;adir las siguientes 
      l&iacute;neas en la configuraci&oacute;n de tu kernel para activarlas.

      <verb>
        options    SYSVSHM
        options    "SHMMAXPGS=64"   # 256Kb of sharable memory
        options    SYSVSEM          # enable for semaphores
        options    SYSVMSG          # enable for messaging
      </verb>

      <p>Recompila e instala.

      <p><bf/NOTA:/ Quiz&aacute;s necesites incrementar SHMMAXPGS a un 
      n&uacute;mero como 4096 (16M) si quieres usar GIMP. 256K es suficiente 
      para la memoria compartida en X11R6.

    <sect1>
      <heading>
        &iquest;C&oacute;mo uso sendmail para envio de mail UUCP?<label id="uucpmail">
      </heading>

      <p>La configuraci&oacute;n de sendmail incluida en FreeBSD est&aacute; 
      preparada para sistemas que conectan directamente con Internet. Los 
      sistemas que quieran usar UUCP para el env&iacute;o de mail deben 
      utilizar otro fichero de configuraci&oacute;n.

      <p>Retocar <tt>/etc/sendmail.cf</tt> manualmente est&aacute; considerado
      algo para puristas. La versi&oacute;n 8 de sendmail incluye un nuevo
      sistema de configuraci&oacute;n llamado
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?m4" name="m4">, en
      el cual la configuraci&oacute;n se realiza en un nivel m&aacute;s alto. 
      Deber&iacute;as usar los ficheros de configuraci&oacute;n situados en

      <verb>
        /usr/src/usr.sbin/sendmail/cf
      </verb>

      <p>Si no instalaste tu sistema con el c&oacute;digo fuente completo, el
      paquete de configuraci&oacute;n de sendmail est&aacute; en una 
      distribuci&oacute;n aparte. Asumiendo que tienes tu CD-ROM montado, haz:

      <verb>
        cd /usr/src
        tar -xvzf /cdrom/dists/src/ssmailcf.aa
      </verb>

      <p>No te preocupes, solo son unos cientos de kilobytes de tama&ntilde;o.
      El fichero <tt>README</tt> en el directorio <tt>cf</tt> puede
      servir como introducci&oacute;n a la configuraci&oacute;n del m4.

      <p>Para env&iacute;o y recepci&oacute;n va UUCP, te aconsejamos usar la
      opci&oacute;n <em>mailertable</em>. Se basa en una base de datos
      que sendmail puede usar como base para tomar las decisiones
      de enrutado del mail.

      <p>Primero tienes que crear tu fichero <tt>.mc</tt>. Estos ficheros
      se encuentran en el directorio
      <tt>/usr/src/usr.sbin/sendmail/cf/cf</tt>. Si miras, encontrar&aacute;s
      algunos ejemplos. Asumiendo que tu fichero se llama <tt>foo.com</tt>,
      todo lo que necesitas hacer para convertirlo en un fichero
      <tt>sendmail.cf</tt> v&aacute;lido es:


      <verb>
        cd /usr/src/usr.sbin/sendmail/cf/cf
        make foo.cf
        cp foo.cf /etc/sendmail.cf
      </verb>

      <p>Un fichero t&iacute;pico <tt>.mc</tt> ser&iacute;a algo como:

      <verb>
        include(`../m4/cf.m4')
        VERSIONID(`Your version number')
        OSTYPE(bsd4.4)

        FEATURE(nodns)
        FEATURE(nocanonify)
        FEATURE(mailertable)

        define(`UUCP_RELAY', your.uucp.relay)
        define(`UUCP_MAX_SIZE', 200000)

        MAILER(local)
        MAILER(smtp)
        MAILER(uucp)

        Cw    your.alias.host.name
        Cw    youruucpnodename.UUCP
      </verb>

      <p>Las opciones <em>nodns</em> y <em>nocanonify</em> previenen
      del uso del DNS durante el tr&aacute;fico de correo. La cl&aacute;usula
      <em>UUCP_RELAY</em> se necesita por razones imperiosas, no
      preguntes :). Simplemente pon un nombre de m&aacute;quina de Internet que
      sea capaz de gestionar pseudo-dominios .UUCP; m&aacute;s sencillo,
      entrar&aacute;s el mail relay de tu ISP.

      <p>Una vez hayas hecho esto, necesitas el fichero llamado
      <tt>/etc/mailtertable</tt>. Un ejemplo t&iacute;pico ser&iacute;a:

      <verb>
        #
        # makemap hash /etc/mailertable.db < /etc/mailertable
        #
        horus.interface-business.de   uucp-dom:horus
        .interface-business.de        uucp-dom:if-bus
        interface-business.de         uucp-dom:if-bus
        .heep.sax.de                  smtp8:%1
        horus.UUCP                    uucp-dom:horus
        if-bus.UUCP                   uucp-dom:if-bus
        .                             uucp-dom:sax
      </verb>

      <p>Como puedes ver, esto es parte de un fichero real. Las tres
      primeras l&iacute;neas manejan casos especiales donde el correo dirigido
      a un dominio no debe ser enviado a trav&eacute;s de la ruta por defecto,
      si no a trav&eacute;s de un UUCP vecino para acortar el path de 
      env&iacute;o.  La siguiente l&iacute;nea gestiona el mail del dominio 
      local para que sea enviado v&iacute;a SMTP. Finalmente, los vecinos UUCP 
      son anotados en la parte .UUCP pseudo-domains, para poder sobreescribir 
      las reglas por defecto. La &uacute;ltima l&iacute;nea es siempre un 
      punto, que indica el mail gateway hacia el resto del mundo. Todos los 
      nombres de nodos detr&aacute;s de <tt>uucp-dom:</tt> deben ser vecinos 
      v&aacute;lidos UUCP.

      <p>Como recordatorio de que este fichero debe ser convertido a
      una base de datos DBM antes de ser usada, la l&iacute;nea de comandos
      para realizar esta operaci&oacute;n esta puesta como un comentario al
      inicio del fichero. Siempre tienes que ejecutar este comando
      cada vez que realices alg&uacute;n cambio en tu mailtertable.

      <p>Si no tienes la seguridad de que una ruta de correo vaya a
      funcionar correctamente, recuerda la opci&oacute;n <tt>-bt</tt> de
      sendmail. Esta opci&oacute;n arranca el sendmail en <em>modo test</em>;
      simplemente entra 0, seguido por la direcci&oacute;n de mail sobre la que
      quieres testear la ruta. La &uacute;ltima l&iacute;nea te indica el agente
      interno, el host de destino y la direcci&oacute;n (posiblemente
      traducido). Sal de este modo tecleando Control-D.

      <verb>
        j@uriah 191% sendmail -bt
        ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
        Enter <ruleset> <address>
        > 0 foo@interface-business.de
        rewrite: ruleset  0   input: foo @ interface-business . de
        ...
        rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
        < @ interface-business . de >
        > ^D
        j@uriah 192%
      </verb>

    <sect1>
      <heading>&iquest;C&oacute;mo configuro el correo para conexiones NO permanentes a Internet?<label id="ispmail"></heading>

      <p>Si tienes una direcci&oacute;n IP fija en la conexi&oacute;n, no 
      necesitar&aacute;s ajustar nada de lo que ya viene por defecto. 
      Configura tu hostname como el nombre asignado a tu IP de Internet y 
      sendmail har&aacute; el resto.

      <p>Si tienes direcciones IP asignadas dinamicamente y usas una
      conexi&oacute;n <bf/ppp/ a Internet, probablemente tendr&aacute;s un 
      buz&oacute;n en el servidor de correo de tu proveedor. Supongamos que el 
      dominio de tu proveedor es <tt/myisp.com/, y tu nombre de usuario es
      <tt/user/. Supongamos tambi&eacute;n que has llamado a tu m&aacute;quina
      <tt/bsd.home/ y que tu proveedor te ha indicado que uses la
      m&aacute;aquina <tt/relay.myISP.com/ como mail realy (gateway).

      <p>Para poder recoger el correo de tu buz&oacute;n necesitar&aacute;s 
      instalar un agente de recogida de correo. <bf/Fetchmail/ es una buena 
      opci&oacute;n ya que soporta diferentes protocolos. Normalmente se usa 
      POP3.  Puedes recoger automaticamente tu correo al realizar la
      conexi&oacute;n a&ntilde;adiendo la siguiente l&iacute;nea en el fichero
      <tt>/etc+ppp/ppp.linkup</tt>:

      <verb>
        MYADDR:
          !bg su user -c fetchmail
      </verb>

      <p>Asumimos que tienes una cuenta para <tt/user/ en <tt/bsd.home/.
      En el home directory de <tt/user/ en <tt/bsd.home/, crea el fichero
      <tt/.fetchmailrc/:

      <verb>
        poll myISP.com protocol pop3 fetchall pass MySecret;
      </verb>

      <p>No hace falta decir que este fichero no debe ser "leible" por nadie
      excepto <tt/user/ ya que contiene el password <tt/MySecret/.

      <p>Para enviar el correo con la cabecera <bf/from:/ correcta, debes
      decirle al sendmail que use <tt/user@myISP.com/ en lugar de
      <tt/user@bsd.home/. Tambi&eacute;n deber&iacute;as decirle al sendmail 
      que envie todo el correo saliente a traves de <tt/relay.myISP.com/, para 
      una transmisi&oacute;n mucho m&aacute;s r&aacute;pida.

      <p>El siguiente fichero <tt/.mc/ debe ser suficiente:

      <verb>
        VERSIONID(`bsd.home.mc version 1.0')
        OSTYPE(bsd4.4)dnl
        FEATURE(nouucp)dnl
        MAILER(local)dnl
        MAILER(smtp)dnl
        Cwlocalhost
        Cwbsd.home
        CwmyISP.com
        MASQUERADE_AS(`myISP.com')dnl
        FEATURE(allmasquerade)dnl
        FEATURE(masquerade_envelope)dnl
        FEATURE(nocanonify)dnl
        FEATURE(nodns)dnl
        define(SMART_HOST, `relay.myISP.com')
        DmmyISP.com
        define(`confDOMAIN_NAME',`myISP.com')dnl
        define(`confDELIVERY_MODE',`deferred')dnl
      </verb>

      <p>Mira en la secci&oacute;n anterior para los detalles de como convertir
      este fichero <tt/.mc/ en un <tt/sendmail.cf/. No te olvides de
      rearrancar sendmail despu&eacute;s de cada actualizaci&oacute;n del 
      fichero sendmail.cf.

    <sect1>
       <heading>Olvid&eacute; el password de Root!!</heading>
       
       <p>Tranquilo!!!. Simplemenre rearranca tu sistema, teclea -s en el 
       prompt de arranque para entrar en modo monousuario. En la pregunta
       sobre el shell a usar, pulsa ENTER. Aparecer&aacute; un prompt #. Teclea
       <tt>mount -u /</tt> para remontar tu sistema de ficheros en modo
       de lectura/escritura y a continuaci&oacute;n teclea <tt/mount -a/ para 
       montar todos los sistemas de ficheros. Ejecura <tt/passwd root/
       para cambiar el password de root. Teclea <tt/exit/ para continuar
       normalmente con el arranque.

    <sect1>
      <heading>&iquest;C&oacute;mo mantengo el control sobre Control-Alt-Delete?</heading>

      <p>Edita el mapa de teclado que est&aacute;s usando para la 
      c&oacute;nsola y reemplaza las palabras <tt/boot/ por <tt/nop/. El mapa 
      de teclado por defecto es <tt>/usr/share/syscons/keymaps/us.iso.kbd</tt>
      . Por supuesto si usas otro mapa de teclado adecuado a tu pa&iacute;s, 
      tendr&iacute;as que editarlo.

    <sect1>
      <heading>&iquest;C&oacute;mo reformateo ficheros de texto DOS a UNIX?</heading>

      <p>Simplemente usando este comando de perl:

<verb>
perl -i.bak -npe 's/\r\n/\n/g' file ...
</verb>
  
      <p>file es el fichero a procesar. La modificaci&oacute;n se hace en el 
      propio fichero dejando el original grabado con extensi&oacute;n .bak.

      Alternativamente puedes usar el comando <url url="/cgi/man.cgi?tr"
      name="tr(1)">

<verb>
tr -d '\r' &lt; dos-text-file &gt; unix-file
</verb>

      dos-text-file es el fichero que contiene el texto DOS mientras que 
      unix-file contendr&aacute; la salida convertida. Este sistema puede
      ser m&aacute;s r&aacute;pido que usar perl.

    <sect1>
      <heading>&iquest;C&oacute;mo puedo hace "kill" de procesos por nombre?</heading>

      <p>Usa <url url="/cgi/cvsweb.cgi/man.cgi?killall" name="killall(1)">.

    <sect1>
      <heading>&iquest;Porque el su no me dejar ser root al no estar en el ACL?</heading>

      <p>El error proviene de sistema del autentificaci&oacute;n distribuida 
      Kerberos.  El problema no es fatal pero si molesto. Puedes ejecutar el 
      comando su con la opcion -K, o desinstalar Kerberos como se describe en 
      la siguiente secci&oacute;n.

    <sect1>
      <heading>&iquest;C&oacute;mo desinstalo Kerberos?</heading>

      <p>Para eliminar Kerberos del sistema, reinstala la distribuci&oacute;n 
      bin de la release que est&eacute;s usando. Si tienes el CDROM, puedes 
      montar el cd (asumiremos que esta en /cdrom) y ejecutar:

<verb>
cd /cdrom/bin
./install.sh
</verb>

  <sect1>
    <heading>&iquest;C&oacute;mo a&ntilde;ado pseudoterminales a mi sistema?</heading>

    <p>Si tienes muchos usuarios de telnet, ssh, X, o de c&oacute;nsola, 
    probablemente terminar&aacute;s desbordando el n&uacute;mero de
    pseudoterminales del sistema. Aqu&iacute; tienes como a&ntilde;adir 
    m&aacute;s:

    <enum>
    <item>Compila e instala un nuevo kernel com la l&iacute;nea

    <verb>
      pseudo-device pty 256
    </verb>

    <p>en el fichero de configuraci&oacute;n.

    <item>Ejecuta el comando

    <verb>
    # cd /dev
    # ./MAKEDEV pty {1,2,3,4,5,6,7}
    </verb>

    <p>para crear 256 nodos de dispositivo para los nuevos terminales.

    <item>Edita el fichero <tt>/etc/ttys</tt> y a&ntilde;ade una l&iacute;nea
    para cada uno de los 256 terminales. Estas l&iacute;neas deben seguir la
    estructura de las entradas existentes, algo como esto:

    <verb>
      ttyqc none network
    </verb>

    <p>El &oacute;rden de la designaci&oacute;n de letras es 
    <tt>tty[pqrsPQRS][0-9a-v]</tt>, usando una expresi&oacute;n regular.

    <item>Rebota el sistema con el nuevo kernel, y lo tendr&aacute;s listo
    para funcionar.
    </enum>

  </sect>

