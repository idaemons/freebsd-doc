<!--
     The FreeBSD Dutch Documentation Project

     $FreeBSD$
     $FreeBSDnl: doc/nl_NL.ISO8859-1/books/handbook/geom/chapter.sgml,v 1.13 2006/01/05 21:13:21 siebrand Exp $
     Gebaseerd op: 1.38
-->

<chapter id="GEOM">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Tom</firstname>
	<surname>Rhodes</surname>
	<contrib>Geschreven door </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Siebrand</firstname>
	<surname>Mazeland</surname>
	<contrib>Vertaald door </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>GEOM: Modulair schijftransformatie framework</title>

  <sect1 id="GEOM-synopsis">
    <title>Overzicht</title>

    <indexterm><primary>GEOM</primary></indexterm>

    <indexterm>
      <primary>GEOM schijf framework</primary>

      <see>GEOM</see>
    </indexterm>

    <para>Dit hoofdstuk beschrijft het gebruik van schijven in het
      GEOM framework in &os;.  Hieronder vallen de belangrijkste
      <acronym
	role="Redundant Array of Inexpensive Disks">RAID</acronym>
      besturingsprogramma's die het framework gebruikt voor
      instellingen.  In dit hoofdstuk wordt niet diepgaand beschreven
      hoe GEOM omgaat met I/O, het onderliggende subsysteem of code.
      Die informatie staat in het hulppagina voor &man.geom.4; en de
      verscheidene <quote>SEE ALSO</quote> referenties.  Dit hoofdstuk
      is ook geen definitief stuk over het instellen van
      <acronym>RAID</acronym>.  Alleen de door GEOM ondersteunde
      <acronym>RAID</acronym>-classificaties worden beschreven.</para>

    <para>Na het lezen van dit hoofdstuk weet de lezer:</para>

    <itemizedlist>
      <listitem>
	<para>Welk type <acronym>RAID</acronym>-ondersteuning via GEOM
	  beschikbaar is;</para>
      </listitem>

      <listitem>
	<para>Hoe de basisgereedschappen te gebruiken om de
	  verschillende <acronym>RAID</acronym>-niveau's in te stellen,
	  te onderhouden en te wijzigen;</para>
      </listitem>

      <listitem>
	<para>Hoe schijfapparaten via GEOM te spiegelen, aaneen te
	  schakelen, te versleutelen en vanaf afstand schijven aan te
	  sluiten;</para>
      </listitem>

      <listitem>
	<para>Hoe problemen op te lossen met schijven die via het GEOM
	  framework zijn aangesloten.</para>
      </listitem>
    </itemizedlist>

    <para>Veronderstelde voorkennis:</para>

    <itemizedlist>
      <listitem>
	<para>Begrijpen hoe &os; omgaat met schijfapparaten (<xref
	    linkend="disks">);</para>
      </listitem>

      <listitem>
	<para>Weten hoe een nieuwe &os; kernel in te stellen en te
	  installeren (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="GEOM-intro">
    <title>GEOM inleiding</title>

    <para>GEOM staat toegang en controle toe op klassen, Master Boot
      Records, <acronym>BSD</acronym> labels, enzovoort, door gebruik
      te maken van diensten of de speciale bestanden in <filename
	role="directory">/dev</filename>.  GEOM ondersteunt
      verschillende software <acronym>RAID</acronym> instellingen en
      biedt transparante toegang tot het besturingssysteem en de
      hulpprogramma's.</para>
  </sect1>

  <sect1 id="GEOM-striping">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschreven door </contrib>
	</author>
	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>RAID0 - aaneengeschakeld</title>

    <indexterm><primary>GEOM</primary></indexterm>

    <indexterm><primary>aaneengeschakeld</primary></indexterm>

    <para>Aaneenschakelen is een methode die gebruikt wordt
      om meerdere schijven te combineren tot een enkele volume.  In
      veel gevallen wordt dit gedaan met hardware controllers.  Het
      GEOM subsysteem biedt softwareondersteuning voor
      <acronym>RAID</acronym>0, ook wel bekend als aaneenschakelen
      (<quote>disk striping</quote>).</para>

    <para>In een <acronym>RAID</acronym>0-systeem worden gegevens
      opgedeeld in blokken die verdeeld worden over de schijven in een
      reeks.  In plaats van te hoeven wachten tot een systeem 256k naar
      &eacute;&eacute;n schijf heeft geschreven, kan een
      <acronym>RAID</acronym>0-systeem tegelijkertijd 64k naar vier
      verschillende schijven schrijven, waardoor superieure I/O
      prestaties worden bereikt.  Deze prestaties kunnen nog verbeterd
      worden door meerdere schijfcontrollers te gebruiken.</para>

    <para>Iedere schijf in een
      <acronym>RAID</acronym>0-aaneenschakeling moet van dezelfde
      grootte zijn, omdat I/O-verzoeken altijd zijn opgebouwd uit
      precies gelijk over de schijven verdeelde verzoeken tot lezen of
      schrijven.</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="geom/striping" align="center">
      </imageobject>

      <textobject>
	<phrase>Illustratie aaneengeschakelde schijven</phrase>
      </textobject>
    </mediaobject>

    <procedure>
      <title>Ongeformatteerde ATA-schijven aaneenschakelen</title>

      <step>
	<para>Laad de module <filename>geom_stripe</filename>:</para>

	<screen>&prompt.root; <userinput>kldload geom_stripe</userinput></screen>
      </step>

      <step>
	<para>Zorg ervoor dat er een koppelpunt beschikbaar is.  Als dit
	  volume een rootpartitie wordt, gebruikt dan tijdelijk een
	  ander koppelpunt zoals <filename
	    role="directory">/mnt</filename>:</para>

	<screen>&prompt.root; <userinput>mkdir /mnt</userinput></screen>
      </step>

      <step>
	<para>Stel de apparaatnamen voor de schijven vast die aaneen
	  worden geschakeld en maak het nieuwe apparaat aan.  Om twee
	  ongebruikte, ongepartitioneerde <acronym>ATA</acronym>
	  schijven aaneen te schakelen (<filename>/dev/ad2</filename>
	  en <filename>/dev/ad3</filename>):</para>

	<screen>&prompt.root; <userinput>gstripe label -v st0 /dev/ad2 /dev/ad3</userinput></screen>

<!--
    <para>A message should be returned explaining that meta data has
      been stored on the devices.
XXX: What message?  Put it inside the screen output above.
-->
      </step>

      <step>
	<para>Schrijf een standaard label naar de nieuwe partitie, ook
	  wel bekend als een partitietabel en installeer de standaard
	  opstart code:</para>

	<screen>&prompt.root; <userinput>bsdlabel -wB /dev/stripe/st0</userinput></screen>
      </step>

      <step>
	<para>Dit proces hoort twee nieuwe apparaten gemaakt te hebben
	  in de map <filename role="directory">/dev/stripe</filename>
	  naast het apparaat <devicename>st0</devicename>, te weten
	  <devicename>st0a</devicename> en
	  <devicename>st0c</devicename>.  Vanaf nu kan er een
	  bestandssysteem op <devicename>st0a</devicename> worden
	  gezet met behulp van de <command>newfs</command> applicatie:</para>

	<screen>&prompt.root; <userinput>newfs -U /dev/stripe/st0a</userinput></screen>

	<para>Na het uitvoeren van het bovenstaande commando rollen er
	  veel getallen over het scherm en na een aantal seconden is
	  het proces afgerond.  Het volume is gereed en klaar om
	  gemount te worden.</para>
      </step>
    </procedure>

    <para>Om de nieuwe aaneengeschakelde schijf handmatig te koppelen
      moet het volgende gedaan worden:</para>

    <screen>&prompt.root; <userinput>mount /dev/stripe/st0a /mnt</userinput></screen>

    <para>Om dit aaneengeschakelde bestandssysteem automatisch te
      mounten bij het opstarten kan de volume-informatie in
      <filename>/etc/fstab</filename> gezet worden:</para>

    <screen>&prompt.root; <userinput>echo "/dev/stripe/st0a /mnt ufs rw 2 2" \</userinput>
      <userinput>&gt;&gt; /etc/fstab</userinput></screen>

    <para>Laadt de module <filename>geom_stripe</filename> ook automatisch
      bij het initialiseren van een systeem door de volgende regel toe
      te voegen aan <filename>/boot/loader.conf</filename>:</para>

    <screen>&prompt.root; <userinput>echo 'geom_stripe_load="YES"' &gt;&gt; /boot/loader.conf</userinput></screen>
  </sect1>

  <sect1 id="GEOM-mirror">
    <title>RAID1 - spiegelen</title>

    <indexterm><primary>GEOM</primary></indexterm>

    <indexterm><primary>schijf spiegelen</primary></indexterm>

    <para>Spiegelen (<quote>mirroring</quote>) is een technologie die
      door veel bedrijven en thuisgebruikers wordt ingezet om gegevens
      te back-uppen zonder onderbrekingen.  Als er een spiegel bestaat,
      betekent dat eenvoudigweg dat schijfB een kopie is van schijfA,
      of misschien zijn schijvenC+D een kopie van schijvenA+B.  Los van
      de schijfinstellingen is het belangrijkste aspect dat de
      gegevens van de ene schijf of partitie worden gerepliceerd naar
      de andere.  Later kunnen die gegevens eenvoudiger worden hersteld
      of geback-upped zonder dat dit leidt tot onderbrekingen in
      dienstverlening of toegang tot gegevens en schijven kunnen zelfs
      fysiek worden opgeslagen in een kluis.</para>

    <para>Begin met een systeem dat twee schijven heeft van gelijke
      grootte.  Deze oefening stelt dat het directe toegang
      (&man.da.4;) <acronym>SCSI</acronym>-schijven zijn.</para>

    <para>Begin door &os; te installeren op de eerste schijf met twee
      partities.  Een van de twee moet een swap-partitie zijn die twee
      keer de grootte van het RAM-geheugen is en de rest van de ruimte
      moet toegewezen worden aan het root bestandssysteem (<filename
	role="directory">/</filename>).  Er zouden eigen partities
      gemaakt kunnen worden voor andere koppelpunten, maar hierdoor
      wordt de moeilijkheidsgraad wel tien keer hoger doordat de
      instellingen voor &man.bsdlabel.8; and &man.fdisk.8; handmatig
      gewijzigd moeten worden.</para>

    <para>Herstart en wacht tot het systeem volledig is
      ge&iuml;nitialiseerd.  Meld daarna aan als gebruiker
      <username>root</username>.</para>

    <para>Maak het apparaat <filename>/dev/mirror/gm</filename> en link
      het aan <filename>/dev/da1</filename>:</para>

    <screen>&prompt.root; <userinput>gmirror label -vnb round-robin gm0 /dev/da1</userinput></screen>

    <para>Het systeem hoort te antwoorden met:</para>

    <screen>Metadata value stored on /dev/da1.
Done.</screen>

    <para>Initialiseer GEOM, waardoor de kernelmodule
      <filename>/boot/kernel/geom_mirror.ko</filename> wordt
      geladen:</para>

    <screen>&prompt.root; <userinput>gmirror load</userinput></screen>

    <note>
      <para>Dit commando hoort de apparaatnode
	<devicename>gm0</devicename> gemaakt te hebben onder de map
	<filename role="directory">/dev/mirror</filename>.</para>
    </note>

    <para>Installeer het algemene <command>fdisk</command> label en de
      bootcode op het nieuw aangemaakte apparaat
      <devicename>gm0</devicename>:</para>

    <screen>&prompt.root; <userinput>fdisk -vBI /dev/mirror/gm0</userinput></screen>

    <para>Installeer nu de algemene <command>bsdlabel</command>
      informatie:</para>

    <screen>&prompt.root; <userinput>bsdlabel -wB /dev/mirror/gm0s1</userinput></screen>

    <note>
      <para>Als meerdere slices en partities bestaan, dienen de vlaggen
	voor de vorige twee commando's anders te zijn.  Ze moeten
	gelijk zijn aan de groottes van de slice en partitie van de
	andere schijf.</para>
    </note>

    <para>Gebruik &man.newfs.8; om een standaard <acronym>UFS</acronym>
      bestandssysteem te maken op de apparaatnode
      <devicename>gm0s1a</devicename>:</para>

    <screen>&prompt.root; <userinput>newfs -U /dev/mirror/gm0s1a</userinput></screen>

    <para>Door het bovenstaande commando spuugt een systeem wat
      informatie uit en wat getalletjes.  Dat is goed.  Bekijk de
      uitvoer op het voorkomen van foutmeldingen en koppel het apparaat
      op het koppelpunt <filename
	role="directory">/mnt</filename>:</para>

    <screen>&prompt.root; <userinput>mount /dev/mirror/gm0s1a /mnt</userinput></screen>

    <para>Verplaats nu alle gegevens van de bootschijf naar dit nieuwe
      bestandssysteem.  In dit voorbeeld worden &man.dump.8; en
      &man.restore.8; gebruikt, maar &man.dd.1; werkt ook in dit
      scenario.</para>

    <screen>&prompt.root; <userinput>dump -L -0 -f- / |(cd /mnt &amp;&amp; restore -r -v -f-)</userinput></screen>

    <para>Dit dient voor ieder bestandssysteem uitgevoerd te worden.
      Plaats eenvoudigweg het juiste bestandssysteem op de juiste
      plaats bij het uitvoeren van het voorgaande commando.</para>

    <para>Wijzig nu het gerepliceerde bestand
      <filename>/mnt/etc/fstab</filename> en verwijder het swapbestand
      of plaats er een commentaarteken voor.
      <footnote>
	<para>Het uitcommentari&euml;ren van de regel voor het
	  swapbestand in <filename>fstab</filename> zorgt er
	  waarschijnlijk voor dat het beschikbaar maken van swapruimte
	  op een andere manier bewerkstelligd moet worden. In <xref
	    linkend="adding-swap-space"> staat daarover meer
	  informatie.</para>
      </footnote>
      Wijzig de informatie voor de andere bestandssystemen zodat ze de
      nieuwe schijf gebruiken, zie daarvoor het volgende voorbeeld:</para>

    <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
#/dev/da0s2b             none            swap    sw              0       0
/dev/mirror/gm0s1a       /               ufs     rw              1       1</programlisting>

    <para>Maak nu een bestand <filename>boot.config</filename> aan op zowel
      de huidige als de nieuwe rootpartitie.  Dit bestand
      <quote>helpt</quote> het <acronym>BIOS</acronym> van een systeem
      op te starten vanaf de juiste schijf:</para>

    <screen>&prompt.root; <userinput>echo "1:da(1,a)/boot/loader" &gt; /boot.config</userinput>
&prompt.root; <userinput>echo "1:da(1,a)/boot/loader" &gt; /mnt/boot.config</userinput></screen>

    <note>
      <para>Dit bestand dient op beide rootpartities te staan om zeker
	te stellen dat een systeem goed opstart.  Als een systeem om
	welke reden dan ook niet kan lezen van de nieuwe rootpartitie,
	dan is een achtervang beschikbaar.</para>
    </note>

    <para>Zorg ervoor dat de <filename>geom_mirror.ko</filename>
      module automatisch geladen wordt tijdens het opstarten van het
      systeem:</para>

    <screen>&prompt.root; <userinput>echo 'geom_mirror_load="YES"' &gt;&gt; /mnt/boot/loader.conf</userinput></screen>

    <para>Hiermee wordt aan &man.loader.8; aangegeven dat de module
      <filename>geom_mirror.ko</filename> geladen moet worden tijdens
      de initialisatie van een systeem.</para>

    <para>Herstart het systeem:</para>

    <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

    <para>Als alles goed is gegaan, hoort het systeem gestart te zijn
      vanaf het apparaat <filename>gm0s1a</filename> en er moet een
      <command>login</command> prompt staan te wachten.  Als er iets
      mis is gegaan, kijk dan in de volgende sectie voor het oplossen
      van problemen.  Voeg nu de schijf <filename>da0</filename> toe
      aan het apparaat <filename>gm0</filename>:</para>

    <screen>&prompt.root; <userinput>gmirror configure -a gm0</userinput>
&prompt.root; <userinput>gmirror insert gm0 /dev/da0</userinput></screen>

    <para>De vlag <option>-a</option> geeft &man.gmirror.8; aan dat
      automatische synchronisatie gebruikt moet worden, ofwel dat
      schrijfbewerkingen naar schijf automatisch gespiegeld moeten
      worden.  In de hulppagina wordt beschreven hoe schijven herbouwd
      en vervangen kunnen worden, hoewel daar
      <devicename>data</devicename> wordt gebruikt in plaats van
      <devicename>gm0</devicename>.</para>

    <sect2>
      <title>Problemen oplossen</title>

      <sect3>
	<title>Systeem weigert op te starten</title>

	<para>Als een systeem opstart in een prompt dat op het volgende
	  lijkt:</para>

	<programlisting>ffs_mountroot: can't find rootvp
Root mount failed: 6
mountroot></programlisting>

	<para>Herstart te machine met de aan/uit-schakelaar of met de
	  resetknop.  Selecteer in het bootmenu optie zes (6).
	  Hierdoor komt een systeem in een &man.loader.8; prompt.  Laad
	  de kernelmodules handmatig:</para>

	<screen>OK? <userinput>load geom_mirror</userinput>
OK? <userinput>boot</userinput></screen>

	<para>Als dit werkt werd de module om welke reden dan ook niet
	  juist geladen.  Zet de onderstaande regel in het bestand met
	  kernelinstellingen en herbouw en installeer de kernel.</para>

	<programlisting>options	GEOM_MIRROR</programlisting>

	<para>Hiermee moet het probleem opgelost zijn.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="geom-ggate">
    <title>GEOM Gate netwerk apparaten</title>

    <para>GEOM ondersteund het op afstand gebruiken van apparaten, zoals
      schijven, CD-ROMs, bestanden, etc. door het gebruik van de gate
      applicaties.  Dit is vergelijkbaar met <acronym>NFS</acronym>.</para>

    <para>Om te beginnen moet er een exports bestand gemaakt worden.
      Dit bestand specificeert wie de geexporteerde bron mag benaderen
      en welke rechten er op dat moment verleend worden.  Bijvoorbeeld
      om de vierde slice te exporteren van de eerste
      <acronym>SCSI</acronym> schijf, moet het volgende in
      <filename>/etc/gg.exports</filename> gezet worden:</para>

    <programlisting>192.168.1.0/24 RW /dev/da0s4d</programlisting>

    <para>Dit staat alle machines in het prive netwerk toe om het
      bestandssysteem op <devicename>da0s4d</devicename> te benaderen.</para>

    <para>Om dit apparaat te kunnen exporteren is het van belang dat de
      schijf nog niet gekoppeld is en moet de &man.ggated.8; dienst
      gestart worden.</para>

    <screen>&prompt.root; <userinput>ggated</userinput></screen>

    <para>Om vervolgens het apparaat aan een client machine te koppelen
      moet het volgende gedaan worden:</para>

    <screen>&prompt.root; <userinput>ggatec create -o rw 192.168.1.1 /dev/da0s4d</userinput>
ggate0
&prompt.root; <userinput>mount /dev/ggate0 /mnt</userinput></screen>

    <para>Vanaf dit moment kan de schijf benaderd worden via het
      <filename role="directory">/mnt</filename> koppelpunt.</para>

    <note>
      <para>Let op, dit mislukt als de schijf reeds gekoppeld is op
	de server machine of als deze reeds gekoppeld is aan een andere
	machine op het netwerk.</para>
    </note>

    <para>Zodra het apparaat niet langer nodig is, kan het veilig
      ontkoppeld worden met behulp van &man.umount.8; net zoals met
      elke andere schijf.</para>
    </sect1>

    <sect1 id="geom-glabels">
      <title>Het labelen van schijven</title>

      <indexterm><primary>GEOM</primary></indexterm>

      <indexterm><primary>Disk Labels</primary></indexterm>

      <para>Tijdens het initialiseren van het systeem zal de &os; kernel
	apparaatnodes creeeren nadat het een apparaat gevonden heeft.
	Deze manier om te zoeken naar apparaten levert wat problemen op
	bijvoorbeeld wanneer er een nieuwe schijf wordt toegevoegd via
	<acronym>USB</acronym>.  Het is hoogst waarschijnlijk dat een
	flash apparaat een apparaatnode krijgt van
	<devicename>da0</devicename>, waarna de originele
	<devicename>da0</devicename> op schuift naar
	<devicename>da1</devicename>.  Dit levert problemen op als
	bestandssystemen worden gekoppeld als ze gedefinieerd zijn in
	<filename>/etc/fstab</filename>, dit kan zelfs ertoe leiden dat
	het systeem niet opstart.</para>

      <para>Een mogelijke oplossing hiervoor is om de
	<acronym>SCSI</acronym> schijven een vaste plek te geven op
	een bepaalde volgorde, zodat zodra er een nieuwe schijf geplaatst
	wordt, deze een ongebruikt apparaatnode toegewezen krijgt.  Maar
	wat als er <acronym>USB</acronym> apparaten zijn die de primaire
	<acronym>SCSI</acronym> disk vervangt?  Dit gebeurd omdat
	<acronym>USB</acronym> apparaten meestal eerder gevonden worden
	dan een <acronym>SCSI</acronym> kaart.  Een oplossing hiervoor
	is om de apparaten pas toe te voegen als het systeem reeds
	gestart is, een andere methode kan zijn om alleen een enkele
	<acronym>ATA</acronym> schijf te koppelen en nooit
	<acronym>SCSI</acronym> schijven door middel van
	<filename>/etc/fstab</filename>.</para>

    <para>Maar er is een betere oplossing beschikbaar.  Door het gebruik
      van <command>glabel</command> kunnen beheerders en gebruikers een
      label toevoegen aan een schijf, en deze labels gebruiken in
      <filename>/etc/fstab</filename>.  Omdat <command>glabel</command>
      het label bewaard in de laatste sector van de schijf, kan het
      label bewaard blijven ook na een reboot en kan het
      bestandssysteem altijd gekoppeld worden ongeacht welke apparaatnode
      toegekend is aan het apparaat.</para>

    <note>
      <para>Uiteraard hoeft een label niet permanent te zijn, het
	<command>glabel</command> programma kan zowel tijdelijke als
	permanente labels aanmaken.  Alleen een permanent label blijft
	beschikbaar ook na een reboot.  Zie de &man.glabel.8; handleiding
	voor meer informatie over de verschillen tussen de
	labeltypes.</para>
    </note>

    <sect2>
      <title>Label types en voorbeelden</title>

      <para>Er zijn twee type labels: een generiek label en een
	tijdelijk label.  Het verschil tussen de labels zit hem in
	de automatische herkennen die gekoppeld zijn aan permanente
	labels en het feit dat dit type label ook beschikbaar blijft
	na een herstart van het systeem.  Deze labels krijgen een
	speciale directory toegewezen in
	<filename class="directory">/dev</filename>, welke genoemd
	wordt naar het bestandssysteem type.  Bijvoorbeeld
	<acronym>UFS</acronym>2 labels worden geplaatst in de
	<filename class="directory">/dev/ufs2</filename> directory.

      <para>Een generiek label verdwijnt na een herstart van het systeem.
	Deze labels worden gecreeerd in
	<filename class="directory">/dev/label</filename> en zijn
	perfect voor experimenten.</para>
<!-- XXXTR: How do you create a file system label without running newfs
            or when there is no newfs (e.g.: cd9660)? -->

      <para>Permanente labels kunnen op het bestandssysteem gezet worden
	door gebruik van het <command>tunefs</command> of
	<command>newfs</command> commando.  Om een permanent label te
	schrijven voor een <acronym>UFS</acronym>2 bestandssysteem
	zonder de huidige data te vernietigen:</para>

      <screen>&prompt.root; <userinput>tunefs -L <replaceable>home</replaceable> <replaceable>/dev/da3</replaceable></userinput></screen>

      <warning>
	<para>Als het bestandssyteem vol is kan dit leiden tot data
	  corruptie; echter als het bestandssysteem vol is zou het
	  hoofddoel moeten zijn om oude achtergebleven bestanden weg
	  te halen in plaats van het toevoegen van labels.</para>
      </warning>

      <para>Er zou nu een label moeten bestaan in
	<filename class="directory">/dev/ufs2</filename>, welke
	toegevoegd kan worden aan het <filename>/etc/fstab</filename>
	bestand:</para>

      <programlisting>/dev/ufs2/home	/home            ufs     rw              2      2</programlisting>

      <note>
	<para>Het bestandssysteem mag niet gekoppeld zijn op het moment
	  dat <command>tunefs</command> gebruikt wordt.</para>
      </note>

      <para>Nu kan het bestandssysteem net als normaal worden gekoppeld:</para>

      <screen>&prompt.root; <userinput>mount /home</userinput></screen>

      <para>Vanaf dit moment is het mogelijk om, zolang de
	<filename>geom_label.ko</filename> geladen wordt tijdens het
	opstarten van het systeem, of als deze is meegecompileerd door
	middel van de <literal>GEOM_LABEL</literal> optie in de kernel,
	de apparaatnode te wijzigen zonder ernstige gevolgen voor het
	systeem.</para>

      <para>Bestandssystemen kunnen ook een standaard label mee krijgen
	door gebruik te maken van de <option>-L</option> optie met het
	<command>newfs</command> commando.  Zie de &man.newfs.8;
	handleiding voor meer informatie.</para>

      <para>Het volgende commando kan worden gebruikt om een label te
	verwijderen:</para>

      <screen>&prompt.root; <userinput>glabel destroy home</userinput></screen>
    </sect2>
  </sect1>

  <sect1 id="geom-gjournal">
    <title>UFS logboeken door middel van GEOM</title>

    <indexterm><primary>GEOM</primary></indexterm>

    <indexterm><primary>Journaling</primary></indexterm>

    <para>Met de komst van &os;&nbsp;7.0 komt ook de langverwachte
      optie van <acronym>UFS</acronym> logboeken.  De implementatie
      zelf is gedaan door middel van het GEOM subsysteem, welke
      makkelijk geconfigureerd kan worden met behulp van de
      &man.gjournal.8; applicatie.</para>

    <para>Wat is logboeken? Logboek mogelijkheden betekend het opslaan
      van bestandssysteem transacties, zoals wijzigingen die een
      complete schrijf actie zijn, voor er meta-data wordt toegevoegd
      en voor de wijzigingen op schijf worden gezet.  Deze transactie
      log kan later opnieuw afgespeeld worden om te voorkomen dat er
      bestandssysteem inconsistenties voorkomen.</para>

    <para>Deze methode is een extra manier om te beschermen tegen
      data verlies en inconsistenties van het bestandssysteem.  In
      tegenstelling tot Soft Updates, welke bijhoud welke meta-data
      wijzigingen er worden uitgevoerd en Snapshots, wat een beeld
      bestand is van het bestandssysteem, wordt er een complete log
      bewaard in de laatste sector, of zoals in sommige gevallen op
      een compleet andere schijf.</para>

    <para>In tegenstelling tot andere logboek implementaties is de
      <command>gjournal</command> methode blok gebaseerd en niet
      geimplementeerd als onderdeel van het bestandssysteem maar als
      uitbreiding op <acronym>GEOM</acronym>.</para>

    <para>Om ondersteuning in te schakelen voor
      <command>gjournal</command>, moet de kernel over de volgende optie
      beschikken, welke standaard is op 7.x systemen:</para>

    <programlisting>options        UFS_GJOURNAL</programlisting>

    <para>Het creeeren van een logboek op een vrij en beschikbaar
      bestandssysteem kan nu gedaan worden met behulp van de volgende
      stappen, ervanuit gaande dat <devicename>da4</devicename> de
      nieuwe beschikbare <acronym>SCSI</acronym> schijf is:</para>

    <screen>&prompt.root; <userinput>gjournal label /dev/da4</userinput>
&prompt.root; <userinput>gjournal load</userinput></screen>

    <para>Op dit moment zou er een <devicename>ad4</devicename>
      apparaatnode en een <devicename>ad4.journal</devicename>
      apparaatnode moeten zijn.  Nu kan er een bestandssysteem op
      gezet worden:</para>

    <screen>&prompt.root; <userinput>newfs -O 2 -J /dev/da4.journal</userinput></screen>

    <para>Het hiervoor ingevoerde commando zal een
      <acronym>UFS</acronym>2 bestandssysteem met logboek
      ondersteuning aanmaken.</para>
 
    <para>Koppel het apparaat op een gewenst koppelpunt met:</para>

    <screen>&prompt.root; <userinput>mount /dev/da4.journal <replaceable>/mnt</replaceable></userinput></screen>

    <note>
      <para>In het geval dat er meerdere slices zijn, zal er een logboek
	voor elke slice gecreeerd worden.  Bijvoorbeeld, als
	<devicename>ad4s1</devicename> en <devicename>ad4s2</devicename>
	allebei slices zijn, dan zal <command>gjournal</command> een
	<devicename>ad4s1.journal</devicename> en een
	<devicename>ad4s2.journal</devicename> creeeren.  In het geval
	dat het commando twee keer gestart wordt, wordt het resultaat
	<quote>journals</quote>.</para>
    </note>
    
    <para>In sommige gevallen kan het gewenst zijn om het logboek op een
      andere schijf te bewaren.  Voor deze gevallen moet de
      logboekleverancier of het opslagapparaat gespecificeerd worden
      achter het apparaat waarop de logboek functionaliteit aangebracht
      moet worden.  De logboek functionaliteit kan ook worden ingeschakeld
      op een reeds bestaand systeem met behulp van
      <command>tunefs</command>.  Maak echter altijd een backup voor dat
      dit soort dingen uitgeprobeerd worden.  In de meeste gevallen zal
      <command>gjournal</command> falen als het geen actueel logboek
      kan maken, maar het voorkomt geen dataverlies als gevolg van
      verkeerd gebruik van <command>tunefs</command>.</para>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
