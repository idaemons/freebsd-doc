<!--
     The FreeBSD Dutch Documentation Project

     $FreeBSD$
     $FreeBSDnl: nl_NL.ISO8859-1/books/handbook/cutting-edge/chapter.sgml,v 1.42 2005/09/23 17:09:55 siebrand Exp $
     Gebaseerd op: 1.219
-->

<chapter id="cutting-edge">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Geherstructureerd, gereorganiseerd en delen bijgewerkt door </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Origineel door </contrib>
      </author>
      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Remko</firstname>
	<surname>Lodder</surname>
	<contrib>Vertaald door </contrib>
      </author>
      <author>
	<firstname>Siebrand</firstname>
	<surname>Mazeland</surname>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Het scherp van de snede</title>

  <sect1 id="cutting-edge-synopsis">
    <title>Overzicht</title>

    <para>&os; wordt ontwikkeld tussen de verschillende versies in.
      Voor mensen die het nieuwste van het nieuwste willen hebben zijn
      er verschillende makkelijke mechanismes om een systeem
      gesynchroniseerd te houden met de laatste ontwikkelingen.  Wees
      gewaarschuwd: het nieuwste van het nieuwste is niet voor
      iedereen geschikt!  Dit hoofdstuk helpt om een keuze te maken of
      het wenselijk is het ontwikkelsysteem te volgen of
      &eacute;&eacute;n van de uitgegeven versies.</para>

    <para>Na het lezen van dit hoofdstuk weet de lezer:</para>

    <itemizedlist>
      <listitem>
	<para>De verschillen tussen de ontwikkeltakken &os.stable; en
	  &os.current;;</para>
      </listitem>

      <listitem>
	<para>Hoe een systeem bijgewerkt kan worden met
	  <application>CVSup</application>,
	  <application>CVS</application> of
	  <application>CTM</application>;</para>
      </listitem>

      <listitem>
	<para>Hoe een basissysteem opnieuw te compileren en
	  te herinstalleren met <command>make buildworld</command>,
	  enzovoort.</para>
      </listitem>
    </itemizedlist>

    <para>Veronderstelde criteria:</para>

    <itemizedlist>
      <listitem>
	<para>Een juist ingesteld netwerk (<xref
	    linkend="advanced-networking">);</para>
      </listitem>

      <listitem>
	<para>Weten hoe software van derden te installeren (<xref
	    linkend="ports">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="current-stable">
    <title>&os.current; vs. &os.stable;</title>

    <indexterm><primary>-CURRENT</primary></indexterm>

    <indexterm><primary>-STABLE</primary></indexterm>

    <para>Er zijn twee ontwikkeltakken voor &os;: &os.current; en
      &os.stable;.  Deze sectie licht beiden toe en beschrijft hoe een
      systeem bijgewerkt te houden met elke tak.  &os.current; wordt
      eerst behandeld, daarna &os.stable;.</para>

    <sect2 id="current">
      <title>Bijblijven met &os;</title>

      <para>Bedenk dat &os.current; het <quote>nieuwste van het
	  nieuwste</quote> is van &os; ontwikkeling.  Van &os.current;
	gebruikers wordt verwacht dat ze veel technische kennis hebben
	en capabel zijn om zelfstandig lastige systeemproblemen op te
	lossen.  Nieuwe gebruikers van &os; kunnen het beste twee keer
	nadenken alvorens het te installeren.</para>

      <sect3>
	<title>Wat is &os.current;?</title>

	<indexterm><primary>momentopname</primary></indexterm>

	<para>&os.current; is de laatste werkende set broncode voor
	  &os;.  Dit bevat werk in uitvoering, experimentele
	  wijzigingen en overgangsmechanismes die mogelijk wel of niet
	  meegenomen worden in de volgende offici&euml;le uitgave van
	  het besturingssysteem.  Alhoewel veel &os;-ontwikkelaars de
	  broncode van &os.current; dagelijks compileren, zijn er
	  periodes dat de broncode niet compileerbaar is.  Deze
	  problemen worden zo snel mogelijk gerepareerd, maar het is
	  mogelijk dat &os.current; een ramp veroorzaakt in plaats van
	  dat het de gewenste functionaliteit levert.  Dit ligt geheel
	  aan het moment waarop de broncode is opgehaald.</para>
      </sect3>

      <sect3>
	<title>Wie heeft &os.current; nodig?</title>

	<para>&os.current; is beschikbaar voor drie primaire
	  aandachtsgroepen:</para>

	<orderedlist>
	  <listitem>
	    <para>Leden van de &os;-gemeenschap die actief werken aan
	      een deel van de broncode voor wie <quote>current</quote>
	      een echte eis is.</para>
	  </listitem>

	  <listitem>
	    <para>Leden van de &os;-gemeenschap die actief testen en
	      tijd hebben om problemen op te lossen om zeker te stellen
	      dat &os.current; zo gezond als mogelijk is.  Er zijn ook
	      mensen die actuele suggesties maken over wijzigingen
	      en de algemene richting van &os; en die patches
	      opsturen om deze te implementeren.</para>
	  </listitem>

	  <listitem>
	    <para>Diegenen die alleen een oogje in het zeil willen
	      houden of de huidige bronnen gebruiken ter referentie
	      (bijvoorbeeld voor het <emphasis>lezen</emphasis> en
	      niet het draaien).  Deze mensen geven ook regelmatig
	      commentaar of dragen bij in de code.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Wat is &os.current; <emphasis>niet</emphasis>?</title>

	<orderedlist>
	  <listitem>
	    <para>Een snelle manier om pre-release versies te krijgen
	      omdat bekend is dat er een aantal leuke nieuwe
	      mogelijkheden in zitten en het leuk is deze als eerste te
	      gebruiken.  Het als eerste gebruiken van nieuwe
	      mogelijkheden betekent ook de eerste zijn die nieuwe bugs
	      ontdekt.</para>
	  </listitem>

	  <listitem>
	    <para>Een snelle manier om bugfixes te krijgen.  Elke
	      willekeurige versie van &os.current; heeft waarschijnlijk
	      net zoveel nieuwe bugs als dat er bugs opgelost
	      zijn.</para>
	  </listitem>

	  <listitem>
	    <para>Op welke manier dan ook
	      <quote>officieel ondersteund</quote>.  We doen onze best
	      om mensen echt te helpen in &eacute;&eacute;n van de drie
	      <quote>legitieme</quote> &os.current; groepen maar er is
	      simpelweg <emphasis>niet genoeg tijd</emphasis> om
	      technische ondersteuning te leveren.  Dit is niet omdat
	      we gemene en vervelende mensen zijn die anderen niet
	      willen helpen (we zouden niet eens aan &os; werken als
	      we dat durfden).  De ontwikkelaars kunnen simpelweg geen
	      honderd berichten per dag beantwoorden
	      <emphasis>&eacute;n</emphasis> aan &os; werken.  Bij de
	      keuze tussen het verbeteren van &os; en vragen
	      beantwoorden over experimentele code, kiezen
	      ontwikkelaars voor het eerste.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>&os.current; gebruiken</title>

	<indexterm>
	  <primary>-CURRENT</primary>

	  <secondary>gebruiken</secondary>
	</indexterm>

	<orderedlist>
	  <listitem>
	    <para>Neem een abonnement op de mailinglijsten
	      &a.current.name; en &a.cvsall.name;.  Dit is niet alleen
	      een goed idee, het is <emphasis>essentieel</emphasis>.
	      Geen berichten ontvangen van de lijst
	      <emphasis>&a.current.name;</emphasis> betekent geen
	      commentaar zien dat mensen maken over de huidige staat
	      van het systeem en dus waarschijnlijk struikelen over
	      problemen die anderen al gevonden en opgelost hebben.
	      Nog belangrijker is het missen van belangrijke informatie
	      die kritisch kan zijn voor een systeem.</para>

	    <para>De lijst &a.cvsall.name; biedt de mogelijkheid de
	      wijzigingsboodschap te zien voor elke wijziging die
	      gemaakt wordt samen met relevante informatie over
	      mogelijke bijwerkingen.</para>

	    <para>Ga om op deze lijsten of &eacute;&eacute;n van de
	    andere beschikbare lijsten te abonneren naar
	    &a.mailman.lists.link; en klik op de gewenste lijst.
	    Instructies over de rest van de procedure zijn daar
	    beschikbaar.</para>
	  </listitem>

	  <listitem>
	    <para>Haal de broncode van een &os;
	      <link linkend=" mirrors">mirrorsite</link>.  Dit kan op
	      de volgende twee manieren:</para>

	    <orderedlist>
	      <indexterm><primary><command>cvsup</command></primary></indexterm>

	      <indexterm><primary><command>cron</command></primary></indexterm>

	      <indexterm>
		<primary>-CURRENT</primary>

		<secondary>Synchroniseren met <application>CVSup</application></secondary>
	      </indexterm>

	      <listitem>
		<para>Gebruik het programma <link
		    linkend="cvsup">cvsup</link> met de
		  <filename>supfile</filename> genaamd
		  <filename>standard-supfile</filename> uit
		  <filename>/usr/share/examples/cvsup</filename>.  Dit
		  is de geadviseerde methode, omdat de gehele collectie
		  in &eacute;&eacute;n keer wordt binnengehaald en
		  daarna alleen hetgeen wat gewijzigd is.  Veel mensen
		  draaien <command>cvsup</command> vanuit de
		  <command>cron</command> en houden daarmee hun
		  broncode automatisch bijgewerkt.  De voorbeeld
		  <filename>supfile</filename> dient aangepast te
		  worden om <link linkend="cvsup">cvsup</link> in te
		  stellen voor een omgeving.</para>
	      </listitem>

	      <indexterm>
		<primary>-CURRENT</primary>

		<secondary>Synchroniseren met CTM</secondary>
	      </indexterm>

	      <listitem>
		<para>Gebruik de <application><link
		  linkend="ctm">CTM</link></application> faciliteit.
		  Bij een <quote>slechte verbinding</quote>, dure
		  connecties of alleen e-mail toegang, is
		  <application>CTM</application> een optie.  Het werkt
		  echter lastig en geeft mogelijk corrupte bestanden.
		  Dit zorgt ervoor dat het zelden gebruikt wordt, dat
		  de kans verhoogt dat het niet werkt voor redelijk
		  lange periodes.  Het advies is
		  <application><link
		      linkend="cvsup">CVSup</link></application> te
		  gebruiken.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Als de broncode wordt opgehaald om te draaien en niet
	      alleen om naar te kijken, haal dan
	      <emphasis>alles</emphasis> op van &os.current; en niet
	      alleen geselecteerde delen.  De reden hiervoor is dat
	      verschillende delen van de code afhangen van updates
	      op andere plekken en het compileren van een onderdeel
	      gegarandeerd problemen oplevert.</para>

	    <indexterm>
	      <primary>-CURRENT</primary>

	      <secondary>compileren</secondary>
	    </indexterm>

	    <para>Voordat &os.current; gecompileerd wordt is het
	      raadzaam om de <filename>Makefile</filename> in
	      <filename>/usr/src</filename> aandachtig te bekijken.
	      Het is handig om de eerste keer op zijn minst <link
		linkend="makeworld">de kernel en de
		<quote>wereld</quote> opnieuw te bouwen</link> als
		onderdeel van het updateproces.  Via de
	      &a.current; en <filename>/usr/src/UPDATING</filename> is
	      het mogelijk op de hoogte te blijven van mogelijke
	      wijzigingen in de opstartprocedures die soms nodig zijn
	      tussen verschillende versies.</para>
	  </listitem>

	  <listitem>
	    <para>Wees actief!  Ervaringen van &os.current;-gebruikers
	      zijn belangrijk, zeker als het gaat om suggesties voor
	      verbeteringen of bugfixes.  Suggesties met bijbehorende
	      code worden enthousiast ontvangen!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>&os; stabiel houden</title>

      <sect3>
	<title>Wat is &os.stable;?</title>

	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; is de ontwikkeltak waaruit grote releases
	  gemaakt worden.  Wijzigingen in deze tak gaan in een ander
	  tempo en met de algemene aanname dat ze eerst in &os.current;
	  worden ingebracht ter test.  Dit is <emphasis>nog
	    steeds</emphasis> een ontwikkeltak, echter dit betekent dat
	  op elk gegeven moment de code voor &os.stable; wel of niet
	  geschikt is voor een speciaal doel.  Het is simpelweg een
	  andere ontwikkelomgeving en geen bron voor
	  eindgebruikers.</para>
      </sect3>

      <sect3>
	<title>Wie heeft &os.stable; nodig?</title>

	<para>Bij interesse in het bijhouden van of bijdragen aan het
	  &os;-ontwikkelproces, speciaal als het gerelateerd is aan de
	  volgende versie van &os;, is het volgen van &os.stable; het
	  overwegen waard.</para>

	<para>Ondanks dat security fixes ook in de &os.stable;-tak
	  komen, hoeft dit <emphasis>niet</emphasis> per se.  In elke
	  beveiligingswaarschuwing voor &os; wordt uitgelegd uit hoe
	  het probleem opgelost kan worden voor de release die het
	  betreft.

	  <footnote>
	    <para>Dit is niet helemaal waar.  Oude releases van &os;
	      kunnen niet eeuwig ondersteund worden, ook al duurt
	      ondersteuning vele jaren.  Een volledige beschrijving van
	      het huidige beveiligingsbeleid voor oudere releases van
	      &os; staat op <ulink
		url="&url.base;/security/">http://www.FreeBSD.org/security/</ulink>.</para>
	  </footnote>

	  Het volgen van de volledige ontwikkeltak alleen om
	  veiligheidsredenen levert ongetwijfeld ongewenste wijzigingen
	  op.</para>

	<para>Ondanks het voornemen ervoor te zorgen dat de
	  &os.stable;-tak compileert en altijd draait, wordt dit niet
	  gegarandeerd.  Terwijl code ontwikkeld wordt in &os.current;
	  voordat die in &os.stable; verwerkt wordt, draaien meer
	  mensen &os.stable; dan &os.current;, dus het is onontkoombaar
	  dat bugs en randgevallen soms in &os.stable; gevonden worden
	  die niet in &os.current; bekend waren.</para>

	<para>Om deze redenen wordt <emphasis>niet</emphasis>
	  aangeraden &os.stable; blindelings te volgen en het is extra
	  belangrijk geen productieservers bij te werken naar
	  &os.stable; zonder de code te testen in een
	  testomgeving.</para>

	<para>Als de mogelijkheden om dit te doen niet beschikbaar
	  zijn, dan is het advies de meest recente release van &os; te
	  draaien en dan de binaire update methode te hanteren om bij
	  te werken tussen verschillende releases.</para>
      </sect3>

      <sect3>
	<title>&os.stable; gebruiken</title>

	<indexterm>
	  <primary>&os.stable;</primary>

	  <secondary>gebruiken</secondary>
	</indexterm>

	<orderedlist>
	  <listitem>
	    <para>Neem een abonnement op de lijst &a.stable.name;.
	      Deze biedt informatie over onderdelen van de build die
	      mogelijk verschijnen in &os.stable; of eventuele andere
	      kwesties die speciale aandacht vereisen.  Ontwikkelaars
	      kondigen in deze mailinglijst ook aan wanneer ze
	      overwegen om een controversi&euml;le fix of aanpassing
	      willen maken, waardoor de gebruikers een kans hebben om
	      te reageren als ze goede redenen hebben tegen de
	      voorgestelde wijziging.</para>

	    <para>De lijst &a.cvsall.name; biedt informatie over de
	      commitlogregels voor elke wijziging zoals deze gemaakt is
	      tezamen met relevante informatie over mogelijke
	      bijwerkingen.</para>

	    <para>Ga om te abonneren op deze lijsten, of
	      &eacute;&eacute;n van de andere beschikbare lijsten
	      naar &a.mailman.lists.link; en klik op de lijst waarop
	      een abonnement gewenst is.  Instructies over de rest van
	      de procedure zijn daar beschikbaar.</para>
	  </listitem>

	  <listitem>
	    <para>Bij installatie van een nieuw systeem dat zo stabiel
	      mogelijk moet zijn kan simpelweg de laatst gedateerde
	      snapshot gehaald worden van <ulink
		url="ftp://snapshots.jp.FreeBSD.org/pub/FreeBSD/snapshots/"></ulink>
	      en deze kan ge&iuml;installeerd worden zoals elke andere
	      release.  Ook kan de meest recente &os.stable; release
	      ge&iuml;nstalleerd worden van de <link
		linkend="mirrors">mirrorsites</link> en kunnen de
	      onderstaande instructies gevolgd worden om een systeem
	      bij te werken naar de meest recente &os.stable;
	      broncode.</para>

	    <para>Als al een vorige release van &os; draait en
	      bijgewerkt moet worden via de broncodes dan kan dat via
	      de &os; <link linkend="mirrors">mirrorsites</link>.  Dit
	      kan op &eacute;&eacute;n van de twee volgende
	      manieren:</para>

	    <orderedlist>
	      <indexterm><primary><command>cvsup</command></primary></indexterm>

	      <indexterm><primary><command>cron</command></primary></indexterm>

	      <indexterm>
		<primary>&os.stable;</primary>

		<secondary>synchroniseren met <application>CVSup</application></secondary>
	      </indexterm>

	      <listitem>
		<para>Gebruik het programma <link
		    linkend="cvsup">cvsup</link> met de
		  <filename>supfile</filename>
		  <filename>stable-supfile</filename> uit de map
		  <filename>/usr/share/examples/cvsup</filename>.
		  Dit is de aanbevolen methode omdat het hiermee
		  mogelijk is de volledige collectie te downloaden en
		  daarna alleen hetgeen wat veranderd is.  Veel mensen
		  draaien <command>cvsup</command> vanuit de
		  <command>cron</command> om de broncodes automatisch
		  bij te werken.  Het voorbeeld van de
		  <filename>supfile</filename> dient aangepast en
		  ingesteld te worden voor de omgeving waarin het
		  instellingenbestand gebruikt wordt.</para>
	      </listitem>

	      <indexterm>
		<primary>&os.stable;</primary>

		<secondary>synchroniseren met CTM</secondary>
	      </indexterm>

	      <listitem>
		<para>Gebruik <application><link
		    linkend="ctm">CTM</link></application> als er geen
		  snelle, goedkope verbinding is met internet.  Dan is
		  dit de methode om te gebruiken.</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Als er snelle on-demand toegang nodig is tot de
	      broncode en bandbreedte is geen overweging, gebruik dan
	      <command>cvsup</command> of <command>ftp</command>.
	      Gebruik anders <application>CTM</application>.</para>
	  </listitem>

	  <indexterm>
	    <primary>&os.stable;</primary>

	    <secondary>compileren</secondary>
	  </indexterm>

	  <listitem>
	    <para>Lees alvorens &os.stable; te compileren goed de
	      <filename>Makefile</filename> in
	      <filename>/usr/src</filename>.  Het is handig om de
	      eerste keer op zijn minst <link linkend="makeworld">de
		kernel en de <quote>wereld</quote> opnieuw te
		bouwen</link> als onderdeel van het updateproces.  Via
	      de &a.stable; en <filename>/usr/src/UPDATING</filename>
	      is het mogelijk op de hoogte te blijven van mogelijke
	      wijzigingen in de opstartprocedures die soms nodig zijn
	      tussen verschillende releases.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Broncode synchroniseren</title>

    <para>Er zijn verschillende manieren om een internet (of e-mail)
      verbinding te gebruiken om bij te blijven met elk onderdeel van
      de &os; projectbronnen of alle onderdelen, afhankelijk van
      het interessegebied.  De primaire diensten zijn <link
	linkend="anoncvs">Anonieme CVS</link> en
      <link linkend="ctm">CTM</link>.</para>

    <warning>
      <para>Ondanks dat het mogelijk is om alleen delen van de
	broncode bij te werken, is de enige ondersteunde methode
	de totale broncode bijwerken en zowel userland (alle
	programma's die in gebruikersruimte draaien, zoals
	programma's in <filename>/bin</filename> en
	<filename>/sbin</filename>) als de kernel opnieuw compileren.
	Als alleen delen van de broncode worden bijgewerkt, alleen de
	kernel of alleen het userland, resulteert dat vaak in
	problemen.  Deze problemen kunnen verschillen van
	compileerfouten tot kernel panics of corruptie van
	gegevens.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>

      <secondary>anoniem</secondary>
    </indexterm>

    <para><application>Anonieme CVS</application> en
      <application>CVSup</application> gebruiken het
      <emphasis>pull</emphasis> model om broncode bij te werken.  In
      het geval van <application>CVSup</application> start de gebruiker
      (of een <command>cron</command> script) het programma
      <command>cvsup</command> waarbij het communiceert met een
      <command>cvsupd</command> server om bestanden bij te werken.  De
      ontvangen updates zijn op de minuut nauwkeurig en ze komen alleen
      wanneer dat is ingesteld.  Updates kunnen eenvoudig beperkt
      worden tot specifieke bestanden of mappen uit een
      interessegebied.  Updates worden automatisch gegenereerd door een
      server, aan de hand van wat is ingesteld.
      <application>Anonieme CVS</application> is veel eenvoudiger dan
      <application>CVSup</application> omdat dat alleen een uitbreiding
      is van <application>CVS</application> die de mogelijkheid biedt
      om wijzigingen direct van een CVS repository op afstand te halen.
      <application>CVSup</application> kan dit veel effici&euml;nter
      doen, maar <application>anonieme CVS</application> is makkelijker
      in het gebruik.</para>

    <indexterm><primary><application>CTM</application></primary></indexterm>

    <para><application>CTM</application> aan de andere kant maakt geen
      vergelijking tussen de aanwezige bronnen en die op de master
      server.  In plaats daarvan wordt een script uitgevoerd dat
      wijzigingen in bestanden ziet sinds de vorige keer dat is
      bijgewerkt en die meerdere keren per dag worden uitgevoerd op de
      master CTM machine.  Elke ontdekte wijziging wordt gecomprimeerd,
      krijgt een volgnummer toegekend en wordt gecodeerd voor
      verzending via e-mail (in leesbare ASCII).  Deze <quote>CTM
	delta's</quote> kunnen dan aangeleverd worden aan
	&man.ctm.rmail.1; die ze automatisch decodeert, controleert en
	toepast in de gebruikerskopie van de bronnen.  Dit proces is
	veel effici&euml;nter dan <application>CVSup</application> en
	claimt minder systeembronnen omdat het model
	<emphasis>push</emphasis> in plaats van
	<emphasis>pull</emphasis> is.</para>

    <para>Er zijn andere nadelen.  Als per ongeluk een deel van het
      archief wordt verwijderd, kan <application>CVSup</application>
      dat detecteren en het beschadigde deel repareren.
      <application>CTM</application> doet dit niet en als een deel van
      de broncode wordt verwijderd (en er geen backup is), dan moet er
      opnieuw begonnen worden (vanaf de meest recente CVS <quote>base
	delta</quote> en moet alles opnieuw opgebouwd worden
      met <application>CTM</application>.  Met
      <application>Anonymous CVS</application> kan simpelweg het
      slechte deel verwijderd worden alvorens weer te
      synchroniseren.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>De <quote>wereld</quote> opnieuw bouwen</title>

    <indexterm><primary><quote>world</quote> opnieuw bouwen</primary></indexterm>

    <para>Zodra de lokale broncode gesynchroniseerd is met een
      bepaalde versie van &os; (&os.stable;, &os.current;, enzovoort)
      kan de broncode gebruikt worden om een systeem te
      herbouwen.</para>

    <warning>
      <title>Maak een backup</title>

      <para>Het kan niet vaak genoeg verteld worden hoe belangrijk het
	is om een backup te maken van een systeem
	<emphasis>v&oacute;&oacute;r</emphasis> deze taak uit te
	voeren.  Ook al is het opnieuw bouwen van de wereld vrij simpel
	(als deze instructies gevolgd worden), er worden ongetwijfeld
	ooit fouten gemaakt, misschien zelfs in de broncode, die het
	onmogelijk maken om een systeem op te starten.</para>

      <para>Wees ervan verzekerd dat er een backup gemaakt is en dat er
	een reparatiediskette of cd-rom bij de hand is.  Deze wordt
	waarschijnlijk nooit gebruikt maar <quote>better safe than
	  sorry</quote>.</para>
    </warning>

    <warning>
      <title>Abonneer op de juiste mailinglijsten</title>

      <indexterm><primary>mailinglijst</primary></indexterm>

      <para>De &os.stable; en &os.current; takken zijn van nature
	<emphasis>in ontwikkeling</emphasis>.  Mensen die bijdragen
	aan &os; zijn menselijk en foutjes ontstaan regelmatig.</para>

      <para>Soms zijn deze foutjes onschadelijk, ze geven dan hooguit
	een nieuwe diagnostische waarschuwing weer.  Maar de wijziging
	kan ook catastrofaal zijn en ervoor zorgen dat een systeem niet
	meer opstart of bestandssystemen vernietigt (of erger).</para>

      <para>Als problemen zoals deze voorkomen wordt er een
	<quote>heads up</quote> naar de juiste mailinglijst gestuurd,
	waarin uitgelegd wordt wat het probleem is en welke systemen
	het raakt.  Er wordt een <quote>all clear</quote> bericht
	gestuurd als het probleem is opgelost.</para>

      <para>&os.stable; of &os.current; volgen zonder de &a.stable; of
	&a.current; te volgen is vragen om problemen.</para>
    </warning>

    <warning>
      <title>Gebruik geen <command>make world</command></title>

      <para>Veel oudere documentatie raadt aan om <command>make
	world</command> te gebruiken.  In dat geval worden er
	belangrijke stappen overgeslagen en gebruik het commando alleen
	als er voldoende kennis over aanwezig is.  In bijna alle
	omstandigheden is <command>make world</command> verkeerd en
	de procedure die hier beschreven is hoort in plaats daarvan
	gebruikt te worden.</para>
    </warning>

    <sect2>
      <title>De universele wijze om een systeem bij te werken</title>

      <para>Een systeem bijwerken kan met de volgende procedure, nadat
	<filename>/usr/src/UPDATING</filename> is geraadpleegd om te
	controleren of er voor buildworld voor de gebruikte versie van
	de broncode nog acties zijn uit te voeren:</para>

      <screen>&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <note>
	<para>Er zijn een aantal zeldzame gevallen waarin
	  <command>mergemaster -p</command> nog een keer moet draaien
	  voor de stap met <maketarget>buildworld</maketarget>.  Deze
	  staan beschreven in <filename>UPDATING</filename>.  In het
	  algemeen kan deze stap echter zonder risico worden
	  overgeslagen als er niet tussen een of meer hoofdversies
	  wordt bijgewerkt.</para>
      </note>

      <para>Nadat <maketarget>installkernel</maketarget> succesvol is
	afgerond, dient er in single-user modus opgestart te worden
	(met <command>boot -s</command> vanaf de loaderprompt).  Draai
	dan:</para>

      <screen>&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Lees verdere uitleg</title>

	<para>De hierboven beschreven volgorde is alleen een korte
	  samenvatting.  Ook de volgende secties lezen geeft een beter
	  beeld van elke stap, met name als er een op maat gemaakte
	  kernelinstelling wordt gebruikt.</para>
      </warning>
    </sect2>

    <sect2>
      <title><filename>/usr/src/UPDATING</filename> lezen</title>

      <para>Lees voor verder te gaan
	<filename>/usr/src/UPDATING</filename> (of het gelijknamige
	bestand waar de kopie van de broncode ook staat).  Dit bestand
	kan belangrijke informatie bevatten over mogelijke problemen of
	specificeert de volgorde waarin bepaalde commando's gestart
	moeten worden.  Als <filename>UPDATING</filename> tegenstrijdig
	is met wat hier wordt beschreven, heeft
	<filename>UPDATING</filename> voorrang.</para>

      <important>
	<para><filename>UPDATING</filename> lezen is geen acceptabele
	  vervanging voor het abonneren op de correcte mailinglijst
	  zoals eerder beschreven.  De twee vullen elkaar aan en zijn
	  niet exclusief.</para>
      </important>
    </sect2>

    <sect2>
      <title><filename>/etc/make.conf</filename> controleren</title>

      <indexterm><primary><filename>make.conf</filename></primary></indexterm>

      <para>Controleer
	<filename>/usr/share/examples/etc/make.conf</filename>
	(<filename>/etc/defaults/make.conf</filename> in
	&os;&nbsp;4.X) en <filename>/etc/make.conf</filename>.  Het
	eerste bestand bevat standaard definities, waarvan de meeste
	uitgecommentarieerd zijn.  Om hiervan gebruik te maken als het
	systeem opnieuw opgebouwd wordt vanuit de broncode, moeten ze
	toegevoegd worden aan <filename>/etc/make.conf</filename>.
	Bedenk dat alles wat toegevoegd wordt aan
	<filename>/etc/make.conf</filename> ook gebruikt wordt bij elk
	<command>make</command> commando.  Het is dus verstandig om
	daar redelijke waardes in te vullen voor een systeem.</para>

      <para>Een typische gebruiker wil waarschijnlijk de regels
	<makevar>CFLAGS</makevar> en <makevar>NOPROFILE</makevar>
	uit <filename>/usr/share/examples/etc/make.conf</filename>
	(<filename>/etc/defaults/make.conf</filename> in &os;&nbsp;4.X)
	kopieren naar <filename>/etc/make.conf</filename> en het
	commentaar verwijderen.</para>

      <para>Bekijk de andere definities (<makevar>COPTFLAGS</makevar>,
	<makevar>NOPORTDOCS</makevar>, enzovoort) en bepaal of deze
	relevant zijn.</para>
    </sect2>

    <sect2>
      <title><filename>/etc</filename> bijwerken</title>

      <para>De map <filename>/etc</filename> bevat een groot deel van
	de systeeminstellingen en scripts die gestart worden tijdens de
	systeemstart.  Sommige van deze scripts verschillen van versie
	tot versie in &os;.</para>

      <para>Sommige van de instellingenbestanden worden dagelijks
	gebruikt voor het draaien van een systeem.  In het bijzonder
	<filename>/etc/group</filename>.</para>

      <para>Er zijn gevallen geweest waarbij het installatiegedeelte
	van <command>make installworld</command> een aantal
	gebruikersnamen of groepen verwachtte.  Als er een upgrade
	wordt uitgevoerd is het waarschijnlijk dat deze gebruikers of
	groepen niet bestaan.  Dit levert problemen op bij upgraden.
	In sommige gevallen controleert <command>make
	  buildworld</command> of deze gebruikers of groepen
	bestaan.</para>

      <para>Een voorbeeld hiervan is het toevoegen van de gebruiker
	<username>smmsp</username>.  Gebruikers hadden een falend
	installatieproces toen &man.mtree.8; probeerde om
	<filename>/var/spool/clientmqueue</filename> te
	cre&euml;ren.</para>

      <para>De oplossing is om <filename>/usr/src/etc/group</filename>
	te controleren en de lijst met groepen te vergelijken met die
	van het bij te werken systeem.  Als daar groepen bestaan die
	nog niet op een systeem staan, moeten deze worden gekopieerd.
	Hetzelfde geldt voor het hernoemen van groepen in
	<filename>/etc/group</filename> die hetzelfde GID hebben maar
	een andere naam dan in
	<filename>/usr/src/etc/group</filename>.</para>

      <para>&man.mergemaster.8; kan in voorbereidende modus gedraaid
	worden als de optie <option>-p</option> wordt meegegeven.  Dan
	worden alleen de bestanden vergeleken die essentieel zijn voor
	het succes van <maketarget>buildworld</maketarget> of
	<maketarget>installworld</maketarget>:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>In <quote>paranoide beheerdersmodus</quote> kan er
	  gecontroleerd worden welke bestanden op een systeem eigendom
	  zijn van de groep die wordt hernoemd of verwijderd:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>Dit commando toont alle bestanden die eigendom zijn van
	  de groep <replaceable>GID</replaceable> (een groepsnaam of
	  een numeriek groeps-ID).</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Systeem naar single-user modus brengen</title>

      <indexterm><primary>single-user modus</primary></indexterm>

      <para>Het kan zijn dat een systeem in single-user modus
	gecompileerd moet worden.  Buiten het duidelijke voordeel dat
	de operatie iets sneller verloopt, is het voordeel dat bij een
	herinstallatie van een systeem een aantal belangrijke
	systeembestanden waaronder binaire systeembestanden,
	bibliotheken, include bestanden, enzovoort, worden aangepast,
	iets wat op een actief systeem vragen om problemen is (zeker
	als er actieve gebruikers op een systeem aanwezig zijn).</para>

      <indexterm><primary>multi-user modus</primary></indexterm>

      <para>Een andere methode is het systeem compileren in multi-user
	modus en daarna naar single-user modus gaan voor de
	installatie.  Bij deze methode moeten de volgende stappen
	gevolgd worden.  Het overschakelen naar single-user modus kan
	uitgesteld worden tot en met
	<maketarget>installkernel</maketarget> of
	<maketarget>installworld</maketarget>.</para>

      <para>Een supergebruiker kan als volgt een draaiend systeem naar
	single-user modus overgeschakelen:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>Als alternatief kan tijdens het opstarten de optie
	<option>-s</option> worden meegegeven.  Het systeem start dan
	in single-user modus.  Op de shell prompt moet dan worden
	ingegeven:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Hierdoor worden de bestandssystemen gecontroleerd,
	<filename>/</filename> met lees en schrijf rechten opnieuw
	gemount, worden alle andere UFS bestandssystemen die in
	<filename>/etc/fstab</filename> staan gemount en wordt swap
	ingeschakeld.</para>

	<note>
	  <para>Als de CMOS-klok ingesteld is naar de lokale tijd en
	    niet naar GMT (dit is waar als het resultaat van
	    &man.date.1; niet de correcte tijd en zone weergeeft), dan
	    is het misschien handig om het volgende commando te
	    starten:</para>

	  <screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	  <para>Dit zorgt ervoor dat de lokale tijdzoneinstellingen
	    correct ingesteld worden.  Zonder deze instelling kunnen er
	    later problemen ontstaan.</para>
	</note>
    </sect2>

    <sect2>
      <title><filename>/usr/obj</filename> verwijderen</title>

      <para>Als delen van een systeem opnieuw gebouwd worden, worden ze
	standaard geplaatst in mappen onder
	<filename>/usr/obj</filename>.  Deze mappen schaduwen de mappen
	onder <filename>/usr/src</filename>.</para>

      <para>Het proces <command>make buildworld</command> kan versneld
	worden en problemen met afhankelijkheden kunnen voorkomen
	worden als deze map wordt verwijderd.</para>

      <para>Sommige bestanden onder <filename>/usr/obj</filename>
	hebben mogelijk de optie <quote>niet aanpassen</quote>
	ingesteld (zie &man.chflags.1;) die eerst verwijderd moet
	worden:</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2>
      <title>Broncode hercompileren</title>

      <sect3>
	<title>Uitvoer bewaren</title>

	<para>Het is een goed idee om de uitvoer van &man.make.1; te
	  bewaren in een ander bestand.  Als er iets misgaat is er een
	  kopie van de foutmelding aanwezig.  Hoewel dit misschien niet
	  helpt in de diagnose van wat er fout is gegaan, kan het
	  anderen helpen als het probleem wordt aangegeven in
	  een &os; mailinglijst.</para>

	<para>De makkelijkste manier om dit te doen is door het
	  commando &man.script.1; te gebruiken, met een parameter
	  die de naam specificeert waar de uitvoer naartoe moet.  Dit
	  moet direct gedaan worden v&oacute;&oacute;r het herbouwen
	  van de wereld, zodat het proces klaar is moet
	  <userinput>exit</userinput> worden ingegeven:</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Bewaar de uitvoer in deze stap <emphasis>niet</emphasis>
	  in <filename>/tmp</filename>.  Deze map wordt mogelijk
	  opgeschoond tijdens de volgende herstart.  Een betere plaats
	  om dit bestand te bewaren is de map
	  <filename>/var/tmp</filename> (zoals in het vorige voorbeeld)
	  of in de thuismap van <username>root</username>.</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>Basissysteem compileren</title>

	<para>Ga naar de map <filename>/usr/src</filename>, tenzij de
	  broncode ergens anders staat, in welk geval naar die map
	  gegaan moet worden:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Om de wereld opnieuw te bouwen moet het commando
	  &man.make.1; gebruikt worden.  Dit commando leest zijn
	  instructies uit het bestand <filename>Makefile</filename>,
	  dat beschrijft hoe de programma's die samen &os; vormen
	  moeten worden gebouwd, in welke volgorde ze gebouwd moeten
	  worden, enzovoort.</para>

	<para>Het algemene formaat van de commandoregel die gebruikt
	  moet worden is als volgt:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABELE</replaceable> <replaceable>doel</replaceable></userinput></screen>

	<para>In dit voorbeeld is de optie
	  <option>-<replaceable>x</replaceable></option> een optie die
	  wordt meegegeven aan &man.make.1;.  In de hulppagina voor
	  &man.make.1; staat een voorbeeld van de opties die meegegeven
	  kunnen worden.</para>

	<para><option>-D<replaceable>VARIABELE</replaceable></option>
	  geeft een variabele door aan <filename>Makefile</filename>.
	  Het gedrag van <filename>Makefile</filename> wordt
	  be&iuml;nvloed door deze variabele.  Dit zijn dezelfde
	  variabelen die ingesteld worden in
	  <filename>/etc/make.conf</filename>.  Deze optie biedt een
	  alternatief om deze opties in te stellen.</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE <replaceable>doel</replaceable></userinput></screen>

	<para>Het bovenstaande commando is een andere manier om aan te
	  geven dat geprofileerde bibliotheken niet gebouwd moeten
	  worden en correspondeert met de onderstaande regel in
	  <filename>/etc/make.conf</filename>:</para>

	<programlisting>NOPROFILE=    true	#    Avoid compiling profiled libraries</programlisting>

	<para><replaceable>doel</replaceable> geeft &man.make.1; aan
	  wat er gedaan moet worden.  Elke
	  <filename>Makefile</filename> definieert een aantal van
	  verschillende doelen en het gekozen doel bepaalt wat er
	  gebeurt.</para>

	<para>Sommige doelen staan vermeld in het bestand
	  <filename>Makefile</filename>, maar zijn niet geschikt om
	  direct te starten.  Integendeel, deze worden gebruikt door
	  het bouwproces om de benodigde stappen onder te
	  verdelen.</para>

	<para>In veel gevallen hoeven er geen parameters te worden
	  meegegeven aan &man.make.1; en dus ziet de commando regel er
	  als volgt uit:</para>

	<screen>&prompt.root; <userinput>make <replaceable>doel</replaceable></userinput></screen>

	<para>Het <maketarget>world</maketarget> doel is opgesplitst in
	  twee delen: <maketarget>buildworld</maketarget> en
	  <maketarget>installworld</maketarget>.  Vanaf versie
	  5.3 van &os; verandert <maketarget>world</maketarget>
	  dusdanig dat het helemaal niet meer werkt omdat het
	  gevaarlijk is voor de meeste gebruikers.</para>

	<para>Zoals de namen impliceren bouwt
	  <maketarget>buildworld</maketarget> een compleet nieuwe boom
	  onder <filename>/usr/obj</filename> en
	  <maketarget>installworld</maketarget> installeert deze boom
	  op de huidige machine.</para>

	<para>Dit is erg handig om twee redenen.  Als eerste biedt het
	  de mogelijkheid om de bouw veilig te doen met de wetenschap
	  dat geen enkel draaiend onderdeel van een systeem geraakt
	  wordt.  De bouw is <quote>zelf ondersteunend</quote>.
	  Hierdoor kan veilig in multi-user modus
	  <maketarget>buildworld</maketarget> gedraaid worden.  Het
	  wordt echter nog steeds aangeraden om
	  <maketarget>installworld</maketarget> in single-user modus te
	  starten.</para>

	<para>Ten tweede geeft het de mogelijkheid om NFS-mounts te
	  gebruiken om meerdere machines in het netwerk bij te werken.
	  Als er drie machines zijn, <hostid>A</hostid>,
	  <hostid>B</hostid> en <hostid>C</hostid>, die bijgewerkt
	  moeten worden, dan kunnen <command>make buildworld</command>
	  en <command>make installworld</command> gedraaid worden op
	  <hostid>A</hostid> waarna <hostid>B</hostid> en
	  <hostid>C</hostid> een NFS-mount kunnen opzetten naar
	  <filename>/usr/src</filename> en
	  <filename>/usr/obj</filename> op machine <hostid>A</hostid>
	  waarna <command>make installworld</command> gedraaid kan
	  worden op <hostid>B</hostid> en <hostid>C</hostid> om de
	  resultaten de installeren.</para>

	<para>Alhoewel het doel <maketarget>world</maketarget> nog wel
	  bestaat wordt het gebruik ervan sterk
	  <emphasis>afgeraden</emphasis>.</para>

	<para>Voer het volgende commando uit:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Het is nu mogelijk om de optie <option>-j</option> mee te
	  geven aan <command>make</command>, wat resulteert in meerdere
	  processen die tegelijkertijd draaien.  Dit heeft het meeste
	  effect op machines met meerdere processoren.  Echter, omdat
	  het compilatieproces meer IO-gericht is dan processorgericht,
	  kan het ook nuttig zijn op systemen met &eacute;&eacute;n
	  processor.</para>

	<para>Start als volgt op een systeem met &eacute;&eacute;n
	 processor:</para>

	<screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; draait dan maximaal 4 processen
	  tegelijkertijd.  In het algemeen blijkt uit de mailinglijsten
	  dat dit de beste resultaten geeft.</para>

	<para>Als er meerdere processoren in een systeem zitten en
	  gebruik gemaakt wordt van een SMP kernel, probeer dan waardes
	  tussen de 6 en 10 en bekijk hoe het systeem reageert.</para>

	<para>Deze mogelijkheid is nog steeds fragiel en commits in de
	  broncode verbreken deze mogelijkheid vaak.  Als het opnieuw
	  bouwen van de wereld mislukt, probeer dan nogmaals te
	  compileren zonder deze opties alvorens een probleemrapport
	  aan te maken.</para>
      </sect3>

      <sect3>
	<title>Doorlooptijd</title>

	<indexterm>
	  <primary><quote>world</quote> opnieuw bouwen</primary>

	  <secondary>doorlooptijd</secondary>
	</indexterm>

	<para>De doorlooptijd wordt door veel factoren be&iuml;nvloed.
	  Een 500&nbsp;MHz &pentium;&nbsp;III met 128&nbsp;MB ram doet
	  er ongeveer 2&nbsp;uur over om de &os.stable; boom te bouwen
	  zonder extra trucjes.  Een &os.current; boom kan wat langer
	  duren.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Nieuwe kernel compileren en installeren</title>

      <indexterm>
	<primary>kernel</primary>

	<secondary>compileren</secondary>
      </indexterm>

      <para>Om volledig gebruik te maken van het nieuwe systeem moet de
	kernel opnieuw gecompileerd worden.  Dit is bijna altijd nodig
	omdat sommige geheugenstructuren mogelijkerwijs veranderd zijn
	en programma's als &man.ps.1; en &man.top.1; niet werken totdat
	de kernel en de broncode dezelfde versie hebben.</para>

      <para>De simpelste en makkelijkste manier om dit te doen is
	om een kernel te maken die gebaseerd is op
	<filename>GENERIC</filename>.  Ondanks dat
	<filename>GENERIC</filename> mogelijk niet alle benodigde
	apparaten heeft voor een systeem, hoort het alles te bevatten
	dat nodig is om een systeem te starten in single-user modus.
	Dit is een goede test op de correcte werking van een nieuw
	systeem.  Na het opstarten van <filename>GENERIC</filename> en
	een systeemcontrole kan erna een nieuwe kernel gebouwd worden
	gebaseerd op een aangepast kernelinstellingenbestand.</para>

      <para>Op moderne versies van &os; is het belangrijk om de
	<link linkend="make-buildworld">wereld opnieuw te bouwen</link>
	voordat een nieuwe kernel gebouwd wordt.</para>

      <note>
	<para>Als een aangepaste kernel gemaakt moet worden en er reeds
	  een instellingenbestand aanwezig is, gebruik dan
	  <literal>KERNCONF=<replaceable>MYKERNEL</replaceable></literal>
	  als volgt:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </note>

      <para>Let op dat als <literal>kern.securelevel</literal> een
	waarde hoger dan 1 heeft <emphasis>of</emphasis>
	<literal>noschg</literal> of gelijksoortige opties geplaatst
	zijn op het binaire kernelbestand, is het misschien nodig om
	terug te gaan naar single-user modus om
	<maketarget>installkernel</maketarget> uit te voeren.  In
	andere gevallen moet het mogelijk zijn om deze commando's
	zonder problemen uit te voeren in multi-user modus.  Zie
	&man.init.8; voor meer informatie over
	<literal>kern.securelevel</literal> en &man.chflags.1; voor
	informatie over diverse bestandsopties.</para>
    </sect2>

    <sect2>
      <title>Opnieuw opstarten in single-user modus</title>

      <indexterm><primary>single-user modus</primary></indexterm>

      <para>Start met de instructies in <xref
	  linkend="makeworld-singleuser"> in single-user modus op om te
	testen of de nieuwe kernel werkt.</para>
    </sect2>

    <sect2>
      <title>Nieuwe binaire systeembestanden installeren</title>

      <para>Na het draaien van <command>make buildworld</command> kan
	nu <maketarget>installworld</maketarget> gebruikt worden om de
	nieuwe binaire systeembestanden te installeren.</para>

      <para>Voer de volgende commando's uit:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Als er variabelen gespecificeerd zijn op de commandoregel
	  van <command>make buildworld</command> moeten dezelfde
	  variabelen gebruikt worden op de commandoregel van
	  <command>make installworld</command>.  Dit is niet per se
	  waar voor opties zoals <option>-j</option>, die nooit
	  gebruikt mogen worden met
	  <maketarget>installworld</maketarget>.</para>

	<para>Als bijvoorbeeld het volgende commando is
	  uitgevoerd:</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE buildworld</userinput></screen>

	<para>Dan moet het resultaat ge&iuml;nstalleerd worden
	  met:</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE installworld</userinput></screen>

	<para>Anders wordt geprobeerd geprofileerde bibliotheken te
	  installeren die niet gebouwd zijn tijdens de fase
	  <command>make buildworld</command>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Bestanden bijwerken die niet bijgewerkt zijn door
	<command>make installworld</command></title>

      <para>Het herbouwen van de wereld werkt bepaalde mappen niet
	bij (in het bijzonder <filename>/etc</filename>,
	<filename>/var</filename> en <filename>/usr</filename>) met
	nieuwe of gewijzigde instellingenbestanden.</para>

      <para>De simpelste manier om deze bestanden bij te werken is door
	&man.mergemaster.8; te gebruiken, maar het is ook mogelijk
	dit handmatig te doen.  Welke manier er ook gekozen wordt, zorg
	er altijd voor dat een backup van <filename>/etc</filename>
	beschikbaar is voor het geval er iets misgaat.</para>

    <sect3 id="mergemaster">
      <sect3info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Bijgedragen door </contrib>
	  </author>
	</authorgroup>
      </sect3info>

      <title><command>mergemaster</command></title>

      <indexterm><primary><command>mergemaster</command></primary></indexterm>

      <para>Het hulpprogramma &man.mergemaster.8; is een Bourne script
	dat helpt bij het bepalen van de verschillen tussen de
	instellingenbestanden in <filename>/etc</filename> en de
	instellingenbestanden in de broncodeboom
	<filename>/usr/src/etc</filename>.  Deze methode wordt
	aangeraden om instellingenbestanden van een systeem bijgewerkt
	te houden met de bestanden die in de broncodeboom staan.</para>

      <para>Het programma wordt gestart met
	<command>mergemaster</command> op de commandoregel en geeft dan
	resultaten weer.  <command>mergemaster</command> bouwt dan een
	tijdelijke root omgeving vanaf <filename>/</filename> en vult
	deze met diverse instellingenbestanden voor een systeem.  Deze
	bestanden worden vergeleken met de bestanden die
	ge&iuml;nstalleerd zijn op een systeem.  Op dit punt worden de
	bestanden getoond die verschillen in het &man.diff.1;-formaat,
	met een <option>+</option> voor toegevoegde of gewijzigde
	regels en een <option>-</option> voor regels die verwijderd of
	vervangen zijn.  In de hulppagina voor &man.diff.1; staat meer
	informatie over de syntaxis van &man.diff.1; en hoe
	bestandsverschillen getoond worden.</para>

      <para>&man.mergemaster.8; toont dan elk bestand dat verschilt en
	op dit moment is er de mogelijkheid om of het nieuwe bestand te
	verwijderen (ofwel het tijdelijke bestand), het tijdelijke
	bestand te installeren zonder enige wijzigingen, het verwerken
	van het oude bestand in het nieuwe bestand of de resultaten van
	&man.diff.1; nogmaals te tonen.</para>

      <para>Als gekozen wordt om het tijdelijke bestand te verwijderen,
	geeft dit &man.mergemaster.8; aan dat het huidige bestand niet
	gewijzigd dient te worden en de nieuwe versie verwijderd kan
	worden.  Deze optie wordt niet aangeraden, behalve als er geen
	reden is om het huidige bestand aan te passen.  Op ieder moment
	kunnen hulpteksten getoond worden door <keycap>?</keycap> in te
	geven op de prompt van &man.mergemaster.8;.  Als een bestand
	wordt overgeslagen, dan wordt het weer getoond als alle overige
	bestanden verwerkt zijn.</para>

      <para>Bij de keuze om het ongewijzigde tijdelijke bestand te
	installeren wordt het huidige bestand vervangen door het
	nieuwe.  Voor de meeste ongewijzigde bestanden is dit de beste
	optie.</para>

      <para>Als ervoor gekozen wordt om de wijzigingen te verwerken
	wordt er een tekstverwerker gestart die de inhoud van beide
	bestanden toont.  D verschillen kunnen verwerkt worden terwijl
	beide bestanden naast elkaar op het scherm staan.  Hier kunnen
	delen gekozen worden die gezamenlijk een nieuw bestand
	opleveren.  Als de bestanden zij aan zij vergeleken worden,
	wordt met de toets <keycap>l</keycap> de inhoud links
	geselecteerd en met de toets <keycap>r</keycap> de inhoud
	rechts geselecteerd.  Het eindresultaat bestaat uit delen van
	beide bestanden die erna geinstalleerd kunnen worden.  Deze
	optie wordt voornamelijk gebruikt voor bestanden die gewijzigd
	zijn door de beheerder.</para>

      <para>Als ervoor gekozen wordt om de &man.diff.1; resultaten nog
	een keer te tonen, worden dezelfde verschillen getoond
	zoals &man.mergemaster.8; deed voordat een optie gevraagd
	werd.</para>

      <para>Zodra &man.mergemaster.8; klaar is met de systeembestanden
	worden er andere opties getoond.  &man.mergemaster.8; kan
	vragen of het wachtwoordbestand opnieuw gebouwd moet worden
	en/of &man.MAKEDEV.8; gestart moet worden als er een versie van
	&os; voor 5.0 draait.  Als laatste wordt een optie getoond om
	alle overgebleven tijdelijke bestanden te verwijderen.</para>
      </sect3>

      <sect3>
	<title>Handmatig bijwerken</title>

	<para>Bij handmatig bijwerken kunnen de bestanden van
	  <filename>/usr/src/etc</filename> niet zomaar naar
	  <filename>/etc</filename> gekopieerd worden om een werkend
	  systeem te krijgen.  Sommige van deze bestanden moeten eerst
	  <quote>ge&iuml;nstalleerd</quote> worden.  Dit omdat de map
	  <filename>/usr/src/etc</filename> <emphasis>geen</emphasis>
	  kopie is van <filename>/etc</filename>.  Daarnaast staan er
	  in <filename>/etc</filename> bestanden die niet in
	  <filename>/usr/src/etc</filename> staan.</para>

	<para>Als &man.mergemaster.8; gebruikt wordt (zoals
	  aangeraden), kan doorgegaan worden met het <link
	    linkend="update-dev">volgende onderdeel</link>.</para>

	<para>De simpelste manier om met de hand bij te werken, is de
	  bestanden in een nieuwe map installeren en daarna naar
	  verschillen tussen de bestanden te zoeken.</para>

	<warning>
	  <title>Backup maken van <filename>/etc</filename></title>

	  <para>Ondanks dat, in theorie, niets in deze map automatisch
	    wordt aangepast, is het altijd beter om daar zeker van te
	    zijn.  Dus kopieer de bestaande <filename>/etc</filename>
	    naar een veilige locatie.  Zoals bijvoorbeeld met het
	    volgende commando:</para>

	  <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	  <para><option>-R</option> maakt een recursieve kopie,
	    <option>-p</option> bewaart tijden, eigenaarschap,
	    enzovoort op bestanden.</para>
	</warning>

	<para>Er moet een dummyset van mappen gemaakt worden om de
	   nieuwe <filename>/etc</filename> en andere bestanden in te
	   installeren.  <filename>/var/tmp/root</filename> is een
	   redelijke keuze en er zijn hier een aantal benodigde
	   submappen aanwezig:</para>

	<screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

	<para>Dit maakt de benodigde mappenstructuur en installeert de
	  bestanden.  Een groot deel van de submappen die gemaakt zijn
	  in <filename>/var/tmp/root</filename> zijn leeg en moeten
	  verwijderd worden.  De simpelste manier om dit te doen
	  is:</para>

	<screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

	<para>Dit verwijderd alle lege mappen.  De standaardfout wordt
	  omgeleid naar <filename>/dev/null</filename> om
	  waarschuwingen te voorkomen over mappen die niet leeg
	  zijn.</para>

	<para><filename>/var/tmp/root</filename> bevat nu alle
	  bestanden die geplaatst zouden moeten worden op de juiste
	  locaties in <filename>/</filename>.  Er moet nu in de
	  bestanden gekeken worden om te bepalen of deze verschillen
	  met de huidige betanden.</para>

	<para>Let op dat sommige van de bestanden die
	  ge&iuml;nstalleerd zijn in <filename>/var/tmp/root</filename>
	  beginnen met een <quote>.</quote>.  Op het moment van
	  schrijven hebben alleen shell opstartscripts in
	  <filename>/var/tmp/root</filename> en
	  <filename>/var/tmp/root/root</filename> dit, maar er kunnen
	  ook andere zijn.  Zorg ervoor dat <command>ls -a</command>
	  gebruikt wordt om deze bestanden te zien.</para>

	<para>De simpelste manier om twee bestanden te vergelijken is
	  &man.diff.1; gebruiken:</para>

	<screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

	<para>Dit toont de verschillen tussen de huidige
	  <filename>/etc/shells</filename> en de nieuwe
	  <filename>/var/tmp/root/etc/shells</filename>.  Gebruik dit
	  om te bepalen of de wijzigingen gemigreerd moeten worden of
	  dat het oude bestand gekopie&euml;rd moet worden.</para>

	<tip>
	  <title>Voeg aan de naam van de nieuwe rootmap
	    (<filename>/var/tmp/root</filename>) een tijdsindicatie toe
	    zodat makkelijk verschillen tussen versies bepaald kunnen
	    worden</title>

	  <para>Als de wereld regelmatig wordt herbouwd moeten
	    bestanden in <filename>/etc</filename> ook regelmatig
	    bijgewerkt moeten worden, wat een vervelend werkje kan
	    zijn.</para>

	  <para>Dit proces kan versneld worden door een kopie te
	    bewaren van de bestanden die gemigreerd zijn naar
	    <filename>/etc</filename>.  De volgende procedure geeft een
	    idee over hoe dit gedaan kan worden.</para>

	  <procedure>
	    <step>
	      <para>Maak de wereld zoals normaal.  Als
		<filename>/etc</filename> en de andere mappen
		bijgewerkt moeten worden, geef dan de doelmap een naam
		gebaseerd op de huidige datum.  Op 14 februari 1998
		wordt dat als volgt gedaan:</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	    </step>

	    <step>
	      <para>Migreer de wijzigingen van deze map zoals hierboven
		beschreven.</para>

	      <para>Verwijder de map
		<filename>/var/tmp/root-19980214</filename>
		<emphasis>niet</emphasis> na afronden.</para>
	    </step>

	    <step>
	      <para>Als de laatste versie van de broncode gedownload en
		opnieuw gemaakt is, volg stap 1.  Dit geeft een nieuwe
		map die wellicht
		<filename>/var/tmp/root-19980221</filename> heet (als
		er een week zit tussen het bijwerken).</para>
	    </step>

	    <step>
	      <para>De verschillen die gemaakt zijn in de
		tussenliggende week kunnen nu getoond worden door met
		&man.diff.1; een recursieve diff te maken tussen de
		twee mappen:</para>

	      <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	      <para>Vaak is dit een kleinere set aan verschillen dan
		tussen <filename>/var/tmp/root-19980221/etc</filename>
		en <filename>/etc</filename>.  Omdat de set
		verschillen kleiner is, is het makkelijker om deze te
		migreren naar de map <filename>/etc</filename>.</para>
	    </step>

	    <step>
	      <para>De oudste van de twee
		<filename>/var/tmp/root-*</filename>-mappen kan nu
		verwijderd worden:</para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	    </step>

	    <step>
	      <para>Herhaal dit proces elke keer als er wijzigingen
		gemigreerd moeten worden naar
		<filename>/etc</filename>.</para>
	    </step>
	  </procedure>

	  <para>Met &man.date.1; kan het maken van de mappen
	    geautomatiseerd worden:</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
      </sect3>
    </sect2>

    <sect2 id="update-dev">
      <title><filename>/dev</filename> bijwerken</title>

      <note>
	<indexterm><primary>DEVFS</primary></indexterm>

	<para>Als &os;&nbsp;5.0 of later wordt gebruikt kan deze sectie
	  veilig overgeslagen worden.  Deze versies gebruiken
	  &man.devfs.5; om apparaatnodes transparant aan te maken voor
	  gebruikers.</para>
      </note>

      <para>In veel gevallen herkent &man.mergemaster.8; dat het nodig
	is om apparaatnodes bij te werken en aan te bieden en doet dat
	automatisch.  Hieronder wordt beschreven hoe apparaatnodes
	handmatig bijgewerkt kunnen worden.</para>

      <para>Om veiligheidsredenen bestaat dit proces uit meerdere
	stappen.</para>

      <procedure>
	<step>
	  <para>Kopieer <filename>/var/tmp/root/dev/MAKEDEV</filename>
	    naar <filename>/dev</filename>:</para>

	  <screen>&prompt.root; <userinput>cp /var/tmp/root/dev/MAKEDEV /dev</userinput></screen>

	  <indexterm><primary><filename>MAKEDEV</filename></primary></indexterm>

	  <para>Als &man.mergemaster.8; is gebruikt om
	    <filename>/etc</filename> bij te werken is het script
	    <filename>MAKEDEV</filename> al aangepast.  Het kan echter
	    geen kwaad om dit te controleren (met &man.diff.1;) en het
	    script indien nodig handmatig te kopieren.</para>
	</step>

	<step>
	  <para>Maak een afdruk van de huidige
	    <filename>/dev</filename>.  Deze snapshot moet de
	    permissies, eigenaarschappen, grote en kleine nummers van
	    ieder bestand bevatten, maar niet de timestamps.  De
	    makkelijkste manier om dit te doen is door &man.awk.1; te
	    gebruiken om er informatie uit te halen:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>ls -l | awk '{print $1, $2, $3, $4, $5, $6, $NF}' > /var/tmp/dev.out</userinput></screen>
	</step>

	<step>
	  <para>Cree&euml;r alle apparaatnodes opnieuw:</para>

	  <screen>&prompt.root; <userinput>sh MAKEDEV all</userinput></screen>
	</step>

	<step>
	  <para>Maak een tweede afdruk van de map, deze keer naar
	    <filename>/var/tmp/dev2.out</filename>.  Bekijk nu door de
	    twee bestanden te vergelijken of er apparaatnodes niet zijn
	    aangemaakt.  Dit hoort niet voor te komen, maar het kan
	    maar beter gecontroleerd zijn.</para>

	  <screen>&prompt.root; <userinput>diff /var/tmp/dev.out /var/tmp/dev2.out</userinput></screen>

	  <para>Als er verschillen zijn is het waarschijnlijk dat deze
	    in diskslices zitten.  Om deze apparaatnodes opnieuw aan te
	    maken kan iets als het onderstaande commando gebruikt
	    worden:</para>

	  <screen>&prompt.root; <userinput>sh MAKEDEV sd0s1</userinput></screen>

	  <para>De precieze afwijkingen kunnen vari&euml;ren.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title><filename>/stand</filename> bijwerken</title>

      <note>
	<para>Deze stap is opgenomen om het proces compleet te maken.
	  Hij kan zonder problemen overgeslagen worden.  Als
	  &os;&nbsp;5.2 of later wordt gebruikt, wordt de map
	  <filename>/rescue</filename> automatisch bijgewerkt met de
	  nieuwste, statisch gecompileerde binaire bestanden tijdens
	  <command>make installworld</command>, waardoor het overbodig
	  wordt om <filename>/stand</filename> bij te werken (bestaat
	  helemaal niet in &os;&nbsp;6.0 en later).</para>
      </note>

      <para>Volledigheidshalve is het misschien wenselijk de bestanden
	in de map <filename>/stand</filename> bij te werken.  Deze
	bestanden bestaan uit harde links naar het binaire bestand
	<filename>/stand/sysinstall</filename>.  Dit bestand moet
	statisch gelinkt zijn zodat het zonder tussenkomst van andere
	bestandssystemen kan werken (in het bijzonder
	<filename>/usr</filename>).

      <screen>&prompt.root; <userinput>cd /usr/src/release/sysinstall</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Herstarten</title>

      <para>Dit was het.  Na een controle of alles op de juiste plaats
	staat kan het systeem herstart worden.  Dan kan met een simpele
	&man.shutdown.8;:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Klaar</title>

      <para>Het &os; systeem is nu succesvol bijgewerkt.
	Gefeliciteerd!</para>

      <para>Als er dingen misgingen is het makkelijk om een deel van
	het systeem opnieuw te bouwen.  Als bijvoorbeeld per ongeluk
	<filename>/etc/magic</filename> verwijderd is als onderdeel
	van de upgrade of door een merge van <filename>/etc</filename>,
	dan werkt &man.file.1; niet meer.  Dat kan als volgt opgelost
	worden:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Vragen</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Moet de wereld opnieuw gemaakt worden voor elke
	      wijziging?</para>
	  </question>

	  <answer>
	    <para>Op deze vraag bestaat geen eenvoudig antwoord, omdat
	      dit afhangt van de aard van de wijziging.  Als
	      bijvoorbeeld net <application>CVSup</application> is
	      gedraaid en de onderstaande bestanden zijn bijgewerkt,
	      dan is het waarschijnlijk niet de moeite waard om de
	      volledige wereld te herbouwen:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>Dan is het handiger om naar de juiste submappen te
	      gaan, daar <command>make all install</command> uit te
	      voeren en dat is het zo'n beetje.  Maar als er iets
	      wezenlijks is veranderd, bijvoorbeeld
	      <filename>src/lib/libc/stdlib</filename>, dan dient ofwel
	      de wereld herbouwd te worden of tenminste die delen die
	      statisch gelinkt zijn (en ook al het andere dat statisch
	      gelinkt is en onderdeel is van een systeem).</para>

	    <para>Uiteindelijk beslist een beheerder zelf.  Misschien
	      vindt die het prettig iedere twee weken de wereld te
	      herbouwen terwijl de wijzigingen in die twee weken
	      binnenkomen.  Een andere beheerder herbouwt alleen die
	      onderdelen die veranderd zijn en vertrouwt erop dat hij
	      alle afhankelijkheden in de gaten heeft.</para>

	    <para>Natuurlijk hangt het ook af van de keuze hoe vaak het
	      wenselijk is bij te werken en of &os.stable; of
	      &os.current; wordt bijgehouden.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Het compileren gaat fout met veel meldingen van
	      signal 11 (of andere signalnummers).  Wat is er aan de
	      hand?</para>
	  </question>

	  <indexterm><primary>signal 11</primary></indexterm>

	  <answer>
	    <para>Dit wijst meestal op hardwareproblemen.  Het
	      (her)bouwen van de wereld is een prima manier om een
	      stresstest op hardware uit te voeren en hierdoor komen
	      vaak geheugenproblemen bovendrijven.  Die resulteren vaak
	      in een compiler die op mysterieuze wijze overlijdt na het
	      ontvangen van vreemde signalen.</para>

	    <para>Dit probleem is nog duidelijker als na het herstarten
	      van de make het proces opnieuw stopt op een ander
	      punt.</para>

	    <para>Hier biedt niets anders uitkomst dan componenten in
	      een systeem wisselen om uit te zoeken welk component er
	      faalt.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kan <filename>/usr/obj</filename> verwijderd worden
	      na afloop?</para>
	  </question>

	  <answer>
	    <para>Het korte antwoord is ja.</para>

	    <para><filename>/usr/obj</filename> bevat alle
	      objectbestanden die tijdens het compileren zijn gemaakt.
	      Normaliter is een van de eerste stappen in het
	      <command>make buildworld</command> proces deze map
	      verwijderen en een verse start maken.  In dit geval heeft
	      het behouden van <filename>/usr/obj</filename> na het
	      afronden weinig zin en geeft het ook nogal wat extra
	      vrije schijfruimte (ongeveer 340&nbsp;MB).</para>

	    <para>Als er veel kennis aanwezig is bij een beheerder, dan
	      kan <command>make buildworld</command> aangegeven worden
	      deze stap over te slaan.  Hierdoor draaien volgende
	      builds veel sneller, omdat veel broncode niet opnieuw
	      gecompileerd hoeft te worden.  De andere kant van de
	      medaille is dat er subtiele afhankelijkheidsproblemen
	      kunnen ontstaan, waardoor een build op bijzondere wijze
	      kan falen.  Hierdoor onstaat regelmatig ruis op &os;
	      mailinglijsten als er iemand klaagt dat zijn build faalt,
	      terwijl hij zich niet realiseert dat dit komt doordat hij
	      zijn updateproces niet volgens het boekje heeft
	      uitgevoerd.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kunnen onderbroken builds gecontinueerd
	      worden?</para>
	  </question>

	  <answer>
	    <para>Dit hangt af van hoever een systeem was voordat een
	      probleem gevonden werd.</para>

	    <para><emphasis>Normaal gesproken</emphasis> (en dit is
	      geen vaste regel) maakt het proces <command>make
		buildworld</command> nieuwe kopie&euml;n van essentiele
	      hulpprogramma's (zoals &man.gcc.1; en &man.make.1;) en de
	      systeembibliotheken.  Deze hulpprogramma's en
	      bibliotheken worden daarna ge&iuml;nstalleerd.  De nieuwe
	      hulpprogramma's en bibliotheken worden daarna gebruikt om
	      zichzelf opnieuw op te bouwen en wederom te installeren.
	      Het complete systeem (nu met gewone programma's zoals
	      &man.ls.1; en &man.grep.1;) wordt daarna opnieuw gebouwd
	      met de nieuwe systeembestanden.</para>

	    <para>Als een systeem in de laatste fase zit (wat uit de
	      uitvoer blijkt) kan dit redelijk veilig gedaan
	      worden:</para>

	    <screen><emphasis>&hellip; fix the problem &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNOCLEAN all</userinput></screen>

	    <para>Dit maakt het werk van de vorige <command>make
		buildworld</command> niet ongedaan.</para>

	    <para>Als het onderstaande bericht in de uitvoer van
	      <command>make buildworld</command> staat, dan is het
	      redelijk veilig om het te doen:</para>

	    <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>Als dat bericht er niet is, of er is onzekerheid
	      over, dan is het altijd beter om de build opnieuw te
	      starten vanaf het begin.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kan kan de wereld bouwen versneld worden?</para>
	  </question>

	  <answer>
	    <itemizedlist>
	      <listitem>
		<para>Draai in single-user modus;</para>
	      </listitem>

	      <listitem>
		<para>Zet de mappen <filename>/usr/src</filename> en
		  <filename>/usr/obj</filename> op aparte
		  bestandssystemen die op aparte schijven staan.  Hang
		  deze schijven als mogelijk aan aparte
		  schijfcontrollers;</para>
	      </listitem>

	      <listitem>
		<para>Nog beter, verspreid de bestandssystemen over
		  meerdere schijven via het apparaat &man.ccd.4;
		  (concatenated disk driver);</para>
	      </listitem>

	      <listitem>
		<para>Zet profiling uit (voeg
		  <quote>NOPROFILE=true</quote> toe aan
		  <filename>/etc/make.conf</filename>).  Het is zeer
		  waarschijnlijk niet nodig;</para>
	      </listitem>

	      <listitem>
		<para>Voer ook <makevar>CFLAGS</makevar> toe aan
		  <filename>/etc/make.conf</filename> met iets als
		  <option>-O -pipe</option>.  De optimalisatie
		  <option>-O2</option> is veel langzamer en het
		  optimalisatieverschil tussen <option>-O</option> en
		  <option>-O2</option> is meestal verwaarloosbaar.
		  <option>-pipe</option> laat de compiler gebruik maken
		  van pipes in plaats van tijdelijke bestanden voor
		  communicatie, wat schijfacties scheelt (ten koste van
		  geheugengebruik);</para>
	      </listitem>

	      <listitem>
		<para>Geef de optie
		  <option>-j<replaceable>n</replaceable></option> mee
		  aan &man.make.1; om meerdere processen parallel te
		  laten lopen.  Dit helpt in de meeste gevallen,
		  onafhankelijk of er gewerkt wordt op een systeem met
		  &eacute;&eacute;n of meerdere processoren;</para>
	      </listitem>

	      <listitem>
		<para>Het bestandssysteem dat
		  <filename>/usr/src</filename> bevat, kan (opnieuw)
		  gemount worden met de optie <option>noatime</option>.
		  Dit voorkomt dat het bestandssysteem de
		  toegangsmomenten registreert.  Deze informatie is
		  waarschijnlijk toch niet nodig.</para>

		<screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		<warning>
		  <para>In dit voorbeeld wordt aangenomen dat
		    <filename>/usr/src</filename> op zijn eigen
		    bestandssysteem staat.  Als dit niet het geval is
		    (bijvoorbeeld als het onderdeel is van
		    <filename>/usr</filename>), dan moet het mountpunt
		    voor dat bestandssysteem gebruikt moeten worden
		    en niet <filename>/usr/src</filename>;</para>
		</warning>
	      </listitem>

	      <listitem>
		<para>Het bestandssysteem dat
		  <filename>/usr/obj</filename> gevat kan (opnieuw)
		  worden gemount met de optie <option>async</option>.
		  Dit zorgt ervoor dat schrijfacties naar een schijf
		  asynchroon plaatsvinden.  In andere woorden: de
		  schrijfactie wordt direct uitgevoerd en de gegevens
		  worden later naar de schijf geschreven.  Dit stelt
		  het systeem in staat om data geclusterd weg te
		  schrijven, wat een grote prestatieverbetering kan
		  opleveren.</para>

		<warning>
		  <para>Houd er rekening mee dat deze optie het
		    bestandssysteem kwetsbaarder maakt.  Met deze optie
		    is er een vergrote kans dat, indien er een
		    stroomstoring optreed, het bestandssysteem in een
		    niet meer te herstellen staat komt als de machine
		    herstart.</para>

		  <para>Als op dit bestandssysteem alleen
		    <filename>/usr/obj</filename> staat, is dit geen
		    probleem.  Als er andere belangrijke gegevens op
		    hetzelfde bestandssysteem staan, zorg er dan voor
		    dat er verse backups zijn voordat deze optie
		    aangezet wordt.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Zorg ervoor, zoals al eerder is aangegeven, dat
		    als <filename>/usr/obj</filename> niet op een eigen
		    bestandssysteem staat, het juiste mountpunt wordt
		    gebruikt.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Wat te doen als er iets mis gaat?</para>
	  </question>

	  <answer>
	    <para>Zorg ervoor dat het systeem geen rommel meer bevat
	      van eerdere builds.  Het volgende helpt daarbij:</para>

	    <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Inderdaad, <command>make cleandir</command> moet twee
	      keer gedraaid worden.</para>

	    <para>Herstart daarna het complete proces vanaf
	      <command>make buildworld</command>.</para>

	    <para>Als er nog steeds problemen zijn, stuur dan de
	      foutmelding en de uitvoer van <command>uname -a</command>
	      naar de &a.questions;.  Wees bereid aanvullende vragen
	      over het systeem te beantwoorden!</para>
	  </answer>
	</qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Bijgedragen door </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Meerdere machines bijwerken</title>

    <indexterm>
      <primary>NFS</primary>

      <secondary>meerdere machines installeren</secondary>
    </indexterm>

    <para>Als er meerdere machines zijn die dezelfde broncode
      bijhouden, lijkt het downloaden van alle broncode en alles overal
      opnieuw bouwen zonde van de bronnen: harde schijfruimte, netwerk
      bandbreedte, en processorbelasting.  Dit klopt en de oplossing is
      om alles op &eacute;&eacute;n machine te doen terwijl de overige
      machines het uitgevoerde werk benaderen via NFS.  Nu wordt een
      methode beschreven waarmee dit gedaan kan worden.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Benodigdheden</title>

      <para>Als eerste moet er een groep van machines gekozen worden
	die dezelfde set aan binaire bestanden zal draaien, hier een
	<emphasis>bouwgroep</emphasis>.  Elke machine kan een eigen
	afwijkende kernel hebben maar moet dezelfde binaire
	gebruikersbestanden draaien.  Uit die groep moet een machine
	gekozen worden die de <emphasis>bouwmachine</emphasis> wordt.
	Dit wordt de machine waar de wereld en kernel op gebouwd
	worden.  In het meest ideale geval is dit een snelle machine
	die genoeg processorkracht vrij heeft om <command>make
	  buildworld</command> en <command>make buildkernel</command>
	te draaien.  Er moet ook een machine gekozen worden die de
	<emphasis>testmachine</emphasis> wordt waarop alle bijgewerkte
	software wordt test voordat die in productie wordt genomen.
	Dit <emphasis>moet</emphasis> een machine zijn die voor langere
	tijd down mag zijn.  Dit kan de bouwmachine zijn maar dat hoeft
	niet per se.</para>

      <para>Alle machines in deze bouwgroep moeten ingesteld worden om
	<filename>/usr/obj</filename> en <filename>/usr/src</filename>
	vanaf dezelfde machine te mounten op hetzelfde punt.  In het
	meest ideale geval zijn dit twee verschillende schijven op de
	bouwmachine, maar ze kunnen ook door middel van NFS op die
	machine gemount zijn.  Als er meerdere bouwgroepen zijn, dan
	moet <filename>/usr/src</filename> op &eacute;&eacute;n
	bouwmachine staan en door middel van NFS gemount worden op de
	overige machines.</para>

      <para>Zorg er als laatste voor dat
	<filename>/etc/make.conf</filename> op alle machines in de
	bouwgroep het eens zijn met de bouwmachine.  Dat betekent dat
	de bouwmachine alle delen van het basissysteem moet bouwen die
	elke machine in de bouwgroep installeert.  Ook heeft elke
	bouwmachine zijn kernelnaam ingesteld met
	<makevar>KERNCONF</makevar> in
	<filename>/etc/make.conf</filename> en de bouwmachine moet ze
	allemaal hebben in <makevar>KERNCONF</makevar>, zijn eigen
	kernel eerst.  De bouwmachine moet de instellingenbestanden
	voor elke machine in
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
	hebben als deze machine de kernels voor de overige machines
	gaat bouwen.</para>
    </sect2>

    <sect2>
      <title>Basissysteem</title>

      <para>Nu kan &eacute;&eacute;n systeem alles bouwen.  Bouw de
	kernel en wereld zoals beschreven in <xref
	  linkend="make-buildworld"> op de bouwmachine, maar installeer
	niets.  Zodra de bouw klaar is, moet op de testmachine de
	kernel ge&iuml;nstalleerd en getest worden.  Als deze machine
	<filename>/usr/src</filename> en <filename>/usr/obj</filename>
	mount via NFS, moet na een herstart in single-user modus het
	netwerk ingeschakeld worden zodat de mounts opnieuw gemaakt
	kunnen worden.  De makkelijkste manier om dit te doen is om te
	starten in multi-user modus en daar
	<command>shutdown now</command> starten om in single-user modus
	te komen.  Eenmaal daar aangekomen kunnen de nieuwe kernel en
	de wereld ge&iuml;nstalleerd worden en kan daarna normaal
	<command>mergemaster</command> gestart worden.  Zodra dit klaar
	is, kan de machine opnieuw gestart worden om naar multi-user
	modus terug te keren.</para>

      <para>Nadat zeker is dat alles op de testmachine correct werkt,
	kan dezelfde procedure gebruikt worden om de nieuwe software op
	elke machine te installeren in de bouwgroep.</para>
    </sect2>

    <sect2>
      <title>Ports</title>

      <para>Dezelfde idee&euml;n kunnen gebruikt worden voor de ports.
	De eerste kritieke stap is om <filename>/usr/ports</filename>
	te mounten op alle machines in de bouwgroep.  Daarna kan
	<filename>/etc/make.conf</filename> correct ingesteld worden
	om de distfiles te delen.  De variabele
	<makevar>DISTDIR</makevar> moet wijzen naar een gedeelde map
	waarin geschreven kan worden door de gebruiker waar
	<username>root</username> naar wijst in de NFS mounts.  Op elke
	machine moet <makevar>WRKDIRPREFIX</makevar> naar een lokale
	bouwmap wijzen.  Als er pakketten gebouwd en gedistribueerd
	worden moet <makevar>PACKAGES</makevar> naar een map wijzen
	gelijkvormig aan de instelling voor
	<makevar>DISTDIR</makevar>.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
