<!--
     The FreeBSD Dutch Documentation Project

     $FreeBSD$
     gebaseerd op: 1.143
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
	 <firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Geschreven door </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	 <firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Naar een tutorial van </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Tevens gebaseerd op tuning(7) geschreven door</contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Danny</firstname>
	<surname>Pansters</surname>
	<contrib>Vertaling door </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Configuratie en optimalisatie</title>

  <sect1 id="config-synopsis">
    <title>Overzicht</title>

    <indexterm><primary>systeem configuratie</primary></indexterm>
    <indexterm><primary>systeem optimalisering</primary></indexterm>

    <para>Een belangrijk aspect van &os; is systeemconfiguratie.
      Een correcte configuratie helpt moeilijkheden bij toekomstige
      upgrades te voorkomen.  In dit hoofdstuk wordt de configuratie
      van &os; beschreven, alsmede een aantal prestatiebevorderende
      maatregelen waarmee een &os; systeem geoptimaliseerd kan
      worden.</para>

    <para>Nadat je dit hoofdstuk gelezen hebt, zul je het volgende
      weten:</para>

    <itemizedlist>
      <listitem>
	<para>Hoe je effici&euml;nt met bestandssystemen en
	  wisselpartities omgaat</para>
      </listitem>

      <listitem>
	<para>De grondslagen van het <filename>rc.conf</filename>
	  configuratiesysteem en van het opstarten van toepassingen
	  (services) d.m.v. <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>

      <listitem>
	<para>Hoe een netwerkkaart geconfigureerd en getest wordt.</para>
      </listitem>

      <listitem>
	<para>Hoe je virtuele hosts configureert op je
	  netwerkapparatuur.</para>
      </listitem>

      <listitem>
	<para>Hoe de verscheidene configuratiebestanden in
	  <filename>/etc</filename> gebruikt worden.</para>
      </listitem>

      <listitem>
	 <para>Hoe je &os; kunt optimaliseren met
	   <command>sysctl</command> variabelen.</para>
      </listitem>

      <listitem>
	<para>Hoe schijfprestaties verbeterd en kernelbeperkingen
	  gewijzigd kunnen worden.</para>
      </listitem>
    </itemizedlist>

    <para>Voordat je dit hoofdstuk leest, is het goed om eerst:</para>

    <itemizedlist>
      <listitem>
	<para>De &unix; en &os; grondslagen (<xref
	   linkend="basics">) te begrijpen.</para>
      </listitem>
      <listitem>
	<para>Bekend zijn met het actualiseren van de &os; broncode
	  (<xref linkend="cutting-edge">) en
	  de grondlagen van kernel configuratie en compilatie
	  (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Initi&euml;le configuratie</title>

    <sect2>
      <title>Partitioneren</title>

      <indexterm><primary>partitioneren</primary></indexterm>
      <indexterm>
	<primary><filename>/etc</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>/var</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>/usr</filename></primary>
      </indexterm>

      <sect3>
	<title>Partities</title>

	<para>Bij het aanleggen van bestandssystemen met
	  &man.disklabel.8; of &man.sysinstall.8;, is het van belang
	  te onthouden dat op een harde schijf de data-overdracht het
	  snelst is aan de buitenste sporen en het langzaamst aan de
	  binnenste.  Kleinere en veelgebruikte bestandssystemen kunnen
	  daarom het beste aan het begin van de schijf geplaatst worden,
	  terwijl grotere partities als <filename>/usr</filename> meer
	  naar het einde van de schijf geplaatst kunnen worden.  Het is
	  een goed idee om partities aan te maken in deze of
	  gelijksoortige volgorde: root, swap,
	  <filename>/var</filename>, <filename>/usr</filename>.</para>

	<para>De grootte van <filename>/var</filename>
	  hangt af van de wijze waarop de machine gebruikt gaat worden.
	  <filename>/var</filename> wordt gebruikt voor onder meer
	  mailboxen, logbestanden, en printerdata en -wachtrijen.
	  Mailboxen en logbestanden kunnen onverwacht groot worden,
	  afhankelijk van het aantal systeemgebruikers en de bewaarduur
	  van logbestanden.  Meestal kun je met minder dan een gigabyte
	  af.  Vergeet echter niet dat <filename>/var/tmp</filename>
	  groot genoeg moet zijn om pakketten te kunnen bevatten.</para>

	<para>De <filename>/usr</filename> partitie bevat veel van de
	  benodigde systeembestanden.  Tevens bavat ze de &man.ports.7;
	  collectie (aanbevolen) en de broncode (optioneel).  Beide
	  zijn optioneel tijdens de installatie.
	  Voor deze partitie wordt tenminste 2 gigabytes aanbevolen.</para>

	<para>Je doet er goed aan rekening te houden met de vereiste
	  schijfruimte bij het kiezen van partitiegroottes.  Als je in
	  een partitie onvoldoende vrije schijfruimte hebt, terwijl
	  een andere vrijwel niet gebruikt wordt, is dat een vervelend
	  en niet optimaal oplosbaar probleem.</para>

	<note><para>&man.sysinstall.8;'s <literal>Auto-defaults</literal>
	  partitiekeuze kan in de ervaring van sommige gebruikers
	  mogelijk te kleine <filename>/var</filename> en
	  <filename>/</filename> partities opleveren.  Partitioneer
	  verstandig en ben niet te zuinig met schijfruimte.
	  </para></note>

      </sect3>

      <sect3 id="swap-design">
	<title>Wisselpartities (swap)</title>

	<indexterm><primary>swap grootte</primary></indexterm>
	<indexterm><primary>wisselpartitie</primary></indexterm>
	<indexterm><primary>wisselpartitie grootte</primary></indexterm>

	<para>Als vuistregel geldt dat het wisselbestand ongeveer het
	  dubbele van de grootte van het systeemgeheugen (RAM) moet
	  zijn.  Bijvoorbeeld, als de machine 128&nbsp;megabytes
	  geheugen heeft, kan het beste een wisselbestand van
	  (tenminste) 256&nbsp;megabytes gebruikt worden.  Minder
	  dan 256&nbsp;megabytes swap is in dit geval af te raden.
	  Systemen met weinig geheugen kunnen overigens beter
	  functioneren met meer swap.  Ook doe je er goed aan rekening
	  te houden met eventuele geheugenuitbreiding in de toekomst.
	  Bovendien zijn de VM paging algoritmen van de kernel zodanig
	  afgestemd dat ze het beste presteren bij een wisselbestand van
	  tenminste tweemaal de grootte van het geheugen.  Een te kleine
	  swap kan dus ineffici&euml;nties in de VM code tot gevolg
	  hebben en mogelijk problemen veroorzaken indien het
	  systeemgeheugen later uitgebreid wordt.</para>

	<para>Op grotere systemen met meerdere SCSI schijven (of
	  meerdere IDE schijven op verschillende controllers) is het aan
	  te raden om op elke schijf een wisselpartitie te configureren
	  (dit kan tot en met vier schijven), elk van ongeveer dezelfde
	  grootte.  De kernel kan met arbitraire groottes werken, maar
	  interne datastructuren schalen tot viermaal de grootste
	  swappartitie.  De kernel kan de beschikbare ruimte voor het
	  wisselbestand het meest optimaal indelen indien de partities
	  ongeveer even groot zijn.  Een grote swap is prima, ook als ze
	  zelden gebruikt wordt.  Zo kan het gemakkelijker zijn om een
	  (uit de hand gelopen) proces dat het systeem grotendeels bezet
	  houdt te be&euml;indigen, voordat het noodzakelijk wordt om
	  opnieuw op te starten.</para>
      </sect3>

      <sect3>
	<title>Waarom partitioneren?</title>

	<para>Waarom niet &eacute;&eacute;n enkele grote partitie
	  gebruiken?  Er zijn verscheidene redenen waarom dit niet zo'n
	  goed idee is.  De verschillende partities hebben hun eigen
	  karakteristiek operationeel gedrag en vereisten.  Door ze te
	  scheiden zijn er betere mogelijkheden om het systeem te
	  optimaliseren.  Bijvoorbeeld, vanaf de <filename>/</filename>
	  en <filename>/usr</filename> partities wordt vooral gelezen
	  en er wordt weinig naar geschreven, terwijl er in
	  <filename>/var</filename> en <filename>/var/tmp</filename>
	  zowel veel gelezen als geschreven zal worden.</para>

	<para>Door je systeem goed te partitioneren kun je vermijden dat
	  fragmentatie die optreedt in de kleinere partities met veel
	  schrijfactiviteit doorsijpelt naar partities die vooral
	  lees-intensief zijn.  Door schrijf-intensieve partities aan
	  het begin van de schijf te plaatsen, zorg je ervoor dat de
	  invoer/uitvoer performance het beste is daar waar het het
	  meest nodig is.
	  Ofschoon je natuurlijk ook de best mogelijke in/uit performance
	  wilt hebben in de grotere partities, zal het plaatsen van deze
	  bestandssystemen aan het begin van de schijf niet opwegen tegen
	  de voordelen van het plaatsen van <filename>/var</filename> aan
	  het begin van de schijf (na root en swap) voor wat betreft de
	  totale snelheid van het systeem.
	  Tenslotte zijn er veiligheidsoverwegingen.  Een compacte en
	  nette root partitie die vrijwel alleen-lezen is, heeft een
	  betere kans om een nare crash te overleven.</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Basisconfiguratie</title>

    <indexterm>
      <primary>rc bestanden</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>De voornaamste lokatie voor systeemconfiguratie is het bestand
      <filename>/etc/rc.conf</filename>.  Dit bestand bevat een scala
      aan configuratieve informatie, die gebruikt wordt om het systeem
      te configureren bij het opstarten.  De naam impliceert dit al;
      het is informatie voor de <filename>rc*</filename> files (rc staat
      voor "resource configuration").</para>

    <para>De systeembeheerder wordt geacht regels toe te voegen aan het
      <filename>rc.conf</filename> bestand om de standaard instellingen
      uit <filename>/etc/defaults/rc.conf</filename> aan te passen.
      Het standaard bestand moet niet letterlijk gekopi&euml;erd worden
      naar <filename>/etc</filename> - het bevat standaard waardes en
      is niet bedoeld als voorbeeld.  Alle wijzigingen die specifiek
      zijn voor uw systeem horen in <filename>/etc/rc.conf</filename>
      te staan.</para>

    <para>In een clusterscenario is het nuttig om systeem-specifieke
      configuratie te scheiden van algemene configuratie die voor het
      hele cluster geldt.  Hiervoor kunnen een aantal strategie&euml;n
      worden gebruikt.  De aanbevolen benadering is om gedeelde
      configuratie in een ander bestand te plaatsen, zoals
      <filename>/etc/rc.conf.site</filename>, en dit invoegen in
      <filename>/etc/rc.conf</filename>, wat verder alleen
      systeem-specifieke informatie bevat.</para>

    <para>Aangezien <filename>rc.conf</filename> gelezen wordt door
      &man.sh.1; is dit eenvoudig te bereiken.  Bijvoorbeeld:</para>

    <itemizedlist>
      <listitem><para>rc.conf:</para>
<programlisting>	  . rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"</programlisting>
      </listitem>

      <listitem><para>rc.conf.site:</para>
<programlisting>	  defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"</programlisting>
      </listitem>
    </itemizedlist>

    <para>Het <filename>rc.conf.site</filename> bestand kan dan naar elk
      systeem gedistribueerd met behulp van <command>rsync</command> of
      een gelijksoortig programma, terwijl het
      <filename>rc.conf</filename> bestand uniek blijft.</para>

    <para>Het actualiseren van het systeem met &man.sysinstall.8;
      of <command>make world</command> zal het
      <filename>rc.conf</filename> bestand niet overschrijven, zodat
      de bestaande systeemconfiguratie niet verloren gaat.</para>

  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Toepassingen configureren</title>

    <para>Ge&iuml;nstalleerde toepassingen hebben meestal hun eigen
      configuratiebestanden, met hun eigen syntax, etc.  Het is van
      belang deze bestanden apart te houden van het basissysteem,
      zodat ze gemakkelijk gelokaliseerd kunnen worden en beheerd
      met de hulpmiddelen voor pakketbeheer.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>Deze bestanden worden typisch ge&iuml;nstalleerd in
      <filename>/usr/local/etc</filename>.  Indien een toepassing een
      uitgebreide set configuratiebestanden heeft, zal er een
      subdirectory voor aangemaakt worden.</para>

    <para>Bij de installatie van een port of pakket, zullen normaliter
      ook voorbeeld-configuratiebestanden ge&iuml;nstalleerd worden.
      Deze zijn doorgaans te herkennen aan een
      <filename>.default</filename> toevoegsel.  Indien er geen
      bestaande configuratiebestanden voor de toepassing zijn, zullen
      deze gecre&euml;erd worden door de <filename>.default</filename>
      bestanden te kopi&euml;ren.</para>

    <para>Een voorbeeld is de directory
      <filename>/usr/local/etc/apache</filename>:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Aan de grootte van de bestanden kunt je zien dat alleen
      <filename>srm.conf</filename> gewijzigd is.  Als je later de
      <application>Apache</application> port vernieuwd zal dit bestand
      niet overschreven worden.</para>

  </sect1>

  <sect1 id="configtuning-starting-services">
    <title>Services starten</title>

    <indexterm><primary>services</primary></indexterm>

    <para>Het is gebruikelijk dat op een systeem een aantal services
      draaien.  Dit zijn 'dienstverlenende' toepassingen die normaliter
      niet gestopt worden.  Er zijn verscheidene methoden om een
      service, of daemon, te starten.</para>

    <indexterm><primary>/usr/local/etc/rc.d</primary></indexterm>

    <para>Software ge&iuml;nstalleerd van een port of pakket
      plaatst vaak een script in <filename>/usr/local/etc/rc.d</filename>
      dat bij het opstarten van het systeem wordt aangeroepen met een
      <option>start</option> argument en bij het afsluiten van het
      systeem met een <option>stop</option> argument.
      Dit is de aanbevolen wijze om systeem-wijde services te starten
      die moeten draaien als <username>root</username>, of waarvan
      het de bedoeling is dat ze initi&euml;el worden gestart als
      <username>root</username>.

      Deze scripts worden geregistreerd als onderdeel van de
      installatie van het pakket en ze worden verwijderd als het
      pakket gede&iuml;nstalleerd wordt.</para>

    <para>Een generiek opstartscript in
      <filename>/usr/local/etc/rc.d</filename> ziet er als volgt
      uit:</para>

    <programlisting>#!/bin/sh
echo -n ' FooBar'

case "$1" in
start)
         /usr/local/bin/foobar
         ;;
stop)
         kill -9 `cat /var/run/foobar.pid`
         ;;
*)
         echo "Usage: `basename $0` {start|stop}" >&2
         exit 64
         ;;
esac

exit 0
    </programlisting>

    <para>De opstart- en afsluitscripts van &os; doorzoeken
      <filename>/usr/local/etc/rc.d</filename> naar scripts met een
      <literal>.sh</literal> extensie die uitvoerbaar zijn door
      <username>root</username>.  Deze worden aangeroepen met de opties
      <option>start</option> en <option>stop</option> bij
      respectievelijk het opstarten en het afsluiten van het systeem.
      Dus als je zou willen dat het bovenstaande script op het juiste
      moment in de opstartroutine van het systeem gevonden en
      uitgevoerd wordt, zou je het opslaan als
      <filename>FooBar.sh</filename> in
      <filename>/usr/local/etc/rc.d</filename> en het uitvoerbaar maken.
      Dat laatste doe je met behulp van het &man.chmod.1;
      commando:</para>

    <screen>&prompt.root; <userinput>chmod 755 <replaceable>FooBar.sh</replaceable></userinput></screen>

    <para>Sommige services verwachten aangeroepen te worden door
      &man.inetd.8; wanneer er een verbinding wordt gemaakt naar
      een geschikte poort.  Dit is gebruikelijk voor services als POP
      en IMAP, of telnet.  In dit geval kun je dergelijke services
      inschakelen door het bestand <filename>/etc/inetd.conf</filename>
      te wijzigen.  Zie &man.inetd.8; voor details.</para>

    <para>Sommige toegevoegde systeemservices zijn misschien niet
      afdoende af te stemmen met <filename>/etc/rc.conf</filename>
      parameters.  Traditioneel werden de commando's om zulke services
      te starten in <filename>/etc/rc.local</filename> geplaatst.
      Sinds &os;&nbsp;3.1 is er geen standaard
      <filename>/etc/rc.local</filename> meer.  Als je het bestand
      echter aanmaakt, zal het op de verwachte manier gebruikt worden.
      Merk op dat een <filename>rc.local</filename> bestand in het
      algemeen beschouwd wordt als laatste redmiddel; als er een
      betere plaats is om de service te starten, doe het dan
      daar.</para>

    <note><para>Plaats <emphasis>geen</emphasis> commando's in
      <filename>/etc/rc.conf</filename>.  Om daemons te starten of
      enig commando uit te voeren bij het opstarten, moet je een
      script in <filename>/usr/local/etc/rc.d</filename>
      plaatsen.</para></note>

    <para>Het is ook mogelijk om systeemservices te starten met behulp
      van de &man.cron.8; daemon.  Deze aanpak heeft een aantal
      voordelen, niet in het minst omdat &man.cron.8; deze processen
      uitvoert als de eigenaar van de <command>crontab</command> in
      kwestie, waardoor services gestart en onderhouden kunnen worden
      door niet-<username>root</username> gebruikers.</para>

    <para>Hierbij wordt een eigenschap van &man.cron.8; benut: de
      specificatie van het tijdstip kan vervangen worden door
      <literal>@reboot</literal>, waardoor de betreffende taak wordt
      uitgevoerd wanneer &man.cron.8; gestart wordt, kort na
      de systeemstart.</para>
  </sect1>

  <sect1 id="configtuning-cron">
    <sect1info>
      <authorgroup>
	 <author>
	<firstname>Tom</firstname>
	<surname>Rhodes</surname>
	<contrib>Een bijdrage van </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Configuratie van <command>cron</command></title>

    <indexterm><primary>cron</primary>
      <secondary>configuratie</secondary></indexterm>

    <para>Een zeer nuttig hulpprogramma in &os; is &man.cron.8;.  De
      <command>cron</command> daemon draait op de achtergrond en
      controleert voortdurend het bestand
      <filename>/etc/crontab</filename>.  Ook controleert
      <command>cron</command> de <filename>/var/cron/tabs</filename>
      directory, op zoek naar nieuwe <filename>crontab</filename>
      bestanden.  Deze <filename>crontab</filename> bestanden bevatten
      informatie over specifieke taken die <command>cron</command> moet
      verrichten op gezette tijden.</para>

    <para>Het <command>cron</command> programma gebruikt twee
      verschillende soorten configuratiebestanden, de systeemcrontab en
      gebruikerscrontabs.  Het enige verschil tussen deze twee formaten
      is het zesde veld.  In de systeemcrontab is dit de gebruikersnaam
      als wie het commando wordt uitgevoerd.  Dit geeft de
      systeemcrontab de mogelijkheid om commando's uit te voeren als
      elke gebruiker.  In een gebruikerscrontab is het zesde veld het
      uit te voeren commando en alle commando's worden uitgevoerd als
      de gebruiker die de crontab heeft aangelegd.  Dit is een
      belangrijke veiligheidsmaatregel.</para>

    <note><para>Gebruikerscrontabs geven individuele gebruikers de
	mogelijkheid om bepaalde terugkerende taken automatisch te
	laten uitvoeren zonder dat root privileges noodzakelijk zijn.
	Commando's in de crontab van een gebruiker worden uitgevoerd
	met de permissies van de eigenaar.</para>

      <para>Root kan ook een gebruikerscrontab aanleggen.  Dit is niet
	dezelfde als <filename>/etc/crontab</filename>
	(de systeemcrontab).  Omdat er al een systeemcrontab is,
	is het doorgaans niet nodig om een gebruikerscrontab voor root
	te maken.</para></note>


    <para>Het <filename>/etc/crontab</filename> bestand (systeemcrontab)
      ziet er uit als volgt:</para>

    <programlisting># /etc/crontab - root's crontab for &os;
#
# &dollar;&os;: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co id="co-comments">
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co id="co-env">
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <co id="co-field-descr">
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <co id="co-main">
</programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>Zoals in de meeste &os; configuratiebestanden,
	  representeert een <literal>#</literal> karakter commentaar.
	  Commentaar wordt gebruikt als uitleg en geheugensteun.
	  Commentaar dient niet vermengd te worden met commando's,
	  anders zal het commentaar ge&iuml;terpreteerd worden als
	  deel van het commando.  Blanco regels worden genegeerd.</para>
      </callout>

      <callout arearefs="co-env">
	<para>Eerst worden omgevingsvariabelen gedefini&euml;erd.  Het
	  is-gelijk karakter (<literal>=</literal>) wordt hiervoor
	  gebruikt; in geval van dit voorbeeld de <envar>SHELL</envar>,
	  <envar>PATH</envar> en <envar>HOME</envar> variabelen.  Als de
	  <envar>SHELL</envar> regel ontbreekt, zal
	  <command>cron</command> standaard <command>sh</command> als
	  shell gebruiken.  Voor de <envar>PATH</envar>
	  omgevingsvariabele is er geen standaardwaarde.  Als
	  <envar>PATH</envar> ontbreekt moet men absolute paden
	  gebruiken.  Indien <envar>HOME</envar> ontbreekt, zal
	  <command>cron</command> de home directory gebruiken van de
	  de gebruiker die <command>cron</command> aanroept.</para>
      </callout>

      <callout arearefs="co-field-descr">
	<para>In deze commentaarregel kun je de zeven velden zien van
	  een crontab definitie.  Dit zijn <literal>minute</literal>,
	  <literal>hour</literal>, <literal>mday</literal>,
	  <literal>month</literal>, <literal>wday</literal>,
	  <literal>who</literal> en <literal>command</literal>.  De
	  betekenissen liggen voor de hand: <literal>minute</literal> is
	  het aantal minuten van het tijdstip waarop het commando moet
	  worden uitgevoerd; <literal>hour</literal> geeft het uur aan;
	  <literal>mday</literal> staat voor de dag van de maand;
	  <literal>month</literal> staat voor het maandnnummer en
	  <literal>wday</literal> geeft de dag van de week aan.  Het
	  veld <literal>who</literal> is bijzonder en bestaat enkel in
	  het <filename>/etc/crontab</filename> bestand.  Het geeft aan
	  als welke gebruiker het commando dient te worden uitgevoerd.
	  Een gebruiker die zijn eigen <filename>crontab</filename>
	  bestand installeert heeft deze optie niet.  Het
	  <literal>command</literal> veld tenslotte bevat het uit te
	  voeren commando.</para>
      </callout>

      <callout arearefs="co-main">
	<para>In deze regel worden aan de hierboven besproken opties
	  waarden toegekend.  Merk op dat er gebruik wordt gemaakt van
	  <literal>*</literal> karakters.  Deze betekenen
	  <quote>eerst-laatst</quote> en kunnen gezien worden als
	  <emphasis>telkens</emphasis>.  In deze regel staat dus dat
	  het commando <command>atrun</command> elke vijf minuten
	  moet worden uitgevoerd door <username>root</username>,
	  ongeacht welke dag of maand het is.  Voor meer informatie over
	  <command>atrun</command> wordt verwezen naar de &man.atrun.8;
	  handleiding.</para>

	<para>Commando's kunnen een willekeurig aantal schakelopties of
	  argumenten hebben.  Echter, als commando's meerdere regels
	  nodig hebben moeten deze regels afgebroken worden met een
	  backslash <quote>\</quote> karakter, om aan te geven dat ze
	  op de volgende regel vervolgd worden.</para>
      </callout>
    </calloutlist>

    <para>Dit is de basisopzet voor elk <filename>crontab</filename>
      bestand.  De enige uitzondering is de aanwezigheid van veld nummer
      zes, waar de gebruikersnaam gespecificeerd wordt.  Dit veld
      bestaat alleen in het systeembestand
      <filename>/etc/crontab</filename>.  Voor
      <filename>crontab</filename> bestanden van individuele
      gebruikers moet dit veld worden weggelaten.</para>

    <sect2 id="configtuning-installcrontab">
      <title>Een crontab installeren</title>

      <para>Om een nieuwe <filename>crontab</filename> te installeren
	kun je het <command>crontab</command> commando gebruiken.
	Het meest gebruikelijk is:</para>

      <screen>&prompt.root; <userinput>crontab crontab</userinput></screen>

      <para>Er bestaat ook een optie om een lijst van
	ge&iuml;nstalleerde <filename>crontab</filename> bestanden op te
	vragen, namelijk de <option>-l</option> schakeloptie van
	<command>crontab</command>.</para>

      <para>Gebruikers die hun eigen crontab bestand willen schrijven
	zonder het gebruik van een template, kunnen de
	<command>crontab -e</command> optie benutten.  Dit zal je
	<envar>EDITOR</envar> openen met een leeg bestand.  Wanneer het
	bestand wordt opgeslagen en de editor afgesloten, wordt het
	bestand automatisch als <filename>crontab</filename>
	ge&iuml;nstalleerd.</para>

    </sect2>
  </sect1>

  <sect1 id="configtuning-rcNG">
    <sect1info>
      <authorgroup>
	 <author>
	 <firstname>Tom</firstname>
	 <surname>Rhodes</surname>
	 <contrib>Een bijdrage van </contrib>
	 </author>
      </authorgroup>
    </sect1info>

    <title>Het rc-systeem van FreeBSD 5.X</title>

    <indexterm><primary>rcNG</primary></indexterm>

    <para>&os; heeft recentelijk het NetBSD
      <filename>rc.d</filename> systeem voor systeem initialisatie
      overgenomen.  Veel van de bestanden in
      <filename>/etc/rc.d</filename> zijn scripts voor basisservices
      die werken met de <option>start</option>, <option>stop</option>
      en <option>restart</option> opties, analoog aan de wijze waarop
      services die via een port of pakket zijn ge&iuml;nstalleerd
      gestart worden met de scripts in
      <filename>/usr/local/etc/rc.d</filename>.
      Je kunt bijvoorbeeld &man.sshd.8; herstarten als volgt:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd restart</userinput></screen>

    <para>Deze procedure is hetzelfde voor andere services.  Uiteraard
      worden services normaliter automatisch gestart zoals
      gespecificeerd in &man.rc.conf.5;.  Om bijvoorbeeld de Network
      Address Translation daemon te starten bij het opstarten van het
      systeem voeg je simpelweg de volgende regel toe aan
      <filename>/etc/rc.conf</filename>:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Als er reeds een <option>natd_enable="NO"</option> regel is,
      verander je gewoon <option>NO</option> in <option>YES</option>.
      De rc scripts zullen voor zover nodig automatisch andere
      afhankelijke services starten.</para>

    <para>Omdat het <filename>rc.d</filename> systeem in eerste instantie
      bedoeld is om services te starten/stoppen bij het
      opstarten/afsluiten van het systeem zullen de standaard
      <option>start</option>, <option>stop</option> en
      <option>restart</option> opties alleen werken als de geschikte
      variabelen in <filename>/etc/rc.conf</filename> ingesteld zijn.
      Bijvoorbeeld, het <command>sshd restart</command> commando werkt
      dan en slechts dan als <varname>sshd_enable</varname> de waarde
      <option>YES</option> krijgt in <filename>/etc/rc.conf</filename>.
      Als je een service wil starten, stoppen of herstarten ongeacht de
      definities in <filename>/etc/rc.conf</filename> moet het commando
      voorafgegaan te worden met <quote>force</quote>.  Dus om
      <command>sshd</command> te herstarten ongeacht
      <filename>/etc/rc.conf</filename> setting, zou je het volgende
      commando uitvoeren:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd forcerestart</userinput></screen>

    <para>Je kunt eenvoudig controleren of een service is "aangezet" in
      <filename>/etc/rc.conf</filename> door het bijpassende
      <filename>rc.d</filename> script uit te voeren met de optioe
      <option>rcvar</option>.  Bijvoorbeeld voor
      <command>sshd</command>:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note><para>De tweede regel (<literal># sshd</literal>) is de uitvoer
	van het <command>sshd</command> command, niet een
	<username>root</username> console.</para></note>

    <para>Om vast te stellen of een service draait is er de
      <option>status</option> optie.  Bijvoorbeeld, om te controleren
      of <command>sshd</command> daadwerkelijk gestart is:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>Het is ook mogelijk om een service te herladen met de optie
      <option>reload</option>.  Dan wordt er getracht een signaal te
      sturen aan een individuele service, waarbij de service haar
      configuratiebestanden zal moeten herlezen.  Meestal komt dit neer
      op het verzenden van een <literal>SIGHUP</literal> signaal.</para>

    <para>De <application>rcNG</application> structuur wordt niet alleen
      gebruikt voor netwerkservices, maar ook voor het merendeel van de
      systeeminitialisatie.  Beschouw bijvoorbeeld het bestand
      <filename>bgfsck</filename>.  Als dit script wordt uitgevoerd
      zal de volgende boodschap worden getoond:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Dit script wordt dus gebruikt voor bestandssysteemcontrole
      in de achtergrond, hetgeen alleen tijdens systeeminitialisatie
      gebeurt.</para>

    <para>Veel systeemservices zijn afhankelijk van andere services om
      correct te kunnen functioneren.  Zo zullen NIS en andere
      RPC-gebaseerde services niet starten als de
      <command>rpcbind</command> (portmapper) service nog niet draait.
      Om dit te stroomlijnen wordt informatie over afhankelijkheden en
      andere meta-data ingevoegd in het commentaar bovenaan het
      opstartscript.  Het &man.rcorder.8; programma wordt vervolgens
      gebruikt om deze commentaarregels te verwerken tijdens de
      systeeminitialisatie en zo vast te stellen in welke volgorde
      de systeemservices gestart moeten worden.  De volgende woorden
      kunnen worden ingevoegd aan het begin van elk
      opstartscript:</para>

    <itemizedlist>
      <listitem>
	<para><literal>PROVIDE</literal>: Specificeert in welke services
	  dit bestand voorziet.</para>
      </listitem>

      <listitem>
	<para><literal>REQUIRE</literal>: Specificeert welke andere
	  services vereist zijn voor deze service.  Dit script wordt
	  uitgevoerd <emphasis>na</emphasis> de gespecificeerde
	  services.</para>
      </listitem>

      <listitem>
	<para><literal>BEFORE</literal>: Specificeert services die
	  afhankelijk zijn van deze service.
	  Dit bestand wordt uitgevoerd <emphasis>voor</emphasis>
	  de gespecificeerde services.</para>
      </listitem>

      <listitem>
	<para>KEYWORD: &os; of NetBSD.  Dit wordt gebruikt voor speciale
	  eigenschappen van &eacute;&eacute;n van de *BSD's.</para>
      </listitem>
    </itemizedlist>

    <para>Met deze methode kan een systeembeheerder gemakkelijk
      systeemservices besturen, zonder gedoe met <quote>runlevels</quote>
      zoals met sommige andere &unix; systemen het geval is.</para>

    <para>Overige informatie over het &os; 5.X
      <filename>rc.d</filename> systeem vindt u in de &man.rc.8;
      en &man.rc.subr.8; handleidingen.</para>
  </sect1>

  <sect1 id="config-network-setup">
    <sect1info>
      <authorgroup>
	 <author>
	 <firstname>Marc</firstname>
	 <surname>Fonvieille</surname>
	 <contrib>Een bijdrage van </contrib>
	 </author>
      </authorgroup>
    </sect1info>

    <title>Configureren van een netwerkkaart</title>

    <indexterm><primary>netwerkkaart configuratie</primary></indexterm>

    <para>We kunnen ons vandaag nog nauwelijks een computer voorstellen
      zonder een netwerkverbinding.  Het toevoegen en configureren van
      een netwerkkaart is een gebruikelijke taak voor een
      &os; beheerder.</para>

    <sect2>
      <title>Het geschikte stuurprogramma vinden</title>

      <indexterm>
	<primary>netwerkkaart configuratie</primary>
	<secondary>stuurprogramma</secondary>
      </indexterm>

      <para>Voor je begint, moet je weten welke kaart je hbet, welke
	chip erop zit en of het een PCI of ISA kaart is.  &os;
	ondersteunt vele kaarten.  Controleer de
	Hardware Compatibiliteit Lijst voor de betreffende release om
	na te gaan of je kaart ondersteund wordt.</para>

      <para>Als je zeker bent dat je kaart ondersteund wordt, moet
	vastgesteld worden wat het geschikte stuurprogramma is.
	Het bestand <filename>/usr/src/sys/i386/conf/LINT</filename>
	(4.X) of <filename>/usr/src/sys/conf/NOTES</filename> geeft een
	lijst van netwerkinterface stuurprogramma's met wat informatie
	over de ondersteunde chipsets/kaarten.  In geval van twijfel,
	lees dan de handleiding van het stuurprogramma
	(<command>man</command>).  In het algemeen bevat deze meer
	informatie over de ondersteunde hardware en mogelijke problemen
	die kunnen optreden.</para>

      <para>Als je een veelgebruikte kaart hebt, hoeft je waarschijnlijk
	niet ver te zoeken.  Stuurprogramma's voor veelvoorkomende
	netwerken zijn al aanwezig in de algemene
	<filename>GENERIC</filename> kernel, in dat geval zal je kaart
	reeds gevonden worden bij het opstarten, bijvoorbeeld zo:</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</screen>

      <para>In dit voorbeeld zijn er twee kaarten die het &man.dc.4;
	stuurprogramma gebruiken aanwezig in het systeem.</para>

      <para>Pas als het juiste stuurprogramma geladen is, kan de
	netwerkkaart gebruikt worden.  Dit kan op twee manieren.
	Het eenvoudigste is om een kernel module te laden voor de
	kaart met &man.kldload.8;.  Maar voor sommige NIC
	stuurprogramma's (bijvoorbeeld ISA kaarten en sommige kaarten
	die het &man.ed.4; stuurprogramma gebruiken) is er geen module.
	Je kunt ook als alternatief de ondersteuning voor je kaart
	in de kernel compileren.  Controleer
	<filename>/usr/src/sys/i386/conf/LINT</filename> (4.X) of
	<filename>/usr/src/sys/conf/NOTES</filename> (5.X) en de
	handleiding van het stuurprogramma om na te gaan wat er in het
	kernel configuratiebestand moet staan.  Zie
	<xref linkend="kernelconfig"> voor meer informatie over het
	compileren van een eigen kernel.  Als je netwerkkaart al bij het
	opstarten wordt herkend door de <filename>GENERIC</filename>
	kernel hoeft je geen eigen kernel te bouwen.</para>
    </sect2>

    <sect2>
      <title>Configuratie van de netwerkkaart</title>

      <indexterm>
	<primary>Netwerkkaart configuratie</primary>
	<secondary>configuratie</secondary>
      </indexterm>

      <para>Nadat een geschikt stuurprogramma geladen is, moet de kaart
	nog geconfigureerd worden.  Mogelijk is dit al gebeurd door
	<application>sysinstall</application> tijdens de
	installatie.</para>

      <para>Om de configuratie van de netwerkkaarten te zien:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
         ether 00:a0:cc:da:da:da
         media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
         status: active
dc1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
         ether 00:a0:cc:da:da:db
         media: Ethernet 10baseT/UTP
         status: no carrier
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
	 inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</screen>

      <note><para>Op oudere versies van of &os; moet je misschien de
	  <option>-a</option> optie gebruiken, volgens &man.ifconfig.8;;
	  voor meer details over de syntax van &man.ifconfig.8; wordt
	  verwezen naar de handleiding.  Merk op dat de invoer voor wat
	  betreft IPv6 (<literal>inet6</literal> etc.) in dit voorbeeld
	  achterwege is gelaten.</para></note>

      <para>In dit voorbeeld werden de volgende apparaten
	weergegeven:</para>

      <itemizedlist>
	<listitem>
	  <para><devicename>dc0</devicename>: De eerste Ethernet
	    interface</para>
	</listitem>

	<listitem>
	  <para><devicename>dc1</devicename>: De tweede Ethernet
	    interface</para>
	</listitem>

	<listitem>
	  <para><devicename>lp0</devicename>: De parallelle poort
	    interface</para>
	</listitem>

	<listitem>
	  <para><devicename>lo0</devicename>: Het loopback
	    apparaat</para>
	</listitem>

	<listitem>
	  <para><devicename>tun0</devicename>: Het tunnel apparaat
	    gebruikt door <application>ppp</application></para>
	</listitem>
      </itemizedlist>

      <para>&os; gebruikt de naam van het stuurprogramma gevolgd door
	een nummer voor de volgorde waarop de kaarten gedetecteerd zijn
	bij het opstarten.  Bijvoorbeeld <devicename>sis2</devicename>
	zou de derde netwerkkaart zijn in het systeem die het
	stuurprogramma &man.sis.4; gebruikt.</para>

      <para>In dit voorbeeld is het <devicename>dc0</devicename>
	apparaat volledig operationeel.  Dit blijkt uit de volgende
	indicatoren:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> betekent dat de kaart
	    geconfigureerd en klaar voor gebruik is.</para>
	</listitem>

	<listitem>
	  <para>De kaart heeft een Internet (<literal>inet</literal>)
	    adres (in dit geval
	    <hostid role="ipaddr">192.168.1.3</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Het heeft een geldig subnet masker (<literal>netmask</literal>;
	    <hostid role="netmask">0xffffff00</hostid> is hetzelfde als
	    <hostid role="netmask">255.255.255.0</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Het heeft een geldig uitzendadres (in dit geval,
	    <hostid role="ipaddr">192.168.1.255</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Het MAC adres van de kaart (<literal>ether</literal>)
	    is <hostid role="mac">00:a0:cc:da:da:da</hostid></para>
	</listitem>

	<listitem>
	  <para>De fysieke mediaselectie is in autoselectie modus
	    (<literal>media: Ethernet autoselect (100baseTX
	    &lt;full-duplex&gt;)</literal>).  Ook zie je dat
	    <devicename>dc1</devicename> geconfigureerd is om met
	    <literal>10baseT/UTP</literal> media te werken.  Voor meer
	    informatie over de mogelijke media types, zie de handleiding
	    voor het betreffende stuurprogramma.</para>
	</listitem>

	<listitem>
	  <para>De status van de link (<literal>status</literal>)
	    is <literal>active</literal>, d.w.z. de drager is gevonden.
	    Voor <devicename>dc1</devicename> ziet men echter
	    <literal>status: no carrier</literal>.  Dit is normaal als
	    er geen ethernet kabel in de kaart gestoken is.</para>
	</listitem>
      </orderedlist>

      <para>Als de &man.ifconfig.8; uitvoer er ongeveer zo uitziet:</para>

<screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
		 ether 00:a0:cc:da:da:da</screen>

      <para>dan is de netwerkkaart nog niet geconfigureerd.</para>

      <para>Om de kaart te configureren heb je <username>root</username>
	privileges nodig.  De netwerkkaart configuratie van vanaf de
	console worden verricht met &man.ifconfig.8; maar dan zou je het
	na elke keer opnieuw opstarten moeten herhalen.  Daarom zet je
	het in het <filename>/etc/rc.conf</filename> bestand.</para>

      <para>Open <filename>/etc/rc.conf</filename> in je favoriete
	editor.  Je zult een regel moeten invoegen voor elke
	netwerkkaart in je systeem, in dit voorbeeld::</para>

<programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para><devicename>dc0</devicename>,
	<devicename>dc1</devicename>, etc, moeten vervangen worden door
	de correcte stuurprogramma's voor je netwerk kaarten, zo ook de
	IP nummers.  In de handleiding van het stuurprogramma en van
	&man.ifconfig.8; vind je meer details over de mogelijke opties
	en in de &man.rc.conf.5; handleiding staat meer informatie over
	het <filename>/etc/rc.conf</filename> bestand.</para>

      <para>Als het netwerk al geconfigureerd is tijdens het installeren
	van &os; zullen er al enkele regels met betrekking tot de
	netwerkkaart(en) in <filename>/etc/rc.conf</filename> staan.
	Controleer <filename>/etc/rc.conf</filename> voor je regels
	toevoegt.</para>

      <para>Ook het bestand <filename>/etc/hosts</filename> moet worden
	gewijzigd om de namen en IP adressen van verschillende machines
	op het lokale netwerk, als ze er nog niet in staan.  Voor meer
	informatie, zie &man.hosts.5; en
	<filename>/usr/share/examples/etc/hosts</filename>.</para>
    </sect2>

    <sect2>
      <title>Testen en probleemoplossing</title>

      <para>Als de gewenste veranderingen in
	<filename>/etc/rc.conf</filename> gemaakt zijn, moet je het
	systeem opnieuw opstarten (of nauwkeurig alle daemons starten
	of herstarten).  Veranderingen aan de interface(s) worden dan
	toegepast en je kunt controleren of herstarten goed werkt
	zonder foutmeldingen.</para>

      <para>Als de kaart werkt maar de performance is slecht, kan het de
	moeite waard zijn om de &man.tuning.7; handleiding door te
	nemen.  Controleer ook de netwerkconfiguratie, want ook
	incorrecte netwerkinstellingen kunnen tot langzame verbindingen
	leiden.</para>

      <para>Soms kunnen enkele <quote>device timeouts</quote> optreden.
	Met sommige kaarten is dit normaal gedrag.  Maar als dit
	continu gebeurt of storend is, ga dan na of er geen sprake is
	van een hardwareconfict tussen de netwerkkaart en een ander
	apparaat.  Controleer nogmaals de bekabeling.  Misschien zit er
	niets anders op dan een ander netwerkkaartje te gebruiken.</para>

      <para>Je kunt ook geconfronteerd worden met een paar
	<errorname>watchdog timeout</errorname> foutmeldingen.  Als
	eerste moet je dan de netwerkkabel controleren.  Veel kaarten
	hebben een PCI slot nodig dat Bus Mastering ondersteund.
	Sommige oudere moederborden hebben maar &eacute;&eacute;n PCI
	slot waarmee dit kan (meestal slot 0).  Controleer de
	documentatie van de netwerkkaart en het moederbord om na te
	gaan of dit het probleem is.</para>

      <para><errorname>No route to host</errorname> meldingen treden op
	als het systeem niet in staat is om een pakket naar de
	eindbestemming te routeren.  Dit kan gebeuren als er geen
	standaardroute gespecificeerd is of als er een kabel niet
	verbonden is.  Controleer de uitvoer van
	<command>netstat -rn</command> en ga na dat er een geldige
	route is naar de bestemming.  Mocht dit niet het geval zijn,
	dan kun je verder lezen hoe dit moet in
	<xref linkend="advanced-networking">.</para>

      <para><errorname>ping: sendto: Permission denied</errorname>
	foutmeldingen worden vaak veroorzaakt door een verkeerd
	geconfigureerde firewall.  Als de kernel <command>ipfw</command>
	activeert bij het opstarten zonder dat er firewallregels zijn
	gedefini&euml;erd, is de standaard policy om alle verkeer te
	weigeren, zelfs pings! Zie <xref linkend="firewalls"> voor meer
	informatie.</para>

      <para>Er kan ook sprake zijn van onvoldoende performance doordat
	de mediaselectie instelling niet optimaal is.  In dergelijke
	gevallen kun je proberen om de mediaselectie niet als
	<literal>autoselect</literal> in te stellen maar expliciet
	aangeven wat de mediaselectie moet zijn, bijvoorbeeld
	10baseT/UTP voor twisted pair.  Hoewel dit voor de meeste
	hardware zal helpen, kan het zijn dat de problemen blijven.
	Controleer dan nogmaals de netwerkinstellingen en lees de
	&man.tuning.7; handleiding.</para>

    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Virtuele hosts</title>

    <indexterm><primary>virtuele hosts</primary></indexterm>
    <indexterm><primary>IP aliassen</primary></indexterm>

    <para>&os; wordt veel gebruikt voor virtuele sitehosting, waarbij
      &eacute;&eacute;n fysieke server er op het netwerk uitziet alsof
      het meerdere servers zijn.  Dit kan bereikt worden door meerdere
      IP adressen toe te kennen aan dezelfde interface.</para>

    <para>Een bepaalde netwerkinterface heeft een <quote>echt</quote>
      adres en kan daarnaast een willekeurig aantal <quote>alias</quote>
      adressen hebben.  Normaliter worden dergelijke aliassen toegevoegd
      door aliasregels toe te voegen aan
      <filename>/etc/rc.conf</filename>.</para>

    <para>Een aliasregel voor de interface <devicename>fxp0</devicename>
      ziet er zo uit:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Merk op dat aliasregels beginnen met alias0 en daarna _alias1,
      _alias2, enz.  Het configuratieproces stopt als er een nummer
      ontbreekt.</para>

    <para>Het is belangrijk dat aliassen het juiste netmasker hebben.
      Dit is eenvoudig: Een bepaalde interface moet altijd
      &eacute;&eacute;n adres hebben dat het netmasker van het netwerk
      correct representeert.  Elk ander adres binnen dit netwerk op
      deze interface (alias) moet een netmasker van allemaal enen
      (bits) hebben.</para>

    <para>Een voorbeeld.  Stel de <devicename>fxp0</devicename>
      interface is verbonden met twee netwerken, het
      <hostid role="ipaddr">10.1.1.0</hostid> netwerk met masker
      <hostid role="netmask">255.255.255.0</hostid> en het
      <hostid role="ipaddr">202.0.75.16</hostid> met netmasker
      <hostid role="netmask">255.255.255.240</hostid>.  We willen dat
      het systeem op <hostid role="ipaddr">10.1.1.1</hostid> tot en met
      <hostid role="ipaddr">10.1.1.5</hostid> en op
      <hostid role="ipaddr">202.0.75.17</hostid> tot en met
      <hostid role="ipaddr">202.0.75.20</hostid>.</para>

    <para>Dit kan als volgt geregeld worden:</para>

<programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Configuratiebestanden</title>

    <sect2>
      <title><filename>/etc</filename> layout</title>
      <para>Configuratiedata wordt in een aantal directories bewaard,
	 o.m:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>Generieke systeemconfiguratiebestanden; deze zijn
		specifiek voor het systeem.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>De standaardversies van
		systeemconfiguratiebestanden die gebruikt als er geen
		in <filename>/etc</filename> staat.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>Extra &man.sendmail.8; configuratiebestanden, of
		configuratiebestanden voor andere MTAs.
	      </entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>Configuratie voor zowel for user- als kernel-ppp
		programma's.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>Standaard locatie voor &man.named.8; data.
		Normaal gesproken bevinden zich hier
		<filename>named.conf</filename> en zonebestanden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/etc</filename></entry>
	      <entry>Configuratiebestanden voor ge&iuml;nstalleerde
		software.  Kan subdirectories hebben waarin bij elkaar
		horende configuratiedata van een applicatie gegroepeerd
		zijn.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>Start/stop scripts voor ge&iuml;nstalleerde
		services.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>Automatisch gegenereerde systeem-specifieke
		database bestanden, zoals de pakketdatabase, de
		&man.locate.1; database, enz.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Hostnamen</title>

      <indexterm><primary>hostnaam</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm>
	  <primary><filename>resolv.conf</filename></primary>
	</indexterm>

	<para>In <filename>/etc/resolv.conf</filename> wordt
	  voorgeschreven op welke wijze &os; het Domain Name System
	  (DNS) moet gebruiken.</para>

	<para>De meest voorkomende termen in
	  <filename>resolv.conf</filename> zijn:</para>

	<informaltable frame="none">
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>
		<entry>Het IP adres van een naamserver die ondervraagd
		  moet worden voor naam/IP conversie.  De servers worden
		  in volgorde geprobeerd en het maximale aantal is
		  drie.</entry>
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Zoeklijst voor het opzoeken van hostnamen.
		  Meestal wordt deze bepaald door het domein waarop de
		  lokale hostnaam zich bevindt.</entry>
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>De lokale domeinnaam.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Een typisch <filename>resolv.conf</filename> bestand:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note><para>Gebruik of <literal>search</literal> of
	  <literal>domain</literal>, maar niet beide opties tegelijk.
	   </para></note>

	<para>Als je DHCP gebruikt: &man.dhclient.8; overschrijft
	  normaliter <filename>resolv.conf</filename> met informatie
	  ontvangen van de DHCP server.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>

	<para><filename>/etc/hosts</filename> is een eenvoudige
	  tekstdatabase uit de dagen van het oude Internet.  Het werkt
	  samen met DNS en NIS om namen en IP nummers over en weer te
	  vertalen.  Lokale computers verbonden via een LAN kunnen best
	  hierin gezet worden om zo op simpele wijze naam/IP conversie
	  voor je LAN te hebben, zonder een &man.named.8; server te
	  hoeven draaien.  Ook kun je naamaliassen toekennen
	  (vergelijkbaar met CNAMES bij DNS).  Op soortgelijke wijze kan
	  <filename>/etc/hosts</filename> ook gebruikt worden als een
	  (zeer beperkte) lokale DNS cache.
	 </para>

	<programlisting># &dollar;&os;&dollar;
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                      localhost localhost.my.domain myname.my.domain
127.0.0.1                localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2                myname.my.domain myname
#10.0.0.3                myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#        10.0.0.0        -   10.255.255.255
#        172.16.0.0      -   172.31.255.255
#        192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#</programlisting>

	<para><filename>/etc/hosts</filename> heeft als formaat:</para>

	<programlisting>[Internet address] [official hostname] [alias1] [alias2] ...</programlisting>

	<para>Bijvoorbeeld:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Raadpleeg &man.hosts.5; voor meer informatie.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Logbestanden configureren</title>

      <indexterm><primary>logbestanden</primary></indexterm>

      <sect3>
	<title><filename>syslog.conf</filename></title>

	<indexterm><primary>syslog.conf</primary></indexterm>

	<para><filename>syslog.conf</filename> is het
	  configuratiebestand voor het &man.syslogd.8; programma.  Het
	  geeft aan welke soorten <command>syslog</command> berichten er
	  gelogd moeten worden en naar welke logbestanden, apparaten,
	  gebruikers of machines.</para>

	<programlisting># &dollar;&os;&dollar;
#
#        Spaces ARE valid field separators in this file.  However,
#        other *nix-like systems still insist on using tabs as field
#        separators.  If you are sharing this file between systems, you
#        may want to use only tabs as field separators here.
#        Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit           /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err  /var/log/messages
security.*                                       /var/log/security
mail.info                                        /var/log/maillog
lpr.info                                         /var/log/lpd-errs
cron.*                                           /var/log/cron
*.err                                            root
*.notice;news.err                                root
*.alert                                          root
*.emerg                                          *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                    /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                             /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                             @loghost
# uncomment these if you're running inn
# news.crit                                      /var/log/news/news.crit
# news.err                                       /var/log/news/news.err
# news.notice                                    /var/log/news/news.notice
!startslip
*.*                                              /var/log/slip.log
!ppp
*.*                                              /var/log/ppp.log</programlisting>

	<para>Zie de &man.syslog.conf.5; handleiding voor meer
	  informatie.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>

	<para><filename>newsyslog.conf</filename> is het
	  configuratiebestand voor &man.newsyslog.8;, een programma
	  dat normaal op gezette tijden via &man.cron.8; wordt
	  uitgevoerd.  &man.newsyslog.8; stelt vast wanneer logbestanden
	  moeten gearchiveerd of anderszins opnieuw gearrangeerd moeten
	  worden.  <filename>logfile</filename> wordt hernoemd naar
	  <filename>logfile.0</filename>, <filename>logfile.0</filename>
	  naar <filename>logfile.1</filename>, enz.</para>

	<para><filename>newsyslog.conf</filename> geeft aan welke
	  logbestanden beheerd moeten worden, hoeveel er in archieven
	  bewaard moeten worden, en wanneer ze aangemaakt moeten worden.
	  Logbestanden kunnen gereorganiseerd en/of gearchiveerd worden
	  als ze een bepaalde grootte bereikt hebben of op een bepaald
	  periodiek tijdstip of een bepaalde datum.</para>

	<programlisting># configuration file for newsyslog
# &dollar;&os;&dollar;
#
# filename           [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                            600  3     100  *     Z
/var/log/amd.log                         644  7     100  *     Z
/var/log/kerberos.log                    644  7     100  *     Z
/var/log/lpd-errs                        644  7     100  *     Z
/var/log/maillog                         644  7     *    @T00  Z
/var/log/sendmail.st                     644  10    *    168   B
/var/log/messages                        644  5     100  *     Z
/var/log/all.log                         600  7     *    @T00  Z
/var/log/slip.log                        600  3     100  *     Z
/var/log/ppp.log                         600  3     100  *     Z
/var/log/security                        600  10    100  *     Z
/var/log/wtmp                            644  3     *    @01T05 B
/var/log/daily.log                       640  7     *    @T00  Z
/var/log/weekly.log                      640  5     1    $W6D0 Z
/var/log/monthly.log                     640  12    *    $M1D0 Z
/var/log/console.log                     640  5     100  *     Z</programlisting>

	<para>In de &man.newsyslog.8; handleiding vind je meer
	  informatie.</para>
      </sect3>
    </sect2>

    <sect2>
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> lijkt veel op
	<filename>rc.conf</filename>.  Waardetoekenning heeft weer de
	<literal>variable=value</literal> vorm.  De gespecificeerde
	&man.sysctl.8; waarden worden doorgevoerd op het moment dat het
	systeem naar multi-user modus gaat.  Niet alle variabelen kunnen
	in deze modus gewijzigd worden.</para>

      <para>Een voorbeeld <filename>sysctl.conf</filename> waarin het
	loggen van gevallen waarin een proces be&euml;indigd wordt ten
	gevolge van een fataal signaal (bijv. een TERM signaal of een
	exitcode van een programma dat crasht) wordt uitgezet en waarin
	de Linux emulatielaag zodanig wordt ingesteld dat een Linux
	programma ook echt zal rapporteren dat het onder &os;
	draait:</para>

      <programlisting>kern.logsigexit=0	# Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=&os;
compat.linux.osrelease=4.3-STABLE</programlisting>
    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Optimalisering met sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm>
      <primary>optimalisering</primary>
      <secondary>met sysctl</secondary>
    </indexterm>

    <para>&man.sysctl.8; is een interface waarmee je veranderingen kunt
      aanbrengen aan een draaiend &os; systeem.  Er zijn onder meer vele
      geavanceerde opties voor de TCP/IP stack en het virtuele
      geheugensysteem, waarmee een ervaren systeembeheerder de
      systeemprestaties drastisch kan verbeteren.  Met &man.sysctl.8;
      kunnen meer dan vijfhonderd ststeemvariabelen opgevraagd en
      ingesteld worden.</para>

    <para>In de kern heeft &man.sysctl.8; twee funkties: het lezen en
      wijzigen van systeeminstellingen.</para>

    <para>Om alle leesbare variabelen te zien:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Om een bepaalde variabele op te vragen, bijvoorbeeld
      <varname>kern.maxproc</varname>:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Om een bepaalde variabele toe te kennen (te wijzigen), is de
      voor de hand liggende syntax
      <replaceable>variable</replaceable>=<replaceable>value</replaceable>:
      </para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>Waarden van sysctl variabelen zijn doorgaans strings (tekst),
      getallen of booleans (<literal>1</literal> als waar,
      <literal>0</literal> als onwaar).</para>

  <sect2 id="sysctl-readonly">
    <sect2info>
      <authorgroup>
	 <author>
	 <firstname>Tom</firstname>
	 <surname>Rhodes</surname>
	 <contrib>Een bijdrage van </contrib>
	 </author>
      </authorgroup>
    </sect2info>
    <title>&man.sysctl.8; alleen-lezen</title>

    <para>In sommige gevallen kan het wenselijk zijn om &man.sysctl.8;
      waarden die alleen-lezen zijn toch te wijzigen.  Het zal duidelijk
      zijn dat dit niet wordt aangeraden, maar het is soms
      onvermijdelijk.</para>

    <para>Op sommige laptops, bijvoorbeeld, is het &man.cardbus.4;
      apparaat niet in staat om geheugenregio's af te tasten, met als
      gevolg foutmeldingen als:</para>

    <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

    <para>In dergelijke gevallen moeten er meestal enkele &man.sysctl.8;
      instellingen gewijzigd worden die alleen-lezen zijn en een
      standaardwaarde hebben.  Dit kan bereikt worden door
      &man.sysctl.8; <quote>OIDs</quote> in het lokale
      <filename>/boot/loader.conf</filename> te zetten.
      Standaardinstellingen zijn te vinden in
      <filename>/boot/defaults/loader.conf</filename>.</para>

    <para>Om het bovenstaande probleem op te lossen moet
      <option>hw.pci.allow_unsupported_io_range=1</option> gezet worden
      in <filename>/boot/loader.conf</filename>.  Nu zal &man.cardbus.4;
      wel goed werken.</para>

    </sect2>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Harde schijven optimaliseren</title>

    <sect2>
      <title>Sysctl variabelen</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>

	<para>De <varname>vfs.vmiodirenable</varname> sysctl variabele
	  kan de waarde 0 (uit) of 1 (aan) hebben.  De standaardwaarde
	  is 1.  Deze variabele bepaalt hoe directories door het systeem
	  in een cache bewaard worden.  De meeste directories zijn
	  klein en gebruiken slechts een klein fragment (typisch
	  1&nbsp;K) in het bestandssysteem en nog minder (typisch
	  512&nbsp;bytes) in de buffer cache.  In de standaard modus
	  operandi zal de buffer cache slechts een bepaald aantal
	  directories in de cache bewaren, ook al is er een overvloed
	  aan geheugen beschikbaar.  Met deze sysctl wordt de VM page
	  cache gebruikt, waardoor voor het cachen van directories al
	  het geheugen kan worden gebruikt.  Het is echter wel
	  zo dat het minimale in-core geheugen dat gebruikt wordt om een
	  directory te cachen in dat geval de fysieke page size is
	  (typisch 4&nbsp;K) i.p.v. 512&nbsp; bytes.  Deze optie wordt
	  vooral aanbevolen als je services wil draaien die met grote
	  aantallen bestanden werken, zoals webcaches, grote
	  mailsystemen en newsservers.  In het algemeen zal deze optie
	  de performance niet verlagen, ook al kost het meer geheugen,
	  maar je zult moeten experimenteren om dit voor jouw specifieke
	  machine na te gaan.</para>
      </sect3>

     <sect3>
 	<title><varname>vfs.write_behind</varname></title>

 	<indexterm>
 	  <primary><varname>vfs.write_behind</varname></primary>
 	</indexterm>

 	<para>De <varname>vfs.write_behind</varname> sysctl variabele
	  staat standaard aan (<literal>1</literal>).  Dit betekent dat
	  het bestandssysteem data naar het medium gaat schrijven op het
	  moment dat er een volledig clusters aan data verzameld zijn.
	  Dit is typisch het geval bij het schrijven van grote
	  sequenti&euml;le bestanden.  Het idee is om te voorkomen dat
	  de buffercache verzadigd raakt met vuile buffers zonder dat
	  dit bijdraagt aan de I/O performance.  Dit kan echter
	  processen ophouden en onder sommige omstandigheden wil je
	  mogelijk deze sysctl uitzetten.</para>
	</sect3>

	<sect3>
 	<title><varname>vfs.hirunningspace</varname></title>

 	<indexterm>
 	  <primary><varname>vfs.hirunningspace</varname></primary>
 	</indexterm>

 	<para>De <varname>vfs.hirunningspace</varname> sysctl variabele
	  bepaalt hoeveel nog te schrijven data er systeemwijd op elk
	  moment in de wachtrij naar schijfcontrollers mag staan.  De
	  standaardwaarde is normaal voldoende maar op machines met veel
	  schijven, wil je deze misschien verhogen naar vier of vijf
	  <emphasis>megabytes</emphasis>.  Merk op dat het zetten van
	  een te hoge waarde (groter dan de schrijfdrempel van de
	  buffer cache) kan leiden tot zeer slechte clustering
	  performance.  Zet deze waarde niet arbitrair hoog! Hogere
	  schrijfwaarden kunnen latentie veroorzaken in het lezen als
	  dit tegelijk plaatsvindt.</para>

 	<para>Er zijn verscheidene andere sysctls betreffende buffer
	  cache en VM page cache.  Het wordt afgeraden deze te wijzigen.
	  Sinds &os; 4.3 is het VM systeem zeer goed in staat zichzelf
	  automatisch te tunen.</para>
	</sect3>

	<sect3>
 	<title><varname>vm.swap_idle_enabled</varname></title>

 	<indexterm>
 	  <primary><varname>vm.swap_idle_enabled</varname></primary>
 	</indexterm>

 	<para>De <varname>vm.swap_idle_enabled</varname> sysctl
	  variabele is nuttig in grote multi-user systemen met veel
	  gebruikers die in- en uitloggen en veel onbenutte processen.
	  Dergelijke systemen hebben de neiging om voortdurend de vrije
	  geheugenreserves onder druk te zetten.  Het is mogelijk om de
	  prioriteit van geheugenpages die verband houden met onbenutte
	  processen sneller te laten dalen dan met het normale pageout
	  algoritme, door deze sysctl aan te zetten en via
	  <varname>vm.swap_idle_threshold1</varname> en
	  <varname>vm.swap_idle_threshold2</varname> de swapout
	  hysterese (in seconden onbenut) af te stemmen.  Gebruik deze
	  optie alleen wanneer nodig, want de andere kant van de
	  medaille is dat dit eerder pre-page geheugen inhoudt in plaats
	  van later, waardoor het meer swap en schijfbandbreedte kost.
	  In een klein systeem heeft deze optie een voorspelbaar effect
	  maar in grote systemen waar al sprake is van een matige paging
	  kan deze optie het mogelijk maken voor het VM systeem om
	  gehele processen gemakkelijk in en uit het geheugen te
	  halen.</para>
	</sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>Ten tijde van &os;&nbsp;4.3 is er geflirt met het
	  uitzetten van IDE schrijfcaching.  Hierdoor neemt de
	  bandbraadte naar IDE schijven af maar het werd als
	  noodzakelijk beschouwd vanwege ernstige problemen met data
	  inconsistentie die door harddisk producenten
	  ge&euml;introduceerd waren.  Het probleem is dat IDE schijven
	  niet de waarheid vertellen over wanneer een schrijfactie
	  klaar is.  Door IDE schrijfcaching wordt data niet alleen
	  ongeorderd geschreven, maar soms kan zelfs het schrijven van
	  sommige blokken voortdurend uitgesteld worden als er sprake
	  is van een hoge disk load.  Een crash of stroomstoring kan
	  dan ernstige corruptie van het bestandssysteem veroorzaken.
	  &os;'s standaard installing werd daarom voor alle zekerheid
	  gewijzigd.  Helaas was het resultaat een groot verlies aan
	  performance en na die release is de standaardwaarde weer
	  terugveranderd.  Met de <varname>hw.ata.wc</varname> sysctl
	  variabele kun je controleren of schrijfcaching aan of uit
	  staat op jouw styteem.  Als schrijfcaching uitstaat, kun je
	  het aan zetten door <varname>hw.ata.wc</varname> naar 1 te
	  zetten.  Aangezien dit een kernelvariabele is, moet deze gezet
	  worden vanuit de boot loader tijdens het opstarten.  Nadat de
	  kernel eenmaal opgestart is, heeft het wijzigen van deze
	  sysctl geen effect.</para>

	<para>Voor meer informatie, zie de &man.ata.4; hadleiding.</para>
      </sect3>

      <sect3>
	<title><option>SCSI_DELAY</option>
	(<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm>
	  <primary><option>SCSI_DELAY</option></primary>
	  <secondary><varname>kern.cam.scsi_delay</varname></secondary>
	</indexterm>

	<para>De <option>SCSI_DELAY</option> kernel configuratie optie
	  kan worden gebruikt om de opstarttijd te versnellen.  De
	  standaard waarde is nogal hoog en kan <literal>15+</literal>
	  seconden vertraging veroorzaken.  Met modernere SCSI systemen
	  zal iets als <literal>5</literal> seconden al voldoende zijn.
	  Nieuwere versies van &os; (5.0+) gebruiken de opstartvariabele
	  <varname>kern.cam.scsi_delay</varname>.  Zowel deze als de
	  <option>SCSI_DELAY</option> optie gebruiken waarden uitgedrukt
	  in <emphasis>milliseconden</emphasis> en
	  <emphasis>niet</emphasis> <emphasis>seconden</emphasis>.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Softupdates</title>

      <indexterm><primary>Softupdates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Het &man.tunefs.8; programma kan worden gebruikt om een
	bestandsysteem nauwkeurig afstemmen.  het heeft veel
	verschillende opties, maar voor nu hebben we alleen interesse
	in het aan- en uitzetten van softupdates en dat gaat als
	volgt:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Een bestandssysteem  kan niet met &man.tunefs.8; worden
	gewijzigd als het gemount is.  Softupdates aanzetten zul je dan
	ook in het algemeen vanuit single-user modus doen, voordat
	partities aangekoppeld zijn.</para>

      <note><para>Vanaf &os;&nbsp;4.5, is het mogelijk om softupdates
	aan te zetten op het moment dat de bestandssystemen aangemaakt
	worden, door middel van de <literal>-U</literal> optie van
	&man.newfs.8;.</para></note>

      <para>Softupdates zorgen voor een drastische verbetering van de
	meta-data performance, met name het aanmaken en verwijderen van
	bestanden, door gebruik van een geheugencache.  Het wordt dan
	ook aangeraden om op al je bestandssystemen softupdates te
	gebruiken.  Er zijn twee nadelen aan softupdates waarvan je je
	bewust moet zijn: Ten eerste, softupdates garandeert een
	consistent bestandssysteem in geval van een crash maar het
	kan makkelijk enkele seconden (zelfs een minuut!) achterliggen
	met het daadwerkelijk bijwerken op de fysieke harde schijf.
	Als je systeem crasht verlies je wellicht meer werk dan anders
	het geval zou zijn.  Ten tweede, softupdates vertraagt het
	vrijgeven van bestandssysteemblokken.  Als je een
	bestandssysteem hebt (zoals op de root partitie) dat bijna vol
	is, dan kan het verrichten van een grote update, zoals
	<command>make installworld</command>, ertoe leiden dat het
	bestandssysteem ruimtegebrek krijgt en dat daardoor de operatie
	mislukt.</para>

      <sect3>
	<title>Meer details over softupdates</title>

	<indexterm>
	  <primary>Softupdates</primary>
	  <secondary>details</secondary>
	</indexterm>

	<para>Er zijn traditioneel twee methodes om de metadata van een
	  bestandssysteem terug naar de schijf te schrijven.  Het
	  bijwerken van metadata houdt in het bijwerken van van
	  niet-inhoudelijke data zoals inodes of directories.</para>

	<para>Historisch gezien was het gebruikelijk om metadata updates
	  synchroon weg te schrijven.  Als bijvoorbeeld een directory
	  gewijzigd was, wachtte het systeem totdat de verandering
	  daadwerkelijk naar de schijf geschreven was.  De databuffers
	  (de inhoud van een bestand) werden doorgeschoven naar de
	  buffer cache en op een later moment asynchroon op de schijf
	  opgeslagen.  Het voordeel van deze benadering is dat ze altijd
	  veilig is.  Als het systeem faalt tijdens een update is de
	  metadata nog altijd consistent.  Een bestand kan volledig
	  gecre&euml;erd zijn, of helemaal niet.  Als de datablokken
	  van een bestand nog niet van de buffer cache naar
	  de schijf geschreven zijn ten tijde van de crash, is
	  &man.fsck.8; in staat om dit te herkennen en het
	  bestandssysteem te repareren door de lengte van het bestand
	  nul te maken.  Ook is deze implementatie helder en eenvoudig.
	  Het nadeel is echter dat het wijzigen van metadata een traag
	  proces is.  Een <command>rm -r</command> commando,
	  bijvoorbeeld, benadert alle bestanden in een directory
	  sequenti&euml;el, maar elke directory verandering (verwijderen
	  van een bestand) wordt synchroon naar de schijf geschreven.
	  Dit houdt ook in het bijwerken van de directory zelf, van de
	  inodetabel en mogelijk ook van indirecte blokken gealloceerd
	  door het bestand in kwestie.  Gelijksoortige overwegingen kan
	  men maken bij een commando als <command>tar -x</command>
	  waarbij een grote bestandshi&euml;earchie wordt
	  uitgepakt.</para>

	<para>De tweede mogelijkheid is om metadata updates asynchroon
	  weg te schrijven.  Dit is standaard in Linux/ext2fs en als
	  een *BSD ufs bestandssysteem met
	  <command>mount -o async</command> aangekoppeld is, is de
	  werking hetzelfde.  Alle bijwerkingen aan metadata wordt
	  eenvoudigweg doorgegeven aan de buffer cache en vermengd met
	  inhoudelijke updates van de bestandsdata.  Het voordeel is
	  een grote winst aan snelheid, omdat er niet telkens gewacht
	  hoeft te worden op elke bijwerking aan metadata tot deze
	  daadwerkelijk naar de schijf geschreven is.  De implementatie
	  is ook in dit geval helder en eenvoudig.  Het grote nadeel is
	  uiteraard dat er geen enkele garantie is voor de consistentie
	  van het bestandssysteem.  Als het systeem faalt tijdens een
	  operatie waarbij veel metadata wordt bijgewerkt (bijvoorbeeld
	  door een stroomstoring of iemand drukt op de resetknop),
	  blijft het bestandssysteem in een onvoorspelbare toestand
	  achter.  Er is geen mogelijkheid om de toestand van het
	  bestandssysteem te onderzoeken als het systeem weer opstart,
	  want de datablokken van een bestand kunnen al weggeschreven
	  zijn geweest terwijl het wegschrijven van bijwerkingen aan de
	  inodetabel of de bijhorende directory nog niet plaats heeft
	  gevonden.  Het is zelfs onmogelijk om een
	  <command>fsck</command> te implementeren die de overgebleven
	  chaos kan opruimen; de benodigde informatie is gewoon niet
	  volledig aanwezig op de schijf.  Als een bestandssysteem op
	  deze manier onherstelbaar beschadigd is, is je enige optie
	  &man.newfs.8; te gebruiken en vervolgens te herstellen van een
	  backup.</para>

	<para>De gebruikelijke oplossing voor dit probleem is het
	  implementeren van <emphasis>dirty region logging</emphasis>,
	  ook wel <emphasis>journaling</emphasis> genoemd, hoewel deze
	  term niet consistent gebruikt wordt en soms ook wordt gebruikt
	  voor andere vormen van transactie logging.  Metadata updates
	  worden nog steeds synchroon geschreven, maar slechts naar een
	  klein gebied van de schijf.  Later worden ze dan naar de
	  juiste locatie verplaatst.  Omdat het loggebied klein is,
	  hoeven de koppen van de schijf zelfs tijdens
	  schrijfintensieve operaties nog maar over een kleine fysieke
	  afstand te bewegen en door deze snellere respons zijn dit
	  soort operaties sneller dan op de traditionele manier.  De
	  extra complexiteit van de implementatie is nogal beperkt, dus
	  het risico van introductie van extra bugs valt wel mee.  Een
	  nadeel is dat alle metadata tweemaal geschreven wordt (eerst
	  naar het loggebied en later nog eens naar de eindlocatie) dus
	  bij normaal gebruik kan er sprake zijn van wat men wel noemt
	  een performance <quote>pessimization</quote>.  Anderzijds, in
	  geval van een crash kunnen alle nog uitstaande metadata
	  operaties snel worden teruggedraaid of vanuit het loggebied
	  alsnog worden afgemaakt, wanneer de machine weer opstart.  Het
	  bestandssysteem zal dan snel opgestart zijn.</para>

	<para>Kirk McKusick, de vader van het Berkeley FFS, loste dit
	  probleem op met softupdates, wat betekent dat alle uitstaande
	  metadata updates in het geheugen bewaard worden en dan
	  geordend achtereenvolgens naar de schijf geschreven worden.
	  Dit heeft het gevolg dat in geval van intensieve metadata
	  operaties latere bijwerkingen aan een item eerdere bewerkingen
	  opvangen (<quote>catch</quote>) als deze nog in het geheugen
	  zitten en nog niet weggeschreven waren.  Dus alle operaties
	  op, zeg, een directory worden in het algemeen eerst in het
	  geheugen uitgevoerd voordat de updates naar de schijf
	  geschreven worden.  De databloks worden geordend conform hun
	  positie zodat ze nooit weggeschreven worden voordat hun
	  metadata geschreven is.  Als het systeem een crash
	  ondervindt, veroorzaakt dat een impliciet het terugdraaien
	  van uitstaande operaties (<quote>log rewind</quote>): Alle
	  operaties die nog niet weggeschreven waren lijken nooit
	  gebeurd te zijn.  Er wordt zo een consistent bestandssysteem
	  in stand gehouden dat er uit ziet als was het 30 tot 60
	  seconden eerder.  Het gebruikte algoritme garandeert dat alle
	  bronnen die in gebruik zijn als zodanig gemarkeerd worden in
	  hun daarvoor geschikte bitmaps: blokken en inodes.  Na een
	  crash is de enige allocatiefout die kan optreden dat bronnen
	  gemarkeerd kunnen zijn als in gebruik (<quote>used</quote>)
	  terwijl ze feitelijk alweer beschikbaar (<quote>free</quote>)
	  zijn.  &man.fsck.8; herkent deze situatie en stelt dergelijke
	  vrij te maken bronnen opnieuw beschikbaar.  Het is volkomen
	  veilig om na een crash te negeren dat het bestandssysteem niet
	  schoon is en het tot aankoppelen te dwingen met
	  <command>mount -f</command>.  Om niet langer in gebruik zijnde
	  bronnen vrij te maken moet later &man.fsck.8; uitgevoerd
	  worden.  Dit is dan ook het idee achter
	  <emphasis>background fsck</emphasis>: Op het moment dat het
	  systeem aan het opstarten is, wordt er alleen een
	  <emphasis>snapshot</emphasis> van het systeem bewaard.  Het
	  commando <command>fsck</command> kan later uitgevoerd worden.
	  Alle bestandssystemen kunnen <quote>dirty</quote> gemount
	  worden en het systeem kan gewoon verder opstarten naar
	  multiuser modus.  Vervolgens zijn er <command>fsck</command>s
	  gepland die in de achtergrond draaien voor elk bestandssysteem
	  dat niet schoon is en waarmee bezette bronnen vrijgegeven
	  worden.  Bestandssystemen die geen gebruik maken van
	  softupdates moeten echter nog steeds gebruik maken van de
	  normale <command>fsck</command> in de voorgrond.</para>

	 <para>Het voordeel van softupdates is dat metadata operaties
	   bijna net zo snel zijn als asynchrone updates (d.w.z. sneller
	   dan met <emphasis>logging</emphasis>, waarbij de metadata
	   tweemaal geschreven wordt).  Nadelen zijn de complexiteit van
	   de code (wat een groter risico van bugs impliceert in een
	   gebied dat bijzonder gevoelig is voor wat betreft verlies van
	   gebruikersdata) en een groter geheugenverbruik.  Tevens moet
	   de gebruiker wennen aan enkele eigenaardigheden.  Na een
	   crash lijkt de toestand van het bestandssysteem wat
	   <quote>ouder</quote>.  In situaties waar de standaard
	   synchrone benadering een aantal lege bestanden zou hebben
	   achtergelaten na <command>fsck</command>, is het met
	   softupdates juist zo dat dergelijke bestanden er helemaal
	   niet zijn, omdat noch de metadata noch de bestandsinhoud
	   ooit naar de schijf is geschreven.  Schijfruimte wordt pas
	   vrijgegeven als de bijwerkingen aan metadata en inhoudelijke
	   bestandsdata weggeschreven zijn, wat mogelijk pas enige tijd
	   na het uitvoeren van <command>rm</command> plaatsvindt.  Dit
	   kan problemen veroorzaken als er grote hoeveelheden data
	   naar een bestandssysteem geschreven wordt dat onvoldoende
	   vrije ruimte heeft om alle bestanden tweemaal te kunnen
	   bevatten (bijvoorbeeld in <filename>/tmp</filename>).</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Fijnafstemming van kernellimieten</title>

    <indexterm>
      <primary>fijnafstemming</primary>
      <secondary>kernellimieten</secondary>
    </indexterm>

    <sect2 id="file-process-limits">
      <title>Bestands-proceslimieten</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>

	<para><varname>kern.maxfiles</varname> kan worden verhoogd of
	  verlaagd, afhankelijk van de systeembehoeften.  Deze variabele
	  geeft het maximale aantal bestandsbeschrijvingen op je systeem.
	  Als de bestandsbeschrijvingstabel vol is zal de systeembuffer
	  meerdere malen <errorname>file: table is full</errorname>
	  tonen, hetgeen je kunt zien met het <command>dmesg</command>
	  commando.</para>

	<para>Elk geopend bestand, socket, of fifo heeft een
	  bestandsbeschrijving (file descriptor).  Een grote
	  produktieserver kan makkelijk enige duizenden
	  bestandsbeschrijvingen nodig hebben, afhankelijk van het soort
	  en aantal services die tegelijk draaien.</para>

	<para><varname>kern.maxfiles</varname>'s standaardwaarde wordt
	  bepaald door de <option>MAXUSERS</option> optie in je kernel
	  configuratiebestand.  <varname>kern.maxfiles</varname> groeit
	  evenredig met de waarde van <option>MAXUSERS</option>.  Als
	  je een eigen kernel bouwt is het een goed idee om deze kernel
	  optie in te stellen volgens het aantal systeemgebruikers (maar
	  niet te laag).  Hoewel een produktieserver misschien niet 256
	  eens gebruikers tegelijk met zich verbonden heeft kunnen de
	  benodigde systeembronnen best vergelijkbaar zijn met een
	  grootschalige webserver.</para>

	<note><para>Vanaf &os;&nbsp;4.5, kun je meestal het beste
	  <option>MAXUSERS</option> naar <literal>0</literal> zetten in
	  je kernel configuratiebestand.  Er wordt dan een redelijke
	  waarde gekozen gebaseerd op de hoeveelheid RAM in het
	  systeem.</para></note>

      </sect3>

      <sect3>
	<title><varname>kern.ipc.somaxconn</varname></title>

	<indexterm>
	  <primary><varname>kern.ipc.somaxconn</varname></primary>
	</indexterm>

	<para>De <varname>kern.ipc.somaxconn</varname> sysctl variabele
	  beparkt de grootte van de luisterwachtrij voor het accepteren
	  van nieuwe TCP verbindingen.  De standaardwaarde van
	  <literal>128</literal> is typisch te laag voor robuuste
	  behandeling van nieuwe verbindingen in een zwaarbeladen
	  webserver omgeving.  Voor zulke omgevingen wordt aangeraden
	  deze waarde te verhogen tot <literal>1024</literal> of hoger.
	  De service daemon zal misschien zelf de luisterwachtrij
	  beperken (bijv. &man.sendmail.8;, of
	  <application>Apache</application>) maar zal vaak een
	  mogelijkheid in haar configuratiebestand hebben om de
	  wachtrijgrootte aan te passen.  Grote luisterwachtrijen zijn
	  ook beter in het afwenden van Denial Of Service
	  (<abbrev>DoS</abbrev>) aanvallen.</para>
      </sect3>

    </sect2>
    <sect2>
      <title>Networkbeperkingen</title>

      <para>De <option>NMBCLUSTERS</option> kernel configuratie
	optie bepaalt het aantal netwerk Mbufs dat beschikbaar is voor
	het systeem.  Een veel bezochte server met een laag aantal
	Mbufs zal &os;'s mogelijkheden beperken.  Elk cluster staat voor
	ongeveer 2&nbsp;K geheugen dus een waarde van 1024 stelt 2
	megabytes aan kernel geheugen voor, gereserveerd voor
	netwerkbuffers.  Met een simpele berekening kun je nagaan
	hoeveel je er nodig hebt.  Als je een webserver met een maximum
	van 1000 simultane verbindingen en elke verbinding kost je
	16&nbsp;K aan ontvangst netwerkbuffers en 16&nbsp;K aan
	zendbuffers, dan heb je ongeveer 32&nbsp;MB aan netbuffers nodig
	voor de webserver.  Een goede vuistregel is te vermeniguldigen
	met twee, dus 2x32&nbsp;MB&nbsp;/&nbsp;2&nbsp;KB&nbsp;=
	64&nbsp;MB&nbsp;/&nbsp;2&nbsp;kB&nbsp;= 32768.  Voor machines
	met veel geheugen wordt 4096 tot 32768 aangeraden.  Je moet in
	geen geval een arbitrair hoge waarde voor deze sysctl opgeven,
	want dat kan leiden tot een crash tijdens het opstarten.  De
	<option>-m</option> optie van &man.netstat.1; kan gebruikt
	worden om netwerk clustergebruik te observeren.</para>

      <para>De <varname>kern.ipc.nmbclusters</varname> loader parameter
	moet gebruikt worden om dir tijdens het opstarten toe te passen.
	Alleen voor oudere versies van &os; is het nodig om de
	<option>NMBCLUSTERS</option> kernel &man.config.8; optie te
	gebruiken.</para>

      <para>Voor drukke servers die extensief gebruik maken van de
	&man.sendfile.2; systeemaanroep, kan het nodig zijn het aantal
	&man.sendfile.2; buffers via de
	<option>NSFBUFS</option> kernel configuratie optie of door deze
	waarde te zetten in <filename>/boot/loader.conf</filename>
	(zie &man.loader.8; voor details).  Een algemene indicator dat
	deze parameter aangepast moet worden is als je processen ziet
	die in de <errorname>sfbufa</errorname> status zijn.  De sysctl
	variabele <varname>kern.ipc.nsfbufs</varname> is alleen-lezen en
	laat zien op welke waarde deze kernelvariabele is ingesteld.
	Deze parameter schaalt engiszins met de
	<varname>kern.maxusers</varname> variabele, maar het kan nodig
	zijn om deze bij te stellen.</para>

      <important>
	<para>Zelfs als een socket als non-blocking gemarkeerd is, dan
	  nog kan het aanroepen van &man.sendfile.2; op het
	  non-blocking socket ertoe leiden dat er toch blokkade optreedt
	  totdat er voldoende <literal>struct sf_buf</literal>'s
	  vrijgemaakt zijn.</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm>
	  <primary>net.inet.ip.portrange.*</primary>
	</indexterm>

	<para>De <varname>net.inet.ip.portrange.*</varname> sysctl
	  variabelen bepalen welk bereik van poortnummers automatisch
	  gebonden worden aan TCP en UDP sockets.  Er zijn drie
	  gebieden: een laag gebied, een midden (standaard) gebied en
	  een hoog gebied.  De meeste netwerkprogramma's gebruiken het
	  standaardbereik, wat begrensd wordt door
	  <varname>net.inet.ip.portrange.first</varname> en
	  <varname>net.inet.ip.portrange.last</varname> met
	  standaardwaarden van respectievelijk 1024 en 5000.  Gebonden
	  poortbereiken worden gebruikt voor uitgaande verbindingen en
	  het is onder bepaalde omstandigheden mogelijk dat poorten
	  opraken.  Dit gebeurt meestal in het geval van een zwaar
	  belaste webproxy.  Poortbereik is niet van belang als vooral
	  services draaien die zich vooral bezighouden met inkomende
	  verbindingen, zoals een normale webserver, of als het aantal
	  uitgaande verbindingen beperkt is zoals bij een mailrelay.
	  Voor situaties waarin een tekort aan poorten dreigt, wordt
	  aangeraden om <varname>net.inet.ip.portrange.last</varname>
	  bescheiden op te hogen.  Een waarde van
	  <literal>10000</literal>, <literal>20000</literal> of
	  <literal>30000</literal> is redelijk.  Hou ook rekening met
	  effecten voor wat betreft firewalls als je poortbereiken gaat
	  wijzigen.  Sommige firewalls kunnen grote poortgebieden
	  blokkeren, meestal de lagere poorten, en verwachten dat
	  andere systemen hogere poorten gebruiken voor uitgaande
	  verbindingen &mdash; om deze reden wordt het aanbevolen om
	  <varname>net.inet.ip.portrange.first</varname> te
	  verlagen.</para>
      </sect3>

      <sect3>
	<title>TCP bandbreedte vertragingsprodukt</title>

	<indexterm>
	  <primary>TCP bandbreedte vertragingsprodukt</primary>
	  <secondary><varname>net.inet.tcp.inflight_enable</varname></secondary>
	</indexterm>

	<para>De TCP bandbreedte vertragingsprodukt limitatie lijkt op
	  TCP/Vegas in <application>NetBSD</application>.  Het kan aangezet
	  worden door de <varname>net.inet.tcp.inflight_enable</varname>
	  sysctl variabele de waarde <literal>1</literal> te geven.  Het
	  systeem zal dan het bandbreedte vertragingssprodukt trachten te
	  berekenen voor elke verbinding en dan de hoeveelheid data in
	  de wachtrij naar het netwerk beperken tot de hoeveelheid die
	  vereist is om maximale doorvoer te kunnen handhaven.</para>

	<para>Dit is nuttig bij gebruik van modems, Gigabit Ethernet, of
	  zelfs bij hoge snelheid WAN links (of elke andere link met een
	  groot bandbreedte vertragingsprodukt), in het bijzonder als je
	  ook windowschaling gebruikt of een groot verzendwindow
	  gebruikt.  Als je deze optie aanzet, denk er dan ook aan om
	  <varname>net.inet.tcp.inflight_debug</varname> de waarde
	  <literal>0</literal> te geven (geen debugging) en voor
	  produktiegebruik zou ook het zetten van
	  <varname>net.inet.tcp.inflight_min</varname> naar minstens
	  <literal>6144</literal> voordeel kunnen opleveren.  Merk
	  echter op dat het instellen van hoge minima effectief enig
	  beperken van bandbreedte kan ondermijnen, afhankelijk van de
	  link.  De mogelijkheid tot limitatie zorgt ervoor dat de
	  hoeveelheid data die opgebouwd wordt in tussentijdse route- en
	  switchwachtrijen verlaagd kan worden en tevens kan de
	  hoeveelheid data die opgebouwd wordt in de interfacewachtrij
	  van de lokale host verlaagd worden.  Met minder pakketten in
	  wachtrijen kunnen interactieve verbindingen opereren met
	  lagere <emphasis>Round Trip</emphasis> tijden, met name over
	  langzame modems.  Merk echter op dat deze optie alleen over
	  datatransmissie (uploading / serverkant) gaat en geen effect
	  heeft op dataontvangst (downloading / clientkant).</para>

	<para>Aanpassen van <varname>net.inet.tcp.inflight_stab</varname>
	  wordt <emphasis>niet</emphasis> aangeraden.  Deze parameter
	  krijgt standaard een waarde van 20, hetgeen 2 maximale
	  pakketten opgeteld bij de bandbreedte windowberekening
	  representeert.  Het extra window is nodig om het algoritme
	  stabiel te houden en om de response bij veranderende
	  omstandigheden te verbeteren, maar het kan ook leiden tot
	  langere pingtijden over langzame verbindingen (zonder het
	  inflight algoritme zou dit echter nog erger zijn).  In
	  dergelijke gevallen kun je misschien deze parameter verlagen
	  naar 15, 10 of 5 en misschien moet voor het gewenste effect
	  ook <varname>net.inet.tcp.inflight_min</varname> verlaagd
	  worden (bijvoorbeeld naar 3500).  Het verlagen van deze
	  parameters moet pas in laatste instantie overwogen
	  worden.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Swapruimte toevoegen</title>

    <para>Je kunt nog zo goed plannen, soms draait een systeem gewoon
      niet zoals verwacht.  Een oorzaak hiervoor kan zijn een tekort aan
      swapruimte.  Als blijkt dat er meer swapruimte nodig is, is dit
      eenvoudig te realiseren.  Er zijn drie manieren om de totale
      ruimte beschikbaar als wisselbestand te vergroten: Een nieuwe
      harde schijf toevoegen, swappen over NFS, of een swapbestand maken
      op een bestaande (UFS of anderzijds) partitie.</para>

    <sect2 id="new-drive-swap">
      <title>Wisselbestand (partitie) op een nieuwe harde schijf</title>

      <para>Dit is natuurlijk de beste manier om de swap te vergroten en
	een goed excuus om een extra harde schijf toe te voegen.  Die
	komt immers altijd wel van pas.  In dat geval kun je het beste
	de discussie over <ulink
	url="configtuning-initial.html#SWAP-DESIGN">swapruimte</ulink>
	uit het onderdeel <ulink
	url="configtuning-initial.html">Initi&euml;le configuratie</ulink>
	uit dit handboek nog eens herlezen om wat suggesties te krijgen
	over hoe je het beste je wisselpartitie(s) kunt regelen.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Swappen over NFS</title>

      <para>In het algemeen wordt swappen over NFS niet aangeraden
	omdat het langzaam is.  Overweeg dit alleen als het onmogelijk
	is om naar een lokale schijf te swappen.  In &os; versies voor
	4.X was het hanteren van een wisselbestand over NFS erg langzaam
	en ineffici&euml;nt.  Nieuwere versies werken beter, maar dan
	nog wordt swappen over NFS sterk gelimiteerd door de aanwezige
	netwerkbandbreedte en het zal de NFS server extra
	belasten.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>Swapbestanden</title>

      <para>Het is mogelijk om een bestand aan te maken van een bepaalde
	grootte en dit als swap te gebruiken.  In dit voorbeeld zullen
	we een 64MB bestand gebruiken, <filename>/usr/swap0</filename>.
	Uiteraard kan een willekeurige naam gebruikt worden.</para>

      <example>
	<title>Een wisselbestand aanmaken met &os; 4.X</title>

      <orderedlist>
	 <listitem>
	   <para>Zorg ervoor dat je kernel het vnode stuurprogramma
	     bevat.  In recente versies van <filename>GENERIC</filename>
	     is vnode <emphasis>niet</emphasis> inbegrepen.</para>

	   <programlisting>pseudo-device vn   #Vnode driver (turns a file into a device)</programlisting>
	 </listitem>

	<listitem>
	  <para>Een vn-apparaat aanmaken:</para>
          <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Een swapbestand aanmaken
	    (<filename>/usr/swap0</filename>):</para>

          <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	</listitem>

	<listitem>
	  <para>Correcte permissies op (<filename>/usr/swap0</filename>)
	     zetten:</para>

          <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Wisselbestand opnemen in
	    <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	</listitem>

	<listitem>
	   <para>Herstart de machine of om het wisselbestand meteen aan
	     te zetten, voer in:</para>

           <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
	 </listitem>
      </orderedlist>

      </example>
      <example>
	<title>Een wisselbestand aanmaken met &os; 5.X</title>

      <orderedlist>
	<listitem>
	  <para>Ga na dat je kernel het stuurprogramma voor de
	    geheugendisk (&man.md.4;) bevat.  Het is standaard in de
	    <filename>GENERIC</filename> kernel.</para>

	  <programlisting>device md   # Memory "disks"</programlisting>
	</listitem>

	<listitem>
	  <para>Maak een swapbestand aan
	    (<filename>/usr/swap0</filename>):</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	</listitem>

	<listitem>
	  <para>Zet correctie permissies op
	    (<filename>/usr/swap0</filename>):</para>

	  <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Neem het swapbestand op in
	    <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	</listitem>

	<listitem>
	  <para>Herstart de machine of om het wisselbestand direct in te
	    schakelen:</para>

          <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 && swapon /dev/md0</userinput></screen>
	 </listitem>
      </orderedlist>

      </example>
    </sect2>
  </sect1>

  <sect1 id="acpi-overview">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Hiten</firstname>
	  <surname>Pandya</surname>
	  <contrib>Geschreven door </contrib>
	</author>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>Vermogen- en bronnenbeheer</title>

    <para>Het is belangrijk om hardwarebronnen op een effici&euml;nte
      wijze te benutten.  Voordat <acronym>ACPI</acronym>
      ge&iuml;ntroduceerd werd was het erg lastig en onflexibel
      om het vermogensverbruik en de thermische eigenschappen van een
      systeem te beheersen.  De hardware werd beheerst door deze of gene
      interface, ingebed in het <acronym>BIOS</acronym>, zoals de
      <emphasis>Plug-n-play BIOS (PNPBIOS)</emphasis> of
      <emphasis>Advanced Power Management (APM)</emphasis>, etc.
      Vermogens- en bronnenbeheer is een kerntaak van moderne
      besturingssystemen.  Je zult bijvoorbeeld willen dat het
      besturingssysteem systeemlimieten in de gaten houdt (en mogelijk
      een SMS stuurt o.i.d.) als de systeemtemperatuur onverwacht
      toeneemt.</para>

    <para>In dit deel van het &os; handboek wordt uitgebreide informatie
      verschaft over <acronym>ACPI</acronym>.  Aan het einde vindt je
      referenties naar meer leesmateriaal.  Merk op dat
      <acronym>ACPI</acronym> op &os;&nbsp;5.X en nieuwere systemen als
      een standaard ingeladen kernelmodule aanwezig is.  Met
      &os;&nbsp;4.9 kun je <acronym>ACPI</acronym> aanzetten door de
      regel <literal>device acpi</literal> toe te voegen aan je kernel
      configuratiebestand en een nieuwe kernel te bouwen en
      installeren.</para>

    <sect2 id="acpi-intro">
      <title>Wat is ACPI?</title>

      <para>Advanced Configuration and Power Interface
	(<acronym>ACPI</acronym>) is een standaard geschreven door een
	alliantie van producenten met als doel te voorzien in een een
	standaard interface voor hardware bronnen- en vermogensbeheer.
	Een belangrijk element is dat het meer flexibiliteit en
	beheersmogelijkheden biedt aan het besturingssysteem
	(<acronym>OS</acronym>).  Moderne systemen hebben de limieten van
	de huidige PNP interfaces verder opgerekt dan wenselijk en
	misschien wel mogelijk was.  <acronym>ACPI</acronym> is de
	directe opvolger van <acronym>APM</acronym>
	(Advanced Power Management).  Centraal is het verleggen van
	hardwarebeheer en -monitoring naar de OS laag i.p.v. de zeer
	beperkte BIOS laag.</para>
    </sect2>

    <sect2 id="acpi-old-spec">
      <title>Tekortkomingen van APM</title>

      <para>Met de <emphasis>Advanced Power Management (APM)</emphasis>
	faciliteit kan het stroomverbruik van een systeem geregeld
	worden op basis van de systeemactiviteit.  Het APM BIOS wordt
	geleverd door de systeemproducent of -verkoper en het is
	specifiek voor dat betreffende hardware platform.  Een APM
	stuurprogramma in het besturingssysteem regelt vervolgens de
	toegang tot de <emphasis>APM Software Interface</emphasis>, die
	het besturen van vermogensniveau mogelijk maakt.</para>

      <para>Er zijn vier hoofdproblemen met APM te onderscheiden: Ten
	eerste wordt het vermogensbeheer verricht door een BIOS
	(afhankelijk van producent) en het besturingssysteem heeft daar
	geen kennis van.  Een voorbeeld hiervan is als de gebruiker
	idle-time waarden zet voor een harde schijf in het APM BIOS;
	dan zal het BIOS de harde schijf langzamer kunnen katen draaien
	zonder dat het besturingssysteem die noodzaak ziet of goedkeurt.
	Ten tweede, de APM logica is ingebed in het BIOS, waardoor het
	opereert buiten het besturingssysteem om.  Dit houdt in dat
	gebruikers problemen met hun APM BIOS alleen kunnen verhelpen
	door een nieuw BIOS in het ROM te flashen, hetgeen een
	gevaarlijke en mogelijk onherstelbare operatie is.  Ten derde is
	er het feit op zich dat APM een producent-specifieke technologie
	is, in de zin dat er altijd een hoge mate van duplicatie zal
	zijn van al dan niet geslaagde pogingen om het wiel te
	heruitvinden en uiteraard ook van bugs.  Er is geen enkele
	garantie dat het wegnemen van een bug door een producent ook
	een zelfde bug weg zal nemen bij een concurrent.  Tenslotte is
	het van belang je te realiseren dat de APM BIOS in het algemeen
	gewoon te weing geheugen kon gebruiken om een ingewikkeld
	vermogensbeheer te kunnen implementeren.  Laat staan dat deze
	goed aanpasbaar kon zijn aan veranderlijke doelstellingen voor
	de betreffende machine.</para>

      <para><emphasis>Plug-n-play BIOS (PNPBIOS)</emphasis> was
	in veel situations onbetrouwbaar.  PNPBIOS is 16-bit
	technologie, dus het besturingssysteem moet 16-bit emulatie
	gebruiken om met PNPBIOS methoden te kunnen interfacen.</para>

      <para>Het &os; <acronym>APM</acronym> stuurprogramma is
	gedocumenteerd in de &man.apm.4; handleiding.</para>
    </sect2>

    <sect2 id="acpi-config">
      <title><acronym>ACPI</acronym> configureren</title>

      <para>Het <filename>acpi.ko</filename> stuurprogramma wordt
	standaard geladen bij het opstarten door de &man.loader.8;
	en hoeft <emphasis>niet</emphasis> gecompileerd te worden.
	De redenatie is dat er met modules gemakkelijker gewerkt kan
	worden, bijvoorbeeld een andere <filename>acpi.ko</filename>
	gebruiken zonder dat er een nieuwe kernel gebouwd moet worden.
	Dit heeft het voordeel dat testen eenvoudiger is.  Een andere
	reden is dat het opstarten van <acronym>ACPI</acronym> nadat een
	systeem eenmaal volledig opgestart is, weinig nuttig is en in
	sommige gevallen fataal kan zijn.  In geval van tijfel kun je
	beter <acronym>ACPI</acronym> helemaal uitzetten.  Dit
	stuurprogramma kan niet gestopt worden als het eenmaal geladen
	is, omdat de systeembus het gebruikt voor allerlei
	interacties met hardware.  <acronym>ACPI</acronym> kan uitgezet
	worden met de &man.acpiconf.8; utility.  In feite kan de meeste
	interactie met het <acronym>ACPI</acronym> systeem gedaan worden
	via &man.acpiconf.8;.  In wezen betekent dit alles dat als er
	iets over <acronym>ACPI</acronym> in &man.dmesg.8; staat, dat
	het hoogstwaarschijnlijk al draait.</para>

      <note><para><acronym>ACPI</acronym> en <acronym>APM</acronym>
	kunnen niet samenleven en moeten afzonderlijk en exclusief
	gebruikt worden.  De laatste die gestart wordt bepaalt of het
	stuurprogramma de ander wel of niet ziet.</para></note>

      <para>In haar eenvoudigste vorm kan <acronym>ACPI</acronym> worden
	gebruikt om het systeem in slaapmodus te zetten met de
	<option>-s</option> vlag een <literal>1-5</literal> optie op
	&man.acpiconf.8;.  De meeste gebruikers hebben alleen
	<literal>1</literal> nodig; de optie <literal>5</literal> al een
	"soft-off" verrichten, wat hetzelfde is als:</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>

      <para>Andere opties zijn mogelijk.  Zie de &man.acpiconf.8;
	handleiding voor meer informatie.</para>
    </sect2>
  </sect1>

  <sect1 id="ACPI-debug">
    <sect1info>
      <authorgroup>
	 <author>
	   <firstname>Nate</firstname>
	   <surname>Lawson</surname>
	   <contrib>Geschreven door </contrib>
	 </author>
      </authorgroup>
      <authorgroup>
	 <author>
	   <firstname>Peter</firstname>
	   <surname>Schultz</surname>
	   <contrib>Met medewerking van </contrib>
	 </author>
      </authorgroup>
      <authorgroup>
	 <author>
	   <firstname>Tom</firstname>
	   <surname>Rhodes</surname>
	   <contrib>en </contrib>
	 </author>
      </authorgroup>
    </sect1info>

    <title>Gebruiken en debuggen van &os; <acronym>ACPI</acronym></title>

    <para><acronym>ACPI</acronym> is een totaal nieuwe manier om
      apparaten te ontdekken, om stroomverbruik te beheren en om een
      gestandaardiseerde toegang te bieden tot allerlei apparaten die
      eerder via het <acronym>BIOS</acronym> beheerd werden.  Er wordt
      voortdurend vooruitgang geboekt om <acronym>ACPI</acronym> op alle
      systemen te laten werken, maar bugs in de <acronym>AML</acronym>
      bytecode van sommige moederborden, onvolledigheden in &os;'s
      kernel subsystemen en bugs in de Intel <acronym>ACPI-CA</acronym>
      interpreter blijven opduiken.</para>

    <para>Deze tekst is bedoeld om de &os; <acronym>ACPI</acronym>
      onderhouders te helpen met het vinden van de hoofdoorzaken van
      problemen die worden geobserveerd en met het debuggen en het
      vinden van een oplossing.</para>

    <sect2 id="ACPI-submitdebug">
      <title>Debugging informatie aanbieden</title>

      <para>Voor diegenen die meteen een probleem willen indienen,
	zend dan s.v.p. de volgende informatie naar
	<ulink url="mailto:acpi-jp@jp.FreeBSD.org">
	acpi-jp@jp.FreeBSD.org</ulink></para>

      <itemizedlist>
	<listitem>
	  <para>Omschrijving van het buggy gedrag, inclusief systeem
	    type en model en alles wat de bug kan veroorzaken.  Als het
	    een nieuw fenomeen is, probeer dan ook zo accuraat mogelijk
	    aan te geven wanneer de bug het eerst optrad.</para>
	</listitem>

	<listitem>
	  <para>De dmesg uitvoer van <quote>boot
	    <option>-v</option></quote>, inclusief enige foutmeldingen
	    die gegenereerd worden als de bug optreedt.</para>
	</listitem>

	<listitem>
	  <para>dmesg uitvoer van <quote>boot
	    <option>-v</option></quote> met <acronym>ACPI</acronym>
	    uitgeschakeld, indien het uitzetten van
	    <acronym>ACPI</acronym> het probleem oplost.</para>
	</listitem>

	<listitem>
	  <para>Uitvoer van <quote>sysctl hw.acpi</quote>.  Dit is
	    tevens een goede manier om uit te vinden welke
	    <acronym>ACPI</acronym> mogelijkheden je systeem
	    heeft.</para>
	</listitem>

	<listitem>
	  <para>Een <acronym>URL</acronym> waar je
	    <acronym>ASL</acronym> gevonden kan worden.  Zend de
	    <acronym>ASL</acronym> <emphasis>niet</emphasis>
	    rechtstreeks naar de lijst omdat deze nogal groot kan zijn.
	    Je kunt een kopie van je ASL genereren met dit
	    commando:</para>

	  <screen>&prompt.root; <userinput>acpidump -t -d &gt; $NAME-$SYSTEM.asl</userinput></screen>

	  <para>(Vervang je loginnaam met
	    <filename>$NAME</filename> en producent/model met
	    <filename>$SYSTEM</filename>.  Bijvoorbeeld:
	    <filename>njl-FooCo6000.asl</filename>)</para>
	</listitem>
      </itemizedlist>

      <para>De meeste &os; programmeurs lezen de freebsd-current
	mailinglijst maar stuur problemen s.v.p. ook naar acpi-jp zodat
	ze zeker gezien worden.  Heb alsjeblieft geduld, deze mensen
	hebben elders ook nog fulltime banen.  Als de bug niet meteen
	duidelijk is, zul je waarschijnlijk gevraagd worden om een
	<acronym>PR</acronym> in te dienen via &man.send-pr.1;.  Als je
	een <acronym>PR</acronym> moet opstellen, vermeld dan alle
	hierboven gevraagde informatie.  Dit helpt om het probleem te
	kunnen volgen en oplossen.  Zend s.v.p. geen
	<acronym>PR</acronym> zonder eerst acpi-jp te mailen, aangezien
	men <acronym>PR</acronym>s gebruikt als herinnering, niet als
	rapportagesysteem.  Mogelijk is jouw probleem al eens door
	iemand anders aangemeld.</para>
    </sect2>

    <sect2 id="ACPI-background">
      <title>Achtergrond</title>

      <para><acronym>ACPI</acronym> is aanwezig op alle moderne
	computers die voldoen aan de ia32 (x86), ia64 (Itanium) of
	amd64 (AMD) architecturen.  De volledige standaard heeft vele
	mogelijkheden zoals <acronym>CPU</acronym> performancebeheer,
	vermogenstoevoerbeheer, thermische zones, diverse
	batterijsystemen, ingebedde controllers en busnummering.  De
	meeste systemen implementeren minder dan de volledige standaard.
	Een desktopsysteem, bijvoorbeeld, implementeert normaliter
	alleen het busnummering gedeeelte, terwijl laptops mogelijk
	ook koeling- en batterijbeheer ondersteunen.  Laptops hebben ook
	suspend en resume (slapen en wakker worden) met hun eigen
	aanverwante comlexiteit.</para>

      <para>Een <acronym>ACPI</acronym>-compliant systeem heeft
	verscheidene componenten.  Het <acronym>BIOS</acronym> is de
	eerste en dan zijn er verscheidene gedefineerde tabellen zoals
	<acronym>FADT</acronym> in het geheugen die zaken als de
	<acronym>APIC</acronym> map (gebruikt voor
	<acronym>SMP</acronym>) specificeren, beschikbeer gesteld door
	verschillende producenten/verkopers.  Daarnaast zijn er
	specifieke eenvoudige configuratievariabelen en
	configuratieregisters, ook alle specifiek voor de leverancier.
	Ook wordt er een tabel van bytecode (de
	<acronym>DSDT</acronym>)) geleverd die een boomstructuurachtige
	namespace biedt voor apparaten en apparaatobjectfuncties.</para>

      <para>Het <acronym>ACPI</acronym> stuurprogramma moet de
	voorgedefini&euml;erde tabellen verwerken, een interpreter voor
	de bytecode implementeren en apparaatstuurprogramma's en de
	kernel aanpassen om alleen al informatie van het
	<acronym>ACPI</acronym> subsysteem te kunnen accepteren.  Intel
	heeft een interpreter beschikbaar gesteld
	(<acronym>ACPI-CA</acronym>) die door &os; en ook door Linux en
	NetBSD gebruikt wordt.  De <acronym>ACPI-CA</acronym> broncode
	kun je vinden in
	<filename role="directory">src/sys/contrib/dev/acpica</filename>.
	De "lijmcode" die <acronym>ACPI-CA</acronym> laat werken met
	&os; bevindt zich in
	<filename>src/sys/dev/acpica/Osd</filename>.
	Tenslotte, stuurprogramma's die verscheidene
	<acronym>ACPI</acronym> apparaten implementeren vind je in
	<filename role="directory">src/sys/dev/acpica</filename>.</para>
    </sect2>

    <sect2 id="ACPI-comprob">
      <title>Veel voorkomende problemen</title>

      <para>Wil <acronym>ACPI</acronym> goed werken, dan moeten alle
	onderdelen goed werken.  Hier zijn enkele veel voorkomende problemen
	in volgorde van hoe vaak ze optreden en enkele mogelijke
	oplossingen of manieren om de problemen te vermijden.</para>

      <sect3>
	<title>Suspend/resume</title>

	<para><acronym>ACPI</acronym> heeft drie slaapstanden waarbij
	  het geheugen (<acronym>RAM</acronym>) wordt ingezet.  Dit
	  zijn de <acronym>STR</acronym> toestanden,
	  <literal>S1</literal>-<literal>S3</literal>, en nog een
	  slaap-met-gebruik-van-harde-schijf toestand
	  (<literal>STD</literal>) die <literal>S4</literal> genoemd
	  wordt.  <literal>S5</literal> is <quote>zo ongeveer</quote>
	  en is de normale status van je systeem wanneer ingestoken
	  maar niet aangezet.  <literal>S4</literal> kan feitelijk op
	  twee manieren ge&iuml;mplementeerd worden:
	  <literal>S4</literal><acronym>BIOS</acronym> is een slaapstand
	  naar schijf met behulp van het <acronym>BIOS</acronym> en
	  <literal>S4</literal><acronym>OS</acronym> wordt volledig door
	  het besturingssysteem beheerd.</para>

	<para>Begin met het controleren van <command>sysctl</command>
	  <option>hw.acpi</option> voor items die iets met "suspend" te
	  maken hebben.  Hier zijn de resultaten voor een
	  Thinkpad:</para>

	<screen>hw.acpi.supported_sleep_state: S3 S4 S5</screen>
	<screen>hw.acpi.s4bios: 0</screen>

	<para>Dit betekent dat hier <quote>acpiconf
	  <option>-s</option></quote> gebruikt kan worden om
	  <literal>S3</literal>, <literal>S4</literal>
	  <acronym>OS</acronym>, en <literal>S5</literal> te testen.
	  Als <option>s4bios</option> gelijk was aan een (1), dan zouden
	  we <literal>S4</literal><acronym>BIOS</acronym> ondersteuning
	  hebben in plaats van <literal>S4</literal>
	  <acronym>OS</acronym>.</para>

	<para>Als je suspend/resume moet testen, begin dan met
	  <literal>S1</literal> indien ondersteund.  Deze toestand
	  heeft de grootste kans om te werken, omdat deze niet veel
	  stuurprogrammaondersteuning vereist.  Niemand heeft nog
	  <literal>S2</literal> ge&iuml;mplementeerd, maar mocht je het
	  hebben, het is ongeveer hetzelfde als <literal>S1</literal>.
	  Het volgende om uit te proberen is <literal>S3</literal>.
	  Dit is het diepste <acronym>STR</acronym> niveau en heeft
	  uitgebreide ondersteuning van stuurprograama's nodig om je
	  hardware goed te kunnen herinitialiseren.  Mocht je hier
	  problemen hebben om verder te komen, mail dan s.v.p. naar de
	  acpi-jp lijst, maar verwacht niet een snelle oplossing omdat
	  er nog de nodige stuurprogramma's/hardware ligt om getest en
	  bewerkt te worden.</para>

	<para>Om een probleem te kunnen isoleren helpt het om zoveel
	  mogelijk stuurprogramma's uit de kernel te halen.  Als dit
	  werkt, kun je terugwerken naar de driver die schuldig is aan
	  het falen.  Typisch zullen binaire stuurprogramma's zijn als
	  <filename>nvidia.ko</filename>, <application>X11</application>
	  beeldschermstuurprogramma's en <acronym>USB</acronym> de
	  meeste problemen vertonen, terwijl bijvoorbeeld Ethernet
	  interfaces meestal meteen goed werken.  Als je de
	  stuurprogramma's zonder problemen kunt in- en uitladen, dan
	  kun je dit automatiseren door de juiste commando's in
	  <filename>/etc/rc.suspend</filename> en
	  <filename>/etc/rc.resume</filename> te zetten.  Er staat een
	  voorbeeld (achter commentaartekens) voor het in- en uitladen
	  van een driver.  Probeer <option>hw.acpi.reset_video</option>
	  naar nul (0) te zetten als het zo mocht zijn dat je
	  beeldscherm er na het wakker worden verstoord uitziet.
	  Probeer langere of kortere waarden te zetten voor
	  <option>hw.acpi.sleep_delay</option> om na te gaan of dat
	  helpt.</para>

	<para>In geval van problemen, kun je ook proberen om een recente
	  Linux distibutie met <acronym>ACPI</acronym> support te laten
	  starten en daarvan de suspend/resume ondersteuning op dezelfde
	  hardware uit te proberen.  Als het werkt met Linux, dan is het
	  waarschijnlijk een &os; stuurprogrammaprobleem en als je kunt
	  uitvinden over welke driver het gaat kan dat bijdragen aan het
	  oplossen van het probleem.  Merk op dat de
	  <acronym>ACPI</acronym> zich in het algemeen niet bezighouden
	  met andere stuurprogramma's bijv. geluid,
	  <acronym>ATA</acronym>, etc.) dus als je bezig bent met een
	  echt driverprobleem, dan zul je waarchijnlijk uiteindelijk
	  ook naar de freebsd-current lijst moeten posten en naar de
	  beheerder van het stuurprogramma.  Als je je avontuurlijk
	  voelt, ga vooral je gang en plaats een paar &man.printf.3;s in
	  problematische stukken van een stuurprogramma voor debugging
	  om na te gaan waar precies de resume funktie hangt.</para>

	<para>Tot slot kun je proberen om <acronym>ACPI</acronym> uit te
	  zetten en in plaats daarvan <acronym>APM</acronym> aan te
	  zetten.  Als suspend/resume werkt met <acronym>APM</acronym>
	  dan kun je het misschien beter daarbij houden, vooral met wat
	  oudere apparatuur (voor 2000).  Producenten hebben nogal wat
	  tijd nodig gehad om <acronym>ACPI</acronym> ondersteuning goed
	  te krijgen en oudere hardware heeft een grotere
	  waarschijnlijkheid dat er <acronym>BIOS</acronym> problemen
	  zijn met <acronym>ACPI</acronym>.</para>
      </sect3>

      <sect3>
	<title>Hangen van het systeem (tijdelijk of permanent)</title>

	<para>Meestal is het hangen van het systeem het gevolg van
	  verloren interrupts of een interrupt storm.  Chipsets kunnen
	  een heleboel problemen hebben, afhankelijk van hoe het
	  <acronym>BIOS</acronym> interrupts configureert voor het
	  opstarten, of de <acronym>APIC</acronym>
	  (<acronym>MADT</acronym>) tabel correct is en de routering van
	  het <acronym>SCI</acronym>.</para>

	<para>Interrupt storms kunnen onderscheiden worden van verloren
	  geraakte interrupts door de uitvoer van
	  <command>vmstat</command> <option>-i</option> te controleren
	  en de regel met <quote>acpi0</quote> goed te lezen.  Als de
	  teller in toenemende mate hoger gaat dan enkele per seconde,
	  dan heb je een interrupt storm.  Als het systeem lijkt te
	  hangen, probeer dan op de console naar de
	  <acronym>DDB</acronym> te breken
	  (<keycombo action="simul"><keycap>CTRL</keycap>
	  <keycap>ALT</keycap><keycap>ESC</keycap></keycombo>) en voer
	  in: <option>show interrupts</option>.</para>

	<para>De beste hoop in geval van interruptproblemen
	  is om <acronym>APIC</acronym> ondersteuning uit te zetten met
	   <option>hint.apic.0.disabled=</option><quote>1</quote> in
	   <filename>loader.conf</filename>.</para>
      </sect3>

      <sect3>
	<title>Panics</title>

	<para>Panics zijn relatief zeldzaam met <acronym>ACPI</acronym>
	  en hebben de hoogste prioriteit om opgelost te worden.  De
	  eerste stap is de verschillende gebeurtenissen te isoleren
	  die de panic kunnen reproduceren (indien mogelijk) en het
	  verkrijgen van een backtrace.  Volg het advies over het
	  aanzetten van <option>options DDB</option> en het opzetten
	  van een seri&euml;le console of een &man.dump.8; partitie.
	  Als je de backtrace handmatig op moet schrijven, zorg dan in
	  ieder geval dat je de bovenste en onderste vijf (5) regels van
	  de backtrace noteert.</para>

	<para>Probeer vervolgens om op te starten met
	  <acronym>ACPI</acronym> uitgezet.  Als dat werkt, heb je het
	  <acronym>ACPI</acronym> subsysteem ge&iuml;soleerd en kun je
	  verschillende <option>debug.acpi.disable</option> waarden
	  uitproberen.  Zie de &man.acpi.4; handleiding voor enkele
	  voorbeelden.</para>
      </sect3>

      <sect3>
	<title>Systeem komt toch weer op na slaap (suspend) of stop (shutdown)</title>
	<para>Probeer eerst
	  <option>hw.acpi.disable_on_poweroff=</option><quote>0</quote>
	  te zetten in &man.loader.conf.5;.  Dit zorgt ervoor dat
	  <acronym>ACPI</acronym> niet het opvangen van bepaalde
	  gebeurtenissen tijdens het afsluitproces negeert.  Om dezelfde
	  redenen moeten sommige systemen deze waarde altijd op
	  <quote>1</quote> (de standaard) hebben.  In het algemeen lost
	  dit een probleem op waarbij een systeem spontaan weer opkomt
	  nadat het in slaapstand is gezet of geheel gestopt.</para>
      </sect3>

      <sect3>
	<title>Overige problemen</title>

	<para>Als je nog andere problemen hebt met <acronym>ACPI</acronym>
	  (met een docking station of apparaten niet gedetecteerd, etc.),
	  verzend dan s.v.p. een beschrijving naar de mailinglijst.  Sommige
	  zaken kunnen echter gerelateerd zijn aan delen van het
	  <acronym>ACPI</acronym> subsysteem die nog niet af zijn dus het
	  kan in sommige gevallen een tijd duren.  Heb s.v.p. geduld en
	  wees bereid om eventuele patches uit te proberen.</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-aslanddump">
      <title><acronym>ASL</acronym>, <command>acpidump</command> en
	 <acronym>IASL</acronym></title>

      <para>Het grootste probleem is dat <acronym>BIOS</acronym>
	producenten vaak incorrecte (of gewoon buggy!) bytecode leveren.  Dit
	blijkt doorgaans uit kernel boodschappen als:</para>

      <screen>ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] (Node 0xc3f6d160), AE_NOT_FOUND</screen>

      <para>Vaak kun je dergelijke problemen oplossen door je
	<acronym>BIOS</acronym> bij te werken tot de laatste revisie.
	De meeste consoleberichten zijn onschuldig, maar als je andere
	problemen ondervindt -- zoals batterijstatus die niet werkt --
	dan ligt het voor de hand te zoeken naar problemen in de
	<acronym>AML</acronym> code.  De bytecode die
	<acronym>AML</acronym> genoemd wordt wordt gecompileerd van een
	broncodetaal genaamd <acronym>ASL</acronym>.  Deze staat weer in
	een tabel genaamd <acronym>DSDT</acronym>.  Om een kopie van de
	<acronym>ASL</acronym> te verkrijgen kun je &man.acpidump.8;
	gebruiken.  Je moet dan zowel de <option>-t</option> (laat
	inhoud van vaste tabellen zien) als de <option>-d</option>
	(disassembleer <acronym>AML</acronym> naar
	<acronym>ASL</acronym>) opties gebruiken.  Zie het
	<link linkend="ACPI-submitdebug">Debugging informatie
	aanleveren</link> gedeelte voor een voorbeeld.</para>

      <para>De eenvoudigste eerste controle die je kunt verrichten, is
	de <acronym>ASL</acronym> code opnieuw compileren en kijken of
	er foutmeldingen optreden.  Waarschuwingen kunnen doorgaans
	genegeerd worden maar fouten zijn bugs die meestal ertoe leiden
	dat <acronym>ACPI</acronym> niet correct werkt.  Om
	<acronym>ASL</acronym> te hercompileren gebruik je:</para>

      <screen>&prompt.root; <userinput>iasl jouw.asl</userinput></screen>
    </sect2>

    <sect2 id="ACPI-fixasl">
      <title><acronym>ASL</acronym> repareren</title>

      <para>Op langere termijn is het de bedoeling dat voor vrijwel elke
	machine <acronym>ACPI</acronym> werkt zonder enig ingrijpen van
	de gebruiker.  Op dit moment echter, wordt er nog gewerkt aan
	oplossingen voor veel voorkomende vergissingen die
	<acronym>BIOS</acronym> producenten maken.  De Microsoft
	interpreter (<filename>acpi.sys</filename> en <filename>acpiec.sys</filename>)
	controleert niet strikt of het <acronym>BIOS</acronym> volledig
	aan de standaard voldoet waardoor het voorkomt dat
	<acronym>BIOS</acronym> makers die alleen testen onder Windows
	bepaalde fouten in hun <acronym>ASL</acronym> nooit correct
	repareren.  We hopen de identificatie en documentatie van welk
	niet-standaard gedrag precies wordt toegelaten door Microsoft's
	interpreter voort te zetten en te repliceren zodat &os; kan
	werken zonder dat gebruikers zich gedwongen zien om de
	<acronym>ASL</acronym> te repareren.  Als een tijdelijke
	oplossing en om te helpen met het in kaart brengen van bepaald
	gedrag, kun je de <acronym>ASL</acronym> handmatig repareren.
	Als dit lukt, stuur dan s.v.p. een &man.diff.1; van de oude en
	de nieuwe <acronym>ASL</acronym> zodat het buggy gedrag mogelijk
	in <acronym>ACPI-CA</acronym> kan worden verwerkt, waardoor
	andere gebruikers niet meer handmatig met hun
	<acronym>ASL</acronym> aan de gang hoeven.</para>

      <para>Hier volgt een lijst van veel voorkomende foutmeldingen, hun
	oorzaken en hoe ze op te lossen:</para>

      <sect3>
	<title>_OS afhankelijkheden</title>

	<para>Sommige <acronym>AML</acronym>s gaan ervan uit dat de
	  wereld enkel bestaat uit verscheidene Windows versies.  Je
	  kunt &os; zich laten voordoen als elk <acronym>OS</acronym>
	  om te kijken of dit je problemen oplost.  Een gemakkelijke
	  manier om dit te doen is
	  <option>hw.acpi.osname</option>=<quote>Windows 2001</quote> te
	  zetten in <filename>/boot/loader.conf</filename> of andere
	  gelijksoortige strings die je tegenkomt in je
	  <acronym>ASL</acronym>.</para>

      <sect3>
	<title>Ontbrekende return statements</title>

	<para>Sommige methoden hebben geen specifieke returnwaarde zoals
	  wel vereist wordt door de standaard.  Hoewel
	  <acronym>ACPI-CA</acronym> hier niets mee doet, heeft &os;
	  de mogelijkheid tot impliciete returns.  Je kunt ook expliciet
	  return statements toevoegen waar vereist als je weet welke
	  waarden teruggevoerd moeten worden.  Om <command>iasl</command>
	  te dwingen tot compilatie van <acronym>ASL</acronym> kun je
	  de <option>-f</option> schakeloptie gebruiken.</para>
      </sect3>

      <sect3>
	<title>Verder gaan dan de standaard <acronym>AML</acronym></title>

	<para>Nadat je <filename>jouw.asl</filename> aangepast hebt,
	  compileer je het als volgt:</para>

	<screen>&prompt.root; <userinput>iasl jouw.asl</userinput></screen>

	<para>Met de <option>-f</option> optie kun je afdwingen dat er
	  de <acronym>AML</acronym> gemaakt wordt, zelfs als er
	  compileerfouten optreden.  Denk eraan dat sommige fouten
	  (zoals ontbrekende return statements) automatisch opgelost
	  worden door de interpreter.</para>

	<para><filename>DSDT.aml</filename> is de standaard naam voor
	  het bestand dat door <command>iasl</command> wordt
	  geproduceerd.  Je kunt dit inladen in plaats van de buggy
	  versie uit het <acronym>BIOS</acronym> (die nog steeds
	  aanwezig is in het flashgeneugen) door
	  <filename role="directory">/boot/loader.conf</filename> als
	  volgt te wijzigen:</para>

	<programlisting>acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"</programlisting>

	<para>Vergeet niet je <filename>DSDT.aml</filename> in de
	  <filename role="directory">/boot</filename> directory te
	  zetten.</para>
      </sect3>

    <sect2 id="ACPI-debugoutput">
      <title>Debugging uitvoer van <acronym>ACPI</acronym> verkrijgen</title>

      <para>Het <acronym>ACPI</acronym> stuurprogramma heeft een zeer
	flexibele debugging faciliteit.  Je kunt zowel een set van
	subsystemen specificeren als het niveau van verbositeit.  De te
	debuggen subsystemen worden gespecificeerd als lagen
	(<quote>layers</quote>) en ze zijn opgedeeld in
	<acronym>ACPI-CA</acronym> componenten (ACPI_ALL_COMPONENTS)
	en <acronym>ACPI</acronym> hardware ondersteuning
	(ACPI_ALL_DRIVERS).  De verbositeit van debugging uitvoer wordt
	gespecificeerd als het niveau (<quote>level</quote>) en gaat van
	CPI_LV_ERROR (alleen fouten rapporteren) tot ACPI_LV_VERBOSE
	(alles).  Het niveau is een bitmasker en dus kunnen er meerdere
	opties tegelijk gezet worden (gescheiden door spaties).  In de
	praktijk zul je wellicht een seri&euml;le console willen
	gebruiken om de uitvoer te loggen als deze zo omvangrijk is dat
	ze de console message buffer vult (misschien wel meerdere
	keren).  Een complete lijst van de individuele lagen en niveaus
	vindt je in de &man.acpi.4; handleiding.</para>

      <para>Debugging uitvoer staat niet standaard aan.  Om het aan te
	zetten voeg je <option>options ACPI_DEBUG</option> toe aan je
	kernel configuratie als <acronym>ACPI</acronym> in je kernel is
	gebouwd.  Je kunt <option>ACPI_DEBUG=1</option> aan je
	<filename>/etc/make.conf</filename> bestand toevoegen om het
	systeemwijd aan te zetten.  Als je <acronym>ACPI</acronym> als
	module gebruikt (de normale situatie), dan hoeft je slechts de
	<filename>acpi.ko</filename> module te hercompileren als
	volgt:</para>

      <screen>&prompt.root; <userinput>cd /sys/modules/acpi/acpi
&amp;&amp; make clean &amp;&amp; make
ACPI_DEBUG=1</userinput></screen>

      <para>Installeer <filename>acpi.ko</filename> in
	<filename role="directory">/boot/kernel</filename> en voeg de
	gewenste debuglaag en het gewenste verbositeitsniveau toe aan
	het <filename>loader.conf</filename> bestand.  Hier is een
	voorbeeld waarmee debugging uitvoer wordt aangezet voor alle
	<acronym>ACPI-CA</acronym> componenten en alle
	<acronym>ACPI</acronym> hardware stuurprogramma's
	(<acronym>CPU</acronym>, <acronym>LID</acronym>, etc).  Het
	verbositeitsniveau is het laagste; er worden alleen
	foutmeldingen gemeld.</para>

      <programlisting>debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"</programlisting>

      <para>Als de informatie die je zoekt veroorzaakt wordt door een
	specifieke gebeurtenis (bijvoorbeeld in en uit slaapstand gaan),
	dan kun je wijzigingen aan <filename>loader.conf</filename>
	achterwege laten en in plaats daarvan <command>sysctl</command>
	gebruiken om laag en niveau te specificeren na het opstarten en
	zo het systeem voor te bereiden op die specifieke gebeurtenis.
	De <command>sysctl</command>s hebben dezelfde namen als de
	parameters in <filename>loader.conf</filename>.</para>
    </sect2>

    <sect2 id="ACPI-References">
      <title>Referenties</title>

      <para>Meer informatie over <acronym>ACPI</acronym> kun je vinden
	op de volgende locaties:</para>

      <itemizedlist>
	<listitem>
	  <para>De <acronym>ACPI</acronym> mailinglijst
	    <ulink url="mailto:acpi-jp@jp.freebsd.org">
	    acpi-jp@jp.freebsd.org</ulink></para>
	</listitem>

	<listitem>
	  <para>De <acronym>ACPI</acronym> mailinglijst archieven
	    <ulink url="http://home.jp.freebsd.org/mail-list/acpi-jp/">
	    http://home.jp.freebsd.org/mail-list/acpi-jp/</ulink></para>
	</listitem>

	<listitem>
	  <para>De <acronym>ACPI</acronym> 2.0 specificatie
	    <ulink url="http://acpi.info/spec.htm">
	    http://acpi.info/spec.htm/</ulink></para>
	</listitem>

	<listitem>
	  <para>&os; Handleidingen: &man.acpi.4;,
	    &man.acpi.thermal.4;, &man.acpidump.8;, &man.iasl.8;,
	    &man.acpidb.8;</para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt">
	    <acronym>DSDT</acronym> debugging informatie</ulink>.
	    (Gebruikt Compaq als voorbeeld maar van algemeen nut).</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
