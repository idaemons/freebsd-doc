<!--
  The Vinum Volume Manager
  By Greg Lehey (grog at lemis dot com)

  Added to the Handbook by Hiten Pandya <hiten@FreeBSD.org>
  and Tom Rhodes <trhodes@FreeBSD.org>

  The Dutch FreeBSD Documentation Project

  $FreeBSD$
  $FreeBSDnl: nl_NL.ISO8859-1/books/handbook/vinum/chapter.sgml,v 1.22 2004/11/13 22:13:42 remko Exp $
  Gebaseerd op: 1.32
-->

<chapter id="vinum-vinum">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Greg</firstname>
	<surname>Lehey</surname>
	<contrib>Geschreven door </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Erwin</firstname>
	<surname>Kooi</surname>
	<contrib>Vertaald door </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>De VINUM volume manager</title>

  <sect1 id="vinum-synopsis">
    <title>Samenvatting</title>

    <para>Welke harde schijven er ook gebruikt worden, er zijn altijd
      mogelijke problemen:<para>

    <itemizedlist>
      <listitem>
	<para>Ze kunnen te klein zijn</para>
      </listitem>

      <listitem>
	<para>Ze kunnen te traag zijn</para>
      </listitem>

      <listitem>
	<para>Ze kunnen te onbetrouwbaar zijn.</para>
      </listitem>
    </itemizedlist>

    <para>E&eacute;n manier waarop gebruikers zich wapenen tegen
      een aantal van deze problemen is door meerdere en soms ook
      redundante disks te gebruiken.</para>

    <para>Naast ondersteuning voor verschillende kaarten en controllers
      die hardware RAID ondersteunen, bevat het &os; basissysteem ook
      de Vinum Volume Manager, een <quote>block device driver</quote>
      waarmee virtuele disken gemaakt kunnen worden.</para>

    <para>Vinum biedt meer flexibiliteit, prestaties en betrouwbaarheid
      dan traditionele diskopslag en er kan RAID-0, RAID-1 en RAID-5
      mee gemaakt worden of een combinatie van deze RAID
      niveau's.</para>

    <para>In dit hoofdstuk wordt een overzicht gegeven van de mogelijke
      problemen die traditionele diskopslag met zich meebrengt en de
      Vinum Volume Manager wordt ge&iuml;ntroduceerd.</para>
  </sect1>

  <sect1 id="vinum-intro">
    <title>Schijfgrootte</title>

    <indexterm><primary>Vinum</primary></indexterm>

    <indexterm>
      <primary>RAID</primary>

      <secondary>Software</secondary>
    </indexterm>

    <para><emphasis>Vinum</emphasis> is een <emphasis>Volume
	Manager</emphasis>, een virtuele schijfdriver die de drie
      genoemde problemen op kan lossen.  Het probleem wordt in de
      volgende paragrafen verder uitgediept.  Verscheidene
      oplossingen zijn al voorgesteld en toegepast:</para>

    <para>De capaciteit van schijven wordt groter, maar ook de vraag
      naar capaciteit neemt toe.  Vaak is het gewenste bestandsysteem
      groter dan de op dat moment beschikbare schijven. Hoewel dit
      probleem niet meer zo actueel als het tien jaar geleden was,
      bestaat het nog steeds.  In sommige systemen is dit opgelost door
      een virtuele harde schijf te maken die de data op meerdere
      fysieke harde schijven kan opslaan.</para>
  </sect1>

  <sect1 id="vinum-access-bottlenecks">
    <title>Snelheid van Toegang</title>

    <para>Moderne systemen hebben vaak simultaan toegang tot data
      nodig.  FTP en webservers kunnen bijvoorbeeld duizenden simultane
      sessies onderhouden en hebben vaak meerdere 100 Mbit/s
      verbindingen met de rest van de wereld.  De benodigde
      datadoorvoer is dan groter dan de meeste schijven kunnen
      leveren.</para>

    <para>Huidige schijven kunnen data sequentieel overdragen met
      ongeveer 70 MB/s, maar deze snelheid heeft geen waarde in een
      omgeving waar onafhankelijke processen toegang tot de schijf
      hebben.  In zo'n situatie is het interessanter om vanuit het
      standpunt van de schijfdriver te kijken: de belangrijkste
      parameter is dan de belasting die een bepaalde data overdracht op
      de driver plaatst. Met andere woorden: wat is het tijdbeslag van
      een dataoverdracht op te schijf?</para>

    <para>Bij elke dataoverdracht moet de schijf eerst zijn kop
      positioneren, wachten tot de eerste sector onder de kop doorkomt
      en vervolgens de overdracht starten. Deze acties duren bijzonder
      kort.  Het heeft geen enkele zin om ze te onderbreken.</para>

    <para><anchor id="vinum-latency">Neem een overdracht van ongeveer
      10 kB: de huidige generatie high-performance schijven kan de kop
      in 3.5 ms plaatsen.  De snelste schijven draaien met 15.000
      toeren per minuut, dus de gemiddelde rotatie vertraging (een
      halve omwenteling) bedraagt 2 ms.  Met 70&nbsp;MB/s de overdracht
      zelf duurt ongeveer 150 &mu;s, bijna niets vergeleken met de tijd
      die verloren is gegaan aan het positioneren.  In zulke gevallen
      daalt de data overdracht naar iets meer dan 1 MB/s en is dus
      duidelijk afhankelijk van de grootte van de over te dragen
      data.</para>

    <para>De traditionele en logische oplossing voor dit probleem is
      <quote>meer schijven</quote>: in plaats van &eacute;&eacute;n
      grote schijf, meerdere kleine schijven met een zelfde totale
      opslagcapaciteit.  Iedere schijf is in staat om onafhankelijk de
      kop te plaatsen en de data over te dragen, dus de effectieve
      doorvoer neemt toe met een factor bijna gelijk aan het aantal
      schijven.</para>

    <para>De exacte verbetering van de doorvoer is natuurlijk kleiner
      dan het aantal schijven, want hoewel iedere schijf in staat is om
      parallel de data over te dragen, er is geen garantie dat de data
      gelijk over de schijven verdeeld is.  De belasting op de ene
      schijf zal dan ook groter zijn dan op de andere schijf.</para>

    <indexterm>
      <primary>aaneenschakelen</primary>

      <secondary>disken aaneenschakelen</secondary>
    </indexterm>

    <indexterm>
      <primary>Vinum</primary>

      <secondary>aaneenschakelen</secondary>
    </indexterm>

    <para>Een gelijke belasting van de schijven is in grote mate
      afhankelijk van de manier waarop data over de schijven is
      verdeeld.  In het volgende stuk is de opslag van een virtuele
      schijf voor te stellen als een verzameling sectoren die met een
      nummer aangesproken kan worden, net als bladzijden in een boek.
      De meest voor de hand liggende methode om een virtuele schijf
      te maken is het achter elkaar plakken van de fysieke schijven.
      Een virtueel boek zou dan opgebouwd zijn uit verschillende achter
      elkaar zittende fysieke hoofdstukken.  Deze methode heet
      <emphasis>aaneenschakelen</emphasis>
      (<quote>concatenation</quote>) en heeft het voordeel dat schijven
      verschillend van grootte kunnen zijn.  Dit werkt prima als
      toegang tot de data gelijk verdeeld is over de hele dataset.  Als
      die toegang beperkt is tot een klein deel van de dataset, is de
      snelheidsverbetering een stuk kleiner.
      <xref linkend="vinum-concat"> laat de manier zien hoe
      aaneengeschakelde schijven hun data opslaan.</para>

    <para>
      <figure id="vinum-concat">
	<title>Aaneengeschakeld georganiseerd</title>

	<graphic fileref="vinum/vinum-concat">
      </figure>
    </para>

    <indexterm>
      <primary>verdelen</primary>

      <secondary>disk striping</secondary>
    </indexterm>

    <indexterm>
      <primary>Vinum</primary>

      <secondary>verdelen</secondary>
    </indexterm>

    <para>Een andere methode is het verdelen van de totale opslag van
      de virtuele schijf in kleinere stukjes van gelijke grootte en ze
      achter elkaar op verschillende fysieke schijven op te slaan.
      Bijvoorbeeld: de eerste 256 sectoren worden op schijf 1
      opgeslagen, de tweede 256 sectoren op schijf 2 enzovoort, tot de
      laatste schijf is gebuikt, waarna weer bij schijf 1 verder wordt
      gegaan, net zolang tot de schijven vol zijn.  Deze methode heet
      <emphasis>verdelen</emphasis> (<quote>striping</quote>) of
      <acronym>RAID-0</acronym>.

    <footnote>
      <indexterm>
	<primary>RAID</primary>
      </indexterm>

      <para><acronym>RAID</acronym> staat voor <emphasis>Redundant
	Array of Inexpensive Disks</emphasis> (Redundante Reeks van
	Goedkope Disks) en biedt verschillende vormen van
	fout-tolerantie.  Hoewel die laatste term wat misleidend is:
	het biedt namelijk geen redundantie.</para>
    </footnote>.

      Bij RAID-0 kost het iets meer moeite om de data te vinden en het
      kan extra I/O belasting met zich meebrengen als data is verdeeld
      over verschillende fysieke schijven.  Het kan echter ook zorgen
      voor een constantere belasting van die schijven.
      <xref linkend="vinum-striped"> geeft weer hoe RAID-0 schijven hun
      data opslaan.</para>

    <para>
      <figure id="vinum-striped">
	<title>Verdeeld georganiseerd</title>

	<graphic fileref="vinum/vinum-striped">
      </figure>
    </para>
  </sect1>

  <sect1 id="vinum-ddata-integrity">
    <title>Betrouwbaarheid van Data</title>

    <para>Het laatste probleem met de huidige schijven is dat ze
      onbetrouwbaar zijn.  Hoewel de betrouwbaarheid de laatste jaren
      enorm is toegenomen, blijven schijven het vitale onderdeel van
      een server dat waarschijnlijk als eerste kapot gaat.  Als dat
      gebeurt kan het catastrofale gevolgen hebben: het vervangen van
      de schijf en het terugplaatsen van de data kan dagen
      kosten.</para>

    <indexterm>
      <primary>spiegelen</primary>

      <secondary>disken spiegelen</secondary>
    </indexterm>

    <indexterm>
      <primary>Vinum</primary>

      <secondary>spiegelen</secondary>
    </indexterm>

    <indexterm><primary>RAID-1</primary></indexterm>

    <para>De traditionele manier om dit te voorkomen is
      <emphasis>spiegelen</emphasis> (<quote>mirroring</quote>): het
      hebben van een kopie van de data op een andere fysieke schijf.
      Sinds de uitvinding van RAID niveau's staat dit bekend als
      RAID-1.  Een schrijfactie naar de virtuele schijf gebeurt op
      beide fysieke schijven.  Een leesactie hoeft slechts vanaf
      &eacute;&eacute;n te gebeuren.  Op deze manier kan de virtuele
      schijf dus blijven werken als &eacute;&eacute;n van de twee
      fysieke schijven kapot is.</para>

    <para>RAID-1 heeft twee problemen:</para>

    <orderedlist>
      <listitem>
	<para>Prijs.  Er is twee keer zoveel schijfruimte nodig als bij
	  een niet-redundante schijf.</para>
      </listitem>

      <listitem>
	<para>Prestatie.  Een schrijfacie moet op twee schijven
	  gebeuren en kost dus twee keer zoveel bandbreedte.  Een
	  leesactie hoeft maar op &eacute;&eacute;n schijf te gebeuren
	  en heeft hier dus geen last van.</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>RAID-5</primary>
    </indexterm>

    <para>Een andere manier is <emphasis>pariteit</emphasis>,
      uitgevoerd in <acronym>RAID</acronym> niveau's 2, 3, 4 en 5.
      Van deze vier is <acronym>RAID-5</acronym> het meest interessant.
      In Vinum is het ge&iuml;mplementeerd als een variant van een
      verdeelde organisatie waarbij &eacute;&eacute;n blok van elk deel
      is gereserveerd voor de pariteit van de andere blokken.  Voor
      Vinum is een <acronym>RAID-5</acronym> samenstelling
      (<quote>plex</quote>) dan ook gelijk aan een verdeelde
      samenstelling, met als verschil dat het een pariteitblok bevat in
      ieder deel.  Zoals voorgeschreven door <acronym>RAID-5</acronym>
      wisselt de locatie van dit pariteitblok van het ene deel naar het
      andere.  De nummers in de datablokken geven de relatieve
      bloknummers aan.</para>

    <para>
      <figure id="vinum-raid5-org">
	<title>RAID-5 georganiseerd</title>

	<graphic fileref="vinum/vinum-raid5-org">
      </figure>
    </para>

    <para>Vergeleken met spiegelen heeft <acronym>RAID-5</acronym> het
      voordeel dat er beduidend minder opslagcapaciteit nodig is.
      Lezen gebeurt op dezelfde manier als bij een verdeelde
      organisatie, maar schrijven kost beduidend meer tijd, ongeveer
      25% van de leesprestaties meer.  Als &eacute;&eacute;n schijf
      uitvalt, kan de reeks doorwerken in een <emphasis>verslechterde
	staat</emphasis> (<quote>degraded mode</quote>): data van een
      functionerende schijf kan zonder problemen gelezen worden, maar
      data van de defecte schijf moet eerst worden samengesteld uit de
      pariteit van de overeenkomende blokken van de resterende
      schijven.</para>
  </sect1>

  <sect1 id="vinum-objects">
    <title>Vinum Objecten</title>

    <para>Om deze problemen op te lossen, hanteert vinum een
      hi&euml;rarchie met vier niveau's van objecten:</para>

    <itemizedlist>
      <listitem>
	<para>Het meest zichtbare object is de virtuele schijf.  Dit
	  object wordt <emphasis>volume</emphasis> genoemd.  Op een
	  paar kleine details na, hebben volumes dezelfde
	  eigenschappen als een &unix; schijf.  Het belangrijkste
	  verschil is dat er geen beperking aan de grootte van de
	  schijf is.</para>
      </listitem>

      <listitem>
	<para>Volumes zijn opgebouwd uit
	  <emphasis>samenstellingen</emphasis>, die elk de totale
	  opslagcapaciteit van het volume hebben.  Dit niveau in de
	  hi&euml;rarchie biedt daarom redundantie.  Een samenstelling
	  is goed voor te stellen als een individuele schijf in een
	  <acronym>RAID-1</acronym> systeem.  Iedere schijf bevat
	  dezelfde data.</para>
      </listitem>

      <listitem>
	<para>Omdat Vinum bestaat binnen het &unix; opslagsysteem, moet
	  het mogelijk zijn om &unix; partities te gebruiken als
	  bouwstenen voor samenstellingen die uit meerdere schijven
	  bestaan.  Maar het blijkt dat dit te inflexibel is: &unix;
	  schijven hebben een beperkt aantal partities.  In plaats
	  daarvan verdeelt Vinum een &unix; partitie (de schijf) in
	  aaneengesloten stukken die <emphasis>subschijven</emphasis>
	  worden genoemd.  Deze subschijven worden vervolgens als
	  bouwstenen voor de samenstelling gebruikt.</para>
      </listitem>

      <listitem>
	<para>Subschijven bestaan op Vinum <emphasis>drives</emphasis>,
	  op dit moment &unix; partities.  Een Vinum drive kan
	  een oneindig aantal subdisks bevatten.  Met uitzondering van
	  een klein stukje aan het begin van de schijf, dat wordt
	  gebruikt om informatie over de configuratie en de toestand op
	  te slaan, is de gehele schijf beschikbaar voor de opslag van
	  data.</para>
      </listitem>
    </itemizedlist>

    <para>In de volgende paragrafen wordt beschreven hoe deze objecten
      de functionaliteit van Vinum leveren.</para>

    <sect2>
      <title>Volumegrootte Overwegingen</title>

      <para>Een samenstelling kan meerdere subschijven bevatten die
	uitgespreid zijn over alle disks in de Vinum configuratie.  Dat
	houdt in dat de grootte van een individuele schijf geen limiet
	is voor de samenstelling en dus niet voor het volume.</para>

    </sect2>

    <sect2>
      <title>Redundante Dataopslag</title>

      <para>Vinum implementeert <acronym>RAID-0</acronym> door meerdere
	samenstellingen aan een volume te koppelen.  Elke samenstelling
	representeert hierbij de data in het volume.  Een volume kan
	tussen de &eacute;&eacute;n en acht samenstellingen
	bevatten.</para>

      <para>Hoewel een samenstelling de totala data van een volume
	voorstelt, is het mogelijk dat delen van deze voorstelling
	missen, door ontwerp (door geen subdisk voor delen van de
	samenstelling te defini&euml;ren) of per ongeluk (door een
	defecte schijf).  Zo lang tenminste &eacute;&eacute;n
	samenstelling de data voor het gehele volume kan leveren, is
	het volume volledig bruikbaar.</para>
    </sect2>

    <sect2>
      <title>Prestaties</title>

      <para>Vinum implementeert aaneenschakelen en spiegelen op het
	niveau van de samenstelling:</para>

      <itemizedlist>
	<listitem>
	  <para>Een aaneengeschakelde samenstelling gebruikt de
	    adresruimte van elke subdisk achter elkaar.</para>
	</listitem>

	<listitem>
	  <para>Een verdeelde samenstelling spreidt de data over
	    iedere subdisk.  De subdisks moeten daarvoor allemaal
	    dezelfde grootte hebben en er moeten tenminste twee
	    subdisks zijn om onderscheid te kunnen maken met een
	    aaneengeschakelde samenstelling.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Welke Samenstelling?</title>

      <para>De versie van Vinum die met &os;&nbsp;&rel.current; wordt
	meegeleverd, kent twee soorten samenstellingen:</para>

      <itemizedlist>
	<listitem>
	  <para>Aaneengeschakelde samenstellingen zijn het meest
	    flexibel: ze kunnen een oneindig aantal subdisks bevatten
	    die verschillend van lengte mogen zijn.  De samenstelling
	    kan uitgebreid worden door subdisks toe te  voegen.  Ze
	    kosten minder <acronym>CPU</acronym> tijd dan verdeelde
	    samenstellingen, hoewel het verschil van de
	    <acronym>CPU</acronym> belasting niet meetbaar is.  Aan de
	    andere kant, ze zijn het meest kwetsbaar voor
	    <quote>hot-spots</quote>, waar &eacute;&eacute;n disk heel
	    intensief gebruikt wordt en anderen ongebruikt
	    blijven.</para>
	</listitem>

	<listitem>
	  <para>Het grootste voordeel van verdeelde samenstellingen
	    (<acronym>RAID-0</acronym>) is dat ze geen
	    <quote>hot-spots</quote> hebben.  Door het kiezen van een
	    optimale deelgrootte (veelal 256 kB) kan de belasting op de
	    fysieke schijven gelijk getrokken worden.  De nadelen van
	    deze aanpak zijn (minescuul) complexere code en beperkingen
	    aan de subdisks: ze moeten allemaal van gelijke grootte
	    zijn en het uitbreiden van een samenstelling met extra
	    subdisks is zo gecompliceerd, dat de huidige versie van
	    Vinum dit niet ondersteunt.  Vinum voegt een extra,
	    triviale, beperking toe: een verdeelde samenstelling moet
	    tenminste twee subdisks hebben, omdat die anders niet
	    onderscheiden kan worden van een aaneengeschakelde
	    samenstelling.</para>
	</listitem>
      </itemizedlist>

      <para>In <xref linkend="vinum-comparison"> worden de voor- en
	nadelen van elke samenstelling samengevat.</para>

      <table id="vinum-comparison" frame="none">
	<title>Vinum Samenstellingen</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>Samenstellingtype</entry>

	      <entry>Min. aantal subdisks</entry>

	      <entry>Subdisks toevoegen</entry>

	      <entry>Gelijke grootte</entry>

	      <entry>Toepassing</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>aaneengeschakeld</entry>

	      <entry>1</entry>

	      <entry>ja</entry>

	      <entry>nee</entry>

	      <entry>Veel dataopslag met maximale flexibiliteit en
		gemiddelde performance.</entry>
	    </row>

	    <row>
	      <entry>verdeeld</entry>

	      <entry>2</entry>

	      <entry>nee</entry>

	      <entry>ja</entry>

	      <entry>Hoge prestaties, ook bij veel gelijktijdige
		toegang.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>

  <sect1 id="vinum-examples">
    <title>Voorbeelden</title>

    <para>Vinum houdt een <emphasis>configuratie database</emphasis>
      bij waarin beschreven staat welke objecten bekend zijn in het
      systeem.  Bij het instellen vult de gebruiker deze database uit
      &eacute;&eacute;n of meer configuratiebestanden &man.vinum.8;.
      Vinum bewaart een kopie van de database op iedere slice (die
      Vinum <emphasis>device</emphasis> noemt) die door Vinum wordt
      beheerd.  Deze database wordt na iedere statuswijziging
      bijgewerkt, zodat een na een herstart acuraat de toestand van
      ieder Vinum object wordt weergegeven.</para>

    <sect2>
      <title>Het Configuratiebestand</title>

      <para>Het configuratiebestand beschijft de individuele vinum
	objecten.  De definitie van een eenvoudig volume kan er zo
	uitzien:</para>

      <programlisting>
    drive a device /dev/da3h
    volume myvol
      plex org concat
        sd length 512m drive a</programlisting>

      <para>Dit bestand beschrijft vier Vinum objecten:</para>

      <itemizedlist>
	<listitem>
	  <para>De <emphasis>drive</emphasis> regel beschrijft een
	    partitie (<emphasis>drive</emphasis>) en de relatieve
	    positie ten opzichte van de onderliggende hardware.  Het
	    heeft de symbolische naam <emphasis>a</emphasis>.  Deze
	    scheiding van de symbolische naam van de schijf maakt het
	    mogelijk om disks te verplaatsen van de ene locatie naar de
	    andere, zonder verwarring te veroorzaken.</para>
	</listitem>

	<listitem>
	  <para>De <emphasis>volume</emphasis> regel beschrijft een
	    volume.  Het enige benodigde attribuut is de naam:
	    <emphasis>myvol</emphasis>.</para>
	</listitem>

	<listitem>
	  <para>De <emphasis>plex</emphasis> regel beschrijft een
	    samenstelling.  Het enige benodigde attribuut is de
	    organisatie, in dit geval <emphasis>concat</emphasis>.  Er
	    is geen naam nodig: het systeem genereert automatisch een
	    naam door <emphasis>.p</emphasis><emphasis>x</emphasis> aan
	    de volumenaam toe te voegen, waarbij <emphasis>x</emphasis>
	    het nummer van de samenstelling in het volume is.  De naam
	    van deze samenstelling wordt dus
	    <emphasis>myvol.p0</emphasis>.</para>
	</listitem>

	<listitem>
	  <para>De <emphasis>sd</emphasis> regel beschrijft een
	    subdisk.  De minimale specificaties zijn de naam van een
	    schijf waar de subdisk kan worden opgeslagen en de lengte
	    van de subdisk.  Net als bij een samenstelling is er geen
	    naam nodig: het systeem genereert automatisch een naam door
	    <emphasis>.s</emphasis><emphasis>x</emphasis> aan de
	    samenstellingnaam toe te voegen, waarbij
	    <emphasis>x</emphasis> het nummer van de subdisk is.  De
	    naam van deze subdisk is dus
	    <emphasis>myvol.p0.s0</emphasis>.</para>
	</listitem>
      </itemizedlist>

      <para>Na het verwerken van deze definitie ziet de uitvoer van
	&man.vinum.8; er als volgt uit:</para>

      <programlisting width="97">
      &prompt.root; vinum -&gt; <userinput>create config1</userinput>
      Configuration summary
      Drives:       1 (4 configured)
      Volumes:       1 (4 configured)
      Plexes:       1 (8 configured)
      Subdisks:      1 (16 configured)

       D a                  State: up       Device /dev/da3h       Avail: 2061/2573 MB (80%)

       V myvol              State: up       Plexes:      1  Size:       512 MB

       P myvol.p0          C State: up       Subdisks:    1  Size:       512 MB

       S myvol.p0.s0         State: up       PO:        0 B Size:       512 MB</programlisting>

      <para>Deze uitvoer geeft de korte uitvoer van &man.vinum.8; weer.
	Het is grafisch weergegeven in
	<xref linkend="vinum-simple-vol">.</para>

      <para>
	<figure id="vinum-simple-vol">
	  <title>Een Eenvoudig Vinum Volume</title>

	  <graphic fileref="vinum/vinum-simple-vol">
	</figure>
      </para>

      <para>Deze en de volgende figuren stellen een volume voor dat
	samenstellingen bevat die weer de subdisks bevatten.  In dit
	triviale voorbeeld bevat het volume een samenstelling en deze
	samenstelling bevat een subdisk.</para>

      <para>Dit speciale volume heeft geen voordeel boven een gewone
	schijf paritie.  Het bevat &eacute;&eacute;n samenstelling, dus
	het is niet redundant.  De samenstelling bevat
	&eacute;&eacute;n subdisk, dus er is geen verschil in de plaats
	van de data met een conventionele schijf partitie.  In de
	volgende paragrafen worden meer interesante configuraties
	getoond.</para>
    </sect2>

    <sect2>
      <title>Verbeterde Betrouwbaarheid: Spiegelen</title>

      <para>De betrouwbaarheid van een volume wordt vergroot door
	spiegelen.  Bij het opzetten van een gespiegeld volume is het
	van belang dat subdisks van iedere samenstelling op een
	andere schijf staan, zodat een defecte schijf niet beide
	samenstellingen be&iuml;nvloedt.  De volgende configuratie maakt
	een gespiegeld volume:</para>

      <programlisting>
       drive b device /dev/da4h
       volume mirror
      plex org concat
       sd length 512m drive a
         plex org concat
           sd length 512m drive b</programlisting>

      <para>In dit voorbeeld was het niet nodig om drive
	<emphasis>a</emphasis> opnieuw te defini&euml;ren, omdat Vinum
	alle objecten bijhoudt in de configuratie database.  Na het
	verwerken van deze definitie, ziet de configuratie er als volgt
	uit:</para>

     <programlisting width="97">
        Drives:        2 (4 configured)
        Volumes:        2 (4 configured)
        Plexes:        3 (8 configured)
        Subdisks:      3 (16 configured)

        D a                    State: up        Device /dev/da3h        Avail: 1549/2573 MB (60%)
        D b                    State: up        Device /dev/da4h        Avail: 2061/2573 MB (80%)

    V myvol              State: up        Plexes:      1  Size:        512 MB
    V mirror             State: up        Plexes:      2  Size:        512 MB

    P myvol.p0         C State: up        Subdisks:    1  Size:        512 MB
    P mirror.p0        C State: up        Subdisks:    1  Size:        512 MB
    P mirror.p1        C State: initializing     Subdisks:     1 Size:        512 MB

    S myvol.p0.s0        State: up        PO:        0 B  Size:        512 MB
    S mirror.p0.s0        State: up        PO:        0 B  Size:        512 MB
    S mirror.p1.s0        State: empty    PO:        0 B  Size:        512 MB</programlisting>

      <para>Het is grafisch weergegeven in
	<xref linkend="vinum-mirrored-vol">.</para>

      <para>
	<figure id="vinum-mirrored-vol">
	  <title>Een gespiegeld Vinum Volume</title>

	  <graphic fileref="vinum/vinum-mirrored-vol">
	</figure>
      </para>

      <para>In dit voorbeeld bevat iedere samenstelling de volledige 512
	MB van de opslagcapaciteit.  Net als in het vorige voorbeeld
	bevat iedere samenstelling slechts &eacute;&eacute;n
	subdisk.</para>
    </sect2>

    <sect2>
      <title>Verbeterde Prestatie</title>

      <para>Het gespiegelde volume in het vorige voorbeeld is beter
	bestand tegen hardware fouten dan een niet-gespiegeld volume,
	maar de prestaties zijn lager: iedere schrijfactie naar het
	volume moet op beide schijven worden uitgevoerd, waardoor een
	groter deel van de bandbreedte van de schijf nodig is.  Als
	prestaties een belangrijke rol spelen, moet er een andere
	benadering gekozen worden: in plaats van spiegelen wordt de
	data verdeeld over zoveel mogelijk schijven.  De volgende
	configuratie laat een volume zien waarbij een samenstelling
	over vier schijven verdeeld is:</para>

      <programlisting>
      drive c device /dev/da5h
      drive d device /dev/da6h
      volume stripe
      plex org striped 512k
        sd length 128m drive a
        sd length 128m drive b
        sd length 128m drive c
        sd length 128m drive d</programlisting>

      <para>Zoals eerder al te zien was, is het niet nodig om drives
	die al bekend zijn bij Vinum opnieuw te defini&euml;ren.  Na
	het verwerken van deze definitie, ziet de configuratie er zo
	uit:</para>

      <programlisting width="92">
      Drives:             4 (4 configured)
      Volumes:        3 (4 configured)
      Plexes:             4 (8 configured)
      Subdisks:      7 (16 configured)

   D a                    State: up        Device /dev/da3h        Avail: 1421/2573 MB (55%)
   D b                    State: up        Device /dev/da4h        Avail: 1933/2573 MB (75%)
   D c                    State: up        Device /dev/da5h        Avail: 2445/2573 MB (95%)
   D d                    State: up        Device /dev/da6h        Avail: 2445/2573 MB (95%)

   V myvol                State: up        Plexes:      1  Size:        512 MB
   V mirror               State: up        Plexes:      2  Size:        512 MB
   V striped              State: up        Plexes:      1  Size:        512 MB

   P myvol.p0           C State: up        Subdisks:    1  Size:        512 MB
   P mirror.p0          C State: up        Subdisks:    1  Size:        512 MB
   P mirror.p1          C State: initializing     Subdisks:     1 Size:        512 MB
   P striped.p1           State: up        Subdisks:    1  Size:        512 MB

   S myvol.p0.s0          State: up        PO:        0 B  Size:        512 MB
   S mirror.p0.s0         State: up        PO:        0 B  Size:        512 MB
   S mirror.p1.s0         State: empty     PO:        0 B  Size:        512 MB
   S striped.p0.s0        State: up        PO:        0 B  Size:        128 MB
   S striped.p0.s1        State: up        PO:      512 kB Size:        128 MB
   S striped.p0.s2        State: up        PO:     1024 kB Size:        128 MB
   S striped.p0.s3        State: up        PO:     1536 kB Size:        128 MB</programlisting>

      <para>
	<figure id="vinum-striped-vol">
	  <title>Een verdeeld Vinum Volume</title>

	  <graphic fileref="vinum/vinum-striped-vol">
	</figure>
      </para>


      <para>Dit volume wordt weergegeven in
	<xref linkend="vinum-striped-vol">.  De grijstinten geven de
	positie binnen de samenstelling aan: de lichtste strepen komen
	het eerst, de donkerste het laatst.</para>
    </sect2>

    <sect2>
      <title>Betrouwbaarheid en Prestaties</title>

      <para><anchor id="vinum-resilience">Met voldoende hardware is het
	mogelijk om een volume te bouwen met zowel verbeterde
	betrouwbaarheid als verbeterde prestaties ten opzichte van een
	standaard &unix; partitie.  De volgende configuratie is een
	voorbeeld van zo'n volume:</para>

      <programlisting>
        volume raid10
      plex org striped 512k
        sd length 102480k drive a
        sd length 102480k drive b
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
      plex org striped 512k
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
        sd length 102480k drive a
        sd length 102480k drive b</programlisting>

      <para>De subdisks van de tweede samenstelling zijn twee schijven
	verschoven ten opzichte van die van de eerste samenstelling.
	Dit zorgt ervoor dat een schrijfactie niet naar dezelfde disks
	gaat, zelfs niet als die schrijfactie over twee schijven
	plaatsvindt.</para>

      <para><xref linkend="vinum-mirrored-vol"> laat deze configuratie
	zien in grafische vorm.</para>

      <para>
	<figure id="vinum-raid10-vol">
	  <title>Een gespiegeld en verdeeld Vinum Volume</title>

	  <graphic fileref="vinum/vinum-raid10-vol">
	</figure>
      </para>

    </sect2>
  </sect1>

  <sect1 id="vinum-object-naming">
    <title>Objectnamen</title>

    <para>Zoals eerder in dit hoofstuk beschreven staat, kent Vinum
      standaardnamen toe aan samenstellingen en subdisks.  Er mag
      echter een andere naam aan gegeven worden.  Een andere naamgeving
      wordt niet aangeraden: ervaring met de VERITAS volume manager,
      die een willekeurige object benaming toestaat, heeft laten zien
      dat deze flexibiliteit geen beduidend voordeel heeft, terwijl het
      de kans op verwarring vergroot.</para>

    <para>Namen mogen bestaan uit alle karakters, behalve de spatie,
      maar het wordt aanbevolen om alleen letters, cijfers en het
      liggende streepje te gebruiken.  De namen van de volumes,
      samenstellingen en subdisks kunnen 64 tekens lang zijn en de
      namen van drives kunnen 32 tekens lang zijn.</para>

    <para>Vinum objecten worden device nodes toegekend in de
      <filename>/dev/vinum</filename> hi&euml;rarchie.  Met de
      configuratie uit de vorige paragraaf cre&euml; Vinum de volgende
      nodes:</para>

    <itemizedlist>
      <listitem>
	<para>De controle devices
	  <filename>/dev/vinum/control</filename> en
	  <filename>/dev/vinum/controld</filename>, die &man.vinum.8;
	  en de Vinum daemon gebruiken.</para>
      </listitem>

      <listitem>
	<para>Blok en karakterdevice instellingen voor elk volume.
	  Dit zijn de primaire devices die door Vinum gebruikt
	  worden.  De blokdevicenamen zijn de namen van het volume,
	  terwijl de karakterdevicenamen de BSD benaming volgen door er
	  de letter <emphasis>r</emphasis> voor te zetten.  De zou de
	  volgende blokdevices bevatten:
	  <filename>/dev/vinum/myvol</filename>,
	  <filename>/dev/vinum/mirror</filename>,
	  <filename>/dev/vinum/striped</filename>,
	  <filename>/dev/vinum/raid5</filename> en
	  <filename>/dev/vinum/raid10</filename>,
	  en de karakterdevices
	  <filename>/dev/vinum/rmyvol</filename>,
	  <filename>/dev/vinum/rmirror</filename>,
	  <filename>/dev/vinum/rstriped</filename>,
	  <filename>/dev/vinum/rraid5</filename> en
	  <filename>/dev/vinum/rraid10</filename>.  Hier zit duidelijk
	  een probleem.  Er kunnen twee volumes te zijn die
	  <emphasis>r</emphasis> en <emphasis>rr</emphasis> heten, maar
	  er ontstaat een confict als device node
	  <filename>/dev/vinum/rr</filename> wordt aangemaakt: is het
	  een karakterdevice voor volume <emphasis>r</emphasis>
	  of een blokdevice voor volume <emphasis>rr</emphasis>?  Nu
	  heeft Vinum geen oplossing.  Het volume dat het eerst gemaakt
	  wordt, krijgt de naam.</para>
      </listitem>

      <listitem>
	<para>Een map <filename>/dev/vinum/drive</filename> met entries
	  voor elke drive.  Deze entries zijn eigenlijk symbolic links
	  naar de bijbehorende schijfnodes.</para>
      </listitem>

      <listitem>
	<para>Een map <filename>/dev/vinum/volume</filename> met
	  entries voor elk volume. Het bevat submappen voor elke
	  samenstelling, die weer submappen voor de subdisks
	  bevatten.</para>
      </listitem>

      <listitem>
	<para>De mappen
	  <filename>/dev/vinum/plex</filename>,
	  <filename>/dev/vinum/sd</filename> en
	  <filename>/dev/vinum/rsd</filename>, die blokdevicenodes
	  bevatten voor elke samenstelling en blok- en
	  karakterdevicenodes voor elke subdisk daarvan.</para>
      </listitem>
    </itemizedlist>

    <para>Dit is een volgend voorbeeld:</para>

    <programlisting>
        drive drive1 device /dev/sd1h
        drive drive2 device /dev/sd2h
        drive drive3 device /dev/sd3h
        drive drive4 device /dev/sd4h
    volume s64 setupstate
      plex org striped 64k
        sd length 100m drive drive1
        sd length 100m drive drive2
        sd length 100m drive drive3
        sd length 100m drive drive4</programlisting>

    <para>Na verwerking maakt &man.vinum.8; de volgende structuur aan
      in <filename>/dev/vinum</filename>:</para>

    <programlisting>
        brwx------  1 root  wheel  25, 0x40000001 Apr 13 16:46 Control
        brwx------  1 root  wheel  25, 0x40000002 Apr 13 16:46 control
        brwx------  1 root  wheel  25, 0x40000000 Apr 13 16:46 controld
        drwxr-xr-x  2 root  wheel      512 Apr 13 16:46 drive
        drwxr-xr-x  2 root  wheel      512 Apr 13 16:46 plex
        crwxr-xr--  1 root  wheel  91,   2 Apr 13 16:46 rs64
        drwxr-xr-x  2 root  wheel      512 Apr 13 16:46 rsd
        drwxr-xr-x  2 root  wheel      512 Apr 13 16:46 rvol
        brwxr-xr--  1 root  wheel  25,   2 Apr 13 16:46 s64
        drwxr-xr-x  2 root  wheel      512 Apr 13 16:46 sd
        drwxr-xr-x  3 root  wheel      512 Apr 13 16:46 vol

      /dev/vinum/drive:
  total 0
  lrwxr-xr-x  1 root  wheel 9 Apr 13 16:46 drive1 -&gt; /dev/sd1h
  lrwxr-xr-x  1 root  wheel 9 Apr 13 16:46 drive2 -&gt; /dev/sd2h
  lrwxr-xr-x  1 root  wheel 9 Apr 13 16:46 drive3 -&gt; /dev/sd3h
  lrwxr-xr-x  1 root  wheel 9 Apr 13 16:46 drive4 -&gt; /dev/sd4h

      /dev/vinum/plex:
  total 0
  brwxr-xr--  1 root  wheel  25, 0x10000002 Apr 13 16:46 s64.p0

      /dev/vinum/rsd:
  total 0
  crwxr-xr--  1 root  wheel  91, 0x20000002 Apr 13 16:46 s64.p0.s0
  crwxr-xr--  1 root  wheel  91, 0x20100002 Apr 13 16:46 s64.p0.s1
  crwxr-xr--  1 root  wheel  91, 0x20200002 Apr 13 16:46 s64.p0.s2
  crwxr-xr--  1 root  wheel  91, 0x20300002 Apr 13 16:46 s64.p0.s3

      /dev/vinum/rvol:
  total 0
  crwxr-xr--  1 root  wheel  91,   2 Apr 13 16:46 s64

      /dev/vinum/sd:
  total 0
  brwxr-xr--  1 root  wheel  25, 0x20000002 Apr 13 16:46 s64.p0.s0
  brwxr-xr--  1 root  wheel  25, 0x20100002 Apr 13 16:46 s64.p0.s1
  brwxr-xr--  1 root  wheel  25, 0x20200002 Apr 13 16:46 s64.p0.s2
  brwxr-xr--  1 root  wheel  25, 0x20300002 Apr 13 16:46 s64.p0.s3

      /dev/vinum/vol:
  total 1
  brwxr-xr--  1 root  wheel  25,   2 Apr 13 16:46 s64
  drwxr-xr-x  3 root  wheel      512 Apr 13 16:46 s64.plex

      /dev/vinum/vol/s64.plex:
  total 1
  brwxr-xr--  1 root  wheel  25, 0x10000002 Apr 13 16:46 s64.p0
  drwxr-xr-x  2 root  wheel      512 Apr 13 16:46 s64.p0.sd

      /dev/vinum/vol/s64.plex/s64.p0.sd:
  total 0
  brwxr-xr--  1 root  wheel  25, 0x20000002 Apr 13 16:46 s64.p0.s0
  brwxr-xr--  1 root  wheel  25, 0x20100002 Apr 13 16:46 s64.p0.s1
  brwxr-xr--  1 root  wheel  25, 0x20200002 Apr 13 16:46 s64.p0.s2
  brwxr-xr--  1 root  wheel  25, 0x20300002 Apr 13 16:46 s64.p0.s3</programlisting>

    <para>Hoewel het wordt aangeraden om samenstellingen en subdisks
      geen naam mee te geven, moeten Vinum drives een naam hebben.
      Hierdoor kan een drive naar een andere locatie verplaatst worden
      terwijl hij nog steeds automatisch herkend wordt.  Drive namen
      mogen maximaal 32 tekens lang zijn.</para>

    <sect2>
      <title>Bestandssystemen Maken</title>

      <para>Volumes lijken voor het systeem identiek aan schijven, met
	&eacute;&eacute;n uitzondering: in tegenstelling tot &unix;
	schijven partitioneert Vinum het volume niet en het bevat dus
	geen partitietabel.  Daarom was het nodig een paar
	disk hulpprogramma's te veranderen, met name &man.newfs.8;, dat
	voorheen probeerde om de laatste letter van een Vinum
	volumenaam als een partitie te zien.  Bijvoorbeeld: een schijf
	kan een naam hebben als <filename>/dev/ad0a</filename> of
	<filename>/dev/da2h</filename>.  Deze namen stellen
	respectievelijk de eerste partitie (<devicename>a</devicename>)
	op de eerste (0) IDE schijf (<devicename>ad</devicename>) en de
	achtste partitie (<devicename>h</devicename>) op de derde (2)
	SCSI schijf (<devicename>da</devicename>) voor.  Een Vinum
	volume kan daarintegen <filename>/dev/vinum/concat</filename>
	heten.  Een naam die geen enkele relatie met een partitienaam
	heeft.</para>

      <para>Normaliter klaagt &man.newfs.8; als het de naam van de
	schijf niet kan interpreteren. Bijvoorbeeld:</para>

      <screen>&prompt.root; <userinput>newfs /dev/vinum/concat</userinput>
        newfs: /dev/vinum/concat: can't figure out file system partition</screen>

      <note>
	<para>Het volgende geldt alleen voor versies van &os;&nbsp;4.X
	  en lager:</para>
      </note>

      <para>Om een bestandsysyteem op dit volume te maken moet de
	<option>-v</option> van &man.newfs.8; gebruikt worden:</para>

      <screen>&prompt.root; <userinput>newfs -v /dev/vinum/concat</userinput></screen>
    </sect2>
  </sect1>

  <sect1 id="vinum-config">
    <title>Vinum Configureren</title>

    <para>De <filename>GENERIC</filename> kernel bevat geen Vinum.  Het
      is mogelijk een kernel te bouwen waar Vinum in zit, maar dit
      wordt niet aangeraden.  De standaard manier om Vinum te starten
      is als kernelmodule (<acronym>kld</acronym>).  Het is zelfs niet
      nodig om &man.kldload.8; te gebruiken voor Vinum.  Als
      &man.vinum.8; wordt gestart en de module is niet geladen, dan
      gebeurt dit alsnog automatisch.</para>

    <sect2>
      <title>Opstarten</title>

      <para>Vinum slaat de configuratie informatie op op de disk slices
	in ongeveer dezelfde vorm als de configuratiebestanden.  Bij
	het lezen van de configuratie database herkent Vinum een aantal
	aleutelwoorden die niet zijn toegestaan in
	configuratiebestanden.  Een diskconfiguratie kan bijvoorbeeld
	de volgende tekst bevatten:</para>

      <programlisting width="119">volume myvol state up
volume bigraid state down
plex name myvol.p0 state up org concat vol myvol
plex name myvol.p1 state up org concat vol myvol
plex name myvol.p2 state init org striped 512b vol myvol
plex name bigraid.p0 state initializing org raid5 512b vol bigraid
sd name myvol.p0.s0 drive a plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p0.s1 drive b plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p1.s0 drive c plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p1.s1 drive d plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p2.s0 drive a plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 0b
sd name myvol.p2.s1 drive b plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 524288b
sd name myvol.p2.s2 drive c plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1048576b
sd name myvol.p2.s3 drive d plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1572864b
sd name bigraid.p0.s0 drive a plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 0b
sd name bigraid.p0.s1 drive b plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 4194304b
sd name bigraid.p0.s2 drive c plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 8388608b
sd name bigraid.p0.s3 drive d plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 12582912b
sd name bigraid.p0.s4 drive e plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 16777216b</programlisting>

      <para>Duidelijke verschillen zijn de aanwezigheid van explicite
	locatie informatie en namen (beide zijn toegestaan, maar worden
	afgeraden) en informatie over de toestand (die niet beschikbaar
	is voor de gebruiker).  Vinum slaat geen informatie over drives
	op in de configuratie: het vindt de drives door de
	geconfigureerde schijven te scannen naar partities met een
	vinum label.  Hierdoor kan Vinum zelfs drives detecteren als ze
	aan een andere &unix; schijf worden toegekend.</para>

      <sect3 id="vinum-rc-startup">
	<title>Automatisch Opstarten</title>

	<para>Om Vinum automatisch te laten starten als het systeem
	  geboot wordt, moet de volgende regel in het
	  <filename>/etc/rc.conf</filename> bestand staan:</para>

	<programlisting>start_vinum="YES"    # set to YES to start vinum</programlisting>

	<para>Als het <filename>/etc/rc.conf</filename> bestand niet
	  bestaat, moet het gemaakt worden met de bovengenoemde inhoud.
	  Hierdoor laadt het systeem de Vinum <acronym>kld</acronym>
	  tijdens het starten en worden de objecten uit de configuratie
	  ook gestart.  Dit gebeurt voordat de bestandssystemen gemount
	  worden.  &man.fsck.8; kan dus automatisch draaien en
	  bestandssystemen op Vinum volumes kunnen gemount
	  worden.</para>

	<para>Als Vinum met <command>vinum start</command> wordt
	  gestart, leest Vinum de configuratie database van
	  &eacute;&eacute;n van de Vinum drives.  Normaal gesproken
	  bevat iedere drive een identieke kopie van de configuratie
	  database.  Het maakt dus niet uit welke drive gelezen wordt.
	  Na een crash moet Vinum echter bepalen welke drive het laatst
	  is bijgewerkt en de configuratie van die drive gebruiken.  Als
	  het nodig is wordt de configuratie van de oudere drives
	  daarna bijgewerkt, in volgorde van leeftijd. </para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="vinum-root">
    <title>Het Root Bestandssysteem op Vinum</title>

    <para>Bij een machine die een volledig gespiegeld bestandssysteem
      heeft, is het wenselijk ook het root bestandssysteem te
      spiegelen.  Het bouwen van zo'n configuratie is niet zo
      recht-toe-recht-aan als bij een ander bestandssysteem
      omdat:</para>

    <itemizedlist>
      <listitem>
	<para>Het root bestandssysteem al heel snel beschikbaar moet
	  zijn tijdens het opstartproces, dus de Vinum infrastructuur
	  moet dan al beschikbaar zijn.</para>
      </listitem>

      <listitem>
	<para>Het volume met het root bestandssysteem bevat ook de
	  bootstrap en de kernel, die gelezen moeten worden door de
	  eigen systeemprogramma's (bijvoorbeeld de BIOS op PC's), die
	  meestal geconfigureerd kunnen worden om Vinum te
	  gebruiken.</para>
      </listitem>
    </itemizedlist>

    <para>In de volgende paragrafen wordt de term
      <quote>root volume</quote> gebruikt voor het Vinum volume dat het
      root bestandssysteem bevat.  Het is waarschijnlijk een goed idee
      om de naam <literal>root</literal> te gebuiken voor dit volume,
      maar dit is niet technisch noodzakelijk.  Alle
      commandovoorbeelden in de volgende stukken gaan echter uit van
      deze naam.</para>

    <sect2>
      <title>Vinum op Tijd Starten voor het root Bestandssysteem</title>

      <para>Om dit te bereiken, moeten een aantal stappen worden
	doorlopen:</para>

      <itemizedlist>
	<listitem>
	  <para>Vinum moet beschikbaar zijn voor de kernel tijdens
	    het opstarten.  De methode zoals beschreven in
	    <xref linkend="vinum-rc-startup"> is dus niet geschikt en
	    de <literal>start_vinum</literal> parameter mag zelfs
	    <emphasis>niet</emphasis> aanwezig zijn als de volgende
	    opzet wordt gebruikt.  De eerste optie is Vinum statisch
	    in de kernel te compileren, zodat het altijd beschikbaar
	    is.  Maar die is vaak niet wenselijk.  Er is nog een
	    mogelijkheid door <filename>/boot/loader</filename>
	    (<xref linkend="boot-loader">) de Vinum kernel module te
	    laten laden, voordat de kernel gestart wordt.  Dit wordt
	    gedaan door de volgende regel in
	    <filename>/boot/loader.conf</filename> op te nemen:</para>

	  <programlisting>vinum_load="YES"</programlisting>
	</listitem>

	<listitem>
	  <para>Vinum moet in een vroeg stadium ge&iuml;nitialiseerd
	    worden om het volume voor het root bestandssysteem te
	    kunnen leveren.  De Vinum kernel module gaat niet uit
	    zichzelf op zoek naar drives die mogelijk een Vinum
	    volume kunnen bevatten totdat de administrator (of een
	    van de opstartscripts) een <command>vinum start</command>
	    commando geeft.</para>

	  <note>
	    <para>De volgende paragrafen laten de benodigde
	      stappen zien voor &os;&nbsp;5.X.  De stappen voor
	      &os;&nbsp;4.X zijn anders, zoals wordt uitgelegd in
	      <xref linkend="vinum-root-4x">.</para>
	  </note>

	  <para>Door de ondestaande regel in
	    <filename>/boot/loader.conf</filename> te zetten, zoekt
	    Vinum automatisch alle drives af naar Vinum informatie als
	    onderdeel van het starten van de kernel:</para>

	  <programlisting>vinum.autostart="YES"</programlisting>

	  <note>
	    <para>Het is dus niet nodig om de kernel te vertellen waar
	      het root bestandssysteem staat.
	      <filename>/boot/loader</filename> zoekt de naam voor het
	      root device op in <filename>/etc/fstab</filename> en geeft
	      deze informatie door aan de kernel.  Op het moment dat het
	      root bestandssysteem gemount moet worden, haalt de kernel
	      uit de devicenaam welke driver gebuikt moet worden om dit
	      te vertalen naar het interne device ID (major/minor
	      number).</para>
	  </note>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Een Vinum Root Volume Beschikbaar Maken voor
	Bootstrap</title>

      <para>Omdat de huidige &os; bootstrap maar 7,5 KB code bevat en
	al belast is met het lezen van bestanden (zoals
	<filename>/boot/loader</filename>) van het UFS bestandssysteem,
	is het bijna onmogelijk om het ook te leren hoe Vinum
	informatie gelezen moet worden en deze dan te gebruiken om de
	elementen van het boot volume samen te stellen.  Er zijn daarom
	een paar trucs nodig om de bootstrap code wijs te maken dat er
	een standaard <literal>"a"</literal> partitie aanwezig is met
	het root bestandssysteem.</para>

      <para>Om dit mogelijk te maken, moet het root volume aan de
	volgende eisen voldoen:</para>

      <itemizedlist>
	<listitem>
	  <para>Het root volume mag niet verdeeld of RAID-5 zijn.</para>
	</listitem>

	<listitem>
	  <para>Het root volume mag niet meer dan &eacute;&eacute;n
	    aaneengeschakelde subdisk per samenstelling
	    bevatten.</para>
	</listitem>
      </itemizedlist>

      <para>Het is mogelijk en wenselijk om meer dan &eacute;&eacute;n
	samenstelling te hebben, ieder met een replica van het root
	bestandssysteem.  Het bootstrap proces gebruikt wel maar
	&eacute;&eacute;n van deze replica's om de bootstrap en alle
	andere bestanden te vinden, tot het moment dat de kernel het
	root bestandssysteem laadt.  Iedere subdisk binnen deze
	samenstellingen heeft dus zijn eigen <literal>"a"</literal>
	partitievoorstelling nodig om dit device bootbaar te maken.
	Het is niet verplicht dat iedere voorgestelde
	<literal>"a"</literal> partitie op dezelfde offset is geplaatst
	binnen het device, vergeleken met andere devices die
	samenstellingen van het root volume bevatten.  Het is wel een
	goed idee om op die manier Vinum volumes te maken, zodat de
	resulterende gespiegelde devices symmetrisch zijn.  Dit om
	verwarring te voorkomen.</para>

      <para>Om deze <literal>"a"</literal> partities voor ieder device
	dat een deel van het root volume bevat te maken, moet het
	volgende worden gedaan:</para>

      <procedure>
	<step>
	  <para>De locatie (offset vanaf het begin van het device) en
	    de grootte van de subdisk die onderdeel is van het root
	    volume moet als volgt bekeken worden:</para>

	  <screen>&prompt.root; <userinput>vinum l -rv root</userinput></screen>

	  <note><para>De Vinum offsets en groottes worden aangegeven in
	    bytes.  Ze moeten door 512 worden gedeeld om de bloknummers
	    te krijgen die in <command>disklabel</command> moeten
	    worden gebruikt.</para></note>
	</step>

	<step>
	  <para>Voor elk device dat deelneemt aan het root
	    bestandssysteem moet het onderstaande command uitgevoerd
	    worden:</para>

	  <screen>&prompt.root; <userinput>disklabel -e <replaceable>devname</replaceable></userinput></screen>

	  <para><replaceable>devname</replaceable> moet of de naam van
	    een disk (zoals <devicename>da0</devicename>) voor schijven
	    zonder slice-tabel zijn (ook wel: fdisk), of de naam van de
	    slice zijn (zoals <devicename>ad0s1</devicename>).</para>

	  <para>Als er al een <literal>"a"</literal> partitie op het
	    device aanwezig is (waarschijnlijk met een pre-Vinum
	    root bestandssysteem), moet die eerst worden hernoemd,
	    zodat het wel toegankelijk blijft (voor de zekerheid), maar
	    niet langer gebruikt wordt om het systeem van op te
	    starten.  Actieve paritities (zoals een root bestandssysteem
	    dat op dit moment gemount is) kan geen andere naam gegeven
	    worden.  Dit moet dus gebeuren als het systeem vanaf een
	    <quote>Fixit</quote> medium opgestart is of in twee
	    stappen, waar (in een gespiegelde situatie) de disk waar
	    niet van geboot is als eerste wordt aangepast.<para>

	  <para>Daarna moet de offset van de Vinum partitie op dit
	    device (als het bestaat) opgeteld worden bij de offset van
	    de root volume subdisk op dit device.  De resulterende
	    waarde wordt de <literal>"offset"</literal> waarde voor de
	    nieuwe <literal>"a"</literal> partitie.  De
	    <literal>"size"</literal> waarde voor deze partitie kan
	    worden gehaald uit bovenstaande berekening.  De
	    <literal>"fstype"</literal> wordt
	    <literal>4.2BSD</literal>.  De <literal>"fsize"</literal>,
	    <literal>"bsize"</literal> en <literal>"cpg"</literal>
	    waardes moeten zo goed mogelijk worden gekozen om een
	    daadwerkelijk bestandssysteem na te bootsen, hoewel ze
	    vrij onbelangrijk zijn in deze context.</para>

	  <para>Op deze manier wordt een nieuwe <literal>"a"</literal>
	    partitie gemaakt dat de Vinum partitie op dit device
	    overlapt.  Het <command>disklabel</command> staat deze
	    overlap alleen toe als de Vinum partitie gemarkeerd is met
	    het fstype <literal>"vinum"</literal>.</para>
	</step>

	<step>
	  <para>Dat is het!  Er bestaat nu een nep
	    <literal>"a"</literal> partitie op ieder device dat een
	    replica van het root volume heeft.  Het is aan te bevelen
	    om de resultaten nogmaals te verifieren met iets
	    als:</para>

	  <screen>&prompt.root; <userinput>fsck -n /dev/<replaceable>devnaam</replaceable>a</userinput></screen>
	</step>
      </procedure>

      <note>
	<para>Alle bestanden die controle informatie bevatten
	  moeten relatief zijn ten opzichte van het root bestandssysteem
	  in het Vinum volume dat, bij het cre&euml;ren van een Vinum
	  volume, niet overeen hoeft te komen met het root
	  bestandssysteem dat op dit moment in gebruik is.  Dit geldt in
	  het bijzonder voor <filename>/etc/fstab</filename> en
	  <filename>/boot/loader.conf</filename>.</para>
      </note>

      <para>Bij de volgende herstart zou de bootstrap de juiste
	controle informatie moeten vinden in het nieuwe, op Vinum
	gebaseerde, root bestandssysteem en moeten starten.  Aan het
	einde van het kernel initialisatie proces, nadat alle devices
	aangemeld zijn, geeft het volgende bericht aan dat het opzetten
	gelukt is:</para>

      <screen>Mounting root from ufs:/dev/vinum/root</screen>
    </sect2>

    <sect2>
      <title>Een op Vinum Gebaseerde Root Setup</title>

      <para>Nadat het Vinum root volume is opgezet, geeft
	<command>vinum l -rv root</command> een volgend
	resultaat:</para>

      <screen>
...
Subdisk root.p0.s0:
                Size:        125829120 bytes (120 MB)
                State: up
                Plex root.p0 at offset 0 (0 B)
                Drive disk0 (/dev/da0h) at offset 135680 (132 kB)

Subdisk root.p1.s0:
                Size:        125829120 bytes (120 MB)
                State: up
                Plex root.p1 at offset 0 (0 B)
                Drive disk1 (/dev/da1h) at offset 135680 (132 kB)</screen>

      <para>De interessante waarden zijn <literal>135680</literal> voor
	de offset (relatief ten opzichte van de partitie
	<filename>/dev/da0h</filename>).  Dit vertaalt zich naar 265
	512-byte disk blocks in <command>disklabel</command>'s termen.
	Zo is de grootte van dit root volume 245760 512-byte blocks.
	<filename>/dev/da1h</filename>, dat de tweede replica van dit
	root volume bevat, is symmetrische opgezet.</para>

      <para>Disklabel voor deze devices kan er zo uitzien:</para>

      <para>
	<screen>
...
8 partitions:
#       size   offset   fstype   [fsize bsize bps/cpg]
  a:   245760     281   4.2BSD     2048 16384    0   # (Cyl.    0*- 15*)
  c: 71771688       0   unused       0    0        # (Cyl.    0 - 4467*)
  h: 71771672      16    vinum                     # (Cyl.    0*- 4467*)</screen>
      </para>

      <para>Hieruit blijkt dat de <literal>"size"</literal> parameter
	voor de nep <literal>"a"</literal> partitie overeenkomt met
	de waarde als hierboven beschreven en dat de
	<literal>"offset"</literal> parameter de som is van de offset
	binnen de Vinum partitie <literal>"h"</literal> en de offset
	van deze partitie binnen het device (of de slice).  Dit is een
	normale opzet om problemen te voorkomen zoals in
	<xref linkend="vinum-root-panic"> beschreven is.  Verder blijkt
	dat de hele <literal>"a"</literal> partitie volledig binnen de
	<literal>"h"</literal> partitie valt die alle Vinum data voor
	dit device bevat.</para>

      <para>In het bovenstaande voorbeeld is de volledige schijf voor
	Vinum gereserveerd en er is geen restant van de pre-Vinum root
	partitie, omdat dit een nieuwe schijf is die vanaf het begin af
	aan bedoeld was als onderdeel van een Vinum
	configuratie.</para>
    </sect2>

    <sect2>
      <title>Problemen Oplossen</title>

      <para>Als er iets fout gaat moet er een manier zijn om dat te
	herstellen.  De volgende lijst bevat een paar bekende valkuilen
	en oplossingen.</para>

      <sect3>
	<title>Systeem Bootstrap Laadt, Maar Systeem Start Niet
	  Door</title>

	<para>Als om wat voor reden dan ook het systeem niet doorgaat
	  met opstarten, kan de bootstrap worden onderbroken door de
	  <keycap>spatie</keycap> toets in te drukken tijdens de 10
	  seconden waarschuwing.  Dan kunnen de loader variabelen
	  (zoals <literal>vinum.autostart</literal>) bekeken worden
	  met behulp van <command>show</command> en aangepast worden
	  met <command>set</command> of
	  <command>unset</command>.</para>

	<para>Als het enige probleem was dat de Vinum kernel module
	  nog niet in de lijst van modules staat die automatisch
	  geladen wordt, dan moet <command>load vinum</command>
	  voldoende zijn.</para>

	<para>Als alles in orde is, kan het bootproces doorgestart
	  worden met <command>boot -as</command>.  De opties
	  <option>-as</option> geven de kernel aan om het root
	  bestandssysteem te vragen (<option>-a</option>),
	  en het boot proces te stoppen in single-user mode
	  (<option>-s</option>), waarbij het root bestandssysteem
	  als read-only gemount wordt.  Op die manier is er geen
	  risico op data inconsistentie tussen de samenstellingen,
	  zelfs niet als er maar &eacute;&eacute;n samenstelling van
	  een multi-samenstellingen volume gemount is.</para>

	<para>Op de prompt, waar om het root bestandssysteem gevraagd
	  wordt, kan ieder device dat een valide root bestandssysteem
	  bevat worden opgegeven.  Als <filename>/etc/fstab</filename>
	  goed is opgezet, is iets als
	  <literal>ufs:/dev/vinum/root</literal> te zien.  Een andere
	  keuze kan <literal>ufs:da0d</literal> zijn, dat een
	  hypothetische partitie is die het pre-Vinum root
	  bestandssysteem bevat.  Als &eacute;&eacute;n van de alias
	  <literal>"a"</literal> partities ingevuld wordt die
	  eigenlijk een referentie naar de subdisk van het Vinum root
	  device zijn, dan wordt in een gespiegelde setup maar
	  &eacute;&eacute; kant van het gespiegelde volume gemount.
	  Als dit bestandssysteem later als read-write gemount wordt,
	  moet(en) de andere samenstelling(en) van het root volume
	  verwijderd worden, omdat deze samenstellingen anders
	  inconsistente data bevatten.</para>
      </sect3>

      <sect3>
	<title>Alleen Primaire Bootstrap Laadt</title>

	<para>Als <filename>/boot/loader</filename> niet start, maar
	  de primaire bootstrap laadt wel (zichtbaar door een enkel
	  minnetje in de linker bovenhoek van het scherm, direct na de
	  start van het boot proces), kan worden geprobeerd het
	  primaire boot proces te onderbreken door op de
	  <keycap>spatie</keycap> toets te drukken.  Dit zorgt ervoor
	  dat het boot proces stopt bij de tweede fase (zie ook
	  <xref linkend="boot-boot1">).  Hier kan worden geprobeerd
	  vanaf een andere partitie te starten, bijvoorbeeld van de
	  partitie waar het vorige root bestandssysteem op stond, dat
	  nu van de <literal>"a"</literal> verplaatst is.</para>
      </sect3>

      <sect3 id="vinum-root-panic">
	<title>Niets start, Paniek van Bootstrap</title>

	<para>Dit gebeurt als de bootstrap is vernietigd door de Vinum
	  installatie.  Helaas laat Vinum op dit moment slechts 4 KB
	  vrij aan het begin van zijn paritie voordat de Vinum volume
	  identificatie geschreven wordt.  De stage 1 en 2 bootstraps
	  en de disklabel informatie hebben ongeveer 8 KB nodig.  Dus
	  als de Vinum partitie op offset 0 van de slice van de schijf
	  begint die als bootbaar was bedoeld, zal deze Vinum
	  informatie de bootstrap vernielen.</para>

	<para>Als bovenstaande situatie is omzeild, bijvoorbeeld door
	  te starten vanaf een <quote>Fixit</quote> medium, en de
	  bootstrap opnieuw is aangemaakt met
	  <command>disklabel -B</command> zoals beschreven in
	  <xref linkend="boot-boot1">, overschrijft de nieuwe bootstrap
	  de Vinum identificatie en kan Vinum de Vinum disks niet
	  langer vinden.  Hoewel geen Vinum configuratie data of
	  data in de Vinum volumes overschreven wordt en alle data
	  hersteld kan worden door precies dezelfde Vinum configuratie
	  data opnieuw in te vullen, is dit een lastige situatie om te
	  herstellen.  Het zou nodig zijn om de complete Vinum
	  parititie tenminste 4&nbsp;KB te verplaatsen, om te voorkomen
	  dat de Vinum identificatie en de bootstrap met elkaar
	  botsen.</para>
      </sect3>
    </sect2>

    <sect2 id="vinum-root-4x">
      <title>Verschillen met &os;&nbsp;4.X</title>

      <para>In &os;&nbsp;4.X missen sommige interne functies die nodig
	zijn om Vinum automatisch alle disks te laten scannen en de code
	die het interne ID van de root device achterhaalt is niet slim
	genoeg om met een naam als <filename>/dev/vinum/root</filename>
	om te gaan.  Daarom zijn er een paar verschillen ten opzichte
	van &os;&nbsp;5.X.</para>

      <para>Vinum moet expliciet verteld worden welke disks bekeken
	moeten worden door iets als het volgende in
	<filename>/boot/loader.conf</filename>:</para>

      <programlisting>vinum.drives="/dev/<replaceable>da0</replaceable> /dev/<replaceable>da1</replaceable>"</programlisting>

      <para>Het is belangrijk dat alle schijven die Vinum data kunnen
	bevatten genoemd worden.  Het maakt niet uit of er
	<emphasis>meer</emphasis> schijven genoemd worden en het is ook
	niet nodig om iedere slice en/of partitie expliciet op te
	geven, omdat Vinum alle slices en paritities van de genoemde
	schijven afgaat voor valide Vinum identificatie
	informatie.</para>

      <para>Omdat de routines die de naam van het root bestandssysteem
	verwerken en daar het device ID (major/minor nummers) uit halen
	alleen maar met de <quote>klassieke</quote> devicenamen als
	<filename>/dev/ad0s1a</filename> overweg kunnen, kunnen ze
	niets maken van een root volume naam als
	<filename>/dev/vinum/root</filename>.  Daarom moet Vinum zelf
	de interne kernel parameter dat het ID van het root volume
	bevat aanpassen tijdens zijn eigen initialisatie.  Dit gaat
	door de naam van het root volume op te geven in de loader
	variable <literal>vinum.root</literal>.  Dit ziet er in
	<filename>/boot/loader.conf</filename> zo uit:</para>

      <programlisting>vinum.root="root"</programlisting>

      <para>Als de kernel initialisatie probeert uit te vinden welk
	root device gemount moet worden, ziet het dat sommige
	kernelmodules al parameters gezet hebben.  In dat geval
	<emphasis>en</emphasis> als het device dat het root device
	claimt hetzelfde major nummer heeft als de driver die gevonden
	is uit de naam van het root device (<literal>Vinum</literal> in
	dit geval), dan gebruikt het het van te voren gedefinieerde
	device ID, in plaats van het zelf proberen uit te vinden.  Zo
	kan het normale automatische boot process doorgaan met het
	mounten van het Vinum root volume voor het root
	bestandssysteem.</para>

      <para>Maar als <command>boot -a</command> is gegeven om de naam
	van het root device te vragen, kan het nog steeds niet overweg
	met een naam die refereert aan een Vinum volume.  Als er een
	devicenaam is gegeven die niet refereert aan een Vinum device,
	dan zorgt het verschil tussen de major nummers van de van te
	voren ingestelde root parameter en de driver zoals die uit de
	gegeven naam wordt afgeleid ervoor dat deze routine zijn eigen
	afgeleide naam gebruikt.  Invoer als
	<literal>ufs:da0d</literal> werkt zoals verwacht.  Als dit
	mislukt, is het niet meer mogelijk om nogmaals iets als
	<literal>ufs:vinum/root</literal> in te voeren, omdat het
	niet een tweede keer verwerkt kan worden.  De enige uitweg is
	het systeem opnieuw te starten en opnieuw te beginnen.  Op de
	<quote>askroot</quote> prompt kan <filename>/dev/</filename>
	altijd achterwege gelaten worden.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
