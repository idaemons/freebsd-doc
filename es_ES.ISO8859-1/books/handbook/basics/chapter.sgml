<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->

<chapter id="basics">
  <title>Conceptos B&aacute;sicos de Unix</title>
  
  <sect1>
    <title>Sin&oacute;psis</title>

    <para><emphasis>Reescrito por Chris Shumway
      <email>cshumway@osd.bsdi.com</email>, 10 Mar 2000.</emphasis></para>

	<para>El siguiente cap&iacute;tulo cubre la funcionalidad y
	  &oacute;rdenes b&aacute;sicas del sistema operativo FreeBSD. Si se es
	  nuevo en FreeBSD, seguramente querr&aacute; leer este cap&iacute;tulo
	  antes de buscar ayuda.</para>



  </sect1>

  <sect1 id="permissions">
    <title>Permisos</title>

	<para>FreeBSD, cuya raiz hist&oacute;rica es el UNIX BSD, tiene
	  sus fundamentos basados en varios conceptos clave de UNIX. El primero, y
	  m&aacute;s remarcado, es que FreeBSD es un sistema operativo
	  multi-usuario.  El sistema puede manejar varios usuarios trabajando
	  todos simult&aacute;neamente y en tareas que no guardan relaci&oacute;n
	  entre sí. El sistema es el responsable de compartir y administrar
	  peticiones de dispositivos de hardware, perif&eacute;ricos, memoria y
	  tiempo de Unidad Central de Proceso (CPU) de manera equitativa para cada
	  usuario.</para>   


	<para>Debido a que el sistema es capaz de soportar m&uacute;ltiples
	  usuarios, todo lo que el sistema administra tiene un conjunto de
	  permisos que gobiernan qui&eacute;n puede leer, escribir y ejecutar el
	  elemento. Estos permisos se guardan como octetos divididos en tres
	  partes: una para el propietario del archivo, otra para el grupo al que
	  el archivo pertenece, y otra para cualquier otro. Esta
	  representaci&oacute;n num&eacute;rica funciona as&iacute;:</para>




    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Valor</entry>
	    <entry>Permiso</entry>
	    <entry>Listado de Directorio</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>No leer, no escribir, no ejecutar</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>No leer, no escribir, ejecutar</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>No leer, escribir, no ejecutar</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>No leer, escribir, ejecutar</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Leer, no escribir, no ejecutar</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Leer, no escribir, ejecutar</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Leer, escribir, no ejecutar</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Leer, escribir, ejecutar</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

	<para>Si se muestra un listado expandido de directorio mediante
	  <command>ls -l</command>, se mostrar&aacute;n en una columna los
	  permisos de fichero para el propietario, grupo y todos los dem&aacute;s.
	  Veamos como se descompone:</para>

    <screen>-rw-r--r--</screen>

	<para>El primer car&aacute;cter, de izquierda a derecha, es un
	  car&aacute;cter especial que indica si se trata de un archivo normal, un
	  directorio, un dispositivo especial de tipo car&aacute;cter o bloque, un
	  socket, o cualquier otro dispositivo de pseudo-archivo. Los siguientes
	  tres caracteres, expresados como <literal>rw-</literal> muestran los
	  permisos para el propietario del archivo. Los siguientes tres
	  caracteres, <literal>r--</literal> muestran los permisos para el grupo
	  al que el archivo pertenece.  Los &uacute;ltimos tres caracteres,
	  <literal>r--</literal>, muestran los permisos para el resto del mundo.
	  Un gui&oacute;n indica que el permiso est&aacute; desactivado.  En el
	  caso de este archivo, los permisos est&aacute;n asignados de tal manera
	  que el propietario puede leer y escribir en el archivo, el grupo puede
	  leer el archivo, y el resto del mundo s&oacute;lo puede leer el archivo.
	  De acuerdo con la tabla que se muestra m&aacute;s arriba, los permisos
	  para este archivo ser&iacute;an <literal>644</literal>, donde cada cifra
	  representa las tres partes de los permisos del archivo.</para>


	<para>Todo &eacute;sto est&aacute; muy bien, pero &iquest;c&oacute;mo
	  controla el sistema los permisos de los dispositivos? FreeBSD en
	  realidad trata la mayor&iacute;a de los dispositivos hardware como un
	  archivo que los programas pueden abrir, leer y en los que pueden
	  escribir datos como si de cualquier otro archivo se tratara. Estos
	  archivos especiales de dispositivos se encuentran en el directorio
	  <filename>/dev</filename>.</para>

	<para>Los directorios tambi&eacute;n son tratados como archivos. Tienen
	  permisos de lectura, escritura y ejecuci&oacute;n. El bit de
	  ejecuci&oacute;n en un directorio tiene un significado
	  lig&eacute;ramente distinto que para los archivos. Cuando un directorio
	  est&aacute; marcado como ejecutable significa que se puede mirar dentro,
	  por ejemplo, se podr&iacute;a hacer un listado de ese directorio.</para> 

	<para>Hay m&aacute;s permisos, pero se usan principalmente en
	  circunstancias especiales como los binarios ejecutables de tipo "setuid"
	  y los los directorios de tipo "sticky". Si desea m&aacute;s
	  informaci&oacute;n acerca de los permisos de archivos y c&oacute;mo
	  establecerlos, aseg&uacute;rese de mirar la p&aacute;gina de manual de
	  &man.chmod.1;.</para> 
  </sect1>

  <sect1 id="dirstructure">
    <title>Estructura de directorios</title>
	<para>Como FreeBSD utiliza sus sistemas de archivos (file systems) para
	  determinar muchas operaciones fundamentales en el sistema, la
	  jerarqu&iacute;a del sistema de archivos es extremadamente importante.
	  Dado que la p&aacute;gina de manual de &man.hier.7; proporciona una
	  descripci&oacute;n completa de la estructura de directorios, no la vamos
	  a repetir aqu&iacute;. Para m&aacute;s informaci&oacute;n, puede
	  consultar &man.hier.7;.</para>

	<para>De una especial importancia es el raiz (root) de todos los
	  directorios, el directorio /. Este directorio es el primero en ser
	  montado al arrancar y contiene contiene el sistema b&aacute;sico
	  necesario a la hora de iniciar. El directorio raiz tambi&eacute;n
	  contiene puntos de montaje para cualquier otro sistema de archivos que
	  se desee montar.</para>
 
	<para> Un punto de montaje es un directorio donde se pueden injertar al
	  sistema de archivos raiz otros sistemas de ficheros adicionales. Los
	  puntos de montaje convencionales incluyen <filename>/usr</filename>,
	  <filename>/var</filename>, <filename>/mnt</filename> y
	  <filename>/cdrom</filename>. Estos directorios directorios se
	  corresponden habitualmente con entradas en en archivo
	  <filename>/etc/fstab</filename>. <filename>/etc/fstab</filename> es una
	  tabla que sirve como referencias al sistema y contiene los diferentes
	  sistemas de archivos y sus respectivos puntos de montaje. La
	  mayor&iacute;a de los sistemas de archivos que figuran en
	  <filename>/etc/fstab</filename> son montados autom&aacute;ticamente al
	  arrancar por el gui&oacute;n de &oacute;rdenes (script) &man.rc.8; a no
	  ser que contengan la opci&oacute;n <option>noauto</option>.
	  Cons&uacute;ltese la p&aacute;gina del manual &man.fstab.5; para
	  m&aacute;s informaci&oacute;n acerca del formato del archivo
	  <filename>/etc/fstab</filename> y de las opciones que se pueden
	  especificar.</para>       

  </sect1>

  <sect1 id="shells">
    <title>Int&eacute;rpretes de &oacute;rdenes (Shells)</title>

	<para>En FreeBSD, gran parte del trabajo diario se realiza a trav&eacute;s
	  de un interfaz de la linea de &oacute;rdenes llamado "shell". El
	  principal trabajo del shell es recoger &oacute;rdenes del canal de
	  entrada y ejecutarlas.  Muchos shells tienen tambi&eacute;n integradas
	  funciones para ayudarnos en las tareas cotidianas tales como la
	  manipulaci&oacute;n de archivos, edici&oacute;n de l&iacute;neas de
	  &oacute;rdenes, macros de &oacute;rdenes, expansi&oacute;n de
	  expresiones regulares en nombres de archivo y variables del sistema.
	  FreeBSD viene con un conjunto de shells, como sh, el shell Bourne y csh,
	  el shell C. Hay disponibles muchos otros shells en la "FreeBSD Ports
	  Collection" que son mucho m&aacute;s potentes, como bash y tcsh.</para>

	<para>&iquest;Qu&eacute; shell usar? Es cuesti&oacute;n de gustos. Si se
	  es programador de C se puede sentir m&aacute;s c&oacute;modo con tcsh,
	  un shell con una sintaxis similar al C. Si se proviene del mundo Linux o
	  se es nuevo en el interfaz de &oacute;rdenes de Unix, se puede probar
	  con bash. El asunto es que cada shell posee unas propiedades
	  &uacute;nicas que pueden o no funcionar con el entorno de trabajo
	  preferido y se ha de efectuar una elecci&oacute;n sobre el shell a
	  usar.</para>

	<para>Una de las propiedades comunes de un shell es que completa los
	  nombres de archivo. Dada la introducci&oacute;n de las primeras letras
	  de una orden o del nombre de un archivo, se puede hacer que el shell
	  complete autom&aacute;ticamente el resto de la orden o el nombre del
	  archivo pulsando la tecla TAB.  Aqu&iacute; va un ejemplo. Supongamos
	  que se tienen dos archivos llamados <filename>foobar</filename> y
	  <filename>foo.bar</filename>. Se quiere borrar
	  <filename>foo.bar</filename>. Lo que habr&iacute;a que teclear es:
	  <command>rm fo[TAB].[TAB]</command>.</para> 

	<para>El shell nos mostrar&iacute;a <command>rm
	  foo[BEEP].bar</command>.</para>


	<para>El [BEEP] es el pitido de consola (<emphasis>console
	  bell</emphasis>): es el shell dici&eacute;ndonos que fue incapaz de
	  completar totalmente el nombre de archivo porque hay m&aacute;s de una
	  coincidencia. Tanto <filename>foobar</filename> como
	  <filename>foo.bar</filename> comienzan por <literal>fo</literal>, pero
	  solo se pudo completar hasta <literal>foo</literal>.  Si se teclea
	  <literal>.</literal>, y de nuevo TAB, el shell ser&aacute; capaz de
	  introducir el resto del nombre por nosotros.</para>

	<para>Otra funci&oacute;n del shell son las variables de entorno.  Las
	  variables de entorno son parejas de valores clave almacenados en el
	  espacio de entorno del shell. Este espacio puede ser le&iacute;do por
	  cualquier programa invocado por el shell y, por tanto, en él se
	  encuentra bastante informaci&oacute;n relativa a la configuraci&oacute;n
	  de programas. Lo siguiente es una lista de las variables de entorno
	  m&aacute;s comunes y su significado:</para> 

    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Descripci&oacute;n</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Nombre de usuario con el que se ha entrado al sistema.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Lista de directorios, separada por puntos y coma, en los que
		  se busca ejecutables.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
		<entry>Nombre en la red de la pantalla de X11 a la que conectarse, si
		  se encuentra disponible.</entry>	
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>El shell actual.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>El nombre del terminal del usuario. Se usa para determinar
		  las posibilidades del terminal de datos.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Base de datos donde encontrar los c&oacute;digos de
		  escape necesarios para realizar diferentes funciones en el
		  terminal.</entry>  
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Tipo de sistema operativo. Por ejemplo, FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Arquitectura de la CPU en la que el sistema se
		  est&aacute; ejecutando.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>El editor de texto preferido por el usuario.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>El paginador de texto preferido por el usuario.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
		<entry>Lista de directorios en los que se busca p&aacute;ginas de
		  manual, separados por puntos y coma.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

	<para>Visualizar o establecer una variable de entorno difiere ligeramente
	  de shell a shell. Por ejemplo, en los shells al estilo C como tcsh y
	  csh, se usar&iacute;a <command>setenv</command> para establecer y
	  visualizar las variables de entorno actuales. Siguiendo el ejemplo, para
	  establecer o modificar el valor de <envar>EDITOR</envar>, bajo csh o
	  tcsh una orden como la siguiente establecer&iacute;a el valor de
	  <envar>EDITOR</envar> a <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Bajo los shells tipo Bourne (Bourne Shells):</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

	<para>Tambi&eacute;n se puede hacer que la mayor&iacute;a de los shells
	  muestren el contenido de una variable de entorno situando el
	  car&aacute;cter <literal>$</literal> delante del nombre de la variable
	  desde la l&iacute;nea de &oacute;rdenes. Por ejemplo, <command>echo
	  $TERM</command> mostrar&aacute; cualquiera que sea el valor que se le
	  haya establecido a <envar>TERM</envar>, porque el shell expande el valor
	  de <envar>TERM</envar> y se lo pasa al programa echo.</para>

	<para>Los shells manejan muchos caracteres especiales, llamados
	  meta-caracteres, como representaciones especiales de datos. El mas
	  com&uacute;n es el car&aacute;cter <literal>*</literal>, que representa
	  cualquier n&uacute;mero de caracteres en un nombre de archivo. Estos
	  meta-caracteres especiales se pueden usar para la expansi&oacute;n de
	  nombres de archivos. Por ejemplo, teclear <command>echo *</command> es
	  casi lo mismo que introducir <command>ls</command> porque el shell
	  recoge todos los archivos que coinciden con <command>*</command> y se
	  los pone en la l&iacute;nea de &oacute;rdenes a echo para que los
	  vea.</para>

	<para>Para evitar que el shell interprete estos caracteres especiales, se
	  pueden salvar poniendo el car&aacute;cter contrabarra
	  (<literal>\</literal>) delante de ellos. <command>echo $TERM</command>
	  muestra cualquiera que sea el valor establecido para el terminal que
	  estamos usando. <command>echo \$TERM</command> muestra
	  <envar>$TERM</envar> tal cual.</para>

    <sect2 id="changing-shells">
      <title>Cambiando de shell</title>


	<para>La manera m&aacute;s f&aacute;cil de cambiar de shell es usando la
	  orden <command>chsh</command>. Al ejecutar <command>chsh</command> se
	  nos situar&aacute; dentro del editor de texto que figure en la variable
	  de entorno <envar>EDITOR</envar> o, de no estar configurada, se nos
	  abrir&aacute; <command>vi</command>. C&aacute;mbiese la l&iacute;nea
	  <quote>Shell:</quote> adecuadamente.</para>  

	<para>Tambi&eacute;n se le puede suministrar a <command>chsh</command> la
	  opci&oacute;n <option>-s</option>; &eacute;sto establecer&aacute; el
	  shell por nosotros sin necesidad de entrar en el editor de texto.  Por
	  ejemplo, si se desea cambiar el shell a bash, lo siguiente
	  realizar&aacute; el ajuste:</para> 

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

	<para>Ejecutar <command>chsh</command> sin par&aacute;metros y cambiar el
	  shell desde all&iacute; tambien funcionar&iacute;a.</para>

      <note>
	<para>El shell que se desee usar <emphasis>debe</emphasis> figurar en el
	  archivo <filename>/etc/shells</filename>. Si se ha instalado un shell
	  desde la <link linkend="ports">colecci&oacute;n de ports</link>,
	  entonces esto ya se habr&aacute; realizado. Si se ha instalado
	  manualmente el shell, se debe realizar el cambio pertinente.</para>

	<para>Por ejemplo, si se instal&oacute; manualmente
	  <command>bash</command> y se situ&oacute; en
	  <filename>/usr/local/bin</filename>, deber&iacute;a hacer:

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

	<para>Y entonces volver a ejecutar <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Editores de texto</title>
	<para>Gran parte de la configuraci&oacute;n de FreeBSD se realiza
	  modificando archivos de texto. A causa de esto, es una buena idea
	  familiarizarse con un editor de texto. FreeBSD viene con unos cuantos
	  como parte del sistema base y muchos m&aacute;s se encuentran
	  disponibles en la colecci&oacute;n de ports.</para>

	<para>El editor de textos m&aacute;s f&aacute;cil y r&aacute;pido de
	  aprender es uno llamado <application>ee</application>, cuyo nombre
	  proviene del ingl&eacute;s "easy editor" (editor f&aacute;cil). Para
	  iniciar <application>ee</application> se deber&iacute;a teclear en la
	  l&iacute;nea de &oacute;rdenes <command>ee filename</command>, donde
	  <literal>filename</literal> es el nombre del archivo que deseamos
	  editar.  Por ejemplo, para editar <filename>/etc/rc.conf</filename>,
	  tecl&eacute;ese <command>ee /etc/rc.conf</command>. Una vez dentro de
	  ee, todas las posibles &oacute;rdenes para manipular las funciones del
	  editor se presentan en la parte superior de la pantalla. El
	  car&aacute;cter acento circunflejo <literal>&#94;</literal> representa a
	  la tecla de control en el teclado, o sea que &#94;e significa pulsar
	  simult&aacute;neamente la tecla control y la letra <literal>e</literal>.
	  Para abandonar <application>ee</application>, se debe pulsar la tecla
	  escape y elegir abandonar (leave) el editor. El editor preguntar&aacute;
	  entonces si se desean conservar los cambios si el archivo hubiera sido
	  modificado.</para>

	<para>FreeBSD viene tambi&eacute;n con editores de texto mucho m&aacute;s
	  potentes.  Por ejemplo, <application>vi</application> como componente
	  del sistema b&aacute;sico y <application>emacs</application> o
	  <application>vim</application> como parte de la colecci&oacute;n de
	  ports. Estos editores ofrecen mucha m&aacute;s funcionalidad y potencia
	  a expensas de un aprendizaje un poco m&aacute;s complicado. De cualquier
	  manera, si se planea editar muchos textos, aprender un editor m&aacute;s
	  potente como <application>vim</application> o
	  <application>emacs</application> le ahorrar&aacute; mucho tiempo a largo
	  plazo.</para>
  </sect1>

  <sect1>
    <title>Para m&aacute;s informaci&oacute;n</title>

    <sect2 id="basics-man">
      <title>P&aacute;ginas de manual</title>

	<para>La documentaci&oacute;n m&aacute;s exhaustiva de FreeBSD se
	  encuentra en la forma de p&aacute;ginas de manual. Casi todos los
	  programas del sistema vienen con un sucinto manual de referencia
	  explicando el funcionamiento b&aacute;sico y los diferentes argumentos.
	  Estos manuales pueden ser revisados con el programa man. El uso del
	  programa man es sencillo:</para>

      <screen>&prompt.user; <userinput>man <replaceable>command</replaceable></userinput></screen>

	<para><literal>command</literal> es el nombre del programa del que se
	  quiere saber algo. Por ejemplo, para saber algo acerca del programa
	  <command>ls</command> tecl&eacute;ese:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

	<para>El manual en l&iacute;nea est&aacute; dividido en secciones
	  numeradas:</para>

      <orderedlist>
	<listitem>
	  <para>&Oacute;rdenes/programas de usuario.</para>
	</listitem>

	<listitem>
	  <para>LLamadas de sistema y c&oacute;digos num&eacute;ricos de
	    error.</para> </listitem>

	<listitem>
	  <para>Funciones de las librer&iacute;as de C.</para>
	</listitem>

	<listitem>
	  <para>Manejadores de Dispositivos.</para>
	</listitem>

	<listitem>
	  <para>Formatos de Archivos.</para>
	</listitem>

	<listitem>
	  <para>Juegos y otros divertimentos.</para>
	</listitem>

	<listitem>
	  <para>Informaci&oacute;n miscel&aacute;nea.</para>
	</listitem>

	<listitem>
	  <para>Programas relativos al mantenimiento y operación del
	    sistema.</para>
	</listitem>

	<listitem>
	  <para>Desarrolladores del Kernel.</para>
	</listitem>
  </orderedlist>

	<para>En algunos casos, el mismo ep&iacute;grafe puede aparecer en
	  m&aacute;s de una secci&oacute;n del manual en l&iacute;nea. Hay, por
	  ejemplo, un programa de usuario llamado chmod y una llamada de sistema
	  <literal>chmod()</literal>.  En este caso se le puede especificar a man
	  cu&aacute;l se desea especificando la secci&oacute;n:</para>


      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

	<para>Esto nos mostrar&aacute; la p&aacute;gina del manual en l&iacute;nea
	  del programa de usuario <command>chmod</command>.  Las referencias a una
	  secci&oacute;n concreta del manual en l&iacute;nea se sit&uacute;an
	  tradicionalmente entre par&eacute;ntesis en la documentaci&oacute;n
	  impresa, de tal manera que &man.chmod.1; se refiere al programa de
	  usuario <command>chmod</command> y &man.chmod.2; se refiere a la llamada
	  de sistema.</para>

    <para>Esto est&aacute; muy bien si se conoce el nombre del programa y
	  simplemente se quiere saber c&oacute;mo usarlo. Pero, &iquest;qu&eacute;
	  si se recuerda el nombre del programa? Se puede usar man para que
	  realice una b&uacute;squeda mediante palabras clave en las descripciones
	  de programas usando el argumento <option>-k</option>:</para>

    <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

    <para>Con esta orden se nos mostrar&aacute; una lista de programas que
	  contienen la palabra clave <quote>mail</quote> en sus descripciones.
	  &Eacute;sto equivale a usar el programa apropos.</para>

	<para>Si se est&aacute; mirando todos esos curiosos programas que residen
	  en <filename>/usr/bin</filename> y no se tiene ni pu&ntilde;etera idea
	  de que narices hacen realmente, h&aacute;gase un sencillo:</para> 

    <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

    <para>o</para>

    <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

    <para>que hace exactamente lo mismo.</para>
  </sect2>

  <sect2 id="basics-info">
    <title>Archivos de informaci&oacute;n GNU</title>

	<para>FreeBSD incluye muchas aplicaciones y utilidades producidas por la
	  Free Software Foundation (FSF). De manera adicional a las p&aacute;ginas
	  de manual estos programas vienen con documentos de hipertexto m&aacute;s
	  detallados, llamados archivos <literal>info</literal>, que pueden ser
	  revisados con el programa <command>info</command> o, si se ha instalado
	  <application>emacs</application>, el modo "info" de
	  <application>emacs</application>.</para>

	<para>Para usar el programa &man.info.1; simplemente
	  tecl&eacute;ese:</para>  

      <screen>&prompt.user; <userinput>info</userinput></screen>

	<para>Para una descripci&oacute;n breve, tecl&eacute;ese
	  <literal>h</literal>.  Para una referencia r&aacute;pida de un programa,
	  tecl&eacute;ese <literal>?</literal>.</para> 
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

