<!-- $Id: serial.sgml,v 1.3 1998-11-26 22:33:33 nik Exp $ -->
<!-- The FreeBSD Documentation Spanish Project -->
  <sect>
    <heading>Comunicaciones serie<label id="serial"></heading>

    <p>Esta seccion responde las preguntas mas frecuentes sobre las
    comunicaciones serie con FreeBSD. PPP y SLIP se tratan en la
    seccion <ref id="networking" name="Networking">.

    <sect1>
      <heading>Como se si FreeBSD ha encontrado mis puertos serie?</heading>

      <p>Cuando el kernel de FreeBSD arranca, testeara los puertos serie
      del sistema que esten configurados en el kernel. Puedes estar atento
      a los mensajes de la consola o ejecutar el comando:

      <verb>
        dmesg | grep sio
      </verb>

      <p>una vez el sistema este en funcionamiento.

      <p>Aqui tienes un ejemplo del resultado de la ejecucion del comando:

      <verb>
        sio0 at 0x3f8-0x3ff irq 4 on isa
        sio0: type 16550A
        sio1 at 0x2f8-0x2ff irq 3 on isa
        sio1: type 16550A
      </verb>

      <p>Esto muestra dos puertos serie. El primero en la irq 4 usando
      la direccion <tt/0x3f8/, y tiene una UART 16550A. El segundo usa
      el mismo tipo de chip pero esta en la irq 3 y usa la direccion
      <tt/0x2f8/. Los modems internos son tratados como puertos serie,
      esceptuando que siempre tienen un modem adjuntado al puerto.

      <p>El kernel <tt/GENERIC/ incluye soporte para dos puertos serie
      usando la misma irq y direccion que en el ejemplo anterior. Si estas
      opciones no son correctar para tu sistema, o si has anyadido modems
      internos o tienes mas puertos serie de los que estan configurados en
      el kernel, solo tienes que reconfigurar el kernel. Mira en la seccion
      <ref id="make-kernel" name="about building a kernel"> para mas detalles.

    <sect1>
      <heading>Como se si FreeBSD ha encontrado mi modem interno?</heading>

      <p>Respondido en la seccion anterior.

    <sect1>
      <heading>He actualizado a 2.0.5 y mi <tt/tty0X/ no existen!</heading>

      <p>No te preocupes, han sido integrados en los dispositivos <tt/ttydX/.
      Tendras que modificar algunos ficheros antiguos de configuracion.

    <sect1>
      <heading>Como accedo a los puertos serie en FreeBSD?</heading>

      <p>El tercer puerto serie, <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?sio" name="sio2"> (conocido
      como COM3 en DOS), esta en <tt>/dev/cuaa2</tt> para dispositivos de
      salida (dial-out) y en <tt>/dev/ttyd2</tt> para dispositivos de
      entrada (dial-in). Cual es la diferencia entre estas dos clases de
      dispositivos?.

      <p>Usas los <tt/ttydX/ para los entrantes. Al abrir <tt>/dev/ttydX</tt>
      en "blocking mode", un proceso esperara para que el dispositivo
      <tt/cuaaX/ correspondiente se vuelva inactivo. Cuando abres un
      dispositivo <tt/cuaaX/, se asegura de que el puerto serie no esta
      en uso por un dispositivo <tt/ttydX/. Si el puerto esta disponible,
      se lo "roba" al dispositivo <tt/ttydX/. Al mismo tiempo, el dispositivo
      <tt/cuaaXX/ no se preocupa de la deteccion de portadora. Con este
      esquema, y un modem en respuesta automatica, puedes recibir usuarios
      remotos y puedes hacer conexiones externas con el mismo modem, mientras
      el sistema se preocupa de evitar los posible conflictos.

    <sect1>
      <heading>Como activo el soporte de tarjetas serie multipuerto?</heading>

      <p>Otra vez, en la seccion de configuracion del kernel tienes la
      informacion. Para una tarjeta multipuerto, pon una linea
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?sio" name="sio">
      para cada puerto serie de la tarjeta en el fichero de configuracion
      del kernel. Especifica la irq y vector solo en una de las lineas.
      Todos los puertos de la tarjeta compartiran la misma irq. Por
      consistencia, usa el ultimo puerto serie para especificar la irq. De
      la misma manera, especifica la opcion <tt/COM&lowbar;MULTIPORT/.

      <p>El siguiente ejemplo es para una tarjeta AST 4-port en la irq 7:

      <verb>
        options "COM_MULTIPORT"
        device sio4 at isa? port 0x2a0 tty flags 0x781
        device sio5 at isa? port 0x2a8 tty flags 0x781
        device sio6 at isa? port 0x2b0 tty flags 0x781
        device sio7 at isa? port 0x2b8 tty flags 0x781 irq 7 vector siointr
      </verb>

      <p>Los flags indican que el puerto master tiene un numero menor de 7
      (<tt/0x700/), los diagniosticos estan activados durante el testeo
      (<tt/0x080/), y los puertos comparten una irq (<tt/0x001/).

    <sect1>
      <heading>Puede manejar FreeBSD tarjetas multipuerto compartiendo irq?</heading>

      <p>Todavia no. Tendras que usar una irq diferente para cada tarjeta.

    <sect1>
      <heading>Puedo cambiar los parametros serie por defecto para un puerto?</heading>

      <p>El dispositivo <tt/ttydX/ (o <tt/cuaaX/) es el que querras abrir
      para tus aplicaciones. Cuando un proceso abre el dispositivo, tendra
      una serie de configuraciones I/O por defecto. Puedes ver estas
      configuraciones con el comando:

      <verb>
        stty -a -f /dev/ttyd1
      </verb>

      Cuando le cambias la configuracion a este dispositivo, este cambio
      se mantiene hasta que el dispositivo se cierra. Cuando se reabre,
      vuelve a la configuracion por defecto. Para hacer cambios sobre la
      configuracion por defecto, puedes abrir y ajustar las opciones del
      "estado inicial" del dispositivo. Por ejemplo, para poner el
      dispositivo tty5 en modo <tt/CLOCAL/, 8 bits, y contro del flujo
      <tt>XON/XOFF</tt>, haz

      <verb>
        stty -f /dev/ttyid5 clocal cs8 ixon ixoff
      </verb>

      <p>Un buen lugar para hacer esto es en <tt>/etc/rc.serial</tt>. Ahora,
      una aplicacion tendra esta configuracion por defecto cuando abra el
      puerto <tt/ttyd5/.

      <p>Tambien puedes prevenir o limitar ciertos cambios que pretenda
      hacer una aplicacion. Para ello, ajusta el "lock state" del
      dispostivo. Por ejemplo, para bloquear la velocidad del puerto
      <tt/ttyd5/ a 57600 bps, haz:

      <verb>
        stty -f /dev/ttyld5 57600
      </verb>

      <p>Ahora, una aplicacion que abre <tt/ttyd5/ e intenta cambiar la
      velocidad del puerto no podra hacerlo.

      <p>Naturalmente, deberias hacer que el estado inicial y el estado de
      cloqueo sean solo de escritura para el usuario <tt/root/. El script
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?MAKEDEV"
      name="MAKEDEV"> <bf/NO/ hace esto cuando crea el dispositivo.

    <sect1>
      <heading>Como puedo activar logins de entrada en mi modem?</heading>

      <p>Quieres hacerte proveedor de Internet, eh?. Primero, necesitaras
      uno o mas modems que puedan responder automaticamente. Tu modem
      necesitara activar el carrier-detect solo cuando detecte una portadora
      y no tenerla activada continuamente. Necesitara cortar la comunicacion
      y resetearse el mismo cuando la linea <tt/DTR/ pase de on a off.
      Probablemente usaria <tt>RTS/CTS</tt> para el control de flujo.
      Finalmente, debe usar una velocidad constante entre el ordenador y el
      mismo, pero deberia negociar la velocidad entre el mismo y el modem
      remoto.

      <p>Para muchos modem compatibles Hayes, este comando creara estas
      configuraciones y las grabara en la memoria no volatil:

      <verb>
        AT &amp;C1 &amp;D3 &amp;K3 &amp;Q6 S0=1 &amp;W
      </verb>

      <p>Mira la seccion <ref id="direct-at" name="enviar comandos AT"> para
      saber como enviar estas configuraciones al modem sin necesidad de un
      programa terminal de DOS.

      <p>A continuacion, anyade una linea en el fichero <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?ttys" name="/etc/ttys"> para
      el modem. Este fichero lista todos los puertos en los que el sistema
      operativo esperara los logins. La linea seria como esra:

      <verb>
        ttyd1 "/usr/libexec/getty std.57600" dialup on insecure
      </verb>

      <p>Esta linea indica que el segundo puerto serie <tt>/dev/ttyd1</tt>
      tiene un modem conectado, la velocidad es de 57600 bps y sin paridad
      (<tt/std.57600/. El tipo de terminal para este puero es "dialup".
      El puerto esta "on" y es inseguro (lo que significa que los logins
      como root no son permitidos).

      <p>Muchos usuarios, ponen un sus ficheros .profile o .login un
      prompt para el tipo de terminal. El ejemplo muestra el puerto como
      inseguro. Para ser root en ese puerto, hacer el login como un usuario
      normal, y ejecutar el comando su. Si en lugar de inseguro, el terminal
      es seguro (secure), puedes hacer login como root directamente.

      <p>Despues de modificar el fichero <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?ttys" name="/etc/ttys">,
      necesitas lanzar una senyal <tt/HUP/ al proceso <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?init" name="init">:

      <verb>
        kill -HUP 1
      </verb>

      <p>Esto fuerza al proceso init a releer el fichero <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?ttys" name="/etc/ttys">.
      El proceso init arrancara los procesos getty en todos los puertos
      configurados como "on". Puedes ver si los logins estan disponibles
      en los puertos tecleando:

      <verb>
        ps -ax | grep '[t]tyd1'
      </verb>

      <p>deberias ver algo como:

      <verb>
        747 ??  I      0:00.04 /usr/libexec/getty std.57600 ttyd1
      </verb>

    <sect1>
      <heading>Como puedo conectar un dumb terminal a un FreeBSD?</heading>

      <p>Si estas usando otro ordenador como terminal en tu sistema FreeBSD,
      usa un cable null modem entre los dos puertos serie. Si ya estas
      usando un terminal, mira en las instrucciones del mismo.

      <p>A continuacion, modifica el fichero
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?ttys" name="/etc/ttys">
      Por ejemplo, si estas instalando un terminal WYSE-50 en el quinto puerto
      serie, usa una linea como esta:

      <verb>
        ttyd4 "/usr/libexec/getty std.38400" wyse50 on secure
      </verb>

      <p>Este ejemplo muestra que el puerto <tt>/dev/ttyd4</tt> tiene un
      terminal Wyse50 conectado a 38400 bps sin paridad y los logins de
      root son permitidos.

    <sect1>
      <heading>Por que no puedo ejecutar <tt/tip/ o <tt/cu/?</heading>

      <p>En tu sistema, los programas <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip"> y <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?cu" name="cu"> son probablemente
      ejecutables solo por <htmlurl url="http://www.freebsd.org/cgi/man.cgi?uucp"
      name="uucp"> y el grupo <tt/dialer/. Puedes usar el grupo <tt/dialer/
      para controlar quien tiene acceso al modem o sistemas remotos. Solo
      tienes que anyadirte tu mismo al grupo dialer.

      <p>Alternativamente, puedes dejar que todos los usuarios de tu sistema
      ejecuten <tt/tip/ y <tt/cu/ tecleando:

      <verb>
        # chmod 4511 /usr/bin/cu
        # chmod 4511 /usr/bin/tip
      </verb>

    <sect1>
      <heading>Mi modem hayes no esta soportado. Que puedo hacer?</heading>

      <p>Actualmente, el man de <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip"> esta
      anticuado. Hay un dialer Hayes generico. Solo usa
      ``<tt/at=hayes/'' en tu fichero <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?remote" name="/etc/remote">.

      <p>El driver Hayes no es tan desarrollado como para reconocer algunas
      de las caracteristicas avanzadas de los modem modernos---mensajes como
      <tt/BUSY/, <tt/NO DIALTONE/ o <tt/CONNECT 115200/ lo pueden confundir.
      Deberias anular estos mensajes cuando uses <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip"> (utilizando
      la cadena <tt/ATX0&amp;W/).

      <p>Tambien, el timeout de llamada para <tt/tip/ esta en 60 segundos.
      Tu modem deberia usar algo menor, o tip puede pensar que hay un
      problema de comunicacion. Intenta con <tt/ATS7=45&amp;W/.

    <sect1>
      <heading>
        Como puedo introducir estos comandos AT?<label id="direct-at">
      </heading>

      <p>Haz lo que se llama una entrada <tt/directa/ en el fichero
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?remote"
      name="/etc/remote">. Por ejemplo, si tu modem esta conectado al
      primer puerto serie, <tt>/dev/cuaa0</tt>, escribe la siguiente
      linea:

      <verb>
        cuaa0:dv=/dev/cuaa0:br#19200:pa=none
      </verb>

      <p>Usa la velocidad mas alta que soporte tu modem en la seccion br.
      A continuacion teclea <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip cuaa0">
      y estaras conectado al modem.

      <p>Si no existe el dispositivo <tt>/dev/cuaa0</tt> en tu sistema
      , teclea lo siguiente:

      <verb>
        # cd /dev
        # ./MAKEDEV cuaa0
      </verb>

      <p>O usa el comando cu como root con los siguientes parametros:

      <verb>
        # cu -l``line'' -s``speed''
      </verb>

      <p>con line siendo el puerto serie (por ejemplo <tt>/dev/cuaa0</tt>>)
      y speed siendo la velocidad (por ejemplo <tt>57600</tt>. Cuando
      termines de entrar los comandos AT, pulsa la tecla <tt>.</tt> para
      salir.

    <sect1>
      <heading>El simbolo <tt/@/ no funciona correctamente!</heading>

      <p>El simbolo <tt/@/ en la opcion de numeros de telefono indica a tip
      que busque en el fichero <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?phones(5)" name="phone(5)"> un numero de
      telefono determinado. Pero el simbolo <tt/@/ es tambien un caracter
      especial en otros ficheros y opciones como
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?remote"
      name="/etc/remote">. Pon una contrabarra junto al caracter:

      <verb>
        pn=\@
      </verb>

    <sect1>
      <heading>Como puedo llamar desde la linea de comandos?</heading>

      <p>Pon lo que se llama una entrada <tt/generica/ en el fichero
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?remote"
      name="/etc/remote">. Por ejemplo:

      <verb>
        tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
        tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:
      </verb>

      <p>Entonces puedes hacer cosas como <tt/tip -115200 5551234/. Si
      prefieres usar <htmlurl url="http://www.freebsd.org/cgi/man.cgi?cu" name="cu">
      antes que <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip">, usa una
      entrada generica de cu:

      <verb>
        cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:
      </verb>

      <p>y teclea ``<tt/cu 5551234 -s 115200/''.

    <sect1>
      <heading>Tengo que teclear la velocidad cada vez que hago esto?</heading>

      <p>Pon una entrada para <tt/tip1200/ o <tt/cu1200/, pero puedes usar
      el rate que mejor se amolde a tus necesidades. <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip"> piensa que
      una buena velocidad por defecto es 1200 bps ya que busca una entrada
      <tt/tip1200/. No tienes por que usar 1200 bps.

    <sect1>
      <heading>Accedo a diferentes hosts a traves de un servidor de terminales.</heading>

      <p>En lugar de esperar a que estes conectado y teclear
      <tt/CONNECT &lt;host&gt;/ cada vez, usa la opcion <tt/cm/ de tip. Por
      ejemplo, estas entradas en el fichero <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?remote" name="/etc/remote">:

      <verb>
        pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
        muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
        deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cua02:br#38400:at=hayes:du:pa=none:pn=5551234:
      </verb>

      <p>Esto hara que puedas teclear <tt/tip pain/ o <tt/tip muffin/ para
      conectarte a las maquinas pain o muffin.

    <sect1>
      <heading>Puede tip intentar mas de una linea para cada lugar?</heading>

      <p>Este es un problema habitual en universidades con diferentes lineas
      de modem y unos cientos de usuarios intentado usarlas...

      <p>Haz una entrada para tu universidad en el fichero <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?remote" name="/etc/remote">
      y usa <tt>\@</tt> para la opcion <tt/pn/:

      <verb>
        big-university:\
        :pn=\@:tc=dialout
        dialout:\
        :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:
      </verb>

      <p>Entonces, lista los numeros de telefono de la universidad en el
      fichero <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?phones" name="/etc/phones">:

      <verb>
        big-university 5551111
        big-university 5551112
        big-university 5551113
        big-university 5551114
      </verb>

      <p><htmlurl url="http://www.freebsd.org/cgi/man.cgi?tip"
      name="tip"> intentara cada uno de estos numeros en el orden en el
      que esten listados. Si quieres que se realicen reintentos, ejecuta
      <tt/tip/ en una bucle while.

    <sect1>
      <heading>Por que tengo que teclea CTRL+P dos veces para enviar CTRL+P
      una vez?</heading>

      <p>CTRL+P es el caracter por defecto de "forzar", usado para indicarle
      al programa
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip">
      que el proximo caracter es un dato literal. Puedes configurar el
      caracter "forzar" a cualquier otro caracter con el escape <tt/~s/,
      el cual significa "poner una variable".

      <p>Teclea <tt/~sforce=&lt;single-char&gt;/ seguido de una nueva
      linea. <tt/&lt;single-char&gt;/ es cualquier caracter simple. Si
      dejas libre <tt/&lt;single-char&gt;/ entonces el caracter de
      forzar es el caracter nul, al cual puedes acceder tecleando
      CTRL+2 o CTRL+SPACE. Un valor mas adecuado para
      <tt/&lt;single-char&gt;/ es SHIFT+CTRL+6, el cual solo es usado en
      algunos servidores de terminales.

      <p>Puedes tener el caracter de forzar donde quieras, especificando
      lo siguiente en tu fichero <tt>&dollar;HOME/.tiprc</tt>

      <verb>
        force=<single-char>
      </verb>

    <sect1>
      <heading>De repente, todo lo que tecleo es en mayusculas?</heading>

      <p>Has debido pulsar CTRL+A, <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?tip" name="tip"> tiene este
      caracter especial para gente que tenga la tecla caps-lock estropeada.
      Usa <tt/~s/ como en la seccion anterior y pon la variable "raisechar"
      a un valor razonable. De hecho, puedes ponerla al mismo valor que
      que el caracter de forzar, si no esperas usar estas caracteristicas.

      <p>Aqui hay un ejemplo del fichero .tiprc perfecto para usuarios de
      Emacs que necesiten teclear CTRL+2 y CTRL+A muchas veces:

      <verb>
        force=^^
        raisechar=^^
      </verb>

      <p>El simbolo ^^ es SHIFT+CTRL+6.

    <sect1>
      <heading>Como puedo hacer transferecia de ficheros con <tt/tip/?</heading>

      <p>Si estas conectado con otro sistema UNIX, puedes enviar y recibir
      ficheros con <tt/~p/ (put) y <tt/~t/ (take). Estos comandos ejecutan
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?cat" name="cat"> y
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?echo" name="echo">
      en el sistema remoto para aceptar y enviar ficheros. La sintaxis es:

      <verb>
        ~p <local-file> [<remote-file>]
        ~t <remote-file> [<local-file>]
      </verb>

      <p>No hay chequeo de errores, por lo que es mejor usar otro protocolo
      como zmodem.

    <sect1>
      <heading>Como puedo usar zmodem con <tt/tip/?</heading>

      <p>Primero, instala uno de los programas zmodem de la coleccion de
      puertos (por ejemplo
      <htmlurl url="http://www.freebsd.org/cgi/ports.cgi?^lrzsz" name="lrzsz">
      y <htmlurl url="http://www.freebsd.org/cgi/ports.cgi?^rzsz"
      name="rzsz">).

      <p>Para recibir ficheros, inicia el programa de envio en la parte
      remota. A continuacion, pulsa enter y teclea
      <tt/~C rz/'' (or ``<tt/~C lrz/'' si instalaste lrzsz) para empezar
      a recibir localmente.

      <p>Para enviar ficheros, inicia el programa de recepcion en la parte
      remota. A continuacion pulsa enter y teclea
      <tt/~C sz &lt;files&gt;/'' (o <tt/~C lsz &lt;files&gt;/) para enviarlos
      al sistema remoto.

    <sect1>
       <heading>FreeBSD parece que no puede encontrar mis puertos series aun
       cuando la configuracion es correcta.</heading>

       <p>Las placas bases y tarjetas con UARTs de Acer no son detectadas
       correctamente por FreeBSD durante la fase de deteccion serie. Obten
       un parche de <url url="http://www.lemis.com/serial-port-patch.html"
       name="www.lemis.com"> para solucionar el problema.
           

  </sect>

