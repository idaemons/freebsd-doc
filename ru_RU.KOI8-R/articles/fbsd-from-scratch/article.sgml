<!--
     The FreeBSD Russian Documentation Project

     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/articles/fbsd-from-scratch/article.sgml,v 1.4 2004/07/16 12:06:00 den Exp $

     Original revision: 1.5
-->

<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN" [
<!ENTITY % man PUBLIC "-//FreeBSD//ENTITIES DocBook Manual Page Entities//EN">
%man;
<!ENTITY % freebsd PUBLIC "-//FreeBSD//ENTITIES DocBook Miscellaneous FreeBSD Entities//EN">
%freebsd;
<!ENTITY % trademarks PUBLIC "-//FreeBSD//ENTITIES DocBook Trademark Entities//RU">
%trademarks;
<!ENTITY scratch.ap "<application>FreeBSD From Scratch</application>">
]>

<article lang="ru">
  <articleinfo>
    <title>FreeBSD "с нуля"</title>

    <author>
      <firstname>Jens</firstname>

      <surname>Schweikhardt</surname>

      <affiliation>
        <address><email>schweikh@FreeBSD.org</email></address>
      </affiliation>
    </author>

    <copyright>
      <year>2002,2003,2004</year>

      <holder>Jens Schweikhardt</holder>
    </copyright>

    <pubdate>$FreeBSD$</pubdate>

    <legalnotice id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.adobe;
      &tm-attrib.general;
    </legalnotice>
  </articleinfo>

  <abstract>
    <para>В этой статье описывается мои по
      полностью автоматизированная установка преднастроенной
      компилируемой из исходных текстов, включая компиляцию всех ваших любимых
      портов и преднастроенной так, что она соответствует вашим представлениям
      о настоящей системе.  Если вы полагаете, что концепция
      <command>make world</command> является прекрасным подходом, то
      &scratch.ap; расширяет это понятие
      до <command>make evenmore</command>.</para>
  </abstract>

  <sect1 id="introduction">
    <title>Введение</title>

    <para>Вы когда-либо обновляли вашу систему при помощи
      <command>make world</command>?  Существует одна проблема, возникающая
      при наличии всего лишь одной системы на диске.  Если выполнение цели
      <maketarget>installworld</maketarget> прерывается на середине, у вас
      остаётся неработоспособная система, которая может даже не загружаться.
      Либо цель <maketarget>installworld</maketarget> отрабатывает нормально,
      а новое ядро не загружается.  Тогда наступает момент для поиска Fixit CD
      и резервных копий, которые вы делали полгода назад.</para>

    <para>Я исповедую подход <quote>сотрите данные на дисках при обновлении
      систем</quote>.  Удаление дисков, и даже разделов, обеспечивает вам то,
      что нигде не остаётся никаких частей старого, то, о чём не заботятся
      большее число процедур обновления.  Однако очистка разделов означает, что
      вам нужно перекомпилировать/переустановить все ваши порты и пакаджи, а
      также проделать все тонкие процедуры настройки.  Если вы думаете, что
      эта задача тоже должна быть автоматизирована, то читайте дальше.</para>
  </sect1>

  <sect1 id="why">
    <title>Почему мне (не) нужна &scratch.ap;?</title>

    <para>Это закономерный вопрос.  У нас имеется утилита
      <application>sysinstall</application> и хорошо изученный способ
      компиляции ядра и пользовательских приложений.</para>

    <para>Проблема с утилитой <application>sysinstall</application> заключается
      в том, что она несколько ограничена в том, что, куда и как может
      устанавливать.</para>

    <itemizedlist>
      <listitem>
        <para>Обычно она использовалась для установки уже откомпилированных
          дистрибутивных наборов и пакаджей с некоторого носителя (CD, DVD,
          FTP).  Она не может устанавливать результат выполнения
          <literal>make buildworld</literal>.</para>
      </listitem>

      <listitem>
        <para>Она не может устанавливать вторую систему в некоторый каталог
          уже работающей системы.</para>
      </listitem>

      <listitem>
        <para>Она не может выполнять установку в разделы
          <application>Vinum</application>.</para>
      </listitem>

      <listitem>
        <para>Она не может строить порты, а лишь устанавливать уже
          откомпилированные пакаджи.</para>
      </listitem>

      <listitem>
        <para>Создание скриптов или выполнение нестандартных действий после
          установки затруднено.</para>
      </listitem>

      <listitem>
        <para>И последним, но одним из самых важных факторов, является
          полуофициальное прекращение дальнейшей поддержки
          <application>sysinstall</application>.</para>
      </listitem>
    </itemizedlist>

    <para>Хорошо известный способ полного построения и установки системы,
      описанный в <ulink
      url="http://www.freebsd.org/doc/ru_RU.KOI8-R/books/handbook/makeworld.html">
      Руководстве</ulink>, по умолчанию замещает существующую систему.  При
      этом сохраняются только модули и ядро.  Системные бинарные файлы, файлы
      объявлений функций и множество других файлов перезаписываются; уже
      ненужные файлы остаются и могут преподносить сюрпризы.  Если по
      какой-либо причине обновление завершилось неудачно, бывает трудно и даже
      невозможно вернуть систему в исходное состояние.</para>

    <para>&scratch.ap; решает все эти проблемы.  Её стратегия проста:
      использование работающей системы для установки новой в пустое дерево
      каталогов, при этом новые разделы монтируются в соответствующие места
      этого дерева.  Многие конфигурационные файлы могут быть скопированы в
      соответствующее место, а &man.mergemaster.8; сможет позаботиться о тех,
      что скопировать не удалось.  Тонкая настройка новой системы может быть
      выполнена в старой, вплоть до момента, когда вы сможете выполнить chroot
      в новую систему.  Другими словами, мы проходим через три этапа, при этом
      каждый шаг представляет собой либо запуск скрипта, либо вызов команды
      <command>make</command>:</para>

    <orderedlist>
      <listitem>
        <para><filename>stage_1.sh</filename>:
          Создание новой загружаемой системы в пустом каталоге и объединение
          либо копирование максимально большего количества необходимых файлов.
          Затем загрузка новой системы.</para>
      </listitem>

      <listitem>
        <para><filename>stage_2.sh</filename>:
          Установка требуемых портов.</para>
      </listitem>

      <listitem>
        <para><filename>stage_3.mk</filename>:
          Выполнение последующей настройки программного обеспечения,
          установленного на предыдущем этапе.</para>
      </listitem>
    </orderedlist>

    <para>После того, как вы воспользуетесь &scratch.ap; для построения второй
      системы и в течение нескольких недель убедитесь, что она работает
      удовлетворительно, можете затем использовать её повторно для
      переустановки исходной системы.  С этого момента, как только вы
      почувствуете необходимость обновления, то просто выберите разделы,
      которые хотите удалить и выполнить переустановку.</para>

    <para>Может быть, вы слышали и даже пробовали использовать систему <ulink
      url="http://www.linuxfromscratch.org/">Linux From Scratch</ulink>, или
      LFS для краткости.  LFS также определяет, как построить и установить
      систему с нуля на пустой раздел при помощи работающей системы.  LFS
      делает упор на выяснение роли каждого компонента системы (таких, как
      ядро, компилятор, устройства, командный процессор, база данных
      терминальных устройств и так далее) и деталей установки каждого
      компонента.  &scratch.ap; не опускается до такого уровня детализации.
      Моей целью является проведение автоматизированной и полной установки, а
      не описание всех кровавых подробностей полного перепостроения системы.
      В случае, если вы хотите изучить &os; до такого уровня, начните с
      просмотра <filename>/usr/src/Makefile</filename> и следуйте действиям,
      которые выполняет <command>make buildworld</command>.</para>

    <para>В подходе, который применяется в &scratch.ap;, имеются свои
      отрицательные стороны, которые вы должны иметь в виду.</para>

    <!-- XXX: Хорошо бы написать stage_2.sh с применением системы разделения
         jail, которые запускаются в только что установленной при помощи
         stage_1 системе.  При корректной настройке первичного IP-адреса jail,
         возможно строить порты в chroot без деинсталляции всего установленного
         из 'хостирующей' системы.  Однако не забывайте, что даже jail-системы
         работают на ядре 'хоста'. -->

    <itemizedlist>
      <listitem>
        <para>При компиляции портов на втором этапе систему нельзя использовать
          в обычном режиме.  Если вы имеете дело с сервером, работающим в
          режиме промышленной эксплуатации, вы должны быть готовы к простою,
          к которому приводит выполнение второго этапа.  Порты, построенные
          при помощи <filename>stage_2.conf.default</filename> ниже, требуют
          примерно 4 часа для построения на системе AMD1800+ со SCSI-дисками,
          имеющими скорость вращения 10krpm и 1 Гбайтом ОЗУ.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="prerequisites">
    <title>Предварительные требования</title>

    <para>Для того, чтобы воспользоваться подходом &scratch.ap;, вам нужно
      иметь:</para>

    <itemizedlist>
      <listitem>
        <para>Работающую систему &os; с исходными текстами и деревом
          портов.</para>
      </listitem>

      <listitem>
        <para>По крайней мере один неиспользуемый раздел, куда будет
          устанавливаться новая система.</para>
      </listitem>

      <listitem>
        <para>Опыт работы с &man.mergemaster.8;.  Или по крайней мере
          отсутствие страха его использовать.</para>
      </listitem>

      <listitem>
        <para>Если у вас нет подключения или слабый канал в Internet:
          дистрибутивные файлы для ваших любимых портов.</para>
      </listitem>

      <listitem>
        <para>Знание основ написания скриптов на языке командного процессора
          Bourne, &man.sh.1;.</para>
      </listitem>

      <listitem>
        <para>Наконец, вы должны уметь указывать загрузчику системы на загрузку
          новой системы, либо интерактивно, либо из конфигурационного
          файла.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="stage1">
    <title>Этап первый: Установка системы</title>

    <para>В первом варианте этой статьи на первом шаге использовался
      единственный скрипт, в котором вся настройка выполнялась его
      редактированием.  После того, как пользователи высказали свои замечания,
      я решил разделить код и данные на уровне скриптов.  Это позволяет иметь
      разные наборы конфигурационных данных для установки различных систем без
      внесения изменений в скрипты с кодом.</para>

    <para>Скрипт с кодом для первого этапа называется
      <filename>stage_1.sh</filename>, и он запускается с единственным
      аргументом, например</para>

    <informalexample>
      <screen>&prompt.root; <userinput>./stage_1.sh <replaceable>default</replaceable></userinput></screen>
    </informalexample>

    <para>будет считывать свою конфигурацию из файла
      <filename>stage_1.conf.default</filename> и записывать протокол в файл
      <filename>stage_1.log.default</filename>.</para>

    <para>Далее приводится мой файл <filename>stage_1.conf.default</filename>.
      Вам необходимо подправить его в различных местах для того, чтобы он
      соответствовал вашим представлениям об <quote>идеальной системе</quote>.
      Я попытался подробно прокомментировать те места, которые вы должны
      исправлять.  Конфигурационный скрипт должен предоставлять четыре функции
      для оболочки, <command>create_file_systems</command>,
      <command>create_etc_fstab</command>, <command>copy_files</command> и
      <command>all_remaining_customization</command> (в случае, если это
      имеет смысл: именно в такой последовательности они будут вызываться из
      <filename>stage_1.sh</filename>).

    <para>Следует внимательно отнестись к следующим моментам:</para>

    <itemizedlist>
      <listitem>
        <para>Разбиение разделов.</para>

        <para>Я не являюсь сторонником наличия одного большого раздела для
          всей системы.  Мои системы, как правило, имеют по крайней мере по
          одному разделу для <filename>/</filename>, <filename>/usr</filename>
          и <filename>/var</filename> с каталогом <filename>/tmp</filename>,
          образованным символической ссылкой в <filename>/var/tmp</filename>.
          Вдобавок я использую файловые системы в режиме совместного доступа к
          <filename>/home</filename> (домашние каталоги пользователей),
          <filename>/home/ncvs</filename> (копия CVS-хранилища &os;),
          <filename>/usr/ports</filename> (дерево портов),
          <filename>/src</filename> (различные выгруженные из хранилища деревья
          исходных текстов) и <filename>/share</filename> (остальные совместно
          используемые данные, резервные копии которых не нужны, например,
          спул сервера телеконференций).</para>
      </listitem>

      <listitem>
        <para>Новые возможности.</para>

        <para>Это то, что вы хотите иметь сразу после загрузки новой
          системы и даже до запуска второго этапа.  Причина отказа от простой
          установки всех моих любимых портов на первом этапе заключается в том,
          что теоретически и практически существуют проблемы начальной загрузки
          и целостности: на первом этапе работает ваше старое ядро, однако в
          chroot-окружении содержится новые двоичные файлы программ и файлы
          объявлений.  Если новая система, к примеру, поддерживает новый
          системный вызов (согласно её заголовочным файлам), некоторый скрипт
          конфигурации может попытаться использовать его и завершить работу
          аварийно, потому что работает под старым ядром.  Я наблюдал и другие
          проблемы при попытке построения порта <filename
          role="package">lang/perl5</filename>.</para>
      </listitem>
    </itemizedlist>

    <para>Перед тем, как запускать <filename>stage_1.sh</filename>, убедитесь,
      что выполнили обычные действия при подготовке к
      <command>make installworld installkernel</command>, типа:</para>

    <itemizedlist>
      <listitem>
        <para>отредактировали конфигурационный файл вашего ядра</para>
      </listitem>

      <listitem>
        <para>успешно выполнили <command>make buildworld</command></para>
      </listitem>

      <listitem>
        <para>успешно выполнили <command>make buildkernel
          KERNCONF=<replaceable>whatever</replaceable></command></para>
      </listitem>
    </itemizedlist>

    <para>Когда вы запускаете <filename>stage_1.sh</filename> первый раз, и
      конфигурационный файл, скопированный с работающей системы в новую,
      является устаревшим по сравнению с тем, что находится в каталоге
      <filename>/usr/src</filename>, <command>mergemaster</command> будет
      запрашивать вас на отработку этой ситуации.  Я рекомендую переносить
      изменения.  Если вам надоело отвечать на запросы, вы можете просто
      обновить файлы в вашей <emphasis>работающей</emphasis> системе за раз
      (Если только это вам подходит.  Скорее всего, вам не нужно это делать,
      если одна из ваших систем работает под управлением
      <literal>-STABLE</literal>, а другая с <literal>-CURRENT</literal>.
      Изменения могут оказаться несовместимыми).  Последующие вызовы
      утилиты <command>mergemaster</command> обнаружат, что RCS-идентификаторы
      версий соответствуют тем, что находятся в <filename>/usr/src</filename>,
      и пропустят файл.</para>

    <para>Скрипт <filename>stage_1.sh</filename> остановится на первой команде,
      которая завершится неудачно (возвратит ненулевой код завершения) из-за
      <command>set -e</command>, так что вы не пропустите ошибки.  Он также
      остановится, если вы используете отмену значения переменной окружения,
      как правило, из-за опечатки.  Вы должны исправить все ошибки в вашей
      версии <filename>stage_1.conf.default</filename> перед тем, как
      продолжить работу.</para>

    <para>В скрипте <filename>stage_1.sh</filename> мы вызываем
      <command>mergemaster</command>.  Даже если никаким файлам объединение не
      требуется, он выведет сообщение и в конце сделает запрос</para>

    <screen>*** Comparison complete

Do you wish to delete what is left of /var/tmp/temproot.stage1? [no] <userinput>no</userinput></screen>

    <para>Пожалуйста, ответьте <literal>no</literal> или просто нажмите
      <keycap>Enter</keycap>.  Причина в том, что
      <command>mergemaster</command> оставит несколько файлов нулевой длины в
      каталоге <filename>/var/tmp/temproot.stage1</filename>, которые позже
      будут скопированы в новую систему (если их здесь уже нет).</para>

    <para>После этого будет выдан список установленных файлов при помощи
      утилиты постраничного вывода, по умолчанию это &man.more.1;, может быть
      &man.less.1;:</para>

    <screen>*** You chose the automatic install option for files that did not
    exist on your system.  The following were installed for you:
      /newroot/etc/defaults/rc.conf
      ...
      /newroot/COPYRIGHT

(END)</screen>

    <para>Нажмите <keycap>q</keycap> для того, чтобы прекратить просмотр.
      Затем вы будете проинформированы
      о <filename>login.conf</filename>:</para>

    <screen>*** You installed a login.conf file, so make sure that you run
    '/usr/bin/cap_mkdb /newroot/etc/login.conf'
    to rebuild your login.conf database

    Would you like to run it now? y or n [n]</screen>

    <para>Ответ не имеет значения, так как мы будем запускать &man.cap.mkdb.1;
      в любом случае.</para>

    <para>Вот авторский файл <ulink url="stage_1.conf.default">
      <filename>stage_1.conf.default</filename></ulink>, который вы должны
      потом модифицировать.  В комментариях даётся достаточно информации о том,
      что необходимо изменить.</para>

    <warning>
      <para>Пожалуйста, обратите на команды &man.newfs.8;.  Хотя вы не можете
        создавать новые файловые системы на смонтированных разделах, скрипт
        успешно удалит все несмонтированные разделы
        <filename>/dev/da0s1a</filename>, <filename>/dev/da0s1e</filename> и
        <filename>/dev/da2s1e</filename>.  Этого может оказаться достаточным,
        чтобы испортить вам день, так что подправьте имена устройств.</para>
    </warning>

    <programlisting><inlinegraphic fileref="stage_1.conf.default" format="linespecific"></programlisting>

    <para>Сгрузите <ulink url="stage_1.conf.default">
      <filename>stage_1.conf.default</filename></ulink>.</para>

    <para>При работе этот скрипт устанавливает систему, которая при загрузке
      имеет:</para>

    <itemizedlist>
      <listitem>
        <para>Унаследованные списки пользователей и групп.</para>
      </listitem>

      <listitem>
        <para>Подключение к Internet по Ethernet и PPP с использованием
          межсетевого экрана.</para>
      </listitem>

      <listitem>
        <para>Правильный временной пояс и NTP.</para>
      </listitem>

      <listitem>
        <para>Другие более мелкие конфигурационные параметры, например,
          <filename>/etc/ttys</filename> и <command>inetd</command>.</para>
      </listitem>
    </itemizedlist>

    <para>Другие функции готовы к настройке, но не будут работать, пока не
      будет завершён второй этап.  Например, мы скопировали файлы для настройки
      печати и X11.  Однако для печати, скорее всего, необходимы приложения,
      отсутствующие в базовом комплекте системы.  X11 не будет работать, пока
      мы не откомпилируем сервер, библиотеки и программы.</para>
  </sect1>

  <sect1 id="stage2">
    <title>Этап второй: Установка портов</title>

    <note>
      <para>На этом этапе вместо компиляции портов возможна также установка
        (уже откомпилированных) пакаджей.  В этом случае
        <filename>stage_2.sh</filename> будет представлять собой не более, чем
        перечень команд <command>pkg_add</command>.  Я надеюсь, что вы сумеете
        написать такой скрипт.  Здесь мы сосредоточимся на более гибком и
        традиционном способе с использованием портов.</para>
    </note>

    <para>Следующий скрипт <filename>stage_2.sh</filename> показывает, как
      я устанавливаю мои любимые порты.  Он может быть запущен любое количество
      раз и будет пропускать все порты, которые уже установлены.  Он
      поддерживает <emphasis>dryrun</emphasis>-параметр (<option>-n</option>)
      для только показа того, что будет выполнено.  Вы запускаете его точно
      также, как <filename>stage_1.sh</filename>, с только одним аргументом,
      указывающим на конфигурационный файл, к примеру</para>

    <informalexample>
      <screen>&prompt.root; <userinput>./stage_2.sh <replaceable>default</replaceable></userinput></screen>
    </informalexample>

    <para>который будет считывать перечень портов из
      <filename>stage_2.conf.default</filename>.</para>

    <para>Список портов состоит из строчек с двумя или большим количеством
      слов, разделённых пробелами: категория и порт, за которыми опционально
      следует команда установки, которая будет компилировать и устанавливать
      порт (по умолчанию: <command>make install</command>).  Пустые строки и
      строки, начинающиеся с символа #, игнорируются.  В большинстве случаев
      в них указывается только название категории и порт.  Однако некоторые
      порты могут быть тонко настроены при помощи указания
      <command>make</command>-переменных, к примеру:</para>

    <programlisting>www mozilla make WITHOUT_MAILNEWS=yes WITHOUT_CHATZILLA=yes install
mail procmail make BATCH=yes install</programlisting>

    <para>На самом деле вы можете указать некоторые команды оболочки, так что
      не ограничены простыми вызовами <command>make</command>:</para>

    <programlisting>java linux-sun-jdk13 yes | make install
news inn-stable CONFIGURE_ARGS="--enable-uucp-rnews --enable-setgid-inews" make install</programlisting>

    <para>Заметьте, что строка для <filename
      role="package">news/inn-stable</filename> является примером одновременно
      задания переменной оболочки <literal>CONFIGURE_ARGS</literal>.  Файл
      <filename>Makefile</filename> порта будет использовать это как начальное
      значение и определит некоторые другие необходимые аргументы.  Разница в
      задании <application>make</application>-переменных в командной строке
      по команде</para>

    <programlisting>news inn-stable make CONFIGURE_ARGS="--enable-uucp-rnews --enable-setgid-inews" install</programlisting>

    <para>заключается в том, что в последнем случае значение будет
      переназначено, но не расширено.  Выбор нужного метода зависит от
      конкретного порта.</para>

    <para>Убедитесь в том, что ваши порты не используют интерактивный режим
      установки, то есть не должны пытаться читать со стандартного устройства
      ввода ничего кроме того, что вы им подаёте на вход.  Если это всё же
      происходит, то они будут считывать последующие строки из вашего перечня
      портов, описываемого в этом документе, и будут работать некорректно.
      Если скрипт <filename>stage_2.sh</filename> неожиданно пропустил порт
      или прекратил работу, причина может быть в этом.</para>

    <para>Ниже приводится <filename>stage_2.conf.default</filename>.  Для
      каждого установленного им порта создаётся файл протокола
      <filename>LOGDIR/category+port</filename>.</para>

    <programlisting><inlinegraphic fileref="stage_2.conf.default" format="linespecific"></programlisting>

    <para>Сгрузите <ulink url="stage_2.conf.default">
      <filename>stage_2.conf.default</filename></ulink>.</para>

  <sect1 id="stage3">
    <title>Этап третий</title>

    <para>На втором этапе вы установили ваши любимые порты.  Некоторые их них
      требуют некоторой настройки.  Именно для этого и предназначен третий
      этап, настройки.  Я мог бы интегрировать эту настройку в конец скрипта
      <filename>stage_2.sh</filename>.  Однако я думаю, что есть концептуальное
      различие между установкой порта и модификацией его начальной
      конфигурации, и это требует отдельного шага.</para>

    <para>Я решил реализовать третий этап в виде файла
      <filename>Makefile</filename>, потому что это позволяет легко выбирать
      то, что вы хотите конфигурировать, следующим простым вызовом:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>make -f stage_3.mk <replaceable>target</replaceable></userinput></screen>
    </informalexample>

    <para>Как и в случае с <filename>stage_2.sh</filename>, убедитесь, что файл
      <filename>stage_3.mk</filename> после загрузки новой системы есть в
      наличии, поместив его на совместно используемый раздел либо скопировав
      его куда-нибудь в новую систему.</para>

  <sect1 id="limitations">
    <title>Ограничения</title>

    <para>Автоматизированная установка порта может оказаться затруднена, если
      он является интерактивным и не поддерживает команду <command>make
      BATCH=YES install</command>.  Для нескольких портов интерактивность
      означает не более, чем ввод <literal>yes</literal> в ответ на вопрос о
      принятии некоторого лицензионного соглашения.  Если такой ввод
      считывается со стандартного устройства ввода, мы просто направляем
      соответствующие ответы на вход установочной команды (обычно <command>make
      install</command>; именно так я работал с <filename
      role="package">java/linux-sun-jdk14</filename> в
      <filename>stage_2.conf.default</filename>).</para>

    <para>Такой подход, например, не работает с <filename
      role="package">editors/staroffice52</filename>, который требует работы
      X11.  Процедура установки включает достаточно большое количество нажатий
      мыши и набор, так что она не может быть автоматизирована так, как другие
      порты.  Однако для меня сработал следующий трюк: сначала я создал
      пакадж staroffice на старой системе при помощи команды</para>

    <informalexample>
      <screen>&prompt.root; <userinput>cd /usr/ports/editors/staroffice52</userinput>
&prompt.root; <userinput>make package</userinput>
===>  Building package for staroffice-5.2_1
Creating package /usr/ports/editors/staroffice52/staroffice-5.2_1.tbz
Registering depends:.
Creating bzip'd tar ball in '/usr/ports/editors/staroffice52/staroffice-5.2_1.tbz'</screen>
    </informalexample>

    <para>и на втором этапе я просто использовал следующее:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>pkg_add /usr/ports/editors/staroffice52/staroffice-5.2_1.tbz</userinput></screen>
    </informalexample>

    <para>Вы должны также принять во внимание вопросы обновления
      конфигурационных файлов.  Вообще говоря, вы не знаете, когда и сменился
      ли вообще формат или содержимое конфигурационного файла.  В файл
      <filename>/etc/group</filename> может быть добавлена новая группа, или в
      <filename>/etc/passwd</filename> может добавиться дополнительное поле.
      Всё это уже происходило в прошлом.  Простое копирование конфигурационного
      файла из старой в новую систему может в большинстве случаев оказаться
      достаточным, но в этих случаях это не так.  Если вы обновляете систему
      каноническим способом (путём перезаписывания старых файлов), вы должны
      использовать утилиту <command>mergemaster</command> для работы с
      изменениями, если вы хотите эффективно объединить вашу локальные
      настройки с потенциально новыми возможностями.  К сожалению,
      <command>mergemaster</command> работает только с файлами базового
      комплекта системы, а не с любыми файлами, устанавливаемыми портами.
      Похоже, что стороннее программное обеспечение специально проектируется
      для того, чтобы я не дремал, и меняет конфигурационные файлы по два
      раза в месяц.  Всё, что вы можете здесь сделать, это быть
      предупреждёнными, особенно при изменении старшего номера версии.  В
      прошлом я переписывал или перенастраивал файлы для Web-серверов,
      серверов телеконференций и программ для их чтения.  Любое активно
      разрабатываемое программное обеспечение является первым кандидатом на
      получение проблем с конфигурационными файлами.</para>

    <para>Я использовал систему &scratch.ap; несколько раз для обновления
      <literal>5-CURRENT</literal> до <literal>5-CURRENT</literal>, то есть
      я никогда не пытался установить <literal>5-CURRENT</literal> из системы
      <literal>4-STABLE</literal> и наоборот.  Из-за количества изменений между
      релизами с разными старшими номерами я ожидаю, что этот процесс будет
      несколько более сложным.  Использование &scratch.ap; для обновления
      внутри <literal>4-STABLE</literal> должно проходить безболезненно (хотя
      я ещё этого не пробовал делать.)  Пользователи ветки
      <literal>4-STABLE</literal> могут иметь в виду следующее:</para>

    <note>
      <para>Если вы не используете файловую систему устройств, &man.devfs.5;,
        то можете создать устройства для некоторого вашего оборудования командой
        &man.MAKEDEV.8; в процессе
        <command>all_remaining_customization</command>.</para>
    </note>
  </sect1>

  <sect1 id="files">
    <title>Файлы</title>

    <para>Вот три файла, которые вам нужны кроме тех конфигурационных, что
      уже показаны выше.</para>

    <para>Это скрипт <ulink url="stage_1.sh">
      <filename>stage_1.sh</filename></ulink>, который вы не должны
      модифицировать.</para>

    <programlisting><inlinegraphic fileref="stage_1.sh" format="linespecific"></programlisting>

    <para>Сгрузите <ulink
      url="stage_1.sh"><filename>stage_1.sh</filename></ulink>.</para>

    <para>Это скрипт <ulink
      url="stage_2.sh"><filename>stage_2.sh</filename></ulink>.  Вам может
      понадобиться изменить переменные в самом начале файла.</para>

    <programlisting><inlinegraphic fileref="stage_2.sh" format="linespecific"></programlisting>

    <para>Сгрузите <ulink
      url="stage_2.sh"><filename>stage_2.sh</filename></ulink>.</para>

    <para>Это мой файл <ulink
      url="stage_3.mk"><filename>stage_3.mk</filename></ulink>, который даст
      вам идею о том, как автоматизировать всю повторную конфигурацию.</para>

    <programlisting><inlinegraphic fileref="stage_3.mk" format="linespecific"></programlisting>

    <para>Сгрузите <ulink
      url="stage_3.mk"><filename>stage_3.mk</filename></ulink>.</para>
  </sect1>
</article>
