<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN" [
<!ENTITY % man PUBLIC "-//FreeBSD//ENTITIES DocBook Manual Page Entities//EN">
%man;
<!ENTITY % authors SYSTEM "../../../en_US.ISO8859-1/books/handbook/authors.ent"> %authors;
]>

<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD: doc/ru_RU.KOI8-R/books/faq/book.sgml,v 1.51 2001/06/11 01:20:24 ache Exp $
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/faq/book.sgml,v 1.49 2001/03/11 12:51:51 phantom Exp $

     Original revision: 1.145
-->

<book lang="en">

<bookinfo>
  <title>Часто Задаваемые Вопросы по FreeBSD 2.X, 3.X и 4.X</title>

  <corpauthor>The FreeBSD Documentation Project</corpauthor>

  <pubdate>$FreeBSD: doc/ru_RU.KOI8-R/books/faq/book.sgml,v 1.51 2001/06/11 01:20:24 ache Exp $</pubdate>

  <abstract>
    <para>Этот документ является так называемым FAQ (Frequently Asked
      Questions), то есть списком Часто Задаваемых Вопросов по FreeBSD версий
      2.X, 3.X и 4.X.  Если не оговорено обратное, предполагается, что все
      замечания справедливы для версий FreeBSD 2.0.5 и выше.  Пункты с
      пометкой &lt;XXX&gt; находятся в стадии разработки.  Если вы хотите
      помочь в составлении этого документа, пошлите письмо в список рассылки
      проекта по адресу <email>freebsd-doc@FreeBSD.org</email>.
      Последняя редакция этого документа всегда доступна с <ulink
      URL="http://www.FreeBSD.org/">WWW-сервера FreeBSD</ulink>.  Его также
      можно получить в виде одного большого <ulink
      URL="book.html">HTML-файла</ulink> по HTTP или в виде обычного текстового
      файла, файла формата postscript, PDF или другого формата с <ulink
      URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">FTP-сервера</ulink>.
      Вы также можете осуществить
      <ulink URL="http://www.FreeBSD.org/search/search.html">поиск</ulink> в
      FAQ.</para>
  </abstract>
</bookinfo>


<preface id="preface">
  <title>Предисловие</title>

  <para>Добро пожаловать в FAQ по FreeBSD 2.X-4.X!</para>

  <para>Как и обычный FAQ конференций Usenet, этот документ содержит
    большинство из часто задаваемых вопросов, касающихся операционной системы
    FreeBSD (и, конечно же, ответы на них).  Первоначально предназначенный для
    уменьшения потока сообщений и избежания повторения одних и тех же вопросов,
    постепенно FAQ превратился в ценный источник информации.</para>

  <para>Мы прилагаем все усилия, чтобы сделать этот FAQ максимально
    информативным; если у вас есть идеи по его усовершенствованию, пожалуйста,
    напишите составителям по адресу &a.faq;.</para>


<qandaset>
<qandaentry>
  <question id="what-is-FreeBSD">
    <para>FreeBSD - что это такое?</para>
  </question>

  <answer>

  <para>В двух словах, FreeBSD - это UN*X-подобная операционная система для
    платформ i386 и Alpha/AXP, разработанная на основе операционной системы
    4.4BSD-Lite с некоторыми усовершенствованиями, взятыми из 4.4BSD-Lite2
    Калифорнийского Университета (Беркли).  Также она косвенно
    базируется на 386BSD (BSD Net/2, перенесённой на платформу i386 Вильямом
    Джолитцем (William Jolitz)), хотя от того первоначального кода осталось
    очень мало.  Более подробные объяснения того, что представляет из себя
    FreeBSD и для чего она может вам пригодиться, можно найти на <ulink
    URL="http://www.FreeBSD.org/ru/">домашней странице FreeBSD</ulink>.</para>

  <para>FreeBSD используется компаниями, Интернет-провайдерами, научными
    работниками, профессионалами в вычислительной технике, студентами и
    рядовыми пользователями по всему миру для работы, образования и отдыха. Вы
    можете увидеть некоторых из них в нашей <ulink
    URL="http://www.FreeBSD.org/ru/gallery/gallery.html">галерее</ulink>.</para>

  <para>Для более детального ознакомления с FreeBSD, пожалуйста, обратитесь к
    <ulink URL="../../handbook/index.html">Руководству по
    FreeBSD</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="FreeBSD-goals">
    <para>Каковы цели FreeBSD?</para>
  </question>

  <answer>

  <para>Цели, преследуемые проектом FreeBSD - это предоставление программного
    обеспечения, которое может быть использовано в любых целях без всяческих
    ограничений. Многие из нас вкладывают значительные усилия в её разработку
    (и проектирование) и определённо были бы не против получения финансовой
    поддержки, но мы не собираемся её требовать. Мы надеемся, что наша основная
    и самая значительная <quote>миссия</quote> - предоставить код всем
    желающим, для любых целей, так чтобы он нашел самое широкое применение и
    принес наибольшую пользу.  Это, на наш взгляд, одна из самых
    фундаментальных целей Free Software, которую мы с энтузиазмом
    поддерживаем.</para>
 
  <para>Исходный код, подпадающий под действие GNU General
    Public License (GPL) или GNU Library General Public License (LGPL),
    имеет несколько больше ограничений, хотя  и представляет собой
    навязывание доступа к исходным текстам, а не наоборот, как обычно. Из-за
    дополнительных сложностей, которые могут возникнуть в случае
    коммерческого использования программного обеспечения GPL, мы стараемся,
    где только это возможно, заменить подобное программное обеспечение
    аналогичным, но подпадающим под более свободную лицензию BSD.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="why-called-FreeBSD">
    <para>Почему система называется именно FreeBSD?</para>
  </question>

  <answer>

  <para>     
    <itemizedlist>
      <listitem>
        <para>Она может использоваться безо всяческих выплат, даже
          для извлечения выгоды.</para>
      </listitem>

      <listitem>
        <para>Все исходные тексты операционной системы свободно доступны,
          на её использование в других разработках (как коммерческих, так и
          некоммерческих) и дальнейшее распространение наложены минимальные
          ограничения.</para>
      </listitem>

      <listitem>
        <para>Любой, у кого есть усовершенствования и/или исправления,
          может предоставить свой код и он будет (правда, с парой
          оговорок) добавлен в исходные тексты системы.</para>
      </listitem>

    </itemizedlist>
  </para>
 
  <para>Для тех наших читателей, для которых английский не является родным
    языком, можно добавить, что слово <quote>free</quote> используется здесь в
    двух смыслах, один означает <quote>бесплатно</quote>, а другой <quote>вы
    можете делать всё, что хотите</quote>. За исключением пары вещей, которые
    вы <emphasis>не можете</emphasis> делать с FreeBSD, например, претендовать
    на то, что являетесь её разработчиком, на самом деле можно делать с ней
    всё, что вам заблагорассудится.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="latest-version">
    <para>Какова последняя версия FreeBSD?</para>
  </question>

  <answer>

  <para>Версия <ulink
    URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/4.2-RELEASE/">
    4.2</ulink>, выпущенная в ноябре 2000 года, является самой последней
    версией ветки <emphasis>STABLE</emphasis>.  Она также является самым
    последним <emphasis>РЕЛИЗОМ</emphasis>.</para>

  <para>Если говорить кратко, то ветка <emphasis>-STABLE</emphasis>
    предназначена поставщикам услуг Internet или другим корпоративным
    пользователям, которым в первую очередь нужна надёжность и не слишком
    большое количество отличий от последнего релиза по сравнению с
    возможностями последнего снэпшота <emphasis>-CURRENT</emphasis>.  Релизы
    можно делать из любой ветки, но <emphasis>-CURRENT</emphasis> вы должны
    использовать только в случае, если уверены, что готовы к постоянным (по
    сравнению со <emphasis>-STABLE</emphasis>) изменениям в работе
    системы.</para>
 
  <para>Релизы делаются только <link linkend="release-freq">раз в несколько
    месяцев</link>.  Хотя многие стараются отслеживать актуальное состояние
    исходных текстов FreeBSD (обратите внимание на вопросы о <link
    linkend="current">FreeBSD-CURRENT</link> и <link
    linkend="stable">FreeBSD-STABLE</link>), делать это не обязательно, так как
    исходные тексты постоянно меняются.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="current">
    <para>Что такое FreeBSD-CURRENT?</para>
  </question>

  <answer>

  <para><ulink
    URL="../../handbook/cutting-edge.html#CURRENT">FreeBSD-CURRENT</ulink> -
    это версия операционной системы, находящаяся в стадии разработки до момента
    выпуска 5.0-RELEASE. Таким образом, она представляет реальный интерес только
    для разработчиков системы и её фанатов.  Обратитесь к <ulink
    URL="../../handbook/cutting-edge.html#CURRENT">соответствующему
    разделу</ulink> <ulink URL="../../handbook/index.html">Руководства</ulink>
    для прояснения деталей работы с -CURRENT.</para>
 
  <para>Если вы не специалист по операционным системам или не в состоянии
    отличить реальную проблему от временных явлений, вы не должны использовать
    FreeBSD-CURRENT.  Эта ветвь зачастую меняется очень быстро и вполне может
    быть просто не работоспособна некоторое время. Те, кто используют
    FreeBSD-CURRENT, должны быть в состоянии анализировать любые проблемы и
    сообщать о них, если это действительно ошибки, а не <quote>глюки</quote>.
    Сообщения типа <quote>make world produces some error about groups</quote>
    в списке рассылки -CURRENT иногда воспринимаются пренебрежительно.</para>
 
  <para>Ежедневно из веток -CURRENT и -STABLE делаются <ulink
    URL="http://www.FreeBSD.org/ru/releases/snapshots.html">снэпшоты</ulink>.
    В настоящее время имеются в наличии дистрибутивы некоторых снэпшотов.  Их
    предназначение:</para>

  <para>     
    <itemizedlist>
      <listitem>
        <para>Тестирование самой последней версии инсталлятора.</para>
      </listitem>

      <listitem>
        <para>Дать людям, которые хотят работать с -CURRENT или -STABLE, но не
          имеют времени и/или возможности (пропускной способности) для
          отслеживания ежедневных измененений, простой способ её
          установки.</para>
      </listitem>

      <listitem>
        <para>Фиксация точки для последующих ссылок в случае,
          если позже мы что-нибудь очень сильно сломаем. (Хотя CVS, как
          правило, не позволяет случиться ничему такому ужасному :)</para>
      </listitem>

      <listitem>
        <para>Любые новые возможности, которым требуется тестирование,
          должны иметь как можно больше потенциальных тестеров.</para>
      </listitem>

    </itemizedlist>
  </para>
 
  <para>Не утверждается, что всякий снэпшот -CURRENT имеет качество
    <quote>готового продукта</quote>.  Если вам нужна стабильно работающая и
    полностью оттестированная система, то необходимо дождаться выхода полного
    релиза или воспользоваться снэпшотами -STABLE.</para>
 
  <para>Снэпшоты доступны непосредственно с <ulink
    URL="ftp://current.FreeBSD.org/pub/FreeBSD/">
    ftp://current.FreeBSD.org/pub/FreeBSD/</ulink>
    для 5.0-CURRENT и <ulink URL="ftp://releng4.FreeBSD.org/pub/FreeBSD/">
    releng4.FreeBSD.org</ulink> для снэпшотов 4-STABLE.  На момент написания
    этого документа (май 2000) снэпшоты 3-STABLE больше не выпускаются.</para>

  <para>Снэпшоты, как правило, генерируются ежедневно для всех активно
    разрабатываемых веток.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="stable">
    <para>В чём смысл FreeBSD-STABLE?</para>
  </question>

  <answer>

  <para>После того, как была выпущена FreeBSD 2.0.5, мы решили разделить
    разработку FreeBSD на две части. Одна ветка, названная <ulink
    URL="../../handbook/stable.html">-STABLE</ulink>, предназначена для внесения
    только хорошо оттестированных исправлений и маленьких последовательных
    усовершенствований (для провайдеров услуг Интернет и других коммерческих
    пользователей, для которых неожиданные изменения или экспериментальные
    возможности весьма нежелательны).  Другой ветвью является <ulink
    URL="../../handbook/cutting-edge.html#CURRENT">-CURRENT</ulink>, и она по
    существу является прямой линией, ведущей к 5.0-RELEASE (и последующим) с тех
    пор, как была выпущена 2.0.  Если вам поможет картинка, то вот как это
    выглядит:</para>
 
  <programlisting>
               2.0
                |
                |
                |  [2.1-STABLE]
 *ВЕТВЬ*      2.0.5 -&gt; 2.1 -&gt; 2.1.5 -&gt; 2.1.6 -&gt; 2.1.7.1  [конец 2.1-STABLE]
                |                            (Мар 1997)
                |
                |
                |  [2.2-STABLE]
 *ВЕТВЬ*      2.2.1 -&gt; 2.2.2-RELEASE -&gt; 2.2.5 -&gt; 2.2.6 -&gt; 2.2.7 -&gt; 2.2.8 [конец]
                |        (Мар 1997)   (Окт 97) (Апр 98)  (Июл 98) (Дек 98)
                |
                |
             3.0-SNAPs  (начало в I квартале 1997)
                |
                |
             3.0-RELEASE (Окт 1998)
                |
                |  [3.0-STABLE]
 *ВЕТВЬ*     3.1-RELEASE (Фев 1999) -&gt; 3.2 -&gt; 3.3 -&gt; 3.4 -&gt; 3.5 -&gt; 3.5.1
                |                    (Май 1999) (Сен 1999) (Дек 1999) (Июнь 2000) (Июль 2000)
                |
                |  [4.0-STABLE]
*ВЕТВЬ*        4.0  (Март 2000) -&gt; 4.1 -&gt; 4.1.1 -&gt; 4.2 -&gt; ... будущие релизы 4.x ...
                |
                |                (Июль 2000) (Сентябрь 2000) (Ноябрь 2000)
               \|/
                +
        [продолжение 5.0-CURRENT]
  </programlisting>
 
  <para>Ветвь -CURRENT постепенно переходит в 5.0 и выше, тогда как предыдущая
    ветвь, 2.2-STABLE, была вытеснена релизом 2.2.8.  Её заменила ветвь
    3-STABLE, финальный релиз которой, 3.5.1-RELEASE, вышел в июле 2000 года.
    В мае 2000 года (хотя релиз 3.5 вышел после этой даты) ветвь 3-STABLE была
    более или менее полностью вытеснена ветвью 4-STABLE.  В ноябре 2000 года
    была выпущена 4.2-RELEASE.  Активно разрабатываемой веткой -STABLE
    является 4-STABLE, хотя исправления ошибок (в основном касающиеся вопросов
    безопасности) всё ещё вносятся и в 3-STABLE.  Предполагается, что ветвь 3.X
    будет официально признана устаревшей летом 2000 года.  <quote>Текущей
    веткой</quote> сейчас является 5.0-CURRENT, хотя выход её релиза ещё не
    запланирован.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="release-freq">
    <para>В какой момент выпускаются новые версии FreeBSD?</para>
  </question>

  <answer>

  <para>Как правило, основная группа разработчиков выпускает новую версию,
    только когда они уверены, что добавленных новых возможностей и/или
    внесённых исправлений уже достаточно и новый релиз не потеряет
    стабильности. Многие пользователи оценивают эту осторожность как одну из
    лучших сторон FreeBSD, хотя она несколько разочаровывает, если вам не
    терпится попробовать новые возможности..</para>
 
  <para>В среднем новые версии выпускаются примерно раз в четыре месяца.</para>
 
  <para>Для тех, кому не терпится, ежедневно выпускаются бинарные релизы..
    смотрите выше.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="available-platforms">
    <para>FreeBSD разрабатывается только для персональных компьютеров?</para>
  </question>

  <answer>

  <para>Начиная с версии 3.x, FreeBSD работает как на архитектуре x86, так и на
    платформе <ulink URL="http://www.FreeBSD.org/ru/alpha/alpha.html">
    DEC Alpha</ulink>.  Некоторый интерес был проявлен к переносу на
    платформы SPARC, PowerPC и IA64.</para>

   <para>Если ваш компьютер имеет другую архитектуру и вам нужно что-то прямо
     сейчас, советуем попробовать
     <ulink URL="http://www.netbsd.org/">NetBSD</ulink> или
     <ulink URL="http://www.openbsd.org/">OpenBSD</ulink>.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="responsible">
    <para>Кто разрабатывает FreeBSD?</para>
  </question>

  <answer>

  <para>Решения, которые касаются ключевых моментов в проекте FreeBSD,
    такие, как общее направление развития проекта или кто
    может добавлять код к дереву исходных текстов, принимаются 
    <ulink URL="../../handbook/staff.html#STAFF-CORE">основной командой</ulink>
    разработчиков (core team), состоящей из 9 человек.  Также существует
    гораздо большая группа из более чем 200
    <ulink URL="../../handbook/staff-committers.html">коммиттеров</ulink>
    (committers), которые могут делать изменения прямо в дереве исходных
    текстов FreeBSD.</para>
 
  <para>Однако, большинство нетривиальных изменений широко обсуждается
    в <link linkend="mailing">списках рассылки</link>, и не существует 
    никаких ограничений на участие в подобных дискуссиях.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="where-get">
    <para>Где можно найти FreeBSD?</para>
  </question>

  <answer>

  <para>Все основные релизы FreeBSD доступны по ftp с <ulink
    URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/">FTP-сервера
    FreeBSD</ulink>:</para>
 
  <para>     
    <itemizedlist>
      <listitem>
        <para>Текущий релиз 3.X-STABLE, 3.5.1-RELEASE, находится в <ulink
          URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/3.5.1-RELEASE">
          каталоге с 3.5.1-RELEASE</ulink>.</para>
      </listitem>

      <listitem>
        <para>Текущий релиз ветки 4-STABLE, 4.2-RELEASE, находится в <ulink
          URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/4.2-RELEASE">
          каталоге с 4.2-RELEASE</ulink>.</para>
      </listitem>

      <listitem>
        <para><ulink
          URL="ftp://releng4.FreeBSD.org/pub/FreeBSD/">Снэпшоты
          4.X</ulink> обычно делаются ежедневно.</para>
      </listitem>

      <listitem>
        <para>Выпуски <ulink 
          URL="ftp://current.FreeBSD.org/pub/FreeBSD/">5.0 Snapshot</ulink>,
          которые делаются ежедневно из ветви <link
          linkend="current">-CURRENT</link>, предназначены для тестеров и
          разработчиков.</para>
      </listitem>
    </itemizedlist>
  </para>
 
  <para>FreeBSD также доступна через компанию CDROM, по такому адресу:</para>
 
  <address>BSDi
    <street>4041 Pike Lane, Suite F</street>
    <city> Concord</city>, <state>CA</state>
    <postcode>94520</postcode>
    <country>USA</country>

    <phone>Заказы:    +1 800 786-9907</phone>
    <phone>Вопросы:   +1 925 674-0783</phone>
    <fax>FAX:         +1 925 674-0821</fax>
    <otheraddr>email: <ulink URL="mailto:orders@osd.bsdi.com">Адрес для заказов в BSDi</ulink></otheraddr>
    <otheraddr>WWW:   <ulink URL="http://www.osd.bsdi.com/">Web-страница компании BSDi</ulink></otheraddr>
  </address>

  <para>В Австралии вы сможете найти её по адресу:</para>
 
  <address>Advanced Multimedia Distributors
    <street>Factory 1/1 Ovata Drive</street>
    <city>Tullamarine, Melbourne</city>
    <state>Victoria</state>
    <country>Australia</country>
    <phone>Voice: +61 3 9338 6777</phone>
 
    <otheraddr>CDROM Support BBS</otheraddr>
    <street>17 Irvine St</street>
    <city>Peppermint Grove</city> <state>WA</state>
    <postcode>6011</postcode>
    <phone>Voice: +61 9 385-3793</phone>
    <fax>Fax:   +61 9 385-2360</fax>
  </address>

  <para>И в Великобритании:</para>
 
  <address>The Public Domain &amp; Shareware Library
    <street>Winscombe House, Beacon Rd</street>
    <city>Crowborough</city>
    <state>Sussex. TN6 1UL</state>
    <phone>Voice: +44 1892 663-298</phone>
    <fax>Fax:   +44 1892 667-473</fax>
  </address>

  </answer>
</qandaentry>


<qandaentry>
  <question id="mailing">
    <para>Где найти информацию по спискам рассылки FreeBSD?</para>
  </question>

  <answer>

  <para>Исчерпывающая информация содержится в <ulink
    URL="../../handbook/eresources.html#ERESOURCES-MAIL">разделе</ulink>
    Руководства, который посвящен спискам рассылки.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="y2k">
    <para>Где можно найти информацию о проблеме 2000 года во FreeBSD?</para>
  </question>

  <answer>

  <para>Полная информация находится на странице <ulink
    URL="http://www.FreeBSD.org/y2kbug.html">Готовности к 2000
    году</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="newsgroups">
    <para>Какие существуют телеконференции по FreeBSD?</para>
  </question>

  <answer>

  <para>Полная информация о группах новостей есть в <ulink
    URL="../../handbook/eresources-news.html">разделе</ulink> Руководства,
    касающемся телеконференций.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="irc">
    <para>Существуют ли каналы IRC (Internet Relay Chat) по FreeBSD?</para>
  </question>

  <answer>

  <para>Да, большинство сетей IRC имеют канал FreeBSD:</para>
 
  <para>     
    <itemizedlist>
      <listitem>
        <para>Канал <literal>#FreeBSD</literal> в сети EFNet
          посвящён FreeBSD, но не обращайтесь туда за технической поддержкой и
          даже не пытайтесь найти человека, который поможет вам обойтись без
          чтения страниц Справочника или собственных изысканий.  Этот канал
          предназначен в первую и основную очередь для общения, и в круг
          обсуждаемых тем входит секс, спорт, ядерное оружие, как будто это и
          есть FreeBSD.  В общем, вас предупредили!  Канал доступен на сервере
          <hostid>irc.chat.org</hostid>.</para>
      </listitem>

      <listitem>
        <para>Канал <emphasis>#FreeBSDhelp</emphasis> в сети EFNet предназначен
          для помощи пользователям FreeBSD.  Здесь гораздо более благосклонно
          относятся к вопросам, чем на
          канале <emphasis>#FreeBSD</emphasis>.</para>
      </listitem>

      <listitem>
        <para>Канал <literal>#FreeBSD</literal> в сети DALNET
          доступен на сервере <hostid>irc.dal.net</hostid> в США и на
          <hostid>irc.eu.dal.net</hostid> в Европе.</para>
      </listitem>

      <listitem>
        <para>Канал <literal>#FreeBSD</literal> в сети UNDERNET
          доступен на серверах <hostid>us.undernet.org</hostid> в США и
          <hostid>eu.undernet.org</hostid> в Европе.  Так как это канал
          взаимопомощи, приготовьтесь к чтению документации, к которой вас
          отошлют.</para>
      </listitem>

      <listitem>
        <para>Канал <literal>#FreeBSD</literal> в сети <ulink
          url="http://www.hybnet.net/">HybNet</ulink> доступен на сервере
          <hostid>irc.FreeBSD.org</hostid>.  Этот канал
          <emphasis>на самом деле</emphasis> является каналом
          взаимопомощи.</para>
      </listitem>
    </itemizedlist>
  </para>
 
  <para>Все эти каналы разные и не имеют отношения друг к другу. Их стили
    общения также отличаются, так что вам, может быть, придётся попробовать
    все, чтобы найти тот, который соответствует вашему стилю.  Как и обычно с
    *любым* каналом IRC, если вы легко раздражаетесь или не можете иметь дела
    с большим количеством лиц школьного (и младшего школьного) возраста,
    пытающихся озвучить свои попытки самоутверждения, не обращайте на это
    внимания.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="books">
    <para>Книги по FreeBSD</para>
  </question>

  <answer>

  <para>Вы можете обратиться в FreeBSD Documentation Project (а ещё лучше к
    нему присоединиться) через список рассылки
    <literal>freebsd-doc</literal>: <email>freebsd-doc@FreeBSD.org</email>.
    Этот список рассылки предназначен для обсуждения документации
    FreeBSD. Для вопросов по системе предназначен список рассылки
    <literal>freebsd-questions</literal>:
    <email>freebsd-questions@FreeBSD.org</email>.</para>
 
  <para>Имеется <quote>Руководство</quote> по FreeBSD, и оно может быть найдено
    на <ulink URL="../../handbook/index.html">веб-сервере</ulink>.
    Заметьте, что этот проект находится в процессе разработки;
    некоторые части могут отсутствовать или быть устаревшими.</para>
 
  <para>Прекрасным печатным руководством по FreeBSD является книга
    <quote>The Complete FreeBSD</quote>, написанная Грегом Лиэем (Greg Lehay) и
    изданная BSDi (бывшая Walnut Creek CDROM) Books. В настоящее время вышло
    второе издание, содержащее 1750 страниц руководств по установке и
    администрированию системы и прикладных программ, а также страницы
    Справочника. Книга (и последний релиз FreeBSD) может быть заказана в
    компаниях <ulink URL="http://www.osd.bsdi.com/">BSDi</ulink> и
    <ulink URL="http://www.cheapbytes.com/">CheapBytes</ulink> или в
    вашем любимом книжном магазине. Индекс ISBN 1-57176-227-2.</para>
 
  <para>Так как FreeBSD основана на выпуске Berkeley 4.4BSD-Lite,
    большинство руководств по 4.4BSD подходят к FreeBSD.
    O'Reilly and Associates издают следующие руководства:</para>
 
  <para>     
    <itemizedlist>
      <listitem>
        <para>4.4BSD System Manager's Manual <!-- <br> -->
          By Computer Systems Research Group, UC Berkeley <!-- <br> -->
          1st Edition June 1994, 804 pages <!-- <br> -->
          <ulink URL="http://www.amazon.com/exec/obidos/ASIN/1-56592-080-5">ISBN</ulink>: 1-56592-080-5 <!-- <br> --></para>
      </listitem>

      <listitem>
        <para>4.4BSD User's Reference Manual <!-- <br> -->
          By Computer Systems Research Group, UC Berkeley <!-- <br> -->
          1st Edition June 1994, 905 pages <!-- <br> -->
          <ulink URL="http://www.amazon.com/exec/obidos/ASIN/1-56592-075-9">ISBN</ulink>: 1-56592-075-9 <!-- <br> --></para>
      </listitem>

      <listitem>
        <para>4.4BSD User's Supplementary Documents <!-- <br> -->
          By Computer Systems Research Group, UC Berkeley <!-- <br> -->
          1st Edition July 1994, 712 pages <!-- <br> -->
          <ulink URL="http://www.amazon.com/exec/obidos/ASIN/1-56592-076-7">ISBN</ulink>: 1-56592-076-7 <!-- <br> --></para>
      </listitem>

      <listitem>
        <para>4.4BSD Programmer's Reference Manual <!-- <br> -->
          By Computer Systems Research Group, UC Berkeley <!-- <br> -->
          1st Edition June 1994, 886 pages <!-- <br> -->
          <ulink URL="http://www.amazon.com/exec/obidos/ASIN/1-56592-078-3">ISBN</ulink>: 1-56592-078-3 <!-- <br> --></para>
      </listitem>

      <listitem>
        <para>4.4BSD Programmer's Supplementary Documents <!-- <br> -->
          By Computer Systems Research Group, UC Berkeley <!-- <br> -->
          1st Edition July 1994, 596 pages <!-- <br> -->
          <ulink URL="http://www.amazon.com/exec/obidos/ASIN/1-56592-079-1">ISBN</ulink>: 1-56592-079-1 <!-- <br> --></para>
      </listitem>
    </itemizedlist>
  </para>
 
  <para>Описание этих книг может быть найдено через WWW как ссылка на
    <ulink URL="http://gnn.com/gnn/bus/ora/category/bsd.html">описание книг
    из набора 4.4BSD</ulink>.  Из-за малых объёмов продаж, эти книги найти
    труднее.</para>
 
  <para>Вы не ошибётесь, если для подробного ознакомления с устройством
    ядра 4.4BSD kernel обратитесь к следующей литературе:</para>
 
  <para>McKusick, Marshall Kirk, Keith Bostic, Michael J Karels,
    and John Quarterman.<!-- <br> --></para>
 
  <para><emphasis>The Design and Implementation of the 4.4BSD Operating
    System</emphasis>.  Reading, Mass. : Addison-Wesley, 1996.<!-- <br> -->
    <ulink URL="http://www.amazon.com/exec/obidos/ASIN/0-201-54979-4">ISBN</ulink> 0-201-54979-4<!-- <br> --></para>
 
  <para>Хорошей книгой по системному администрированию является:</para>
 
  <para>Evi Nemeth, Garth Snyder, Scott Seebass &amp;
    Trent R. Hein,<!-- <br> -->
    <quote>Unix System Administration Handbook</quote>, Prentice-Hall,
    1995<!-- <br> -->
    <ulink URL="http://www.amazon.com/exec/obidos/ASIN/0-13-151051-7">ISBN</ulink>: 0-13-151051-7<!-- <br> --></para>
 
  <para>
    <note>
      <para>Удостоверьтесь, что вы получили второе издание, с красной
        обложкой, а не первое.</para>
    </note>
  </para>

  <para>Эта книга касается основ администрирования, в том числе протоколов
    TCP/IP, DNS, NFS, SLIP/PPP, sendmail, INN/NNTP, системы печати и так
    далее..  Она сравнительно дорогая (примерно US&#36;45-&#36;55), но
    того стоит.  К ней прилагается также компакт-диск с исходными
    текстами различных утилит; большинство их них, однако, также 
    присутствуют на диске FreeBSD 2.2.6R (на котором к тому же
    часто находятся более свежие версии).</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="access-pr">
    <para>Как можно получить доступ к вашей базе сообщений о проблемах (Problem
      Report)?</para>
  </question>

  <answer>

  <para>Сообщения пользователей обо всех проблемах могут быть запрошены (или
    добавлены) с помощью нашего <ulink
    URL="http://www.FreeBSD.org/send-pr.html">веб-интерфейса</ulink> и <ulink
    URL="http://www.FreeBSD.org/cgi/query-pr-summary.cgi?query">запроса</ulink>.
    Команда <command>send-pr(1)</command> также может быть использована для
    передачи и изменения сообщений о проблемах через электронную почту.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="doc-formats">
    <para>Есть ли версии документации в другом формате, например,
      в виде обычного текста ASCII или PostScript?</para>
  </question>

  <answer>

  <para>Да.  Документация имеется в нескольких различных форматах и
    упакованная разными способами на FTP-сервере FreeBSD, и находится она
    в каталоге <ulink
    URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/">
    /pub/FreeBSD/doc/</ulink>.</para>

  <para>Документация подразделяется на категории различными способами.  Это
    включает:</para>

  <itemizedlist>
    <listitem>
      <para>Имя документа, например, <literal>faq</literal> или
        <literal>handbook</literal>.</para>
    </listitem>

    <listitem>
      <para>Язык и кодировка документа.  Они опираются на имена локализаций,
        которые вы найдёте в каталоге <filename>/usr/share/locale</filename>
        вашей системы FreeBSD.  На данный момент для документации поддерживаются
        следующие языки и кодировки:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Имя</entry>

              <entry>Значение</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>en_US.ISO8859-1</literal></entry>

              <entry>US English</entry>
            </row>

            <row>
              <entry><literal>es_ES.ISO8859-1</literal></entry>

              <entry>Испанский</entry>
            </row>

            <row>
              <entry><literal>fr_FR.ISO8859-1</literal></entry>

              <entry>Французский</entry>
            </row>

            <row>
              <entry><literal>ja_JP.eucJP</literal></entry>

              <entry>Японский (кодировка EUC)</entry>
            </row>

            <row>
              <entry><literal>ru_RU.KOI8-R</literal></entry>

              <entry>Русский (кодировка KOI8-R)</entry>
            </row>

            <row>
              <entry><literal>zh_TW.Big5</literal></entry>

              <entry>Китайский (кодировка Big5)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <note>
        <para>Некоторые документы могут иметься не на всех языках.</para>
      </note>
    </listitem>

    <listitem>
      <para>Формат документа.  Мы формируем документацию в нескольких различных
        форматах, пытаясь сделать её максимально гибкой.  Имеющиеся
        форматы;</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Формат</entry>

              <entry>Значение</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>html-split</literal></entry>

              <entry>Набор маленьких связанных друг с другом
                HTML-файлов.</entry>
            </row>

            <row>
              <entry><literal>html</literal></entry>

              <entry>Один большой HTML-файл, полностью содержащий
                документ </entry>
            </row>

            <row>
              <entry><literal>pdb</literal></entry>

              <entry>Формат баз данных Palm Pilot, для использования с
                утилитой <ulink
                URL="http://www.iSilo.com/">iSilo</ulink>.
              </entry>
            </row>

            <row>
              <entry><literal>pdf</literal></entry>

              <entry>Adobe's Portable Document Format</entry>
            </row>

            <row>
              <entry><literal>ps</literal></entry>

              <entry>Postscript</entry>
            </row>

            <row>
              <entry><literal>rtf</literal></entry>

              <entry>Microsoft's Rich Text Format
                <footnote>
                  <para>Номера страниц при загрузке в Word автоматически
                    не обновляются.  Нажмите
                    <keycap>CTRL</keycap>+<keycap>A</keycap>,
                    <keycap>CTRL</keycap>+<keycap>END</keycap>,
                    <keycap>F9</keycap> после загрузки документа для
                    обновления номеров страниц.</para>
                </footnote>
              </entry>
            </row>

            <row>
              <entry><literal>txt</literal></entry>

              <entry>Обычный текст</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </listitem>

    <listitem>
      <para>Способ компрессии и создания архива.  Сейчас используется
        три.</para>

      <orderedlist>
        <listitem>
          <para>В случае формата <literal>html-split</literal>, файлы
            архивируются с помощью &man.tar.1;.  Получающийся файл
            <filename>.tar</filename> затем подвергается сжатию по
            схемам, подробно описываемым далее.</para>
        </listitem>

        <listitem>
          <para>Все другие форматы генерируют один файл с именем
            <filename>book.<replaceable>format</replaceable></filename>
            (то есть <filename>book.pdb</filename>,
            <filename>book.html</filename>, и так далее).</para>

          <para>Эти файлы затем сжимаются по трём схемам сжатия.</para>

          <informaltable frame="none">
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>Схема</entry>

                  <entry>Описание</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>zip</literal></entry>

                  <entry>Формат Zip.  Если вам нужно будет развернуть это
                    во FreeBSD, то потребуется установить сначала порт
                    <filename>archivers/unzip</filename>.
                  </entry>
                </row>

                <row>
                  <entry><literal>gz</literal></entry>

                  <entry>Формат GNU Zip.  Для распаковки таких файлов
                    используется &man.gunzip.1;, которая является частью
                    FreeBSD.
                  </entry>
                </row>

                <row>
                  <entry><literal>bz2</literal></entry>

                  <entry>Формат BZip2.  Используется реже, чем другие, но,
                    как правило, даёт файлы меньшего размера.  Чтобы
                    работать с такими файлами, установите порт
                    <filename>archivers/bzip2</filename>.
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>Таким образом, версия Руководства в формате Postscript,
            упакованная с помощью BZip2, будет находиться в файле с именем
            <filename>book.sgml.bz2</filename> в каталоге
            <filename>handbook/</filename>.</para>
        </listitem>

        <listitem>
          <para>Отформатированная документация также доступна в виде пакаджей
            FreeBSD, о чём пойдёт речь несколько позже.</para>
        </listitem>
      </orderedlist>
    </listitem>
  </itemizedlist>

  <para>После выбора формата и способа компрессии, в котором вы хотите получить
    файл, вы должны определиться, должен ли он быть в виде
    <emphasis>пакаджа</emphasis> FreeBSD.</para>

  <para>Плюсом сгрузки и установки в виде пакаджа является то, что документация
    затем может управляться обычными средствами для работы с пакаджами, такими,
    как &man.pkg.add.1; и &man.pkg.delete.1;.</para>

  <para>Если вы решили сгрузить и установить пакадж, то вы должны знать имя
    файла.  Файлы, содержащие документацию в виде пакаджей, находятся в
    каталоге <filename>packages</filename>.  Каждый такой файл имеет вид
    <filename><replaceable>document-name</replaceable>.<replaceable>lang</replaceable>.<replaceable>encoding</replaceable>.<replaceable>format</replaceable>.tgz</filename>.</para>

  <para>Например, FAQ на английском языке в формате PDF находится в пакадже
    <filename>faq.en_US.ISO8859-1.pdf.tgz</filename>.</para>

  <para>Зная это, для установки пакаджа с англоязычным FAQ в формате PDF вы
    можете воспользоваться следующей командой.</para>

  <screen>
&prompt.root; <userinput>pkg_add ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/packages/faq.en_US.ISO8859-1.pdf.tgz</userinput>
  </screen>

  <para>Сделав это, можно использовать утилиту &man.pkg.info.1; для определения
    того, куда файл был установлен.</para>

  <screen>
&prompt.root; <userinput>pkg_info -f faq.en_US.ISO8859-1.pdf</userinput>
Information for faq.en_US.ISO8859-1.pdf:

Packing list:
        Package name: faq.en_US.ISO8859-1.pdf
        CWD to /usr/share/doc/en_US.ISO8859-1/books/faq
File: book.pdf
        CWD to .
File: +COMMENT (ignored)
File: +DESC (ignored)
  </screen>

  <para>Как видите, <filename>book.pdf</filename> будет установлен в
    <filename>/usr/share/doc/en_US.ISO8859-1/books/faq</filename>.</para>

  <para>Если же вы не хотите использовать пакаджи, то вам нужно самим сгрузить
    упакованные файлы, распаковать их, а затем скопировать документацию в
    соответствующие места.</para>

  <para>Например, версия FAQ в виде отдельных HTML-файлов, упакованная при
    помощи &man.gzip.1;, находится в файле
    <filename>en_US.ISO8859-1/books/faq/book.html-split.tar.gz</filename>.
    Для сгрузки и распаковки этого файла вам нужно сделать вот что.</para>

  <screen>
&prompt.root; <userinput>fetch ftp://ftp.freebsd.org/pub/FreeBSD/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.gz</userinput>
&prompt.root; <userinput>gzip -d book.html-split.tar.gz</userinput>
&prompt.root; <userinput>tar xvf book.html-split.tar</userinput>
  </screen>

  <para>У вас получится набор файлов <filename>.html</filename>.  Главным
    является <filename>index.html</filename>, и в нём находится оглавление,
    вводный материал и ссылки на остальные части документа.  После этого вы
    их можете копировать и перемещать при необходимости на окончательное
    местоположение.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="become-web-mirror">
    <para>Могу ли я зазеркалировать веб-сервер FreeBSD?</para>
  </question>

  <answer>

  <para>Несомненно! Есть несколько способов это сделать.</para>

  <itemizedlist>
    <listitem>
      <para>С помошью <application>CVSup</application>:
        Вы можете запрашивать отформатированные файлы с помощью
        <application>CVSup</application> и подключаться к серверу
        <application>CVSup</application>.</para>

      <para>Для получения страниц веб-сервера посмотрите на пример, находящийся
        в файле
        <filename>/usr/share/examples/cvsup/www-supfile</filename>.</para>
    </listitem>

    <listitem>
      <para>С помощью зеркалирования ftp:  Вы можете скачать оригинальную
        копию информации на веб-сервере, находящуюся на ftp, используя ваше
        любимое средство зеркалирования ftp.  Имейте в виду, что вам нужно
        будет ещё преобразовать эту информацию перед тем, как помещать её на
        вашем сервере.  Просто начните с каталога
        ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-CURRENT/www.</para>
    </listitem>
  </itemizedlist>

  </answer>
</qandaentry>


<qandaentry>
  <question id="translation">
    <para>Я могу перевести документацию на язык племени мумбо-юмбо.</para>
  </question>

  <answer>

  <para>Хорошо. Хотя мы не сможем заплатить, в наших силах подарить вам
    бесплатный CD или футболку и внести вас в список составителей
    Руководства, если вы предоставите перевод.  Перед тем, как начать перевод,
    обратитесь в список рассылки <emphasis>freebsd-doc</emphasis> по адресу
    <email>freebsd-doc@FreeBSD.org</email>; здесь можно найти тех, кто способен
    помочь в переводе.  Может также оказаться, что группа, занимающаяся
    переводом документации на выбранный вами язык, уже существует, и она не
    откажется от вашей помощи.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="other-info-sources">
    <para>Другие источники информации.</para>
  </question>

  <answer>

  <para>Следующие телеконференции содержат информацию о FreeBSD, которая 
    будет полезна её пользователям:</para>

  <itemizedlist>
    <listitem>
      <para><ulink URL="news:comp.unix.bsd.freebsd.announce">
        comp.unix.bsd.freebsd.announce</ulink> (модерируемая)</para>
    </listitem>

    <listitem>
      <para><ulink URL="news:comp.unix.bsd.freebsd.misc">
        comp.unix.bsd.freebsd.misc</ulink></para>
    </listitem>

    <listitem>
      <para><ulink
        URL="news:comp.unix.bsd.misc">comp.unix.bsd.misc</ulink></para>
    </listitem>
  </itemizedlist>

  <para>Web-ресурсы:</para>
 
  <itemizedlist>
    <listitem>
      <para><ulink
        URL="http://www.FreeBSD.org/">Веб-сервер FreeBSD</ulink>.</para>
    </listitem>

    <listitem>
      <para><anchor id="pao">Если у вас лаптоп, взгляните на страницу
        <ulink URL="http://www.jp.FreeBSD.org/PAO/">Tatsumi
        Hosokawa's Mobile Computing</ulink> в Японии.</para>
    </listitem>

    <listitem>
      <para><anchor id="smp">Информация о SMP (Symmetric MultiProcessing)
        находится на <ulink
        URL="http://people.FreeBSD.org/~fsmp/SMP/SMP.html">странице поддержки
        SMP</ulink>.</para>
    </listitem>

    <listitem>
      <para><anchor id="multimedia">Информация о мультимедийных приложениях
        для FreeBSD находится на <ulink
        URL="http://people.FreeBSD.org/~faulkner/multimedia/mm.html">
        мультимедийной странице</ulink>.  Если вы интересуетесь адаптерами
        захвата изображения <ulink
        URL="http://people.FreeBSD.org/~ahasty/Bt848.html">Bt848</ulink>,
        перейдите по ссылке.</para>
    </listitem>
  </itemizedlist>

  <para>В Руководстве по FreeBSD имеется достаточно полный <ulink
    URL="../../handbook/bibliography.html">библиографический раздел</ulink>,
    который стоит посмотреть, если вы хотите подыскать книгу по системе.</para>

  </answer>
</qandaentry>

</qandaset>

</preface>


<chapter id="install">
<title>Установка</title>

<qandaset>
<qandaentry>
  <question id="floppy-download">
    <para>Какой файл нужно скачать для установки FreeBSD?</para>
  </question>

  <answer>

  <para>До выхода в свет релиза FreeBSD 3.1 для установки вам был нужен только
    один файл с образом дискеты, <filename>floppies/boot.flp</filename>.
    Однако, начиная с версии 3.1, во FreeBSD была добавлена базовая поддержка
    для очень широкого спектра оборудования, что требует значительно большего
    дискового пространства, поэтому для установки FreeBSD версий 3.x и 4.x
    используются два образа дискет, находящиеся в файлах
    <filename>floppies/kernel.flp</filename> и
    <filename>floppies/mfsroot.flp</filename>.  Эти образы нужно перенести на
    дискеты с помощью таких утилит, как <command>fdimage</command> или
    &man.dd.1;.</para>

  <para>Если вы хотите скачать дистрибутив самостоятельно (например, для
    установки с раздела DOS), вот список рекомендованных частей 
    дистрибутива:</para>
 
  <itemizedlist>
    <listitem>
      <para> bin/<!-- <br> --> </para>
    </listitem>

    <listitem>
      <para> manpages/<!-- <br> --> </para>
    </listitem>

    <listitem>
      <para> compat*/<!-- <br> --> </para>
    </listitem>

    <listitem>
      <para> doc/ <!-- <br> --> </para>
    </listitem>

    <listitem>
      <para> src/ssys.* <!-- <br> --> </para>
    </listitem>
  </itemizedlist>

  <para>Полные инструкции по этой процедуре и об установке вообще можно
    найти в <ulink URL="../../handbook/install.html">разделе</ulink>
    Руководства, посвящённом инсталляции FreeBSD.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="floppy-image-too-large">
    <para>Помогите! Загрузочный файл не помещается на дискету!</para>
  </question><answer>

  <para>На дискету размером 3.5 дюйма (1.44Мб) может поместиться
    1474560 байт данных. Образ дискеты имеет размер ровно 1474560 байт.</para>

  <para>Типичные ошибки при подготовке загрузочной дискеты:</para>

  <itemizedlist>
    <listitem>
      <para>Образ дискеты был загружен по FTP не в режиме
        <emphasis>binary</emphasis>.</para>

      <para>Некоторые клиентские программы FTP используют по умолчанию
        текстовый (<emphasis>ascii</emphasis>) режим передачи и пытаются
        поменять все принятые последовательности символов "конец строки" на 
        соответствующие им в вашей системе. В таком случае образ
        загрузочного диска будет неизбежно испорчен. Проверьте размер
        полученного файла: если он не <emphasis>точно</emphasis> такой же,
        как на FTP-сервере, то ошибка произошла, скорее всего, в процессе
        передачи.</para>

      <para>Во избежание этого введите команду <emphasis>binary</emphasis> в
        командной строке FTP после того, как вы подключитесь к серверу, но до
        того, как начали скачивать файл.</para>
    </listitem>

    <listitem>
      <para>Для переноса образа на дискету была использована команда DOS
        <command>copy</command> (или её аналог с графическим
        интерфейсом).</para>

      <para>Программы типа <command>copy</command> не работают с образами
        дискет, предназначенными для загрузки. Образ содержит полное содержимое
        дискеты, дорожка за дорожкой, и не предназначен для помещения на
        дискету в качестве обычного файла. Вам необходимо перенести его
        на дискету <quote>непосредственно</quote>, используя низкоуровневые
        средства (такие, как <command>fdimage</command> или
        <command>rawrite</command>), описанные в <ulink
        URL="../../handbook/install.html">Руководстве</ulink>.</para>
    </listitem>
  </itemizedlist>

  </answer>
</qandaentry>


<qandaentry>
  <question id="install-instructions-location">
    <para>Где инструкции по установке FreeBSD?</para>
  </question>

  <answer>

  <para>Инструкции по установке могут быть найдены в
    <ulink URL="../../handbook/install.html">главе</ulink>
    Руководства, посвящённом установке FreeBSD.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="need-to-run">
    <para>Что мне нужно иметь для запуска FreeBSD?</para>
  </question>

  <answer>

  <para>Вам нужен персональный компьютер не ниже 386, с 5 или более
    мегабайтами ОЗУ и по крайней мере 60Мб свободного пространства на
    винчестере.  Система может работать с дешёвым графическим адаптером MDA,
    но для того, чтобы запустить X11R6, требуется адаптер стандарта VGA
    или лучше.</para>

  <para>Посмотрите также раздел
    <xref linkend="hardware" remap="Аппаратная совместимость">.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="four-meg-ram-install">
    <para>У меня только 4Мб ОЗУ. Смогу ли я установить FreeBSD?</para>
  </question>

  <answer>

  <para>FreeBSD 2.1.7 была последней версией, которую можно было
    проинсталлировать на системе с 4Мб ОЗУ. Более новые версии FreeBSD,
    типа 2.2, требуют по крайней мере 5Мб ОЗУ для установки.</para>

  <para>Все версии FreeBSD, включая 3.0, будут <emphasis>работать</emphasis> на
    4Мб ОЗУ, просто на 4Мб нельзя запустить инсталляционную программу. Вы
    можете добавить дополнительную память для инсталляции, если вам
    это нужно, а после того, как система будет установлена и запущена,
    вернуться к конфигурации с 4Мб. Или вы можете подключить ваш диск
    к компьютеру с ОЗУ, большим чем 4Мб, проинсталлировать систему и
    переставить диск обратно.</para>

  <para>Есть ещё несколько причин, по которым FreeBSD 2.1.7 не будет
    устанавливаться с 4Мб. А именно: она не будет устанавливаться
    на системе с 640Кб основной и 3Мб дополнительной памяти. Если ваша
    материнская плата может перемещать некоторую <quote>потерянную</quote>
    память из области 640Кб в область 1Мб, тогда может быть, вы
    сможете запустить FreeBSD 2.1.7.</para>

  <para>Попробуйте войти в настройку вашего BIOS и посмотреть параметры
    <quote>перемещения</quote> (remap).  Включите его.  Может быть, ещё
    понадобится выключить теневое ПЗУ (ROM shadowing).</para>

  <para>Может быть, самое простое решение - найти еще 4Мб на время
    инсталляции. Откомпилируйте ядро только с теми параметрами, которые
    нужны и затем уберите 4Мб.</para>

  <para>Вы можете также проинсталлировать версию 2.0.5, а затем
    обновить вашу систему до 2.1.7 с помощью пункта <quote>upgrade</quote>
    программы инсталляции 2.1.7.</para>

  <para>После установки вы можете построить ядро, которое будет работать
    на 4Мб. Кто-то даже умудрялся загружаться с 2Мб (хотя система
    в основном была неработоспособна :-))</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="custom-boot-floppy">
    <para>Как сделать оригинальную загрузочную дискету?</para>
  </question><answer>

  <para>В настоящий момент нет <emphasis>простого</emphasis> способа сделать
    оригинальную загрузочную дискету.  Вам придётся делать новый релиз
    полностью, включая загрузочную дискету.</para>

  <para>Чтобы сделать оригинальный релиз, следуйте инструкциям <link
    linkend="custrel">здесь</link>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="multiboot">
    <para>Могу ли я иметь более чем одну операционную систему на моём PC?</para>
  </question>

  <answer>

  <para>Взгляните на это <ulink
    URL="http://www.FreeBSD.org/tutorials/multi-os/">руководство</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="windows-coexist">
    <para>Может ли Windows 95/98 сосуществовать с FreeBSD?</para>
  </question>

  <answer>

  <para>Сначала установите Windows 95/98, а затем FreeBSD.  Менеджер загрузки
    FreeBSD будет управлять процессом загрузки Win95/98 или FreeBSD.  Если
    после этого вы ещё раз выполните процедуру установки Windows 95/98, то при
    этом менеджер загрузки будет грубо удалён.  Если такое случится, обратитесь
    к следующему разделу.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="win95-damaged-boot-manager">
    <para>Windows 95/98 уничтожила мой менеджер загрузки! Как мне его
      вернуть?</para>
  </question>

  <answer>

  <para>Вы можете переустановить менеджер загрузки FreeBSD тремя
    способами:</para>

  <itemizedlist>
    <listitem>
      <para>Запустите DOS, перейдите в каталог tools/ вашего дистрибутива
        FreeBSD и найдите программу <filename>bootinst.exe</filename>.
        Запустите её следующим образом:</para>

      <screen>
<prompt>...\TOOLS&gt;</prompt> <userinput>bootinst.exe boot.bin</userinput>
      </screen>

      <para>и менеджер загрузки будет переустановлен.</para>
    </listitem>

    <listitem>
      <para>Загрузитесь с установочной дискеты FreeBSD и перейдите в меню
        установки Custom install.  Выберите пункт Partition.  Выберите
        устройство, на котором будет располагаться для ваш менеджера загрузки
        (это будет самый первый диск) и когда вы перейдете к редактированию
        разделов, первым делом (то есть ещё не делая никаких изменений)
        выберите (W)rite.  Последует запрос на подтверждение, ответьте yes,
        и когда вы попадёте в меню выбора менеджера загрузки, выберите 
        пункт <literal>Boot Manager</literal>.  Менеджер загрузки будет
        переписан на диск.  Теперь нужно выйти из меню установки и загрузиться
        с винчестера как обычно.</para>
    </listitem>

    <listitem>
      <para>Загрузитесь с установочной дискеты (или компакт-диска) FreeBSD и
        найдите пункт меню <quote>Fixit</quote>.  Выберите Fixit floppy или
        CD-ROM #2 (<quote>живая</quote> файловая система) соответственно
        вашему случаю и вы окажетесь в приглашении командного процессора.
        Теперь выполните следующую команду:</para>

      <screen>
<prompt>Fixit#</prompt> <userinput>fdisk -B -b /boot/boot0 <replaceable>bootdevice</replaceable></userinput>
      </screen>

      <para></para>

      <para>подставив вместо <replaceable>bootdevice</replaceable> название
        реально используемого для загрузки устройства, например,
        <devicename>ad0</devicename> (первый диск IDE),
        <devicename>ad4</devicename> (первый диск IDE на дополнительном
        контроллере), <devicename>da0</devicename> (первый диск SCSI) и
        тому подобное.</para>
    </listitem>
  </itemizedlist>

  </answer>
</qandaentry>


<qandaentry>
  <question id="boot-on-thinkpad">
    <para>На компьютерах IBM Thinkpad серий A, T и X операционная система
      устанавливается, но при следующей перезагрузке машины зависают.  Как
      можно от этого избавиться?</para>
  </question>

  <answer>
  <para>Из-за ошибки в первых версиях BIOS от IBM раздел FreeBSD на этих
    машинах распознается как возможный служебный раздел FAT для режима
    сна.  Когда BIOS пытается обработать раздел FreeBSD, происходит
    зависание.</para>

  <para>Согласно IBM<footnote> <para>Письмо от Keith Frechette
    <email>kfrechet@us.ibm.com</email>.</para></footnote>, исправление
    включено в следующие релизы моделей/BIOS.</para>

  <informaltable frame="none">
  <tgroup cols="2">
  <thead>
    <row>
      <entry>Модель</entry>
      <entry>Номер версии BIOS</entry>
    </row>
  </thead>

  <tbody>
    <row>
      <entry>T20</entry>
      <entry>IYET49WW и выше</entry>
    </row>

    <row>
      <entry>T21</entry>
      <entry>KZET22WW и выше</entry>
    </row>

    <row>
      <entry>A20p</entry>
      <entry>IVET62WW и выше</entry>
    </row>

    <row>
      <entry>A20m</entry>
      <entry>IWET54WW и выше</entry>
    </row>

    <row>
      <entry>A21p</entry>
      <entry>KYET27WW и выше</entry>
    </row>

    <row>
      <entry>A21m</entry>
      <entry>KXET24WW и выше</entry>
    </row>

    <row>
      <entry>A21e</entry>
      <entry>KUET30WW</entry>
    </row>
  </tbody>
  </tgroup>
  </informaltable>

  <para>Если у вас BIOS более ранней версии и обновление для вас не
    представляется возможным, то это можно обойти, установив FreeBSD, изменив
    идентификатор раздела, используемый FreeBSD и установив новые загрузочные
    блоки, которые могут работать с различными ID разделов.</para>

  <para>Во-первых, вам нужно привести компьютер в состояние, когда он
    проходит через экран самотестирования.  Для этого требуется включить
    машину, не позволяя ей найти раздел FreeBSD на ведущем диске.  Одним
    из способов сделать это является извлечение винчестера и временное
    его установка на более старый ThinkPad (такой, как ThinkPad 600) или
    настольный ПК с подходящим переходным кабелем.  Здесь вы можете
    удалить раздел FreeBSD и вернуть диск на место.  ThinkPad должен
    загружаться снова.</para>

  <para>С работающей машиной вы можете использовать процедуру, описанную
    здесь, для получения рабочей системы FreeBSD.</para>

  <procedure>
    <step>
      <para>Сгрузите файлы <filename>boot1</filename> и
        <filename>boot2</filename> по адресу <ulink
        url="http://people.freebsd.org/~bmah/ThinkPad/">
        http://people.freebsd.org/~bmah/ThinkPad/</ulink>.  Поместите эти
        файлы куда-нибудь, откуда вы сможете их потом взять.</para>
    </step>

    <step>
      <para>Установите FreeBSD обычным образом на ThinkPad.  <emphasis>Не
        используйте</emphasis> режим <literal>Dangerously
        Dedicated</literal>.  <emphasis>Не перезагружайтесь</emphasis>
        после окончания установки.</para>
    </step>

    <step>
      <para>Переключитесь в экран <quote>Emergency Holographic
        Shell</quote> (<keycombo><keycap>ALT</keycap>
        <keycap>F4</keycap></keycombo>) или запустите оболочку
        <quote>fixit</quote>.</para>
    </step>

    <step>
      <para>Используйте команду &man.fdisk.8; для изменения идентификатора
        раздела FreeBSD со <literal>165</literal> на <literal>166</literal>
        (этот тип используется в OpenBSD).</para>
    </step>

    <step>
      <para>Перепишите файлы <filename>boot1</filename> и
        <filename>boot2</filename> на локальную файловую систему.</para>
    </step>

    <step>
      <para>Для записи <filename>boot1</filename> и
        <filename>boot2</filename> на слайс с FreeBSD воспользуйтесь
        командой &man.disklabel.8;.</para>

      <screen>
&prompt.root; <userinput>disklabel -B -b boot1 -s boot2 ad0s<replaceable>n</replaceable></userinput>
      </screen>

      <para>Здесь <replaceable>n</replaceable> означает номер слайса,
        в котором установлена FreeBSD.</para>
    </step>

    <step>
      <para>Выполните переагрузку.  В приглашении загрузчика вам будет
        дан выбор для загрузки <literal>OpenBSD</literal>.  На самом деле
        при этом загружается FreeBSD.</para>
    </step>
  </procedure>

  <para>Случай, когда вы хотите загружать OpenBSD и FreeBSD на одном и
    том же лэптопе оставлен читателю в качестве упражнения.</para>
  </answer>

</qandaentry>


<qandaentry>
  <question id="install-bad-blocks">
    <para>Можно ли производить установку на диск с повреждёнными
      блоками?</para>
  </question>

  <answer>

  <para>До версии 3.0 в поставку FreeBSD включалась утилита, известная под
    именем <command>bad144</command>, которая автоматически переносила
    повреждённые блоки.  Так как современные диски с интерфейсом IDE выполняют
    эту функцию самостоятельно, то утилита <command>bad144</command> была
    удалена из дерева исходных текстов FreeBSD.  Если вы собираетесь
    устанавливать FreeBSD 3.0 и выше, то мы настоятельно рекомендуем приобрести
    новый диск.  Если вы этого делать не собираетесь, то устанавливайте
    FreeBSD 2.x.</para>

  <para>Если вы обнаружите испорченные блоки на современном диске IDE, то
    весьма вероятно, что он скоро выйдет из строя совсем (собственная
    способность переносить испорченные блоки исчерпана, что означает очень
    большую порчу поверхности); мы рекомендуем приобрести новый диск.</para>

  <para>Если повреждённые блоки находятся на SCSI диске, взгляните на <link
    linkend="awre">такое решение</link>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="boot-floppy-strangeness">
    <para>Странные вещи происходят при загрузке с инсталляционного
      диска!</para>
  </question>

  <answer>

  <para>Если вы видите, что машина зависает или неожиданно 
    перезагружается, когда вы пытаетесь загрузиться с установочной
    дискеты, вы должны задать себе три вопроса:-</para>

  <orderedlist>
    <listitem>
      <para>Вы используете новую, только что отформатированную дискету
        (предпочтительно неиспользованную прямо из коробки, а не ту, что
        пришла с популярным журналом и последние три года провалялась под
        диваном)?</para>
    </listitem>

    <listitem>
      <para>Вы скачали образ дискеты в двоичном режиме?
        (не смущайтесь, даже лучшие из нас время от времени скачивают
        двоичный файл в режиме ASCII!)</para>
    </listitem>

    <listitem>
      <para>Если вы используете Windows95 или Win98, удостоверьтесь, что вы
        запускаете <command>fdimage</command> или <command>rawrite</command>
        в режиме чистого DOS?  Эти операционные системы могут влиять на
        программы, работающие непосредственно с оборудованием, что и делает
        программа создания установочного диска; даже запуск из DOS в
        графической оболочке может вызвать проблемы.</para>
    </listitem>
  </orderedlist>

  <para>Есть сведения, что Netscape вызывает проблемы при скачивании
    загрузочного диска, так что лучше всего использовать специальную
    программу FTP, если она у вас есть.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="no-install-cdrom">
    <para>Я загрузился с ATAPI CD-ROM, однако программа установки сообщила, что
      CD-ROM не найден.  Куда он подевался?</para>
  </question>

  <answer>

  <para>Обычной причиной возникновения такой проблемы является неправильно
    сконфигурированный привод CD-ROM.  Теперь зачастую ПК продаются с CD-ROM,
    установленным как ведомое устройство на втором контроллере IDE, но без
    ведущего устройства на этом контроллере.  Согласно спецификации ATAPI,
    такая конфигурация неверна, однако Windows в таком случае всё же работает,
    и BIOS игнорирует это при загрузке.  Вот почему BIOS может видеть CD-ROM
    при загрузке, а FreeBSD для завершения установки - нет.</para>

  <para>Переконфигурируйте вашу систему так, чтобы CD-ROM оказался либо
    основным устройством на том IDE-контроллере, на котором он установлен,
    либо ведомым устройством на контроллере IDE, который имеет ведущее
    устройство.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="cannot-install-tape">
    <para>Помогите! Не могу установить систему с ленты!</para>
  </question>

  <answer>

  <para>Если вы инсталлируете 2.1.7R с ленты, вы должны создать
    ленту с размером блока tar, равным 10 (5120 байт). Размер
    блока tar по умолчанию равен 20 (10240 байт), поэтому ленты,
    созданные со стандартным размером блока, не могут быть использованы
    для установки 2.1.7R; вы получите сообщение об ошибке, говорящее,
    что размер записи слишком большой.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="parallel-connect">
    <para>Соединение двух машин с FreeBSD через параллельные
      порты (PLIP)</para>
  </question>

  <answer>

  <para>Для этого нужен соединительный шнур типа laplink и на обеих машинах
    должна быть включена поддержка драйвера lpt.</para>
 
  <screen>
&prompt.root; <userinput>dmesg | grep lp</userinput>
lpt0 at 0x378-0x37f irq 7 on isa
lpt0: Interrupt-driven
lp0: TCP/IP capable interface
  </screen>

  <para>Подключите кабель laplink к параллельным портам компьютеров.</para>
 
  <para>Настройте параметры сетевого интерфейса lp0 на обеих машинах, войдя
    администратором.  Например, если вы хотите соединить хосты с именами
    max и moritz</para>
 
  <programlisting>
                max &lt;-----&gt; moritz
IP Address    10.0.0.1      10.0.0.2
  </programlisting>

  <para>на машине max дайте команду</para>

  <screen>
&prompt.root; <userinput>ifconfig lp0 10.0.0.1 10.0.0.2</userinput>
  </screen>

  <para>на машине moritz запустите</para>

  <screen>
&prompt.root; <userinput>ifconfig lp0 10.0.0.2 10.0.0.1</userinput>
  </screen>

  <para>Это всё!  Пожалуйста, прочтите ещё страницы Справочника &man.lp.4;
    и &man.lpt.4;.</para>

  <para>Вы также должны добавить эти хосты в файл
    <filename>/etc/hosts</filename>.</para>

  <programlisting>
127.0.0.1               localhost.my.domain localhost
10.0.0.1                max.my.domain max
10.0.0.2                moritz.my.domain
  </programlisting>

  <para>Для проверки работоспособности связи выполните следующие
    действия:</para>
 
  <para>на машине max:</para>

  <screen>
&prompt.root; <userinput>ifconfig lp</userinput>0
lp0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>

Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
moritz             max              UH          4   127592       lp0
&prompt.root; <userinput>ping -c 4 moritz</userinput>
PING moritz (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- moritz ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="install-PLIP">
    <para>Можно ли я установить систему на лэптоп через PLIP (Parallel
      Line IP)?</para>
  </question>

  <answer>

  <para>Для этого нужно соединить два компьютера параллельным кабелем
    Laplink особым образом.</para>

  <table>
    <title>Соединение параллельного кабеля для работы с сетью</title>

    <tgroup cols="5">
      <thead>
        <row>
          <entry>A-name</entry>

          <entry>A-End</entry>

          <entry>B-End</entry>

          <entry>Descr.</entry>

          <entry>Post/Bit</entry>
        </row>
      </thead>

      <tbody>
        <row>
          <entry><literallayout>DATA0
-ERROR</literallayout></entry>

          <entry><literallayout>2
15</literallayout></entry>

          <entry><literallayout>15
2</literallayout></entry>

          <entry>Data</entry>

          <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
        </row>

        <row>
          <entry><literallayout>DATA1
+SLCT</literallayout></entry>

          <entry><literallayout>3
13</literallayout></entry>

          <entry><literallayout>13
3</literallayout></entry>

          <entry>Data</entry>

          <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
        </row>

        <row>
          <entry><literallayout>DATA2
+PE</literallayout></entry>

          <entry><literallayout>4
12</literallayout></entry>

          <entry><literallayout>12
4</literallayout></entry>

          <entry>Data</entry>

          <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
        </row>

        <row>
          <entry><literallayout>DATA3
-ACK</literallayout></entry>

          <entry><literallayout>5
10</literallayout></entry>

          <entry><literallayout>10
5</literallayout></entry>

          <entry>Strobe</entry>

          <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
        </row>

        <row>
          <entry><literallayout>DATA4
BUSY</literallayout></entry>

          <entry><literallayout>6
11</literallayout></entry>

          <entry><literallayout>11
6</literallayout></entry>

          <entry>Data</entry>

          <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
        </row>

        <row>
          <entry>GND</entry>

          <entry>18-25</entry>

          <entry>18-25</entry>

          <entry>GND</entry>

          <entry>-</entry>
        </row>
      </tbody>
    </tgroup>
  </table>

  <para>Посмотрите также <link linkend="pao">это замечание</link> на странице,
    посвящённой мобильным вычислениям.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="geometry">
    <para>Какие параметры диска я должен использовать?</para>
  </question>

  <answer>

  <para>
    <note>
      <para>Под <quote>параметрами</quote> диска мы понимаем число дорожек,
        головок и секторов на дорожку на диске, что для простоты обозначается
        как C/H/S.  Именно так работает BIOS персональных компьютеров при чтении
        или записи диска.</para>
    </note>
  </para>

  <para>Похоже, что по каким-то причинам это вызывает много недоразумений.
    Прежде всего, <emphasis>физические</emphasis> параметры диска SCSI не
    имеют никакого значения, так как FreeBSD работает в терминах дисковых
    блоков.  Фактически нет такого показателя, как <emphasis>физические
    параметры</emphasis>, так как плотность размещения секторов различна по
    всему диску; то, что производители называют <emphasis>реальными</emphasis>
    физическими параметрами, есть не
    что иное, как свободное пространство. Для дисков IDE, 
    FreeBSD работает в терминах C/H/S, но во всех современных дисках они
    преобразовываются во внутреннее представление.</para>
  
  <para>Имеют значение только <emphasis>логические</emphasis> параметры - это
    те, что получает BIOS, когда спрашивает <quote>какие у тебя
    параметры?</quote>, а затем
    использует для обращения к диску.  Так как FreeBSD использует BIOS
    при загрузке, очень важно получить верные параметры.  В частности,
    если у вас на диске находятся несколько операционных систем, они обе
    должны иметь одинаковое представление о параметрах диска, иначе
    серьёзные проблемы при загрузке неизбежны!</para>

  <para>В случае дисков SCSI, параметры используются в зависимости от того,
    включена ли поддержка расширенной трансляции на вашем контроллере
    (что часто обозначается как <quote>поддержка дисков DOS &gt;1GB</quote> или
    что-то похожее).  Если эта возможность выключена, то используйте
    <replaceable>N</replaceable> дорожек, 64 головки и 32 сектора на дорожку,
    где <replaceable>N</replaceable> - это ёмкость
    диска в мегабайтах. Например, 2Гбайтный диск должен иметь 2048 
    дорожек, 64 головки и 32 сектора на дорожку.</para>

  <para>Если трансляция <emphasis>включена</emphasis> (что обычно используется
    для преодоления некоторых ограничений MSDOS) и ёмкость диска превышает
    1ГБ, используется M дорожек, 63 сектора на дорожку (*не* 64) и 255
    головок, где 'M' - это объём диска в мегабайтах, поделённый на
    7.844238 (!).  Таким образом, наш диск объёмом 2ГБ будет иметь 
    261 дорожку, 63 сектора на дорожку и 255 головок.</para>

  <para>Если вы не уверены, или FreeBSD ошибается при определении
    параметров диска во время установки, самый простой способ решить эту 
    проблему - создать на диске маленький раздел DOS.  После этого
    параметры диска должны определиться правильно (и вы всегда можете
    удалить раздел DOS в редакторе разделов, если вы не хотите его
    сохранить, или оставить его для настройки сетевых адаптеров и подобных
    вещей).</para>

  <para>Кроме того, существует свободно доступная утилита, распространяемая
    вместе с FreeBSD, которая называется <filename>pfdisk.exe</filename>
    (можно найти в каталоге <filename>tools</filename> компакт-диска с FreeBSD
    или на различных ftp-серверах), которую можно использовать для определения
    параметров, которые используются другими операционными системами,
    расположенными на вашем диске.  Затем вы можете использовать эти 
    параметры в редакторе разделов.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="disk-divide-restrictions">
    <para>Есть ли ограничения на разбиение диска?</para>
  </question>

  <answer>

  <para>Да. Вы должны убедиться, что корневой раздел находится до
    1024 дорожки, так чтобы BIOS могла загрузить с него ядро. (Заметьте,
    что это ограничение BIOS компьютера, а не FreeBSD).</para>

  <para>Для диска SCSI, это, как правило, будет означать, что
    корневой раздел располагается в первых 1024Мб (или в первых 4096Мб,
    если включен режим расширенной трансляции - посмотрите предыдущий
    вопрос).  Для дисков IDE соответствующее значение равно 504Мб.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="disk-manager">
    <para>Как насчёт менеджеров диска? У меня большой диск!</para>
  </question>

  <answer>

  <para>FreeBSD распознаёт Ontrack Disk Manager и допускает его
    использование. Другие менеджеры дисков не поддерживаются.</para>

  <para>Если вы хотите использовать диск с FreeBSD, вам не нужен
    менеджер диска. Отконфигурируйте диск на столько пространства,
    сколько сможет обработать BIOS (обычно 504 мегабайта). и
    FreeBSD распознает, сколько места у вас есть на самом деле.
    Если вы используете старый диск с контроллером MFM, вам может
    потребоваться точно указать FreeBSD количество используемых
    дорожек.</para>

  <para>Если вы хотите использовать FreeBSD совместно с другой
    операционной системой, это можно сделать и без менеджера диска:
    удостоверьтесь, что загрузочный раздел FreeBSD и раздел для другой
    операционной системы не выходят за пределы 1024 дорожки. Если вы
    будете осторожны, 20 мегабайтного раздела для загрузки будет
    достаточно.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="missing-os">
    <para>При загрузке FreeBSD выдаётся сообщение <literal>Missing Operating
      System</literal></para>
  </question>

  <answer>

  <para>Это классический  случай, когда FreeBSD и DOS или другая операционная
    система конфликтуют по поводу <link linkend="geometry">параметров</link>
    диска.  Вам нужно будет переустановить FreeBSD, но имейте в виду, что
    инструкции, данные выше, помогают всегда.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="stop-at-boot-manager">
    <para>После приглашения менеджера загрузки <literal>F?</literal> ничего не
      происходит.</para>
  </question>

  <answer>

  <para>Это ещё один признак проблемы, описанной в предыдущем разделе.
    Параметры диска в BIOS и параметры, используемые FreeBSD, не 
    совпадают. Если ваш контроллер или BIOS поддерживают трансляцию
    дорожек (часто обозначаемую как <literal>&gt;1GB drive support</literal>),
    попробуйте включить эту возможность и переустановить FreeBSD.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="need-complete-sources">
    <para>Нужно ли устанавливать все исходные тексты системы?</para>
  </question>

  <answer>

  <para>В общем случае, нет. Однако мы настоятельно рекомендуем установить, как
    минимум, исходные тексты набора <literal>base</literal>,
    включающий некоторые файлы, здесь упоминаемые,
    и <literal>sys</literal>, в который включены исходные тексты
    ядра.  Для работы системы присутствия исходных текстов не требуется, разве
    что для программы конфигурирования ядра &man.config.8;.  За исключением
    исходных текстов ядра, структура исходных текстов системы
    позволяет монтировать их в режиме "только для чтения" через NFS и
    компилировать программы.  (Из-за ограничения на исходные тексты ядра мы
    рекомендуем монтировать их не прямо в <filename>/usr/src</filename>, а в
    какой-нибудь другой каталог с символическими ссылками для дублирования
    структуры каталогов.</para>

  <para>Наличие исходных текстов системы значительно облегчает процесс
    перехода на новые версии FreeBSD.</para>

  <para>Для выбора подмножества исходных текстов, которое вы хотите
    установить, используйте пункт меню Custom, когда находитесь в меню
    Distributions программы установки.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="need-kernel">
    <para>Нужно ли перекомпилировать ядро?</para>
  </question>

  <answer>

  <para>Построение нового ядра всегда было необходимым шагом при
    установке FreeBSD, однако последние релизы предоставляют более
    дружественный инструмент конфигурации ядра. В командной строке
    на приглашение загрузчика FreeBSD (boot:) введите <option>-c</option> и вы 
    попадёте в экран визуальной настройки, которая позволяет 
    конфигурировать настройки ядра для большинства адаптеров ISA.</para>
  
  <para>Однако рекомендуется, что потом вы всё же построите новое ядро,
    содержащее только те драйверы, которые вам нужны, для того,
    чтобы сэкономить немного ОЗУ, хотя для большинства систем это 
    больше не является большой необходимостью.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="password-encryption">
    <para>Какой из паролей - DES или MD5, я должен использовать и как указать,
      какого типа пароли используются пользователями?</para>
  </question>

  <answer>

  <para>По умолчанию во FreeBSD используется формат паролей на основе
    <emphasis>MD5</emphasis>.  Это делается в предположении, что он более
    защищён, чем традиционный формат паролей UNIX, в котором используется схема
    на основе алгоритма <emphasis>DES</emphasis>.  Пароли DES остаются
    применимыми, если вам нужно использовать файл паролей совместно с более
    старыми операционными системами, в которых используется менее защищённый
    формат паролей (их можно использовать, если в программе sysinstall вы
    выберите установку дистрибутива <quote>crypto</quote> или установите
    исходные тексты пакета crypto в случае построения из исходных текстов).
    Управление выбором используемого формата паролей осуществляется через
    параметр входа <quote>passwd_format</quote> в файле
    <filename>/etc/login.conf</filename>, принимающий значения
    <quote>des</quote> (если он есть) или <quote>md5</quote>.  Более подробная
    информация о параметрах входа находится на странице Справочника
    login.conf(5).</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="boot-floppy-hangs">
    <para>Загрузка с установочной дискеты прерывается на сообщении
      <literal>Probing Devices...</literal>.</para>
  </question>

  <answer>

  <para>Если у вас установлены устройства IDE Zip или Jaz, уберите их
    и попробуйте снова. Они могут мешать инсталляционной программе. После
    того, как система будет установлена, вы можете снова подключить
    устройства. Надеемся, что это будет исправлено в более поздних
    релизах.</para>
  
  </answer>
</qandaentry>


<qandaentry>
  <question id="panic-on-install-reboot">
    <para>Сообщение <literal>panic: cant mount root</literal> после перезагрузки
      только что установленной системы.</para>
  </question>

  <answer>

  <para>Эта ошибка проявляется, когда есть несогласование между представлениями
    загрузочного блока и ядра о дисковых устройствах.  Эта ошибка обычно
    проявляется на системах с двумя дисками IDE, с винчестерами, установленными
    как ведущий или единственный на отдельных контроллерах IDE, с FreeBSD,
    инсталлированной на втором контроллере IDE.  Программа в загрузочных блоках
    полагает, что система установлена на wd1 (второй диск BIOS), тогда как ядро
    даёт первому диску на втором контроллере название wd2.  После обнаружения
    устройства ядро пытается смонтировать то, что загрузочные блоки выдают за
    загрузочный диск, wd1, тогда как он на самом деле wd2, и ошибается.</para>

  <para>Для разрешения этой проблемы сделайте одно из следующих действий:</para>
  
  <para>
    <orderedlist>
      <listitem>
        <para>Для FreeBSD 3.3 и выше, перегрузите систему и нажмите
          <literal>Enter</literal> при появлении приглашения <literal>Booting
          kernel in 10 seconds; hit [Enter] to interrupt</literal>.  Вы
          окажетесь в загрузчике.</para>

        <para>После этого наберите <literal>set
          root_disk_unit="<replaceable>disk_number</replaceable>"</literal>.
          Здесь в качестве <replaceable>disk_number</replaceable> должен быть
          указан <literal>0</literal>, если FreeBSD установлена на ведущем диске
          первого контроллера IDE, <literal>1</literal> если она установлена
          на ведомом диске первого контроллера IDE, <literal>2</literal>, если
          система находится на ведущем диске второго IDE-контроллера и
          <emphasis>3</emphasis>, если она установлена на ведомом диске второго
          контроллера IDE.</para>

        <para>Затем введите команду <literal>boot</literal>, и ваша система
          должна нормально загрузиться.</para>

        <para>Чтобы сделать эти изменения постоянными (то есть чтобы вам не
          было нужды выполнять эти действия каждый раз при перезагрузке или
          включении вашей машины с FreeBSD), поместите строчку
          <literal>root_disk_unit="<replaceable>disk_number</replaceable>"</literal>
          в файл <filename>/boot/loader.conf.local</filename>.</para>
      </listitem>

      <listitem>
        <para>При использовании FreeBSD 3.2 и более ранних версий в приглашении
          Boot: наберите <literal>1:wd(2,a)kernel</literal> и
          нажмите клавишу Enter.  Если система запустилась, выполните команду
          <command>echo "1:wd(2,a)kernel" &gt; /boot.config</command>
          чтобы сделать это строкой загрузки по умолчанию.</para>
      </listitem>

      <listitem>
        <para>Поместите диск с FreeBSD на первичный контроллер IDE, так чтобы
          именования диском пришли в соответствие.</para>
      </listitem>

      <listitem>
        <para><ulink
          URL="../../handbook/kernelconfig.html">Перестройте ядро</ulink>,
          изменив конфигурацию контроллера wd на следующее:</para>

        <programlisting>
controller      wdc0    at isa? port "IO_WD1" bio irq 14 vector wdintr
disk            wd0     at wdc0 drive 0
# disk            wd1     at wdc0 drive 1 # comment out this line

controller      wdc1    at isa? port "IO_WD2" bio irq 15 vector wdintr
disk            wd1     at wdc1 drive 0 # change from wd2 to wd1
disk            wd2     at wdc1 drive 1 # change from wd3 to wd2
        </programlisting>

        <para>Проинсталлируйте новое ядро.  Если вы переместили ваши диски и
          хотите восстановить предыдущую настройку, замените диски в нужной
          конфигурации и перезагрузитесь.  Ваша система должна нормально
          запуститься.</para>
      </listitem>
    </orderedlist>
  </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="memory-limits">
    <para>Какие имеются ограничения на объём оперативной памяти?</para>
  </question>

  <answer>

  <para>Размер оперативной памяти ограничен объёмом в 4 гигабайта.  Такая
    конфигурация реально тестировалась, подробности есть в <ulink
    URL="ftp://ftp.cdrom.com/archive-info/configuration">конфигурации
    wcarchive</ulink>.  Если вы собираетесь устанавливать столько оперативной
    памяти в компьютер, будьте внимательны.  Скорее всего, вам придётся
    использовать память ECC и для уменьшения нагрузки также взять 9-чиповые
    модули памяти вместо 18-чиповых.</para>

</answer></qandaentry>


<qandaentry>
  <question id="ffs-limits">
    <para>Какие существуют ограничения для файловой системы ffs?</para>
  </question>

  <answer>

  <para>Для файловой системы ffs максимальный теоретический размер равен 
    8 терабайтам (2Г блоков) или 16ТБ при стандартном размере блока 8К.
    На практике есть программное ограничение в 1 терабайт, но с
    некоторыми модификациями достижимы 4 гигабайта (и такие системы
    существуют).</para>

  <para>Максимальный размер одного файла ffs равен примерно 1Г блоков
    (4ТБ) при размере блока 4К.</para>

  <table>
    <title>Maximum file sizes</title>

    <tgroup cols="5">
      <thead>
        <row>
          <entry>fs block size</entry>

          <entry>2.2.7-stable</entry>

          <entry>3.0-current</entry>

          <entry>works</entry>

          <entry>should work</entry>
        </row>
      </thead>

      <tbody>
        <row>
          <entry>4K</entry>

          <entry>4T-1</entry>

          <entry>4T-1</entry>

          <entry>4T-1</entry>

          <entry>4+t</entry>
        </row>

        <row>
          <entry>8K</entry>

          <entry>32+G</entry>

          <entry>8T-1</entry>

          <entry>32+G</entry>

          <entry>32T-1</entry>
        </row>

        <row>
          <entry>16K</entry>

          <entry>128+G</entry>

          <entry>16T-1</entry>

          <entry>128+G</entry>

          <entry>32T-1</entry>
        </row>

        <row>
          <entry>32K</entry>

          <entry>512+G</entry>

          <entry>32T-1</entry>

          <entry>512+G</entry>

          <entry>64T-1</entry>
        </row>

        <row>
          <entry>64K</entry>

          <entry>2048+G</entry>

          <entry>64T-1</entry>

          <entry>2048+G</entry>

          <entry>128T-1</entry>
        </row>
      </tbody>
    </tgroup>
  </table>

  <para>При размере блока файловой системы 4К, тройная адресация
    блоков работает и всё должно быть ограничено максимальным количеством 
    блоков, которое задаётся в виде тройной переадресации
    блока (примерно 1K^3 + 1K^2 + 1K), однако всё ограничивается 
    (ошибочным) лимитом 1Г-1 на количество блоков файловой системы.
    Это ограничение должно быть равным 2Г-1. При количестве блоков,
    приближающемся к 2Г-1, появляются некоторые ошибки, но этот предел 
    недостижим при размере блока 4К.</para>

  <para>При размере блока 8К и больше, всё должно быть ограничено
    лимитом 2Г-1 на количество блоков файловой системы, но реально
    ограничено пределом в 1Г-1 на число блоков файловой системы, кроме
    случая -STABLE, недостижимый при тройной переадресации, так что предел
    равен максимальному числу блоков файловой системы, который может
    быть представлен через двойную переадресацию (примерно
    (размер блока/4)^2 + (размер блока/4)), и под -CURRENT превышение
    этого ограничения может вызвать проблемы.  Использование верного
    ограничения в 2Г-1 блоков вызывает проблемы.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="tb-on-floppy">
    <para>Как можно поместить файлы размером 1ТБ на дискету?</para>
  </question>

  <answer>

  <para>Я храню парочку таких на дискете :-)  Максимальный размер 
    файла не связан непосредственно с максимальным размером диска.
    Максимальный размер диска равен 1ТБ.  Особенностью является
    то, что размер файла может превышать размер диска.</para>
  
  <para>В следующем примере создаётся файл размером 8Т-1 с помощью всего
    32К дискового пространства (3 блока адреса и 1 блок данных) на 
    маленьком корневом разделе.  Команда dd должна уметь работать с
    большими файлами.</para>
  
<screen>
&prompt.user; <userinput>cat foo</userinput>
df .
dd if=/dev/zero of=z bs=1 seek=`echo 2^43 - 2 | bc` count=1
ls -l z
du z
df .
&prompt.user; <userinput>sh foo</userinput>
Filesystem  1024-blocks     Used    Avail Capacity  Mounted on
/dev/da0a         64479    27702    31619    47%    /
1+0 records in
1+0 records out
1 bytes transferred in 0.000187 secs (5346 bytes/sec)
-rw-r--r--  1 bde  bin  8796093022207 Sep  7 16:04 z
32	z
Filesystem  1024-blocks     Used    Avail Capacity  Mounted on
/dev/da0a         64479    27734    31587    47%    /
  </screen>

  <para>Bruce Evans, September 1998</para>
  
  </answer>
</qandaentry>


<qandaentry>
  <question id="archsw-readin-failed-error">
    <para>Я скомпилировал новое ядро и при загрузке получил сообщение об ошибке
      <literal>archsw.readin.failed</literal>.</para>
  </question>

  <answer>

  <para>Вы можете осуществить загрузку системы, явно указав ядро во время
    второго этапа загрузочного процесса, нажав любую клавишу после
    появления символа | до запуска загрузчика.  Более точно, вы обновили
    исходные тексты ядра, откомпилировали и установили новое ядро <emphasis>без
    выполнения make world </emphasis>.  Такое не поддерживается.  Выполните
    make world.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="upgrade-3x-4x">
    <para>Как произвести обновление 3.X -&gt; 4.X?</para>
  </question>

  <answer>

  <para>Мы <emphasis>настоятельно</emphasis> рекомендуем воспользоваться
    для этой цели бинарными снэпшотами.  Снэпшоты ветки 4.STABLE находятся на
    сервере <ulink
    URL="ftp://releng4.FreeBSD.org/">releng4.FreeBSD.org</ulink>.</para>

  <para>Если вы хотите произвести обновление с помощью исходных текстов,
    то за дополнительной пожалуйста, обратитесь к <ulink
    URL="http://www.FreeBSD.org/handbook/cutting-edge.html">Руководству по
    FreeBSD</ulink>.</para>

  <para><emphasis>Обновление через исходные тексты, а тем более 3.X -> 4.X,
    никогда не рекомендуется делать начинающим пользователям; прочтите
    внимательно инструкции перед тем, как сделать это!</emphasis></para>

  </answer>
</qandaentry>
</qandaset>
</chapter>


<chapter id="hardware">
<title>Аппаратная совместимость</title>

<qandaset>
<qandaentry>
  <question id="supported-hard-drives">
    <para>Какие типы винчестеров поддерживает FreeBSD?</para>
  </question>

  <answer>

  <para>FreeBSD работает с дисками стандартов EIDE и SCSI (с
    соответствующими контроллерами; обратитесь к следующему разделу), и
    всеми дисками, использующими оригинальный интерфейс <quote>Western
    Digital</quote> (MFM, RLL, ESDI и, конечно же, IDE).  Некоторые
    контроллеры ESDI, использующие собственные интерфейсы, могут и не
    работать: к таким относятся WD1002/3/6/7 и их клоны.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="supported-scsi-controllers">
    <para>Какие поддерживаются контроллеры SCSI?</para>
  </question>

  <answer>

  <para>Полный список приведён в <ulink
    URL="../../handbook/install.html#INSTALL-HW">Руководстве</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="supported-cdrom-drives">
    <para>Какие приводы CD-ROM поддерживаются во FreeBSD?</para>
  </question>

  <answer>

  <para>Поддерживаются любые SCSI-устройства чтения компакт дисков,
    подключенные к поддерживаемому контроллеру.</para>

  <para>Кроме того, поддерживаются следующие оригинальные интерфейсы:</para>
  
  <para>     
    <itemizedlist>
      <listitem>
        <para>Mitsumi LU002 (8bit), LU005 (16bit) и FX001D (16bit 2x
          Speed).</para>
      </listitem>

      <listitem>
        <para>Sony CDU 31/33A<!-- <br> --></para>
      </listitem>

      <listitem>
        <para>Sound Blaster не-SCSI CD-ROM<!-- <br> --></para>
      </listitem>

      <listitem>
        <para>Matsushita/Panasonic CD-ROM<!-- <br> --></para>
      </listitem>

      <listitem>
        <para>ATAPI-совместимые IDE CD-ROM<!-- <br> --></para>
      </listitem>
    </itemizedlist>
  </para>

  <para>Все не-SCSI адаптеры ставятся своей медлительностью по сравнению
    со SCSI, а некоторые CDROM стандарта ATAPI могут и не работать.</para>

  <para>С версии 2.2 компакт-диск с FreeBSD от BSDi является загрузочным.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="zip-support">
    <para>Поддерживает ли FreeBSD устройства ZIP?</para>
  </question>

  <answer>

  <para>Несомненно, FreeBSD поддерживает ZIP-устройства SCSI.  Устройству
    ZIP могут быть назначены SCSI ID только 5 или 6, и если BIOS вашего
    SCSI-адаптера поддерживает такую возможность, вы можете с него даже 
    загрузиться.  Мне не известны адаптеры, позволяющие загрузиться с
    устройств, номера которых отличны от 0 или 1... посмотрите в
    вашей документации (и сообщите мне, если у вас это работает).</para>

  <para>Устройства ZIP стандарта ATAPI (IDE) поддерживаются FreeBSD начиная
    с версии 2.2.6.</para>

  <para>FreeBSD поддерживает устройства Zip, работающие через параллельный
    порт, начиная с версии 3.0.  Если вы используете более новую версию,
    проверьте, содержит ли ваше ядро драйверы для
    <devicename>scbus0</devicename>, <devicename>da0</devicename>,
    <devicename>ppbus0</devicename> и <devicename>vp0</devicename> (ядро
    GENERIC содержит всё это, кроме <devicename>vp0</devicename>).  Если эти
    драйверы имеются, то устройство должно быть доступно как
    <filename>/dev/da0s4</filename>.  Диски могут быть смонтированы
    командами <command>mount /dev/da0s4 /mnt</command> или (для дисков dos)
    <command>mount_msdos /dev/da0s4 /mnt</command> соответственно.</para>

  <para>Также посмотрите <link linkend="jaz">следующее замечание</link>
    о съёмных носителях, и <link linkend="disklabel">это замечание</link>
    о <quote>форматировании</quote>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="jaz-zip-removable-support">
    <para>Поддерживает ли FreeBSD съёмные диски типа JAZ или EZ?</para>
  </question>

  <answer>

  <para>Кроме IDE-варианта устройства EZ, это всё устройства SCSI, так что
    для FreeBSD все они должны выглядеть как диски SCSI, а IDE EZ должен
    выглядеть как диск IDE.</para>

  <para><anchor id="jaz">Я не знаю, насколько хорошо FreeBSD поддерживает
    смену носителя во время работы.  Конечно, чтобы сменить диск, вам 
    сначала нужно его размонтировать, и обратите внимание на то, что при
    загрузке все внешние устройства должны быть включены, чтобы FreeBSD
    могла их распознать.</para>

  <para>Посмотрите это <link linkend="disklabel">замечание</link> о 
    <quote>форматировании</quote>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="multiport-serial-support">
    <para>Какие многопортовые последовательные адаптеры поддерживаются во
      FreeBSD?</para>
  </question>

  <answer>

  <para>Список таких устройств находится в разделе о <ulink
    URL="../../handbook/install.html#INSTALL-MISC">различных
    устройствах</ulink> Руководства.</para>

  <para>Некоторые безымянные клоны таких адаптеров тоже работают нормально,
    особенно те, которые заявляют о своей совместимости с AST.</para>

  <para>Прочтите страницы Справочника о <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?sio(4)">sio</ulink>
    для получения подробной информации о конфигурировании таких
    адаптеров.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="usbkbd">
    <para>У меня клавиатура USB.  Поддерживает ли её FreeBSD?</para>
  </question>

  <answer>
    <para>Поддержка устройств USB была добавлена во FreeBSD 3.1.  Однако там
      она ещё находилась в стадии разработки и не всегда работает так же, как
      в версии 3.2.  Если вы хотите поэкспериментировать с поддержкой
      клавиатуры USB, следуйте нижеприводимым указаниям.</para>

    <orderedlist>
      <listitem>
        <para>Используйте FreeBSD 3.2 и выше.</para>
      </listitem>

      <listitem>
        <para>В конфигурационный файл ядра добавьте следующие строки и
          перестройте ядро.</para>

        <programlisting>
device  uhci
device  ohci
device  usb
device  ukbd
options KBD_INSTALL_CDEV
        </programlisting>

        <para>При использовании FreeBSD версий, предшествующих 4.0, добавьте
          вместо этого такие строки:</para>

        <programlisting>
          controller      uhci0
          controller      ohci0
          controller      usb0
          controller      ukbd0
          options         KBD_INSTALL_CDEV
        </programlisting>
      </listitem>

      <listitem>
        <para>Перейдите в каталог <filename>/dev</filename> и создайте
          специальные файлы устройств следующим образом:</para>

        <screen>
          &prompt.root; <userinput>cd /dev</userinput>
          &prompt.root; <userinput>./MAKEDEV kbd0 kbd1</userinput>
        </screen>
      </listitem>

      <listitem>
        <para>Отредактируйте файл <filename>/etc/rc.conf</filename>, добавив
          следующие строки:</para>

        <programlisting>
          usbd_enable="YES"
          usbd_flags=""
        </programlisting>
      </listitem>
    </orderedlist>

    <para>После перезагрузки системы AT-клавиатуре будет соответствовать
      <filename>/dev/kbd0</filename>, а клавиатуре USB -
      <filename>/dev/kbd1</filename>, если они обе подключены к системе.
      Если присутствует только клавиатура USB, ей будет соответствовать
      <filename>/dev/ukbd0</filename>.</para>

    <para>Если вы хотите использовать клавиатуру USB на консоли, вы должны
      явно указать драйверу консоли на использование имеющейся клавиатуры
      USB.  Это может быть сделано в процессе инициализации системы следующей
      командой.</para>

    <screen>
      &prompt.root; <userinput>kbdcontrol -k /dev/kbd1 &lt; /dev/ttyv0 &gt; /dev/null</userinput>
    </screen>

    <para>Заметьте, что, если клавиатура USB является единственной
      присутствующей, она доступна как <filename>/dev/kbd0</filename>,
      и поэтому команда должна выглядеть примерно так:</para>

    <screen>
&prompt.root; <userinput>kbdcontrol -k /dev/kbd0 &lt; /dev/ttyv0 &gt; /dev/null</userinput>
    </screen>

    <para>Вышеуказанную команду хорошо бы добавить в
      <filename>/etc/rc.i386</filename>.</para>

    <para>Как только вы всё это сделаете, клавиатура USB будет работать и в
      X-окружении без каких-либо особых настроек.</para>

    <para>Выключение и включение USB-клавиатуры на ходу может ещё не работать
      совершенно корректно.  Во избежание неприятностей было бы правильно
      подключить клавиатуру перед запуском системы и не отключать её до
      закрытия системы.</para>

    <para>За дополнительной информацией обратитесь к странице Справочника
      &man.ukbd.4;.</para>
  </answer>
</qandaentry>


<qandaentry>
  <question id="busmouse">
    <para>У меня необычная мышь типа bus mouse. Как её настроить?</para>
  </question>

  <answer>

  <para>FreeBSD поддерживает мыши типов bus mouse и InPort bus mouse от таких
    производителей, как Microsoft, Logitech и ATI.  Драйвер устройства bus mouse
    включен по умолчанию в ядро GENERIC во FreeBSD версий 2.X, но не включён в
    версию 3.0 и выше.  Если вы строите собственное ядро с этим драйвером,
    добавьте следующую строку в конфигурационный файл ядра</para>

  <para>Во FreeBSD 3.0 и ранее, добавьте:</para>

  <programlisting>
device mse0 at isa? port 0x23c tty irq5 vector mseintr
  </programlisting>

  <para>Во FreeBSD 3.X строчка должна иметь вид:</para>

  <programlisting>
device mse0 at isa? port 0x23c tty irq5
  </programlisting>

  <para>А во FreeBSD 4.X и выше строчка должна быть такой:</para>

  <programlisting>
device mse0 at isa? port 0x23c irq5
  </programlisting>

  <para>Мышь типа bus mouse обычно поставляется с отдельными интерфейсными
    адаптерами.  Они позволяют установить адрес порта ввода/вывода и номер IRQ,
    отличающиеся от приведённых выше.  Для получения дополнительной информации
    обратитесь к документации по вашей мыши и странице Справочника
    &man.mse.4;.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ps2mouse">
    <para>Как использовать мышь PS/2 (типа <quote>mouse port</quote> или
      <quote>keyboard</quote>)?</para>
  </question>

  <answer>

  <para>Если вы используете FreeBSD версии выше, чем 2.2.5, то необходимый
    драйвер, <devicename>psm</devicename>, включён в ядро и активизирован.
    Ядро должно обнаружить мышь PS/2 во время загрузки.</para>

  <para>Если вы работаете с предыдущей, но сравнительно свежей версией FreeBSD
    (2.1.x и выше), то вы можете просто включить её поддержку в меню
    конфигурации ядра во время инсталляции, либо позже, указав
    <option>-c</option> в приглашении <command>boot:</command>.  По умолчанию
    она отключена, так что вы должны включить её явно.</para>

  <para>Если вы используете более старую версию FreeBSD, то вам нужно добавить
    следующие строки в файл конфигурации ядра и построить новое ядро.</para>

  <para>Во FreeBSD 3.0 и ранее, строчка должна иметь вид:</para>
 
  <programlisting>
device psm0 at isa? port "IO_KBD" conflicts tty irq 12 vector psmintr
  </programlisting>

  <para>Во FreeBSD 3.1 и выше, строчка должна быть такой:</para>

  <programlisting>
device psm0 at isa? tty irq 12
  </programlisting>

  <para>Во FreeBSD 4.0 и выше строчка должна иметь вид:</para>

  <programlisting>
device psm0 at atkbdc? irq 12
  </programlisting>

  <para>Обратитесь к главе Руководства о <ulink
    URL="../../handbook/kernelconfig.html">конфигурировании ядра</ulink>, если
    вы не имели опыта такой работы.</para>

  <para>После того, как ядро правильно обнаружило <devicename>psm0</devicename>
    во время загрузки, проверьте существование файла устройства для
    <devicename>psm0</devicename> в каталоге <filename>/dev</filename>.  Это
    можно сделать, набрав:</para>

  <screen>
&prompt.root; <userinput>cd /dev; sh MAKEDEV psm0</userinput>
  </screen>

  <para>войдя в систему администратором.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="moused">
    <para>Можно ли каким-либо образом использовать мышь, кроме X Window?</para>
  </question>

  <answer>

  <para>Если вы используете стандартный драйвер консоли, syscons, то можете
    использовать указатель мыши в текстовых консолях для выделения и 
    переноса текста.  Запустите демон мыши, moused, и включите отображение
    указателя мыши на консоли:</para>
  
  <screen>
&prompt.root; <userinput>moused -p /dev/<replaceable>xxxx</replaceable> -t <replaceable>yyyy</replaceable></userinput>
&prompt.root; <userinput>vidcontrol -m on</userinput>
  </screen>

  <para>Здесь <replaceable>xxxx</replaceable> - это имя устройства мыши,
    а <replaceable>yyyy</replaceable> - тип протокола, используемого мышью.
    Страница Справочника по &man.moused.8; содержит информацию о поддерживаемых
    типах протоколов.</para>

  <para>Вы можете запускать демон мыши автоматически во время старта
    системы.  В версии 2.2.1, установите значение следующей переменной в
    <filename>/etc/sysconfig</filename>.</para>

  <programlisting>
mousedtype="yyyy"
mousedport="xxxx"
mousedflags=""
  </programlisting>

  <para>В версиях от 2.2.2 и до 3.0, установите значения следующих переменных
    в файле <filename>/etc/rc.conf</filename>.</para>

  <programlisting>
moused_type="yyyy"
moused_port="xxxx"
moused_flags=""
  </programlisting>

  <para>В версиях 3.1 и выше, если предположить, что у вас мышь типа PS/2, то
    достаточно добавить строчку <literal>moused_enable="YES"</literal> в файл
    <filename>/etc/rc.conf</filename>.</para>

  <para>Кроме того, если вы хотите использовать даемон мыши на всех виртуальных
    терминалах, а не только на консоли во время загрузки, добавьте следующую
    строку в файл <filename>/etc/rc.conf</filename>.</para>

  <programlisting>
allscreens_flags="-m on"
  </programlisting>

  <para>Начиная с FreeBSD 2.2.6, даемон мыши в состоянии определять тип
    протокола автоматически, если, конечно, мышь не достаточно древней
    модели.  Укажите <literal>auto</literal> для автоматического
    определения типа протокола.</para>

  <para>После запуска даемона мыши, доступ к мыши должен согласовываться
    между даемоном мыши и другими программами типа X Window.  Этот вопрос
    рассмотрен в <link linkend="x-and-moused">другом разделе</link>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="text-mode-cut-paste">
    <para>Как можно вырезать и копировать текст с помощью мыши в
      текстовой консоли?</para>
  </question>

  <answer>

  <para>После того, как вы запустили даемон мыши (посмотрите <link
    linkend="moused">предыдущий раздел</link>), нажмите кнопку 1 (левую) и
    двигайте мышь для выбора области выделения.  Затем нажмите кнопку 2
    (среднюю) или кнопку 3 (правую) для вставки текста из буфера, начиная
    с текущей позиции курсора.</para>
 
  <para>В версиях 2.2.6 и выше, нажатие на кнопку 2 вызовет вставку текста.
    Нажатие на кнопку 3 <quote>расширит</quote> выбранный область текста.  Если
    у вашей мыши отсутствует средняя кнопка, вы можете её сэмулировать или
    переназначить кнопки опциями программы moused. Обратитесь к странице
    Справочника по <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?moused(8)">
    moused(8)</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="usbmouse">
    <para>У меня мышь USB.  Поддерживает ли FreeBSD мышь USB?</para>
  </question>

  <answer>
    <para>Поддержка устройств USB была добавлена во FreeBSD 3.1.  Однако там
      она ещё находилась в стадии разработки и не всегда работает так, как
      в версии 3.2.  Если вы хотите поэкспериментировать с поддержкой мыши USB,
      следуйте нижеприводимым указаниям.</para>

    <orderedlist>
      <listitem>
        <para>Используйте FreeBSD 3.2 и выше.</para>
      </listitem>

      <listitem>
        <para>В конфигурационный файл ядра добавьте следующие строки и 
          перестройте ядро.</para>

        <programlisting>
device  uhci
device  ohci
device  usb
device  ums
        </programlisting>

        <para>Во FreeBSD версий, предшествующих 4.0, вместо этого добавьте
          такие строчки:</para>

        <programlisting>
          controller     uhci0
          controller     ohci0
          controller     usb0
          device         ums0
        </programlisting>
      </listitem>

      <listitem>
        <para>Перейдите в каталог <filename>/dev</filename> и создайте
          специальный файл устройства такой командой:</para>

        <screen>
          &prompt.root; <userinput>cd /dev</userinput>
          &prompt.root; <userinput>./MAKEDEV ums0</userinput>
        </screen>
      </listitem>

      <listitem>
        <para>Отредактируйте файл <filename>/etc/rc.conf</filename>, добавив
          такие строчки:</para>

        <programlisting>
          moused_enable="YES"
          moused_type="auto"
          moused_port="/dev/ums0"
          moused_flags=""
          usbd_enable="YES"
          usbd_flags=""
        </programlisting>

        <para>Подробное обсуждение moused может быть найдено в <link
          linkend="moused">предыдущем разделе</link>.</para>
      </listitem>

      <listitem>
        <para>Чтобы использовать мышь USB при работе в X, отредактируйте
          файл <filename>XF86Config</filename>.  Если вы используете
          XFree86 3.3.2 и выше, то в разделе <emphasis>Pointer</emphasis>
          должны присутствовать такие строки:</para>

        <programlisting>
          Device         "/dev/sysmouse"
          Protocol       "Auto"
        </programlisting>

        <para>Если у вас более старая версия XFree86, то в разделе
          <emphasis>Pointer</emphasis> должны присутствовать строки:</para>

        <programlisting>
          Device         "/dev/sysmouse"
          Protocol       "SysMouse"
        </programlisting>
      </listitem>
    </orderedlist>

    <para>Поддержке мыши при работе в X посвящен <link
      linkend="x-and-moused">другой раздел</link>.</para>

    <para>Выключение и включение мыши USB на ходу может ещё не работать
      совершенно корректно.  Во избежание неприятностей было бы правильно
      подключить мышь перед запуском системы и не отключать её до закрытия
      системы.</para>
  </answer>
</qandaentry>


<qandaentry>
  <question id="mouse-wheel-buttons">
    <para>У моей мыши есть дополнительные колёсико и кнопочки.  Можно ли их
      использовать во FreeBSD?</para>
  </question>

  <answer>

  <para>Ответ, к сожалению, <quote>в зависимости от обстоятельств</quote>.
    Эти мышки с дополнительными возможностями, как правило, требуют наличия
    специальных драйверов.  До тех пор, пока драйвер мыши или прикладная
    программа не будут иметь отдельную поддержку такой мыши, она будет
    работать как стандартная двух- или трёхкнопочная мышь.</para>

  <para>Возможные способы использования колёсиков мыши при работе в X Window
    описаны в <link linkend="x-and-wheel">другом разделе</link>.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="psmerr">
    <para>Похоже, что моя мышь не работает.  Её курсор прыгает по экрану.  Мышь
      имеет колёсико и подключено к порту мыши PS/2.</para>
  </question>

  <answer>

  <para>В драйвере psm для мыши PS/2 во FreeBSD версий 3.2 и ранее имеются
    проблемы при работе с некоторыми мышками, у которых есть колёсико, в том
    числе с мышками Logitech модель M-S48 и их OEM-разновидностями.
    Исправьте файл <filename>/sys/i386/isa/psm.c</filename> с помощью
    следующего патча и перестройте ядро.</para>

  <programlisting>
Index: psm.c
===================================================================
RCS file: /src/CVS/src/sys/i386/isa/Attic/psm.c,v
retrieving revision 1.60.2.1
retrieving revision 1.60.2.2
diff -u -r1.60.2.1 -r1.60.2.2
--- psm.c      1999/06/03 12:41:13     1.60.2.1
+++ psm.c      1999/07/12 13:40:52     1.60.2.2
@@ -959,14 +959,28 @@
     sc->mode.packetsize = vendortype[i].packetsize;

     /* set mouse parameters */
+#if 0
+    /*
+     * A version of Logitech FirstMouse+ won't report wheel movement,
+     * if SET_DEFAULTS is sent...  Don't use this command.
+     * This fix was found by Takashi Nishida.
+     */
     i = send_aux_command(sc->kbdc, PSMC_SET_DEFAULTS);
     if (verbose >= 2)
       printf("psm%d: SET_DEFAULTS return code:%04x\n", unit, i);
+#endif
     if (sc->config & PSM_CONFIG_RESOLUTION) {
         sc->mode.resolution
           = set_mouse_resolution(sc->kbdc,
-              (sc->config & PSM_CONFIG_RESOLUTION) - 1);
+                                 (sc->config & PSM_CONFIG_RESOLUTION) - 1);
+    } else if (sc->mode.resolution >= 0) {
+      sc->mode.resolution
+          = set_mouse_resolution(sc->kbdc, sc->dflt_mode.resolution);
+    }
+    if (sc->mode.rate > 0) {
+      sc->mode.rate = set_mouse_sampling_rate(sc->kbdc, sc->dflt_mode.rate);
     }
+    set_mouse_scaling(sc->kbdc, 1);

     /* request a data packet and extract sync. bits */
     if (get_mouse_status(sc->kbdc, stat, 1, 3) < 3) {</programlisting>

    <para>Версии FreeBSD выше чем 3.2 должны работать нормально.</para>
  </answer>
</qandaentry>


<qandaentry>
  <question id="laptop-mouse-trackball">
    <para>Как использовать мышь/трэкболл/сенсорную панель на лэптопе?</para>
  </question>

  <answer>

  <para>Посмотрите <link linkend="ps2mouse">один из предыдущих разделов</link>.
    И посмотрите <link linkend="pao">это замечание</link> на странице о
    мобильных вычислениях.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="tape-support">
    <para>Какие типы стримеров поддерживаются?</para>
  </question>

  <answer>

  <para>FreeBSD поддерживает устройства SCSI и QIC-36 (с интерфейсом QIC-02),
    включая 8-мм (Exabyte) и DAT.</para>

  <para>Некоторые ранние модели 8-мм стримеров не совсем соответствуют
    стандарту SCSI-2 и могут работать не совсем хорошо.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="tape-changer-support">
    <para>Поддерживает ли FreeBSD роботов для смены лент?</para>
  </question>

  <answer>

  <para>FreeBSD 2.2 поддерживает SCSI-чейнджеры через устройство <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ch(4)">ch(4)</ulink>
    и команду <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?chio(1)">
    chio(1)</ulink>.  Подробная информация об управлении чейнджерами может
    быть найдена на странице Справочника по команде <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?chio(4)">chio(1)</ulink>.</para>

  <para>Если вы не используете систему
    <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?amanda">AMANDA</ulink>
    или другое программное обеспечение, умеющее работать с роботами, имейте в
    виду, что они могут только переносить ленты с одного места на другое,
    так что вам нужно самим отслеживать, в каком слоте находится нужная
    лента, и в какой слот нужно вернуть ленту, находящуюся в стримере.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="sound-card-support">
    <para>Какие звуковые адаптеры поддерживаются во FreeBSD?</para>
  </question>

  <answer>

  <para>FreeBSD поддерживает звуковые адаптеры SoundBlaster, SoundBlaster Pro,
    SoundBlaster 16, Pro Audio Spectrum 16, AdLib и Gravis UltraSound.
    Имеется ограниченная поддержка MPU-401 и совместимых с ним адаптеров.
    Адаптеры, удовлетворяющие спецификации Microsoft Sound System, также
    поддерживаются драйвером pcm.</para>

  <para>
    <note>
      <para>Это касается только звука!  Этот драйвер не поддерживает CDROM,
        SCSI или джойстики ни на каких подобных адаптерах, кроме SoundBlaster.
        Поддерживаются устройства на SCSI-интерфейсе SoundBlaster и не-SCSI
        CDROM, но загрузиться с них невозможно.</para>
    </note>
  </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="es1370-silent-pcm">
    <para>Есть ли решение проблемы отсутствия звука при использовании
      драйвера pcm с адаптером es1370?</para>
  </question>

  <answer>

  <para>При каждой перезагрузке вам нужно запускать следующую команду:</para>

  <screen>
&prompt.root; <userinput>mixer pcm 100 vol 100 cd 100</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="network-cards">
    <para>Какие сетевые адаптеры поддерживает FreeBSD?</para>
  </question>

  <answer>

  <para>Более полный список содержится в разделе Руководства об
    <ulink URL="../../handbook/install-hw.html#INSTALL-NICS">адаптерах
    Ethernet</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="no-math-coprocessor">
    <para>На моей машине отсутствует математический сопроцессор - это
      плохо?</para>
  </question>

  <answer>

  <para>
    <note>
      <para>Это касается только владельцев компьютеров 386/486SX/486SLC - во
        всех остальных машинах модуль вычислений с плавающей точкой объединён
        с центральным процессором.</para>
    </note>
  </para>

  <para>В общем случае это не проблема, но в отсутствии сопроцессора вы
    можете столкнуться со снижением производительность и точности при
    использовании программной эмуляции сопроцессора (обратитесь к разделу
    об <link linkend="emul">эмуляции вычислений с плавающей точкой</link>).  
    В частности, прорисовка дуг в X будет ОЧЕНЬ медленной.  Приобретение
    математического сопроцессора настоятельно рекомендуется, он того
    стоит.</para>

  <para>
    <note>
      <para>Некоторые математические сопроцессоры работают лучше, чем другие.
        Нам неприятно это признавать, но Intel пока никого не подводил.  Если
        вы не уверены, что сопроцессор будет работать с FreeBSD, избегайте
        клонов.</para>
    </note>
  </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="other-device-support">
    <para>Какие ещё устройства поддерживаются во FreeBSD?</para>
  </question>

  <answer>

  <para>В <ulink
    URL="../../handbook/install-hw.html#INSTALL-MISC">Руководстве</ulink>
    приведён список остальных устройств, которые поддерживаются во
    FreeBSD.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="power-management-support">
    <para>Поддерживает ли FreeBSD управление энергосбережением на
      лаптопах?</para>
  </question>

  <answer>

  <para>FreeBSD поддерживает APM на некоторых машинах.  Поищите в файле
    конфигурации ядра <filename>LINT</filename> слово <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?apm(4)">APM</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>

  <question>
    <para>Решение специфичных проблем с аппаратным обеспечением</para>
  </question>

  <answer>

  <para>Этот раздел содержит решения специфичных проблем с аппаратным
    обеспечением, с которыми сталкиваются наши пользователи.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="micron-hang-boot">
    <para>Компьютеры Micron зависают при загрузке</para>
  </question>

  <answer>

  <para>Некоторые материнские платы Micron имеют BIOS, не удовлетворяющую
    стандарту PCI BIOS, что приводит к печальным последствиям при
    загрузке FreeBSD, потому что имеет место несоответствие устройств
    PCI занимаемым ими адресам.</para>

  <para>Для решения этой проблемы отключите в BIOS опцию <quote>Plug and Play
    Operating System</quote>.</para>

  <para>Более подробная информация об этой проблеме находится по следующему
    адресу: <ulink
    URL="http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron">
    http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</ulink></para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="newer-adaptec-support">
    <para>FreeBSD не распознаёт мой новейший контроллер от Adaptec.</para>
  </question>

  <answer>

  <para>Новый набор микросхем AIC789x от Adaptec поддерживается подсистемой CAM
    SCSI, впервые появившейся в 3.0.  Патчи для 2.2-STABLE находятся по адресу
    <ulink URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/">
    ftp://ftp.FreeBSD.org/pub/FreeBSD/development/cam/</ulink>.
    Загрузочный диск с поддержкой CAM доступен по адресу <ulink
    URL="http://people.FreeBSD.org/~abial/cam-boot/">
    http://people.FreeBSD.org/~abial/cam-boot/</ulink>.
    В обоих случаях прежде чем начать, прочтите файл README. </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="internal-plugnplay-modem">
    <para>FreeBSD не находит внутренний модем Plug &amp; Play.</para>
  </question>

  <answer>

  <para>Вам нужно добавить PnP ID вашего модема в список PnP ID драйвера 
    последовательного порта.  Для включения поддержки Plug &amp; Play, 
    откомпилируйте новое ядро с опцией <literal>controller pnp0</literal>
    в конфигурационном файле, и перезагрузите машину.  Ядро
    выведет список ID всех найденных PnP-устройств.  Добавьте PnP ID модема в
    таблицу в файле <filename>/sys/i386/isa/sio.c</filename>, где-то в районе
    2777 строки.  Чтобы найти таблицу, поищите слово <literal>SUP1310</literal>
    в структуре <literal>siopnp_ids[]</literal>.  Снова постройте ядро,
    проинсталлируйте его и перезагрузитесь.  Теперь ваш модем должен быть
    опознан.</para>

  <para>Вам может понадобиться отконфигурировать PnP-устройства командой
    <literal>pnp</literal> в конфигураторе во время загрузки следующим
    образом:</para>

  <para>  
    <programlisting>
pnp 1 0 enable os irq0 3 drq0 0 port0 0x2f8
    </programlisting>

    чтобы модем был распознан.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="serial-console-prompt">
    <para>Как сделать, чтобы приглашение boot: выводилось на консоль на
      последовательном порту?</para>
  </question>

  <answer>

  <para>
    <orderedlist>
      <listitem>
        <para>Постройте ядро с параметром
          <literal>options COMCONSOLE</literal>.</para>
      </listitem>

      <listitem>
        <para>Создайте файл /boot.config, поместив туда только текст
          <option>-P</option>.</para>
      </listitem>

      <listitem>
        <para>Отключите клавиатуру.</para>
      </listitem>
    </orderedlist>
  </para>

  <para>Подробная информация находится в файле
    <filename>/usr/src/sys/i386/boot/biosboot/README.serial</filename>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="micron-3comnic-failure">
    <para>Почему сетевой адаптер 3Com PCI не работает с компьютерами
      Micron?</para>
  </question>

  <answer>

  <para>Некоторые материнские платы Micron имеют BIOS, не удовлетворяющую
    стандарту PCI BIOS, что приводит к несоответствию устройств PCI
    занимаемым ими адресам.  Это приводит к печальным последствиям при
    загрузке FreeBSD.</para>

  <para>Для решения этой проблемы отключите в BIOS опцию <quote>Plug and Play
    Operating System</quote>.</para>

  <para>Более подробная информация об этой проблеме находится по следующему
    адресу: <ulink
    URL="http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron">
    http://cesdis.gsfc.nasa.gov/linux/drivers/vortex.html#micron</ulink></para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="smp-support">
    <para>Поддерживает ли FreeBSD многопроцессорные системы (SMP)?</para>
  </question>

  <answer>

  <para>Поддержка SMP (Symmetric Multiprocessing) имеется только в 3.0-STABLE и
    последующих релизах.  По умолчанию поддержка SMP в ядре
    <emphasis>GENERIC</emphasis> не включена, так что для её включения вам
    нужно будет перекомпилировать ядро.  Посмотрите в файл
    <filename>/sys/i386/conf/LINT</filename>, чтобы определить, какие параметры
    нужно поместить в конфигурационный файл вашего ядра.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="asusk7v-boot-failure">
    <para>При загрузке с установочной дискеты машины с материнской платой
      ASUS K7V зависают.  Как это исправить?</para>
  </question>

  <answer>
    <para>Войдите в настройку BIOS и выключите защиту от загрузочных
      вирусов.</para>
  </answer>
</qandaentry>
</qandaset>
</chapter>


<chapter
id="troubleshoot">
<title>Устранение некоторых проблем</title>


<qandaset>
<qandaentry>
  <question id="awre">
    <para>На моём винчестеры есть запорченные блоки!</para>
  </question>

  <answer>

  <para>Если это SCSI-устройство, то винчестер должен иметь возможность
    автоматической переадресации таких блоков.  Однако по непонятным
    причинам во многих поставляемых дисках эта возможность отключена...</para>

  <para>Чтобы её включить, вам нужно изменить режим работы устройства, что
    во FreeBSD может быть выполнено администратором посредством команды</para>

  <screen>
&prompt.root; <userinput>scsi -f /dev/rsd0c -m 1 -e -P 3</userinput>
  </screen>

  <para>и изменить значения параметров AWRE и ARRE с 0 на 1:-</para>

  <programlisting>
AWRE (Auto Write Reallocation Enbld):  1
ARRE (Auto Read Reallocation Enbld):  1
  </programlisting>

  <para>Последующие параграфы были предоставлены <ulink
    URL="mailto:tedm@toybox.placo.com">Тэдом Миттельштадтом</ulink>
    (Ted Mittelstaedt):</para>

  <para>Для дисков IDE появление запорченных блоков является признаком
    возможных неприятностей.  Все современные IDE-диски поставляются с
    включенной возможностью переадресации испорченных блоков.  Все 
    производители винчестеров в настоящее время предоставляют расширенные
    гарантии и заменяют диски с запорченными блоками.</para>

  <para>Если вы всё же хотите спасти ваш диск IDE с запорченными блоками,
    вы можете попытаться найти программу диагностики винчестеров от
    производителя и протестировать ею диск.  Иногда эти программы могут
    заставить электронику винчестера пересканировать диск в поисках
    испорченных блоков и заблокировать их.</para>

  <para>В случае дисков стандартов ESDI, RLL и MFM, наличие испорченных блоков
    является обычным явлением и не является большой проблемой. В ПК
    контроллер винчестера и BIOS берут на себя работу по блокировке
    испорченных блоков.  Это прекрасно работает в случае операционных систем
    типа DOS, которые используют вызовы BIOS для доступа к диску.  Однако
    драйвер диска во FreeBSD не обращается к BIOS, поэтому для обеспечения
    подобной функциональности существует bad144.  bad144 работает только с
    драйвером wd (что означает, что эта утилита не поддерживается во FreeBSD
    4.0), её НЕВОЗМОЖНО использовать со SCSI.  bad144 помещает все
    найденные испорченные сектора в специальный файл.</para>

  <para>У bad144 имеется особенность - специальный файл с испорченными
    блоками помещается на последнюю дорожку диска.  Так как этот файл
    может содержать список испорченных секторов, находящихся в начале
    диска, где может располагаться файл ядра /kernel, он должен быть
    доступен загрузчику, использующему вызовы BIOS для чтения файла ядра.
    Это значит, что диск, который использует bad144, не должен иметь
    размеры, превышающие 1024 дорожки, 16 головок и 63 сектора.  Это
    ограничивает размер диска, обрабатываемого bad144, 500 мегабайтами.</para>

  <para>Для использования bad144, просто установите <quote>Bad Block</quote>
    в положение ON на экране программы fdisk во время начальной установки.
    Это работает начиная с FreeBSD 2.2.7.  Диск должен иметь размер,
    не превышающий 1024 дорожки.  Рекомендуется, чтобы до этого диск
    проработал не менее 4 часов для перехода в рабочий тепловой режим и
    стабильный режим работы головок.</para>

  <para>Если диск имеет размер, превышающий 1024 головки (как, например,
    большой диск ESDI), контроллер ESDI использует особый режим 
    трансляции, чтобы это работало в DOS.  Драйвер wd будет знать об этих
    режимах трансляции, ЕСЛИ вы укажете на использование
    <quote>преобразованных</quote> параметров в команде <quote>set
    geometry</quote> программы fdisk.  Вы также НЕ должны использовать режим
    <quote>dangerously dedicated</quote> при выделении раздела для
    FreeBSD, так как при этом параметры диска не принимаются во внимание.
    Также, хотя fdisk будет использовать изменённые параметры, он всё же
    помнит настоящий размер диска, и попытается создать слишком большой
    раздел FreeBSD.  Если параметры диска изменились на транслированные,
    раздел ДОЛЖЕН быть создан вручную с указанием количества блоков.</para>

  <para>Самым быстрым способом является установка большого диска ESDI с
    контроллером ESDI, загрузка DOS и выделение на нём раздела DOS.  Затем
    запустите инсталляционную программу FreeBSD и в экране программы
    fdisk найдите и запишите размер блока и их количество раздела DOS.
    Затем установите параметры в те же значения, которые использует DOS,
    удалите раздел DOS и создайте <quote>совмещённый</quote> раздел FreeBSD с
    ранее записанным размером блока.  Затем установите загрузку с этого раздела
    и включите сканирование испорченных блоков.  Во время установки сначала,
    ещё до создания файловых систем, запустится bad144 (вы можете это
    увидеть по Alt-F2).  Если возникнут проблемы при создании файла с
    запорченными секторами, вы установили слишком большие параметры диска
    - перезагрузитесь и начните всё сначала (включая повторные разбиение
    на разделы и форматирование винчестера в DOS).</para>

  <para>Если переадресация включена и всё равно на диске присутствуют
    запорченные блоки, то, по-видимому, остаётся только заменить винчестер.
    Количество испорченных блоков с течением времени имеет тенденцию только
    увеличиваться.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="bustek742a-eisa-scsi">
    <para>FreeBSD не распознаёт мой EISA SCSI контроллер Bustek 742a!</para>
  </question><answer>

  <para>Нижеследующая информация специфична для 742a, но может касаться и
    других адаптеров от Buslogic (Bustek = Buslogic).</para>

  <para>Существуют две основных <quote>версии</quote> адаптеров 742a.  Это
    аппаратные модификации A-G и модификации H и выше.  Буква, обозначающая
    модификацию, расположена после номера сборки на кромке адаптера.  На
    адаптере 742a установлены две микросхемы ПЗУ, одна содержит BIOS, а
    другая - микрокод (так называемое firmware).  Для FreeBSD не имеет
    значения используемая версия BIOS, но имеет значение версия микрокода.
    Buslogic высылает обновления для ПЗУ, если вы позвоните в их отдел
    технической поддержки.  Микросхемы с BIOS и микрокодом поставляются
    соответствующими парами.  В ПЗУ адаптера вы должны иметь самую
    последнюю версии микрокода для вашей аппаратной модификации.</para>

  <para>Адаптерам модификаций A-G может только подойти BIOS/Firmware версий
    вплоть до 2.41/2.21.  Адаптерам модификаций H и старше подходят самые
    последние версии BIOS/Firmware 4.70/3.37.  Отличие между версиями
    микрокода заключается в том, что версия микрокода 3.37 поддерживает
    механизм <quote>round robin</quote>.</para>

  <para>На адаптерах Buslogic проставлен серийный номер.  Если у вас
    адаптер старой модификации, вы можете позвонить в подразделение RMA
    фирмы Buslogic, сказать им серийный номер адаптера и попытаться
    обменять его на более новую модификацию.  Если адаптер достаточно нов,
    то они его поменяют.</para>

  <para>FreeBSD 2.1 поддерживает микрокод модификаций только 2.21 и выше.
    Если у вас версия микрокода старее, чем эта, то адаптер не будет
    распознаваться как адаптер Buslogic.  Однако он может быть опознан
    как Adaptec 1540.  Ранние версии микрокода от Buslogic содержат режим
    <quote>эмуляции</quote> AHA1540.  Однако для EISA-адаптера всё это выглядит
    как-то неприлично.</para>

  <para>Если у вас адаптер старой модификации и вы получили микрокод 2.21
    для него, установите перемычку W1 в положение B-C, по умолчанию она
    находится в положении A-B.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="hpnetserver-scsi-failure">
    <para>Не распознаётся SCSI-контроллер на HP Netserver!</para>
  </question>

  <answer>

  <para>В общем-то это известная проблема.  EISA-контроллеры SCSI, 
    расположенные на материнской плате машин HP Netserver, занимают
    EISA-слот номер 11, так что все <quote>настоящие</quote> слоты EISA будут
    ему предшествовать.  Так как адресное пространство для слотов EISA выше 10
    пересекается с адресным пространством, предназначенным для PCI, то
    автоконфигуратор FreeBSD в настоящее время не может эту проблему
    нормально обойти.</para>

  <para>Так что пока лучшее, что вы можете предпринять, это попытаться
    указать, что пересечения диапазонов адресов нет :), установив опцию
    ядра <literal>EISA_SLOTS</literal> в значение 12.  Отконфигурируйте и
    откомпилируйте ядро так, как это описано в <ulink
    URL="../../handbook/kernelconfig.html">разделе Руководства</ulink> о
    конфигурировании ядра.</para>

  <para>Конечно, это даст вам типичную ситуации "курица или яйцо"
    при установке системы на такой машине.  Для обхода этой проблемы
    внутри <emphasis>UserConfig</emphasis> есть специальный хак.  Не используя
    <quote>визуального</quote> интерфейса, а только интерфейс командной строки,
    просто наберите</para>

  <programlisting>
eisa 12
quit
  </programlisting>

  <para>в приглашении, и проинсталлируйте систему как обычно.  В любом случае
    рекомендуется, что вы отконфигурируете и проинсталлируете собственное
    ядро.</para>

  <para>Надеемся, что будущие версии будут содержать полное решение этой
    проблемы.</para>
  
  <para>
    <note>
      <para>Вы не сможете использовать режим <emphasis remap=bf>dangerously
        dedicated</emphasis> на машинах HP Netserver.  Полное описание причин
        содержится в <link linkend="dedicate">этом замечании</link>.</para>
    </note>
  </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="cmd640-ide">
    <para>Что не так с IDE-контроллером CMD640?</para>
  </question>

  <answer>

  <para>Этот контроллер не рабочий.  Он не может отрабатывать команды на
    обоих каналах одновременно.</para>

  <para>Решение этой проблемы существует и включается автоматически, если
    в вашей системе используется этот контроллер.  Подробная информация
    находится на страницах Справочника по дисковому драйверу (man 4 wd).</para>

  <para>Если вы уже работаете с FreeBSD 2.2.1 или 2.2.2 с IDE-контроллером
    CMD640 и хотите использовать второй канал, постройте новое ядро с
    включенной опцией <literal>options "CMD640"</literal>.  В версии 2.2.6 и
    выше это включено по умолчанию.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ed1-timeout">
    <para>Выдаются сообщения типа <literal>ed1: timeout</literal>.</para>
  </question>

  <answer>

  <para>Обычно это вызвано конфликтом прерываний (например, двух адаптеров,
    использующих один и тот же IRQ).  FreeBSD до версии 2.0.5R была
    нечувствительна к таким конфликтам, и драйвер сетевого адаптера
    оставался работоспособен даже при конфликтах IRQ.  Однако с версии
    2.0.5R и выше, конфликты IRQ больше не считаются безобидными.  
    Загрузитесь с опцией -c и смените строку, описывающую ed0/de0/...
    на соответствующую вашей системе..</para>

  <para>Если вы используете разъём BNC сетевого адаптера, таймауты
    устройства могут быть вызваны плохим терминированием.  Чтобы это
    проверить, подключите терминатор к адаптеру (без кабеля) и
    посмотрите, не исчезли ли сообщения об ошибках.</para>

  <para>Некоторые NE2000-совместимые адаптеры выдают такую ошибку, если нет
    связи по UTP-порту или отключен кабель.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="mount-cd-superblock">
    <para>При монтировании компакт-диска, выдаётся сообщение <literal>Incorrect
      super block</literal>.</para>
  </question>

  <answer>

  <para>В параметрах команды <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?mount(8)">mount</ulink> вам нужно
    указать тип устройства, который вы собираетесь смонтировать.  По
    умолчанию <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?mount(8)">
    mount(8)</ulink> полагает, что монтируемая файловая система имеет тип 
    <literal>ufs</literal>.  При монтировании файловой системы
    CDROM нужно указать опцию <option>-t cd9660</option> в команде <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?mount(8)">mount(8)</ulink>.  При
    этом, конечно же, предполагается, что CDROM содержит файловую систему
    стандарта ISO 9660, как на большинстве CDROM.  С версии 1.1R FreeBSD
    автоматически распознаёт также расширение Rock Ridge (для длинных имён
    файлов).</para>

  <para>Например, если вы хотите смонтировать устройство CDROM
    <filename>/dev/cd0c</filename> в каталог <filename>/mnt</filename>, вы
    должны выполнить следующую команду:</para>

  <screen>
&prompt.root; <userinput>mount -t cd9660 /dev/cd0c /mnt</userinput>
  </screen>

  <para>Заметьте, что имя устройства (<filename>/dev/cd0c</filename> в этом
    примере) может быть другим, в зависимости от интерфейса вашего CDROM.
    Отметьте, что опция <option>-t cd9660</option> всего лишь приводит к вызову
    команды <command>mount_cd9660</command>, так что пример выше может быть
    укорочен до такой команды:</para>

  <screen>
&prompt.root; <userinput>mount_cd9660 /dev/cd0c /mnt</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="cdrom-not-configured">
    <para>При монтировании компакт-диска выдаётся сообщение <literal>Device not
      configured</literal>.</para>
  </question>

  <answer>

  <para>Обычно это означает, что в приводе CDROM нет компакт-диска либо
    устройство не было обнаружено на этапе загрузки.  Вставьте в
    привод какой-нибудь диск, и/или проверьте его настройку как
    ведущего/ведомого устройства, если оно типа IDE (ATAPI).  Для привода
    CDROM может потребоваться несколько секунд для обнаружения, что был
    вставлен диск, так что будьте терпеливыми.</para>

  <para>Иногда SCSI CDROM может отсутствовать в системе из-за недостатка
    времени на ответ при сбросе шины.  Если ваш привод CD-ROM является
    SCSI-устройством, пожалуйста, попробуйте добавить такой символ в ваш
    файл конфигурации ядра и перекомпилируйте его.</para>

  <programlisting>
options "SCSI_DELAY=15"
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="printer-slow">
    <para>Мой принтер печатает невероятно медленно.  Что тут можно
      сделать?</para>
  </question>

  <answer>

  <para>Если принтер подключен к параллельному порту, и единственной
    проблемой является его медлительность, попробуйте установить порт в
    режим <quote>polled</quote>:</para>

  <screen>
&prompt.root; <userinput>lptcontrol -p</userinput>
  </screen>

  <para>Утверждается, что некоторые новейшие принтеры от HP не работают
    корректно в режиме прерываний, скорее всего из-за (это ещё не совсем
    точно выяснено) проблем с временными задержками.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="signal11">
    <para>Программы аварийно завершают работу с ошибкой <literal>Signal
      11</literal>.</para>
  </question>

  <answer>

  <para>Ошибки выполнения, связанные с 11 сигналом, происходят, когда ваш
    процесс пытается обратиться к области памяти, доступ к которой ему не был
    дан операционной системой.	Если что-то подобное происходит в случайные
    на первый взгляд промежутки времени, то вам нужно попытаться выяснить
    подробности происходящих событий более детально.</para>

  <para>Эти проблемы могут быть классифицированы следующим образом:</para>

  <orderedlist>
    <listitem>
      <para>Если проблема возникает только в определенном приложении, которое
	было самостоятельно вами разработано, то, скорее всего, это ошибка в
	вашем коде.</para>
    </listitem>

    <listitem>
      <para>Если это проблема в части базового комплекта системы FreeBSD, то
	это тоже может быть ошибка в программном коде, хотя в большинстве
	случаев такие проблемы обнаруживаются и ошибки исправляются задолго
	до того, как обычным читателям FAQ доводится использовать этот код
	(именно для этого предназначена версия -current).</para>
    </listitem>
  </orderedlist>

  <para>В частности, достоверно *не* ошибка FreeBSD, если вы сталкиваетесь
    с проблемой при компиляции программы, но при работе компилятора место
    сбоя каждый раз изменяется.</para>

  <para>Например, положим, что вы запускаете команду "make buildworld" и
    компиляция завершилась аварийно при попытке компиляции ls.c в to ls.o.
    Если при следующей попытке повторно выполнить "make buildworld"
    компиляция прервется на том же самом месте, то это ошибки процесса
    построения -- попробуйте обновить исходные тексты и попробуйте снова.
    Если компиляция прерывается в каком-то другом месте, то в этом
    практически достоверно виновато обрудование.</para>

  <para>Что вы должны сделать:</para>

  <para>В первом случае вы должны воспользоваться отладчиком, к примеру, gdb,
    для нахождения точки программы, в которой делается попытка доступа к
    неверному адресу и затем исправить эту ошибку.</para>

  <para>Во втором случае вам нужно проверить, что ваше оборудование
    исправно.</para>

  <para>Среди часто приводящих к этому причин:</para>

  <orderedlist>
    <listitem>
      <para>Ваши винчестеры могут перегреваться: Проверьте работу
	вентиляторов в вашем системном блоке, так как ваш диск (и может,
	также другие компоненты, могут перегреваться).</para>
    </listitem>

    <listitem>
      <para>Работающий процессор перегревается: Это может произойти из-за
	увеличения частоты процессора за рабочие границы или поломки
	вентилятора на процессоре.  В любом случае вам нужно убедиться, что
	ваше оборудование работает так, как ему положено, по крайней мере,
	на момент поиска причин неисправности, другими словами, Установите
	частоту работы на настройки по умолчанию.</para>

      <para>Если вы превысили рабочие частоты работы процессора, заметьте,
	что дешевле обходится медленная система, чем сгоревшая система,
	требующая замены!  Также общество нечасто симпатизирует
	проблемам на таких системах, вне зависимости от того, считаете ли
	вы увеличение рабочей частоты не влияющим на работу или нет.</para>
    </listitem>

    <listitem>
      <para>Хитрая память: Если у вас установлено множество микросхем
	SIMM/DIMM, то вытащите их все и попытайтесь поработать индивидуально
	с каждой микросхемой SIMM или DIMM и локализовать проблему либо до
	проблематичной микросхемы DIMM/SIMM, либо даже их комбинации.</para>
    </listitem>

    <listitem>
      <para>Чересчур оптимистические настройки материнской платы: При
	настройке вашей BIOS и выборе положения перемычек на материнской
	плате вы имеете возможность задать различные частоты и задержки,
	в большинстве случаев настройки по умолчанию достаточны, но иногда
	установка слишком малых периодов ожидания для ОЗУ, установка
	параметра "RAM Speed: Turbo" или подобных параметров в BIOS вызовет
	странное поведение.  Возможным решением может стать установка
	параметров BIOS по умолчанию, но сначала стоит записать ваши
	настройки!</para>
    </listitem>

    <listitem>
      <para>Неустойчивое или недостаточное электропитание материнской платы.
	Если в вашей системе есть неиспользуемые адаптеры ввода/вывода,
	винчестеры или приводы компакт-дисков, попробуйте временно их убрать
	или отключить от кабеля электропитания, чтобы посмотреть, сможет ли
	ваш блок питания работать с меньшей нагрузкой.	Или попробуйте
	воспользоваться другим блоком питания, желательно большей мощности
	(например, если имеющийся блок питания рассчитан на 250 Ватт,
	попробуйте другой мощностью 300 Ватт).</para>
    </listitem>
  </orderedlist>

  <para>Вы также должны прочитать FAQ по SIG11 (ссылка дана ниже), в котором
    даны прекрасные описания всех этих проблем, хотя и с точки зрения Linux.
    Также обсуждается, как аппаратура или программное обеспечение для
    тестирования памяти могут пропускать сбойную память.</para>

  <para>Наконец, если ничего из этого не помогает, то возможно, что просто вы
    нашли ошибку во FreeBSD и должны следовать инструкциям по посылке
    сообщений о проблемах.</para>

  <para>Подробная информация по этому вопросу содержится в <ulink
    URL="http://www.bitwizard.nl/sig11/">FAQ по проблеме SIG11</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="screen-loses-sync">
    <para>При загрузке монитор темнеет и теряет синхронизацию!</para>
  </question>

  <answer>

  <para>Это известная проблема с видеоадаптерами ATI Mach 64.  Она вызвана тем,
    что этот адаптер использует адрес <literal>2e8</literal>, как и
    четвёртый последовательный порт.  Из-за ошибки (или особенности работы?) в
    драйвере <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?sio(4)">
    sio(4)</ulink> он обращается к порту, даже если если он не существует, и
    <emphasis remap=bf>даже</emphasis> если вы отключите sio3 (четвёртый порт),
    который, как правило, использует этот адрес ввода/вывода.</para>

  <para>Пока это не исправлено, используйте следующий метод:</para>

  <para>
    <orderedlist>
      <listitem>
        <para>В приглашении загрузчика наберите <option>-c</option>.  (Это
          переведёт ядро в режим конфигурации).</para>
      </listitem>

      <listitem>
        <para>Отключите устройства <devicename>sio0</devicename>,
          <devicename>sio1</devicename>, <devicename>sio2</devicename> и
          <devicename>sio3</devicename> (все их).  После этого драйвер sio не
          будет активизироваться и проблем не будет.</para>
      </listitem>

      <listitem>
        <para>Для продолжения загрузки наберите exit.</para>
      </listitem>
    </orderedlist>
  </para>

  <para>Если вам нужно использовать последовательные порты, вы должны построить
    новое ядро со следующей модификацией: в файле
    <filename>/usr/src/sys/i386/isa/sio.c</filename> найдите строчку, содержащую
    число <literal>0x2e8</literal> и удалите её вместе с предшествующий запятой
    (оставив следующую).  После этого следуйте обычным указаниям по построению
    ядра.</para>

  <para>Даже после этих изменений вы можете обнаружить, что X Window работает
    ненормально.  Если это произошло, удостоверьтесь, что вы используете
    XFree86 версии не ниже 3.3.3.  Этот и последующие релизы имеют встроенную
    поддержку адаптеров Mach64 и даже отдельный X-сервер для таких
    адаптеров.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="reallybigram">
    <para>У меня 128 МБ ОЗУ, но система используется только 64.</para>
  </question>

  <answer>

  <para>Так как для определения объёма памяти FreeBSD использует информацию
    BIOS, она ограничена 16 битами, используемыми для выражения
    размера ОЗУ в килобайтах (65535 КБ = 64МБ) (или меньше... некоторые
    BIOS ограничивают размеры памяти до 16МБ).  Если у вас больше чем 64МБ
    ОЗУ, FreeBSD будет пытаться обнаружить эту память; однако эта попытка
    может и не удасться).</para>

  <para>Для решения этой проблемы вам нужно использовать опцию ядра,
    указанную ниже.  Способ выяснения полной информации о памяти из BIOS
    существует, но у нас нет места в загрузочном блоке, чтобы это делать.
    Когда проблема нехватки места в загрузочных блоках будет решена, мы
    будем использовать расширенные функции BIOS для получения полной
    информации о памяти... но пока мы остановились на опции ядра.</para>

  <para><literal>options "MAXMEM=<replaceable>n</replaceable>"</literal></para>

  <para>Здесь <replaceable>n</replaceable> - это объём памяти в килобайтах. Для
    машины со 128 МБ ОЗУ вам нужно использовать значение
    <literal>131072</literal>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="panic-kmemmap-too-small">
    <para>FreeBSD 2.0 аварийно завершает работу с сообщением <literal>kmem_map
      too small!</literal></para>
  </question>

  <answer>

  <para>
    <note>
      <para>Сообщение может также выглядеть как <literal>mb_map too
        small!</literal></para>
    </note>
  </para>

  <para>Такое завершение работы показывает, что системе не хватает
    виртуальной памяти для сетевых буферов (точнее, структур mbuf). Вы
    можете увеличить количество виртуальной памяти для структур mbuf,
    добавив:</para>

  <para><literal>options "NMBCLUSTERS=<replaceable>n</replaceable>"</literal>
    </para>

  <para>в файл конфигурации ядра, где <replaceable>n</replaceable> - это число
    в пределах 512-4096, в зависимости от числа TCP-соединений, которое вам
    нужно одновременно обслуживать.  Я рекомендую попробовать значение 2048 -
    это должно избавить вас от аварийных остановов.  Вы можете отслеживать
    количество структур mbuf, выделенных/используемых системой командой <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?netstat(1)">netstat -m</ulink>.
    Значение по умолчанию для NMBCLUSTERS равно
    <literal>512 + MAXUSERS * 16</literal>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="cmap-busy-panic">
    <para>При перезагрузке с новым ядром выдаётся сообщение <literal>CMAP busy
      panic</literal>.</para>
  </question>

  <answer>

  <para>Процедура определения устаревших файлов
    <filename>/var/db/kvm_*.db</filename> иногда даёт сбой и использует не те
    файлы, что может вызвать аварийный останов системы.</para>

  <para>Если это случилось, перезагрузитесь в однопользовательском режиме
    и выполните команду:</para>

  <screen>
&prompt.root; <userinput>rm /var/db/kvm_*.db</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="brkadrint-illegal-host-access">
    <para>ahc0: brkadrint,  Illegal Host Access at seqaddr 0x0</para>
  </question>

  <answer>

  <para>Это - результат конфликта со SCSI-адаптером Ultrastor. </para>
  
  <para>Во время загрузки войдите в меню конфигурации ядра и выключите
    устройство <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?uha(4)">
    uha0</ulink>, являющееся источником этой проблемы.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="mail-loopback">
    <para>Sendmail говорит, что <literal>mail loops back to
      myself</literal></para>
  </question>

  <answer>

  <para>В FAQ по sendmail на это дан такой ответ:-</para>
  
  <para>     
    <literallayout>
        * Выдаются сообщения "Local configuration error", примерно такие:

        553 relay.domain.net config error: mail loops back to myself
        554 &lt;user@domain.net&gt;... Local configuration error

        Как можно решить эту проблему?

        Согласно записям MX, почта для домена (скажем, domain.net) была
        перенаправлена на указанный хост (в нашем случае relay.domain.net),
        но он не распознаётся как domain.net.  Добавьте строку domain.net в
        файл /etc/sendmail.cw (если вы используете FEATURE(use_cw_file)) или
        добавьте "Cw domain.net" в /etc/sendmail.cf.
    </literallayout>
  </para>

  <para>Текущая версия <ulink
    URL="ftp://rtfm.mit.edu/pub/usenet/news.answers/mail/sendmail-faq">
    FAQ по sendmail</ulink> больше не поставляется вместе с sendmail.
    Однако этот документ регулярно помещается в конференции
    <ulink URL="news:comp.mail.sendmail">comp.mail.sendmail</ulink>,
    <ulink URL="news:comp.mail.misc">comp.mail.misc</ulink>,
    <ulink URL="news:comp.mail.smail">comp.mail.smail</ulink>,
    <ulink URL="news:comp.answers">comp.answers</ulink> и
    <ulink URL="news:news.answers">news.answers</ulink>.
    Вы можете получить копию по электронной почте, послав сообщение,
    содержащее команду
    <literal>send usenet/news.answers/mail/sendmail-faq</literal> в теле
    письма, в адрес <email>mail-server@rtfm.mit.edu</email>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="remote-fullscreen">
    <para>Полноэкранные приложения на удалённой машине ведут себя
      неправильно!</para>
  </question>

  <answer>

  <para>На удалённой машине тип терминала может быть установлен в значение,
    отличное от типа терминала <literal>cons25</literal>, требуемом при
    использовании консоли FreeBSD.</para>

  <para>Есть несколько возможных способов решения этой проблемы:</para>

  <para>
    <itemizedlist>
      <listitem>
        <para>После входа на другую машину установите значение переменной
          окружения TERM равным <literal>ansi</literal> или
          <literal>sco</literal>, если эта машина знает об этих
          типах терминалов.</para>
      </listitem>

      <listitem>
        <para>Используйте эмулятор VT100 типа <ulink
          URL="http://www.FreeBSD.org/cgi/ports.cgi?screen-">screen</ulink> 
          на консоли FreeBSD. <application>Screen</application> даёт вам
          возможность открывать несколько рабочих сеансов на одном терминале,
          и она имеет ещё ряд полезных особенностей.  Каждое окно программы
          <application>screen</application> ведёт себя как терминал VT100, так
          что переменная TERM на удалённой машине должна быть установлена в
          значение <literal>vt100</literal>.</para>
      </listitem>

      <listitem>
        <para>Опишите терминал <literal>cons25</literal> в базе данных
          характеристик терминалов на удалённой машине.  Способ описания
          зависит от используемой на этой машине операционной системе.  Вам
          может помочь чтение руководств по администрированию удалённой
          системы.</para>
      </listitem>

      <listitem>
        <para>Запустите X-сервер на стороне FreeBSD и войдите на удалённую
          систему с помощью какого-либо эмулятора терминала, работающего в X
          Window, такого, как <command>xterm</command> или
          <command>rxvt</command>.  Переменная окружения TERM на удалённой
          машине должна быть установлена в значение <literal>xterm</literal>
          или <literal>vt100</literal>.</para>
      </listitem>
    </itemizedlist>
  </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="calcru-negative">
    <para>Выводятся сообщения <literal>calcru: negative
      time...</literal></para>
  </question>

  <answer>

  <para>Это может быть вызвано различными аппаратными или программными
    проблемами, связанными с прерываниями.  Это может быть связано как
    с ошибками при программировании, так и с природой самих устройств.
    Например, работа с TCP/IP по параллельному порту с использованием
    большого MTU приводит к этой проблеме, также как использование
    графических акселераторов; в последнем случае вы должны проверить
    настройку прерываний на графическом адаптере.</para>

  <para>Одним из проявлений этой проблемы является прерывание работы
    процессов с диагностическим сообщением <quote>SIGXCPU exceeded cpu time
    limit</quote>.</para>

  <para>Если эта проблема не может быть решена, для FreeBSD 3.0 от 29
    ноября 1998 и выше измените значение системной переменной:</para>

  <screen>
&prompt.root; <userinput>sysctl -w kern.timecounter.method=1</userinput>
  </screen>

  <para>Это коснётся производительности системы, но, принимая во внимание
    источник этой проблемы, это будет незаметно.  Если проблема всё ещё
    даёт о себе знать, оставьте значение этой переменной равным единичке
    и увеличьте значение параметра <literal>NTIMECOUNTER</literal> в файле
    конфигурации вашего ядра.  Если в конце концов вы достигнете значения
    <literal>NTIMECOUNTER=20</literal>, то вам эту проблему решить не удастся,
    прерывания дают слишком большую нагрузку на процессор, чтобы обеспечить
    отслеживание времени.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="pcm0-not-found">
    <para>Выдаётся сообщение <literal>pcm0 not found</literal> или мой звуковой
      адаптер определяется как <literal>pcm1</literal>, хотя в конфигурационном
      файле ядра указана строчка <literal>device pcm0</literal></para>
  </question>

  <answer>

  <para>Такое бывает во FreeBSD 3.x со звуковыми адаптерами PCI.  Устройство
    <literal>pcm0</literal> предназначено исключительно для адаптеров ISA,
    поэтому, если у вас имеется адаптер PCI, то вы увидите эту ошибку и ваш
    адаптер будет распознан как <literal>pcm1</literal>.

  <note>
    <para>Вы не сможете избавиться от предупреждающего сообщения, просто
      изменив строку в конфигурационном файле ядра на
      <literal>device pcm1</literal>, так как это приведёт к закреплению
      устройства <literal>pcm1</literal> за адаптерами ISA, а ваш адаптер PCI
      будет найден как устройство <literal>pcm2</literal> (и появится
      предупреждение <literal>pcm1 not found</literal>).</para>
  </note>

  Если у вас имеется звуковой адаптер PCI, то вам нужно также создать
  устройство <literal>snd1</literal>, а не <literal>snd0</literal>:</para>

  <screen>
&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>./MAKEDEV snd1</userinput>
  </screen>

  <para>Такой ситуации не возникает во FreeBSD 4.x, так как в ней было положено
    много усилий, чтобы сделать её более <emphasis>PnP-центричной</emphasis> и
    устройство <literal>pcm0</literal> больше не предназначено исключительно
    для адаптеров ISA</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="pnp-not-found">
    <para>После обновления FreeBSD до версии 4.x мой PnP-адаптер больше не
      обнаруживается (или определяется как <literal>unknown</literal>)</para>
  </question>

  <answer>

  <para>FreeBSD 4.x теперь гораздо более <emphasis>PnP-центрична</emphasis>,
    что отражается на некоторых устройствах PnP (к примеру, звуковых
    адаптерах и внутренних модемах), перестающих работать, хотя они
    функционировали в системе FreeBSD 3.x.</para>

  <para>Причины такого поведения объясняются в следующем сообщении
    электронной почты, опубликованном в списке рассылки freebsd-questions
    Питером Уэммом (Peter Wemm) в ответ на вопрос о внутреннем модеме,
    который перестал распознаваться после обновления до FreeBSD 4.x
    (комментарии внутри <literal>[]</literal> были добавлены для пояснения
    контекста послания.</para>

  <blockquote>
    <para>BIOS, поддерживающая PNP, предварительно отводит и оставляет ему
      [модему] место в адресном пространстве портов, так что [в 3.x]
      процедура обнаружения в старом стиле ISA <quote>находит</quote> его
      здесь.</para>

    <para>В 4.0 код для работы с ISA гораздо более PnP-центричен.  [В 3.x]
      было возможно при распознавании ISA найти <quote>беспризорное</quote>
      устройство и затем по идентификатору PNP-устройства произвести поиск и
      получить ошибку из-за конфликта ресурсов.  Поэтому для предотвращения
      повторной процедуры распознавания в нем сначала выключаются все
      управляемые адаптеры.  Это также означает, что для поддерживаемого
      оборудования PnP нужно знать их PnP-идентификаторы.  Имеются планы на
      обеспечение возможности найстройки этого со стороны
      пользователя.</para>
  </blockquote>

  <para>Чтобы заставить устройство работать снова, требуется определить его
    PnP-идентификатор и добавить его в список, который используется
    процедурой распознавания ISA для идентификации устройств PnP.  Этот
    идентификатор можно получить при помощи программы &man.pnpinfo.8;, найдя
    устройство в ее выдаче, вот, например, вывод команды &man.pnpinfo.8; в
    случае внутреннего модема:</para>

  <screen>
&prompt.root; <userinput>pnpinfo</userinput>
Checking for Plug-n-Play devices...

Card assigned CSN #1
Vendor ID PMC2430 (0x3024a341), Serial Number 0xffffffff
PnP Version 1.0, Vendor Version 0
Device Description: Pace 56 Voice Internal Plug & Play Modem

Logical Device ID: PMC2430 0x3024a341 #0
	Device supports I/O Range Check
TAG Start DF
    I/O Range 0x3f8 .. 0x3f8, alignment 0x8, len 0x8
	[16-bit addr]
    IRQ: 4  - only one type (true/edge)
  </screen>

  <para>[лишние строки TAG исключены]</para>

  <screen>
TAG End DF
End Tag

Successfully got 31 resources, 1 logical fdevs
-- card select # 0x0001

CSN PMC2430 (0x3024a341), Serial Number 0xffffffff

Logical device #0
IO:  0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8 0x03e8
IRQ 5 0
DMA 4 0
IO range check 0x00 activate 0x01
  </screen>

  <para>Информация, которая вам нужна, находится в строке <quote>Vendor
    ID</quote> в самом начале вывода команды.  Шестнадцатиричное число в
    скобках (в этом примере 0x3024a341) является PnP-идентификатором, а
    строчка, идущая прямо перед ним (PMC2430) является уникальным
    ASCII-идентификатором.  Эту информацию нужно добавить в файл
    <filename>/usr/src/sys/isa/sio.c</filename>.</para>

  <para>Сначала вы должны сделать резервную копию файла
    <filename>sio.c</filename> просто на тот случай, если что-то пойдет не
    так.  Эта копия также может потребоваться для создания патча для
    посылки его вместе с вашим PR (вы же собираетесь послать PR, не правда
    ли?) отредактировав файл <filename>sio.c</filename> и поискав
    строчку</para>

  <programlisting>
static struct isa_pnp_id sio_ids[] = {
  </programlisting>

  <para>после чего переместитесь ниже и найдите подходящее место, чтобы
    добавить строчку для вашего устройства.  Записи имеют примерно такой
    вид, и они отсортированы по ASCII-строкам Vendor ID, которые должны быть
    помещены в поле комментария справа от строки кода вместе с полным
    описанием устройства (если оно поместится) или частью из
    <emphasis>Device Description</emphasis> вывода программы
    &man.pnpinfo.8;:</para>

  <programlisting>
{0x0f804f3f, NULL},	/* OZO800f - Zoom 2812 (56k Modem) */
{0x39804f3f, NULL},	/* OZO8039 - Zoom 56k flex */
{0x3024a341, NULL},	/* PMC2430 - Pace 56 Voice Internal Modem */
{0x1000eb49, NULL},	/* ROK0010 - Rockwell ? */
{0x5002734a, NULL},	/* RSS0250 - 5614Jx3(G) Internal Modem */
  </programlisting>

  <para>Добавьте шестнадцатиричный идентификатор Vendor ID вашего устройства
    в соответствующее место, сохраните файл, перестройте ядро и выполните
    перезагрузку.  Ваше устройство должно теперь быть найдено в виде
    устройства <literal>sio</literal>, как это и было во FreeBSD 3.x</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="nlist-failed">
    <para>При запуске некоторых программ, например, <command>top</command>
      или <command>systat</command>, выдается сообщение об ошибке
      <errorname>nlist failed</errorname>.</para>
  </question>

  <answer>
  <para>Проблема в том, что приложение, которое вы пытаетесь запустить,
    ищет специфические ссылки в ядре, но по каким-либо причинам не может
    их найти; эта ошибка происходит от одной из следующих проблем:</para>

  <itemizedlist>
    <listitem>
      <para>Ваше ядро и программы пользователей не соответствуют друг другу
        (например, вы построили ядро, но не выполнили команду
        <maketarget>installworld</maketarget>, или наоборот), и поэтому
        таблица имен отличается от того, что думают о ней пользовательские
        приложения.  Если это ваш случай, просто завершите процесс
        обновления (обратитесь к файлу
        <filename>/usr/src/UPDATING</filename> для выяснения правильной
        последовательности действий).</para>
    </listitem>

    <listitem>
      <para>Для загрузки ядра вы не используете
        <command>/boot/loader</command>, а делаете это непосредственно из
        boot2 (обратитесь к справочно странице по &man.boot.8;).  Хотя нет
        ничего плохого в обходе <command>/boot/loader</command>, обычно
        работу по доступности символьной информации ядра из
        пользовательских приложений он выполняет лучше.</para>
    </listitem>
  </itemizedlist>

  </answer>
</qandaentry>

</qandaset>
</chapter>


<chapter id="commercial">
<title>Коммерческие приложения</title>

<para>
  <note>
    <para>Этот раздел выглядит довольно заброшенным, однако мы,
      конечно же, надеемся, что производители сделают добавления! :)  Проект
      FreeBSD финансово не заинтересован в успехах никакой из компаний, которые
      здесь упоминаются, хотя приводит их список в интересах общества (в
      предположении, что коммерческий интерес к FreeBSD может положительно
      повлиять на дальнейшее развитие FreeBSD).  Мы просим поставщиков
      коммерческого программного обеспечения присылать нам информацию о
      ваших продуктах для включения в этот список.  Более полный список
      производителей находится на <ulink
      URL="http://www.FreeBSD.org/commercial/commercial.html">странице
      производителей</ulink>.</para>
  </note>
</para>


<qandaset>
<qandaentry>
  <question id="motif">
    <para>Где можно купить Motif для FreeBSD?</para>
  </question>

  <answer>

  <para>Обратитесь в фирму <link linkend="apps2go">Apps2go</link>, предлагающую
    самый дешёвый дистрибутив Motif 2.1.20 для FreeBSD (как для i386, так и для
    Alpha) в формате ELF.<anchor id="apps2go"></para>
 
  <para>Существуют два дистрибутива, <quote>для разработчиков</quote>
    (<quote>development edition</quote>) и ещё более дешёвая <quote>времени
    выполнения</quote> (<quote>runtime edition</quote>).  В эти дистрибутивы
    включены:

    <itemizedlist>
      <listitem>
        <para>OSF/Motif manager, xmbind, panner, wsm.</para>
      </listitem>

      <listitem>
        <para>Пакет разработчика с uil, mrm, xm, xmcxx, файлами include
          и Imake.</para>
      </listitem>

      <listitem>
        <para>Статические и динамические ELF-библиотеки (для использования
          с FreeBSD 3.0 и выше).</para>
      </listitem>

      <listitem>
        <para>Демонстрационные приложения.</para>
      </listitem>
    </itemizedlist>
  </para>
 
  <para>При оформлении заказа не забудьте указать, что вам нужна версия Motif
    именно для FreeBSD (не забудьте также указать архитектуру процессора)!
    <emphasis>Apps2go</emphasis> также продаёт версии для NetBSD и OpenBSD.  В
    настоящий момент их можно получить только по FTP.</para>

  <para>
    <variablelist>
      <varlistentry><term>Дополнительная информация</term>
        <listitem>
          <para><ulink
            URL="http://www.apps2go.com/">WWW-сервер Apps2go</ulink></para>
        </listitem>
      </varlistentry>

      <varlistentry><term>или</term>
        <listitem>
          <para>электронные адреса отделов <ulink
            URL="mailto:sales@apps2go.com">продаж</ulink> и <ulink
            URL="mailto:support@apps2go.com">поддержки</ulink>.</para>
        </listitem>
      </varlistentry>

      <varlistentry><term>или</term>
        <listitem>
          <para>телефоны (817) 431 8775  и +1 817 431-8775</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </para>
  
  <para>Обратитесь в фирму <link linkend="metrox">Metro Link</link> для
    получения дистрибутива Motif 2.1 для FreeBSD в форматах ELF или
    a.out.</para>

  <para>В этот дистрибутив включены:
    <itemizedlist>
      <listitem>
        <para>OSF/Motif manager, xmbind, panner, wsm.</para>
      </listitem>

      <listitem>
        <para>Пакет разработчика с uil, mrm, xm, xmcxx, файлами include
          и Imake.</para>
      </listitem>

      <listitem>
        <para>Статические и динамические библиотеки (укажите ELF для
          использования с FreeBSD 3.0 и выше; или a.out при использовании
          FreeBSD 2.2.8 и ранее).</para>
      </listitem>

      <listitem>
        <para>Демонстрационные приложения.</para>
      </listitem>

      <listitem>
        <para>Преформатированные страницы справочника.</para>
      </listitem>
    </itemizedlist>
  </para>

  <para>При заказе обязательно отметьте, что вам требуется версия Motif
    именно для FreeBSD! <emphasis>Metro Link</emphasis> также предлагает
    версии для Linux. Они доступны на CDROM или для скачивания по FTP.</para>

  <para>Обратитесь в фирму <link linkend="xig">Xi Graphics</link> за
    дистрибутивом Motif 2.0 для FreeBSD в формате a.out.</para>

  <para>В этот дистрибутив включены:
    <itemizedlist>
      <listitem>
        <para>OSF/Motif manager, xmbind, panner, wsm.</para>
      </listitem>

      <listitem>
        <para>Пакет разработчика с uil, mrm, xm, xmcxx, файлами include
          и Imake.</para>
      </listitem>

      <listitem>
        <para>Статические и динамические библиотеки (для использования с
          FreeBSD 2.2.8 и ранее).</para>
      </listitem>

      <listitem>
        <para>Демонстрационные приложения.</para>
      </listitem>

      <listitem>
        <para>Отформатированные страницы Справочника.</para>
      </listitem>
    </itemizedlist>
  </para>

  <para>При заказе обязательно укажите, что вам требуется версия Motif именно
    для FreeBSD!  <emphasis>Xi Graphics</emphasis> также предлагает версии
    для BSDI и Linux.  В настоящее время это набор из 4 дискет... в будущем
    это будет стандартный дистрибутив на компакт-диске, как их CDE.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="cde">
    <para>Где можно купить CDE для FreeBSD?</para>
  </question>

  <answer>

  <para>Фирма <link linkend="xig">Xi Graphics</link> предлагала CDE для FreeBSD,
    но сейчас этот продукт в продаже отсутствует.</para>
 
  <para><ulink URL="http://www.kde.org/">KDE</ulink> - это свободно
    распространяемый вариант десктопа для X11, который во многом похож на CDE.
    Вам может также приглянуться <ulink URL="http://www.xfce.org/">xfce</ulink>.
    Как KDE, так и xfce могут быть найдены в <ulink
    URL="http://www.FreeBSD.org/ports/">коллекции портов</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="commercial-xserver">
    <para>Существуют ли коммерческие высокопроизводительные X-серверы?</para>
  </question>

  <answer>

  <para>Да, фирмы <ulink URL="http://www.xig.com/">Xi Graphics</ulink> и
    <ulink URL="http://www.metrolink.com/">Metro Link</ulink> предлагают свой
    продукт Accelerated-X для FreeBSD и других систем на базе Intel.</para>

  <para>Metro Link предлагает высокопроизводительный X-сервер, в котором
    предусмотрена упрощённая процедура конфигурирования с помощью набора
    утилит FreeBSD для работы с пэкэджами, поддержка нескольких
    видеоадаптеров одновременно и он поставляется только в бинарном виде,
    доступном по FTP.  Нельзя не отметить, что Metro Link продаёт всё это
    по очень доступной цене в 39 долларов.<anchor id="metrox"></para>

  <para>Metro Link продаёт также Motif для FreeBSD в форматах ELF и a.out
    (смотрите выше).</para>

  <para>     
    <variablelist>
      <varlistentry><term>Дополнительная информация</term>
        <listitem>
          <para><ulink URL="http://www.metrolink.com/">
            WWW-сервер Metro Link</ulink></para>
        </listitem>
      </varlistentry>

      <varlistentry><term>или</term>
        <listitem>
          <para>адреса электронной почты отделов <ulink 
            URL="mailto:sales@metrolink.com">продаж</ulink> и <ulink
            URL="mailto:tech@metrolink.com">поддержки</ulink>.</para>
        </listitem>
      </varlistentry>

      <varlistentry><term>или</term>
        <listitem>
          <para>телефоны (954) 938-0283 и +1 954 938-0283</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </para>

  <para>Xi Graphics предлагает высокопроизводительный X-сервер, который
    обеспечивает простую конфигурацию, поддержку нескольких видеоадаптеров
    и поставляется только в бинарной форме, в форме стандартного
    дистрибутива на дискетах для FreeBSD и Linux.  Xi Graphics также
    предлагает высокопроизводительный X-сервер с поддержкой компьютеров
    класса laptop.<anchor id="xig"></para>

  <para>Имеется бесплатная <quote>демонстрационная</quote> версия 5.0.</para>

  <para>Xi Graphics также предлагает Motif и CDE для FreeBSD (смотрите
    выше).</para>

  <para>     
    <variablelist>
      <varlistentry><term>Дополнительная информация</term>
        <listitem>
          <para><ulink URL="http://www.xig.com/">
            Xi Graphics WWW page</ulink></para>
        </listitem>
      </varlistentry>

      <varlistentry><term>или</term>
        <listitem>
          <para><ulink URL="mailto:sales@xig.com">Sales</ulink> или <ulink
            URL="mailto:support@xig.com">Support</ulink> по email.</para>
        </listitem>
      </varlistentry>

      <varlistentry><term>или</term>
        <listitem>
          <para>телефон (800) 946 7433  или +1 303 298-7478.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </para>
  
  </answer>
</qandaentry>


<qandaentry>
  <question id="database-systems">
    <para>Существуют ли СУБД для FreeBSD?</para>
  </question>

  <answer>

  <para>Да! Обратитесь к разделу <ulink
    URL="http://www.FreeBSD.org/commercial/software_bycat.html#CATEGORY_DATABASE">
    Поставщики программного обеспечения</ulink> на веб-сервере FreeBSD.</para>

  <para>Также посмотрите раздел <ulink
    URL="http://www.FreeBSD.org/ports/databases.html">Базы данных</ulink>
    Коллекции портов.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="oracle-support">
    <para>Можно ли запустить Oracle на FreeBSD?</para>
  </question>

  <answer>

  <para>Да. Руководство по настройке Linux-Oracle на FreeBSD находится
    по следующим адресам:</para>

  <para>       
    <itemizedlist>
      <listitem>
        <para><ulink URL="http://www.scc.nl/~marcel/howto-oracle.html">
          http://www.scc.nl/~marcel/howto-oracle.html</ulink></para>
      </listitem>

      <listitem>
        <para><ulink
          URL="http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd">
          http://www.lf.net/lf/pi/oracle/install-linux-oracle-on-freebsd</ulink>
          </para>
      </listitem>
    </itemizedlist>
  </para>

  </answer>
</qandaentry>
</qandaset>
</chapter>


<chapter id="applications">
<title>Прикладные программы</title>

<qandaset>
<qandaentry>
  <question id="user-apps">
    <para>Итак, где находятся все прикладные программы?</para>
  </question>

  <answer>

  <para>Пожалуйста, загляните на <ulink URL="http://www.FreeBSD.org/ru/ports/">
    страницу портов</ulink>, содержащую информацию о программных продуктах,
    перенесённых во FreeBSD.  На данный момент в этом списке находится более
    3400 приложений и он ежедневно увеличивается, так что почаще туда
    заглядывайте или подпишитесь на <link
    linkend="mailing">список рассылки</link>
    <literal>freebsd-announce</literal>, в котором публикуется информация
    о появлении новых приложений.</para>

  <para>Большинство портов предназначено для веток 2.2, 3.x и 4.x, и многие из
    них должны нормально работать на системах версий 2.1.x.  При выходе
    нового релиза FreeBSD в него в каталог <filename>ports/</filename>
    включается актуальная на момент выхода коллекция портов.</para>

  <para>Мы также поддерживаем концепцию <quote>пакаджа</quote>, являющегося не
    более чем упакованным дистрибутивом в бинарной форме с некоторыми
    встроенными возможностями по его настройке во время установки. Пакадж
    может быть легко проинсталлирован и деинсталлирован снова без углубления
    в детали того, какие файлы должны быть инсталлированы.</para>

  <para>Используйте меню установки пакаджей в
    <filename>/stand/sysinstall</filename> (в пункте меню post-configuration)
    или запускайте <command>pkg_add(1)</command> с указанием конкретных файлов
    с пакаджами, которые вы хотите проинсталлировать.  Файлы с пакаджами, как
    правило, идентифицируются по их суффиксу <filename>.tgz</filename>, а для
    тех, кто имеет дистрибутив системы на компакт-диске, предназначен каталог
    <filename>packages/All</filename>, содержащий все эти файлы.  Они также
    могут быть получены по сети для разных версий FreeBSD со следующих
    серверов:</para>

  <para>     
    <variablelist>
      <varlistentry><term>для 2.2.8-RELEASE/2.2.8-STABLE</term>
        <listitem>
          <para><ulink
            URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/">
            ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-2.2.8/</ulink></para>
        </listitem>
      </varlistentry>

      <varlistentry><term>для 3.X-RELEASE/3.X-STABLE</term>
        <listitem>
          <para><ulink
            URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-3-stable/">
            ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-3-stable/</ulink></para>
        </listitem>
      </varlistentry>

      <varlistentry><term>для 4.X-RELEASE/4-STABLE</term>
        <listitem>
          <para><ulink
            URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-stable/">
            ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-4-stable/</ulink></para>
        </listitem>
      </varlistentry>

      <varlistentry><term>для 5.X-CURRENT</term>
        <listitem>
          <para><ulink
            URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-5-current/">
            ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/i386/packages-5-current/</ulink></para>
        </listitem>
      </varlistentry>
    </variablelist>
  </para>

  <para>или с ближайшего к вам зеркального сервера.</para>

  <para>Имейте в виду, что не все порты могут быть доступны в виде
    пакаджей, так как постоянно идёт добавление новых. Неплохо время от
    времени проверять, какие пакаджи доступны на основном сервере <ulink
    URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/">ftp.FreeBSD.org</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="minimal-sh">
    <para>Почему возможности <command>/bin/sh</command> так малы?  Почему бы
      во FreeBSD не использовать <command>bash</command> или какой-либо другой
      командный процессор?</para>
  </question><answer>

  <para>Потому что в стандарте POSIX сказано, что все командные процессоры
    должны вести себя так же, как shell.</para>

  <para>Более подробный ответ заключается в следующем: многим требуется, чтобы
    разрабатываемые скрипты для командного процессора были переносимы между
    многими системами.  Именно поэтому в POSIX очень подробно описан командный
    процессор и набор утилит.  Большинство скриптов пишутся на языке процессора
    Bourne shell, к тому же некоторые важные программные вызовы
    (&man.make.1;, &man.system.3;, &man.popen.3; и их аналоги на языках скриптов
    высокого уровня, таких как Perl или Tcl) предполагают для интерпретации
    команд использование именно Bourne shell.  Так как Bourne shell используется
    столь широко и часто, то очень важно, чтобы он стартовал очень быстро, его
    поведение было строго регламентировано и при этом потребности в оперативной
    памяти были малы.</para>

  <para>В имеющейся реализации мы приложили максимум усилий для воплощения в
    жизнь всех этих требований одновременно.  Для того, чтобы сохранить
    <command>/bin/sh</command> небольшим по размеру, мы не включили многие из
    обычных возможностей, которые имеются в других командных процессорах.
    Однако в Коллекцию Портов включены командные процессоры, обладающие гораздо
    большими возможностями, такие, как bash, scsh, tcsh и zsh. (Вы можете
    сами сравнить использование памяти всеми этими оболочками, посмотрев в
    колонки <quote>VSZ</quote> и <quote>RSS</quote> вывода команды <command>ps
    -u</command>).</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="missing-libcso30">
    <para>Где найти библиотеку libc.so.3.0?</para>
  </question>

  <answer>

  <para>Похоже, что вы пытаетесь запустить пакадж, построенный в системе версии
    2.2 и выше, на системе версии 2.1.x. Пожалуйста, прочтите предыдущий раздел
    и найдите подходящий для вашей системы порт или пакадж.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="missing-libcso40">
    <para>Выдаются сообщения <literal>Error: can't find
      libc.so.4.0</literal></para>
  </question>

  <answer>

  <para>Вы случайно скачали пакаджи, предназначенные для систем версий 4.X и
    5.X и пытались установить их на вашей системе FreeBSD версий 2.X или 3.X.
    Пожалуйста, скачайте подходящие версии пакаджей.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="emul">
    <para>ghostscript выдаёт массу сообщений на моём 386/486SX.</para>
  </question>

  <answer>

  <para>У вас нет сопроцессора, верно?  Вам нужно добавить в ядро другой
    эмулятор сопроцессора; это делается добавлением следующей строки в файл
    конфигурации ядра и последующей его перекомпиляцией.</para>

  <programlisting>
options GPL_MATH_EMULATE
  </programlisting>

  <para>
    <note>
      <para>Если вы поступаете таким образом, вам нужно будет
        убрать опцию <literal>MATH_EMULATE</literal>.</para>
    </note>
  </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="sco-socksys">
    <para>При запуске приложения SCO/iBCS2, оно прерывается на
      <literal>socksys</literal> (только во FreeBSD 3.0 и более
      ранних версий).</para>
  </question>

  <answer>

  <para>Прежде всего вам нужно отредактировать файл
    <filename>/etc/sysconfig</filename> (или <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)">/etc/rc.conf</ulink>),
    изменив в последнем разделе значение следующей переменной на
    <literal>YES</literal>:</para>

  <programlisting>
# Set to YES if you want ibcs2 (SCO) emulation loaded at startup
ibcs2=NO
  </programlisting>

  <para>После этого модуль ядра для поддержки ibcs2 будет запущен на этапе
    загрузки системы.</para>

  <para>Затем вам нужно изменить каталог /compat/ibcs2/dev так, чтобы он
    выглядел следующим образом:</para>

  <screen>
lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 X0R@ -&gt; /dev/null
lrwxr-xr-x  1 root  wheel         7 Oct 15 22:20 nfsd@ -&gt; socksys
-rw-rw-r--  1 root  wheel         0 Oct 28 12:02 null
lrwxr-xr-x  1 root  wheel         9 Oct 15 22:20 socksys@ -&gt; /dev/null
crw-rw-rw-  1 root  wheel   41,   1 Oct 15 22:14 spx
  </screen>

  <para>Работа с socksys была значительно упрощена по сравнению с более ранними
    версиями.  Socksys должен указывать на <ulink 
    URL="http://www.FreeBSD.org/cgi/man.cgi?null(4)">/dev/null</ulink>, чтобы
    обмануть open &amp; close.  Код, имеющийся в -CURRENT, возьмёт на себя всё
    остальное.  Если вам нужен драйвер <devicename>spx</devicename> для
    подключения X по локальному сокету, определите переменную
    <literal>SPX_HACK</literal> при компиляции системы.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="configure-inn">
    <para>Как настроить INN (Internet News) на моей машине?</para>
  </question>

  <answer>

  <para>После установки пакаджа или порта для inn, для начала загляните
    на <ulink URL="http://www.cis.ohio-state.edu/~barr/INN.html">страничку
    Дэйва Бэрра</ulink> (Dave Barr), посвящённую INN, где вы
    найдёте соответствующий FAQ.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ms-frontpage">
    <para>Какую версию Microsoft FrontPage я должен иметь?</para>
  </question>

  <answer>

  <para>Используй порт, дурачок! Среди портов имеется Apache с поддержкой
    FrontPage.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="java">
    <para>Поддерживает ли FreeBSD среду Java?</para>
  </question>

  <answer>

  <para>Да. Посетите страницу <ulink URL="http://www.FreeBSD.org/java/">
    http://www.FreeBSD.org/java/</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ports-3x">
    <para>Почему некоторый порт не компилируется на моей машине
      с 3.X-STABLE?</para>
  </question>

  <answer>

  <para>Если вы используете FreeBSD версии, значительно отстающей от -CURRENT
    или -STABLE, вам нужен пакет обновления, который можно найти по адресу
    <ulink URL="http://www.FreeBSD.org/ports/">
    http://www.FreeBSD.org/ports/</ulink>.  Если вы отслеживаете все
    изменения, то, скорее всего, кто-то внёс изменения в порт, так что он
    работает в -CURRENT, но не работает в -STABLE.  Так как предполагается, что
    коллекция портов должна работать
    как в ветке -CURRENT, так и в ветви -STABLE, то, пожалуйста, пошлите
    сообщение об этой ошибке с помощью команды <command>send-pr(1)</command>.
    </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="find-ldso">
    <para>Где найти ld.so?</para>
  </question>

  <answer>

  <para>Если вам необходимо запустить некоторые приложения в формате aout
    типа Netscape Navigator на Elf-машине, такой как 3.1-R и выше,
    то для этого требуется <filename>/usr/libexec/ld.so</filename> и некоторые
    библиотеки в формате aout.  Они включены в дистрибутив как compat22.
    Запустите <filename>/stand/sysinstall</filename> или
    <filename>install.sh</filename> в каталоге compat22, чтобы
    установить этот компонент.  Прочтите также документы ERRATA от
    3.1-R и 3.2-R.</para>

  </answer>
</qandaentry>
</qandaset>
</chapter>


<chapter id="kernelconfig">
<title>Конфигурирование ядра</title>


<qandaset>
<qandaentry>
  <question id="make-kernel">
    <para>Я хочу изменить настройки ядра. Это сложно?</para>
  </question>

  <answer>

  <para>Вовсе нет! Обратитесь к <ulink URL="../../handbook/kernelconfig.html">
    соответствующему разделу</ulink> Руководства, который посвящён этому
    вопросу.</para>

  <para>
    <note>
      <para>Рекомендуем сохранить копию вашего ядра в файл
        <filename>kernel.YYMMDD</filename> после того, как вы получите рабочую
        версию, для того, чтобы в следующий раз, если вы испортите что-либо в
        вашем конфигурационном файле, вы смогли загрузить это ядро, вместо того,
        чтобы начинать снова с <filename>kernel.GENERIC</filename>.  Это, в
        частности, имеет смысл, если вы производите загрузку системы с
        контроллера, который не поддерживается в стандартном ядре GENERIC (из
        моего личного опыта).</para>
    </note>
  </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="missing-hw-float">
    <para>Я не могу скомпилировать ядро. Отсутствует
      <literal>_hw_float</literal>.</para>
  </question>

  <answer>

  <para>Позвольте мне угадать.  Вы, наверное, удалили
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?npx(4)">npx0</ulink> из
    вашего файла конфигурации ядра, потому что у вас нет сопроцессора, да?
    А вот и неправильно! :-)   Строка <devicename>npx0</devicename>
    <emphasis>ОБЯЗАТЕЛЬНА</emphasis>.  Даже если у вас нет
    математического сопроцессора, вы <emphasis remap=bf>должны</emphasis>
    включить поддержку устройства <devicename>npx0</devicename>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="why-kernel-big">
    <para>Почему моё ядро такое большое (больше 10МБ)?</para>
  </question>

  <answer>

  <para>Скорее всего, вы компилировали ядро в <emphasis>отладочном
    режиме</emphasis>.  Ядра, построенные в этом режиме, содержат много
    символьной информации, которая используется для отладки и сильно
    увеличивает размер ядра.  Заметьте, что, если вы работаете с FreeBSD версии
    3.0 и старше, то уменьшения производительности при использовании
    отладочного ядра нет или оно незначительно, однако отладочное ядро
    полезно иметь под рукой на случай аварийного завершения работы
    системы.</para>
 
  <para>Однако, если вы испытываете нехватку дискового пространства или
    просто не хотите использовать отладочное ядро, проверьте, что имеют
    место следующие две вещи:</para>

  <itemizedlist>
    <listitem>
      <para>В конфигурационном файле вашего ядра нет строчки, имеющей такой
        вид:</para>

      <programlisting>makeoptions DEBUG=-g</programlisting>
    </listitem>

    <listitem>
      <para>Вы не запускали утилиту <command>config</command> с опцией
        <option>-g</option>.</para>
    </listitem>
  </itemizedlist>

  <para>Обе из вышеперечисленных ситуаций приведут к построению ядра в
    отладочном режиме.  Если же вы точно следуете указанным шагам, то сможете
    построить обычное ядро и заметите значительное уменьшение его размера;
    большинство ядер имеют размер от 1.5МБ до 2МБ.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="multiport-serial-interrupts">
    <para>Конфликты прерываний при включении поддержки многопортовыx
      коммуникационных адаптеров.</para>
  </question>

  <answer>

  <para><emphasis remap=bf>Q.</emphasis> Когда я компилирую ядро с поддержкой
    многопортовых коммуникационных адаптеров, сообщается, что только первый
    порт будет тестироваться, а все остальные пропускаются из-за конфликтов
    прерываний.  Как это исправить?</para>

  <para><emphasis remap=bf>A.</emphasis> Проблема состоит в том, что во FreeBSD
    встроен код, предохраняющий ядро от аппаратных и программных конфликтов.
    Вам нужно убрать указания IRQ на всех портах, кроме одного.
    Например:</para>

  <programlisting>
#
# Высокоскоростной многопортовый коммуникационный адаптер - 16550 UARTS
#
device sio2 at isa? port 0x2a0 tty irq 5 flags 0x501 vector siointr
device sio3 at isa? port 0x2a8 tty flags 0x501 vector siointr
device sio4 at isa? port 0x2b0 tty flags 0x501 vector siointr
device sio5 at isa? port 0x2b8 tty flags 0x501 vector siointr
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="generic-kernel-build-failure">
    <para>Не удаётся откомпилировать ни один вариант ядра, даже
      GENERIC.</para>
  </question>

  <answer>

  <para>Есть несколько причин, приводящих к возникновению этой проблемы.  Вот
    они, в случайном порядке:</para>

  <itemizedlist>
    <listitem>
      <para>Вы не используете новые цели <command>make buildkernel</command>
        и <command>make installkernel</command>, и ваше дерево исходных
        текстов отличается от того, которое использовалось для построения
        работающей в данный момент системы (например, вы выполняете
        построение 4.2-RELEASE на системе 4.0-RELEASE).  Если вы пытаетесь
        выполнить обновление, то, пожалуйста, прочитайте файл
        <filename>/usr/src/UPDATING</filename>, обратив особое внимание на
        раздел <quote>COMMON ITEMS</quote> в его конце.</para>
    </listitem>

    <listitem>
      <para>Вы используете новые цели <command>make buildkernel</command> и
        <command>make installkernel</command>, но выполнение цели
        <command>make buildworld</command> не было завершено.  Полное и
        корректное выполнение цели <command>make buildkernel</command>
        зависит от файлов, генерирующихся при выполнении цели
        <command>make buildworld</command>.</para>
    </listitem>

    <listitem>
      <para>Даже если вы пытаетесь построить <link
        linkend="stable">FreeBSD-STABLE</link>, возможно, что вы скачали
        дерево исходных текстов в момент, когда оно модифицировалось или
        было неработоспособно по другим причинам; абсолютно гарантируется
        построение только релизов, хотя в большинстве случаев <link
        linkend="stable">FreeBSD-STABLE</link> строится без проблем.  Если
        вы еще этого не сделали, попробуйте сгрузить дерево исходных текстов
        повторно и посмотреть, разрешилась ли проблема.  Попробуйте
        использовать другой сервер в случае, если есть проблемы с тем,
        который вы используете сейчас.</para>
    </listitem>
  </itemizedlist>

  </answer>
</qandaentry>

</qandaset>
</chapter>


<chapter id="admin">
<title>Системное администрирование</title>


<qandaset>
<qandaentry>
  <question id="startup-config-files">
    <para>Где расположены файлы конфигурации системы?</para>
  </question>

  <answer>

  <para>Для FreeBSD версий от 2.0.5R до 2.2.1R основным конфигурационным файлом
    является <filename>/etc/sysconfig</filename>.  Все параметры указываются
    здесь, а остальные конфигурационные файлы, такие, как
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc(8)">/etc/rc</ulink>
    и <filename>/etc/netstart</filename> просто его используют.</para>

  <para>Посмотрите файл <filename>/etc/sysconfig</filename> и измените значения
    переменных на соответствующие вашей системе.  В файле содержатся
    комментарии, описывающие смысл этих переменных и способ их задания.</para>

  <para>В системах выше 2.2.1 и в 3.0 файл <filename>/etc/sysconfig</filename>
    сменил название на говорящее само за себя <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)">rc.conf</ulink>,
    синтаксис описания переменных был несколько улучшен.
    <filename>/etc/netstart</filename> тоже был переименован в
    <filename>/etc/rc.network</filename>, так что все конфигурационные файлы
    теперь можно перенести одной командой <command><ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?cp(1)">cp</ulink>
    /usr/src/etc/rc* /etc</command>.</para>

  <para>А в системах версий 3.1 и выше <filename>/etc/rc.conf</filename> был
    перемещён в <filename>/etc/defaults/rc.conf</filename>. <emphasis>Не
    редактируйте этот файл!</emphasis>  Вместо этого, если в файле
    <filename>/etc/defaults/rc.conf</filename> имеется параметр, который вы
    хотите изменить, то вы должны скопировать строчку с ним в файл
    <filename>/etc/rc.conf</filename> и поменять его значение именно
    здесь.</para>

  <para>Например, если вы хотите запустить named, сервер DNS, включенный в
    поставку FreeBSD начиная с FreeBSD 3.1, всё, что вам нужно сделать, это:
    <screen>
&prompt.root; <userinput>echo named_enable="YES" &gt;&gt; /etc/rc.conf</userinput>
    </screen>
  </para>

  <para>Чтобы запустить местные сервисы во FreeBSD 3.1 и выше, поместите
    скрипты в каталог <filename>/usr/local/etc/rc.d</filename>.  У этих скриптов
    должен быть выставлен бит выполнимости, и их имена должны оканчиваться на
    .sh.  Во FreeBSD 3.0 и ранее, вы должны отредактировать файл
    <filename>/etc/rc.local</filename>.</para>

  <para>Файл <filename>/etc/rc.serial</filename> предназначен для инициализации
    коммуникационных адаптеров (например, установки характеристик
    работы последовательных портов и тому подобное).</para>

  <para>Файл <filename>/etc/rc.i386</filename> предназначен для настройки
    специфичных для архитектуры Intel параметров, таких, как эмуляция iBCS2
    или характеристик системной консоли ПК.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="adding-users">
    <para>Как проще всего добавить пользователя?</para>
  </question>

  <answer>

  <para>Используйте команду <ulink 
    URL="http://www.FreeBSD.org/cgi/man.cgi?adduser">adduser</ulink>.
    Для выполнения более сложных операций обратитесь к команде <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?pw">pw</ulink>.</para>

  <para>Чтобы удалить пользователя, используйте команду <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?rmuser">rmuser</ulink>.  И,
    снова повторимся, команда <command>pw</command> тоже будет работать.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="adding-disks">
    <para>Как добавить в систему новый диск?</para>
  </question>

  <answer>

  <para>Обратитесь к Руководству по форматированию дисков на сервере <ulink
    URL="../../tutorials/formatting-media/">www.FreeBSD.org</ulink>.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="removable-drives">
    <para>Как использовать устройство для чтения сменных дисков?</para>
  </question><answer>

  <para>Каким бы ни было это устройство, типа ZIP, EZ (или даже обычным
    дисководом, если вы хотите его использовать) или каким-то
    другим, как только оно будет установлено и распознано
    системой, и вы вставите в него картридж/дискету/что-там-ещё, всё
    будет выглядеть примерно одинаково.</para>

  <para><anchor id="disklabel">(этот раздел опирается на <ulink
    URL="http://www.vmunix.com/mark/FreeBSD/ZIP-FAQ.html">
    FAQ по устройствам ZIP</ulink> Марка Мэйо (Mark Mayo))</para>

  <para>Если это устройство ZIP или обычный дисковод, и у вас уже есть
    файловая система DOS на дискетах, то вы можете использовать команду
    типа:</para>

  <screen>
&prompt.root; <userinput>mount -t msdos /dev/fd0c /floppy</userinput>
  </screen>

  <para>для обычных дискет, или</para>

  <screen>
&prompt.root; <userinput>mount -t msdos /dev/da2s4 /zip</userinput>
  </screen>

  <para>для дискет ZIP со стандартной конфигурацией.</para>
 
  <para>Для других дисков посмотрите их параметры с помощью команды
    <command>fdisk</command> или <filename>/stand/sysinstall</filename>.</para>
 
  <para>Остальные примеры даны для привода ZIP на da2, третьем диске
    SCSI.</para>

  <para>Если это дискета или сменный диск, который будет использоваться для
    обмена информацией с другими людьми, хорошей идеей будет помещение туда
    файловой системы BSD.  Вы получите поддержку длинных имён файлов,
    увеличение производительности по крайней мере в два раза и гораздо
    большую надёжность.  Первым делом вам снова будет нужно выполнить
    разбиение диска на разделы/файловые системы.  Вы можете воспользоваться
    утилитой <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?fdisk">fdisk</ulink> либо
    <filename>/stand/sysinstall</filename>, а в случае небольшого диска, на
    котором не нужно располагать несколько операционных систем, просто сотрите
    таблицу разделов (слайсов) FAT и используйте разбиение на разделы
    BSD.</para>

  <screen>
&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda2 count=2</userinput>
&prompt.root; <userinput>disklabel -Brw da2 auto</userinput>
  </screen>

  <para>Вы можете использовать disklabel или
    <filename>/stand/sysinstall</filename> для создания нескольких разделов
    BSD.  Вам наверняка придётся это сделать, если вы станете добавлять место
    для раздела подкачки на винчестере, хотя это не имеет отношения к
    устройствам типа ZIP.</para>

  <para>В итоге вы должны создать новую файловую систему (в этом примере
    она занимает весь наш диск ZIP):</para>

  <screen>
&prompt.root; <userinput>newfs /dev/rda2c</userinput>
  </screen>

  <para>и смонтировать её:</para>

  <screen>
&prompt.root; <userinput>mount /dev/da2c /zip</userinput>
  </screen>

  <para>Хорошо ещё добавить строку типа следующей в файл
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?fstab">/etc/fstab</ulink>,
    чтобы в будущем можно было просто давать команду
    <command>mount /zip</command>:</para>

  <programlisting>
/dev/da2c /zip ffs rw,noauto 0 0
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="root-not-found-cron-errors">
    <para>Почему после редактирования моего файла crontab я получаю сообщения
      вида <errorname>root: not found</errorname>?</para>
  </question>

  <answer>

  <para>Обычно это случается при редактировании системного crontab-файла
    (<filename>/etc/crontab</filename>) и последующего использования утилиты
    &man.crontab.1; для его установки:</para>

  <screen>&prompt.root; <userinput>crontab /etc/crontab</userinput></screen>

  <para>Это неправильно.  Системный crontab-файл имеет формат, отличный от
    пользовательских crontab-файлов, которые обновляет утилита
    &man.crontab.1; (страница Справочника по &man.crontab.5; описывает
    отличия более подробно).</para>

  <para>Если вы сделали именно это, то нужно удалить файл
    <filename>/var/cron/tabs/root</filename>, так как он будет являться
    просто копией <filename>/etc/crontab</filename>, но неправильного формата.
    В следующий раз при редактировании <filename>/etc/crontab</filename>
    вам не нужно ничего делать для извещения утилиты &man.cron.8; о сделанных
    изменениях, так как она заметит изменения автоматически.</para>

  <para>Реальная причина ошибки заключается в том, что системный crontab-файл
    имеет дополнительное поле, указывающее, какой пользователь запускает
    команду.  В системном crontab-файле, поставляемом с FreeBSD и используемом
    по умолчанию, это пользователь <username>root</username> для всех
    строк.  Если этот crontab-файл используется в качестве crontab-файла
    пользователя <username>root</username> (что <emphasis>не то же
    самое</emphasis>, что системный crontab-файл), &man.cron.8; полагает,
    что слово <literal>root</literal> является первым в команде на выполнение,
    но такой команды не существует.</para>

  </answer>
</qandaentry>

<qandaentry>
  <question id="rcconf-readonly">
    <para>Я сделал ошибку в файле <filename>rc.conf</filename> или в каком-то
      другом файле начальной загрузки, и теперь не могу его отредактировать
      из-за того, что файловая система находится в режиме только для чтения.
      Что мне делать?</para>
  </question>

  <answer>

  <para>При получении приглашения на ввод полного пути до командного
    процессора, просто нажмите <literal>ENTER</literal>, а затем выполните
    команду <command>mount /</command> для повторного монтирования корневой
    файловой системы в режиме чтения/записи.  Вам может также потребоваться
    выполнить команду <command>mount -a -t ufs</command> для монтирования
    файловой системы, в которой расположен ваш любимый редактор.  Если
    редактор расположен на сетевой файловой системе, то вам потребуется
    выполнить сетевые настройки вручную до монтирования сетевой файловой
    системы, либо воспользоваться редактором, находящимся в локальной файловой
    системе, таким, как &man.ed.1;.</para>

  <para>Если вы собираетесь использовать полноэкранный редактор, такой, как
    &man.vi.1; или &man.emacs.1;, то вам нужно будет выполнить команду
    <command>export TERM=cons25</command>, чтобы такие редакторы смогли
    корректно взять данные из базы данных &man.termcap.5;.</para>

  <para>После выполнения этих шагов вы сможете отредактировать файл
    <filename>/etc/rc.conf</filename> так, как вы это обычно делаете для
    исправления ошибки.  Сообщение об ошибке, выводимое сразу же после
    сообщений при загрузке ядра, должно указать вам на номер строки в файле,
    которая содержит ошибку.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="mount-dos">
    <para>Как смонтировать вторичный раздел DOS?</para>
  </question>

  <answer>

  <para>Вторичные разделы DOS находятся после ВСЕХ первичных разделов.
    Например, если раздел <quote>E</quote> является вторым разделом DOS на
    втором диске SCSI, вам нужно создать специальные файлы для пятого
    <quote>слайса</quote> в каталоге /dev, затем смонтировать /dev/da1s5:</para>

  <screen>
&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV da1s5</userinput>
&prompt.root; <userinput>mount -t msdos /dev/da1s5 /dos/e</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="mount-foreign-fs">
    <para>Можно ли смонтировать другие файловые системы?</para>
  </question>

  <answer>

  <para>Компакт-диски с файловой системой UFS от 
    <emphasis remap=bf>Digital UNIX</emphasis> могут быть замонтированы без
    всяких проблем.  Монтирование файловых систем Digital UNIX или других
    систем, поддерживающих UFS, может быть более сложным, в зависимости от
    особенностей разбиения диска конкретной операционной системой.</para>

  <para><emphasis remap=bf> Linux</emphasis>: Версии 2.2 и выше имеют поддержку
    разделов <emphasis remap=bf>ext2fs</emphasis>.
    За дополнительной информацией обратитесь к страницам справочника по
    команде <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?mount_ext2fs">
    mount_ext2fs</ulink>.</para>

  <para><emphasis remap=bf> NT</emphasis>: Существует драйвер, позволяющий под
    FreeBSD иметь доступ к NTFS в режиме "только для чтения".  Посмотрите
    учебник от Марка Овенса (Mark Ovens) по адресу <ulink
    URL="http://ukug.uk.freebsd.org/~mark/ntfs_install.html">
    http://ukug.uk.freebsd.org/~mark/ntfs_install.html</ulink>.</para>

  <para>Нас интересует любая дополнительная информация по этому вопросу.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="nt-bootloader">
    <para>Как можно использовать загрузчик NT для запуска FreeBSD?</para>
  </question>

  <answer>

  <para>Эта процедура выглядит по разному для версий FreeBSD 2.2.x и 3.x (с
    трёхступенчатым процессом загрузки системы).</para>

  <para>Идея заключается в копировании первого сектора корневого раздела
    FreeBSD в файл, находящийся в разделе DOS/NT.  Предположим, что вы назвали
    этот файл <filename>c:\bootsect.bsd</filename> (по аналогии с
    <filename>c:\bootsect.dos</filename>), после чего можете отредактировать
    файл <filename>c:\boot.ini</filename>, чтобы он выглядел примерно
    так:</para>

  <programlisting>
[boot loader]
timeout=30
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Windows NT"
C:\BOOTSECT.BSD="FreeBSD"
C:\="DOS"
  </programlisting>

  <para>Для систем 2.2.x предполагается, что DOS, NT, FreeBSD или другая
    операционная система были установлены в их соответствующие разделы fdisk на
    <emphasis remap=bf>одном и том же</emphasis> диске.  В моём случае DOS &amp;
    NT находятся на первом разделе fdisk, а FreeBSD на втором.  Я также
    установил FreeBSD для загрузки с её раздела, а
    <emphasis remap=bf>не</emphasis> из MBR.</para>

  <para>Смонтируйте дискету в формате DOS (если вы используете NTFS) или
    раздел FAT, скажем, в каталог <filename>/mnt</filename>.</para>

  <screen>
&prompt.root; <userinput>dd if=/dev/rda0a of=/mnt/bootsect.bsd bs=512 count=1</userinput>
  </screen>

  <para>Перезапустите DOS или NT.  Пользователи NTFS должны скопировать файл
    <filename>bootsect.bsd</filename> и/или <filename>bootsect.lnx</filename>
    с дискеты на диск <filename>C:\</filename>.  Измените атрибуты
    (права) на файл <filename>boot.ini</filename> следующим образом:</para>

  <screen>
<prompt>C:\&gt;</prompt> <userinput>attrib -s -r c:\boot.ini</userinput>
  </screen>

  <para>Отредактируйте этот файл, добавив соответствующие строки из примерного
    <filename>boot.ini</filename> выше, и восстановите атрибуты:</para>

  <screen>
<prompt>C:\&gt;</prompt> <userinput>attrib +s +r c:\boot.ini</userinput>
  </screen>

  <para>Если FreeBSD загружается из MBR, восстановите его командой DOS
    <command>fdisk</command> после того, как переконфигурировали их для
    загрузки с их <quote>родных</quote> разделов.</para>

  <para>Для систем FreeBSD 3.x эта процедура выглядит несколько проще.</para>

  <para>Если FreeBSD установлена на тот же самый диск, что и загрузочный раздел
    NT, просто скопируйте <filename>/boot/boot1</filename> в
    <filename>C:\BOOTSECT.BSD</filename>.  Однако, если FreeBSD установлена на
    другой диск, то <filename>/boot/boot1</filename> работать не будет, нужно
    копировать <filename>/boot/boot0</filename>.

    <warning>
      <para>НЕ КОПИРУЙТЕ ПРОСТО <filename>/boot/boot0</filename> ВМЕСТО
        <filename>/boot/boot1</filename>, ЭТИМ ВЫ ПЕРЕЗАПИШЕТЕ ТАБЛИЦУ РАЗДЕЛОВ
        ВИНЧЕСТЕРА И ВАШ КОМПЬЮТЕР ПЕРЕСТАНЕТ ЗАГРУЖАТЬСЯ!</para>
    </warning>

    <filename>/boot/boot0</filename> нужно устанавливать с помощью sysinstall,
    выбрав менеджер загрузки FreeBSD в диалоговом окне при выборе менеджера
    загрузки.  Это потому что в <filename>/boot/boot0</filename> область
    таблицы разделов заполнена символами NULL, а sysinstall копирует сюда
    таблицу разделов перед тем, как скопировать <filename>/boot/boot0</filename>
    в область MBR.</para>

  <para>При запуске менеджер загрузки FreeBSD задаёт ОС, которая загружалась
    последний раз, устанавливая для этой операционной системы признак
    активизации в таблице разделов, а затем записывает 512 байт самого
    себя обратно в MBR, так что если вы просто скопируете
    <filename>/boot/boot0</filename> в <filename>C:\BOOTSECT.BSD</filename>,
    то в MBR будет записана пустая таблица разделов с флагом активности в
    некотором месте.</para>

 </answer>
</qandaentry>


<qandaentry>
  <question id="lilo-bootloader">
    <para>Как загрузить FreeBSD и Linux с помощью LILO?</para>
  </question>

  <answer>

  <para>Если у вас установлены FreeBSD и Linux на одном и том же диске,
    следуйте указаниям по установке LILO о загрузке не-Linux операционных
    систем.  Они сводятся к следующему:</para>

  <para>Загрузите Linux, и добавьте следующие строки в файл
    <filename>/etc/lilo.conf</filename>:

  <programlisting>
other=/dev/hda2
table=/dev/hda
label=FreeBSD
  </programlisting>

  (здесь вы предполагаем, что слайс с FreeBSD известен Linux как
  <filename>/dev/hda2</filename>; измените эту строку в соответствии с вашей 
  конфигурацией).  Затем достаточно будет запустить <command>lilo</command>,
  войдя в систему как администратор.</para>
 
  <para>Если FreeBSD располагается на другом диске, вам нужно добавить строчку
    <literal>loader=/boot/chain.b</literal> в конфигурационный файл
    LILO.  Например:

    <programlisting>
other=/dev/dab4
table=/dev/dab
loader=/boot/chain.b
label=FreeBSD
    </programlisting>
  </para>
 
  <para>В некоторых случаях для успешной загрузки со второго диска вам
    может потребоваться указать номер диска BIOS загрузчику FreeBSD.
    Например, если диск SCSI с FreeBSD определяется BIOS как диск 1,
    в приглашении загрузчика FreeBSD нужно указать:</para>

  <screen>
Boot: <userinput>1:da(0,a)/kernel</userinput>
  </screen>

  <para>Во FreeBSD 2.2.5 и выше вы можете настроить <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?boot(8)">boot(8)</ulink>
    на автоматическое принятие таких параметров во время загрузки.</para>

  <para>В документе <ulink
    URL="http://sunsite.unc.edu/LDP/HOWTO/mini/Linux+FreeBSD.html">
    Linux+FreeBSD mini-HOWTO</ulink> содержится много информации,
    касающейся взаимодействия FreeBSD и Linux.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="booteasy-loader">
    <para>Как загрузить FreeBSD и Linux с помощью BootEasy?</para>
  </question>

  <answer>

  <para>Установите LILO в начало загрузочного раздела Linux, а не в
    Master Boot Record.  После этого можно запустить LILO из BootEasy.</para>

  <para>Это рекомендуется сделать в любом случае при одновременном
    использовании Windows-95 и Linux, чтобы упростить восстановление
    работоспособности Linux после переинсталляции Windows95 (которая
    является Недоброжелательной Операционной Системой и не терпит
    присутствия других операционных систем в Master Boot Record).</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="dangerously-dedicated">
    <para>Не угрожает ли режим <quote>dangerously dedicated</quote> моему
      здоровью?</para>
  </question>

  <answer>

  <para><anchor id="dedicate">В процессе установки вы можете выбрать два
    различных метода разбиения вашего диска.  По умолчанию это делается
    в режиме совместимости с другими операционными системами на этой же
    машине с использованием записей в таблице разделов fdisk (то, что
    называется <quote>слайсом</quote> во FreeBSD), со слайсом (разделом),
    выделенным FreeBSD.  Опционально, вы можете выбрать установку менеджера
    загрузки для переключения между операционными системами.  Либо вы
    можете выделить диск полностью под FreeBSD, не заботясь о совместимости
    с другими операционными системами.</para>

  <para>Почему же этот режим называется <quote>dangerous</quote>? Дело в том,
    что диск в этом режиме не будет содержать того, что обычные утилиты для
    ПК распознают как таблицу разделов.  В зависимости от того, насколько
    хорошо они написаны, они могут сообщить вам об этом, как только
    обнаружат такой диск, или, что гораздо хуже, могут запортить загрузчик
    BSD, даже не спрашивая и не сообщая об этом.  К тому же известно, что
    разметка диска в режиме <quote>dangerously dedicated</quote> вводит в
    заблуждение BIOS многих производителей, включая AWARD (которые используются
    в компьютерах HP Netserver, Micronics и многих других) и Symbios/NCR
    (производителя популярных SCSI-контроллеров серии 53C8xx).  И это не
    полный список, есть ещё другие производители.  Симптомами подобных
    проблем является сообщение <quote>read error</quote>, выводимое загрузчиком
    FreeBSD, когда он не может найти сам себя, а также зависания системы при
    загрузке.</para>

  <para>Тогда зачем вообще нужен этот режим?  Он экономит всего лишь
    несколько килобайт дискового пространства и может вызвать серьёзные 
    проблемы при новой инсталляции.  Причиной появления этого режима
    является желание избежать появления одной из самых распространённых
    проблем, с которой сталкиваются новички - соответствие параметров
    BIOS и реальных параметров диска.</para>

  <para><quote>Параметры</quote> диска являются устаревшей концепцией, но она
    лежит в основе работы BIOS с диском.  Когда программа установки FreeBSD
    создаёт слайсы, она записывает их расположение в соответствии с тем,
    как с ними будет работать BIOS.  Если это делается неправильно, вы не
    сможете выполнить загрузку системы.</para>

  <para>Режим <quote>dangerously dedicated</quote> пытается обойти это, упрощая
    решение данной проблемы.  Иногда он делает это правильно.  Однако это
    значит, что его нужно использовать только как последнюю альтернативу - есть
    способы получше, решающие проблему в 99 случаях из 100.</para>

  <para>Итак, как избежать использования режима <quote>DD</quote> во время
    установки?  Сначала запишите параметры диска, которые сообщает BIOS.  Вы
    можете выяснить это, заставив ядро вывести эти параметры при загрузке,
    указав <option>-v</option> в приглашении <literal>boot:</literal>, или
    используя <command>boot -v</command> в загрузчике.  Перед тем, как
    запустится программа установки, ядро выведет параметры, используемые BIOS.
    Не волнуйтесь - подождите запуска программы
    установки, а затем воспользуйтесь скроллингом, чтобы посмотреть
    значения этих параметров.  Как правило, BIOS нумерует диски в том же
    порядке, что и FreeBSD, сначала IDE, затем SCSI.</para>

  <para>Когда вы разбиваете диск на слайсы, проверьте, что параметры диска,
    выводимые в окне программы FDISK, корректны (то есть они соответствуют
    параметрам BIOS); если это не так, воспользуйтесь командой
    <literal>g</literal>, чтобы их исправить.  Вы можете это сделать, если на
    диске нет абсолютно ничего или если этот диск был перенесён с другой
    системы.  Заметьте, что это касается только загрузочного диска; FreeBSD
    прекрасно разберётся с остальными дисками, которые могут у вас быть.</para>

  <para>Как только вы добились соответствия параметров диска в BIOS и
    FreeBSD, скорее всего, проблем у вас больше не будет, и использовать
    режим <quote>DD</quote> не потребуется.  Если, однако, страшной сообщение
    <quote>read error</quote> продолжает появляться при загрузке, самое время
    перекреститься и попробовать этот режим - терять вам больше нечего.</para>

  <para>Чтобы вернуть диск из режима <quote>dangerously dedicated</quote> к
    нормальному режиму использования, есть два способа. Первый заключается
    в том, что вы записываете достаточное количество байтов NULL поверх
    MBR, чтобы любой инсталлятор думал, что это чистый диск. Это можно
    сделать, например, командой</para>

  <screen>
&prompt.root; <userinput>dd if=/dev/zero of=/dev/rda0 count=15</userinput>
  </screen>

  <para>Другой способ - недокументированной командой DOS</para>

  <screen>
<prompt>C:\&gt;</prompt> <userinput>fdisk /mbr</userinput>
  </screen>

  <para>проинсталлировать новую MBR, удалив загрузчик BSD.</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="add-swap-space">
    <para>Как добавить дополнительную виртуальную память?</para>
  </question>

  <answer>

  <para>Наилучший способ - увеличить размер раздела подкачки, может быть,
    добавив для этого ещё один диск.  Общим правилом является выбор
    размера виртуальной памяти, в два раза превышающий объём физической
    памяти.  Однако, если у вас очень мало физической памяти, этот объём
    гораздо больше.  Хорошей практикой является задание достаточного
    объёма виртуальной памяти в ожидании добавления физической памяти,
    чтобы потом не испытывать трудностей.</para>

  <para>Перенос виртуальной памяти на отдельный диск увеличивает
    быстродействие системы по сравнению с добавлением виртуальной памяти
    на том же диске.  Например, компиляция исходных текстов происходит
    быстрее, если они находятся не на том же диске, что и раздел подкачки.
    Особенно это заметно для дисков SCSI.</para>

  <para>Если у вас имеется несколько дисков, размещение раздела подкачки
    на каждом из них, даже на рабочем диске, обычно бывает полезно.
    Как правило, каждый быстрый диск в вашей системе должен иметь раздел
    подкачки.  FreeBSD поддерживает по умолчанию до 4 устройств подкачки с
    чередованием.  При задании нескольких разделов подкачки вам захочется
    сделать их одинакового размера, однако иногда первичный раздел подкачки
    делается несколько больше для того, чтобы он мог поместить аварийный
    образ ядра.  Размер вашего первичного раздела подкачки должен по крайней 
    мере быть равным объёму физической памяти, чтобы поместить аварийный
    образ ядра.</para>

  <para>Диски IDE не позволяют реализовать одновременный доступ к обоим дискам
    по одному каналу (FreeBSD не поддерживает режим 4, так что весь ввод/вывод
    для дисков IDE <quote>программируется</quote>).  Однако я всё
    равно советую перенести раздел подкачки на отдельный диск.  Диски
    достаточно дешёвы, и экономить тут не на чем.</para>

  <para>Использование NFS для размещения раздела подкачки рекомендуется
    только в случае, если у вас нет локального диска.  Подкачка поверх
    NFS медленна и неэффективна в релизах FreeBSD до 4.x, хотя достаточно
    быстра в релизах 4.0 и выше.  Кроме того, её скорость будет ограничена
    реальной пропускной способностью сети и это даст дополнительную нагрузку
    на NFS-сервер.</para>

  <para>Вот пример vn-файла подкачки размером 64Мб
    (<filename>/usr/swap0</filename>, хотя, конечно, вы можете выбрать любое
    другое имя.</para>

  <para>Удостоверьтесь, что ядро откомпилировано со строкой</para>

  <programlisting>
pseudo-device   vn 1   #Vnode driver (turns a file into a device)
  </programlisting>

  <para>в конфигурационном файле.  Ядро GENERIC её содержит</para>

  <para>     
    <orderedlist>
      <listitem>
        <para>создайте vn-устройство</para>

        <screen>
&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput>
        </screen>
      </listitem>

      <listitem>
        <para>создайте файл подкачки (<filename>/usr/swap0</filename>)</para>

        <screen>
&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput>
        </screen>
      </listitem>

      <listitem>
        <para>Установите корректные права на файл
          (<filename>/usr/swap0</filename>)</para>

        <screen>
&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput>
        </screen>
      </listitem>

      <listitem>
        <para>Включите использование файла подкачки в
          <filename>/etc/rc.conf</filename></para>

        <programlisting>
swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
        </programlisting>
      </listitem>

      <listitem>
        <para>перезагрузите машину</para>
      </listitem>
    </orderedlist>
  </para>

  <para>Чтобы включить использование файла подкачки немедленно, наберите</para>

  <screen>
&prompt.root; <userinput>vnconfig -ce /dev/vn0c /usr/swap0 swap</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="printer-setup">
    <para>У меня проблемы с установкой принтера.</para>
  </question>

  <answer>

  <para>Обратитесь к соответствующему <ulink
    URL="../../handbook/printing.html">разделу</ulink> Руководства,
    посвящённому печати.  В нём описаны решения большинства ваших
    проблем.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="keyboard-mappings">
    <para>Раскладка клавиатуры неверна.</para>
  </question>

  <answer>

  <para>Программа kbdcontrol имеет параметр, задающий файл раскладки.
    Файлы раскладок находятся в каталоге
    <filename>/usr/share/syscons/keymaps</filename>.  Выберите соответствующий
    вашей системе и загрузите его.</para>

  <screen>
&prompt.root; <userinput>kbdcontrol -l uk.iso</userinput>
  </screen>

  <para>Программа <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?kbdcontrol">kbdcontrol</ulink>
    предполагает использование каталога
    <filename>/usr/share/syscons/keymaps</filename>
    и расширения <filename>.kbd</filename>.</para>
 
  <para>Это может быть настроено в файле <filename>/etc/sysconfig</filename>
    (или <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf(5)">rc.conf</ulink>).
    Обратитесь к соответствующим комментариям в этом файле.</para>

  <para>В системах 2.0.5R и выше, всё, относящееся к знакогенератору,
    раскладке клавиатуры, находится в каталоге
    <filename>/usr/share/examples/syscons</filename>.</para>

  <para>На данный момент поддерживаются следующие раскладки:</para>
  
  <para>     
    <itemizedlist>
      <listitem>
        <para>Belgian ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>Brazilian 275 keyboard Codepage 850</para>
      </listitem>

      <listitem>
        <para>Brazilian 275 keyboard ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>Danish Codepage 865</para>
      </listitem>

      <listitem>
        <para>Danish ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>French ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>German Codepage 850</para>
      </listitem>

      <listitem>
        <para>German ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>Italian ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>Japanese 106</para>
      </listitem>

      <listitem>
        <para>Japanese 106x</para>
      </listitem>

      <listitem>
        <para>Latin American</para>
      </listitem>

      <listitem>
        <para>Norwegian ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>Polish ISO-8859-2 (programmer's)</para>
      </listitem>

      <listitem>
        <para>Russian Codepage 866 (alternative)</para>
      </listitem>

      <listitem>
        <para>Russian koi8-r (shift)</para>
      </listitem>

      <listitem>
        <para>Russian koi8-r</para>
      </listitem>

      <listitem>
        <para>Spanish ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>Swedish Codepage 850</para>
      </listitem>

      <listitem>
        <para>Swedish ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>Swiss-German ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>United Kingdom Codepage 850</para>
      </listitem>

      <listitem>
        <para>United Kingdom ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>United States of America ISO-8859-1</para>
      </listitem>

      <listitem>
        <para>United States of America dvorak</para>
      </listitem>

      <listitem>
        <para>United States of America dvorakx</para>
      </listitem>
    </itemizedlist>
  </para>

  </answer>
</qandaentry>

<qandaentry>
  <question id="pnp-resources">
    <para>У меня при загрузке появляются сообщения вида
    <errorname>unknown: &lt;PNP0303&gt; can't assign resources</errorname>
    </para>
  </question>

  <answer>
    <para>Они показывают, что у вас присутствуют устройства поддержка,
    которых отсутствует в текущем ядре. Они абсолютно
    безвредны.</para>

    <para>Если эти сообщения вам не нравятся, Проект FreeBSD с удовольствием
    добавит написанный вами драйвер.</para>
  </answer>
</qandaentry>

<qandaentry>
  <question id="user-quotas">
    <para>Не получается заставить работать дисковые квоты.</para>
  </question>

  <answer>

  <para>     
    <orderedlist>
      <listitem>
        <para>Не включайте квотирование на <filename>/</filename>,</para>
      </listitem>

      <listitem>
        <para>Помещайте файл с квотами в ту файловую систему, которую
          он обслуживает, то есть:</para>

        <informaltable frame="none">
        <tgroup cols="2">
        <thead>
          <row>
            <entry>Файловая система</entry>
            <entry>Файл квот</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><filename>/usr</filename></entry>
            <entry><filename>/usr/admin/quotas</filename></entry>
          </row>

          <row>
            <entry><filename>/home</filename></entry>
            <entry><filename>/home/admin/quotas</filename></entry>
          </row>

          <row>
            <entry>&hellip;</entry>
            <entry>&hellip;</entry>
          </row>
        </tbody>
        </tgroup>
        </informaltable>
      </listitem>
    </orderedlist>
  </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="inappropriate-ccd">
    <para>Что не так с устройством ccd?</para>
  </question>

  <answer>

  <para>Симптом выглядит так:</para>
  
  <screen>
&prompt.root; <userinput>ccdconfig -C</userinput>
ccdconfig: ioctl (CCDIOCSET): /dev/ccd0c: Inappropriate file type or format
  </screen>

  <para>Это сообщение обычно выдаётся, когда вы пытаетесь объединить разделы
    <literal>c</literal>, по умолчанию имеющие тип <literal>unused</literal>.
    Драйвер ccd требует, чтобы используемые разделы имели тип FS_BSDFFS.
    Отредактируйте метки тех дисков, которые вы хотите использовать, сменив
    типы разделов на <literal>4.2BSD</literal>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ccd-disklabel">
    <para>Почему невозможно отредактировать метку диска ccd?</para>
  </question>

  <answer>

  <para>Симптом выглядит так:</para>

  <screen>
&prompt.root; <userinput>disklabel ccd0</userinput>
(здесь выводится информация о диске, пробуем отредактировать метку)
&prompt.root; <userinput>disklabel -e ccd0</userinput>
(редактирование, сохранение, выход)
disklabel: ioctl DIOCWDINFO: No disk label on disk;
use "disklabel -r" to install initial label
  </screen>

  <para>Это происходит из-за того, что метка диска, возвращаемая ccd, на
    самом деле <quote>ненастоящая</quote>, не соответствующая реально
    располагающейся на диске.  Вы можете решить эту проблему, явно записав эту
    метку обратно следующим образом:</para>

  <screen>
&prompt.root; <userinput>disklabel ccd0 &gt; /tmp/disklabel.tmp</userinput>
&prompt.root; <userinput>disklabel -Rr ccd0 /tmp/disklabel.tmp</userinput>
&prompt.root; <userinput>disklabel -e ccd0</userinput>
(теперь это будет работать)
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="sysv-ipc">
    <para>Поддерживает ли FreeBSD вызовы IPC из System V?</para>
  </question>

  <answer>

  <para>Да, FreeBSD поддерживает IPC из System V, а именно совместно
    используемую память, сообщения и семафоры.  Чтобы они работали, вам
    нужно добавить следующие строки в файл конфигурации ядра.</para>

  <programlisting>
options    SYSVSHM
options    SYSVSHM          # enable shared memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging
  </programlisting>

  <para>
    <note>
      <para>Во FreeBSD 3.2 и выше эти параметры уже включены в ядро
        <emphasis>GENERIC</emphasis>, что уже означает их присутствие в вашей
        системе.</para>
    </note>
  </para>

  <para>Перекомпилируйте и проинсталлируйте ядро.</para>
  
  </answer>
</qandaentry>


<qandaentry>
  <question id="uucpmail">
    <para>Как настроить sendmail для доставки почты по UUCP?</para>
  </question>

  <answer>

  <para>Конфигурация sendmail, поставляемая с FreeBSD, предназначена для
    сайтов, которые имеют непосредственный выход в Internet.  Сайты,
    которым требуется обмениваться почтой по UUCP, должны использовать
    другой конфигурационный файл.</para>

  <para>Ковыряние в файле <filename>/etc/sendmail.cf</filename> вручную - это
    занятие для пуристов (и мазохистов).  Восьмая версия sendmail поставляется
    с новой системой генерации конфигурационных файлов с использованием
    препроцессора <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?m4">m4</ulink>,
    в которой ручная настройка перенесена на более высокий уровень абстракции.
    Используйте конфигурационные файлы в каталоге
    <filename>/usr/src/usr.sbin/sendmail/cf</filename>.</para>

  <para>Если вы не собираетесь инсталлировать все исходные тексты системы,
    специально для вас конфигурационные файлы sendmail выделены в отдельный
    дистрибутив.  Если вы имеете смонтированный компакт-диск, выполните
    такую команду:</para>

  <screen>
&prompt.root; <userinput>cd /cdrom/src</userinput>
&prompt.root; <userinput>cat scontrib.?? | tar xzf - -C /usr/src contrib/sendmail</userinput>
  </screen>
 
  <para>Не волнуйтесь, эти файлы занимают всего лишь несколько сотен килобайт.
    Файл <filename>README</filename> в каталоге <filename>cf</filename> может
    быть использован как начальное введение в конфигурацию m4.</para>
 
  <para>Для доставки почты по UUCP лучше всего использовать
    <literal>mailertable</literal>.  В этом файле содержится база данных,
    используемая sendmail при маршрутизации почты.</para>

  <para>Первым делом создайте ваш файл <filename>.mc</filename>.  Для таких
    файлов предназначен каталог
    <filename>/usr/src/usr.sbin/sendmail/cf/cf</filename>.
    Посмотрите в нём, там есть уже несколько примеров.  Положим, что вы назвали
    ваш файл <filename>foo.mc</filename>, всё, что вам нужно для преобразования
    его в нормальный <filename>sendmail.cf</filename>, это:</para>

  <screen>
&prompt.root; <userinput>cd /usr/src/usr.sbin/sendmail/cf/cf</userinput>
&prompt.root; <userinput>make foo.cf</userinput>
&prompt.root; <userinput>cp foo.cf /etc/sendmail.cf</userinput>
  </screen>
 
  <para>Типичный файл <filename>.mc</filename> выглядит примерно так:</para>

  <programlisting>
include(`../m4/cf.m4')
VERSIONID(`<replaceable>Your version number</replaceable>')
OSTYPE(bsd4.4)

FEATURE(nodns)
FEATURE(nocanonify)
FEATURE(mailertable)

define(`UUCP_RELAY', <replaceable>your.uucp.relay</replaceable>)
define(`UUCP_MAX_SIZE', 200000)

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    <replaceable>your.alias.host.name</replaceable>
Cw    <replaceable>youruucpnodename.UUCP</replaceable>
  </programlisting>
 
  <para>Параметры <literal>nodns</literal> и <literal>nocanonify</literal>
    подавляют использование DNS в процессе доставки.  Строка
    <literal>UUCP_RELAY</literal> может понадобиться только в очень странных
    случаях, не спрашивайте о них.  Просто поместите здесь имя хоста Internet,
    который может обрабатывать адреса с псевдо-доменами .UUCP; в
    большинстве случаев достаточно поставить сюда имя почтового шлюза
    вашего провайдера.</para>
 
  <para>Как только вы сгенерируете конфигурационный файл, вам понадобится
    <filename>/etc/mailertable</filename>.  Типичный пример такого файла:</para>

  <programlisting>
#
# makemap hash /etc/mailertable.db &lt; /etc/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:
  </programlisting>
 
  <para>Как видите, это часть реально существующего файла.  Первые три строки
    описывают особые случаи, когда почта, направленная на некоторые домены,
    будет посылаться не по стандартному маршруту, а на некоторую близлежащую
    UUCP-систему для <quote>сокращения</quote> маршрута доставки.  Следующая
    строка описывает,
    что почта на локальный домен в сети Ethernet может быть доставлена по SMTP.
    В конце файла описаны близлежащие системы UUCP в псевдо-домене .UUCP, что
    позволит выполнять правильную доставку почты на адреса
    <literal><replaceable>uucp-система</replaceable>!<replaceable>получатель</replaceable></literal>.
    В последней строке всегда присутствует одна точка, соответствующая всем
    остальным доменам, с доставкой по UUCP на
    ближнюю систему UUCP, который является универсальный почтовым шлюзом во весь
    остальной мир.  Все имена узлов после <literal>uucp-dom:</literal>
    должны быть реально существующими узлами UUCP, что можно проверить
    командой <literal>uuname</literal>.</para>
 
  <para>Как напоминание о том, что этот файл должен быть преобразован в формат
    базы данных DBM перед использованием, командная строка, выполняющая это
    действие, помещена как комментарий в начало файла.  При изменении
    mailertable всегда нужно выполнять эту команду.</para>

  <para>Последняя подсказка: если вы не уверены в правильности настройки
    маршрутизации почты, используйте sendmail с опцией <option>-bt</option>.
    Она переводит sendmail в режим <emphasis>проверки адресов</emphasis>;
    введите <literal>0 </literal>, а затем адрес, который вы хотите
    протестировать на правильность маршрутизации.  В последней строке будут
    указаны используемый
    почтовый агент, хост получателя, с которым будет работать этот агент,
    и (может быть преобразованный) адрес.  Выход их этого режима
    осуществляется по Control-D.</para>

  <screen>
&prompt.user; <userinput>sendmail -bt</userinput>
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter &lt;ruleset&gt; &lt;address&gt;
<prompt>&gt;</prompt> <userinput>0 foo@interface-business.de</userinput>
rewrite: ruleset  0   input: foo @ interface-business . de
...
rewrite: ruleset  0 returns: $# uucp-dom $@ if-bus $: foo \
&lt; @ interface-business . de &gt;
<prompt>&gt;</prompt> <userinput>^D</userinput>
  </screen>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="ispmail">
    <para>Как настроить почту при коммутируемом соединении с Internet?</para>
  </question>

  <answer>

  <para>Если адрес IP вам выделен статически, то вам не нужно ничего
    менять.  Установите имя вашего хоста в соответствии с выделенным
    именем DNS, а sendmail сделает всё остальное.</para>

  <para>Если ваш IP-адрес выделяется динамически при коммутируемом соединении
    по протоколу <emphasis remap=bf>ppp</emphasis> с Internet, может быть, вам
    выделен почтовый ящик на сервере провайдера.  Предположим, что домен вашего
    провайдера называется <hostid role="domainname">myISP.com</hostid>, а ваше
    имя пользователя - <username>user</username>.  Также положим, что вы
    назвали вашу машину <hostid role="fqdn">bsd.home</hostid>, и что ваш
    провайдер сказал, что вы можете использовать <hostid
    role="fqdn">relay.myISP.com</hostid> в качестве почтового шлюза.</para>

  <para>Чтобы забирать почту из вашего почтового ящика, вам нужно установить
    соответствующий агент.  Хорошим агентом является программа
    <application>fetchmail</application>, так как она поддерживает много
    различных протоколов.  Обычно провайдеры предлагают POP3.  Если вы
    используете user-ppp, то можете автоматически забирать вашу почту при
    установлении соединения с Internet, добавив такую строку в файл
    <filename>/etc/ppp/ppp.linkup</filename>:</para>

  <programlisting>
MYADDR:
  !bg su user -c fetchmail
  </programlisting>

  <para>Если вы используете <application>sendmail</application> (как
    показано ниже) для доставки почты для внешних пользователей, поместите
    команду</para>

  <programlisting>
  !bg su user -c "sendmail -q"
  </programlisting>

  <para>после вышеуказанной строки.  Это заставит
    <application>sendmail</application> обработать вашу
    очередь почтовых сообщений, как только будет осуществлено подключение
    к сети.</para>

  <para>Предположим, что вы имеет учётную запись для <username>user</username>
    на машине <hostid role="fqdn">bsd.home</hostid>.  В домашнем каталоге
    пользователя <username>user</username> на машине <hostid
    role="fqdn">bsd.home</hostid> создайте файл
    <filename>.fetchmailrc</filename> такого содержания:</para>

  <programlisting>
poll myISP.com protocol pop3 fetchall pass MySecret
  </programlisting>

  <para>Излишним будет напоминание о том, что этот файл никому не должен
    быть доступен для чтения, кроме пользователя <username>user</username>,
    потому что он содержит пароль <literal>MySecret</literal> доступа к
    почтовому ящику.</para>
 
  <para>Чтобы посылать почту с правильным заголовком <literal>from:</literal>,
    вы должны указать программе <application>sendmail</application> использовать
    <literal>user@myISP.com</literal>, а не <literal>user@bsd.home</literal>.
    Вам может понадобиться настроить <application>sendmail</application> для
    посылки всей почты через <hostid role="fqdn">relay.myISP.com</hostid>,
    чтобы ускорить её передачу.</para>

  <para>Следующий файл <filename>.mc</filename> должен подойти:</para>

  <programlisting>
VERSIONID(`bsd.home.mc version 1.0')
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`myISP.com')dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST', `relay.myISP.com')
Dmbsd.home
define(`confDOMAIN_NAME',`bsd.home')dnl
define(`confDELIVERY_MODE',`deferred')dnl
  </programlisting>

  <para>В предыдущем разделе описано, как преобразовать файл
    <filename>.mc</filename> в <filename>sendmail.cf</filename>.  И не забудьте
    перезапустить <application>sendmail</application> после обновления файла
    <filename>sendmail.cf</filename>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="forgot-root-pw">
    <para>Ой! Я забыл пароль администратора!</para>
  </question>

  <answer>

  <para>Без паники!  Просто перезапустите систему, наберите <userinput>boot
    -s</userinput> в приглашении Boot: (или просто <userinput>-s</userinput> в
    случае использования версий FreeBSD до 3.2) для входа в однопользовательский
    режим.  На вопрос об используемой оболочке нажмите ENTER.  На приглашение
    &prompt.root; введите <command>mount -u /</command>, чтобы перемонтировать
    корневую файловую систему в режиме чтения/записи, после чего выполните
    команду <command>mount -a</command> для монтирования всех файловых систем.
    Запустите команду <command>passwd root</command>, чтобы сменить
    пароль администратора, а затем <command>exit</command> для
    продолжения процесса загрузки.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="CAD-reboot">
    <para>Как запретить перезагрузку по клавишам Control-Alt-Delete?</para>
  </question>

  <answer>

  <para>Если вы используете драйвер консоли syscons (который является
    стандартным) во FreeBSD 2.2.7-RELEASE и выше, перегенерируйте и установите
    новое ядро со строчкой</para>

  <programlisting>options SC_DISABLE_REBOOT</programlisting>

  <para>в конфигурационном файле.  Если же вы используете драйвер консоли PCVT
    во FreeBSD 2.2.5-RELEASE и выше, то укажите следующую строку в
    конфигурационном файле:</para>

  <programlisting>options PCVT_CTRL_ALT_DEL</programlisting>

  <para>Для более старых версий FreeBSD отредактируйте используемый для консоли
    файл раскладки клавиатуры, заменив ключевые слова <literal>boot</literal>
    на <literal>nop</literal>.  Используемая по умолчанию раскладка находится
    в файле <filename>/usr/share/syscons/keymaps/us.iso.kbd</filename>. Вам
    может потребоваться явно указать в файле <filename>/etc/rc.conf</filename>
    загрузку этой раскладки, чтобы она действительно поменялась.  Конечно,
    если в вашей стране вы используете другую раскладку, вы должны 
    отредактировать именно её.</para>
  
  </answer>
</qandaentry>


<qandaentry>
  <question id="dos-to-unix-txt">
    <para>Как преобразовать текстовые файлы DOS в формат UNIX?</para>
  </question>

  <answer>

  <para>Используйте такую команду:</para>
  
  <screen>
&prompt.user; <userinput>perl -i.bak -npe 's/\r\n/\n/g' file ...</userinput>
  </screen>

  <para>где file - это имя файла(ов) для преобразования.  Преобразование
    делается в том же самом файле, оригинальные файлы сохраняются с
    расширением .bak.</para>

  <para>Это преобразование также можно выполнить с помощью команды
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tr">tr</ulink>:</para>

  <screen>
&prompt.user; <userinput>tr -d '\r' &lt; <replaceable>dos-text-file</replaceable> &gt; <replaceable>unix-file</replaceable></userinput>
  </screen>

  <para>где <replaceable>dos-text-file</replaceable> - это имя файла,
    содержащего текст DOS, а в файл <replaceable>unix-file</replaceable> будет
    помещён уже преобразованный текст.  Этот способ может работать гораздо
    быстрее, чем при использовании perl.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="kill-by-name">
    <para>Как прервать процесс по имени?</para>
  </question>

  <answer>

  <para>Используйте команду <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?killall">killall</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="root-acl">
    <para>Почему su выдаёт сообщение о том, что я не вхожу в root ACL?</para>
  </question>

  <answer>

  <para>Эта ошибка выдаётся распределённой системой аутентификации Kerberos.
    Эта ошибка не фатальна, однако это раздражает.  Вы можете запустит su
    с ключом -K либо деинсталлировать Kerberos, как описано в следующем
    разделе.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="uninstall-kerberos">
    <para>Как деинсталлировать Kerberos?</para>
  </question>

  <answer>

  <para>Чтобы убрать Kerberos из системы, переинсталлируйте дистрибутив bin
    того релиза, который у вас запущен.  Если у вас есть CDROM, вы можете
    смонтировать компакт-диск (положим, в каталог /cdrom) и выполнить
    команду</para>

  <screen>
&prompt.root; <userinput>cd /cdrom/bin</userinput>
&prompt.root; <userinput>./install.sh</userinput>
  </screen>

  <para>Либо вы можете убрать все опции "MAKE_KERBEROS" из файла
    <filename>/etc/make.conf</filename> и выполнить полное перестроение
    системы.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="add-pty">
    <para>Как добавить в систему дополнительные псевдотерминалы?</para>
  </question>

  <answer>

  <para>Если у вас много пользователей, работающий в сеансах telnet, ssh, X
    или в screen, вам можете столкнуться с проблемой нехватки
    псевдотерминалов.  Их количество можно увеличить следующим образом:</para>

  <para>     
    <orderedlist>
      <listitem>
        <para>Откомпилируйте и инсталлируйте новое ядро, в конфигурационный
          файл которого входит такая строка:</para>

        <programlisting>
pseudo-device pty 256
        </programlisting>
      </listitem>

      <listitem>
        <para>Выполните следующие команды:</para>

        <screen>
&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV pty{1,2,3,4,5,6,7}</userinput>
        </screen>

        <para>для создания 256 дополнительных файлов устройств для новых
          терминалов.</para>
      </listitem>

      <listitem>
        <para>Отредактируйте файл <filename>/etc/ttys</filename>, добавив по
          строке для каждого из 256 терминалов.  Они должны соответствовать
          формату существующих строк, то есть должны выглядеть вот так:</para>

        <programlisting>
ttyqc none network
        </programlisting>

        <para>Порядок назначения букв при записи в виде регулярного выражения
          имеет вид <literal>tty[pqrsPQRS][0-9a-v]</literal>.</para>
      </listitem>

      <listitem>
        <para>Теперь осталось только перезапустить систему с новым ядром.</para>
      </listitem>
    </orderedlist>
  </para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="create-snd0">
    <para>Не получается создать устройство snd0!</para>
  </question>

  <answer>

  <para>Такого устройства, как <devicename>snd</devicename>, не существует.
    Это название используется в качестве краткого обозначения различных
    устройств, которые составляют во FreeBSD звуковой драйвер, таких как
    <devicename>mixer</devicename>, <devicename>sequencer</devicename> и
    <devicename>dsp</devicename>.</para>

  <para>Для создания этих устройств вы должны сделать следующее:</para>

  <screen>
&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV snd0</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="reread-rc">
    <para>Как перечитать содержимое /etc/rc.conf и перестартовать /etc/rc
       без перезагрузки системы?</para>
  </question>

  <answer>

  <para>Перейдите в однопользовательский режим, а затем возвратитесь обратно
    в многопользовательский.</para>

  <para>На консоли выполните следующее:</para>

  <screen>
&prompt.root; <userinput>shutdown now</userinput>
(Замечание: без -r или -h)

&prompt.root; <userinput>return</userinput>
&prompt.root; <userinput>exit</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="sandbox">
    <para>Что означает термин sandbox (песочница)?</para>
  </question>

  <answer>

  <para><quote>Sandbox</quote> - это термин, используемый при обеспечении
    безопасности.  Он имеет два значения:</para>

  <para>
    <itemizedlist>
      <listitem>
        <para>Процесс, помещённый внутрь некоторых виртуальных стен, которые
          предназначены для того, чтобы предотвратить взлом всей системы в
          результате взлома этого конкретного процесса.</para>

        <para>Говорится, что процесс может <command>играть</command> в границах
          этих стен. Что бы
          этот процесс ни делал, он эти стены разрушить не может, поэтому вам
          не нужен его особый аудит, чтобы с уверенностью сказать, насколько
          его работа безопасна для системы.</para>

        <para>Стеной может служить, например, идентификатор пользователя. Вот
          определение, даваемое на страницах справочника по named и часто
          используемое при обсуждении безопасности систем.</para>

        <para>Рассмотрим, например, службу <literal>ntalk</literal> (смотрите
          /etc/inetd.conf).  Раньше эта служба запускалась с идентификатором
          пользователя root,
          а сейчас - tty.  Пользователь tty - это та песочница, которая
          осложняет взлом системы через ntalk посредством использования этого
          идентификатора пользователя.</para>
      </listitem>
 
      <listitem>
        <para>Процесс, помещённый внутрь симулируемой машины. Это даёт больший
          уровень безопасности.  В общем это означает, что некто, взломавший
          процесс, может думать. что может сломать и систему в целом, однако
          фактически может сломать только симулятор этой машины и не может
          модифицировать никаких реальных данных.</para>

        <para>Самым распространённым способом достигнуть такого результата
          является построение имитирующего окружения в каталоге и затем запуск
          процессов и этом каталоге через chroot (т.е. задав этот каталог в
          качестве <filename>/</filename> для этого процесса, а не реальный
          <filename>/</filename> всей системы).</para>

        <para>Другим часто используемым методом является монтирование низлежащей
          файловой системы в режиме "только для чтения" и затем создание
          уровня файловой системы поверх неё, что даёт процессу видимость
          доступа по записи на ту файловую систему.  Процесс будет полагать,
          что может записывать в те файлы, но это будет единственный процесс,
          который увидит результат - другие процессы не будут этого делать,
          ни в коем случае.</para>

        <para>Попытка сделать такой тип песочницы настолько прозрачна, что
          пользователь (или взломщик) даже не поймёт, что он в ней
          находится.</para>
      </listitem>
    </itemizedlist>
  </para>

  <para>В UNIX реализованы два типа "песочниц". Один на уровне процесса, и один
    на уровне идентификаторов пользователей.</para>

  <para>Каждый процесс в UNIX полностью защищён от других процессов. Никакой
    процесс не может модифицировать адресное пространство другого процесса.
    Это отличается от Windows, где процесс может легко записать что-либо в
    адресное пространство другого процесса, что приводит к аварийным
    ситуациям.</para>

  <para>В UNIX каждым процессом владеет некоторый идентификатор пользователя.
    Если этот пользователь не root, от ограждает процесс от других, 
    владельцами которых являются другие пользователи.  Этот идентификатор
    используется также для защиты данных на диске.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="user-floppymount">
    <para>Как разрешить обычным пользователям монтировать дискеты,
      компакт-диски и другие сменные носители?</para>
  </question>

  <answer>

  <para>Обычным пользователям можно позволить монтировать устройства.
    Вот как это делается:</para>

  <procedure>
    <step>
      <para>Как пользователь <username>root</username>, установите системную
        переменную <varname>vfs.usermount</varname> в значение
        <literal>1</literal>.</para>

      <screen>
&prompt.root; <userinput>sysctl -w vfs.usermount=1</userinput>
      </screen>
    </step>

    <step>
      <para>Работая пользователем <username>root</username>, назначьте
	соответствующие права на устройства с поблочным доступом,
	которые соответствуют сменным носителям.</para>

      <para>Например, чтобы позволить пользователям монтировать дискеты
	в первом дисководе, воспользуйтесь командой</para>
		
      <screen>&prompt.root; <userinput>chmod 666 /dev/fd0</userinput></screen>

      <para>Чтобы разрешить пользователям из группы
        <username>operator</username> монтировать компакт-диски, сделайте
        так:</para>

      <screen>
&prompt.root; <userinput>chgrp operator /dev/cd0c</userinput>
&prompt.root; <userinput>chmod 640 /dev/cd0c</userinput>
      </screen>
    </step>

    <step>
      <para>Наконец, добавьте строчку <literal>vfs.usermount=1</literal> в файл
        <filename>/etc/sysctl.conf</filename>, чтобы она срабатывала во время
        загрузки системы.</para>
    </step>
  </procedure>

  <para>Теперь все пользователи могут монтировать дискету
    <filename>/dev/fd0</filename> в собственные каталоги:</para>

  <screen>
&prompt.user; <userinput> mkdir ~/my-mount-point</userinput>
&prompt.user; <userinput> mount -t msdos /dev/fd0 ~/my-mount-point</userinput>
  </screen>

  <para>Пользователи из группы <username>operator</username> теперь могут
    монтировать компакт-диск <filename>/dev/cd0c</filename> в собственные
    каталоги:</para>

  <screen>
&prompt.user; <userinput> mkdir ~/my-mount-point</userinput>
&prompt.user; <userinput> mount -t msdos /dev/cd0c ~/my-mount-point</userinput>
  </screen>

  <para>Размонтировка устройства осуществляется просто:</para>

  <screen>
&prompt.user; <userinput>umount <filename>~/my-mount-point</filename></userinput>
  </screen>

  <para>Использование <varname>vfs.usermount</varname>, однако, имеет
    некоторые негативные стороны, связанные с вопросами безопасности.
    Более правильным способом работы с носителями в формате MSDOS
    является использование пакета <ulink
    URL="http://www.FreeBSD.org/cgi/ports.cgi?query=%5Emtools-&amp;stype=name">
    mtools</ulink> из коллекции портов.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="new-huge-disk">
    <para>Как перенести систему на большой новый диск?</para>
  </question>

  <answer>

  <para>Самый лучший способ заключается в переустановке ОС на новый диск и
    последующем переносе данных пользователей.	Это очень рекомендуется
    делать, если вы следовали ветке -stable в течение более одного релиза
    или обновляли релиз, а не устанавливали новый.  Вы можете установить
    программу booteasy на оба диска с помощью команды &man.boot0cfg.8; и
    выполнять загрузку с любого из них до тех пор, пока не будете
    удовлетворены новой конфигурацией системы.	Пропустите следующий
    абзац, чтобы перейти к вопросу переноса данных после этой
    операции.</para>

  <para>Если вы решили не делать новой установки, то вам нужно разбить на
    разделы и разметить новый диск с помощью
    <filename>/stand/sysinstall</filename> или &man.fdisk.8; и
    &man.disklabel.8;.	Вы также должны установить на оба диска программу
    booteasy с помощью &man.boot0cfg.8;, чтобы иметь возможность выполнять
    загрузку как старой, так и новой системы после выполнения копирования.
    Обратитесь к <ulink
    url="http://www.freebsd.org/tutorials/formatting-media/index.html">
    руководству по форматированию носителей</ulink> за подробным описанием
    этого процесса.</para>

  <para>Итак, после подготовки диск, вы можете переносить данные.  К
    сожалению, вы не можете просто скопировать данные.	Такие вещи, как
    файлы устройств (в каталоге <filename>/dev</filename>) и символические
    ссылки будут этому мешать.	Вам нужно использовать инструменты, которые
    работают с такими случаями, а именно &man.dump.8; и &man.tar.1;.  Я
    рекомендую выполнять перенос данных в однопользовательском режиме, но
    это не обязательно.</para>

  <para>Вы не должны использовать ничего, кроме &man.dump.8; и
    &man.restore.8; для переноса корневой файловой системы.  Команда
    &man.tar.1; может сработать, а может и не сработать.  Также вы должны
    использовать &man.dump.8; и &man.restore.8; при переносе одного раздела
    в другой пустой раздел.  Последовательность шагов при использовании
    программы dump для переноса данных раздела в новый раздел такова:</para>

  <procedure>
    <step>
      <para>выполните команду newfs над новым разделом.</para>
    </step>

    <step>
      <para>смонтируйте его во временный каталог.</para>
    </step>

    <step>
      <para>перейдите в этот каталог.</para>
    </step>

    <step>
      <para>Выполните команду dump над старым разделом, направив вывод в
	новый раздел.</para>
    </step>
  </procedure>

  <para>Например, если вы собираетесь перенести корневую файловую систему
    на устройство <filename>/dev/ad1s1a</filename> с использованием
    каталога <filename>/mnt</filename> в качестве временной точки
    монтирования, то это делается так:</para>

  <screen>
&prompt.root; <userinput>newfs /dev/ad1s1a</userinput>
&prompt.root; <userinput>mount /dev/ad1s1a</userinput>
&prompt.root; <userinput>cd /mnt</userinput>
&prompt.root; <userinput>dump 0uaf - / | restore xf -</userinput>
  </screen>

  <para>Если вы собираетесь изменить размещение ваших разделов - скажем,
    разбив один из разделов на два или объединив два раздела в один, вы
    можете обнаружить необходимость в переносе всего в один подкаталог на
    новое место.  Так как программа &man.dump.8; работает с файловыми
    системами, она этого сделать не сможет.  Поэтому воспользуйтесь
    программой &man.tar.1;.  Команда общего вида для переноса
    <filename>/old</filename> в <filename>/new</filename> в случае
    &man.tar.1; имеет такой вид:</para>

  <screen>
&prompt.root; <userinput>(cd /old; tar cf - .) | (cd /new; tar xpf -)</userinput>
  </screen>

  <para>Если в каталог <filename>/old</filename> смонтированы файловые
    системы, и вы не хотите перемещать данные или размонтировать их, то
    просто добавьте флаг 'l' к первому упоминанию &man.tar.1;:</para>

  <screen>
&prompt.root; <userinput>(cd /old; tar clf - .) | (cd /new; tar xpf -).</userinput>
  </screen>

  <para>Вы можете предпочесть cpio(1), pax(1) или cpdup (из
    ports/sysutils/cpdup) вместо tar.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="release-candidate">
    <para>Я пытался обновить мою систему до последней -STABLE, а получил -RC
      или -BETA!  Что происходит?</para>
  </question>

  <answer>

  <para>Краткий ответ: это же просто название.	RC означает
    <quote>Release Candidate</quote>.  Это значит, что вскоре
    произойдет выход релиза.  Во FreeBSD -BETA значит то же самое,
    что и -RC.</para>

  <para>Подробный ответ: во FreeBSD релизы выпускаются из одного из
    двух мест.	Крупные релизы, точка-ноль, такие, как
    3.0-RELEASE и 4.0-RELEASE, ответвляются от основного потока
    разработки, более известного как <link
    linkend="current">-CURRENT</link>.	Мелкие релизы, такие, как
    3.1-RELEASE или 4.2-RELEASE, являются снэпшотами активной ветки
    <link linkend="stable">-STABLE</link>.</para>

  <para>Когда делается релиз, то ветвь, из которой он выпускается,
    подвергается некоторой подготовке.	Частью этого процесса
    является замораживание кода.  Когда инициируется замораживание
    кода, то имя ветки изменяется для того, чтобы отразить факт
    близости релиза.  Например, если ветка называлась 4.0-STABLE, то
    её имя будет изменено на 4.1-RC, чтобы указать, что скоро из неё
    будет сделан релиз.  Как только релиз, а в этом примере это
    4.1-RELEASE, будет сделан, ветвь будет переименована в
    4.1-STABLE.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="kernel-chflag-failure">
    <para>Я попытался установить новое ядро, однако утилита chflags не
      сработала.  Как это обойти?</para>
  </question>

  <answer>

  <para>Краткий ответ: Скорее всего, вы работаете в режиме безопасности,
    большем, чем 0.  Для установки ядра перезагрузите машину и войдите в
    однопользовательский режим.</para>

  <para>Подробный ответ: FreeBSD запрещает менять системные флаги при работе
    на уровнях безопасности, превышающих 0.  Вы можете определить ваш
    уровень такой командой:</para>

  <screen>
&prompt.root; <userinput>sysctl kern.securelevel</userinput>
  </screen>

  <para>Вы не можете понизить уровень безопасности; для установки ядра вам
    нужно перезагрузиться в однопользовательский режим, или изменить уровень
    безопасности в <filename>/etc/rc.conf</filename>, а затем выполнить
    перезагрузку.  Обратитесь к странице Справочника по &man.init.8; за
    подробной информацией об уровне безопасности и посмотрите
    <filename>/etc/defaults/rc.conf</filename> и справочную страницу по
    &man.rc.conf.5; для выяснения подробностей о файле rc.conf.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="kernel-securelevel-time">
    <para>Не получается изменить системное время больше чем на одну секунду!
       Как это обойти?</para>
  </question>

  <answer>

  <para>Краткий ответ: Скорее всего, вы работаете на уровне бехопасности,
    превышающем 1.  Для смены даты перезагрузите машину и войдите в
    однопользовательский режим.</para>

  <para>Подробный ответ: FreeBSD запрещает менять системное время на больше
    чем одну секунду при работе на уровнях безопасности, превышающих 1.  Вы
    можете определить ваш уровень такой командой:</para>

  <screen>
&prompt.root; <userinput>sysctl kern.securelevel</userinput>
  </screen>

  <para>Вы не можете понизить уровень безопасности; для изменения даты вам
    нужно перезагрузиться в однопользовательский режим, или изменить уровень
    безопасности в <filename>/etc/rc.conf</filename>, а затем выполнить
    перезагрузку.  Обратитесь к странице Справочника по &man.init.8; за
    подробной информацией об уровне безопасности, и посмотрите
    <filename>/etc/defaults/rc.conf</filename> и справочную страницу по
    &man.rc.conf.5; для выяснения подробностей о файле rc.conf.</para>

  </answer>
</qandaentry>

<qandaentry>
  <question id="statd-mem-leak">
     <para>В &man.rpc.statd.8; есть ошибка работы с памятью ! Он
     использует 256 Mb памяти !</para>
  </question>

  <answer>
    <para>Нет, там нет ошибок и он не использует 256 Mb памяти. Ему
    просто нравится (что он постоянно и делает) отображать неприлично
    большой кусок памяти в свое адресное пространство для удобства.
    Здесь нет ничего неправильного с технической точки зрения, это
    просто сбивает с толку программы вроде &man.top.1; и &man.ps.1;
    </para>

    <para>&man.rpc.statd.8; отображает свой статусный файл
    (находящийся на <filename>/var</filename>) в свое адресное
    пространство. Для того чтоб постоянно не беспокоится о будущих
    переотражениях, когда файл вырастет в размерах, он просто
    отображает его с огромным размером заранее. Это просто заметить
    в исходных текстах, где как вы можете увидеть параметр длина
    к функции &man.mmap.2; имеет значение
    <literal>0x10000000</literal>, или одна шестнадцатая адресного
    пространства для IA32, то есть 256Mb.</para>
  </answer>
</qandaentry>

</qandaset>
</chapter>


<chapter id="x">
<title>X Window System и виртуальные консоли</title>

<qandaset>
<qandaentry>
  <question id="running-X">
    <para>Я хочу запустить X, как это сделать?</para>
  </question>

  <answer>

  <para>Самый простой способ - это указать во время инсталляции, что вы
    хотите использовать X.</para>

  <para>Затем следуйте указаниям в документации по утилите <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xf86config">xf86config</ulink>,
    которая предназначена для конфигурирования работы XFree86(tm) с вашим
    графическим адаптером/мышью/итд.</para>

  <para>Вы можете также попробовать сервер Xaccel. За подробной информацией
    обратитесь к разделу, посвящённому продуктам фирм <link
    linkend="xig">Xi Graphics</link> и <link
    linkend="metrox">Metro Link</link>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="x-and-moused">
    <para>Почему моя мышь не работает с X?</para>
  </question>

  <answer>

  <para>Если вы используете syscons (стандартный драйвер консоли), то можете
    настроить поддержку указателя мыши во всех виртуальных экранах.  Во
    избежание конфликтов с X, драйвер syscons поддерживает виртуальное
    устройство <filename>/dev/sysmouse</filename>.  Все события,
    получаемые от реальной мыши, пишутся в устройство sysmouse через moused.
    Если вы хотите использовать вашу мышь на одной или нескольких виртуальных
    консолях, <emphasis remap=bf>продолжая</emphasis> использовать X,
    посмотрите <xref linkend="moused" remap="другой раздел"> и настройте
    moused.</para>

  <para>Затем отредактируйте <filename>/etc/XF86Config</filename> так, чтобы
    в нём были следующие строки.</para>
 
  <programlisting>
      Section        Pointer
      Protocol       "SysMouse"
      Device         "/dev/sysmouse"
      .....
  </programlisting>

  <para>Пример выше предназначен для XFree86 3.3.2 и выше.  Для более ранних
    версий параметр <emphasis>Protocol</emphasis> должен быть
    <emphasis>MouseSystems</emphasis>.</para>
 
  <para>Некоторые предпочитают использовать в X устройство
    <filename>/dev/mouse</filename>.  Чтобы оно работало, файл устройства
    <filename>/dev/mouse</filename> должен являться ссылкой на <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?sysmouse">
    /dev/sysmouse</ulink>:</para>

  <screen>
&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>rm -f mouse</userinput>
&prompt.root; <userinput>ln -s sysmouse mouse</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="x-and-wheel">
    <para>У моей мыши есть колёсико.  Могу ли я его использовать при работе
      в X?</para>
  </question>

  <answer>

  <para>Да.  Но вам нужно будет настроить программы-клиенты для X.  Посмотрите
    <ulink URL="http://www.inria.fr/koala/colas/mouse-wheel-scroll/">страничку
    Коласа Наабу (Colas Nahaboo)
    (http://www.inria.fr/koala/colas/mouse-wheel-scroll/)</ulink>.</para>

  <para>Если вы собираетесь использовать программу
    <application>imwheel</application>, следуйте этим простым указаниям:</para>

  <orderedlist>
    <listitem>
      <para>Трансляция событий от колёсика</para>

      <para>Работа программы <application>imwheel</application> основана на
        трансляции событий от кнопок мыши 4 и 5 в события от клавиатуры.  То
        есть вам нужно заставить драйвер мыши транслировать события от колёсика
        в события от кнопок 4 и 5.  Есть два способа сделать это, в первом
        из которых  трансляцию выполняет &man.moused.8;.  Во втором методе
        трансляцию событий выполняет сам X-сервер.</para>

      <orderedlist>
        <listitem>
          <para>Использование &man.moused.8; для трансляции событий от
            колёсика</para>

          <para>Для того, чтобы &man.moused.8; выполнял преобразование событий,
            просто добавьте опцию <option>-z 4</option> к команде,
            запускающей &man.moused.8;.  Например, если обычно вы запускаете
            &man.moused.8; командой <command>moused -p /dev/psm0</command>,
            то теперь вы должны будете использовать <command>moused -p
            /dev/psm0 -z 4</command>.  Если &man.moused.8; запускается у вас
            автоматически во время загрузки через
            <filename>/etc/rc.conf</filename>, то вы можете просто добавить
            опцию <option>-z 4</option> к переменной
            <varname>moused_flags</varname> в файле
            <filename>/etc/rc.conf</filename>.</para>

          <para>Теперь вам нужно указать X, что вы используете 5-кнопочную
            мышь.  Для этого просто добавьте строчку
            <literal>Buttons 5</literal> в секцию <quote>Pointer</quote>
            файла <filename>/etc/XF86Config</filename>.  Например, в вашем
            файле <filename>/etc/XF86Config</filename> секция
            <quote>Pointer</quote> может принять такой вид:</para>

          <example>
            <title>Секция <quote>Pointer</quote> файла XF86Config для мыши с
              колёсиком и трансляцией через moused
            </title>

            <programlisting>
              Section "Pointer"
              Protocol        "SysMouse"
              Device          "/dev/sysmouse"
              Buttons         5
              EndSection
            </programlisting>
          </example>
        </listitem>

        <listitem>
          <para>Использование X-сервера для трансляции событий от
            колёсика</para>

          <para>Если &man.moused.8; у вас не запущен или если вы не хотите,
            чтобы &man.moused.8; занимался трансляцией событий от колёсика,
            то это может сделать X-сервер.  Это требует некоторых модификаций
            в вашем файле <filename>/etc/XF86Config</filename>.  Во-первых,
            вам нужно правильно выбрать протокол для вашей мыши.  Большинство
            манипуляторов с колёсиками используют протокол
            <quote>IntelliMouse</quote>.  Однако XFree86 поддерживает другие
            протоколы, такие, как <quote>MouseManPlusPS/2</quote> для мышей
            Logitech MouseMan+.  После того, как вы выберите используемый
            протокол, в секцию <quote>Pointer</quote> нужно будет добавить
            строчку <varname>Protocol</varname>.</para>

          <para>Во-вторых, вам нужно указать, что X-сервер будет
            переопределять события от колёсика в события от кнопок 4 и 5.
            Это делается заданием опции
            <varname>ZAxisMapping</varname>.</para>

          <para>Например, если вы не используете &man.moused.8; и ваша мышь
            IntelliMouse подключена к порту для мыши PS/2, в вашем файле
            <filename>/etc/XF86Config</filename> должно быть указано
            следующее:</para>

          <example>
            <title>Секция <quote>Pointer</quote> для мыши с колёсиком
              из файла <filename>XF86Config</filename> с трансляцией
              с помощью X-сервера</title>

            <programlisting>
              Section "Pointer"
              Protocol        "IntelliMouse"
              Device          "/dev/psm0"
              ZAxisMapping    4 5
              EndSection
            </programlisting>
          </example>
        </listitem>
      </orderedlist>
    </listitem>

    <listitem>
      <para>Установка программы <application>imwheel</application></para>

      <para>Теперь установите программу <application>Imwheel</application> из
	Коллекции Портов.  Она находится в категории <filename>x11</filename>.
	Эта утилита будет преобразовывать события от колёсика вашей мыши в
	события от клавиатуры.  Например, она может послать в программу
	последовательность <keycap>Page Up</keycap>, когда вы крутите колёсико
	вперёд.  Для преобразования событий от колёсика в нажатия клавиш
	<application>imwheel</application> использует конфигурационный файл,
	причём для разных приложений возможна посылка разных
	последовательностей.  Конфигурационным файлом, используемым по
	умолчанию, является <filename>/usr/X11R6/etc/imwheelrc</filename>.  Вы
	можете скопировать его в <filename>~/.imwheelrc</filename> и
	отредактировать, если хотите изменить параметры работы
	<application>imwheel</application>.  Формат конфигурационного файла
	описан на странице Справочника о &man.imwheel.1;.</para>
    </listitem>

    <listitem>
      <para>Настройка редактора <application>Emacs</application> для работы с
	<application>Imwheel</application>
	(<emphasis>по желанию</emphasis>)</para>

      <para>Если вы используете <application>emacs</application> или
	<application>Xemacs</application>, то в ваш файл
	<filename>~/.emacs</filename> нужно добавить маленький раздел.  Для
	редактора <application>emacs</application>, добавьте следующее:</para>

      <example>
	<title>Конфигурация <application>Emacs</application> для работы с
          <application>Imwheel</application></title>

	<programlisting>
          ;;; For imwheel
          (setq imwheel-scroll-interval 3)
          (defun imwheel-scroll-down-some-lines ()
            (interactive)
            (scroll-down imwheel-scroll-interval))
          (defun imwheel-scroll-up-some-lines ()
            (interactive)
            (scroll-up imwheel-scroll-interval))
          (global-set-key [?\M-\C-\)] 'imwheel-scroll-up-some-lines)
          (global-set-key [?\M-\C-\(] 'imwheel-scroll-down-some-lines)
          ;;; end imwheel section
        </programlisting>
      </example>

      <para>Для редактора <application>Xemacs</application>, в ваш файл
	<filename>~/.emacs</filename> добавьте следующее:</para>

      <example>
	<title>Конфигурация <application>Xemacs</application> для работы с
	  <application>Imwheel</application></title>

	<programlisting>
          ;;; For imwheel
          (setq imwheel-scroll-interval 3)
          (defun imwheel-scroll-down-some-lines ()
            (interactive)
            (scroll-down imwheel-scroll-interval))
          (defun imwheel-scroll-up-some-lines ()
            (interactive)
            (scroll-up imwheel-scroll-interval))
          (define-key global-map [(control meta \))] 'imwheel-scroll-up-some-lines)
          (define-key global-map [(control meta \()] 'imwheel-scroll-down-some-lines)
          ;;; end imwheel section
	</programlisting>
      </example>
    </listitem>

    <listitem>
      <para>Запуск <application>Imwheel</application></para>

      <para>Вы можете просто набрать команду <command>imwheel</command> в вашем
	в окне xterm после установки.  Она сама перейдёт в фоновый режим и
	немедленно начнёт работу.  Если вы хотите использовать
	<application>imwheel</application> всегда, просто добавьте её запуск в
	ваш <filename>.xinitrc</filename> или <filename>.xsession</filename>.
	Все предупреждения о PID-файлах, которые выводит
	<application>imwheel</application>, можно проигнорировать.  Эти
	предупреждения имеют смысл только в Linux-версии
	<application>imwheel</application>.</para>
    </listitem>
  </orderedlist>

  </answer>
</qandaentry>


<qandaentry>
  <question id="window-menu-weird">
    <para>Меню и диалоговые окна в X Window работают неправильно!</para>
  </question>

  <answer>

  <para>Попробуйте выключить Num Lock.</para>

  <para>Если клавиша Num Lock во время загрузки по умолчанию включена,
    добавьте в секцию <literal>Keyboard</literal>
    файла <filename>XF86Config</filename> следующую строку.</para>

  <programlisting>
# Let the server do the NumLock processing.  This should only be
# required when using pre-R6 clients
    ServerNumLock
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="virtual-console">
    <para>Что такое виртуальные консоли и как изменить их количество?</para>
  </question>

  <answer>

  <para>Виртуальные консоли, упрощённо говоря, позволяют вам иметь
    несколько одновременных сеансов работы с той же самой машиной без
    установки какой бы то ни было сети или запуска X.</para>

  <para>При запуске системы после вывода сообщений этапа загрузки на консоль
    выдаётся приглашение на вход в систему.  Вы можете ввести своё имя и пароль
    и начать работать (или играть!) на первой виртуальной консоли.</para>

  <para>В какой-то момент вы можете захотеть запустить ещё одну сеанс,
    скажем, чтобы заглянуть в документацию по программе, которую вы
    запустили или для для чтения электронной почты во время ожидания
    завершения передачи данных по FTP.  Просто нажмите Alt-F2 (удерживая
    клавишу Alt, нажмите F2) и вы обнаружите приглашение, ждущее вас на
    второй <quote>виртуальной консоли</quote>!  Когда захотите вернуться к
    первоначальному сеансу, нажмите Alt-F1.</para>

  <para>После инсталляции по умолчанию во FreeBSD задействованы три виртуальных
    консоли (8 начиная с 3.3-RELEASE), а комбинации клавиш Alt-F1, Alt-F2 и
    Alt-F3 служат для переключения между ними.</para>

  <para>Чтобы увеличить количество консолей, отредактируйте файл <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>, добавив
    туда записи для терминалов с именами от <devicename>ttyv4</devicename> до
    <devicename>ttyvc</devicename> после слов <quote>Virtual
    terminals</quote>:</para>

  <programlisting>
# Edit the existing entry for ttyv3 in /etc/ttys and change
# "off" to "on".
ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
ttyva   "/usr/libexec/getty Pc"         cons25  on secure
ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
  </programlisting>

  <para>Используйте из них столько, сколько посчитаете нужным.  Чем больше
    виртуальных терминалов у вас имеется, тем больше ресурсов они
    используют; это может иметь значение, если у вас меньше чем 8МБ ОЗУ.
    Вы можете сменить статус консолей с <literal>secure</literal> на
    <literal>insecure</literal>.</para>

  <para>
    <important>
      <para>Если вы хотите запустить X, вы <emphasis>должны</emphasis>
        оставить для него по крайней мере один неиспользуемый (или
        выключенный) виртуальный терминал.  Таким образов, если вы хотите
        иметь приглашения login на всех двенадцати функциональных клавиши,
        то вам не повезло - вы можете это сделать только для одиннадцати из
        них, если хотите на этой же машине ещё запустить X-сервер.</para>
    </important>
  </para>

  <para>Самым простым способом убрать консоль является просто её
    выключение.  Например, если вы запустили на всех 12 консолях
    виртуальные терминалы, как указано выше, и ещё хотите запустить X, то
    должны будете изменить параметры двенадцатого виртуального
    терминала с:</para>

  <programlisting>
ttyvb   "/usr/libexec/getty Pc"         cons25  on  secure
  </programlisting>

  <para>на:</para>

  <programlisting>
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
  </programlisting>

  <para>Если на вашей клавиатуре только десять функциональных клавиш,
    то последние строки будут выглядеть так:</para>

  <programlisting>
ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
ttyva   "/usr/libexec/getty Pc"         cons25  off secure
ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
  </programlisting>

  <para>(Вы также можете просто их удалить.)</para>

  <para>После того, как вы отредактировали файл <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>,
    проверьте, что у вас имеется достаточное количество устройств для
    виртуальных терминалов.  Самый простой способ сделать это:</para>

  <screen>
&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vty12</userinput>
  </screen>

  <para>Самым простым (и надёжным) способом активировать виртуальные
    консоли является перезагрузка.  Однако если вы вовсе не хотите этого
    делать, просто остановите X Window System и выполните (как
    пользователь <username>root</username>):</para>

  <screen>
&prompt.root; <userinput>kill -HUP 1</userinput>
  </screen>

  <para>При этом требуется, чтобы вы полностью закрыли X Window, если она
    была запущена, до запуска этой команды.  Если вы это не сделаете,
    ваша система может повиснуть/заблокироваться после выполнения команды
    kill.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="vty-from-x">
    <para>Как осуществляется доступ к виртуальным консолям из X?</para>
  </question>

  <answer>

  <para>Используйте комбинацию клавиш
    <keycombo action="simul">
      <keycap>Ctrl</keycap>
      <keycap>Alt</keycap>
      <keycap>F<replaceable>n</replaceable></keycap>
    </keycombo>
    для переключения обратно в виртуальную консоль.  Нажатие
    <keycombo action="simul">
      <keycap>Ctrl</keycap>
      <keycap>Alt</keycap>
      <keycap>F1</keycap>
    </keycombo>
    вернёт вас на первую виртуальную консоль.</para>

  <para>После того, как вы оказались в текстовой консоли, можете использовать,
    как обычно, комбинации
    <keycombo action="simul">
      <keycap>Alt</keycap>
      <keycap>F<replaceable>n</replaceable></keycap>
    </keycombo> для переключения между ними.</para>

  <para>Чтобы вернуться в сеанс работы X, вы должны переключиться в виртуальную
    консоль, на которой запущена X Window.  Если вы запустили X из командной
    строки (например, при помощи команды <command>startx</command>), то сеанс
    работы X будет привязан к следующей неиспользуемой виртуальной консоли, а
    не к той текстовой консоли, с которой он был запущен.  Если у вас имеется
    восемь активных виртуальных терминалов, то X будет работать на девятом, и
    вам нужно будет воспользоваться комбинацией
    <keycombo action="simul">
      <keycap>Alt</keycap>
      <keycap>F9</keycap>
    </keycombo>
    для возврата в X.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="xdm-boot">
    <para>Как запустить XDM во время загрузки?</para>
  </question>

  <answer>

  <para>Есть две философские школы, проповедующие различные методы запуска
    <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm">
    xdm</ulink>.  Последователи одного течения запускают xdm из <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>, используя
    приводимый пример, тогда как другие вставляют запуск xdm в скрипт <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?rc(8)">rc.local</ulink> или
    <filename>X.sh</filename>, поместив последний в каталог
    <filename>/usr/local/etc/rc.d</filename>.  Оба метода равноправны, и один
    из них может работать в ситуациях, с которыми не справляется другой и
    наоборот.  В обоих случая результат один и тот же: X выводит
    графическое приглашение login:.</para>

  <para>Плюсом метода с использованием ttys является документирование того,
    на каком vty будет запущен X и то, что ответственность за перезапуск
    X-сервера при завершении сеанса работы лежит на процессе init.  Метод
    с использованием rc.local позволяет просто прекратить работу xdm, если
    при запуске X возникли какие-нибудь проблемы.</para>

  <para>Из rc.local <command>xdm</command> должен быть запущен без
    аргументов, (то есть как даемон).  xdm должен быть запущен ПОСЛЕ запуска
    getty, иначе они будут конфликтовать, блокируя консоль.  Лучше всего
    выдержать паузу секунд на 10 и потом запустить xdm.</para>

  <para>Если <command>xdm</command> запускается из
    <filename>/etc/ttys</filename>, то есть вероятность конфликта между
    <command>xdm</command> и <command>getty</command>.  Одним из способов
    избежать этого является добавление номера <literal>vt</literal> в файл
    <filename>/usr/X11R6/lib/X11/xdm/Xservers</filename>.</para>

  <programlisting>
:0 local /usr/X11R6/bin/X vt4
  </programlisting>

  <para>В вышеприведённом случае X-серверу указывается работать на
    <filename>/dev/ttyv3</filename>.  Заметьте, что номера отличаются на
    единицу.  Дело в том, что X-сервер считает vty от единицы, когда как
    отсчёт vty в ядре FreeBSD ведётся с нуля.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="xconsole-failure">
    <para>При запуске xconsole выдаётся сообщение <literal>Couldn't open
      console</literal>.</para>
  </question>

  <answer>

  <para>Если вы запускаете <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=X">
    X</ulink> через скрипт <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=startx">
    startx</ulink>, права на устройство <filename>/dev/console</filename>
    <emphasis remap=tt>не</emphasis> изменяются, поэтому такие команды, как
    <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xterm">
    xterm -C</ulink> и <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?manpath=xfree86&amp;query=xconsole">
    xconsole</ulink>, не будут работать.</para>

  <para>Это зависит от прав доступа, установленных для консоли по умолчанию.
    В многопользовательской системе вовсе не нужно, чтобы любой
    пользователь мог выводить информацию на системную консоль.  Для
    пользователей, вошедших в систему через VTY, для решения этой проблемы
    существует файл <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?fbtab">
    fbtab</ulink>.</para>

  <para>В общем, раскомментируйте строчку вида</para>

  <programlisting>
/dev/ttyv0 0600 /dev/console
  </programlisting>

  <para>в файле <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?fbtab(5)">/etc/fbtab</ulink>, и
    этого будет достаточно для того, чтобы всякий,
    кто вошёл в систему с <filename>/dev/ttyv0</filename>, будет иметь доступ к
    консоли.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="xfree86-root">
    <para>Раньше я запускал XFree86, работая как обычный пользователь, а
      теперь при запуске выдается сообщение о том, что я должен быть
      пользователем root!</para>
  </question>

  <answer>

  <para>Все X-серверы должны запускаться пользователем root, чтобы иметь
    прямой доступ к вашему видеооборудованию.  Более старые версии XFree86
    (&lt;= 3.3.6) устанавливали все поставляемые серверы так, что они
    автоматически запускались пользователем root (с установленным битом
    смены владельца запускаемого процесса).  Несомненно, это рискованно,
    потому что X-серверы являются большими, сложными программами.  Более
    новые версии XFree86 не устанавливают на серверах бит смены владельца на
    пользователя root именно по этой причине.</para>

  <para>Очевидно, что запускать X-сервер, работая как пользователь root,
    неправильно и небезопасно.  Есть два способа использовать X, работая как
    обычный пользователь.  Первый способ заключается в использовании
    <command>xdm</command> или другого менеджера дисплеев (к примеру,
    <command>kdm</command>); второй способ - в использовании программы
    <command>Xwrapper</command>.</para>

  <para><command>xdm</command> представляет собой даемона, который
    обрабатывает входы в систему в графическом режиме.  Обычно он запускается
    во время загрузки и отвечает за аутентификацию пользователей и запуск их
    сеансов; практически это графический аналог программ
    <command>getty</command> и <command>login</command>.  Более подробная
    информация о <command>xdm</command> находится в <ulink
    url="http://www.xfree86.org/support.html">документации по
    XFree86</ulink> и в <link linkend="xdm-boot">соответствующем разделе
    FAQ</link>.</para>

  <para><command>Xwrapper</command> является оболочкой для X-сервера; это
    маленькая утилита. позволяющая кому-либо запускать X-сервер и достаточно
    безопасная в использовании.  Она выполняет некоторую проверку
    передаваемых ей в командной строке аргументов, и если все в порядке,
    запускает соответствующий X-сервер.  Если по каким-либо причинам вы не
    хотите запускать менеджер дисплеев, то эта утилита вам подойдет.  Если у
    вас установлена полная коллекция портов, вы можете найти этот порт в
    каталоге <filename>/usr/ports/x11/wrapper</filename>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ps2-x">
    <para>Моя мышь PS/2 в X работает неправильно.</para>
  </question>

  <answer>

  <para>Вполне может быть, что ваша мышь и её драйвер
    рассинхронизировались.</para>

  <para>В версиях 2.2.5 и более ранних это может произойти при переключении
    из X в виртуальный терминал и последующем возвращении в X.  Если эта
    проблема возникает достаточно часто, попробуйте добавить следующую
    строку в файл конфигурации ядра и перекомпилировать его.</para>

  <programlisting>
options PSM_CHECKSYNC
  </programlisting>

  <para>Если у вас нет опыта перекомпиляции ядра, обратитесь к <link
    linkend="make-kernel">соответствующему разделу</link>.</para>
 
  <para>С этой опцией проблем с синхронизацией мыши и её драйвера должно
    быть меньше.  Если, однако, эта проблема всё же осталась, щёлкните
    любой кнопкой мыши, не двигая ей, что заставит мышь и драйвер сделать
    попытку синхронизироваться.</para>

  <para>Заметьте, что в некоторых системах эта опция может не работать и
    приводить к отключению функции <quote>tap</quote> устройства ALPS
    GlidePoint, подключенного к порту мыши PS/2.</para>

  <para>В версиях 2.2.6 и выше, проверка синхронизации сделана гораздо лучше
    и включена в стандартный драйвер мыши PS/2.  Она должна работать даже с
    GlidePort.  (Так как код проверки стал стандартной функцией, опция
    PSM_CHECKSYNC в этих версиях недоступна.)  Однако в редких случаях
    драйвер может ошибочно обнаруживать проблемы с синхронизацией, и вы
    будете видеть такие сообщения ядра:</para>

  <programlisting>
psmintr: out of sync (xxxx != yyyy)
  </programlisting>

  <para>а также обнаружите, что мышь теперь работает неправильно.</para>

  <para>Если это случится, отмените проверку согласования, установив
    значение флага для драйвера мыши PS/2 в 0x100.  Войдите в конфигуратор
    <emphasis>UserConfig</emphasis>, задав опцию <option>-c</option> в
    приглашении загрузчика:</para>

  <screen>
boot: <userinput>-c</userinput>
  </screen>

  <para>Затем в командной строке <emphasis>UserConfig</emphasis>
    наберите:</para>

  <screen>
UserConfig&gt; <userinput>flags psm0 0x100</userinput>
UserConfig&gt; <userinput>quit</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ps2-mousesystems">
    <para>Моя мышь PS/2 от MouseSystems похоже, не работает.</para>
  </question>

  <answer>

  <para>Было несколько сообщений, что некоторые модели мышей PS/2 от
    MouseSystems работают только в режиме <quote>высокого разрешения</quote>.
    В других режимах курсор мыши постоянно прыгает в верхний левый угол
    экрана.</para>

  <para>К сожалению, для версий 2.0.X и 2.1.X решения этой проблемы не
    существует.  Для версий от 2.2 до 2.2.5 приложите следующий патч к файлу
    <filename>/sys/i386/isa/psm.c</filename> и перестройте ядро.  Если у вас
    нет опыта перекомпиляции ядра, обратитесь к <link
    linkend="make-kernel">соответствующему разделу</link>.</para>
  
  <programlisting>
@@ -766,6 +766,8 @@
     if (verbose &gt;= 2)
 	log(LOG_DEBUG, "psm%d: SET_DEFAULTS return code:%04x\n",
 	    unit, i);
+    set_mouse_resolution(sc-&gt;kbdc, PSMD_RES_HIGH);
+
 #if 0
     set_mouse_scaling(sc-&gt;kbdc); 	/* 1:1 scaling */
     set_mouse_mode(sc-&gt;kbdc);		/* stream mode */
  </programlisting>

  <para>Для версий 2.2.6 и выше укажите флаг 0x04 драйверу мыши PS/2 для
    перевода её в режим высокого разрешения.  Войдите в
    <emphasis>UserConfig</emphasis>, задав опцию <option>-c</option> в
    приглашении загрузчика:</para>

  <screen>
boot: <userinput>-c</userinput>
  </screen>

  <para>Затем в командной строке <emphasis>UserConfig</emphasis>
    наберите:</para>

  <screen>
UserConfig&gt; <userinput>flags psm0 0x04</userinput>
UserConfig&gt; <userinput>quit</userinput>
  </screen>

  <para>В предыдущем разделе описана возможная причина проблем с мышью.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="imake-tmpl">
    <para>При компиляции приложений для X программа <command>imake</command> не
      может найти файл <filename>Imake.tmpl</filename>.  Где он
      находится?</para>
  </question>

  <answer>

  <para>Файл Imake.tmpl является частью пакета Imake, стандартного
    инструмента для построения X-приложений.  Он, также как ещё несколько
    заголовочных файлов, требуемых для построения X-приложений, содержится
    в дистрибутиве программ X.  Вы можете их проинсталлировать из sysinstall
    или взять из дистрибутива X. </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="mouse-button-reverse">
    <para>Как поменять местами кнопки мыши?</para>
  </question>

  <answer>

  <para>Поместите команду <command>xmodmap -e "pointer = 3 2 1"</command> в
    один из ваших скриптов .xinitrc или .xsession.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="install-splash">
    <para>Как установить экранную заставку и где такие заставки можно
      найти?</para>
  </question>

  <answer>

  <para>Перед самым выпуском релиза FreeBSD 3.1 в систему была добавлена
    возможность вывода <quote>заставки</quote> во время загрузки.  На данный
    момент экраны заставок должны быть 256-цветными файлами формата BMP
    <filename>*.BMP</filename> или ZSoft PCX (<filename>*.PCX</filename>).
    Кроме того, они должны иметь разрешение 320x200 или меньше для работы со
    стандартными адаптерами VGA. Если вы включили поддержку VESA при компиляции
    ядра, то вы можете использовать экраны размером до 1024x768.  Заметьте, что
    поддержка VESA требует указание опции <literal>VM86</literal>
    при компиляции ядра.  Реальная поддержка VESA может быть вкомпилирована в
    ядро при указании опции <literal>VESA</literal> либо загружена в виде
    kld-модуля ядра во время начальной загрузки.</para>

  <para>Чтобы использовать заставку, вам нужно изменить файлы, управляющие
    процессом загрузки FreeBSD.  Формат этих файлов был изменён перед выпуском
    релиза FreeBSD 3.2, так что есть два способа загрузки экранных
    заставок:</para>

  <para>
    <itemizedlist>
      <listitem>
        <para>FreeBSD 3.1</para>

        <para>Первым делом нужно найти экранную заставку в формате BMP. Релиз
          3.1 поддерживает заставки только в формате Windows.  После того, как
          вы нашли понравившуюся вам заставку, скопируйте её в файл
          <filename>/boot/splash.bmp</filename>.  Затем вам нужно поместить в
          файл <filename>/boot/loader.rc</filename> следующие строки:</para>

        <programlisting>
load kernel
load -t splash_image_data /boot/splash.bmp
load splash_bmp
autoboot
        </programlisting>
      </listitem>

      <listitem>
        <para>FreeBSD 3.2+</para>

        <para>Кроме поддержки заставок в формате PCX, FreeBSD 3.2 включает
          более гибкую систему конфигурации процесса загрузки.  Если вы хотите,
          вы можете использовать метод, указанный выше для FreeBSD 3.1.  Если
          же вы хотите использовать формат PCX, замените
          <literal>splash_bmp</literal> на <literal>splash_pcx</literal>.  С
          другой стороны, если вы хотите использовать новую систему
          конфигурации процесса загрузки, вам нужно создать файл
          <filename>/boot/loader.rc</filename>, содержащий следующие
          строки:</para>

        <programlisting>
include /boot/loader.4th
start
        </programlisting>

        <para>и файл <filename>/boot/loader.conf</filename> со строками:</para>

        <programlisting>
splash_bmp_load="YES"
bitmap_load="YES"
        </programlisting>

        <para>Здесь предполагается, что в качестве заставки вы используете файл
          <filename>/boot/splash.bmp</filename>.  Если вы используете PCX-файл,
          скопируйте его под именем <filename>/boot/splash.pcx</filename>,
          создайте файл <filename>/boot/loader.rc</filename>, как указано
          выше, и создайте файл <filename>/boot/loader.conf</filename>, который
          содержит следующее:</para>

        <programlisting>
splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="/boot/splash.pcx"
        </programlisting>
      </listitem>
    </itemizedlist>
  </para>

  <para>Теперь всё, что вам нужно - это сама заставка.  Поищите заставки в
    галерее по адресу <ulink URL="http://www.baldwin.cx/splash/">
    http://www.baldwin.cx/splash/</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="windows-keys">
    <para>Можно ли в X использовать клавиши Windows(tm), которые есть на
      клавиатуре?</para>
  </question>

  <answer>

  <para>Да.  Всё, что вам нужно сделать, это с помощью &man.xmodmap.1;
    задать функции, которые вы хотите к этим клавишам привязать.</para>

  <para>Положим, что все клавиатуры <quote>Windows(tm)</quote> стандартны и
    3 клавиши имеют следующие клавиатурные коды</para>

  <itemizedlist>
    <listitem>
      <para>115 - клавиша Windows(tm), между клавишами Ctrl и Alt с левой
        стороны</para>
    </listitem>

    <listitem>
      <para>116 - клавиша Windows(tm), справа от клавиши Alt-Gr</para>
    </listitem>

    <listitem>
      <para>117 - клавиша вызова меню, слева от клавиши Ctrl, находящейся
        справа</para>
    </listitem>
  </itemizedlist>

  <para>Чтобы заставить левую клавишу Windows(tm) набирать запятую, попробуйте
    выполнить такую команду:</para>

  <screen>
    &prompt.root; <userinput>xmodmap -e "keycode 115 = comma"</userinput>
  </screen>

  <para>Чтобы увидеть результат, вам нужно будет перезапустить ваш оконный
    менеджер.</para>

  <para>Для того, чтобы переопределения клавиш Windows(tm) выполнялось
    автоматически каждый раз при запуске X, можно поместить вызов команд
    <command>xmodmap</command> в ваш <filename>~/.xinitrc</filename> либо,
    что предпочтительней, создать файл <filename>~/.xmodmaprc</filename> и
    включить в него параметры для <command>xmodmap</command>, по одному на
    строку, и добавить строку</para>

  <programlisting>xmodmap $HOME/.xmodmaprc</programlisting>

  <para>в ваш <filename>~/.xinitrc</filename>.</para>

  <para>Например, я переопределил эти 3 клавиши так, чтобы они выполняли
    функции F13, F14 и F15 соответственно.  Это позволяет легко привязать
    их к полезным функциям в приложениях или вашем менеджере окон.</para>

  <para>Чтобы сделать это, поместите в файл <filename>~/.xmodmaprc</filename>
    вот такие строки:</para>

  <programlisting>
    keycode 115 = F13
    keycode 116 = F14
    keycode 117 = F15
  </programlisting>

  <para>Я использую <command>fvwm2</command> и переопределил клавиши таким
    образом, что F13 сворачивает в иконку (или восстанавливает предыдущие
    размеры) окна, на которое указывает курсор, F14 перемещает окно с курсором
    на передний план или, если оно уже впереди, возвращает обратно, а F15
    вызывает главное меню Рабочего места (Workplace) (приложение), даже если
    курсор находится не на рабочем столе, что бывает полезно, если нет ни
    одного видимого кусочка рабочего стола (к тому же логотип на клавише
    соответствует этой функции).</para>

  <para>Вот строки из моего <filename>~/.fvwmrc</filename>, с помощью которых
    это достигается:</para>

  <programlisting>
    Key F13        FTIWS    A        Iconify
    Key F14        FTIWS    A        RaiseLower
    Key F15        A        A        Menu Workplace Nop
  </programlisting>

  </answer>
</qandaentry>

</qandaset>

</chapter>


<chapter id="networking">
<title>Работа в сети</title>

<qandaset>
<qandaentry>
  <question id="diskless-booting">
    <para>Где можно найти информацию о <quote>бездисковой
      загрузке</quote>?</para>
  </question>

  <answer>

  <para><quote>Бездисковая загрузка</quote> означает, что машина с FreeBSD
    загружается по сети и читает необходимые файлы с сервера, а не со своего
    диска.  Подробное описание есть в
    <ulink URL="../../handbook/diskless.html">соответствующей главе</ulink>
    Руководства.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="router">
    <para>Может ли машина с FreeBSD использоваться как маршрутизатор?</para>
  </question><answer>

  <para>Стандарты Internet и опыт практической работы не позволяют нам
    в FreeBSD держать маршрутизацию пакетов включенной по умолчанию.  Вы
    можете сделать это, изменив значение следующей переменной в файле <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf">rc.conf</ulink> на
    <literal>YES</literal>:</para>

  <programlisting>
gateway_enable=YES          # Set to YES if this host will be a gateway
  </programlisting>

  <para>Этот параметр изменит значение <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?sysctl">системной переменной</ulink>
    <filename>net.inet.ip.forwarding</filename> на <literal>1</literal>.</para>

  <para>Кроме того, в большинстве случаев вам будет необходимо запустить
    программу маршрутизации, для того, чтобы объявить о появлении нового
    маршрутизатора другим системам в вашей сети; FreeBSD поставляется со
    стандартной для BSD-систем программой маршрутизации <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?routed">routed</ulink>, в более
    сложных ситуациях вы можете попробовать <emphasis>GaTeD</emphasis>
    (доступный по адресу
    <ulink URL="http://www.gated.org/">http://www.gated.org </ulink>
    с <filename>ftp.gated.Merit.EDU</filename>), который
    поддерживает FreeBSD начиная с версии 3_5Alpha7.</para>

  <para>Мы обязаны предупредить вас, что даже когда FreeBSD настроена
    таким образом, она не полностью соответствует стандартам Internet 
    для маршрутизаторов, однако для обычной работы этого хватает.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="win95-connection">
    <para>Можно ли подключить машину с Win95 к Internet с помощью
      FreeBSD?</para>
  </question>

  <answer>

  <para>Как правило, те, кто задает такие вопросы, имеют дома два компьютера,
    один с FreeBSD, а другой с Win95; идея состоит в использовании
    FreeBSD для подключения к Internet, а затем осуществлять выход в
    Internet из Windows95 через FreeBSD. На самом деле это просто
    особый случай предыдущего вопроса.</para>

  <para> ... и ответ на него - да!  Во FreeBSD 3.x, ppp режима пользователя
    имеет параметр <option>-nat</option>.  Если вы запустите
    <command>ppp</command> с параметром <option>-nat</option>, установив
    в файле <filename>/etc/rc.conf</filename> <literal>gateway_enable</literal>
    в значение <emphasis>YES</emphasis> и правильно настроите машину с Windows,
    то всё должно прекрасно заработать.</para>

  <para>Более подробная информация о настройке может быть найдена в
    <ulink URL="http://www.FreeBSD.org/tutorials/ppp/index.html">Подробном
    Примере PPP</ulink> Стива Симса (Steve Sims).</para>

  <para>Если вы используете ppp режима ядра, или у вас Ethernet-подключение к 
    Internet, можно воспользоваться командой <command>natd</command>.
    Пожалуйста, обратитесь к разделу о <link linkend="natd">natd</link> этого
    FAQ.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="latest-bind">
    <para>Почему не проходит компиляция последней версии BIND от ISC?</para>
  </question>

  <answer>

  <para>Это - результат конфликта между файлом <filename>cdefs.h</filename> в
    дистрибутиве и тем, что поставляется с FreeBSD. Достаточно 
    удалить файл <filename>compat/include/sys/cdefs.h</filename>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="slip-ppp-support">
    <para>Поддерживает ли FreeBSD протоколы SLIP и PPP?</para>
  </question>

  <answer>

  <para>Да. Посмотрите страницы справочника по командам <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?slattach">slattach</ulink>, <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?sliplogin">sliplogin</ulink>,
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?pppd">pppd</ulink> и 
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink>.
    <command>Pppd</command> и <command>ppp</command> могут обслуживать как
    входящие, так и исходящие соединения. <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?sliplogin">Sliplogin</ulink> имеет
    дело исключительно со входящими соединениям,
    а <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?slattach">slattach</ulink>
    - только с исходящими.</para>

  <para>Эти программы описаны в следующих разделах
    <ulink URL="../../handbook/index.html">руководства</ulink>:</para>
  
  <para>     
    <itemizedlist>
      <listitem>
        <para><ulink URL="../../handbook/slips.html">
          Протокол SLIP (сервер)</ulink></para>
      </listitem>

      <listitem>
        <para><ulink URL="../../handbook/slipc.html">
          Протокол SLIP (клиент)</ulink></para>
      </listitem>

      <listitem>
        <para><ulink URL="../../handbook/ppp.html">
          Протокол PPP (режим ядра)</ulink></para>
      </listitem>

      <listitem>
        <para><ulink URL="../../handbook/ppp-and-slip.html#USERPPP">
          Протокол PPP (режим пользователя)</ulink></para>
      </listitem>
    </itemizedlist>
  </para>

  <para>Если вы имеете доступ в Internet через командную строку
    оболочки, вам может подойти <ulink
    URL="http://www.FreeBSD.org/cgi/ports.cgi?^slirp">slirp</ulink>.
    С его помощью можно получить (ограниченный) доступ к таким
    службам, как ftp и http прямо с вашей машины.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="natd">
    <para>Поддерживает ли FreeBSD NAT или Masquerading?</para>
  </question>

  <answer>

  <para>Если у вас есть локальная сеть (одна или больше машин), но только один
    IP адрес, предоставленный провайдером, вас может привлечь <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?natd">natd</ulink>.
    <command>natd</command> позволяет подключить всю сеть к Internet,
    используя единственный IP адрес.</para>

  <para>Программа <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink> имеет похожую
    встроенную возможность через параметр <option>-nat</option>.  В обоих
    случаях используется библиотека <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?libalias">libalias</ulink>.
    </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="create-dev-net">
    <para>Не могу создать устройство <filename>/dev/ed0</filename>!</para>
  </question>

  <answer>

  <para>В стандарте сетевого взаимодействия Беркли сетевые интерфейсы
    напрямую доступны только ядру.  За дополнительной информацией
    обратитесь к файлу <filename>/etc/rc.network</filename> и страницам
    справочника, описывающим различные сетевые программы, упоминаемые здесь.
    Если всё это оставит вас в недоумении, почитайте книгу, описывающую
    администрирование сети в другой BSD-подобной операционной системе;
    с некоторыми незначительными исключениями, администрирование сети
    во FreeBSD в основном совпадает с SunOS 4.0 и Ultrix.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ethernet-aliases">
    <para>Как настроить алиас на Ethernet?</para>
  </question>

  <answer>

  <para>Добавьте <literal>netmask 0xffffffff</literal> в командной строке
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ifconfig">ifconfig</ulink>
    так, как это сделано здесь:</para>

  <screen>
&prompt.root; <userinput>ifconfig ed0 alias 204.141.95.2 netmask 0xffffffff</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="port-3c503">
    <para>Как заставить адаптер 3C503 использовать другой тип сетевого
      разъёма?</para>
  </question>

  <answer>

  <para>Если вы хотите задействовать другой разъём, то должны указать
    дополнительный параметр в командной строке <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ifconfig">ifconfig</ulink>.
    Разъёмом по умолчанию является <literal>link0</literal>.  Чтобы
    задействовать разъём AUI, а не BNC, используйте <literal>link2</literal>.
    Эти флаги должны быть указаны с помощью переменных ifconfig_*
    в <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf">
    /etc/rc.conf</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="nfs">
    <para>У меня проблемы при работе NFS во FreeBSD.</para>
  </question>

  <answer>

  <para>Некоторые сетевые адаптеры работают (мягко говоря) хуже, чем другие
    что может иногда вызывать проблемы при работе приложений типа NFS,
    интенсивно использующих сеть.</para>

  <para>Подробности описаны в <ulink URL="../../handbook/nfs.html">
    соответствующей главе</ulink> Руководства, посвящённой NFS.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="nfs-linux">
    <para>Почему я не могу смонтировать диск Linux по NFS?</para>
  </question>

  <answer>

  <para>Некоторые версии NFS для Linux поддерживают запросы на монтирование
     только с привилегированного порта; попробуйте</para>

  <screen>
&prompt.root; <userinput>mount -o -P linuxbox:/blah /mnt</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="nfs-sun">
    <para>Почему я не могу смонтировать диск Sun по NFS?</para>
  </question>

  <answer>

  <para>Рабочие станции Sun под управлением SunOS 4.X поддерживают запросы
    на монтирование только с привилегированного порта; попробуйте</para>

  <screen>
&prompt.root; <userinput>mount -o -P sunbox:/blah /mnt</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="exports-errors">
    <para>Почему <command>mountd</command> продолжает выдавать сообщения
      <quote>can't change attributes</quote> и <quote>bad exports
      list</quote> на моем сервере NFS, работающем под управлением
      FreeBSD?</para>
  </question>

  <answer>

  <para>В большинстве случаев проблема заключается в недостаточном понимании
    следующей фразы из справочной страницы по &man.exports.5:</para>

  <blockquote>
    <para>Каждая строка файла (отличная от строк комментариев, начинающихся
      символом #) описывает точку (точки) монтирования и флаги экспорта
      внутри одной локальной файловой системы сервера для одного или большего
      количества хостов.  Для каждой локальной файловой системы сервер хост
      может быть указан только один раз, и для каждой файловой системы
      сервера может быть только одна используемая по умолчанию строка,
      которая используется при работе со всеми другими хостами.</para>
  </blockquote>

  <para>Наглядно это можно продемонстрировать на примере часто встречающейся
    ошибки.  Если все, находящееся выше <filename>/usr</filename>, является
    частью одной файловой системы (то есть нет точек монтирования выше
    <filename>/usr</filename>), то следующий список экспортирования будет
    неправильным:</para>

  <programlisting>
/usr/src   client
/usr/ports client
  </programlisting>

  <para>Здесь имееются две строки, описывающие свойства одной файловой
    системы, <filename>/usr</filename>, экспортируемой некоторому хосту с
    именем <hostid>client</hostid>.  Правильный формат таков:</para>

  <programlisting>/usr/src /usr/ports  client</programlisting>

  <para>Если перефразировать утверждение со страниц Справочника, то свойства
    одной файловой системы, экспортируемой некоторому хосту (экспортирование
    для всех интерпретируется как некий уникальный хост), должны быть описаны
    в одной строке.  Да, при этом возникают ограничения на то, как вы можете
    экспортировать файловые системы, но для большинства людей проблем это не
    вызывает.</para>

  <para>Ниже дается пример правильно составленного списка экпортирования, где
    <filename>/usr</filename> и <filename>/exports</filename> являются
    локальными файловыми системами:</para>

  <programlisting>
# Экспортировать src и ports для client01 и client02, но только
# client01 имеет на них права администратора
/usr/src /usr/ports -maproot=0    client01
/usr/src /usr/ports               client02
# "Клиентские" машины имеют корень и могут выполнять монтирование
# где угодно выше каталога.
# Все остальные могут монтировать /exports/obj только для чтения
/exports -alldirs -maproot=0      client01 client02
/exports/obj -ro
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-nextstep">
    <para>Проблемы при связи по PPP с машинами NeXTStep.</para>
  </question>

  <answer>

  <para>Попробуйте отменить все расширения TCP в <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf">/etc/rc.conf</ulink>,
    изменив значение следующей переменной в NO:</para>

  <programlisting>
tcp_extensions=NO
  </programlisting>

  <para>Маршрутизаторы Annex фирмы Xylogic не работают по этой же причине,
    поэтому при подключении к ним вам нужно проделать то же самое.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ip-multicast">
    <para>Как включить поддержку multicast IP?</para>
  </question>

  <answer>

  <para>Работа с многоадресной рассылкой по умолчанию полностью
    поддерживается версиями FreeBSD 2.0 и выше.  Если вы хотите использовать
    ваш компьютер как маршрутизатор многоадресного трафика, вам нужно
    перекомпилировать ядро с включенной опцией <literal>MROUTING</literal> и
    запустить <command>mrouted</command>.  Версии FreeBSD 2.2 и выше будут
    запускать <command>mrouted</command> во время загрузки, если переменная
    <literal>mrouted_enable</literal> в файле <filename>/etc/rc.conf</filename>
    установлена в значение <literal>YES</literal>.</para>

  <para>Приложения MBONE находятся в своей категории портов, mbone.  Если
    вы ищете приложения для организации конференций <command>vic</command> и
    <command>vat</command>, посмотрите там!</para>

  <para>Более подробная информация располагается на сервере
    <ulink URL="http://www.mbone.com/">Mbone Information Web</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="dec-pci-chipset">
    <para>Какие сетевые адаптеры сделаны на наборе микросхем DEC PCI?</para>
  </question>

  <answer>

  <para>Вот список, составленный <ulink
    URL="mailto:gfoster@driver.nsta.org">Гленом Фостером</ulink> (Glen Foster),
    с некоторыми незначительными добавлениями:</para>

  <programlisting>
Vendor          Model
----------------------------------------------
ASUS            PCI-L101-TB
Accton          ENI1203
Cogent          EM960PCI
Compex          ENET32-PCI
D-Link          DE-530
Dayna           DP1203, DP2100
DEC             DE435, DE450
Danpex          EN-9400P3
JCIS            Condor JC1260
Linksys         EtherPCI
Mylex           LNP101
SMC             EtherPower 10/100 (Model 9332)
SMC             EtherPower (Model 8432)
TopWare         TE-3500P
Znyx            (2.2.x) ZX312, ZX314, ZX342, ZX345, ZX346, ZX348
                (3.x) ZX345Q, ZX346Q, ZX348Q, ZX412Q, ZX414, ZX442,
                      ZX444, ZX474, ZX478, ZX212, ZX214 (10mbps/hd)
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="fqdn-hosts">
    <para>Почему я должен использовать FQDN для хостов не в моей сети?</para>
  </question>

  <answer>

  <para>Вы, наверное, обнаружили, что хост, к которому вы обратились, 
    оказался на самом деле в другом домене; например, если вы находитесь
    в домене foo.bar.edu и хотите обратиться к хосту <hostid>mumble</hostid> в
    домене <hostid role="domainname">bar.edu</hostid>, то должны указать его
    полное доменное имя, <hostid role="fqdn">mumble.bar.edu</hostid>, а не
    просто <hostid>mumble</hostid>.</para>

  <para>Традиционно, это позволял делать ресолвер BSD BIND. Однако текущая
    версия <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?named">bind</ulink>, 
    поставляемая с FreeBSD, больше не добавляет имена доменов, отличающихся от
    того, в котором вы находитесь, для не полностью указанных имён хостов.  Так
    что неполно указанный хост <hostid>mumble</hostid> будет найден либо как
    <hostid role="fqdn">mumble.foo.bar.edu</hostid>, либо будет искаться
    в корневом домене.</para>

  <para>Это отличается от предыдущего поведения, при котором поиск продолжался
    в <hostid role="fqdn">mumble.bar.edu</hostid>
    и <hostid role="domainname">mumble.edu</hostid>.
    Посмотрите RFC 1535 о причинах объявления такого поведения плохой
    практикой и даже ошибкой в безопасности.</para>

  <para>Как хорошее решение, вы можете поместить строку</para>

  <programlisting>
search foo.bar.edu bar.edu
  </programlisting>

  <para>вместо ранее используемой</para>

  <programlisting>
domain foo.bar.edu
  </programlisting>

  <para>в файл <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?resolv.conf">
    /etc/resolv.conf</ulink>.  Однако удостоверьтесь, что порядок поиска не
    нарушает <quote>границ полномочий между местным и внешним
    администрированием</quote>, как это названо в RFC 1535.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="network-permission-denied">
    <para><literal>Permission denied</literal> для любых действий, связанных с
      работой сети.</para>
  </question>

  <answer>

  <para>Если вы компилировали ядро с опцией <literal>IPFIREWALL</literal>,
    имейте в виду, что политика по умолчанию настроена как в 2.1.7R (она
    на самом деле изменилась во время разработки 2.1-STABLE), то есть указан
    запрет на прохождение всех пакетов, которые явно не разрешены.</para>

  <para>Если вы случайно неверно отконфигурировали межсетевой экран, то для
    восстановления работоспособность сети дайте такую команду, войдя
    суперпользователем:</para>

  <screen>
&prompt.root; <userinput>ipfw add 65534 allow all from any to any</userinput>
  </screen>

  <para>Также вы можете установить <literal>firewall_type='open'</literal> в
    файле <filename>/etc/rc.conf</filename>.</para>

  <para>Более подробная информация о конфигурировании межсетевого экрана в
    FreeBSD находится в <ulink
    URL="../../handbook/firewalls.html">соответствующем разделе</ulink>
    Руководства.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ipfw-overhead">
    <para>Какую нагрузку вызывает использование IPFW?</para>
  </question>

  <answer>

  <para>Ответ на этот вопрос зависит главным образом от набора правил
    и производительности процессора.  Для большинства приложений, имеющих
    дело с ethernet и простым набором правил, ответ: незначительно.  Для
    тех, кому нужны реальные цифры для удовлетворения любопытства,
    читайте дальше.</para>

  <para>Следующие измерения были сделаны с использованием 2.2.5-STABLE на
    машине 486-66.  IPFW был модифицирован для измерения времени,
    затрачиваемого внутри процедуры <literal>ip_fw_chk</literal> и вывода
    результатов на консоль каждую тысячу пакетов.</para>

  <para>Тестировались два набора по 1000 правил в каждом.  Первый набор был
    предназначен для демонстрации наихудшего случая, повторяя условие</para>

  <screen>
&prompt.root; <userinput>ipfw add deny tcp from any to any 55555</userinput>
  </screen>

  <para>Это наихудший случай, так как все условия IPFW будут проверены
    перед тем, как будет принято окончательное решение о том, что пакет
    не соответствует условию (мы меняли номер порта).  После 999
    повторений этого условия находилось правило
    <literal>allow ip from any to any</literal>.</para>

  <para>Второй набор был предназначен для быстрого прерывания
    процесса проверки условий:</para>

  <screen>
&prompt.root; <userinput>ipfw add deny ip from 1.2.3.4 to 1.2.3.4</userinput>
  </screen>

  <para>Неподходящий IP-адрес источника для указанного условия
    быстро вызывает пропуск этого правила.  Как и ранее, последним правилом
    было <literal>allow ip from any to any</literal>.</para>

  <para>Затраты на обработку пакета в первом случае было примерно 2.703
    мс/пакет, или примерно 2.7 микросекунд на правило.  Таким образом,
    теоретический предел скорости обработки пакетов с этими правилами
    равен примерно 370 пакетам в секунду.  Предполагая использование
    ethernet 10Мб/с с размером пакета примерно 1500, мы можем достигнуть
    только 55.5% использования пропускной способности.</para>

  <para>В последнем случае на обработку каждого пакета было затрачено
    примерно 1.172мс, или около 1.2 микросекунд на правило.  Теоретический
    предел обработки будет равен около 853 пакетам в секунду, что почти
    соответствует скорости 10Мб/с ethernet.</para>

  <para>Большое количество протестированных правил и природа этих правил
    не даёт представление о реальной жизни - они были использованы
    только для генерации информации о времени обработки.  Вот 
    несколько наблюдений, которые нужно иметь в виду для построении
    эффективного набора правил:</para>

  <para>     
    <itemizedlist>
      <listitem>
        <para>Поместите правило `established' в самое начало списка для
          обработки основного трафика TCP.  Не помещайте перед ним никаких
          правил <literal>allow tcp</literal>.</para>
      </listitem>

      <listitem>
        <para>Старайтесь помещать часто вызываемые правила как можно раньше,
          а редко используемые - позже (<emphasis remap=bf>без изменения
          политики</emphasis>, конечно).  Вы можете выяснить частоту
          использования правил с помощью вывода статистики командой
          <command>ipfw -a l</command>.</para>
      </listitem>
    </itemizedlist>
  </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="service-redirect">
    <para>Как можно перенаправить запросы с одной машины на другую?</para>
  </question>

  <answer>

  <para>Вы можете перенаправить запрос на FTP (или другой сервис) с помощью
    пакаджа <literal>socket</literal>, доступного в дереве портов в категории
    <quote>sysutils</quote>.  Просто замените командную строку запуска сервиса
    на вызов socket, типа:</para>

  <programlisting>
ftp stream tcp nowait nobody /usr/local/bin/socket socket <replaceable>ftp.foo.com</replaceable> <replaceable>ftp</replaceable>
  </programlisting>

  <para>где <replaceable>ftp.foo.com</replaceable>
    и <replaceable>ftp</replaceable> являются соответственно хостом и портом
    для перенаправления.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="bandwidth-mgr-tool">
    <para>Где можно найти средства управления сетевым трафиком?</para>
  </question>

  <answer>

  <para>Для FreeBSD существуют два средства управления трафиком: свободно
    распространяемый <ulink
    URL="http://www.csl.sony.co.jp/person/kjc/programs.html">ALTQ</ulink>
    и коммерческий продукт Bandwidth Manager от <ulink 
    URL="http://www.etinc.com/">Emerging Technologies</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="bpf-not-configured">
    <para>Почему появляются сообщения
      <literal>/dev/bpf0: device not configured</literal>?</para>
  </question>

  <answer>

  <para>Для работы программ, использующих Berkeley Packet Filter <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?bpf">(bpf)</ulink> необходимо
    включение в ядро соответствующего драйвера.  Перекомпилируйте ядро, добавив
    в его конфигурационный файл следующую строку:</para>

  <programlisting>
pseudo-device bpfilter # Berkeley Packet Filter
  </programlisting>

  <para>Затем, после перезапуска системы, вам нужно создать соответствующий файл
    устройства.  Это можно сделать, сменив текущий каталог на 
    <filename>/dev</filename> и выполнив команду</para>
 
  <screen>
&prompt.root; <userinput>sh MAKEDEV bpf0</userinput>
  </screen>

  <para>Обратитесь к разделу руководства, посвящённому <ulink
    URL="../../handbook/kernelconfig-nodes.html">созданию файлов
    устройств</ulink> за подробной информацией по этому вопросу.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="mount-smb-share">
    <para>Как смонтировать диск Windows-машины в моей локальной сети, как это
      делает smbmount в Linux?</para>
  </question>

  <answer>

  <para>Воспользуйтесь пакетом <ulink
    URL="http://www.freebsd.org/cgi/ports.cgi?query=%5Esharity-light-&;amp;stype=name">sharity
    light</ulink> из Коллекции Портов.</para>

  <!-- XXX update for bp's SMBFS in CURRENT, when it is imported! -->

  </answer>
</qandaentry>


<qandaentry>
  <question id="icmp-response-bw-limit">
    <para>Что значат эти сообщения <quote>icmp-response bandwidth limit
      300/200 pps</quote> в моих журнальных файлах?</para>
  </question>

  <answer>

  <para>Это ядро сообщает вам, что имела место некоторая активность,
    приводящая к посылке большего количества ответных пакетов ICMP или
    сбросов TCP (RST), чем, как предполагается, это следует делать.  Ответы
    ICMP часто генерируются в результате попыток подключения к незанятым
    портам UDP.  Сбросы TCP генерируются в результате попыток подключения к
    неоткрытым портам TCP.  Кроме всяких прочих, такие сообщения могут быть
    вызваны следующими действиями:</para>

  <itemizedlist>
    <listitem>
      <para>Лобовая атака типа отказ в обслуживании DoS (в отличие от атак в
        один пакет, которые используют конкретную брешь в защите).</para>
    </listitem>

    <listitem>
      <para>Сканирование портов в попытке осуществить подключение к большому
        количеству портов (в отличие от проб нескольких известных
        портов).</para>
    </listitem>
  </itemizedlist>

  <para>Первое число в сообщении указывает вам, какое количество пакетов
    ядро посылало бы при отсутствии ограничений, а второе число указывает
    лимит.  Вы можете управлять этим ограничением при помощи системной
    переменной <varname>net.inet.icmp.icmplim</varname> приводимым ниже
    способом, где <literal>300</literal> является ограничением на количество
    посылаемых пакетов в секунду:</para>

  <screen>
&prompt.root; <userinput>sysctl -w net.inet.icmp.icmplim=300</userinput>
  </screen>

  <para>Если вы не хотите видеть подобные сообщения в журнальных файлах, но
    хотите использовать это ограничение в ядре, то можете использовать
    системную переменную <varname>net.inet.icmp.icmplim_output</varname>
    для подавления вывода, как это показано здесь:</para>

  <screen>
&prompt.root; <userinput>sysctl -w net.inet.icmp.icmplim_output=0</userinput>
  </screen>

  <para>И наконец, если вы хотите выключить это ограничение, то можете
    установить значение системной переменной
    <varname>net.inet.icmp.icmplim</varname> (смотрите пример выше) равным
    <literal>0</literal>.  Выключение этого лимита не приветствуется по
    причинам, перечисленным выше.</para>

  </answer>
</qandaentry>

</qandaset>
</chapter>


<chapter id="ppp">
<title>PPP</title>

<qandaset>
<qandaentry>
  <question id="userppp">
    <para>Не могу заставить работать ppp. Что я делаю не так?</para>
  </question>

  <answer>

  <para>Первым делом прочтите <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">страницы
    справочника</ulink>, посвящённые ppp, а также соответствующий <ulink
    URL="../../handbook/ppp-and-slip.html#USERPPP">раздел</ulink> Руководства.
    Включите протоколирование командой</para>

  <programlisting>
set log Phase Chat Connect Carrier lcp ipcp ccp command
  </programlisting>

  <para>Эта команда может быть набрана в командной строке <emphasis
    remap=bf>ppp</emphasis> или она может находиться в конфигурационном файле
    <filename>/etc/ppp/ppp.conf</filename> (начало секции <emphasis
    remap=bf>default</emphasis> - лучшее для неё место. Удостоверьтесь, что
    файл <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?syslog.conf">
    /etc/syslog.conf</ulink> содержит строки</para>

  <programlisting>
!ppp
*.*    /var/log/ppp.log
  </programlisting>

  <para>и файл <filename>/var/log/ppp.log</filename> существует. Теперь вы
    сможете найти полную информацию о происходящем в файле протокола. Не
    беспокойтесь, если не всё вам будет там понятно.  Если вы будете
    пользоваться чьей-то помощью, протокол вам пригодится.</para>

  <para>Если ваша версия ppp не понимает команду <command>set log</command>, вы
    должны скачать <ulink URL="http://people.FreeBSD.org/~brian/">последнюю
    версию</ulink>.  Она рассчитана на FreeBSD версий 2.1.5 и выше.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-hangs">
    <para>Ppp просто зависает, когда я его запускаю</para>
  </question>

  <answer>

  <para>Обычно это происходит, когда не может быть определено имя вашего хоста.
    Наилучший способ исправить это - удостовериться, что файл
    <filename>/etc/hosts</filename> используется вашим ресолвером.
    Отредактируйте файл <filename>/etc/host.conf</filename>, поместив
    на первое место строчку <literal>hosts</literal>.  Затем просто добавьте
    записи о вашей машине в файл <filename>/etc/hosts</filename>.  Если у вас
    нет локальной сети, измените строку <hostid>localhost</hostid>:</para>

  <programlisting>
127.0.0.1        foo.bar.com foo localhost
  </programlisting>

  <para>В противном случае просто добавьте ещё одну запись о вашем хосте.
    Обратитесь к соответствующим страницам справочника за подробным
    описанием.</para>

  <para>Если вы выполнили эти указания, вы сможете успешно выполнить
    команду <command>ping -c1 `hostname`</command>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-nodial-auto">
    <para>Ppp не звонит в режиме -auto</para>
  </question>

  <answer>

  <para>Во-первых, проверьте, что у вас есть маршрут по умолчанию.  Выполнив
    команду <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?netstat">netstat -rn</ulink>, вы
    должны увидеть две строки такого вида:</para>

  <programlisting>
Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0
  </programlisting>

  <para>Здесь предполагается, что вы использовали адреса, 
    приведённые в Руководстве, Справочнике или файле
    ppp.conf.sample. Если у вас нет маршрута по умолчанию, это
    может быть из-за использования старой версии
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink>, которая не
    понимает слова <literal>HISADDR</literal> в файле
    ppp.conf. Если ваша версия <emphasis remap=bf>ppp</emphasis> из FreeBSD
    версий ранее чем 2.2.5, замените строку</para>

  <programlisting>
add 0 0 HISADDR
  </programlisting>

  <para>на</para>

  <programlisting>
add 0 0 10.0.0.2
  </programlisting>

  <para>Другой причиной отсутствия маршрута по умолчанию может быть
    то, что вы ошибочно установили маршрут по умолчанию в вашем файле <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?rc.conf">/etc/rc.conf</ulink>
    (этот файл назывался <filename>/etc/sysconfig</filename>
    до 2.2.2-RELEASE), и вы пропустили строку</para>

  <programlisting>
delete ALL
  </programlisting>

  <para>в <filename>ppp.conf</filename>.  В таком случае обратитесь к
    соответствующему <ulink
    URL="../../handbook/ppp-and-slip.html#USERPPP-FINAL">разделу</ulink>
    Руководства.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="no-route-to-host">
    <para>Что означает сообщение <literal>No route to host</literal>?</para>
  </question>

  <answer>

  <para>Эта ошибка появляется из-за отсутствующего раздела</para>

  <programlisting>
MYADDR:
  delete ALL
  add 0 0 HISADDR
  </programlisting>

  <para>в файле <filename>/etc/ppp/ppp.linkup</filename>. Он необходим, если ваш
    IP адрес выделяется динамически или адрес маршрутизатора вам не
    известен.  Если вы используете интерактивный
    режим, вы можете набрать следующие команды после входа в
    <emphasis remap=tt>пакетный режим</emphasis> (пакетный режим
    идентифицируется заглавными буквами <acronym>PPP</acronym> в
    приглашении):</para>

  <programlisting>
delete ALL
add 0 0 HISADDR
  </programlisting>

  <para>Обратитесь к разделу <ulink
    URL="../../handbook/ppp-and-slip.html#USERPPP-DYNAMICIP">PPP и
    динамические IP адреса</ulink> Руководства за подробной информацией.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="connection-threeminutedrop">
    <para>Соединение разрывается через 3 минуты</para>
  </question>

  <answer>

  <para>Таймаут для ppp по умолчанию равен 3 минутам.  Это может быть
    изменено строкой</para>

  <programlisting>
set timeout <replaceable>NNN</replaceable>
  </programlisting>

  <para>где <replaceable>NNN</replaceable> - время неактивности в секундах,
    после которого соединение закрывается.  Если <replaceable>NNN</replaceable>
    равно нулю, соединение никогда не разрывается по таймауту.  Эту команду
    можно поместить в файл <filename>ppp.conf</filename> или набрать ее в
    интерактивном режиме.  Изменение этого параметра также возможно при
    активном соединении, если подключиться к сокету <emphasis
    remap=bf>ppp</emphasis> сервера с помощью программ
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?telnet">telnet</ulink>
    или <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?pppctl">pppctl</ulink>.
    Обратитесь к страницам Справочника, посвящённым
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-drop-heavy-load">
    <para>Соединение разрывается при большой нагрузке</para>
  </question>

  <answer>

  <para>Если у вас включен Link Quality Reporting (LQR), возможно,
    что слишком много пакетов LQR теряется в канале.  Ppp делает вывод,
    что канал плох, и разрывает соединение. В FreeBSD до версии 2.2.5
    LQR было включено по умолчанию.  Сейчас оно по умолчанию выключено.
    LQR можно выключить строкой</para>

  <programlisting>
disable lqr
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-drop-random">
    <para>Соединение разрывается в случайные промежутки времени</para>
  </question>

  <answer>

  <para>Иногда, на шумной линии или даже на линии с включенным режимом
    ожидания звонка, ваш модем может вешать трубку, думая (совершенно
    напрасно), что потерял несущую.</para>

  <para>В большинстве модемов есть параметр, определяющий чувствительность
    к временной потере несущей.  Например, в модеме USR Sportster,
    это определяется значением регистра S10 в десятых долях секунды.
    Чтобы сделать связь более устойчивой, добавьте следующую
    последовательность посылок-ожиданий в строку набора:</para>

  <programlisting>
set dial "...... ATS10=10 OK ......"
  </programlisting>

  <para>Обратитесь к руководству по вашему модему.</para>
  
  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-hangs-random">
    <para>Соединение часто рвётся в случайные промежутки времени</para>
  </question>

  <answer>

  <para>Многие сообщают об обрывах соединений без видимой причины.  Первым 
    делом нужно выяснить, с какой стороны соединения рвётся связь. </para>

  <para>Если вы используете внешний модем, можете просто попробовать
    использовать утилиту <command>ping</command> и посмотреть, мигает ли
    индикатор <acronym>TD</acronym> при передаче данных.  Если он мигает (а
    индикатор <acronym>RD</acronym> нет), проблема с той стороны.  Если
    индикатор <acronym>TD</acronym> не загорается, проблема
    с вашей стороны.  При использовании внутреннего модема вам необходимо
    воспользоваться командой <literal>set server</literal>, указав её в файле
    <filename>ppp.conf</filename>.  Когда произойдёт обрыв связи, подключитесь
    к ppp с помощью pppctl.  Если ваше сетевое подключение неожиданно
    восстановится (ppp оживает при проявлении активности на диагностическом
    сокете) или или если вы не сможете соединиться (здесь мы полагаем, что
    команда <literal>set socket</literal> в начальный момент была выполнена
    успешно), то проблема имеет локальный характер.  Если вы сможете
    подключиться, но связи всё равно нет, включите вывод отладочной информации
    командой <literal>set log local async</literal> и запустите
    <command>ping</command> из другого окна или терминала, чтобы проверить
    связь.  В отладочном выводе будут показаны данные,
    передаваемые и получаемые из канала связи.  Если данные посылаются,
    но не принимаются обратно, проблема с противоположной стороны.</para>
  
  <para>Выяснив, является эта проблема локальной или удалённой системы,
    вы имеете следующие возможности:</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-remote-not-responding">
    <para>Удалённая система не отвечает</para>
  </question>

  <answer>

  <para>Здесь вы мало что можете сделать.  Большинство провайдеров
    отказываются оказать помощь, если вы используете ОС не от Microsoft.
    Вы можете добавить команду <literal>enable lqr</literal> в ваш
    <filename>ppp.conf</filename>, что позволит ppp отследить ошибки в
    удалённой системе и закрывать соединение, однако такое обнаружение
    достаточно медленно и поэтому
    не так уж полезно.  Вы можете также просто не сообщать своему
    провайдеру, что запускаете user-ppp....</para>

  <para>Первым делом попробуйте отключить всю местную компрессию, 
    указав в конфигурационном файле следующее:</para>

  <programlisting>
disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj
  </programlisting>

  <para>Теперь попробуйте установить соединение ещё раз и удостовериться,
    что ситуация не изменилась.  Если качество соединения улучшилось
    или проблема оказалась полностью решённой, выясните, настройка
    чего приводила к проблемам методом проб и ошибок.  Это даст вам
    дополнительную защиту, когда вы будете разговаривать с вашим
    провайдером (хотя при этом может обнаружиться, что вы работаете
    не с продуктом Microsoft). </para>

  <para>Перед тем, как звонить провайдеру, включите вывод отладочной
    информации, как вы это делали ранее и подождите, пока соединение
    снова не прервётся.  Правда, для этого требуется некоторое
    дисковое пространство.  Интерес могут представлять последние
    прочитанные из порта данные.  Обычно это данные в формате ascii
    и они могут даже содержать описание проблемы (<quote>Memory fault,
    core dumped</quote> ?).</para>

  <para>Если ваш провайдер согласен помочь вам, нужно будет включить
    режим отладки с их стороны, а потом, когда связь прервётся в
    следующий раз, они могут сказать вам, почему возникли проблемы
    с их стороны.  Будет хорошо, если вы пришлёте детальное описание
    на адрес &a.brian;, или даже попросите провайдера связаться
    со мной напрямую.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-hung">
    <para>Ppp зависает</para>
  </question>

  <answer>

  <para>Лучше всего в этом случае перекомпилировать ppp, добавив параметры
    <literal>CFLAGS+=-g</literal> и <literal>STRIP=</literal> в конец
    Makefile, а затем выполнить команду
    <command>make clean &amp;&amp; make &amp;&amp; make install</command>.
    Когда ppp зависнет, найдите идентификатор процесса ppp с помощью команды
    <command>ps ajxww | fgrep ppp</command> и выполните команду
    <command>gdb ppp <replaceable>PID</replaceable></command>.  Затем в
    приглашении gdb вы можете использовать команду <command>bt</command> для
    получения стека вызовов.</para>

  <para>Пошлите результат на адрес <email>brian@Awfulhak.org</email>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-loginok-thennothing">
    <para>Ничего не происходит после сообщения Login OK!</para>
  </question>

  <answer>

  <para>До версии FreeBSD 2.2.5, как только связь устанавливалась, <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink> ожидал начала
    согласования Line Control Protocol
    (LCP) с противоположной стороны.  Многие провайдеры Internet не
    начинают согласования и предполагают, что это сделает клиент.
    Чтобы заставить <emphasis remap=bf>ppp</emphasis> инициировать согласование
    параметров LCP, используйте следующую строку:</para>

  <programlisting>
set openmode active
  </programlisting>

  <para><emphasis remap=bf>Замечание</emphasis>: Ничего страшного не
    произойдёт, если согласование
    начнут обе стороны, поэтому режим инициирования сейчас
    по умолчанию активный.  Однако, в следующем разделе описывается
    ситуация, когда это <emphasis remap=bf>приводит</emphasis> к некоторым
    неприятностям.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-same-magic">
    <para>В протоколе есть сообщения о том, что <quote>magic being the
      same</quote>.</para>
  </question>

  <answer>

  <para>Иногда, сразу же после установления соединения, вы можете увидеть
    сообщения в протоколе, говорящие что <quote>magic is the same</quote>.
    Иногда эти сообщения проходят безболезненно, а иногда одна из сторон
    прекращает работу.  Большинство реализаций ppp не может справиться с
    такой ситуацией, и, даже когда связь выглядит установившейся, вы
       будете видеть только бесконечно повторяющиеся конфигурационные
    запросы и подтверждения в файле протокола до тех пор, пока ppp
    окончательно не закроет соединение.</para>

  <para>Обычно это происходит на серверах с медленными дисками, на
    которых порт обслуживает программа getty, а ppp выполняется из
    сценария регистрации или другой программы после регистрации
    пользователя.  Были сообщения, что такое случается постоянно при
    использовании slirp.  Причина заключается в том, что во время,
    проходящее между завершением работы getty и запуском ppp, ppp
    со стороны клиента начинает посылать пакеты Line Control Protocol
    (LCP).  Так как режим эха остаётся всё ещё включенным, ppp клиента
    получает <quote>отражения</quote> своих запросов.</para>

  <para>Частью процесса согласования параметров LCP является определение
    <quote>магического</quote> числа для каждой стороны соединения для
    обнаружения <quote>отражений</quote>.  Согласно спецификации, когда одна
    сторона пытается использовать совпадающее "магическое" число, должен быть
    послан ответ
    NAK и должно быть выбрано новое "магическое" число.  В тот момент,
    когда на порту сервера включен режим эха, клиент ppp посылает пакеты
    LCP, получает то же самое "магическое" число в отражённом пакете и
    отвечает на него NAK.  Он также видит отражённый NAK (который также
    означает, что ppp должен изменить своё "магическое" число).  В
    потенциале это может вызвать появление огромного количества процессов
    смен "магических" чисел, и все они накапливаются в буфере терминала.
    Как только запустится сервер ppp, он будет перегружен запросами на
    смену "магических", немедленно решит, что этого много для согласования
    LCP и прервёт соединение.  В то же самое время, клиент, который больше 
    не видит отражений, останавливается для того, чтобы увидеть, что
    сервер закрыл соединеие.</para>

  <para>Этого можно избежать, позволив начинать согласование 
    противоположной стороне следующей строкой в файле ppp.conf:</para>

  <programlisting>
set openmode passive
  </programlisting>

  <para>Это заставит ppp ожидать начала согласования LCP.  Некоторые
    серверы, однако, могут никогда не начать согласование.  Если это тот
    самый случай, вы можете сделать следующее:</para>

  <programlisting>
set openmode active 3
  </programlisting>

  <para>Это заставит ppp пассивно ждать 3 секунды, и только затем посылать
    запросы LCP.  Если противоположная сторона начнёт посылать в этот
    момент запросы, ppp немедленно ответит, не ожидая истечения
    трёхсекундного интервала.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-lcp-constant">
    <para>Согласование LCP продолжается, пока не закроется соединение</para>
  </question>

  <answer>

  <para>В настоящий момент одной из неприятных особенностей
    реализации <emphasis remap=bf>ppp</emphasis> является то, что она не
    связывает сообщения LCP, CCP &amp; IPCP с запросами.  Как результат, если
    реализация <emphasis remap=bf>ppp</emphasis> с одной стороны более чем на
    6 секунд медленнее, чем с
    другой, противоположная сторона будет посылать два дополнительных
    запроса на согласование параметров LCP. Это фатально.</para>

  <para>Предположим, что у нас работают две реализации, <emphasis
    remap=bf>A</emphasis> и <emphasis remap=bf>B</emphasis>.
    <emphasis remap=bf>A</emphasis> начинает посылать запросы LCP сразу же
    после соединения, а
    <emphasis remap=bf>B</emphasis> требуется 7 секунд для запуска.  Когда
    <emphasis remap=bf>B</emphasis> запускается,
    <emphasis remap=bf>A</emphasis> послало 3 LCP-запроса.  Полагаем, что
    режим эха выключен,
    в противном случае мы столкнулись бы с проблемами "магического"
    числа, описанные в предыдущем разделе.  <emphasis remap=bf>B</emphasis>
    посылает REQ, затем
    ACK на первый REQ от <emphasis remap=bf>A</emphasis>.  Это приводит к тому,
    что <emphasis remap=bf>A</emphasis> входит
    в состояние <acronym>OPENED</acronym> и посылает (первый) ACK обратно
    <emphasis remap=bf>B</emphasis>.  В
    то же самое время <emphasis remap=bf>B</emphasis> посылает обратно ещё два
    ACK в ответ на
    два дополнительных REQ, посланные <emphasis remap=bf>A</emphasis> до старта
    <emphasis remap=bf>B</emphasis>.  <emphasis remap=bf>B</emphasis>
    затем получает первый ACK от <emphasis remap=bf>A</emphasis> и
    возвращается в состояние
    <emphasis remap=bf>REQ-SENT</emphasis>, послав ещё один (четвёртый) REQ
    согласно RFC.  Затем
    он получает третий ACK и входит в состояние <acronym>OPENED</acronym>.  В
    то же
    время <emphasis remap=bf>B</emphasis> принимает четвёртый REQ от <emphasis
    remap=bf>A</emphasis>, что возвращает
    его в состояние <emphasis remap=bf>ACK-SENT</emphasis> и посылает ещё один
    (второй) REQ
    и (четвёртый) ACK согласно RFC.  <emphasis remap=bf>A</emphasis> получает
    REQ, переходит
    в состояние <emphasis remap=bf>REQ-SENT</emphasis> и посылает ещё один
    REQ.  Он немедленно
    принимает последующий ACK и входит в
    состояние <acronym>OPENED</acronym>.</para>

  <para>Это будет продолжаться до тех пор, пока одна из сторон не
    обнаружит, что это ни к чему не приводит и не закроет соединение.</para>

  <para>Лучшим способом избежать этой ситуации является конфигурация
    одной из сторон как <emphasis remap=bf>passive</emphasis>, чтобы она ждала
    другую для
    начала согласования.  Это можно сделать командой</para>

  <programlisting>
set openmode passive
  </programlisting>

  <para>С этой командой нужно быть осторожным.  Вы также должны будете
    использовать команду</para>

  <programlisting>
set stopped N
  </programlisting>

  <para>для ограничения периода ожидания, в течении которого <emphasis
    remap=bf>ppp</emphasis> ждёт
    начала согласования с противоположной стороны.  Как вариант, может
    быть использована строка</para>

  <programlisting>
set openmode active N
  </programlisting>

  <para>(где <emphasis remap=bf>N</emphasis> - период ожидания в секундах
    перед тем, как начать согласование).</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-lockups">
    <para>Вскоре после соединения ppp блокируется</para>
  </question>

  <answer>

  <para>В версиях FreeBSD ранее 2.2.5, была возможна ситуация, 
    когда связь выключалась очень скоро после соединения из-за
    некорректной обработки запроса на согласования сжатия данных
    <emphasis remap=bf>ppp</emphasis>.  Это случалось, когда обе стороны
    пытались установить разные типы CCP (Compression Control Protocol).  Эта
    проблема
    сейчас решена, но если вы всё ещё используете старую версию
    <emphasis remap=bf>ppp</emphasis>, проблема может быть обойдена с помощью
    строки</para>

  <programlisting>
disable pred1
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-shell-test-lockup">
    <para>Когда я выполняю команду shell для тестирования соединения,
      ppp блокируется</para>
  </question>

  <answer>

  <para>Когда вы выполняете команду <command>shell</command> или
    <command>!</command>, <command>ppp</command> запускает оболочку (если были
    заданы параметры, <emphasis remap=bf>ppp</emphasis> их 
    использует).  Ppp будет ждать окончания выполнения команды, прежде
    чем продолжить.  Если вы попытаетесь воспользоваться связью ppp
    после запуска команды, связь будет выглядеть заблокированной.  Это
    происходит из-за того, что <command>ppp</command> ждёт завершения
    выполнения запущенной команды.</para>

  <para>Если вам необходимо выполнять подобные команды, используйте
    команду <command>!bg</command>.  В этом случае нужная команда будет
    выполняться в фоновом режиме, а ppp сможет продолжить обслуживание канала
    связи.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-nullmodem">
    <para>Ppp, обслуживающее нуль-модем, никогда не закрывается</para>
  </question>

  <answer>

  <para><emphasis remap=bf>Ppp</emphasis> не может определить, что соединение
    было закрыто.
    Это происходит из-за метода использования сигнальных линий 
    нуль-модемного кабеля.  При использовании такого типа соединения
    всегда включайте LQR.</para>

  <programlisting>
enable lqr
  </programlisting>

  <para>По умолчанию LQR включается, если это было затребовано с
    противоположной стороны на этапе согласования параметров
    соединения.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-auto-noreasondial">
    <para>В режиме -auto ppp неожиданно начинает звонить</para>
  </question>

  <answer>

  <para>Если <emphasis remap=bf>ppp</emphasis> начинает неожиданно звонить, вы
    должны определить
    причину и задать фильтры dfilters для предотвращения подобных
    звонков.</para>

  <para>Для выяснения причины такого поведения, используйте строку:</para>

  <programlisting>
set log +tcp/ip
  </programlisting>

  <para>Это включит протоколирование всего трафика через соединение.  В
    следующий раз, когда неожиданно будет установлено соединение,
    вы установите причину по временным отметкам в файле протокола.</para>

  <para>После этого вы можете запретить дозвонку при выясненных
    условиях.  Как правило, такие проблемы возникают из-за обращений
    к DNS.  Для предотвращения обращений к DNS и установления соединения
    (что <emphasis remap=bf>не</emphasis> запретит <emphasis
    remap=bf>ppp</emphasis> пропускать пакеты через уже
    установленное соединение), используйте такую комбинацию:</para>

  <programlisting>
set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0
  </programlisting>

  <para>Это может вам не подойти, так как закроет возможность дозвонки
    по запросу - большинству программ нужно обратиться к DNS до того,
    как начать работать.</para>

  <para>В случае DNS, вы должны попытаться определить, кто пытается
    определить имя хоста.  В большинстве случаев виновным оказывается
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?sendmail">sendmail</ulink>.
    Удостоверьтесь, что вы указали программе sendmail
    не осуществлять обращений к DNS в его конфигурационном файле.  
    Обратитесь к разделу о <link linkend="ispmail">настройке почты</link>
    за подробным описанием создания конфигурационного файла и что туда
    нужно поместить.  Вам может понадобиться добавить в файл
    <filename>.mc</filename> строку:</para>

  <programlisting>
define(`confDELIVERY_MODE', `d')dnl
  </programlisting>

  <para>Это заставит sendmail ставить все сообщения в очередь до тех пор, пока
    не будет запущена её обработка (как правило, sendmail запускается с
    параметрами <option>-bd -q30m</option>, указывающими, что
    обрабатывать очередь нужно каждые 30 минут) или до тех пор, пока 
    не будет выполнена команда <command>sendmail -q</command> (может быть, из
    файла ppp.linkup).</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ccp-errors">
    <para>Что означают ошибки CCP</para>
  </question>

  <answer>

  <para>В файле протокола появляются такие сообщения об ошибках:</para>

  <programlisting>
CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)
  </programlisting>

  <para>Это происходит, если ppp пытается установить компрессию 
    типа Predictor1, а противоположная сторона не хочет устанавливать
    никакой компрессии. Эти сообщения безобидны, но если вы хотите
    от них избавиться, вы можете запретить компрессию Predictor1 и
    у себя тоже:</para>

  <programlisting>
disable pred1
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-lockup-ioerrors">
    <para>Ppp блокируется во время передачи файла с ошибками
      ввода-вывода</para>
  </question>

  <answer>

  <para>В FreeBSD 2.2.2 и ранее существовала ошибка в драйвере устройства
    tun, которая не позволяла проходить пакетам размером, превышающим
    значение MTU интерфейса.  Приём пакета, большего, чем размер MTU,
    приводит к ошибке ввода-вывода, который протоколируется через
    syslogd.</para>

  <para>Спецификация протокола ppp утверждает, что MRU, равное 1500,
    должно <emphasis remap=bf>всегда</emphasis> подходить как минимальное,
    несмотря на
    согласование LCP, таким образом, если сделать MTU меньше
    1500, ваш провайдер может начать передавать пакеты размером 1500,
    несмотря ни на что, и вы это почувствуете - ваше соединение
    заблокируется.</para>

  <para>Проблема может быть обойдена, если никогда не ставить MTU,
    меньшее, чем 1500, для FreeBSD 2.2.2 и ранее.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-connectionspeed">
    <para>Почему ppp не протоколирует скорость соединения?</para>
  </question>

  <answer>

  <para>Для вывода протокола взаимодействия с модемом вам нужно
    включить следующее:</para>

  <programlisting>
set log +connect
  </programlisting>

  <para>Это заставит <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ppp">ppp</ulink> протоколировать
    всё, вплоть до последней прочтённой через <quote>expect</quote>
    строки.</para>

  <para>Если вы хотите видеть скорость соединения и используете
    PAP или CHAP (и поэтому вам не нужно определять никаких сценариев
    входа через <literal>set login</literal> после получения строки CONNECT
    сценарием дозвонки dial), вы должны указать ppp, что нужно ожидать полную
    строку CONNECT, вроде следующего:</para>

  <programlisting>
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \
  \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"
  </programlisting>

  <para>Здесь мы получили строку CONNECT, ничего не посылаем, затем
    ожидаем символа перевода строки, заставляя <emphasis
    remap=bf>ppp</emphasis> принять полный ответ модема.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-ignores-backslash">
    <para>Ppp игнорирует символ <literal>\</literal>
      в chat-скрипте</para>
  </question>

  <answer>

  <para>Ppp обрабатывает каждую строку в ваших конфигурационных файлах, так что
    он может проинтерпретировать строку вида
    <literal>set phone "123 456 789"</literal> правильно (и
    обнаружить. что номер является на самом деле
    <emphasis remap=bf>единственным</emphasis> аргументом. Для того, чтобы
    указать символ <literal>"</literal>, вы должны экранировать его символом
    обратного слэша (<literal>\</literal>).</para>

  <para>Когда интерпретатор chat обрабатывает каждую строку, он ещё раз
    просматривает аргумент для того, чтобы найти какую-либо специальную
    последовательность типа <literal>\P</literal> или <literal>\T</literal>
    (обратитесь к Справочнику).  В результате этой двойной интерпретации вы
    должны всегда использовать правильное число экранирующих символов.</para>

  <para>Если вам нужно передать символ <literal>\</literal>, например, вашему
    модему, вам необходимо указать что-то типа:</para>

  <programlisting>
set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"
  </programlisting>

  <para>что приведёт к такой последовательности:</para>

  <programlisting>
ATZ
OK
AT\X
OK
  </programlisting>

  <para>или</para>

  <programlisting>
set phone 1234567
set dial "\"\" ATZ OK ATDT\\T"
  </programlisting>

  <para>что даст такую последовательность:</para>

  <programlisting>
ATZ
OK
ATDT1234567
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-segfault-nocore">
    <para>Ppp получает ошибку защиты, но я не вижу файла
      <filename>ppp.core</filename></para>
  </question>

  <answer>

  <para>Ppp (или любая другая программа такого рода) никогда не
    создаёт файлов дампа памяти.  Так так ppp запускается с
    эффективным uid, равным 0, то операционная система не будет 
    записывать дамп памяти ppp на диск перед его завершением.  Если,
    однако ppp <emphasis remap=bf>всё же</emphasis> прекратит работу из-за
    нарушения защиты,
    или по другому сигналу, который вызывает создание дампа памяти,
    <emphasis remap=bf>и</emphasis> вы уверены, что используете самую
    последнюю версию (смотрите
    самое начало раздела), то вы должны сделать следующее:</para>

  <screen>
&prompt.user; <userinput>tar xfz ppp-*.src.tar.gz</userinput>
&prompt.user; <userinput>cd ppp*/ppp</userinput>
&prompt.user; <userinput>echo STRIP= &gt;&gt;Makefile</userinput>
&prompt.user; <userinput>echo CFLAGS+=-g &gt;&gt;Makefile</userinput>
&prompt.user; <userinput>make clean all</userinput>
&prompt.user; <userinput>su</userinput>
&prompt.root; <userinput>make install</userinput>
&prompt.root; <userinput>chmod 555 /usr/sbin/ppp</userinput>
  </screen>

  <para>Теперь у вас есть отладочная версия ppp. Вам нужно
    стать суперпользователем для запуска ppp, так как соответствующие
    биты прав были убраны. Когда запустите ppp, обратите особое внимание
    на то, какой каталог у вас был текущим на этот момент.</para>

  <para>Итак, если ppp получит ошибку нарушения защиты, он сбросит дамп 
    памяти с именем ppp.core.  Затем вам нужно сделать следующее:</para>

  <screen>
&prompt.user; <userinput>su</userinput>
&prompt.root; <userinput>gdb /usr/sbin/ppp ppp.core</userinput>
<prompt>(gdb)</prompt> <userinput>bt</userinput>
.....
<prompt>(gdb)</prompt> <userinput>f 0</userinput>
....
<prompt>(gdb)</prompt> <userinput>i args</userinput>
....
<prompt>(gdb)</prompt> <userinput>l</userinput>
.....
  </screen>

  <para>Вся эта информация должна быть предоставлена вместе с вашим
    вопросом, чтобы проблему можно было продиагностировать.</para>

  <para>Если вы умеете обращаться с gdb, вы можете попробовать найти
    причины образования дампа, а также адреса и значения относящихся
    к этому переменных.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-autodialprocess-noconnect">
    <para>Процесс, вызвавший прозвонку в режиме auto, никогда не получает
      затребованного соединения</para>
  </question>

  <answer>

  <para>Эта проблема проявлялась, когда <emphasis remap=bf>ppp</emphasis> в
    режиме auto был настроен на динамическое согласование локального IP-адреса
    с противоположной стороной.  Это исправлено в последней версии -
    поищите на странице справочника слово <literal>iface</literal>.</para>

  <para>Причиной было то, что когда эта программа использует системный
    вызов <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?connect">
    connect(2)</ulink>, для сокета назначается IP-адрес tun-интерфейса.
    Ядро создаёт первый исходящий пакет и записывает его в устройство
    tun. Затем <emphasis remap=bf>ppp</emphasis> читает пакет и устанавливает
    соединение.  Если
    в результате согласования <emphasis remap=bf>ppp</emphasis> динамического
    IP-адреса,
    адрес интерфейса изменется, сокет будет работать некорректно.  Любые
    IP-пакеты, передаваемые через сокет, будут отброшены.  Если даже
    этого не произойдёт, ответные данные не будут достигать отправителя,
    так как этот адрес больше ему не принадлежит.</para>

  <para>Теоретически есть несколько способов решить эту проблему.
    Лучше всего, если противоположная сторона назначит интерфейсу тот же
    самый IP-адрес <emphasis remap=tt>:-)</emphasis>  Текущая версия <emphasis
    remap=bf>ppp</emphasis> именно так и
    поступает, более ранние реализации этого не делали.</para>

  <para>Самым простым решением будет просто никогда не менять IP-адрес
    tun-интерфейса, а вместо этого изменять на лету все исходящие пакеты так,
    чтобы IP-адрес источника менялся с IP-адреса интерфейса на соответствующий
    с противоположной стороны.  Это, в сущности, то же самое, что делает опция
    <emphasis remap=tt>iface-alias</emphasis> в последней версии <emphasis
    remap=bf>ppp</emphasis> (с помощью библиотеки <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?libalias">libalias(3)</ulink>
    и ключа <option>-nat</option> для ppp) - она отслеживает все назначенные
    ранее интерфейсу адреса и замещает их на последний из назначенных.</para>

  <para>Другой возможный (и, наверное, самый надёжный) способ - это
    создать системный вызов, меняющий IP-адреса всем уже связанным
    сокетам.  <emphasis remap=bf>Ppp</emphasis> использовал бы этот вызов для
    модификации сокетов
    всех работающих программ после согласования нового IP-адреса.  Этот
    же самый системный вызов могли бы использовать клиенты DHCP, когда
    они осуществляют повторную привязку к сокету.</para>

  <para>Ещё одной возможностью является разрешение интерфейсу становиться
    активным без IP-адреса.  Исходящим пакетам будет даваться IP адрес
    255.255.255.255 до тех пор, пока не будет дан ioctl-запрос SIOCAIFADDR.
    приводящий к полной привязке сокета.  <emphasis remap=bf>Ppp</emphasis>
    нужно будет изменять
    IP-адрес источника и контрольную сумму пакета, только если он
    установлен в 255.255.255.255. Это, однако, является некоторым
    хаком, так как ядро будет посылать некорректные пакеты на не полностью
    сконфигурированный интерфейс, в предположении, что существует
    механизм исправления этих пакетов.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ppp-nat-games">
    <para>Почему большинство игр не работает с опцией -nat?</para>
  </question>

  <answer>

  <para>Причиной, по которой игры и подобные программы не работают с
    библиотекой libalias заключается в том, что внешняя машина будет пытаться
    открыть соединение или посылать (нежданные) UDP пакеты на машину
    внутренней сети.  Программное обеспечение, обеспечивающее опцию -nat, не
    знает о том, что она должна пересылать эти пакеты машине внутренней
    сети.</para>

  <para>Чтобы это всё же заработало, удостоверьтесь, что единственной
    запущенной программой является программное обеспечение, с которым вы
    испытываете проблемы, затем напустите tcpdump на tun-интерфейс
    маршрутизатора либо включите протоколирование tcp/ip
    в ppp (<literal>set log +tcp/ip</literal>) на маршрутизаторе.</para>

  <para>Когда вы запустите некорректно работающее программное обеспечение,
    вы должны увидеть пакеты, проходящие через маршрутизатор.  Когда
    что-то начнёт приходить извне, оно будет отброшено (в этом-то и
    проблема).  Заметьте номер порта получателя этих пакетов, затем
    завершите работу вашего программного обеспечения.  Выполните эту
    процедуру несколько раз для того, чтобы убедиться, что номер порта
    постоянен.  Если это так, то следующая строчка в соответствующем
    разделе /etc/ppp/ppp.conf заставит программное обеспечение
    функционировать нормально:</para>

  <programlisting>
nat port <replaceable>proto</replaceable> <replaceable>internalmachine</replaceable>:<replaceable>port</replaceable> <replaceable>port</replaceable>
  </programlisting>

  <para>Здесь <replaceable>proto</replaceable> - это <literal>tcp</literal>
    либо <literal>udp</literal>, <replaceable>internalmachine</replaceable> -
    это машина, которой вы хотите перенаправлять пакеты,
    и <replaceable>port</replaceable> - это номер порта получателя
    пакетов.</para>

  <para>Несомненно, вы не сможете использовать программное обеспечение на
    других машинах, не изменяя указанную выше команду, а также запускать
    программное обеспечение на двух машинах внутри сети одновременно -
    в конце концов, внешний мир видит всю вашу сеть как единственную
    машину.</para>
  
  <para>Если номера портов непостоянны, есть ещё три варианта:</para>

  <para><emphasis remap=bf>1)</emphasis> Настройте поддержку этого в
    libalias.  Примеры <quote>особых случаев</quote> можно найти в
    <filename>/usr/src/lib/libalias/alias_*.c</filename>
    (<filename>alias_ftp.c</filename> - хорошее начало).  Это
    означает, что вам нужно будет использовать чтение некоторых распознаваемых
    исходящих пакетов, обнаруживать команды для установления внешней машиной
    обратной связи на внутреннюю машину на конкретный (случайный) порт и
    настраивать <quote>маршрут</quote> в таблице соответствий так, чтобы
    последующие пакеты проходили нормально.</para>

  <para>Это самое трудоёмкое решение, но оно наилучшее и позволит программному
    обеспечению работать на нескольких машинах.</para>

  <para><emphasis remap=bf>2)</emphasis> Используйте прокси-сервера.
    Приложение может поддерживать, например, socks5 или (как в случае
    <quote>cvsup</quote>) может иметь режим <quote>passive</quote>, обходящийся
    без запросов к противоположной стороне на открытие обратного
    соединения.</para>

  <para><emphasis remap=bf>3)</emphasis> Переназначьте всё на внутреннюю
    машину с помощью команды <literal>nat addr</literal>.  Это решение в
    лоб.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="useful-port-numbers">
    <para>Кто-нибудь ведёт список полезных номеров портов?</para>
  </question><answer>

  <para>Пока нет, но ниже находится список, могущий таковым стать (если
    к этому будет проявлен какой-либо интерес).  В каждом примере
    <replaceable>internal</replaceable> нужно заменить на IP-адрес машины,
    участвующей в игре.</para>

  <itemizedlist>
    <listitem>
      <para><application>Asheron's Call</application></para>

      <para><literal>nat port udp
        <replaceable>internal</replaceable>:65000 65000</literal></para>

      <para>Находясь в игре, вручную смените номер порта на 65000.  Если
        у вас есть несколько машин, на которых вы хотите играть, назначьте
        каждой машине уникальный номер порта (то есть 65001, 65002 и так
        далее), и добавьте по строчке <literal>nat port</literal> для каждой
        машины.</para>
    </listitem>

    <listitem>
      <para><application>Half Life</application></para>

      <para><literal>nat port udp
        <replaceable>internal</replaceable>:27005 27015</literal></para>
    </listitem>

    <listitem>
      <para><application>PCAnywhere 8.0</application></para>

      <para><literal>nat port udp
        <replaceable>internal</replaceable>:5632 5632</literal></para>

      <para><literal>nat port tcp
        <replaceable>internal</replaceable>:5631 5631</literal></para>
    </listitem>

    <listitem>
      <para><application>Quake</application></para>

      <para><literal>nat port udp
        <replaceable>internal</replaceable>:6112 6112</literal></para>

      <para>Альтернативное решение, обеспечивающее поддержку прокси для
        Quake, можно найти на сервере <ulink 
        URL="http://www.battle.net/support/proxy/">
        www.battle.net</ulink>.</para>
    </listitem>

    <listitem>
      <para><application>Quake 2</application></para>

      <para><literal>nat port udp
        <replaceable>internal</replaceable>:27901 27910</literal></para>
    </listitem>

    <listitem>
      <para><application>Red Alert</application></para>

      <para><literal>nat port udp
        <replaceable>internal</replaceable>:8675 8675</literal></para>

      <para><literal>nat port udp
        <replaceable>internal</replaceable>:5009 5009</literal></para>
    </listitem>
  </itemizedlist>

  </answer>
</qandaentry>


<qandaentry>
  <question id="fcs-errors">
    <para>Что такое ошибки FCS?</para>
  </question>

  <answer>

  <para>FCS является сокращением от <emphasis
    remap=bf>F</emphasis>rame <emphasis remap=bf>C</emphasis>heck <emphasis
    remap=bf>S</emphasis>equence
    (контроль последовательности кадров).  Каждый кадр ppp имеет
    контрольную сумму для проверки того, что принятые данные совпадают
    с переданными.  Если FCS принятого пакета некорректна, пакет 
    отбрасывается и счётчик FCS для HDLC увеличивается.  Значения ошибок
    уровня HDLC можно вывести командой <literal>show hdlc</literal>.</para>

  <para>Если у вас плохая линия (или драйвер коммуникационного адаптера
    отбрасывает пакеты), ошибки FCS неизбежны.  Это обычно не является
    причиной для волнений, хотя это существенно замедляет протоколы
    компрессии.  Если у вас внешний модем, проверьте качество
    экранирования соединительного кабеля - это может избавить от
    проблемы.</para>

  <para>Если ваша связь замирает, как только вы соединились и
    наблюдается большое количество ошибок FCS, это может быть вызвано
    не полной прозрачностью канала для 8-битовых данных.  Проверьте, что
    модем не использует программного управления потоком (XON/XOFF).  Если же
    оборудование <emphasis>должно</emphasis> , использовать программное
    управление потоком, то воспользуйтесь командой <literal>set accmap
    0x000a0000</literal> для указания <command>ppp</command> экранировать
    символы <literal>^Q</literal> и <literal>^S</literal>.</para>

  <para>Другой причиной слишком большого количества ошибок FCS может
    быть прекращение противоположной стороной сеанса <acronym>PPP</acronym>.
    В этом случае Вам может понадобиться включить протоколирование
    <literal>async</literal> для проверки того, не являются ли поступаемые из
    линии данные на самом деле приглашениями login или shell.  Если вы 
    получили приглашение shell с противоположной стороны, возможно
    завершение ppp без обрыва связи командой <emphasis remap=tt>close
    lcp</emphasis> (последующая команда <emphasis remap=tt>term</emphasis>
    снова вернёт вас к приглашению
    shell на удалённой машине).</para>

  <para>Если ничего в файле протокола не говорит о том, что связь
    была прервана, вы должны спросить у администратора удалённой
    машины (вашего провайдера), почему сеанс был закрыт.</para>

  </answer>
</qandaentry>


<qandaentry id=PPPoEwithNAT>
  <question id="macos-win98-pppoe-freeze">
    <para>Почему при работе в MacOS и Windows 98 соединения замирают, когда на
      маршрутизаторе используется PPPoE</para>
  </question>

  <answer>

  <para>Мы благодарим Майкла Возняка (Michael Wozniak)
    <email>mwozniak@netcom.ca</email>, который сообщил следующую информацию, и
    Дэна Флемминга (Dan Flemming) <email>danflemming@mac.com</email> за решение
    проблемы в случае Mac:</para>

  <para>Это происходит из-за эффекта, который можно назвать <quote>чёрной
    дырой</quote> на маршрутизаторе.  MacOS и Windows 98 (и, может быть,
    другие операционные
    системы от Microsoft), посылают пакеты TCP с запрашиваемым размером
    сегмента, который слишком велик для того, чтобы быть помещённым в кадр
    PPPoE (для сети ethernet размер MTU по умолчанию равен 1500) <emphasis
    remap=bf>и</emphasis> с установленным битом <quote>не
    фрагментировать</quote> (по умолчанию для TCP), а маршрутизаторы Telco не
    посылает пакет ICMP <quote>нужно фрагментировать</quote> обратно на сайт
    www, с которым вы работаете.  (Либо маршрутизатор посылает пакеты ICMP
    правильно, а межсетевой экран на стороне веб-сервера их сбрасывает.)  Когда
    веб-сервер посылает вам кадры, которые не помещаются в поток PPPoE, то
    маршрутизаторы Telco их отбрасывают и странички не загружаются (часть
    страниц/графики всё же видно, потому что они меньше, чем MSS).  Похоже,
    что такие настройки действуют по умолчанию на большинстве конфигураций
    PPPoE Telco (если они вообще знают, как программировать маршрутизатор...
    да уж...).</para>

  <para>Одним из способов исправить это является использование утилиты regedit
    на машинах 96/98 для того, чтобы добавить в реестр следующий
    параметр...</para>

  <literallayout>
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\NetTrans\0000\MaxMTU
  </literallayout>

  <para>Это должна быть строка со значением <quote>1450</quote> (точнее,
    <quote>1464</quote>, чтобы размещать пакеты TCP точно по размеру кадра
    PPPoE, однако <quote>1450</quote> даёт вам некоторый запас в случае
    других протоколов IP, которые вы можете использовать).  В Windows 2000 этот
    параметр реестра был переименован в
    <literal>Tcpip\Parameters\Interfaces\<replaceable>ID
    адаптера</replaceable>\MTU</literal>.</para>

  <para>Обратитесь к документам из <ulink
    URL="http://search.support.microsoft.com/kb">Microsoft Knowledge
    Base</ulink> <quote>Q158474 - Windows TCPIP Registry Entries</quote> и
    <quote>Q120642 - TCPIP & NBT Configuration Parameters for Windows
    NT</quote> для получения подробной информации по изменению
    MTU в Windoze для работы с маршрутизатором FreeBSD/NAT/PPPoE.</para>

  <para>К несчастью, в MacOS нет возможности изменить настройки TCP/IP.  Однако
    имеется коммерческое программное обеспечение, такое, как OTAdvancedTuner
    (OT for OpenTransport, the MacOS TCP/IP stack) компании <ulink
    URL="http://www.softworks.com/">Sustainable Softworks</ulink>, которое
    позволяет пользователям настраивать параметры TCP/IP.  Пользователи MacOS
    NAT должны выбрать <literal>ip_interface_MTU</literal> из выпадающего меню,
    ввести число <literal>1450</literal> вместо <literal>1500</literal> в окне,
    затем щёлкнуть на кнопке, следующей за <literal>Save as Auto
    Configure</literal>, и щёлкнуть на <literal>Make Active</literal>.</para>

  <para>В самой последней версии <emphasis remap=bf>ppp</emphasis>
    (2.3 и выше) имеется команда <command>enable
    tcpmssfixup</command>, которая автоматически выравнивает значение
    MSS к нужному.  Эта возможность по умолчанию включена.  Если у
    вас возникли проблемы с более старой версией <emphasis
    remap=bf>ppp</emphasis>, то вас может заинтересовать порт
    <emphasis remap=bf>tcpmssd</emphasis>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="desperation">
    <para>Ничего не помогает - я уже отчаялся!</para>
  </question>

  <answer>

  <para>Если всё уже перепробовано, и ничего не получается, пошлите нам
    максимальное количество информации, ваш конфигурационный файл, 
    способ запуска <emphasis remap=bf>ppp</emphasis>, соответствующие части
    файла протокола, и вывод команды <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?netstat">netstat -rn</ulink>
    (до и после соединения) в адрес списка рассылки
    <email>freebsd-questions@FreeBSD.org</email> или в телеконференцию <ulink
    URL="news:comp.unix.bsd.freebsd.misc">comp.unix.bsd.freebsd.misc</ulink>,
    и может быть, кто-нибудь укажет вам верное направление.</para>

  </answer>
</qandaentry>
</qandaset>
</chapter>


<chapter
id="serial">
<title>Коммуникационные адаптеры</title>

<para>В этом разделе освещены вопросы о работе последовательных
   адаптеров во FreeBSD.  Протоколы PPP и SLIP рассматриваются в разделе,
   посвящённом <xref linkend="networking" remap="работе в сети">.</para>

<qandaset>
<qandaentry>
  <question id="found-serial">
    <para>Как узнать, какие последовательные порты были обнаружены
      FreeBSD?</para>
  </question>

  <answer>

  <para>При загрузке ядра FreeBSD оно будет пытаться найти последовательные
    порты, с поддержкой которых было откомпилировано.  Вы можете
    повнимательней присмотреться к выдаваемым сообщениям либо выполнить
    команду</para>

  <screen>
&prompt.user; <userinput>dmesg | grep sio</userinput>
  </screen>

  <para>после загрузки и запуска системы.</para>

  <para>Вот пример вывода указанной команды:</para>

  <programlisting>
sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
  </programlisting>

  <para>Здесь присутствуют два последовательных порта.  Первый использует irq
    4, порт ввода/вывода <literal>0x3f8</literal> и построен на микросхеме
    UART типа 16550A.  Второй использует тот же тип микросхемы, но использует
    irq 3 и адрес порта ввода/вывода <literal>0x2f8</literal>.  Внутренние
    модемы выглядят точно также, как последовательные порты, за исключением
    того, что к модем ним <quote>подключен</quote> всегда.</para>

  <para>В ядро <filename>GENERIC</filename> встроена поддержка двух
    последовательных портов, с irq и адресами портов ввода/вывода, как в
    примере выше.  Если эти настройки не соответствуют вашим, или если вы
    добавили внутренние модемы, или у вас больше последовательных портов, чем
    описано в ядре, просто переконфигурируйте ядро.  За дополнительной
    информацией обратитесь к разделу <link linkend="make-kernel">о построении
    ядра</link>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="found-modem">
    <para>Как узнать, какие внутренние модемы были обнаружены FreeBSD?</para>
  </question>

  <answer>

  <para>Посмотрите ответ на предыдущий вопрос.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="missing-tty0X">
    <para>Я только что поставил 2.0.5 и не нашёл устройств
      <filename>tty0X</filename>!</para>
  </question>

  <answer>

  <para>Не волнуйтесь, просто они были объединены с устройствами
    <filename>ttydX</filename>.  Вам придётся подправить конфигурационные
    файлы, которые вы раньше использовали.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="access-serial-ports">
    <para>Как осуществляется доступ к последовательным портам во
      FreeBSD?</para>
  </question>

  <answer>

  <para>Третий последовательный порт, <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?sio">sio2</ulink> (который в
    DOS называется COM3), называется <filename>/dev/cuaa2</filename> для
    устройств, выполняющих исходящие звонки, и <filename>/dev/ttyd2</filename>
    для устройств,
    принимающих входящие звонки.  Какая разница между этими двумя классами
    устройств?</para>

  <para>Вы должны использовать <filename>ttydX</filename> для входящих
    соединений.  При открытии <filename>/dev/ttydX</filename> в блокирующем
    режиме, процесс будет ожидать неактивности соответствующего устройства
    <filename>cuaaX</filename>, а затем появления сигнала о наличии несущей.
    При открытии устройства <filename>cuaaX</filename>, он проверяет, что
    последовательный порт не используется уже устройством
    <filename>ttydX</filename>.  Если порт доступен, он <quote>похищает</quote>
    его у устройства <filename>ttydX</filename>.  Также устройство
    <filename>cuaXX</filename> не следит за наличием несущей.  С такой схемой
    работы и модемом, находящимся в режиме автоответа, вы можете позволить
    пользователям входить в систему и в то же время можете осуществлять
    исходящие звонки, а система позаботится о возможных конфликтах.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="enable-multiport-serial">
    <para>Как включить поддержку многопортовых последовательных
      адаптеров?</para>
  </question>

  <answer>

  <para>Повторим ещё раз: информация о конфигурировании ядра содержится в 
    разделе, посвящённом этому вопросу.  Для многопортовых последовательных
    адаптеров в файле конфигурации ядра поместите ключевое слово
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?sio">sio</ulink>
    для каждого порта на адаптере.  Но irq и вектор должен быть указан
    только у одного порта.  Все порты на адаптере должны использовать одно
    и то же irq.  Используйте последний последовательный порт для указания
    irq. Также включите опцию <literal>COM_MULTIPORT</literal>.</para>

  <para>В следующем примере дано описание 4-портового адаптер AST на irq
    7:</para>

  <programlisting>
options "COM_MULTIPORT"
device sio4 at isa? port 0x2a0 tty flags 0x781
device sio5 at isa? port 0x2a8 tty flags 0x781
device sio6 at isa? port 0x2b0 tty flags 0x781
device sio7 at isa? port 0x2b8 tty flags 0x781 irq 7 vector siointr
  </programlisting>

  <para>Флаги указывают, что управляющий порт имеет младший номер
    устройства 7 (<literal>0x700</literal>), включена диагностика на время
    обнаружения
    (<literal>0x080</literal>), и все порты используют одно и то же irq
    (<literal>0x001</literal>).</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="multiport-serial-share-irq">
    <para>Может ли FreeBSD использовать несколько многопортовых адаптеров
      с одинаковым irq?</para>
  </question>

  <answer>

  <para>Пока нет.  Вы должны назначить уникальный irq для каждого
    адаптера.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="default-serial-params">
    <para>Можно ли установить режим работы по умолчанию для порта?</para>
  </question>

  <answer>

  <para>Вашему приложению может понадобиться открыть устройства
    <filename>ttydX</filename> (или <filename>cuaaX</filename>).  Когда процесс
    открывает устройство, оно имеет набор параметров ввода/вывода.  Вы можете
    посмотреть их значения командой</para>

  <screen>
&prompt.root; <userinput>stty -a -f /dev/ttyd1</userinput>
  </screen>

  <para>Когда вы меняете настройки этого устройства, они действуют
    вплоть до закрытия устройства.  При повторном открытии оно будут
    иметь режимы работы по умолчанию.  Чтобы изменить значения режимов
    работы по умолчанию, вы можете открыть и изменить настройки в устройстве
    <quote>начального состояния</quote>.  Например, чтобы сделать режимом
    по умолчанию режим <acronym>CLOCAL</acronym>, 8 бит, и управление потоком
    <filename>XON/XOFF</filename> для устройства ttyd5, сделайте
    следующее:</para>

  <screen>
&prompt.root; <userinput>stty -f /dev/ttyid5 clocal cs8 ixon ixoff</userinput>
  </screen>

  <para>Для выполнения таких действий предназначен скрипт
    <filename>/etc/rc.serial</filename>.  Теперь при открытии устройства
    <filename>ttyd5</filename> приложение будет иметь именно такой режим
    работы с портом.  Оно, однако. может изменить эти режимы по своему
    усмотрению.</para>

  <para>Вы можете запретить изменение приложением некоторых режимов работы,
    выполнив настройки устройства <quote>постоянного состояния</quote>.
    Например, чтобы сделать скорость работы <filename>ttyd5</filename>
    постоянной и равной 57600 bps, выполните</para>

  <screen>
&prompt.root; <userinput>stty -f /dev/ttyld5 57600</userinput>
  </screen>

  <para>Теперь, если приложение откроет <filename>ttyd5</filename> и попытается
    изменить скорость работы порта, она всё равно останется равной 57600
    bps.</para>

  <para>Естественно, вы должны сделать устройства начального и
    постоянного состояний доступными на запись только пользователю
    <username>root</username>.  Скрипт <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?MAKEDEV">MAKEDEV</ulink>
    при создании файлов устройств этого <emphasis>НЕ</emphasis> делает.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="enable-dialup">
    <para>Как сделать вход через модем?</para>
  </question>

  <answer>

  <para>Похоже, что вы хотите стать Internet-провайдером, да?  Сначала
    вам необходимо подключить к системе один или несколько модемов,
    которые могут работать в режиме автоответа.  Модем должен держать
    сигнал наличия несущей, только когда она присутствует.  Он должен
    вешать трубку и переинициализировать, когда сигнал готовности 
    устройства DTE (<acronym>DTR</acronym>) меняет состояние из включенного на
    выключенный.  Должно использоваться аппаратное
    (<filename>RTS/CTS</filename>)
    управление потоком или вовсе отсутствовать.  Ещё он должен работать
    на постоянной скорости с портом компьютера, но (что удобно для
    звонящих) с согласованием скорости передачи с другим модемом.</para>

  <para>Для большинства модемов, поддерживающих набор команд Hayes,
    следующая последовательность команд выполнит эти настройки и
    сохранит их в энергонезависимой памяти:</para>

  <programlisting>
AT &amp;C1 &amp;D3 &amp;K3 &amp;Q6 S0=1 &amp;W
  </programlisting>

  <para>Информация о том, как сделать эти настройки без обращения к терминальным
    программам MS-DOS, содержится в разделе о <link
    linkend="direct-at">посылке AT-команд</link>.</para>

  <para>Затем опишите модем в файле <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>.
    В нём перечислены все порты, с которых операционная система ожидает
    входа пользователей.  Добавьте строку, которая выглядит как эта:</para>

  <programlisting>
ttyd1 "/usr/libexec/getty std.57600" dialup on insecure
  </programlisting>

  <para>В этой строке указано, что ко второму последовательному порту
    (<filename>/dev/ttyd1</filename>) подключен модем на скорости 57600 bps без
    контроля по чётности (<literal>std.57600</literal>, что берётся из файла
    <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?gettytab">/etc/gettytab</ulink>).
    Тип терминала для этого порта определён как <literal>dialup</literal>.
    Порт включен (<literal>on</literal>) и небезопасен
    (<literal>insecure</literal>), что означает, что попытки войти в систему
    пользователем root с этого порта будут отвергнуты.  Для портов,
    обслуживающих входящие звонки, как этот, используйте устройства вида
    <literal>ttydX</literal>.</para>

  <para>Использование слова <literal>dialup</literal> в качестве имени
    терминала является обычной практикой.  Многие пользователи включают в свои
    файлы .profile или .login скрипты для задания реального типа терминала, если
    начальным является тип dialup.  В примере порт описан небезопасным.
    Чтобы войти пользователем <username>root</username> на этом порту, вам
    нужно сначала войти обычным пользователем, а затем командой
    <command>su</command> стать пользователем <username>root</username>.  Если
    порт имеет атрибут <literal>secure</literal>, то пользователь
    <username>root</username> может входить с этого порта
    непосредственно.</para>

  <para>После модифицирования <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>, вам
    нужно послать сигнал потери связи или <acronym>HUP</acronym> процессу
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?init">init</ulink>:</para>

  <screen>
&prompt.root; <userinput>kill -HUP 1</userinput>
  </screen>

  <para>Это заставит процесс init снова прочитать файл <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>.
    Процесс init запустит процессы getty для всех портов с характеристикой
    <literal>on</literal>.  Вы можете проверить, доступны ли входы с
    конкретного порта, выполнив команду</para>

  <screen>
&prompt.user; <userinput>ps -ax | grep '[t]tyd1'</userinput>
  </screen>

  <para>Вы должны увидеть нечто вроде следующего:</para>

  <programlisting>
747 ??  I      0:00.04 /usr/libexec/getty std.57600 ttyd1
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="dumb-terminal">
    <para>Как подключить терминал к FreeBSD?</para>
  </question>

  <answer>

  <para>Если вы собираетесь использовать другой компьютер в качестве
    терминала для FreeBSD, соедините их последовательные порты 
    нуль-модемным кабелем.  Если у вас есть терминал, обратитесь к его
    документации.</para>

  <para>Затем модифицируйте файл <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ttys">/etc/ttys</ulink>
    описанным выше способом.  Например, если вы подключаете терминал
    WYSE-50 к пятому последовательному порту, используйте такую строчку:</para>

  <programlisting>
ttyd4 "/usr/libexec/getty std.38400" wyse50 on secure
  </programlisting>

  <para>В этом примере описан порт на <filename>/dev/ttyd4</filename>, имеющий
    терминал wyse50, подключенный на скорости 34800 bps без контроля по
    четности (<literal>std.38400</literal> из <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?gettytab">/etc/gettytab</ulink>) и
    разрешён непосредственный вход пользователя <username>root</username>
    (secure).</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="cannot-tip">
    <para>Почему не удаётся запустить <command>tip</command> или
      <command>cu</command>?</para>
  </question>

  <answer>

  <para>Скорее всего, в вашей системе запуск программ <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink> и <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?cu">cu</ulink> разрешён только
    пользователю <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?uucp">uucp</ulink> и членам группы
    <literal>dialer</literal>.  Вы можете использовать группу
    <literal>dialer</literal> для управления доступом к вашему модему или
    удалённым системам.  Достаточно добавить пользователя в группу
    dialer.</para>

  <para>Вы можете разрешить всем пользователям вашей системы запускать
    <command>tip</command> и <command>cu</command>, выполнив команды:</para>

  <screen>
&prompt.root; <userinput>chmod 4511 /usr/bin/cu</userinput>
&prompt.root; <userinput>chmod 4511 /usr/bin/tip</userinput>
  </screen>

  </answer>
</qandaentry>


<qandaentry>
  <question id="hayes-unsupported">
    <para>Мой модем Hayes не поддерживается---что можно сделать?</para>
  </question>

  <answer>

  <para>На самом деле страница Справочника о программе <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink> устарела.  Модемы
    Hayes поддерживаются системой.  Просто добавьте
    <literal>at=hayes</literal> в ваш файл <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink>.</para>

  <para>Драйвер модемов Hayes не достаточно умён, чтобы поддерживать
    некоторые из новых возможностей современных модемов---сообщения
    типа <literal>BUSY</literal>, <literal>NO DIALTONE</literal> или
    <literal>CONNECT 115200</literal> будут приводить его в замешательство.  Вы
    должны выключить вывод таких сообщений при использовании программы <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink> (командой
    <literal>ATX0&amp;W</literal>).</para>

  <para>Кроме того, значение таймаута по умолчанию для программы
    <command>tip</command> равен 60 секундам.  Ваш модем должен использовать
    меньшее значение, иначе tip будет думать, что у вас проблемы со связью.
    Попробуйте <literal>ATS7=45&amp;W</literal>.</para>

<para>На самом деле <emphasis remap=tt>tip</emphasis> в том виде, каком поставляется, не 
     поддерживает модемы Hayes полностью.  Решением является редактирование
     файла <filename>tipconf.h</filename> в каталоге <filename>/usr/src/usr.bin/tip/tip</filename>.
     Чтобы это сделать, вам нужен дистрибутив исходных текстов системы.</para>

  <para>Замените строку <literal>#define HAYES 0</literal> на <literal>#define
    HAYES 1</literal>.  Затем выполните команды <command>make</command> и
    <command>make install</command>.  После этих действий всё работает
    замечательно.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="direct-at">
    <para>Как я должен ввести эти AT-команды?</para>
  </question>

  <answer>

  <para>Создайте так называемое <quote>прямое</quote> описание в вашем файле
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink>.
    Например, если ваш модем подключен к первому последовательному порту,
    <filename>/dev/cuaa0</filename>, сделайте такую строку:</para>

  <programlisting>
cuaa0:dv=/dev/cuaa0:br#19200:pa=none
  </programlisting>

  <para>Укажите максимальную скорость обмена с портом, поддерживаемую
    модемом в параметре br.  Затем выполните команду <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip cuaa0</ulink> и
    вы подключитесь к модему.</para>

  <para>Если в вашей системе нет устройства <filename>/dev/cuaa0</filename>,
    сделайте следующее:</para>

  <screen>
&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV cuaa0</userinput>
  </screen>

  <para>Или используйте cu, войдя администратором, с такими параметрами:</para>

  <screen>
&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput>
  </screen>

  <para>где line - это имя последовательного порта (например,
    <filename>/dev/cuaa0</filename>), а speed - скорость работы модема с портом
    (например, <literal>57600</literal>).  После ввода AT-команд, наберите
    <literal>~.</literal> для завершения работы.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="gt-failure">
    <para>Знак <literal>&lt;@&gt;</literal> для описания характеристики pn
      не работает!</para>
  </question>

  <answer>

  <para>Знак <literal>&lt;@&gt;</literal> в характеристике, описывающей
    номер телефона, указывает программе tip обратиться к файлу
    <filename>/etc/phones</filename> для поиска телефонного номера.  Однако
    знак <literal>&lt;@&gt;</literal> является также и специальным символом в
    файлах описания характеристик типа <filename>/etc/remote</filename>.
    Экранируйте его символом обратного слэша:</para>

  <programlisting>pn=\@</programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="dial-command-line">
    <para>Как набрать телефонный номер из командной строки?</para>
  </question>

  <answer>

  <para>Поместите так называемое <quote>общее</quote> описание в ваш файл
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink>.
    Например:</para>

  <programlisting>
tip115200|Dial any phone number at 115200 bps:\
       :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
       :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:
  </programlisting>

  <para>Тогда вы сможете выполнять команды вроде <command>tip -115200
    5551234</command>.  Если предпочитаете программу <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?cu">cu</ulink>, а не <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink>, используйте
    общее описание для cu:</para>

  <programlisting>
cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:
  </programlisting>

  <para>и выполняйте команду <command>cu 5551234 -s 115200</command>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="set-bps">
    <para>Нужно ли при этом каждый раз задавать скорость работы с
      портом?</para>
  </question>

  <answer>

  <para>Создайте описание для <literal>tip1200</literal> или
    <literal>cu1200</literal>, но не останавливайтесь на этом и используйте
    подходящую скорость при задании характеристики br. <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?tip">Tip</ulink> полагает,
    что хорошим значением по умолчанию является 1200 bps, поэтому он
    использует описание для <literal>tip1200</literal>.  Однако вас никто не
    заставляет использовать именно эту скорость.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="terminal-server">
    <para>Мне нужно иметь доступ к нескольких хостам через терминальный
      сервер.</para>
  </question>

  <answer>

  <para>Вместо того, чтобы каждый раз ожидать подключения к терминальному
    серверу, а затем набирать команду <literal>CONNECT
    <replaceable>host</replaceable></literal>, используйте характеристику
    <literal>cm</literal> программы tip.  Например, вот такое описание в файле
    <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink>:</para>

  <programlisting>
pain|pain.deep13.com|Forrester's machine:\
       :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
       :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
       :dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:
  </programlisting>

  <para>позволит вам просто набирать <command>tip pain</command> или 
    <command>tip muffin</command> для подключения к хостам
    <hostid>pain</hostid> или <hostid>muffin</hostid> и
    <command>tip deep13</command> для доступа к терминальному серверу.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="tip-multiline">
    <para>Может ли tip использовать несколько телефонов для одного
      сайта?</para>
  </question>

  <answer>

  <para>Эта проблема возникает, когда в университете есть пара
    модемных входов и несколько тысяч студентов, пытающихся ими
    воспользоваться...</para>

  <para>Создайте описание для вашего университета в файле <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?remote">/etc/remote</ulink> и
    используйте <literal>&lt;\@&gt;</literal> при задании
    характеристики <literal>pn</literal>:</para>

  <programlisting>
big-university:\
       :pn=\@:tc=dialout
dialout:\
       :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:
  </programlisting>

  <para>После этого пропишите номера телефонов университета в файле <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?phones">/etc/phones</ulink>:</para>

  <programlisting>
big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114
  </programlisting>

  <para><ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">Tip</ulink> будет
    пытаться воспользоваться всеми телефонными номерами в указанном порядке,
    прежде чем завершить работу.  Если вы хотите, чтобы попытки были
    продолжены, запустите <command>tip</command> в цикле while.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="multi-controlp">
    <para>Почему нужно нажимать CTRL+P дважды для посылки одного этого
      символа?</para>
  </question>

  <answer>

  <para>По умолчанию CTRL+P является специальным символом <quote>принудительного
    ввода</quote>, используемым для указания программе <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink>, что
    следующий символ является байтом данных.  Вы можете назначить
    функцию символа принудительного ввода любому другому символу с помощью
    команды <literal>~s</literal>, которая предназначена для <quote>установки
    значений переменных</quote>.</para>

  <para>Наберите
    <literal>~sforce=<replaceable>single-char</replaceable></literal>'' с
    начала новой строки.  Здесь под <replaceable>single-char</replaceable>
    имеется в виду любой одиночный символ.  Если вы не зададите
    <replaceable>single-char</replaceable>, то символом
    принудительного ввода будет нулевой символ, который можно получить,
    набрав CTRL+2 или CTRL+SPACE.  Подходящим значением для
    <replaceable>single-char</replaceable> может быть SHIFT+CTRL+6, который
    используется только некоторыми терминальными серверами.</para>

  <para>Вы можете задать любое значение для символа принудительного ввода,
    указав его в вашем файле <filename>&#36;HOME/.tiprc</filename>:</para>

  <programlisting>
force=<replaceable>single-char</replaceable>
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="uppercase">
    <para>Неожиданно всё стало набираться ЗАГЛАВНЫМИ БУКВАМИ?</para>
  </question>

  <answer>

  <para>Должно быть, вы нажали CTRL+A, символ <quote>перехода в верхний
    регистр</quote>
    программы <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?tip">tip</ulink>,
    специально предназначенный для тех, у кого не работает клавиша caps-lock.
    Используйте команду <literal>~s</literal>, как это было сделано
    выше, и установите значение переменной <quote>raisechar</quote> во
    что-нибудь подходящее.  В действительности вы можете установить его равным
    символу принудительного ввода, если не собираетесь пользоваться этими
    особенностями.</para>

  <para>Следующий пример файла .tiprc должен понравиться пользователям
    редактора Emacs, которым часто приходится нажимать CTRL+2 и CTRL+A:</para>

  <programlisting>
force=^^
raisechar=^^
  </programlisting>

  <para>Здесь ^^ обозначает SHIFT+CTRL+6.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="tip-filetransfer">
    <para>Как можно передавать файлы с помощью программы
      <command>tip</command>?</para>
  </question>

  <answer>

  <para>Если вы соединились с другой UNIX-системой, вы можете посылать и 
    принимать файлы командами <literal>~p</literal> (передача) и
    <literal>~t</literal> (приём).  Эти
    команды запускают программы <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?cat">cat</ulink> и <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?echo">echo</ulink> на
    удалённой системе, чтобы принять и послать файлы.  Синтаксис вызова
    имеет такой вид:</para>

  <programlisting>
~p &lt;local-file&gt; [&lt;remote-file&gt;]
~t &lt;remote-file&gt; [&lt;local-file&gt;]
  </programlisting>

  <para>Контроль ошибок передачи при этом не осуществляется, так что вам
    может понадобиться другой протокол передачи, например, zmodem.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="zmodem-tip">
    <para>Как использовать zmodem вместе с <emphasis
      remap=tt>tip</emphasis>?</para>
  </question>

  <answer>

  <para>Первым делом установите одну из программ, реализующих протокол
    zmodem из коллекции портов (там есть парочка в категории comms,
    <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?^lrzsz">lrzsz</ulink>
    и <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?^rzsz">
    rzsz</ulink>).</para>

  <para>Для приёма файлов запустите программу передачи на противоположной
    стороне.  Затем нажмите enter и наберите <literal>~C rz</literal> (или
    <literal>~C lrz</literal>, если у вас установлен
    <application>lrzsz</application>) для начала приёма их на
    локальную машину.</para>

  <para>Для посылки файлов, запустите программу приёма на противоположной
    стороне.  Затем нажмите enter и наберите
    <literal>~C sz <replaceable>files</replaceable></literal> (или
    <literal>~C lsz <replaceable>files</replaceable></literal>) для посылки
    файлов на удалённую систему.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="cannot-find-serial">
    <para>FreeBSD не распознаёт последовательные порты на моей машине, хотя
      все настройки верны.</para>
  </question>

  <answer>

  <para>Микросхемы UART производства Acer на материнских платах и адаптерах
    распознаются некорректно.  Для решения этой проблемы попробуйте 
    воспользоваться патчем с сервера <ulink
    URL="http://www.lemis.com/serial-port-patch.html">
    www.lemis.com</ulink>.</para>

  </answer>
</qandaentry>
</qandaset>
</chapter>


<chapter id="misc">
<title>Разное</title>

<qandaset>
<qandaentry>
  <question id="more-swap">
    <para>Почему FreeBSD использует гораздо больше места в разделе подкачки, чем
      Linux?</para>
  </question>

  <answer>

  <para>Это только кажется, что для FreeBSD требуется больше места на разделе
    подкачки, чем для Linux.  На самом деле это не так.  Главное отличие
    FreeBSD от Linux в этом плане заключается в том, что FreeBSD активно
    перемещает неиспользуемые страницы памяти, к которым не было обращений,
    в раздел подкачки, чтобы увеличить объём доступной физической памяти
    для активного использования.  Linux же перемещает страницы памяти в
    раздел подкачки только в крайнем случае.  Получаемое во FreeBSD
    увеличение нагрузки на раздел подкачки компенсируется более эффективным
    использованием оперативной памяти.</para>

  <para>Заметьте, что, хотя FreeBSD предпочитает использовать раздел подкачки,
    она не может сбросить все неактивные страницы в своп при полностью
    неактивной системе.  Так что вряд ли может возникнуть ситуация, когда,
    проснувшись рано утром, вы обнаружите, что вся ваша система находится в
    разделе подкачки, хотя она простаивала всю ночь.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="top-freemem">
    <para>Почему утилита &man.top.1; показывает очень маленький объём
      свободной памяти, даже когда запущено всего лишь несколько
      приложений?</para>
  </question>

  <answer>

  <para>Просто дело в том, что под свободной памятью подразумевается никак не
    используемая память.  Вся память, которая вашей программе явно не
    выделялась, используется ядром FreeBSD для дискового кэша.
    Значения, показываемые утилитой &man.top.1;, помеченные как
    <literal>Inact</literal>, <literal>Cache</literal> и <literal>Buf</literal>
    - это всё кэшированные данные разных степеней устаревания.  То, что данные
    находятся в кэше, означает, что система не будет обращаться к медленному
    диску снова за теми данными, обращение к которым было недавно, повышая таким
    образом общую производительность.  В общем случае маленькие значения в
    пункте <literal>Free</literal>, показываемые утилитой &man.top.1; для
    свободной памяти - это хорошо, если, конечно они не
    <emphasis>очень</emphasis> маленькие.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="aout-elf">
    <para>Почему используются (и что из себя представляют) форматы выполнимых
      файлов a.aut и ELF?</para>
  </question>

  <answer>

  <para>Для понимания того, почему FreeBSD использует формат
    <filename>ELF</filename>, вы должны сначала получить представление о трёх
    <quote>доминирующих</quote> форматах выполнимых файлов для UNIX:</para>

  <para>
    <note>
      <para>До FreeBSD версии 3.x, во FreeBSD использовался формат
        a.out.</para>
    </note>
  </para>

  <para>     
    <itemizedlist>
      <listitem>
        <para><ulink
          URL="http://www.FreeBSD.org/cgi/man.cgi?a.out(5)">a.out</ulink></para>

        <para>Это самый старый, <quote>классический</quote> формат объектных
          файлов для UNIX.  В нём используется короткий и компактный заголовок
          с магическим числом в начале, которое часто используется для
          определения формата (за подробным описанием обратитесь к странице
          Справочника о <ulink
          URL="http://www.FreeBSD.org/cgi/man.cgi?a.out(5)">a.out(5)</ulink>).
          Он содержит три загружаемых сегмента: .text, .data и .bss плюс таблицу
          символов и таблицу строк.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>Это формат объектных файлов SVR3.  Дополнительно в заголовок
          включена таблица секций, так что вы можете иметь их больше, чем только
          .text, .data и .bss.</para>
      </listitem>

      <listitem>
        <para><acronym>ELF</acronym></para>

        <para>Преемник <acronym>COFF</acronym>, в который добавлены возможности
          иметь много секций и 32- или 64-разрядные значения.  Один большой
          минус: <acronym>ELF</acronym> был спроектирован также в
          предположении, что для каждой аппаратной платформы будет существовать
          только один ABI.  Это предположение достаточно некорректно, и даже в
          мире коммерческих реализаций SYSV (в котором имеется по крайней мере
          три ABI: SVR4, Solaris и SCO) это не так.</para>

        <para>FreeBSD каким-то образом пытается решить эту проблему,
          предоставляя утилиту для <emphasis>пометки</emphasis> конкретного
          выполнимого файла <acronym>ELF</acronym> с информацией о ABI, с
          которым он совместим.  Обратитесь к странице Справочника об утилите
          <ulink
          URL="http://www.FreeBSD.org/cgi/man.cgi?brandelf">brandelf</ulink>
          за подробной информацией.</para>
      </listitem>
    </itemizedlist>
  </para>
  
  <para>FreeBSD выросла на <quote>классических</quote> традициях и традиционно
    использовала формат <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?a.out(5)">a.out</ulink>,
    технологию, опробованную и проверенную во многих вариациях BSD.  Хотя давно
    уже можно было компилировать и выполнять родные выполнимые файлы (и ядро) в
    формате <acronym>ELF</acronym>, FreeBSD с самого начала сопротивлялась
    переходу на <acronym>ELF</acronym> как на формат, используемый по
    умолчанию.  Почему?  Когда мир Linux делал болезненный переход к
    <acronym>ELF</acronym>, причин отвергнуть формат <filename>a.out</filename>
    было не так уж и много, разве что их негибкий механизм работы с совместно
    используемыми библиотеками, который был основан на таблице переходов, что
    делало построение таких библиотек очень затруднительным для разработчиков.
    Так как средства работы с <acronym>ELF</acronym> предоставляли решение этой
    проблемы и это было в общем-то <quote>шагом вперёд</quote> в любом случае,
    цена перехода была признана стоящей того и переход был сделан.</para>

  <para>В случае FreeBSD, наш механизм работы с совместно используемыми
    библиотеками очень похож на механизм, применяемый в <emphasis
    remap=tt>SunOS</emphasis>, поэтому его очень легко использовать.  Однако,
    начиная с 3.0, FreeBSD официально поддерживает <acronym>ELF</acronym> как
    формат, используемый по умолчанию.  И, хотя формат
    <filename>a.out</filename> поддерживается в полной мере, разработчики из
    проекта GNU, являющиеся авторами компилятора, который мы используем, больше
    не поддерживают формат <filename>a.out</filename>.  Это заставило нас
    поддерживать различные версии компилятора и компоновщика, и не позволило
    воспользоваться всеми возможностями последних разработок GNU.  
    Потребность в наличии реализации ISO-C++, в основном конструкторов и
    деструкторов, также привела к поддержке <acronym>ELF</acronym> в будущих
    релизах FreeBSD.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="binary-formats">
    <para>Да, но почему так много разных форматов?</para>
  </question>

  <answer>

  <para>Если вернуться в далёкое тёмное прошлое, то тогда компьютеры были
    очень просто устроены.  На них могла работать простая, маленькая
    система.  Формат a.out полностью решал задачу представления программ
    на простых системах (PDP-11).  Когда же люди перенесли unix с простых
    систем, они оставили a.out, так как его было достаточно для ранних
    реализаций unix для таких архитектур, как Motorola 68k, VAX, и тд.</para>

  <para>Затем какой-то умный инженер решил, что если он может заставить
    программное обеспечение делать некоторые тонкие манипуляции, то это
    позволит преодолеть некоторые ограничения при проектировании и позволит
    ядру процессора работать быстрее.  Когда это было сделано с новым типом
    аппаратуры (в наши дни известном как RISC), оказалось, что
    <filename>a.out</filename>
    плохо подходит для этой аппаратуры, поэтому было разработано много новых
    форматов для достижения большей производительности от такого аппаратного
    обеспечения, чем может дать простой, имеющий ограничения формат
    <filename>a.out</filename>.  Были разработаны такие форматы, как
    <acronym>COFF</acronym>, <acronym>ECOFF</acronym> и
    ещё несколько безвестных других со своими ограничениями, пока наконец
    все не остановились на формате <acronym>ELF</acronym>.</para>

  <para>Вдобавок к этому, так как размеры программ стали достигать огромных
    размеров, а дисковая (и физическая) память оставалась сравнительно
    небольшой, то возникла концепция совместно используемых библиотек.
    Система VM также стала более мощной.  Хотя каждое из этих нововведений
    продолжало использовать формат <filename>a.out</filename>, его
    бесполезность становилась
    видна всё больше и больше с добавлением каждой новой возможности.  К тому
    же люди захотели динамически загружать код во время выполнения программ
    или сбрасывать части программ после выполнения кода инициализации для
    экономии основной памяти и/или размера свопа.  Языки программирования
    становились всё более умными и люди захотели автоматического запуска
    некоторого кода перед главной процедурой программы.  С форматом
    <filename>a.out</filename> была сделана масса ухищрений для реализации
    всех этих
    требований, и они в общем-то работали.  В конце концов наступил момент,
    когда формат <filename>a.out</filename> перестал бы справляться со всеми
    этими
    проблемами без ещё больших потерь в коде и гибкости в работе.  Тогда
    как <acronym>ELF</acronym> решал многие из этих проблем, переход на него
    был бы
    болезненным на рабочей системе.  Так что <acronym>ELF</acronym> ждал
    момента, когда
    был бы более болезненным оставаться с форматом <filename>a.out</filename>,
    чем перейти
    к формату <acronym>ELF</acronym>.</para>

  <para>Однако с течением времени инструменты разработки, на которых
    основаны инструменты разработки FreeBSD (особенно ассемблер и 
    загрузчик), разделились на две параллельные ветви.  В дерево FreeBSD
    была добавлена поддержка совместно используемых библиотеки и были 
    исправлены некоторые ошибки.  Разработчики из GNU, которые изначально
    писали эти программы, полностью их переделали, добавив более простую
    поддержку построения кросс-компиляторов, в котором можно использовать
    различные форматы, и тд.  Когда многие захотели строить кросс-компилятор
    с выходным кодом для FreeBSD, то им не повезло, так как старые исходные
    тексты, которые FreeBSD использовала для as и ld, не подошли.  Новый
    набор утилит от GNU (binutils) поддерживает кросс-компиляцию,
    <acronym>ELF</acronym>,
    совместно используемые библиотеки, расширения C++, и тд.  Вдобавок,
    многие разработчики выпускают программы в бинарном формате
    <acronym>ELF</acronym>, и
    для FreeBSD было бы полезно иметь возможность их запускать.  И если
    такая возможность будет реализована, зачем тогда вообще продолжать
    опираться на <filename>a.out</filename>?  Это измученная старая лошадь,
    которая была
    полезна долгое время, но сейчас самое время от неё отказаться, оставив
    в прошлом долгие годы преданной службы.</para>

  <para><acronym>ELF</acronym> более выразителен, чем a.out, и позволяет
    реализовать
    большую расширяемость основной системы.  Инструменты для работы с
    <acronym>ELF</acronym> лучше поддерживаются разработчиками, и предоставляют
    поддержку
    кросс-компиляции, что для многих важно.  <acronym>ELF</acronym> может
    работать немного
    медленнее, чем a.out, но это трудно измерить.  Также между ними есть
    некоторые отличия по распределению страниц памяти, обработке кода
    инициализации, и тд.  Никакие из этих отличий особо не важны, но эти
    отличия всё же есть.  Со временем поддержка <filename>a.out</filename>
    будет убрана из
    ядра GENERIC, и постепенно убрана из системы совсем, как только отпадёт
    нужда в запуске старых программ в
    формате <filename>a.out</filename>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="chmod-symlinks">
    <para>Почему командой chmod невозможно изменить права на символические
      ссылки?</para>
  </question>

  <answer>

  <para>Символические ссылки не имеют прав доступа, а по умолчанию утилита
    &man.chmod.1; не следует символической ссылке для изменения прав доступа
    к файлу, на который указывает ссылка.  Поэтому, если у вас есть файл,
    скажем, с именем <filename>foo</filename> и символическая ссылка
    <filename>bar</filename> на этот файл, то эта команда всегда будет
    выполняться успешно.</para>

  <screen>
&prompt.user; <userinput>chmod g-w bar</userinput>
  </screen>

  <para>Однако права на файл <filename>foo</filename> не изменятся.</para>

  <para>Чтобы это работало, используйте опции <option>-H</option> или
    <option>-L</option> вместе с опцией <option>-R</option>.
    Обратитесь к страницам Справочника по команде <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?chmod">chmod</ulink> и по <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?symlink">symlink</ulink>.</para>
 
  <para>
    <warning>
      <para>Опция <option>-R</option> выполняет команду <emphasis
        remap=tt>chmod</emphasis> <acronym>РЕКУРСИВНО</acronym>.  Будьте
        осторожны, задавая каталоги или символические ссылки на каталоги в
        параметрах <emphasis remap=tt>chmod</emphasis>.  Если вы хотите изменить
        права на каталог, на который указывает символическая ссылка, используйте
        <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?chmod">chmod</ulink>
        без опций и следуйте символической ссылке с помощью лидирующего слэша
        (<filename>/</filename>).  Например, если <filename>foo</filename>
        является символической ссылкой на каталог <filename>bar</filename>, а
        вы хотите изменить права на <filename>foo</filename> (на самом деле
        <filename>bar</filename>), вы должны выполнить команду
        типа следующей:</para>

      <screen>
&prompt.user; <userinput>chmod 555 foo/</userinput>
      </screen>

      <para>Если задан лидирующий слэш, <ulink
        URL="http://www.FreeBSD.org/cgi/man.cgi?chmod">chmod</ulink> будет
        следовать символической ссылке, <filename>foo</filename>, меняя права
        на каталог <filename>bar</filename>.</para>
    </warning>
  </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="login-8char">
    <para>Почему длина регистрационного имени <emphasis remap=bf>всё
      ещё</emphasis> ограничена 8 символами?</para>
  </question>

  <answer>

  <para>Наверное, вы думаете, что достаточно будет изменить значение 
    константы <literal>UT_NAMESIZE</literal>, перекомпилировать полностью
    систему и всё будет работать.  К несчастью, часть приложений и утилит
    (включая системные) имеют жёстко заданные малые значения (не всегда
    <literal>8</literal> или <literal>9</literal>, но и такие странные, как
    <literal>15</literal> или <literal>20</literal>) в структурах и буферах. 
    Это приведёт не только к порче файлов журналов (из-за записи полей
    переменного размера там, где ожидается поле фиксированного размера), но
    может повлиять на работу клиентов системы Sun NIS и может в принципе
    вызвать другие проблемы при взаимодействии с другими системами UNIX.</para>

  <para>Во FreeBSD 3.0 и старше, максимальная длина имени была увеличена
    до 16 символов и все утилиты с предопределённым размером имени были
    найдены и исправлены.  Так как это касается столь многих областей в
    системе, то такие изменения не делались вплоть до 3.0. </para>

  <para>Если вы абсолютно уверены, что сможете найти и исправить проблемы
    такого рода самостоятельно, когда они возникнут, то можете увеличить
    длину регистрационного имени в ранних релизах, отредактировав файл
    /usr/include/utmp.h и изменив соответствующим образом константу
    UT_NAMESIZE.  Вы должны будете также изменить значение MAXLOGNAME в
    файле /usr/include/sys/param.h, чтобы оно соответствовало UT_NAMESIZE.
    И наконец, если вы компилируете из исходных текстов, не забудьте, что 
    /usr/include обновляется каждый раз!  Делайте изменения в
    соответствующих файлах каталога /usr/src/.. </para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="dos-binaries">
    <para>Можно ли запускать программы для DOS во FreeBSD?</para>
  </question>

  <answer>

  <para>Да, начиная с версии 3.0, вы можете использовать эмулятор DOS
    <emphasis remap=tt>doscmd</emphasis> от BSDI, который был интегрирован
    в систему и усовершенствован.  Пошлите письмо в <ulink
    URL="mailto:freebsd-emulation@FreeBSD.org">список рассылки</ulink>,
    посвящённый эмуляции во FreeBSD, если вы заинтересованы в участии в
    этом проекте.</para>

  <para>Для систем, предшествующих 3.0, в коллекции портов есть замечательная
    утилита <ulink 
    URL="http://www.FreeBSD.org/cgi/ports.cgi?^pcemu">pcemu</ulink>,
    эмулирующая процессор 8088 и функции BIOS, чего достаточно для запуска
    приложений DOS, работающих в текстовом режиме.  Она требует X Window
    System (которая поставляется как XFree86).</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="sup-define">
    <para>Что такое <command>sup</command> и как это можно использовать?</para>
  </question>

  <answer>

  <para>Сокращение <ulink URL="http://www.FreeBSD.org/cgi/ports.cgi?^sup">
    SUP</ulink> означает Software Update Protocol, который был разработан в
    CMU для синхронизации исходных текстов.  Мы используем его для
    синхронизации исходных текстов на удалённых сайтах с основным сервером
    разработчиков.</para>

  <para>Протокол SUP использует пропускную способность канала неэффективно,
    и был отвергнут.  В настоящее время рекомендуемым методом для
    синхронизации исходных текстов является протокол <ulink
    URL="../../handbook/synching.html#CVSUP">CVSup</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="very-very-cool">
    <para>Насколько греется процессор при работе FreeBSD?</para>
  </question>

  <answer>

  <para>В. Кто-нибудь делал замеры температуры при работе FreeBSD?  Я
    знаю, что Linux греется меньше, чем DOS, но никогда не видел упоминания
    FreeBSD.  Наверное, он сильно греется.</para>

  <para>О. Нет, но мы сделали различные вкусовые тесты у добровольцев с
    завязанными глазами, которые до этого приняли по 250 микрограмм
    LSD-25.  35% добровольцев заявило, что FreeBSD имеет вкус апельсина,
    тогда как вкус Linux расценивался как фиолетовый туман.  Насколько
    я помню, ни одна из групп не отметила значительной разницы в
    температуре.  Вы хотели опубликовать полные результаты этого опроса,
    когда обнаружили, что слишком много добровольцев покинули помещение
    во время тестов, что несколько смазало результаты.  Я думаю, что
    большинство из них работают сейчас в Apple над их новым GUI 
    <quote>чеши и нюхай</quote>.  Это старый добрый бизнес!</para>

  <para>Серьёзно, и FreeBSD, и Linux используют инструкцию
    <acronym>HLT</acronym> (halt), когда система простаивает, что уменьшает
    потребление энергии и в свою очередь, выделение тепла.  Вдобавок, если у
    вас настроен APM (комплексное управление энергопотреблением), то FreeBSD
    может переводить процессор в режим пониженного энергопотребления.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="letmeoutofhere">
    <para>Кто там скребётся в микросхемах памяти??</para>
  </question>

  <answer>

  <para>В. Делает ли FreeBSD что-нибудь <quote>эдакое</quote> при компиляции
    ядра, что вызывает поскрипывание микросхем памяти?  При компиляции (и в
    короткий промежуток времени после обнаружения дисковода при старте системы)
    от микросхем памяти исходит странный царапающий звук.</para>

  <para>О. Да!  Вы, наверное, видели частое упоминание <quote>даемонов</quote>
    в документации по BSD, но не многие знают, что это настоящие нематериальные
    существа, которые теперь завладели вашим компьютером.  Царапающий звук,
    издаваемый микросхемами памяти - это на самом деле высокочастотное
    перешёптывание между даемонами, когда они решают, как лучше справиться
    с различными задачами по администрированию системы.</para>

  <para>Если шум достиг ваших ушей, команда DOS <command>fdisk /mbr</command>
    их спугнёт, но не удивляйтесь, если они отреагируют соответствующим
    образом и попытаются вас остановить.  Фактически, если во время
    выполнения этой команды вы услышите сатанинский голос Билла Гейтса из
    встроенного динамика, бегите и даже не оглядывайтесь!  Избавленные
    от противостояния с даемонами BSD, близнецы-демоны DOS и Windows часто
    могут захватить полный контроль не только над вашей машиной и
    навлечь вечное проклятие на вашу душу.  Если бы у меня был выбор, я
    думаю, что предпочёл бы царапающий звук.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="define-MFC">
    <para>Что такое <acronym>MFC</acronym>?</para>
  </question>

  <answer>

  <para>MFC - это сокращение от <quote>Merged From -CURRENT</quote>.  Оно
    используется в протоколах изменений CVS для отметки того, что изменение
    было перенесено в ветвь STABLE из CURRENT.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="define-BSD">
    <para>Что означает сокращение <acronym>BSD</acronym>?</para>
  </question>

  <answer>

  <para>Это сокращение значит что-то на секретном языке, который могут знать
    только посвящённые.  Это нельзя перевести один к одному, однако
    достаточно сказать, что перевод с BSD - это что-то между <quote>Команда
    Formula-1</quote>, <quote>Пингвины - это вкусные плюшки</quote> и <quote>Мы
    прикольнее, чем Linux</quote>. :-)</para>

  <para>Если серьёзно, то BSD является сокращением от <quote>Berkeley Software
    Distribution</quote>, названия, которое было выбрано Berkeley
    <acronym>CSRG</acronym> (Computer Systems Research Group) для их
    дистрибутива Unix.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="define-repocopy">
    <para>Что такое repo-copy?</para>
  </question>

  <answer>

  <para>repo-copy (что является краткой формой от <quote>repository
    copy</quote>) обозначает прямое копирование файлов внутри репозитория
    CVS.</para>

  <para>Без repo-copy, если есть необходимость скопировать или переместить
    файл в другое место репозитория, то коммиттер должен выполнять команды
    <command>cvs add</command> для помещения файла на новое место, а затем
    <command>cvs rm</command>, чтобы удалить старый файл, если старая копия
    должна быть удалена.</para>

  <para>Минусом этого метода является то, что история (то есть записи в
    журналах CVS) работы с файлом не копируются в новое место.  Так как
    Проект FreeBSD осознаёт важность сохранения истории, вместо описанного
    процесса зачастую используется копирование в репозитории.  Это действие
    заключается в том, что один из хозяев репозитория копирует файлы
    непосредственно внутри репозитория, не пользуясь командами
    <command>cvs</command>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="bikeshed-painting">
    <para>Почему я должен беспокоиться о цвете фар велосипеда?</para>
  </question>

  <answer>

  <para>На самом деле краткий, очень краткий ответ на этот вопрос заключается в
    том, что вы этого делать не должны.  Если давать более подробный ответ,
    то ваше умение делать фары не должно означать, что вы должны препятствовать
    другим делать их просто потому, что вам не нравится цвет, в который
    они собираются их окрашивать.  Эта метафора означает, что вам не нужно
    обсуждать каждую мелочь просто потому, что вы знаете о ней
    достаточно много.  Некоторые люди отмечают, что объём шума, генерируемый
    при появлении некоторого изменения, находится в обратной зависимости от
    сложности самого изменения.</para>

  <para>Более пространный и полный ответ заключается в том, что после очень
    долгого обсуждения того, должна ли утилита &man.sleep.1; обрабатывать
    дробное число, заданное в качестве второго аргумента, &a.phk;
    опубликовал большое сообщение, озаглавленное <quote><ulink
    url="http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=506636+517178+/usr/local/www/db/text/1999/freebsd-hackers/19991003.freebsd-hackers">
    Велосипедная фара (любого цвета) на зелёной траве...</ulink></quote>.
    Соответствующие части этого сообщения цитируются ниже.</para>

    <blockquote>
      <attribution>&a.phk; on freebsd-hackers,
        October 2, 1999</attribution>

      <para><quote>Что там насчёт этой велосипедной фары?</quote> Кто-то
        из вас меня спрашивал.</para>

      <para>Это долгая история, или же это старая история, но на самом деле
        она коротка.  В начале 1960-х годов Паркинсон (C. Northcote Parkinson)
        написал книгу <quote>Закон Паркинсона</quote>, которая содержит много
        интересных взглядов на процесс управления.</para>

      <para>[немного выдержек из краткого содержания книги]</para>

      <para>В конкретном примере с велосипедной фарой другим важным объектом
        является атомная электростанция.  Я полагаю, что это иллюстрирует
        древность книги.</para>

      <para>Паркинсон показал, что вы можете прийти на совещание руководителей
        и получить добро на строительство многомиллионной или даже
        многомиллиардной атомной электростанции, но если вы хотите получить
        финансирование производства велосипедных фар, то погрязнете в
        бесконечных обсуждениях.</para>

      <para>Паркинсон объясняет это тем, что атомная станция настолько большой,
        дорогой и сложный объект, что люди не могут его осознать и вместо того,
        чтобы попробовать это сделать, они полагаются на то, что кто-то уже
        проверил все мелочи до того, как всё зашло так далеко.  В своей книге
        Ричард П. Фейнманн (Richard P. Feynmann) даёт несколько интересных и
        очень поучительных примеров, связанных с Лос Аламос.</para>

      <para>Велосипедная фара - это противоположный случай.  Любой может
        сделать фару за один уикэнд, и у него ещё останется время посмотреть
        футбол по телевизору.  Так что не важно, насколько хорошо вы готовились
        к обсуждению, насколько убедительны будут ваши аргументы, кто-нибудь
        воспользуется шансом показать, что он не зря ест свой хлеб, что он
        обращает внимание, что он <emphasis>здесь</emphasis>.</para>

      <para>В Дании это называется <quote>оставить отпечаток своего
        пальца</quote>.  Это касается личной гордости и престижа, это похоже
        на возможность указать куда-то и сказать: <quote> Вон там! Это сделал
        <emphasis>я</emphasis>.</quote>  Это сильно выражено в политиках, но
        присутствует во многих людях, которые получают возможность сделать
        это.  Просто вспомните об отпечатках ног во влажном цементе.</para>
    </blockquote>

  </answer>
</qandaentry>


<qandaentry>
  <question id="changing-lightbulbs">
    <para>Сколько требуется разработчиков FreeBSD, чтобы сменить
      электрическую лампочку?</para>
    </question>

  <answer>

  <para>Необходимо иметь ровно одну тысячу сто семьдесят два
    разработчика:</para>

  <para>Двадцать три сообщат в -CURRENT о том, что не горит свет;</para>

  <para>Четыре начнут утверждать, что это проблема конфигурации и такие
    сообщения нужно посылать в -questions;</para>

  <para>Трое оформят PR по этому поводу, причём одно их них будет направлено
    в doc и будет содержать только строчку "здесь темно";</para>

  <para>Один закоммитит неоттестированную лампочку, что сломает построение
    системы, а затем через пять минут вернёт все назад;</para>

  <para>Восемь поругаются с авторами PR по поводу включения патчей в PR;</para>

  <para>Пять сообщат о том, что не проходит компиляция системы;</para>
 
  <para>Тридцать один человек ответит, что у них всё работает и наверное, те
    выполняли cvsup в неподходящее время;</para>

  <para>Один пошлёт патч для новой лампочки в -hackers;</para>
 
  <para>Один пожалуется, что у него имелись патчики ещё три года назад,
    но когда он послал их в -CURRENT, они были проигнорированы и он имел
    неудачный опыт работы с системой PR; кроме того предлагаемая лампочка
    не имеет отражателя.</para>

  <para>Тридцать семь начнут кричать, что лампочки не относятся к базовой
    системе, что коммиттеры не имеют права делать такие вещи без опроса
    общественности и ЧТО ВООБЩЕ -CORE ДЕЛАЕТ ПО ЭТОМУ ПОВОДУ?</para>

  <para>Две сотни напишут о цвете велосипедных фар;</para>

  <para>Трое скажут, что этот патч не соответствует style(9);</para>

  <para>Семнадцать возразят, что предлагаемая новая лампа подпадает под
    лицензию GPL;</para>

  <para>Пятьсот восемьдесят шесть раздуют флейм по поводу сравнения
    лицензий GPL, BSD, MIT, NPL и личных мнений о неизвестных основателей
    FSF;</para>

  <para>Семеро пошлют различные части этих обсуждений в -chat и
    -advocacy;</para>

  <para>Один закоммитит предлагаемую лампу, хотя она светит хуже, чем
    старая;</para>

  <para>Двое откатят эти изменения с ужасной руганью в журнале коммита о том,
    что лучше FreeBSD будет сидеть в темноте, чем с тусклой лампой.</para>

  <para>Сорок шесть громко воспротивятся этому изменению и потребуют
    объяснений от -core;</para>

  <para>Одиннадцать попросят уменьшить размер лампочки, чтобы она подошла
    к их Тамагочи на случай, если мы когда-нибудь соберёмся переносить
    FreeBSD на эту платформу;</para>

  <para>Семьдесят три заявят о SNR в -hackers и -chat и в знак протеста
    отпишутся;</para>

  <para>Тринадцать пошлют письма "unsubscribe", "How do I unsubscribe?",
    и "Please remove me from the list" с обычной подписью;</para>

  <para>Один закоммитит работающую лампочку в то время, как все будут 
    слишком заняты руганью, чтобы это заметить;</para>

  <para>Тридцать один человек напишет, что новая лампочка будет светить на
    0.364% ярче, если её откомпилировать с помощью TenDRA (хотя при этом
    она приобретёт форму куба) и что FreeBSD должна перейти на компилятор
    TenDRA, а не на EGCS;</para>

  <para>Один заметит, что у лампочки отсутствует цоколь;</para>

  <para>Девять (включая авторов PR) спросят "что такое MFC?";</para>

  <para>Спустя две недели после смены лампочки пятьдесят семь человек сообщат
    о том, что света всё равно нет.</para>

  <para><emphasis>&a.nik; добавил:</emphasis></para>

  <para><emphasis>Я сильно смеялся над всем этим.</emphasis></para>
 
  <para><emphasis>И тогда я подумал, "Постойте-ка, найдётся ли кто-нибудь,
    чтобы задокументировать это где-нибудь?"</emphasis></para>

  <para><emphasis>И на меня снизошло озарение :-)</emphasis></para>

  <para><emphasis>Авторские права на этот параграф:
    Copyright &copy; 1999 &a.des;.  Пожалуйста, не воспроизводите этот материал
    без указания авторских прав.</emphasis></para>

  </answer>
</qandaentry>
</qandaset>
</chapter>


<chapter id="hackers">
<title>Только для серьёзных хакеров FreeBSD</title>

<qandaset>
<qandaentry>
  <question id="define-snap-release">
    <para>Что такое SNAP и RELEASE?</para>
  </question>

  <answer>

  <para>В <ulink URL="http://www.FreeBSD.org/cgi/cvsweb.cgi">Репозитории
    CVS</ulink> сейчас находятся три активно/полуактивно развивающихся ветки
    FreeBSD (ветвь RELENG_2 меняется от силы пару раз в год, вот почему в
    разработке только три активных ветки):</para>
  
  <para>
    <itemizedlist>
      <listitem>
        <para><literal>RELENG_2_2</literal>
          AKA <emphasis>2.2-STABLE</emphasis></para>
      </listitem>

      <listitem>
        <para><literal>RELENG_3</literal>
          AKA <emphasis>3.X-STABLE</emphasis></para>
      </listitem>

      <listitem>
        <para><literal>RELENG_4</literal>
          AKA <emphasis>4-STABLE</emphasis></para>
      </listitem>

      <listitem>
        <para><literal>HEAD</literal> AKA <emphasis>-CURRENT</emphasis>
          AKA <emphasis>5.0-CURRENT</emphasis></para>
      </listitem>
    </itemizedlist>
  </para>

  <para><literal>HEAD</literal> - это не реальный тэг ветки, как другие два;
    это просто символьная константа для обозначения <quote><emphasis>текущего,
    не ветвящегося, находящегося в разработке дерева</emphasis></quote>, то есть
    <quote>-CURRENT</quote>.</para>

  <para>На данный момент <quote>-CURRENT</quote> является находящимся в
    разработке деревом 5.0, ветка <emphasis remap=bf>4-STABLE</emphasis>,
    <symbol>RELENG_4</symbol>, отделилась от <quote>-CURRENT</quote> в марте
    2000 года.</para>

  <para>Ветвь <emphasis remap=bf>2.2-STABLE</emphasis>,
    <symbol>RELENG_2_2</symbol>, отделилась от -CURRENT в ноябре 1996 и
    развитие этой ветви было полностью прекращено.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="custrel">
    <para>Как самим сделать релиз?</para>
  </question>

  <answer>

  <para>Чтобы сделать релиз, вам нужно иметь три вещи: Во-первых, вам нужно
    работать с ядром, включающим драйвер
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?vn">vn</ulink>.  Добавьте
    его в файл конфигурации ядра и откомпилируйте новое ядро:</para>

  <programlisting>
pseudo-device vn         #Vnode driver (turns a file into a device)
  </programlisting>

  <para>Во-вторых, вам нужно иметь на диске полное дерево CVS.  Чтобы добиться
    этого, вы можете использовать <ulink
    URL="../../handbook/synching.html#CVSUP">CVSUP</ulink>, указав в файле
    supfile в качестве имени релиза cvs и удалив все поля с тегами и
    датами:</para>

  <programlisting>
*default prefix=/home/ncvs
*default base=/a
*default host=cvsup.FreeBSD.org
*default release=cvs
*default delete compress use-rel-suffix

## Main Source Tree
src-all
src-eBones
src-secure

# Other stuff
ports-all
www
doc-all
  </programlisting>

  <para>После этого запустите <command>cvsup -g supfile</command> для выкачки
    всех нужных исходных текстов на ваш компьютер...</para>

  <para>Наконец, вам нужно свободное место для построения системы.  Допустим,
    что свободное место есть в каталоге
    <filename>/some/big/filesystem</filename> и, как в примере выше, вы
    поместили дерево CVS в каталог <filename>/home/ncvs</filename>:</para>

  <screen>
&prompt.root; <userinput>setenv CVSROOT /home/ncvs</userinput> # or export CVSROOT=/home/ncvs
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>cd /usr/src/release</userinput>
&prompt.root; <userinput>make release BUILDNAME=3.0-MY-SNAP CHROOTDIR=/some/big/filesystem/release</userinput>
  </screen>

  <blockquote>
    <note>
      <para>Пожалуйста, отметьте, что вам <emphasis>не нужно</emphasis>
        выполнять процедуру построения системы полностью, если у вас уже
        есть заполненный <filename>/usr/obj</filename>.</para>
    </note>
  </blockquote>

  <para>Полный релиз будет строиться в каталоге
    <filename>/some/big/filesystem/release</filename> и по окончании этого
    процесса дистрибутив, готовый к помещению на FTP-сервер, будет находиться в
    каталоге <filename>/some/big/filesystem/release/R/ftp</filename>.  Если вы
    захотите построить SNAP другой ветки, не -CURRENT, то можете указать
    <literal>RELEASETAG=SOMETAG</literal> в командной строке make release выше,
    например, при указании <literal>RELEASETAG=RELENG_2_2</literal>, будет
    строиться самый свежий снэпшот ветки 2.2-STABLE.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="custom-install-disks">
    <para>Как создать инсталляционные диски?</para>
  </question>

  <answer>

  <para>Весь процесс создания инсталляционных дисков и дистрибутивов исходных
    текстов и бинарников автоматизирован в файле
    <filename>/usr/src/release/Makefile</filename>.  Информации, в нём
    содержащейся, должно быть достаточно, чтобы начать.  Однако, должны вас
    предупредить, что этот процесс включает в себя выполнение
    <command>make world</command> и поэтому занимает много времени и дискового
    пространства.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="makeworld-clobbers">
    <para>По команде <command>make world</command> были переустановлены все
      программы.</para>
  </question>

  <answer>

  <para>Да, так и должно быть; как говорит название этой команды, <command>make
    world</command> выполняет построение всех системных файлов с нуля, так
    что в итоге можете быть уверены, что получите чистую рабочую
    систему (вот почему это занимает столько времени).</para>

  <para>Если в момент запуска команд <command>make world</command> или
    <command>make install</command> определена переменная окружения
    <literal>DESTDIR</literal>, то вновь создаваемые файлы будут помещены в
    дерево каталогов.  идентичное существующему, с корнем, располагающимся в
    <literal>&#36;{DESTDIR}</literal>.  Однако некоторые случайные
    комбинации модификаций совместно используемых библиотек и версий
    компилируемых программ при исполнении команды
    <command>make world</command>, может этому помешать.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="bus-speed-defaulted">
    <para>При загрузке системы выдаётся сообщение <quote>(bus speed
      defaulted)</quote>.</para>
  </question>

  <answer>

  <para>Адаптеры SCSI Adaptec 1542 позволяют программно изменять скорость
    доступа к шине.  Предыдущие версии драйвера 1542 пытались определить
    максимально возможную скорость работы и установить это значение.  Мы
    обнаружили, что у некоторых пользователей это приводило к нарушению
    работоспособности системы, поэтому эта возможность сейчас вынесена
    в параметр конфигурации ядра <symbol>TUNE_1542</symbol>.  Использование
    этой опции на тех системах, где она работает, может привести к
    ускорению доступа к дискам, а там, где это не работает, может привести
    к потере данных.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="ctm">
    <para>Можно ли работать с current при ограниченном доступе в
      Internet?</para>
  </question>

  <answer>

  <para>Да, это можно делать <emphasis remap=tt>без</emphasis> скачивания
    полного дерева исходных
    текстов с помощью <ulink
    URL="../../handbook/synching.html#CTM">системы CTM</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="split-240k">
    <para>Как вы разделяете дистрибутив на файлы по 240К?</para>
  </question>

  <answer>

  <para>Команда split в современных BSD-системах имеет опцию
    <option>-b</option>, позволяющую разрезать файлы на части с точностью до
    байта.</para>

  <para>Вот пример из файла <filename>/usr/src/Makefile</filename>.</para>

  <programlisting>
bin-tarball:
(cd ${DISTDIR}; \
tar cf - . \
gzip --no-name -9 -c | \
split -b 240640 - \
${RELEASEDIR}/tarballs/bindist/bin_tgz.)
  </programlisting>

  </answer>
</qandaentry>


<qandaentry>
  <question id="submitting-kernel-extensions">
    <para>Я написал некоторое добавление к ядру, кому его послать?</para>
  </question>

  <answer>

  <para>Обратитесь к соответствующему <ulink
    URL="../../handbook/contrib.html">разделу</ulink> Руководства, в котором
    описано, как это сделать.</para>

  <para>И спасибо вам за ваши усилия!</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="pnp-initialize">
    <para>Как распознаются и инициализируются адаптеры ISA Plug N Play?</para>
  </question>

  <answer>

  <para>От: <ulink URL="mailto:uhclem@nemesis.lonestar.org">Фрэнка Дурды
    IV</ulink> (Frank Durda IV)</para>

  <para>Если рассматривать на самом низком уровне, то существует несколько
    портов ввода/вывода, в которые должны выводить информацию все адаптеры
    PnP, когда компьютер пытается выполнить запрос о наличии установленных
    адаптеров.  Так что, когда запускается процедура определения адаптеров
    PnP, она выполняет запрос о наличии каких-либо адаптеров PnP, а все
    такие адаптеры выдают свой номер модели при чтении того же порта 
    ввода/вывода, поэтому процедура определения получит ответ на свой
    запрос, состоящий из логически наложенных номеров моделей, 
    интерпретируемый как <quote>да</quote>.  В этом ответе по крайней мере
    один бит будет установлен в единицу.  Затем код определения адаптеров может
    <quote>выключать</quote> адаптеры с ID (назначаемыми Microsoft/Intel),
    большими, чем X.  Потом следует попытка определить, остались ли ещё
    адаптеры, отвечающие на запрос.  Если ответ <literal>0</literal>, то
    адаптеров с ID, большими чем X, нет.  После этого делается попытка
    определить наличие адаптеров с номерами, меньшими чем <literal>X</literal>.
    Если они есть, то становится известно, что есть адаптеры с номерами,
    меньшими, чем X.  Тогда происходит запрос адаптерам, большим чем
    X-(limit-4), на выключение.  Запрос повторяется. Применив этот метод
    полудвоичного поиска границ расположения ID достаточное количество раз, код 
    идентификации найдёт все адаптеры PnP, установленные в данной машине
    за число итераций, гораздо меньшее, чем может занять перебор 2^64
    возможных вариантов ID.</para>

  <para>ID представляет собой два 32-разрядные числа (всего их 2^64)
    + 8 бит контрольной суммы.  Первые 32 бита являются идентификатором
    производителя.  Они никогда не сообщаются, однако часто бывает, что
    различные типы адаптеров от одного и того же производителя имеют
    различные 32-битные значения идентификатора производителя.  
    Необходимость в 32 разрядах только для задания производителя адаптера
    выглядит несколько излишним.</para>

  <para>Оставшиеся 32 бита являются серийным номером, ethernet-адресом,
    чем-либо, делающим этот адаптер уникальным.  Производитель не должен
    выпускать других адаптеров, имеющих то же самое значение этих битов,
    если, конечно, у них не разные идентификаторы производителя.  Таким
    образом, вы можете иметь несколько адаптеров одинакового типа, но с
    различными 64-разрядными номерами.</para>

  <para>Группы по 32 бита не могут быть нулевыми.  Это позволяет при
    логическом объединении OR их номеров получать ненулевое значение во
    время начального поиска адаптеров.</para>

  <para>Как только система определила ID всех адаптеров, она активизирует
    каждый адаптер, по одному за раз (через те же порты ввода/вывода), и
    определяет, какие ресурсы требуются данному адаптеру, какие возможные
    прерывания доступны и тд.  Сканирование и сбор информации происходит
    по всем адаптерам.</para>

  <para>Эта информация соотносится с содержащейся в файлах ECU на диске
    или в MLB BIOS.  Поддержка PnP из ECU и BIOS для аппаратуры на
    MLB обычно имеет синтетический характер, и периферия не выполняет
    полностью процедуру настоящего PnP.  Однако, используя BIOS и
    информацию из ECU, процедура инициализации может обнаружить устройства
    PnP, которые не могут быть найдены другим способом.</para>

  <para>Затем устройства PnP опрашиваются ещё раз для назначения им портов
    ввода/вывода, DMA, IRQ и адресов отображаемой памяти.  Теперь 
    устройства должны иметь именно такие настройки и они должны оставаться
    такими до следующей перезагрузки, хотя нигде не сказано, что вы не
    можете их менять, когда захотите.</para>

  <para>Здесь сделано много упрощений, однако общую идею вы должны
    уловить.</para>

  <para>Microsoft использовала для PnP некоторые порты статуса первого
    принтера, по их логике, не существует адаптеров, использующих эти
    адреса для ввода/вывода.  Я обнаружил один такой адаптер принтера от
    IBM, который декодирует запись в порт статуса в момент начального
    опроса устройств PnP, на что MS ответил <quote>хулиган</quote>. Так что они
    выполняют запись в порт статуса принтера для установки адресов,
    вдобавок используют этот адрес + <literal>0x800</literal>, и ещё один порт
    ввода/вывода, который может располагаться где угодно в диапазоне между
    <literal>0x200</literal> и <literal>0x3ff</literal>, для чтения.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="architectures">
    <para>Поддерживает ли FreeBSD аппаратные платформы, отличные от x86?</para>
  </question>

  <answer>

  <para>Интерес к работе над поддержкой многоплатформенности во FreeBSD
    проявили несколько групп разработчиков, и одна из попыток переноса на
    другую архитектуру, FreeBSD/AXP (ALPHA), оказавшаяся достаточно удачной,
    в настоящее время доступна по адресу <ulink
    URL="ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha/">
    ftp://ftp.FreeBSD.org/pub/FreeBSD/alpha</ulink>.
    Эта реализация для ALPHA сейчас поддерживает всё увеличивающееся число
    машин ALPHA, в частности, модели AlphaStation, AXPpci, PC164, Miata и
    Multia.  Чтобы быть в курсе событий, происходящих с этим проектом,
    подпишитесь на соответствующий <email>freebsd-alpha@FreeBSD.org</email>
    <link linkend="mailing">список рассылки</link>.</para>

  <para>Также был проявлен интерес к переносу FreeBSD на платформу SPARC.  Если
    вы хотите подключиться к этому проекту, подпишитесь на соответствующий
    <email>freebsd-sparc@FreeBSD.org</email> <link linkend="mailing">список
    рассылки</link>.  В список планируемых к поддержке платформ совсем недавно
    добавились архитектуры IA-64 и PowerPC, дополнительную информацию можно
    получить, подключившись к соответствующим <link
    linkend="mailing">спискам рассылки</link>
    <email>freebsd-ia64@FreeBSD.org</email> и/или
    <email>freebsd-ppc@FreeBSD.org</email>.  Для обсуждение общих вопросов,
    касающихся новых аппаратных платформ, предназначен <link
    linkend="mailing">список рассылки</link>
    <email>freebsd-platforms@FreeBSD.org</email>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="major-numbers">
    <para>Мне нужно старшее число для написанного мною драйвера
      устройства.</para>
  </question>

  <answer>

  <para>Всё зависит от того, планируете вы сделать этот драйвер
    общедоступным или нет.  Если это так, то, пожалуйста, пошлите нам
    копию исходных текстов драйвера вместе с соответствующими
    модификациями в файле <emphasis remap=tt>files.i386</emphasis>, пример
    описания устройства
    в файле конфигурации ядра и соответствующий код
    <ulink URL="http://www.FreeBSD.org/cgi/man.cgi?MAKEDEV">MAKEDEV</ulink>
    для создания специальных файлов устройств, которые
    использует ваше устройство.  Если это не так. или это невозможно
    из-за лицензионных ограничений, то для старшего числа символьного
    устройства и старшего числа блочного устройства для этих целей были
    зарезервированы значения 32 и 8 соответственно; используйте их.  В
    любом случае.  мы будем рады услышать о вашем драйвере в списке
    рассылки <email>freebsd-hackers@FreeBSD.org</email>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="alternate-directory-layout">
    <para>Альтернативный метод размещения каталогов</para>
  </question>

  <answer>

  <para>В ответ на вопрос о других методах размещения каталогов могу
    сказать, что используемая в настоящее схема не претерпела изменений
    с 1983 года.  Эти соглашения были предназначены для оригинальной
    файловой системы FFS, я никогда их не пересматривал.  Эта схема
    прекрасно работает, позволяя избежать переполнения групп дорожек.
    Как некоторые из вас замечали, она работает плохо при поиске.  
    Большинство файловых систем создаются из архивов, которые были
    созданы с глубиной первого поиска (aka ftw). Это приводит к тому, что
    их каталоги размещаются на нескольких группах дорожек, создавая
    наихудший случай для последующего поиска глубиной один.  Если бы
    было известно общее количество каталогов, которые должны быть созданы,
    выходом было бы создание (общее количество / количество групп дорожек)
    на дорожку группу перед переходом.  Обычно это число определяется чисто
    эвристически.  Даже при использовании маленького фиксированное числа,
    скажем 10, значительно улучшает ситуацию.  Чтобы различать операции
    восстановления от обычных операций (где текущий алгоритм подходит),
    вы можете использовать объединение в кластеры объёмом до 10, если они
    делаются в окне, равным 10 секундам.  Во всяком случае, я думаю, что
    это требует некоторых экспериментов.</para>

  <para>Кирк МакКузик (Kirk McKusick), Сентябрь 1998</para>
 
  </answer>
</qandaentry>


<qandaentry>
  <question id="kernel-panic-troubleshooting">
    <para>Что делать при аварийном остановах системы</para>
  </question>

  <answer>

  <para><emphasis>[Этот раздел был вырезан из письма, написанного &a.wpaul; в
    <link linkend="mailing">список рассылки</link> freebsd-current
    &a.des;, который исправил несколько опечаток и добавил комментарии в
    квадратных скобках]</emphasis></para>

  <programlisting>
From: Bill Paul &lt;wpaul@skynet.ctr.columbia.edu&gt;
Subject: Re: the fs fun never stops
To: ben@rosengart.com
Date: Sun, 20 Sep 1998 15:22:50 -0400 (EDT)
Cc: current@FreeBSD.org
  </programlisting>
 
  <para><emphasis>[&lt;ben@rosengart.com&gt; отправил письмо, содержащее
    следующее аварийное сообщение системы]</emphasis>

    <programlisting>
&gt; Fatal trap 12: page fault while in kernel mode
&gt; fault virtual address   = 0x40
&gt; fault code              = supervisor read, page not present
&gt; instruction pointer     = 0x8:0xf014a7e5
                                ^^^^^^^^^^
&gt; stack pointer           = 0x10:0xf4ed6f24
&gt; frame pointer           = 0x10:0xf4ed6f28
&gt; code segment            = base 0x0, limit 0xfffff, type 0x1b
&gt;                         = DPL 0, pres 1, def32 1, gran 1
&gt; processor eflags        = interrupt enabled, resume, IOPL = 0
&gt; current process         = 80 (mount)
&gt; interrupt mask          =
&gt; trap number             = 12
&gt; panic: page fault
    </programlisting>

    [Если] вы увидите такое сообщение, просто его воспроизвести и
    послать нам не достаточно.  Указатель инструкций, выделенный мною,
    важен, к сожалению, его значение зависит от конфигурации ядра.
    Другими словами, его значение меняется в зависимости от конкретного
    ядра, которое вы используете.  Если вы используете ядро GENERIC
    одного из снэпшотов, то кто-то ещё может отследить функцию, вызвавшую
    ошибку, но если вы работаете со специально отконфигурированным ядром,
    то только <emphasis>вы</emphasis> можете сказать нам, где случилась
    ошибка.</para>

  <para>Вот что вы должны сделать:</para>

  <para>
    <itemizedlist>
      <listitem>
        <para>Запишите значение указателя инструкций.  Заметьте, что
          часть <literal>0x8:</literal> в этом случае не важна: нам нужна часть
          <literal>0xf0xxxxxx</literal>.</para>
      </listitem>

      <listitem>
        <para>Когда система перезагрузится, сделайте следующее:

          <screen>
&prompt.user; <userinput>nm -n /kernel.that.caused.the.panic | grep f0xxxxxx</userinput>
          </screen>

          где <literal>f0xxxxxx</literal> - это значение указателя инструкций.
          Однако неприятность заключается в том, что вы не получите точного
          соответствия, так как в таблице имен ядра для точек входа в функции
          даны адреса на начало функций, а указатель инструкций будет указывать
          куда-то внутрь её тела.  Если вы не получили точного соответствия,
          опустите последнюю цифру в значении указателя инструкций и попробуйте
          снова, то есть:
  
          <screen>
&prompt.user; <userinput>nm -n /kernel.that.caused.the.panic | grep f0xxxxx</userinput>
          </screen>

          Если и это не привело ни к каким результатам, отрежьте следующую
          цифру.  Повторяйте, пока не получите хоть что-то.  Результатом будет
          список функций, которые, возможно, привели к аварийному останову.
          Этот механизм обнаружения ошибочного места довольно неточен, но это
          всё же лучше, чем ничего.</para>
      </listitem>
    </itemizedlist>
  </para>

  <para>Зачастую люди приводят подобные аварийные сообщения, на редко кто
    утруждается привести соответствие указателя инструкций с функцией в
    таблице символов ядра.</para>

  <para>Лучшим способом выяснить причину, вызвавшую аварийный останов, является
    создание аварийного дампа системы, а затем использование
    <command>gdb(1)</command> для трассировки вызовов.  Конечно, это зависит от
    корректности работы <command>gdb(1)</command> с -CURRENT, что я
    гарантировать
    не могу (помнится, кто-то говорил, что новый ELF <command>gdb(1)</command>
    некорректно работает с аварийными дампами ядра: необходимо проверить это до
    выхода 3.0, иначе не избежать краски стыда на наших лицах после выпуска
    CD).</para>

  <para>Во всяком случае, обычно я использую такой способ:</para>

  <para>     
    <itemizedlist>
      <listitem>
        <para>Отредактируйте конфигурационный файл ядра, добавив строку
          <literal>options DDB</literal>, если вам зачем-то понадобился
          встроенный отладчик.  (Я использую его в основном для указания точек
          останова, если подозреваю возникновение бесконечных циклов.)</para>
      </listitem>

      <listitem>
        <para>Выполните
          <command>config -g <replaceable>KERNELCONFIG</replaceable></command>
          для создания каталога построения ядра.</para>
      </listitem>

      <listitem>
        <para>
          <command>cd /sys/compile/<replaceable>KERNELCONFIG</replaceable>;
          make</command></para>
      </listitem>

      <listitem>
        <para>Дождитесь окончания компиляции ядра.</para>
      </listitem>

      <listitem>
        <para><command>make install</command></para>
      </listitem>

      <listitem>
        <para>reboot</para>
      </listitem>
    </itemizedlist>
  </para>

  <para>В процессе выполнения команды &man.make.1; будут построены два ядра,
    <filename>kernel</filename> и <filename>kernel.debug</filename>.
    <filename>kernel</filename> будет установлен как
    <filename>/kernel</filename>, тогда как <filename>kernel.debug</filename>
    может быть использован в качестве источника отладочной информации для
    gdb(1).</para>

  <para>Чтобы включить сброс аварийного дампа, вам нужно отредактировать файл
    <filename>/etc/rc.conf</filename> так, чтобы устройство
    <emphasis remap=tt>dumpdev</emphasis> указывало на раздел подкачки.  В этом
    случае скрипты <command>rc(8)</command> будут вызывать команду
    <command>dumpon(8)</command> для включения создания аварийных дампов.  Вы
    можете запустить команду <command>dumpon(8)</command> вручную.  После
    аварийной остановки аварийный дамп может быть получен с помощью программы
    <command>savecore(8)</command>; если значение переменной
    <emphasis remap=tt>dumpdev</emphasis> было установлено в
    <filename>/etc/rc.conf</filename>, скрипты <command>rc(8)</command> запустят
    <command>savecore(8)</command> автоматически и поместят аварийный дамп в
    каталог <filename>/var/crash</filename>.</para>

  <para>
    <note>
      <para>Аварийные дампы FreeBSD обычно имеют размер, равный физическому
        объёму оперативной памяти вашей машины.  Так что если у вас 64МБ
        ОЗУ, вы получите дамп размером 64МБ.  Поэтому вы должны удостовериться,
        что в каталоге <filename>/var/crash</filename> достаточно места для
        хранения дампа.  Либо вы можете вручную запустить
        <command>savecore(8)</command> и создать аварийный дамп в другом
        каталоге, где достаточно места.  Размер аварийного дампа можно
        уменьшить, указав в конфигурации ядра
        <literal>options MAXMEM=(размер)</literal> подходящее значение для
        объёма памяти, которое будет использоваться ядром.  Например, если у вас
        128 МБ ОЗУ, вы можете ограничить использование памяти ядром 16
        мегабайтами, так что размер аварийного дампа будет равен 16МБ, а не
        128.</para>
    </note>
  </para>

  <para>Как только вы получили аварийный дамп, вы можете выполнить трассировку
    вызовов с помощью <command>gdb(1)</command> таким образом:</para>

  <screen>
&prompt.user; <userinput>gdb -k /sys/compile/KERNELCONFIG/kernel.debug /var/crash/vmcore.0</userinput>
<prompt>(gdb)</prompt> <userinput>where</userinput>
  </screen>

  <para>Заметьте, что при этом может быть выведено несколько экранов
    информации; в идеале вы должны использовать <command>script(1)</command>
    для их
    перехвата.  При использовании необработанного образа ядра со всей
    отладочной информацией может быть найдена конкретная строка исходного
    текста ядра, при достижении которой случилась аварийная остановка.
    Для выяснения последовательности событий, приведших к аварийному
    останову, обычно читается трассировка стека снизу вверх.  Вы можете
    также использовать <command>gdb(1)</command> для вывода значений различных
    переменных или структур, чтобы выяснить состояние системы во время
    аварии.</para>

  <para>Теперь, если вы в самом деле душевнобольной и у вас есть второй
    компьютер, то можете настроить <command>gdb(1)</command> для удалённой
    отладки, так, что сможете использовать <command>gdb(1)</command> на одном
    компьютере, чтобы
    отладить ядро на другом, включая использование точек останова,
    пошагового прохода по коду ядра, всё как с обычной прикладной
    программой.  Я пока с этим не игрался, так как не часто имею
    возможность поставить две машины одну напротив другой для отладки.</para>

  <para><emphasis>[Билл (Bill) добавил: "Я забыл обратить ваше внимание
    на одну вещь: если у вас включена поддержка DDB и ядро переходит
    в режим отладки, вы можете намеренно вызвать аварийный останов 
    (и создание аварийного дампа), набрав 'panic' в командной строке
    ddb.  Этот процесс может снова вызвать отладчик.  В этом случае
    наберите 'continue' и процесс будет завершён созданием аварийного
    дампа." -ed]</emphasis></para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="dlsym-failure">
    <para>Перестала работать функция dlsym() для ELF!</para>
  </question>

  <answer>

  <para>По умолчанию при работе с форматом ELF символы, определённые в
    выполнимом файле, не доступны динамическому загрузчику.  Поэтому
    при вызове функции <function>dlsym()</function>, которая осуществляет
    поиск по дескриптору, полученному после вызова <emphasis
    remap=tt>dlopen(NULL, flags)</emphasis>,
    желаемый результат достигнут не будет.</para>

  <para>Если вы хотите осуществить поиск в выполнимом файле процесса с
    помощью функции <function>dlsym()</function>, вам нужно компоновать
    выполнимый файл с опцией <option>-export-dynamic</option> <ulink
    URL="http://www.FreeBSD.org/cgi/man.cgi?ld">компоновщика ELF</ulink>.</para>

  </answer>
</qandaentry>


<qandaentry>
  <question id="change-kernel-address-space">
    <para>Увеличение и уменьшение адресного пространства ядра</para>
  </question>

  <answer>

  <para>По умолчанию размер адресного пространства ядра равен 256 МБ во
    FreeBSD 3.x и 1 ГБ во FreeBSD 4.x.  Если вы используете FreeBSD
    в качестве сервера с интенсивной сетевой нагрузкой (скажем,
    большой FTP или HTTP сервер), вы можете обнаружить, что 256 МБ
    недостаточно.</para>

  <para>Каким же образом можно увеличить адресное пространство? Здесь
    есть два момента.  Во-первых, вам нужно указать ядру выделить
    большее количество адресного пространства для самого ядра.  Во-вторых,
    так как ядро загружается в верхнюю часть адресного пространства, вам
    нужно уменьшить адрес загрузки так, чтобы он не вышел за верхнюю
    границу. </para>

  <para>Первая проблема решается увеличением значения константы
    <literal>NKPDE</literal> в
    файле <filename>src/sys/i386/include/pmap.h</filename>.  В случае 1 ГБ
    адресного пространства он должен выглядеть примерно так:</para>

  <programlisting>
#ifndef NKPDE
#ifdef SMP
#define NKPDE                   254     /* addressable number of page tables/pde's */
#else
#define NKPDE                   255     /* addressable number of page tables/pde's */
#endif  /* SMP */
#endif
  </programlisting>

  <para>Для вычисления значения <literal>NKPDE</literal> разделите желаемый
    объём адресного пространства (в мегабайтах) на четыре и вычтите из 
    получившегося числа единичку в случае однопроцессорной машины и
    двоечку в случае многопроцессорного ядра.</para>

  <para>Для достижения второй цели вам нужно правильный адрес для загрузки
    ядра: просто отнимите размер адресного пространства (в байтах) от
    0x100100000; результат будет равным 0xc0100000 для адресного пространства
    в 1 ГБ.  Установите значение константы <symbol>LOAD_ADDRESS</symbol>
    в файле <filename>src/sys/i386/conf/Makefile.i386</filename> в это
    значение; затем установите значение счётчика в начале списка секций в
    файле <filename>src/sys/i386/conf/kernel.script</filename> в то же самое
    значение, как это сделано здесь:</para>

  <programlisting>
OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(btext)
SEARCH_DIR(/usr/lib); SEARCH_DIR(/usr/obj/elf/home/src/tmp/usr/i386-unknown-freebsdelf/lib);
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  . = 0xc0100000 + SIZEOF_HEADERS;
  .interp     : { *(.interp)    }
  </programlisting>

  <para>После этого переконфигурируйте и перестройте ядро.  Вы можете
    столкнуться с проблемами при работе утилит <command>ps(1)</command>,
    <command>top(1)</command> и подобных им; решить их может
    <emphasis remap=tt>make world</emphasis> (или ручная перекомпиляция
    <emphasis remap=tt>libkvm</emphasis>, <emphasis remap=tt>ps</emphasis> и
    <emphasis remap=tt>top</emphasis> после копирования исправленного
    <filename>pmap.h</filename>
    в <filename>/usr/include/vm/)</filename>.</para>

  <para>ЗАМЕЧАНИЕ: Размер адресного пространства ядра должен быть
    кратен четырём мегабайтам.</para>
 
  <para>[&a.dg; добавил: <emphasis> Я думаю, что размер адресного пространства
    ядра должен быть степенью двойки, но я в этом не уверен.  Для работы с
    верхними адресами памяти использовался код старого загрузчика, и я ожидаю
    по крайней мере точность в 256 МБ.]</emphasis></para>

  </answer>
</qandaentry>
</qandaset>
</chapter>


<chapter id="acknowledgments">
  <title>Наши благодарности</title>

  <blockquote>
    <attribution>FreeBSD Core Team</attribution>

    <para>Если вы обнаружили неточности в этом FAQ или хотите что-то
      в него добавить, пожалуйста, напишите нам по адресу &a.faq;.
      Мы ждём ваши отзывы и пожелания, чтобы с вашей помощью сделать этот
      документ ещё лучше!</para>
  </blockquote>

  <para>   
    <variablelist>
      <varlistentry><term>&a.jkh;</term>
        <listitem>
          <para>Различные упорядочения и добавления в FAQ.</para>
        </listitem>
      </varlistentry>

      <varlistentry><term>&a.dwhite;</term>
        <listitem>
          <para>Работа со списком рассылки freebsd-questions</para>
        </listitem>
      </varlistentry>

      <varlistentry><term>&a.joerg;</term>
        <listitem>
          <para>Работа с телеконференциями Usenet</para>
        </listitem>
      </varlistentry>

      <varlistentry><term>&a.wollman;</term>
        <listitem>
          <para>Раздел о сети и форматирование</para>
        </listitem>
      </varlistentry>

      <varlistentry><term>Jim Lowe</term>
        <listitem>
          <para>Информация о протоколе многоадресной передачи</para>
        </listitem>
      </varlistentry>

      <varlistentry><term>&a.pds;</term>
        <listitem>
          <para>Раб-наборщик</para>
        </listitem>
      </varlistentry>

      <varlistentry><term>Andrey Zakhvatov</term>
        <listitem>
          <para>Перевод на русский язык</para>
        </listitem>
      </varlistentry>

      <varlistentry><term>The FreeBSD Team</term>
        <listitem>
          <para>Охи, вздохи, стоны, добавления</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </para>

  <para>И всем остальным, оставшимся неизвестными, наши глубочайшие
    извинения и сердечные благодарности!</para>

</chapter>
</book>
