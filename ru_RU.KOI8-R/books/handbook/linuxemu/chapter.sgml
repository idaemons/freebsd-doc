<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/linuxemu/chapter.sgml,v 1.3 2000/10/26 00:44:43 danfe Exp $
     Original revision: 1.32
-->

<chapter id="linuxemu">
  <title>Работа с приложениями, написанными для Linux</title>

  <para><emphasis>Реструктурировал и частично дополнил &a.jim;, 22 марта
    2000.  Оригинальная версия &a.handy; и &a.rich;</emphasis></para>

  <sect1>
    <title>Краткий обзор</title>

    <para>В этой главе будет рассказано о том, каким образом можно запускать
      приложения, изначально написанные для Linux, под FreeBSD и что нужно
      для этого сделать.</para>

    <para>Возможно, Вы спрашиваете себя, зачем FreeBSD нужно уметь работать
      с приложениями, написанными для Linux.  Ответ на этот вопрос достаточно
      прост: многие компании и разработчики производят программное
      обеспечение только для Linux, так как эта операционная система очень
      быстро завоевала огромную популярность в компьютерном мире.
      Пользователям же FreeBSD приходится обращаться к этим компаниям и
      разработчикам с просьбами выпустить версии своих программ специально
      для FreeBSD.  Проблема в том, что большинство производителей
      программного обеспечения не осознают, насколько бы увеличился их рынок
      сбыта, выпускай они FreeBSD версии наряду с Linux версиями, и
      продолжают разрабатывать только под Linux.  Что же делать
      пользователям FreeBSD?  В этой ситуации на помощь приходит Linux
      эмуляция.</para>

    <para>Вкратце, FreeBSD позволяет Вам работать с 90% приложений для
      Linux без каких-либо модификаций последних.  Среди них: Star Office,
      Linux версия Netscape, Adobe Acrobat, RealPlayer 5 и 7, VMWare,
      Oracle, WordPerfect, Doom, Quake и многие другие.  Есть сведения, что
      в некоторых ситуациях эти Linux программы показывали более высокую
      производительность при работе под FreeBSD, чем под Linux.</para>

    <para>Конечно, существует некоторые особенности Linux, которые (пока) не
      поддерживаются в полной мере FreeBSD.  Например, так обстоят дела с
      приложениями Linux, использующими файловую систему
      <filename>/proc</filename>, так как реализация последней сильно
      отличается от таковой в FreeBSD (однако, ситуация меняется к лучшему:
      в FreeBSD-CURRENT поддержка Linux procfs уже встроена в систему).
      Существуют также системные вызовы, специфичные для i386, как,
      например, переключение в режим V86.</para>

    <para>О том, как установить поддержку запуска Linux программ, читайте в
      <link linkend="linuxemu-lbc-install">следующей секции</link>.</para>
  </sect1>

  <sect1 id="linuxemu-lbc-install">
    <title>Инсталляция</title>

    <para>Начиная с 3.0-RELEASE, больше нет необходимости указывать
      <literal>options LINUX</literal> или <literal>options
      COMPAT_LINUX</literal> в Вашем файле конфигурации ядра.</para>

    <para>Поддержка Linux приложений осуществляется посредством специального
      модуля ядра (KLD объекта, <quote>Kernel LoaDable object</quote>), то
      есть его можно загрузить/выгрузить <quote>на лету</quote>, без
      необходимости перезагрузки.  Вам потребуется убедиться в наличии
      следующей строки в файле <filename>/etc/rc.conf</filename>:</para>

    <programlisting>linux_enable=<quote>YES</quote></programlisting>

    <para>Это, в свою очередь, повлияет на выполнение следующего кода в
      файле <filename>/etc/rc.i386</filename>:</para>

    <programlisting>
# Start the Linux binary compatibility if requested.
#
case ${linux_enable} in
[Yy][Ee][Ss])
	echo -n ' linux';	linux &gt; /dev/null 2&gt;&amp;1
	;;
esac</programlisting>

    <para>Если Вы хотите проверить, загружен ли модуль, это можно сделать
      при помощи команды <command>kldstat</command>:</para>

    <screen>&prompt.user; <userinput>kldstat</userinput>
Id Refs Address    Size     Name
 1    2 0xc0100000 16bdb8   kernel
 7    1 0xc24db000 d000     linux.ko</screen>

    <para>Если по какой-либо причине Вы не хотите или не можете загрузить
      KLD, то Вы можете статически включить поддержку Linux в ядро
      посредством опции <literal>options LINUX</literal> в файле
      конфигурации ядра.  Затем соберите и проинсталлируйте новое ядро,
      следуя описанию в секции, посвященной <link
      linkend="kernelconfig">конфигурации ядра</link>.</para>

    <sect2>
      <title>Установка необходимых Linux библиотек</title>

      <para>Установить все требуемые библиотеки можно двумя путями: либо
	используя порт <link linkend="linuxemu-libs-port">linux_base</link>,
	либо установив их <link
	linkend="linuxemu-libs-manually">вручную</link>.</para>

      <sect3 id="linuxemu-libs-port">
	<title>Установка с помощью порта linux_base</title>

	<para>Этот метод является самым простым, и мы рекомендуем
	  воспользоваться именно им.  Процесс аналогичен установке любого
	  другого порта из <ulink url="../ports/">коллекции портов</ulink>.
	  Просто выполните следующие команды:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/emulators/linux_base</userinput>
&prompt.root; <userinput>make install distclean</userinput></screen>

	<para>Теперь Вы можете работать с приложениями для Linux.  Некоторые
	  программы, возможно, будут сообщать о несоответствии подверсий
	  некоторых системных библиотек.  Однако, практически, это не
	  вызывает каких-либо неудобств.</para>
      </sect3>

      <sect3 id="linuxemu-libs-manually">
	<title>Установка библиотек вручную</title>

	<para>Если у Вас нет установленной коллекции портов, то можно
	  установить требуемые библиотеки вручную Вам понадобятся
	  разделяемые библиотеки для Linux, которые нужны программам, и
	  runtime-компоновщик.  Вам также потребуется создать <quote>теневой
	  корень</quote>: директорию <filename>/compat/linux</filename>, где
	  будут расположены Linux библиотеки.  Если нужно загрузить
	  какую-либо разделяемую библиотеку, FreeBSD сперва будет пытаться
	  найти ее в этом дереве.  Так, если программа загружает, например,
	  <filename>/lib/libc.so</filename>, FreeBSD попытается открыть
	  <filename>/compat/linux/lib/libc.so</filename>, и если такого
	  файла не существует, будет пытаться открыть
	  <filename>/lib/libc.so</filename>.  Разделяемые библиотеки должны
	  находиться в теневом дереве, а не в пути, сообщаемым командой
	  Linux <command>ld.so</command>.</para>

	<para>По мере работы с различными Linux программами, у Вас будет
	  накапливаться некий базовый набор библиотек, которого будет
	  достаточно для большинства существующих Linux приложений.</para>
      </sect3>

      <sect3>
	<title>Как установить дополнительные разделяемые библиотеки</title>

	<para>Что, если при установленном <filename>linux_base</filename>
	  порте Ваше приложение все равно сообщает об отсутствии необходимой
	  библиотеки?  Как узнать, какая именно нужна библиотека и где ее
	  взять?  В принципе, есть два способа.  Вам необходимо иметь
	  привилегии суперпользователя для их осуществления.</para>

	<para>Если у Вас есть доступ к машине, на которой установлен Linux,
	  узнайте, какие библиотеки использует Linux приложение, и просто
	  скопируйте из на свою машину.  Например:</para>

	<informalexample>
	  <para>Допустим, Вы скачали по FTP Linux версию Doom'а (на Linux
	    машине).  Вы можете узнать, какие разделяемые библиотеки нужны
	    Doom'у при помощи команды <command>ldd linuxdoom</command>:</para>

	  <screen>&prompt.user; <userinput>ldd linuxdoom</userinput>
libXt.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libX11.so.3.1.0
libc.so.4 (DLL Jump 4.5pl26) =&gt; /lib/libc.so.4.6.29</screen>

	  <para>Вам потребуются все файлы, перечисленные в последней
	    колонке.  Скопируйте их в директорию
	    <filename>/compat/linux</filename> на Вашей системе, а также
	    создайте символические ссылки на эти файлы, с именами ссылок из
	    первой колонки соответственно.  В итоге у Вас на машине должны
	    быть следующие файлы:</para>

	  <screen>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29 /compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</screen>

	  <blockquote>
	    <note>
	      <para>Заметьте, что если у Вас уже есть какая-либо из
		перечисленных библиотек, то ее не нужно копировать заново.
		Однако, у Вас может быть более старая версия.  В этом
		случае, лучше все-таки скопировать библиотеку поздней
		версии, изменив соответственно ссылку на нее.  Предыдущую
		версию библиотеки можно удалить.  Например, пусть у Вас есть
		следующие библиотеки:</para>

	      <screen>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</screen>

	      <para>и какое-либо приложение требует библиотеку более поздней
		версии, судя по команде <command>ldd</command>:</para>

	      <screen>libc.so.4 (DLL Jump 4.5pl26) -&gt; libc.so.4.6.29</screen>

	      <para>Если подверсии немного отличаются, копировать
		<filename>/lib/libc.so.4.6.29</filename> необязательно, так
		как программа, скорее всего, будет нормально работать и с
		устаревшей версией.  Тем не менее, Вы можете заменить
		<filename>libc.so</filename>:</para>

	      <screen>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</screen>
	    </note>
	  </blockquote>

	  <blockquote>
	    <note>
	      <para>Символические ссылки важны <emphasis>только</emphasis>
		для Linux программ.  Runtime-компоновщик FreeBSD
		самостоятельно подберет правильные номера версий библиотек,
		и Вам не нужно об этом беспокоиться.</para>
	    </note>
	  </blockquote>
	</informalexample>
      </sect3>
    </sect2>

    <sect2>
      <title>Настройка Linux ELF-исполняемых файлов</title>

      <para>Для ELF-программ иногда требуется сделать так называемый
	<quote>branding</quote>.  Если при попытке запустить ELF-файл, Вы
	получаете следующее сообщение об ошибке:</para>

      <screen>&prompt.user; <userinput>./linux-elf-программа</userinput>
ELF binary type not known
Abort</screen>

      <para>то нужно изменить тип исполняемого файла, чтобы ядро FreeBSD
	правильно определило, что это Linux программа.  Это можно сделать
	при помощи утилиты &man.brandelf.1;:</para>

      <screen>&prompt.user; <userinput>brandelf -t Linux linux-elf-программа</userinput></screen>

      <para>Следует отметить, что программы, для которых необходим
	<quote>branding</quote>, встречаются все реже и реже, и в недалеком
	будущем Вы вряд ли прибегнете к нему вообще.</para>
    </sect2>

    <sect2>
      <title>Распознавание доменных имен</title>

      <para>Если DNS не настроен или недоступен, или Вы получаете это
	сообщение:</para>

      <screen>resolv+: "bind" is an invalid keyword resolv+:
"hosts" is an invalid keyword</screen>

      <para>то Вам нужно создать (модифицировать) файл
	<filename>/compat/linux/etc/host.conf</filename>, содержащий:</para>

      <programlisting>
order hosts, bind
multi on</programlisting>

      <para>Таким образом, Вы указываете, то сначала производится поиск в
	файле <filename>/etc/hosts</filename>, а только затем запрашивается
	DNS.  Когда файл <filename>/compat/linux/etc/host.conf</filename>
	отсутствует, Linux приложения находят файл
	<filename>/etc/host.conf</filename> для FreeBSD и сообщают о
	несовместимом синтаксисе.  Если Вы не настраивали сервер имен
	(<filename>/etc/resolv.conf</filename>), уберите
	<literal>bind</literal> из файла
	<filename>/compat/linux/etc/host.conf</filename>.</para>
    </sect2>
  </sect1>

  <sect1 id="linuxemu-mathematica">
    <title>Установка пакета Mathematica</title>

    <para><emphasis>Обновлено для Mathematica версии 4.0 Murray Stokely
      <email>murray@cdrom.com</email> и объединено с работой Bojan
      Bistrovic <email>bojanb@physics.odu.edu</email>.</emphasis></para>

    <para>Ниже описано, как установить Linux версию пакета Mathematica 4.0
      на FreeBSD систему.</para>

    <para>Linux версия Mathematica отлично работает под FreeBSD, однако
      исполняемые файлы должны быть модифицированы утилитой
      &man.brandelf.1;.</para>

    <para>Linux версия пакета Mathematica или Mathematica для Студентов
      может быть заказана непосредственно через Wolfram по адресу <ulink
      url="http://www.wolfram.com/">http://www.wolfram.com/</ulink>.</para>

    <sect2>
      <title>Модификация исполняемых файлов</title>

      <para>Исполняемые файлы пакета Mathematica находятся в директории
	<filename>Unix</filename> на компакт диске с дистрибутивом.
	Скопируйте эту директорию (вместе со всеми подкаталогами) на Ваш
	жесткий диск, чтобы модифицировать (утилитой &man.brandelf.1;)
	исполняемые файлы перед инсталляцией:</para>

      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cp -rp /cdrom/Unix/ /localdir/</userinput>
&prompt.root; <userinput>brandelf -t Linux /localdir/Files/SystemFiles/Kernel/Binaries/Linux/*</userinput>
&prompt.root; <userinput>brandelf -t Linux /localdir/Files/SystemFiles/FrontEnd/Binaries/Linux/*</userinput>
&prompt.root; <userinput>brandelf -t Linux /localdir/Files/SystemFiles/Installation/Binaries/Linux/*</userinput>
&prompt.root; <userinput>cd /localdir/Installers/Linux/</userinput>
&prompt.root; <userinput>./MathInstaller</userinput></screen>
    </sect2>

    <sect2>
      <title>Пароль к пакету Mathematica</title>

      <para>Вам необходимо зарегистрировать свою копию пакета Mathematica и
	получить от Wolfram специальный пароль, соответствующий
	<quote>идентификатор машины</quote>.</para>

      <para>После того, как Вы установили необходимые библиотеки и
	распаковали файлы Mathematica, получите <quote>идентификатор
	машины</quote>, запустив программу <command>mathinfo</command> в
	инсталляционной директории.  Идентификатор машины зависит от
	MAC-адреса Вашей первой ethernet-карточки.</para>

      <screen>&prompt.root; <userinput>cd /localdir/Files/SystemFiles/Installation/Binaries/Linux</userinput>
&prompt.root; <userinput>mathinfo</userinput>
disco.example.com 7115-70839-20412</screen>

      <para>При регистрации, либо по телефону или факсу, либо по
	электронной почте, Вы сообщаете Ваш <quote>идентификатор
	машины</quote>, а в ответ получаете пароль, состоящий из нескольких
	чисел.  Введите этот пароль при первом запуске Mathematica.</para>
    </sect2>

    <sect2>
      <title>Внешний интерфейс пакета Mathematica</title>

      <para>Mathematica использует специальные шрифты для отображения
	некоторых символов, которые отсутствуют в стандартных шрифтах
	(символы интегралов, сумм, греческий алфавит и другие).  Протокол X
	требует, чтобы эти шрифты были установлены
	<emphasis>локально</emphasis>.  Это означает, что Вы должны
	скопировать эти шрифты с компакт диска или сетевого узла на Ваш
	жесткий диск.  Обычно, все шрифты должны находиться в каталоге
	<filename>/cdrom/Unix/Files/SystemFiles/Fonts</filename> компакт
	диска или
	<filename>/usr/local/mathematica/SystemFiles/Fonts</filename> на
	винчестере.  Собственно файлы со шрифтами находятся в подкаталогах
	<filename>Type1</filename> и <filename>X</filename>.  О том, как их
	использовать, читайте ниже.</para>

      <para>Можно просто скопировать их в один из существующих подкаталогов
	в директории <filename>/usr/X11R6/lib/X11/fonts</filename>.  В этом
	случае, Вам потребуется отредактировать файл
	<filename>fonts.dir</filename>, добавив в него названия шрифтов и
	изменив число шрифтов в первой строке.  Или Вы можете запустить
	программу <command>mkfontdir</command>, находясь в том каталоге,
	куда Вы скопировали шрифты.</para>

      <para>Есть альтернативный способ: скопировать директории в каталог
	<filename>/usr/X11R6/lib/X11/fonts</filename>:</para>

      <screen>&prompt.root; <userinput>cd /usr/X11R6/lib/X11/fonts</userinput>
&prompt.root; <userinput>mkdir X</userinput>
&prompt.root; <userinput>mkdir MathType1</userinput>
&prompt.root; <userinput>cd /cdrom/Unix/Files/SystemFiles/Fonts</userinput>
&prompt.root; <userinput>cp X/* /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>cp Type1/* /usr/X11R6/lib/X11/fonts/MathType1</userinput>
&prompt.root; <userinput>cd /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>mkfontdir</userinput>
&prompt.root; <userinput>cd ../MathType1</userinput>
&prompt.root; <userinput>mkfontdir</userinput</screen>

      <para>Теперь добавьте каталоги с новыми шрифтами в путь к
	шрифтам:</para>

      <screen>&prompt.root; <userinput>xset fp+ /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>xset fp+ /usr/X11R6/lib/X11/fonts/MathType1</userinput>
&prompt.root; <userinput>xset fp rehash</userinput></screen>

      <para>Если Вы используете XFree86, то можно просто прописать эти
	каталоги в файле <filename>XF86Config</filename>.</para>

      <para>Если на Вашем компьютере <emphasis>нет</emphasis> каталога
	<filename>/usr/X11R6/lib/X11/fonts/Type1</filename>, то замените
	<filename>MathType1</filename> на <filename>Type1</filename> в
	предыдущем примере.</para>
    </sect2>
  </sect1>

  <sect1 id="linuxemu-oracle">
    <title>Установка Oracle</title>

    <para><emphasis>Автор Marcel Moolenaar
	<email>marcel@cup.hp.com</email></emphasis></para>

    <sect2>
      <title>Введение</title>
      <para>Ниже описан процесс установки Oracle 8.0.5 и Oracle 8.0.5.1
	Enterprise Edition для Linux на систему с FreeBSD.</para>
    </sect2>

    <sect2>
      <title>Настройка Linux окружения</title>

      <para>Удостоверьтесь, что порты <filename>linux_base</filename> и
	<filename>linux_devtools</filename> установлены на Вашей системе.
	Они появились в коллекции портов после выхода FreeBSD 3.2.  Если Вы
	используете FreeBSD 3.2 или более раннюю, обновите коллекцию портов.
	Нелишним будет и апгрейд до более поздней версии FreeBSD.  Если у
	Вас возникнут трудности с <filename>linux_base-6.1</filename> или
	<filename>linux_devtools-6.1</filename>, воспользуйтесь версией 5.2
	этих пакетов.</para>

      <para>Если Вы хотите использовать intelligent agent, Вам также
	понадобится TCL пакет от Red Hat:
	<filename>tcl-8.0.3-20.i386.rpm</filename>.  Для этого
	воспользуйтесь следующей командой:</para>

      <screen>&prompt.root; <userinput>rpm -i --ignoreos --root /compat/linux --dbpath /var/lib/rpm <replaceable>package</replaceable></userinput></screen>

      <para>Установка этого пакета должна пройти без каких-либо ошибок.</para>
    </sect2>

    <sect2>
      <title>Настройка окружения Oracle</title>

      <para>Прежде чем Вы сможете установить Oracle, Вам необходимо
	обеспечить нужное окружение.  Ниже описывается, что
	<emphasis>конкретно</emphasis> нужно сделать, чтобы успешно запускать
	Oracle для Linux под FreeBSD.  За общими сведениями обратитесь к
	фирменному руководству по инсталляции Oracle.</para>

      <sect3 id="linuxemu-kernel-tuning">
	<title>Настройка ядра</title>

	<para>Как описывается в руководстве по инсталляции, необходимо
	  установить максимальный размер разделяемой памяти.  Не используйте
	  <literal>SHMMAX</literal> под FreeBSD.  <literal>SHMMAX</literal>
	  высчитывается, исходя из <literal>SHMMAXPGS</literal> и
	  <literal>PGSIZE</literal>.  Следовательно, нужно задавать
	  <literal>SHMMAXPGS</literal>.  За информацией о прочих опциях
	  обратитесь к фирменному руководству:</para>

	<programlisting>options SHMMAXPGS=10000
options SHMMNI=100
options SHMSEG=10
options SEMMNS=200
options SEMMNI=70
options SEMMSL=61</programlisting>

	<para>Установите эти опции в зависимости от того, как и для чего
	  Вы будете использовать Oracle.</para>

	<para>Не забудьте добавить следующие строки в файл конфигурации
	  ядра:</para>

<programlisting>options SYSVSHM # разделяемая память SysV
options SYSVSEM # семафоры SysV
options SYSVMSG # межпроцессное взаимодействие SysV</programlisting>
      </sect3>

      <sect3 id="linuxemu-oracle-account">
	
	<title>Oracle аккаунт</title>

	<para>Вам нужно создать специальный Oracle аккаунт, как и любой
	  другой аккаунт.  Единственное отличие в том, что Вы должны указать
	  для него командный интерпретатор Linux:
	  <filename>/compat/linux/bin/bash</filename>.  Не забудьте добавить
	  <literal>/compat/linux/bin/bash</literal> в файл
	  <filename>/etc/shells</filename>.</para>
      </sect3>

      <sect3 id="linuxemu-environment">
	<title>Переменные окружения</title>

	<para>Кроме стандартных переменных окружения, таких как
	  <envar>ORACLE_HOME</envar> и <envar>ORACLE_SID</envar>, Вам нужно
	  будет установить следующие дополнительные переменные:</para>

	<informaltable frame="none">
	  <tgroup cols="2">
	    <thead>
	      <row>
		<entry>Переменная</entry>

		<entry>Значение</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><envar>LD_LIBRARY_PATH</envar></entry>

		<entry><literal>$ORACLE_HOME/lib</literal></entry>
	      </row>

	      <row>
		<entry><envar>CLASSPATH</envar></entry>

		<entry><literal>$ORACLE_HOME/jdbc/lib/classes111.zip</literal></entry>
	      </row>

	      <row>
		<entry><envar>PATH</envar></entry>

		<entry><literal>/compat/linux/bin
/compat/linux/sbin
/compat/linux/usr/bin
/compat/linux/usr/sbin
/bin
/sbin
/usr/bin
/usr/sbin
/usr/local/bin
$ORACLE_HOME/bin</literal></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Желательно устанавливать их в файле
	  <filename>.profile</filename>.  Вот реальный пример:</para>

<programlisting>ORACLE_BASE=/oracle; export ORACLE_BASE
ORACLE_HOME=/oracle; export ORACLE_HOME
LD_LIBRARY_PATH=$ORACLE_HOME/lib
export LD_LIBRARY_PATH
ORACLE_SID=ORCL; export ORACLE_SID
ORACLE_TERM=386x; export ORACLE_TERM
CLASSPATH=$ORACLE_HOME/jdbc/lib/classes111.zip
export CLASSPATH
PATH=/compat/linux/bin:/compat/linux/sbin:/compat/linux/usr/bin:/compat/linux/usr/sbin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:$ORACLE_HOME/bin
export PATH</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Инсталляция Oracle</title>

      <para>Из-за небольшой несовместимости с Linux эмулятором, Вам нужно
	будет создать подкаталог <filename>.oracle</filename> в директории
	<filename>/var/tmp</filename> прежде чем можно будет начать
	инсталляцию.  Либо сделайте ее владельцем пользователя oracle, либо
	поставьте права на запись для всех.  Если Вы все сделали правильно,
	то инсталляция должна пройти без проблем.  Если какие-либо трудности
	все же возникли, проверьте еще раз все конфигурационные файлы и
	целостность дистрибутива.  После окончания установки, приложите
	патчи (смотрите следующие две секции).</para>

      <para>Одна из часто возникающих проблем &mdash; неправильно
	установленный TCP адаптер.  В результате, невозможно запустить TCP
	сервисы.  Вот решение проблемы:</para>

      <screen>&prompt.root; <userinput>cd $ORACLE_HOME/network/lib</userinput>
&prompt.root; <userinput>make -f ins_network.mk ntcontab.o</userinput>
&prompt.root; <userinput>cd $ORACLE_HOME/lib</userinput>
&prompt.root; <userinput>ar r libnetwork.a ntcontab.o</userinput>
&prompt.root; <userinput>cd $ORACLE_HOME/network/lib</userinput>
&prompt.root; <userinput>make -f ins_network.mk install</userinput></screen>

      <para>Не забудьте повторно запустить <filename>root.sh</filename>!</para>

    <sect3 id="linuxemu-patch-root">
      <title>Модификация root.sh</title>

	<para>Инсталлируя Oracle, необходимо выполнить некоторые действия
	  (имея при этом привилегии суперпользователя).  Фактически это
	  сводится к выполнению скрипта <filename>root.sh</filename>,
	  который находится в директории <filename>orainst</filename>.
	  Перед запуском, приложите к нему следующий патч (исправляет
	  местонахождение утилиты chown), либо запускайте его в командном
	  интерпретаторе Linux.</para>

	<programlisting>*** orainst/root.sh.orig Tue Oct 6 21:57:33 1998
--- orainst/root.sh Mon Dec 28 15:58:53 1998
***************
*** 31,37 ****
# This is the default value for CHOWN
# It will redefined later in this script for those ports
# which have it conditionally defined in ss_install.h
! CHOWN=/bin/chown
#
# Define variables to be used in this script
--- 31,37 ----
# This is the default value for CHOWN
# It will redefined later in this script for those ports
# which have it conditionally defined in ss_install.h
! CHOWN=/usr/sbin/chown
#
# Define variables to be used in this script</programlisting>

	<para>Если Вы инсталлируете Oracle не с компакт диска, то можно
	  модифицировать файл <filename>rthd.sh</filename>, который
	  находится в директории <filename>orainst</filename>.</para>
      </sect3>

      <sect3 id="linuxemu-patch-tcl">
	<title>Модификация genclntsh</title>

	<para>Скрипт genclntsh используется для того, чтобы создать единую
	  разделяемую клиентскую библиотеку.  Приложите следующий патч,
	  чтобы закомментировать определение переменной PATH:</para>

	<programlisting>*** bin/genclntsh.orig Wed Sep 30 07:37:19 1998
--- bin/genclntsh Tue Dec 22 15:36:49 1998
***************
*** 32,38 ****
#
# Explicit path to ensure that we're using the correct commands
#PATH=/usr/bin:/usr/ccs/bin export PATH
! PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin export PATH
#
# each product MUST provide a $PRODUCT/admin/shrept.lst
--- 32,38 ----
#
# Explicit path to ensure that we're using the correct commands
#PATH=/usr/bin:/usr/ccs/bin export PATH
! #PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin export PATH
#
# each product MUST provide a $PRODUCT/admin/shrept.lst</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Запуск и использование Oracle</title>

      <para>Теперь, если Вы все сделали правильно, то можете использовать
	Oracle так же, как если бы Вы поставили его на Linux систему.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>Дополнительные сведения</title>

    <para>Если Вы интересуетесь, как работает Linux эмуляция, эта секция для
      Вас.  Большинство материала взято из электронного письма, адресованного
      &a.chat; by Terry Lambert <email>tlambert@primenet.com</email> (ID
      письма: <literal>&lt;199906020108.SAA07001@usr09.primenet.com&gt;</literal>).</para>

    <sect2>
      <title>Как все это устроено?</title>

      <para>FreeBSD поддерживает абстракцию, называемую <quote>загрузчик
	исполнимых классов</quote>, который фактически является первой
	стадией системного вызова &man.execve.2;.</para>

      <para>На самом деле, FreeBSD имеет несколько загрузчиков вместо
	одного, который, в случае неудачи, выполняет программу как
	сценарий (скрипт).</para>

      <para>Исторически сложилось, что единственный загрузчик в UNIX
	системах проверял <quote>магическое число</quote> (чаще всего первые
	4 или 8 байт файла), чтобы определить, известен ли формат
	исполняемого файла системе, и если да, то вызвал соответствующий
	загрузчик.</para>

      <para>Если файл не опознавался системой как исполнимый, &man.execve.2;
	возвращал ошибку, и текущий командный интерпретатор начинал
	выполнять файл как скрипт.</para>

      <para>Позднее, &man.sh.1; был модифицирован, так, чтобы проверять
	первые два символа в файле, и если они оказывались
	<literal>:\n</literal>, то файл выполнялся как сценарий для
	&man.csh.1; (утверждается, что SCO были первыми, кто сделал
	эту модификацию).</para>

      <para>FreeBSD ведет себя по-другому: пробегает по списку загрузчиков,
	включая специальный <literal>#!</literal> загрузчик, который
	вызывает нужный интерпретатор или <filename>/bin/sh</filename>, если
	не нашел подходящего.</para>

      <para>Формат исполняемого файла FreeBSD определяет по
	<quote>магическому числу</quote>.  На этой стадии пока не
	различается, для какой операционной системы предназначен файл
	(Linux, Solaris, или любой другой, использующей ELF-формат
	исполняемых файлов).</para>

      <para>Далее, ELF-загрузчик определяет <quote>марку</quote>
	(специальный комментарий; отсутствует в исполняемых файлах
	SVR4/Solaris) исполняемого файла, то есть для какой операционной
	системы он предназначен.</para>

      <para>Соответственно, Linux программы должны быть
	<quote>маркированы</quote> для <literal>Linux</literal> (например, с
	помощью утилиты &man.brandelf.1;):</para>

      <screen>&prompt.root; <userinput>brandelf -t Linux file</userinput></screen>

      <para>Когда ELF-загрузчик находит <quote>марку</quote>
	<literal>Linux</literal>, он заменяет соответствующий указатель в
	структуре <literal>proc</literal>.  Все системные вызовы
	индексируются через этот указатель (в традиционной UNIX системе, это
	массив <literal>sysent[]</literal>, содержащий системные вызовы).
	Некоторые особые ситуации и системные вызовы обрабатываются
	специальным модулем ядра поддержки Linux.</para>

      <para>Плюс ко всему, Linux эмулятор динамически <quote>изменяет
	корень</quote> файловой системы при поиске файлов (фактически делая
	то же самое, что и опция <literal>union</literal> при монтировании
	файловых систем (не путать с unionfs!)).  Сперва, файл ищется в
	директории
	<filename>/compat/linux/<replaceable>original-path</replaceable></filename>
	и только затем, в случае неудачи, в
	<filename>/<replaceable>original-path</replaceable></filename>.  Это
	дает возможность Linux программам выполнять FreeBSD команды, если не
	найдется соответствующих Linux команд.  Например, скопировав FreeBSD
	&man.uname.1; в каталог <filename>/compat/linux/bin/</filename>,
	можно <quote>заставить</quote> Linux программы сообщать, что они
	запускаются под FreeBSD.</para>

      <para>На самом деле, ядра FreeBSD и Linux во многом похожи: системные
	операции, виртуальная память, система сигналов и сообщений,
	межпроцессное взаимодействие и прочее.  Разница в том, что FreeBSD
	программы обращаются к системным вызовам FreeBSD, Linux программы
	соответственно к системным вызовам Linux.  Во многих операционных
	системах прошлого адреса системных вызовов были
	<emphasis>зашиты</emphasis> в статический глобальный массив
	<literal>sysent[]</literal>, вместо обращения по указателю в
	структуре <literal>proc</literal>, который инициализируется
	динамически, позволяя таким образом запускать программы, написанные
	для разных операционных систем.</para>

      <para>В чем же разница между системными вызовами Linux и FreeBSD?
	Фактически никакой.  Единственное различие (на данный момент, в
	будущем все может и, вероятно, изменится), пожалуй, в том, что
	функции системных вызовов FreeBSD зашиты в ядро, а для Linux они
	могут быть либо в ядре, либо в динамически загружаемом
	модуле.</para>

      <para>Можно ли назвать это эмуляцией?  Нет.  Как таковой, эмулятор
	(или симулятор) отсутствует.  В таком случае, почему же тогда
	говорят <quote>Linux эмуляция</quote>?  Чтобы
	<quote>насолить</quote> FreeBSD?!  <!-- smiley -->8-).  На самом
	деле, это вопрос терминологии: не существовало слова, которое бы
	точнее описывало этот процесс.  Нельзя сказать, что FreeBSD
	запускает приложения Linux (без перекомпиляции или загрузки
	соответствующего модуля ядра).  Тогда и придумали термин
	<quote>Linux эмуляция</quote>.</para>
    </sect2>
  </sect1>
</chapter>
