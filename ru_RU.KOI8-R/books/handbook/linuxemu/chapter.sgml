<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru$

     Original revision: 1.114
-->

<chapter id="linuxemu">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Реструктурировал и частично обновил </contrib>
      </author>
      <!-- 22 Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Brian N.</firstname>
	<surname>Handy</surname>
	<contrib>Первоначально предоставили </contrib>
      </author>
      <author>
	<firstname>Rich</firstname>
	<surname>Murphey</surname>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Алексей</firstname>
	<surname>Докучаев</surname>
	<contrib>Перевод на русский язык: </contrib>
      </author>
    </authorgroup>
  </chapterinfo>
  <title>Работа с приложениями, написанными для Linux</title>

  <sect1 id="linuxemu-synopsis">
    <title>Краткий обзор</title>

    <indexterm><primary>Linux - бинарная совместимость</primary></indexterm>
    <indexterm>
      <primary>бинарная совместимость</primary>
      <secondary>Linux</secondary>
    </indexterm>

    <para>FreeBSD предоставляет бинарную совместимость с несколькими другими
      &unix; подобными операционными системами, включая Linux.
      Возможно, Вы спрашиваете себя, зачем FreeBSD нужно уметь работать
      с приложениями, написанными для Linux.  Ответ на этот вопрос достаточно
      прост: многие компании и разработчики производят программное
      обеспечение только для Linux, так как эта операционная система очень
      быстро завоевала огромную популярность в компьютерном мире.
      Пользователям же FreeBSD приходится обращаться к этим компаниям и
      разработчикам с просьбами выпустить версии своих программ специально
      для FreeBSD.  Проблема в том, что большинство производителей
      программного обеспечения не осознают, насколько бы увеличился их рынок
      сбыта, выпускай они FreeBSD версии наряду с Linux версиями, и
      продолжают разрабатывать только под Linux.  Что же делать
      пользователям FreeBSD?  В этой ситуации на помощь приходит Linux
      эмуляция.</para>

    <para>Вкратце, FreeBSD позволяет Вам работать с 90% приложений для
      Linux без каких-либо модификаций последних.  Среди них:
      <application>&staroffice;</application>, Linux версия
      <application>&netscape;</application>,
      <application>&adobe;&nbsp;&acrobat;</application>,
      <application><trademark
      class="registered">RealPlayer</trademark></application>
      5 и 7, <application><trademark>VMware</trademark></application>,
      <application>&oracle;</application>, <application><trademark
      class="registered">WordPerfect</trademark></application>,
      <application>Doom</application>, <application>Quake</application>,
      и многие другие.  Есть сведения, что
      в некоторых ситуациях эти Linux программы показывали более высокую
      производительность при работе под FreeBSD, чем под Linux.</para>

    <indexterm>
      <primary>Linux</primary>
      <secondary>файловая система <filename>/proc</filename></secondary>
    </indexterm>

    <para>Конечно, существует некоторые особенности Linux, которые не
      поддерживаются в полной мере FreeBSD.  Например, так обстоят дела с
      приложениями Linux, использующими файловую систему
      <filename>/proc</filename>, так как реализация последней сильно
      отличается от файловой системы <filename>/proc</filename> в FreeBSD.
      Существуют также системные вызовы, специфичные для &i386;, как,
      например, переключение в виртуальный режим 8086.</para>

    <para>При чтении этой главы вы узнаете:</para>
    <itemizedlist>
      <listitem>
	<para>Как включить бинарную совместимость с Linux в
	  вашей системе.</para>
      </listitem>

      <listitem>
	<para>Как установить дополнительные совместно используемые
	  библиотеки Linux.</para>
	</listitem>

      <listitem>
	<para>Как установить приложения Linux в систему
	  FreeBSD.</para>
      </listitem>

      <listitem>
	<para>Детали реализации совместимости с Linux в
	  FreeBSD.</para>
      </listitem>
    </itemizedlist>

    <para>Перед прочтением этой главы вам
      потребуется:</para>

    <itemizedlist>
      <listitem>
	<para>Узнать как устанавливать дополнительное
	  программное обеспечение сторонних разработчиков
	  (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="linuxemu-lbc-install">
    <title>Установка</title>

    <indexterm><primary>KLD (загружаемый объект ядра)</primary></indexterm>

    <para>Бинарная совместимость с Linux не включена по умолчанию.
      Простейший способ включения этой функциональности заключается
      в загрузке KLD объекта <literal>linux</literal> (<quote>Kernel
      LoaDable object</quote>).  Вы можете загрузить этот модуль,
      просто набрав <command>linux</command> в командной строке.</para>

    <para>Если вы хотите, чтобы совместимость с Linux была включена
      постоянно, необходимо добавить в <filename>/etc/rc.conf</filename>
      следующую строку:</para>

    <programlisting>linux_enable="YES"</programlisting>

    <para>Для проверки того, загружен ли KLD, может быть использована
      команда &man.kldstat.8;:</para>

    <screen>&prompt.user; <userinput>kldstat</userinput>
Id Refs Address    Size     Name
 1    2 0xc0100000 16bdb8   kernel
 7    1 0xc24db000 d000     linux.ko</screen>

    <indexterm>
      <primary>параметры ядра</primary>
      <secondary>LINUX</secondary>
    </indexterm>

    <para>Если по какой-либо причине вы не хотите или не можете загрузить
      KLD, то вы можете статически включить поддержку Linux в ядро
      посредством опции <literal>options COMPAT_LINUX</literal> в файле
      конфигурации ядра.  Затем соберите и проинсталлируйте новое ядро,
      следуя описанию в <xref linkend="kernelconfig">.</para>

    <sect2>
      <title>Установка необходимых Linux библиотек</title>

      <indexterm>
	<primary>Linux</primary>
	<secondary>установка библиотек Linux</secondary>
      </indexterm>

      <para>Установить все требуемые библиотеки можно двумя путями: либо
	используя порт <link linkend="linuxemu-libs-port">linux_base</link>,
	либо установив их <link
	linkend="linuxemu-libs-manually">вручную</link>.</para>

      <sect3 id="linuxemu-libs-port">
	<title>Установка с помощью порта linux_base</title>

	<indexterm><primary>коллекция портов</primary></indexterm>

	<para>Этот метод является самым простым, и мы рекомендуем
	  воспользоваться именно им.  Процесс аналогичен установке любого
	  другого порта из <ulink type="html"
	  url="file://localhost/usr/ports/">коллекции портов</ulink>.
	  Просто выполните следующие команды:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/emulators/linux_base</userinput>
&prompt.root; <userinput>make install distclean</userinput></screen>

	<para>Теперь Вы можете работать с приложениями для Linux.  Некоторые
	  программы, возможно, будут сообщать о несоответствии подверсий
	  некоторых системных библиотек.  Однако, практически, это не
	  вызывает каких-либо неудобств.</para>

	<note><para>Возможно наличие нескольких версий порта <filename
	  role="package">emulators/linux_base</filename>, соответствующих
	  различным версиям разных дистрибутивов Linux.  Вы должны
	  установить порт, наиболее близко соотвествующий требованиям
	  приложений Linux, которые будут установлены.</para></note>

      </sect3>

      <sect3 id="linuxemu-libs-manually">
	<title>Установка библиотек вручную</title>

	<para>Если у вас нет установленной коллекции портов, можно
	  установить требуемые библиотеки вручную. Вам понадобятся
	  разделяемые библиотеки для Linux, которые нужны программам, и
	  runtime-компоновщик.  Вам также потребуется создать <quote>теневой
	  корень</quote>: директорию <filename>/compat/linux</filename>, где
	  будут расположены Linux библиотеки.  Если нужно загрузить
	  какую-либо разделяемую библиотеку, FreeBSD сперва будет пытаться
	  найти ее в этом дереве.  Так, если программа загружает, например,
	  <filename>/lib/libc.so</filename>, FreeBSD попытается открыть
	  <filename>/compat/linux/lib/libc.so</filename>, и если такого
	  файла не существует, будет пытаться открыть
	  <filename>/lib/libc.so</filename>.  Разделяемые библиотеки должны
	  находиться в теневом дереве, а не в пути, сообщаемым командой
	  Linux <command>ld.so</command>.</para>

	<para>По мере работы с различными Linux программами, у вас будет
	  накапливаться некий базовый набор библиотек, которого будет
	  достаточно для большинства существующих Linux приложений.</para>
      </sect3>

      <sect3>
	<title>Как установить дополнительные совместно используемые библиотеки</title>

	<indexterm><primary>совместно используемые библиотеки</primary></indexterm>

	<para>Что, если при установленном <filename>linux_base</filename>
	  порте ваше приложение все равно сообщает об отсутствии необходимой
	  библиотеки?  Как узнать, какая именно нужна библиотека и где ее
	  взять?  В принципе, есть два способа.  Вам необходимо иметь
	  привилегии суперпользователя для их осуществления.</para>

	<para>Если у вас есть доступ к машине, на которой установлен Linux,
	  узнайте, какие библиотеки использует Linux приложение, и просто
	  скопируйте из на свою машину.  Например:</para>

	<informalexample>
	  <para>Допустим, вы скачали по FTP Linux версию
	    <application>Doom</application> (на Linux
	    машине).  Вы можете узнать, какие разделяемые библиотеки нужны
	    <application>Doom</application> при помощи команды
	    <command>ldd linuxdoom</command>:</para>

	  <screen>&prompt.user; <userinput>ldd linuxdoom</userinput>
libXt.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libX11.so.3.1.0
libc.so.4 (DLL Jump 4.5pl26) =&gt; /lib/libc.so.4.6.29</screen>

	  <indexterm><primary>символические ссылки</primary></indexterm>

	  <para>Вам потребуются все файлы, перечисленные в последней
	    колонке.  Скопируйте их в директорию
	    <filename>/compat/linux</filename> на вашей системе, а также
	    создайте символические ссылки на эти файлы, с именами ссылок из
	    первой колонки соответственно.  В итоге у вас на машине должны
	    быть следующие файлы:</para>

	  <screen>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</screen>

	  <blockquote>
	    <note>
	      <para>Заметьте, что если у вас уже есть какая-либо из
		перечисленных библиотек, то ее не нужно копировать заново.
		Однако, у вас может быть более старая версия.  В этом
		случае, лучше все-таки скопировать библиотеку поздней
		версии, изменив соответственно ссылку на нее.  Предыдущую
		версию библиотеки можно удалить.  Например, пусть у вас есть
		следующие библиотеки:</para>

	      <screen>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</screen>

	      <para>и какое-либо приложение требует библиотеку более поздней
		версии, судя по команде <command>ldd</command>:</para>

	      <screen>libc.so.4 (DLL Jump 4.5pl26) -&gt; libc.so.4.6.29</screen>

	      <para>Если подверсии немного отличаются, копировать
		<filename>/lib/libc.so.4.6.29</filename> необязательно, так
		как программа, скорее всего, будет нормально работать и с
		устаревшей версией.  Тем не менее, вы можете заменить
		<filename>libc.so</filename>:</para>

	      <screen>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</screen>
	    </note>
	  </blockquote>

	  <blockquote>
	    <note>
	      <para>Символические ссылки важны <emphasis>только</emphasis>
		для Linux программ.  Runtime-компоновщик FreeBSD
		самостоятельно подберет правильные номера версий библиотек,
		и вам не нужно об этом беспокоиться.</para>
	    </note>
	  </blockquote>
	</informalexample>
      </sect3>
    </sect2>

    <sect2>
      <title>Установка Linux ELF исполняемых файлов</title>

      <indexterm>
	<primary>Linux</primary>
	<secondary>ELF исполняемые файлы</secondary>
      </indexterm>

      <para>Для ELF программ иногда требуется сделать так называемый
	<quote>branding</quote>.  Если при попытке запустить ELF-файл, Вы
	получаете следующее сообщение об ошибке:</para>

      <screen>&prompt.user; <userinput>./linux-elf-программа</userinput>
ELF binary type not known
Abort</screen>

      <para>то нужно изменить тип исполняемого файла, чтобы ядро FreeBSD
	правильно определило, что это Linux программа.  Это можно сделать
	при помощи утилиты &man.brandelf.1;:</para>

      <screen>&prompt.user; <userinput>brandelf -t Linux linux-elf-программа</userinput></screen>

      <indexterm><primary>GNU toolchain</primary></indexterm>

      <para>В настоящее время GNU toolchain помещает необходимую информацию
	в исполняемые файлы ELF автоматически, поэтому необходимость
	в этом действии случается все реже и реже, и в недалеком
	будущем вы вряд ли прибегнете к нему вообще.</para>
    </sect2>

    <sect2>
      <title>Распознавание доменных имен</title>

      <para>Если DNS не настроен или недоступен, или вы получаете это
	сообщение:</para>

      <screen>resolv+: "bind" is an invalid keyword resolv+:
"hosts" is an invalid keyword</screen>

      <para>то вам нужно создать (модифицировать) файл
	<filename>/compat/linux/etc/host.conf</filename>, содержащий:</para>

      <programlisting>order hosts, bind
multi on</programlisting>

      <para>Таким образом, вы указываете, то сначала производится поиск в
	файле <filename>/etc/hosts</filename>, а только затем запрашивается
	DNS.  Когда файл <filename>/compat/linux/etc/host.conf</filename>
	отсутствует, Linux приложения находят файл
	<filename>/etc/host.conf</filename> для FreeBSD и сообщают о
	несовместимом синтаксисе.  Если вы не настраивали сервер имен
	(<filename>/etc/resolv.conf</filename>), уберите
	<literal>bind</literal> из файла
	<filename>/compat/linux/etc/host.conf</filename>.</para>
    </sect2>
  </sect1>

  <sect1 id="linuxemu-mathematica">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	  <contrib>Обновил для Mathematica 4.X </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Bojan</firstname>
	  <surname>Bistrovic</surname>
	  <contrib>Объединено с работой </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Установка &mathematica;</title>

    <indexterm>
      <primary>приложения</primary>
      <secondary><application>Mathematica</application></secondary>
    </indexterm>

    <para>Ниже описано, как установить Linux версию пакета
      <application>&mathematica; 4.X</application>
      на систему FreeBSD.</para>

    <para>Linux версия <application>&mathematica;</application> отлично
      работает под FreeBSD, однако
      исполняемые файлы, поставляемые Wolfram, должны быть модифицированы
      утилитой &man.brandelf.1;, чтобы FreeBSD знала о необходимости
      использования Linux ABI для их выполнения.</para>

    <para>Linux версия пакета <application>&mathematica;</application>
      или <application>&mathematica;</application> для студентов
      может быть заказана непосредственно через Wolfram по адресу <ulink
      url="http://www.wolfram.com/"></ulink>.</para>

    <sect2>
      <title>Модификация исполняемых файлов</title>

      <para>Исполняемые файлы пакета <application>&mathematica;</application>
	находятся в директории
	<filename>Unix</filename> на компакт диске с дистрибутивом.
	Скопируйте эту директорию (вместе со всеми подкаталогами) на ваш
	жесткий диск, чтобы модифицировать (утилитой &man.brandelf.1;)
	исполняемые файлы перед инсталляцией:</para>

      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cp -rp /cdrom/Unix/ /localdir/</userinput>
&prompt.root; <userinput>brandelf -t Linux /localdir/Files/SystemFiles/Kernel/Binaries/Linux/*</userinput>
&prompt.root; <userinput>brandelf -t Linux /localdir/Files/SystemFiles/FrontEnd/Binaries/Linux/*</userinput>
&prompt.root; <userinput>brandelf -t Linux /localdir/Files/SystemFiles/Installation/Binaries/Linux/*</userinput>
&prompt.root; <userinput>brandelf -t Linux /localdir/Files/SystemFiles/Graphics/Binaries/Linux/*</userinput>
&prompt.root; <userinput>brandelf -t Linux /localdir/Files/SystemFiles/Converters/Binaries/Linux/*</userinput>
&prompt.root; <userinput>brandelf -t Linux /localdir/Files/SystemFiles/LicenseManager/Binaries/Linux/mathlm</userinput>
&prompt.root; <userinput>cd /localdir/Installers/Linux/</userinput>
&prompt.root; <userinput>./MathInstaller</userinput></screen>

    <para>Вы также можете установить ELF brand по умолчанию для всех
      приложений Linux, которым это требуется, с помощью команды:</para>

    <screen>&prompt.root; <userinput>sysctl kern.fallback_elf_brand=3</userinput></screen>

    <para>FreeBSD будет считать, что все программы, не
      обработанные &man.brandelf.1; используют Linux ABI и вы сможете
      запустить MathInstaller прямо с CDROM.</para>
    </sect2>

    <sect2>
      <title>Пароль к пакету &mathematica;</title>

      <para>Вам необходимо зарегистрировать свою копию пакета
	<application>&mathematica;</application> и
	получить от Wolfram специальный пароль, соответствующий
	<quote>идентификатору машины</quote>.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC адрес</secondary>
      </indexterm>

      <para>После того, как вы установили необходимые библиотеки и
	распаковали файлы <application>&mathematica;</application>,
	получите <quote>идентификатор
	машины</quote>, запустив программу <command>mathinfo</command> в
	инсталляционной директории.  Идентификатор машины зависит от
	MAC-адреса вашей первой Ethernet-карты.</para>

      <screen>&prompt.root; <userinput>cd /localdir/Files/SystemFiles/Installation/Binaries/Linux</userinput>
&prompt.root; <userinput>mathinfo</userinput>
disco.example.com 7115-70839-20412</screen>

      <para>При регистрации, либо по телефону или факсу, либо по
	электронной почте, вы сообщаете <quote>идентификатор
	машины</quote>, а в ответ получаете пароль, состоящий из нескольких
	чисел.  Введите этот пароль при первом запуске
	<application>&mathematica;</application>, как и для
	любой другой платформы.</para>
    </sect2>

    <sect2>
      <title>Подключение интерфейс &mathematica; через сеть</title>

      <para><application>&mathematica;</application> использует специальные
	шрифты для отображения
	некоторых символов, которые отсутствуют в стандартных шрифтах
	(символы интегралов, сумм, греческий алфавит и другие).  Протокол X
	требует, чтобы эти шрифты были установлены
	<emphasis>локально</emphasis>.  Это означает, что вы должны
	скопировать эти шрифты с компакт диска или сетевого узла
	<application>&mathematica;</application> на ваш
	жесткий диск.  Обычно, все шрифты должны находиться в каталоге
	<filename>/cdrom/Unix/Files/SystemFiles/Fonts</filename> компакт
	диска или
	<filename>/usr/local/mathematica/SystemFiles/Fonts</filename> на
	винчестере.  Собственно файлы со шрифтами находятся в подкаталогах
	<filename>Type1</filename> и <filename>X</filename>.  О том, как их
	использовать, читайте ниже.</para>

      <para>Можно просто скопировать их в один из существующих подкаталогов
	в директории <filename>/usr/X11R6/lib/X11/fonts</filename>.  В этом
	случае, вам потребуется отредактировать файл
	<filename>fonts.dir</filename>, добавив в него названия шрифтов и
	изменив число шрифтов в первой строке.  Или вы можете запустить
	программу &man.mkfontdir.1;, находясь в том каталоге,
	куда вы скопировали шрифты.</para>

      <para>Есть альтернативный способ: скопировать директории в каталог
	<filename>/usr/X11R6/lib/X11/fonts</filename>:</para>

      <screen>&prompt.root; <userinput>cd /usr/X11R6/lib/X11/fonts</userinput>
&prompt.root; <userinput>mkdir X</userinput>
&prompt.root; <userinput>mkdir MathType1</userinput>
&prompt.root; <userinput>cd /cdrom/Unix/Files/SystemFiles/Fonts</userinput>
&prompt.root; <userinput>cp X/* /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>cp Type1/* /usr/X11R6/lib/X11/fonts/MathType1</userinput>
&prompt.root; <userinput>cd /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>mkfontdir</userinput>
&prompt.root; <userinput>cd ../MathType1</userinput>
&prompt.root; <userinput>mkfontdir</userinput></screen>

      <para>Теперь добавьте каталоги с новыми шрифтами в путь к
	шрифтам:</para>

      <screen>&prompt.root; <userinput>xset fp+ /usr/X11R6/lib/X11/fonts/X</userinput>
&prompt.root; <userinput>xset fp+ /usr/X11R6/lib/X11/fonts/MathType1</userinput>
&prompt.root; <userinput>xset fp rehash</userinput></screen>

      <para>Если вы используете <application>&xfree86;</application>,
	то можно просто прописать эти
	каталоги в файле <filename>XF86Config</filename>.</para>

      <indexterm><primary>шрифты</primary></indexterm>

      <para>Если на вашем компьютере <emphasis>нет</emphasis> каталога
	<filename>/usr/X11R6/lib/X11/fonts/Type1</filename>, замените
	<filename>MathType1</filename> на <filename>Type1</filename> в
	предыдущем примере.</para>
    </sect2>
  </sect1>

  <sect1 id="linuxemu-maple">
    <title>Installing &maple; *</title>

    <para>Этот раздел не переведен.</para>
  </sect1>

  <sect1 id="linuxemu-matlab">
    <title>Installing &matlab; *</title>

    <para>Этот раздел не переведен.</para>
  </sect1>

  <sect1 id="linuxemu-oracle">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marcel</firstname>
	  <surname>Moolenaar</surname>
	  <contrib>Предоставил </contrib>
	</author>
	<!-- marcel@cup.hp.com -->
      </authorgroup>
    </sect1info>
    <title>Установка &oracle;</title>

    <indexterm>
      <primary>приложения</primary>
      <secondary><application>Oracle</application></secondary>
    </indexterm>

    <sect2>
      <title>Введение</title>

      <para>Ниже описан процесс установки <application>&oracle;
      8.0.5</application> и <application>&oracle; 8.0.5.1 Enterprise
      Edition</application> для Linux на систему FreeBSD.</para>
    </sect2>

    <sect2>
      <title>Настройка Linux окружения</title>

      <para>Удостоверьтесь, что порты <filename
	role='package'>emulators/linux_base</filename> и
	<filename role='package'>devel/linux_devtools</filename> установлены
	на вашей системе. Если у вас возникнут трудности с этими портами,
	воспользуйтесь более ранней их версией.</para>

      <para>Если вы хотите использовать intelligent agent, также
	понадобится TCL пакет от Red Hat:
	<filename>tcl-8.0.3-20.i386.rpm</filename>.  Для этого
	воспользуйтесь следующей командой <application>RPM</application>
	(<filename role='package'>archivers/rpm</filename>):</para>

      <screen>&prompt.root; <userinput>rpm -i --ignoreos --root /compat/linux --dbpath /var/lib/rpm <replaceable>пакет</replaceable></userinput></screen>

      <para>Установка этого <replaceable>пакета</replaceable> должна
	пройти без каких-либо ошибок.</para>
    </sect2>

    <sect2>
      <title>Настройка окружения &oracle;</title>

      <para>Прежде чем вы сможете установить
	<application>&oracle;</application>, вам необходимо
	обеспечить соответствующее окружение.  Ниже дана информация, что
	<emphasis>именно</emphasis> нужно сделать, чтобы успешно запускать
	<application>&oracle;</application> для Linux под FreeBSD,
	а не то, что написано в фирменном руководстве по установке
	<application>&oracle;</application>.</para>

      <sect3 id="linuxemu-kernel-tuning">
	<title>Настройка ядра</title>

	<indexterm><primary>настройка ядра</primary></indexterm>

	<para>Как описывается в руководстве по установке
	  <application>&oracle;</application>, необходимо
	  установить максимальный размер разделяемой памяти.  Не используйте
	  <literal>SHMMAX</literal> под FreeBSD.  <literal>SHMMAX</literal>
	  высчитывается, исходя из <literal>SHMMAXPGS</literal> и
	  <literal>PGSIZE</literal>.  Следовательно, нужно задавать
	  <literal>SHMMAXPGS</literal>.  За информацией о прочих опциях
	  обратитесь к фирменному руководству.  Пример настроек:</para>

	<programlisting>options SHMMAXPGS=10000
options SHMMNI=100
options SHMSEG=10
options SEMMNS=200
options SEMMNI=70
options SEMMSL=61</programlisting>

	<para>Установите эти опции в зависимости от того, как и для чего
	  вы будете использовать <application>&oracle;</application>.</para>

	<para>Не забудьте добавить следующие строки в файл конфигурации
	  ядра:</para>

<programlisting>options SYSVSHM # разделяемая память SysV
options SYSVSEM # семафоры SysV
options SYSVMSG # межпроцессное взаимодействие SysV</programlisting>
      </sect3>

      <sect3 id="linuxemu-oracle-account">
	
	<title>Учетная запись &oracle;</title>

	<para>Создайте специальную учетную запись
	  <username>oracle</username>, как и любую другую учетную запись.
	  Единственное отличие в том, что для <username>oracle</username>
	  необходимо указать командный интерпретатор Linux.
	  Добавьте <filename>/compat/linux/bin/bash</filename> в
	  <filename>/etc/shells</filename> и установите для
	  <username>oracle</username> командный интерпритатор
	  <filename>/compat/linux/bin/bash</filename>.</para>
      </sect3>

      <sect3 id="linuxemu-environment">
	<title>Переменные окружения</title>

	<para>Кроме стандартных переменных окружения
	  <application>&oracle;</application>, таких как
	  <envar>ORACLE_HOME</envar> и <envar>ORACLE_SID</envar>, вам нужно
	  будет установить следующие дополнительные переменные:</para>

	<informaltable frame="none">
	  <tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="2*">
	    <thead>
	      <row>
		<entry>Переменная</entry>

		<entry>Значение</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><envar>LD_LIBRARY_PATH</envar></entry>

		<entry><literal>$ORACLE_HOME/lib</literal></entry>
	      </row>

	      <row>
		<entry><envar>CLASSPATH</envar></entry>

		<entry><literal>$ORACLE_HOME/jdbc/lib/classes111.zip</literal></entry>
	      </row>

	      <row>
		<entry><envar>PATH</envar></entry>

		<entry><literal>/compat/linux/bin
/compat/linux/sbin
/compat/linux/usr/bin
/compat/linux/usr/sbin
/bin
/sbin
/usr/bin
/usr/sbin
/usr/local/bin
$ORACLE_HOME/bin</literal></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Желательно устанавливать их в файле
	  <filename>.profile</filename>.  Вот реальный пример:</para>

<programlisting>ORACLE_BASE=/oracle; export ORACLE_BASE
ORACLE_HOME=/oracle; export ORACLE_HOME
LD_LIBRARY_PATH=$ORACLE_HOME/lib
export LD_LIBRARY_PATH
ORACLE_SID=ORCL; export ORACLE_SID
ORACLE_TERM=386x; export ORACLE_TERM
CLASSPATH=$ORACLE_HOME/jdbc/lib/classes111.zip
export CLASSPATH
PATH=/compat/linux/bin:/compat/linux/sbin:/compat/linux/usr/bin
PATH=$PATH:/compat/linux/usr/sbin:/bin:/sbin:/usr/bin:/usr/sbin
PATH=$PATH:/usr/local/bin:$ORACLE_HOME/bin
export PATH</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Установка &oracle;</title>

      <para>Из-за небольшой несовместимости с Linux эмулятором, вам нужно
	будет создать подкаталог <filename>.oracle</filename> в каталоге
	<filename>/var/tmp</filename> прежде, чем можно будет начать
	установку.  Либо сделайте ее владельцем пользователя
	<username>oracle</username>, либо поставьте права на запись для всех.
	Если вы все сделали правильно, то установка
	<application>&oracle;</application> должна пройти без проблем.  Если
	какие-либо трудности все же возникли, проверьте еще раз все
	конфигурационные файлы и/или целостность дистрибутива
	<application>&oracle;</application>.  После окончания установки
	<application>&oracle;</application> приложите патчи
	(смотрите следующие два раздела).</para>

      <para>Одна из часто возникающих проблем &mdash; неправильно
	установленный TCP адаптер.  В результате, невозможно запустить TCP
	сервисы.  Вот решение проблемы:</para>

      <screen>&prompt.root; <userinput>cd $ORACLE_HOME/network/lib</userinput>
&prompt.root; <userinput>make -f ins_network.mk ntcontab.o</userinput>
&prompt.root; <userinput>cd $ORACLE_HOME/lib</userinput>
&prompt.root; <userinput>ar r libnetwork.a ntcontab.o</userinput>
&prompt.root; <userinput>cd $ORACLE_HOME/network/lib</userinput>
&prompt.root; <userinput>make -f ins_network.mk install</userinput></screen>

      <para>Не забудьте повторно запустить <filename>root.sh</filename>!</para>

    <sect3 id="linuxemu-patch-root">
      <title>Модификация root.sh</title>

	<para>При установке <application>&oracle;</application>
	  необходимо выполнить некоторые действия
	  (имея при этом привилегии суперпользователя).  Фактически это
	  сводится к выполнению скрипта <filename>root.sh</filename>,
	  который находится в директории <filename>orainst</filename>.
	  Перед запуском, приложите к нему следующий патч (исправляет
	  местонахождение утилиты chown), либо запускайте его в командном
	  интерпретаторе Linux.</para>

	<programlisting>*** orainst/root.sh.orig Tue Oct 6 21:57:33 1998
--- orainst/root.sh Mon Dec 28 15:58:53 1998
***************
*** 31,37 ****
# This is the default value for CHOWN
# It will redefined later in this script for those ports
# which have it conditionally defined in ss_install.h
! CHOWN=/bin/chown
#
# Define variables to be used in this script
--- 31,37 ----
# This is the default value for CHOWN
# It will redefined later in this script for those ports
# which have it conditionally defined in ss_install.h
! CHOWN=/usr/sbin/chown
#
# Define variables to be used in this script</programlisting>

	<para>Если вы устанавливаете <application>&oracle;</application>
	  не с компакт диска, можно модифицировать исходный файл
	  <filename>root.sh</filename>.  Он называется
	  <filename>rthd.sh</filename> и находится в каталоге
	  <filename>orainst</filename>.</para>
      </sect3>

      <sect3 id="linuxemu-patch-tcl">
	<title>Модификация genclntsh</title>

	<para>Скрипт <command>genclntsh</command> используется для того,
	  чтобы создать единую совместно используемую клиентскую библиотеку,
	  которая используется для создания демонстраций.  Приложите следующий
	  патч, чтобы закомментировать определение переменной
	  <envar>PATH</envar>:</para>

	<programlisting>*** bin/genclntsh.orig Wed Sep 30 07:37:19 1998
--- bin/genclntsh Tue Dec 22 15:36:49 1998
***************
*** 32,38 ****
#
# Explicit path to ensure that we're using the correct commands
#PATH=/usr/bin:/usr/ccs/bin export PATH
! PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin export PATH
#
# each product MUST provide a $PRODUCT/admin/shrept.lst
--- 32,38 ----
#
# Explicit path to ensure that we're using the correct commands
#PATH=/usr/bin:/usr/ccs/bin export PATH
! #PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin export PATH
#
# each product MUST provide a $PRODUCT/admin/shrept.lst</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Запуск &oracle;</title>

      <para>Теперь, если вы все сделали правильно, то можете использовать
	<application>&oracle;</application> так же, как и в системе
	Linux.</para>
    </sect2>
  </sect1>

  <sect1 id="sapr3">

    <title>Installing &sap.r3; *</title>

    <para>Этот раздел не переведен.</para>
  </sect1>

  <sect1 id="linuxemu-advanced">
    <title>Дополнительные сведения</title>

    <para>Если вы интересуетесь, как работает Linux эмуляция, этот раздел для
      вас.  Большинство материала взято из электронного письма, адресованного
      &a.chat; by Terry Lambert <email>tlambert@primenet.com</email> (ID
      письма: <literal>&lt;199906020108.SAA07001@usr09.primenet.com&gt;</literal>).</para>

    <sect2>
      <title>Как все это устроено?</title>
      <indexterm><primary>загрузчик исполнимых классов</primary></indexterm>

      <para>FreeBSD поддерживает абстракцию, называемую <quote>загрузчик
	исполнимых классов</quote>, который фактически является первой
	стадией системного вызова &man.execve.2;.</para>

      <para>На самом деле, FreeBSD имеет несколько загрузчиков вместо
	одного, который, в случае неудачи, выполняет программу как
	сценарий (скрипт).</para>

      <para>Исторически сложилось, что единственный загрузчик в &unix;
	системах проверял <quote>магическое число</quote> (чаще всего первые
	4 или 8 байт файла), чтобы определить, известен ли формат
	исполняемого файла системе, и если да, то вызвал соответствующий
	загрузчик.</para>

      <para>Если файл не опознавался системой как исполнимый, &man.execve.2;
	возвращал ошибку, и текущий командный интерпретатор начинал
	выполнять файл как скрипт.</para>

      <para>Позднее, &man.sh.1; был модифицирован, так, чтобы проверять
	первые два символа в файле, и если они оказывались
	<literal>:\n</literal>, то файл выполнялся как сценарий для
	&man.csh.1; (утверждается, что SCO были первыми, кто сделал
	эту модификацию).</para>

      <para>FreeBSD ведет себя по-другому: пробегает по списку загрузчиков,
	включая специальный <literal>#!</literal> загрузчик, который
	вызывает нужный интерпретатор или <filename>/bin/sh</filename>, если
	не нашел подходящего.</para>
      <indexterm><primary>ELF</primary></indexterm>

      <para>Формат исполняемого файла FreeBSD определяет по
	<quote>магическому числу</quote>.  На этой стадии пока не
	различается, для какой операционной системы предназначен файл
	(Linux, &solaris;, или любой другой, использующей ELF-формат
	исполняемых файлов).</para>
      <indexterm><primary>Solaris</primary></indexterm>

      <para>Далее, ELF-загрузчик определяет <quote>марку</quote>
	(специальный комментарий; отсутствует в исполняемых файлах
	SVR4/&solaris;) исполняемого файла, то есть для какой операционной
	системы он предназначен.</para>

      <para>Соответственно, Linux программы должны быть
	<quote>маркированы</quote> для <literal>Linux</literal> (например, с
	помощью утилиты &man.brandelf.1;):</para>

      <screen>&prompt.root; <userinput>brandelf -t Linux file</userinput></screen>

      <indexterm>
        <primary>ELF</primary>
	<secondary>branding</secondary>
      </indexterm>

      <para>Когда ELF-загрузчик находит <quote>марку</quote>
	<literal>Linux</literal>, он заменяет соответствующий указатель в
	структуре <literal>proc</literal>.  Все системные вызовы
	индексируются через этот указатель (в традиционной &unix; системе это
	массив <literal>sysent[]</literal>, содержащий системные вызовы).
	Некоторые особые ситуации и системные вызовы обрабатываются
	специальным модулем ядра поддержки Linux.</para>

      <para>Плюс ко всему, Linux эмулятор динамически <quote>изменяет
	корень</quote> файловой системы при поиске файлов; фактически
	так же, как и параметр <literal>union</literal> при монтировании
	файловых систем (не путать с <literal>unionfs</literal>!).
	Сперва, файл ищется в каталоге
	<filename>/compat/linux/<replaceable>original-path</replaceable></filename>
	и только затем, в случае неудачи, в
	<filename>/<replaceable>original-path</replaceable></filename>.  Это
	дает возможность Linux программам выполнять FreeBSD команды, если не
	найдется соответствующих Linux команд.  Например, скопировав FreeBSD
	&man.uname.1; в каталог <filename>/compat/linux/bin/</filename>,
	можно <quote>заставить</quote> Linux программы сообщать, что они
	запускаются под FreeBSD.</para>

      <para>На самом деле, ядра FreeBSD и Linux во многом похожи: системные
	операции, виртуальная память, система сигналов и сообщений,
	межпроцессное взаимодействие и прочее.  Разница в том, что FreeBSD
	программы обращаются к системным вызовам FreeBSD, Linux программы
	соответственно к системным вызовам Linux.  Во многих операционных
	системах прошлого адреса системных вызовов были
	<emphasis>зашиты</emphasis> в статический глобальный массив
	<literal>sysent[]</literal>, вместо обращения по указателю в
	структуре <literal>proc</literal>, который инициализируется
	динамически, позволяя таким образом запускать программы, написанные
	для разных операционных систем.</para>

      <para>В чем же разница между системными вызовами Linux и FreeBSD?
	Фактически никакой.  Единственное различие (на данный момент, в
	будущем все может и, вероятно, изменится), пожалуй, в том, что
	функции системных вызовов FreeBSD зашиты в ядро, а для Linux они
	могут быть либо в ядре, либо в динамически загружаемом
	модуле.</para>

      <para>Можно ли назвать это эмуляцией?  Нет.  Это реализация ABI,
	а не эмуляция. Как таковой, эмулятор (или симулятор)
	отсутствует.</para>

      <para>В таком случае, почему же тогда
	говорят <quote>Linux эмуляция</quote>?  Чтобы
	<quote>насолить</quote> FreeBSD?!.  На самом
	деле, это вопрос терминологии: не существовало слова, которое бы
	точнее описывало этот процесс.  Нельзя сказать, что FreeBSD
	запускает приложения Linux (без перекомпиляции или загрузки
	соответствующего модуля ядра).  Поэтому и придумали термин
	<quote>Linux эмуляция</quote>.</para>
    </sect2>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
