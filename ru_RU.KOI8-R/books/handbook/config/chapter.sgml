<!--
     The FreeBSD Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/config/chapter.sgml,v 1.12 2004/01/19 12:08:24 den Exp $

     Original revision: 1.132
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Написал </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Основывается на учебнике, написанном </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>и на tuning(7), написанном </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Настройка и оптимизация</title>

  <sect1 id="config-synopsis">
    <title>Введение</title>

    <indexterm><primary>настройка системы</primary></indexterm>
    <indexterm><primary>оптимизация системы</primary></indexterm>

    <para>Один из важных аспектов &os; это настройка системы.
      Правильная настройка системы поможет избежать головной боли при
      последующих обновлениях.  Эта глава описывает большую часть процесса
      настройки &os;, включая некоторые параметры, которые можно
      установить для оптимизации системы &os;.</para>

    <para>После прочтения этой главы вы узнаете:</para>

    <itemizedlist>
      <listitem>
	<para>Как эффективно работать с файловыми системами и разделами
	  подкачки.</para> </listitem>
      <listitem>
	<para>Основы настройки <filename>rc.conf</filename> и системы запуска
	  приложений <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>
      <listitem>
	<para>Как настроить и протестировать сетевую карту.</para>
      </listitem>
      <listitem>
	<para>Как настроить виртуальные хосты на сетевых устройствах.</para>
      </listitem>
      <listitem>
	<para>Как использовать различные файлы конфигурации в
	  <filename>/etc</filename>.</para> </listitem>
      <listitem>
	<para>Как оптимизировать &os;, используя переменные
	  <command>sysctl</command>.</para>
      </listitem>
      <listitem>
	<para>Как увеличить скорость работы дисков и изменить ограничения,
	  накладываемые ядром.</para>
      </listitem>
    </itemizedlist>

    <para>Перед прочтением этой главы вам следует:</para>

    <itemizedlist>
      <listitem>
	<para>Понять основы &unix; и &os; (<xref
	    linkend="basics">).</para>
      </listitem>
      <listitem>
	<para>Ознакомиться с модернизированием исходных текстов &os;
	  (<xref linkend="cutting-edge">), и
	  основами конфигурации/компиляции ядра
	  (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Начальное конфигурирование</title>

    <sect2>
      <title>Разделы диска</title>

      <indexterm><primary>разделы диска</primary></indexterm>
      <indexterm>
	<primary><filename>/etc</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>/var</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>/usr</filename></primary>
      </indexterm>

      <sect3>
	<title>Основы построения разделов</title>

	<para>Во время разметки жёсткого диска с помощью &man.disklabel.8;
	  или &man.sysinstall.8;, важно помнить, что скорость чтения и записи
	  данных уменьшается от внешних к внутренним трекам
	  диска.  Самые маленькие и самые
	  часто используемые файловые системы (корневую и раздел подкачки)
	  должны быть расположены в начале
	  диска, в то время как самые большие, такие, как
	  <filename>/usr</filename>, в конце.  Самым оптимальным считается
	  следующий порядок расположения файловых систем: root, swap,
	  <filename>/var</filename>, <filename>/usr</filename>.</para>

	<para>Размер файловой системы <filename>/var</filename> определяется
	  предназначением машины.  <filename>/var</filename>
	  используется для хранения почтовых ящиков, очередей печати и
	  лог файлов.  Размер почтовых ящиков и лог файлов может расти
	  неограниченно в зависимости от количества пользователей
	  системы и от того, как долго хранятся лог-файлы.  Большинству
	  пользователей никогда не потребуется гигабайт, но помните, что
	  <filename>/var/tmp</filename> должен быть достаточно большим для
	  пакетов.</para>

	<para>В разделе <filename>/usr</filename> содержит большинство
	  файлов, необходимых для поддержки системы, &man.ports.7;
	  (порты, рекомендуется) и исходные тексты (опционально).
	  Оба эти каталога опциональны при установке.  Для этого
	  раздела рекомендуется как минимум 2 гигабайта.</para>

	<para>При установке размера разделов, не забудьте принять во внимание
	  рост размера требуемого системе дискового пространства.
	  Переполнение одного раздела даже при наличии свободного места на
	  другом может вызвать затруднения.</para>

	<note><para>Многие пользователи обнаружили, что размер разделов,
	  предлагаемый &man.sysinstall.8;'ом по умолчанию, иногда
	  меньше подходящего для разделов <filename>/var</filename> и
	  <filename>/</filename>.  Тщательно планируйте размер разделов и
	  не жалейте места.</para></note>
      </sect3>

      <sect3 id="swap-design">
	<title>Раздел подкачки</title>

	<indexterm><primary>размер раздела подкачки</primary></indexterm>
	<indexterm><primary>раздел подкачки</primary></indexterm>

	<para>Как правило, размер раздела подкачки должен быть равен
	  удвоенному размеру оперативной памяти.  Например, если на машине
	  установлено 128&nbsp;мегабайт памяти, раздел
	  подкачки должен быть 256&nbsp;мегабайт.  Системы с меньшим
	  количеством памяти могут работать лучше с большим объёмом
	  раздела подкачки.  Не рекомендуется устанавливать размер
	  раздела подкачки меньше 256&nbsp;мегабайт, необходимо также
	  принять во внимание возможное наращивание объема установленной
	  на машине памяти.
	  Алгоритмы кэширования VM настроены на максимальное быстродействие, когда
	  размер раздела подкачки равен как минимум удвоенному размеру
	  памяти.  Заниженный размер раздела подкачки может привести к
	  неэффективной работе постраничного сканирования VM и вызвать
	  проблемы при увеличении объёма памяти.</para>

	<para>На больших системах с несколькими SCSI дисками (или несколькими
	  IDE дисками, находящимися на разных контроллерах),
	  рекомендуется создавать раздел подкачки на каждом диске (до четырёх
	  дисков).  Разделы подкачки должны быть примерно
	  одного размера.  Ядро не накладывает ограничений на размер раздела
	  подкачки, но внутренние структуры позволяют иметь общий размер
	  разделов подкачки, равный наибольшему, умноженному на четыре.
	  Выделение под разделы подкачки примерно одинакового места позволить
	  ядру оптимально расположить разделы подкачки.  Установка
	  размера подкачки больше требуемого нормальна, даже если этот
	  объем не используется.  В этих условиях может быть проще
	  восстановиться после зависания программы перед тем, как
	  возникнет необходимость перезагрузки.</para>
      </sect3>

      <sect3>
	<title>Зачем нужны разделы?</title>

	<para>Некоторые пользователи считают, что лучше использовать
	  один большой раздел, но есть несколько причин, по которым этого
	  лучше не делать.  Во-первых, у
	  каждого раздела свои характеристики, и отделяя их, можно
	  выполнить соответствующие настройки.  Например, корневая и
	  файловая система и <filename>/usr</filename> в основном
	  предназначены для чтения, без большого объема записи.
	  В то же время множество операций чтения и записи
	  выполняется в <filename>/var</filename>
	  и <filename>/var/tmp</filename>.</para>

	<para>При правильном размещении и выборе размера разделов
	  системы, фрагментация в более маленьких разделах, куда часто
	  записываются данные, не перенесётся на остальные разделы.
	  Размещение самых часто используемых разделов ближе к началу диска
	  увеличит скорость ввода/вывода там, где она нужна больше всего.
	  Хотя производительность важна и для больших дисков,
	  передвижение их ближе к концу диска не повлечёт
	  значительного уменьшения быстродействия по сравнению с перемещением
	  ближе к концу диска <filename>/var</filename>.
	  И, наконец, разделы существуют и из соображений
	  безопасности.  Наличие маленького аккуратного корневого раздела,
	  доступного только для чтения даёт значительные шансы на "выживание"
	  после краха системы.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Основные настройки</title>

    <indexterm>
      <primary>rc файлы</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>Основные настройки системы располагаются в
      <filename>/etc/rc.conf</filename>.  Этот файл вмещает широкий спектр
      конфигурационной информации, используемой при загрузке системы.
      Имя этого файла прямо отражает его назначение, это файл настройки
      для файлов <filename>rc*</filename>.</para>

    <para>Администратор должен сделать записи в
      <filename>rc.conf</filename> чтобы переопределить строки по умолчанию из
      <filename>/etc/defaults/rc.conf</filename>.  Файлы по умолчанию нельзя
      копировать в <filename>/etc</filename> - они вмещают значения по
      умолчанию, а не примеры значений.  Все специфичные для данной системы
      изменения должны быть сделаны в файле
      <filename>rc.conf</filename>.</para>

    <para>Существует несколько методов для отделения общей конфигурации для
      группы систем от конкретной для данной системы в целях уменьшения объема
      работы администратора.  Рекомендуемый метод
      - прописать общую конфигурацию в отдельный файл, например, в
      <filename>/etc/rc.conf.site</filename>, и включить его название в
      <filename>/etc/rc.conf</filename>, который вмещает только специфичную
      для данной системы информацию.</para>

    <para>Поскольку <filename>rc.conf</filename> читается
      &man.sh.1;, есть тривиальный способ сделать это. Например:</para>

    <itemizedlist>
      <listitem><para>rc.conf:</para>
<programlisting>	. rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"</programlisting></listitem>
      <listitem><para>rc.conf.site:</para>
<programlisting>	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"</programlisting></listitem>
    </itemizedlist>

    <para>Файл <filename>rc.conf.site</filename> может быть распространён
      на все системы, используя <command>rsync</command> или подобную ей
      программу, в то время, как <filename>rc.conf</filename> должен остаться
      только на одной машине.</para>

    <para>Обновление системы с помощью &man.sysinstall.8;
      или <command>make world</command> не повлекут за собой перезапись
      <filename>rc.conf</filename>.  Вся информация в этом файле
      сохранится.</para>
  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Настройка Приложений</title>

    <para>Обычно, установленные приложения имеют свои конфигурационные файлы,
      со своим собственным синтаксисом.  Важно хранить эти файлы отдельно от
      файлов основной системы, чтобы их можно было легко администрировать с
      помощью средств управления пакетами.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>Обычно эти файлы устанавливаются в
      <filename>/usr/local/etc</filename>.  В случае, если приложению нужно
      большое количество конфигурационных файлов, для их хранения будет
      создан подкаталог.</para>

    <para>Обычно, вместе с установкой портов и пакетов, устанавливаются и
      примеры конфигурационных файлов.  Обычно они имеют расширение
      <filename>.default</filename>.  Если не существует конфигурационных файлов
      для этого приложения, они будут созданы путём копирования
      <filename>.default</filename> файлов.</para>

    <para>Например, <filename>/usr/local/etc/apache</filename>:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Размеры файлов показывают, что только файл
      <filename>srm.conf</filename> был изменён.  При следующем обновлении
      <application>Apache</application> этот файл уже не будет
      перезаписан.</para>
  </sect1>

  <sect1 id="configtuning-starting-services">
    <title>Запуск сервисов</title>

    <indexterm><primary>сервисы</primary></indexterm>

    <para>Обычно в системе работает множество сервисов.  Их можно
      запустить различными способами, каждый из которых имеет свои
      преимущества.</para>

    <indexterm><primary>/usr/local/etc/rc.d</primary></indexterm>

    <para>Программное обеспечение, установленное из коллекции портов или
      пакетов обычно записывает свои скрипты в
      <filename>/usr/local/etc/rc.d</filename>
      который выполняется с аргументом <option>start</option> при запуске
      и с аргументом <option>stop</option> при завершении работы системы.
      Этот метод запуска рекомендуется, если вы запускаете сервисы как
      <username>root</username>, или же они должны быть запущены с
      привилегиями <username>root</username>.  Эти скрипты устанавливаются
      вместе с пакетами, и соответственно, при удалении пакетов скрипты будут
      также удалены.</para>

    <para>Типичный скрипт из <filename>/usr/local/etc/rc.d</filename>,
      выполняющийся при запуске выглядит следующим образом:</para>

    <programlisting>#!/bin/sh
echo -n ' FooBar'

case "$1" in
start)
        /usr/local/bin/foobar
        ;;
stop)
        kill -9 `cat /var/run/foobar.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0
    </programlisting>

    <para>Стартовые скрипты &os; ищут в каталоге
      <filename>/usr/local/etc/rc.d</filename> скрипты с расширением
      <literal>.sh</literal>, исполняемые пользователем
      <username>root</username>.  Обнаруженные скрипты выполняются с
      с параметром <option>start</option> при старте системы и с параметром
      <option>stop</option> при завершении работы системы.
      Поэтому если вы хотите использовать пример скрипта выше и запускать
      его во время старта системы, сохраните его в каталоге
      <filename>/usr/local/etc/rc.d</filename> с именем
      <filename>FooBar.sh</filename> и убедитесь, что он исполняемый.
      Вы можете сделать скрипт исполняемым с помощью &man.chmod.1;,
      как показано ниже:</para>

    <screen>&prompt.root; <userinput>chmod 755 <replaceable>FooBar.sh</replaceable></userinput></screen>

    <para>Некоторые сервисы должны быть запущены &man.inetd.8; при установке
      соединения с определённым портом.  Это может понадобиться, например,
      для почтовых серверов (POP, IMAP, и т.д.).  Для этого нужно
      отредактировать файл <filename>/etc/inetd.conf</filename>.
      Подробнее о работе с этим файлом вы можете прочитать в
      &man.inetd.8;.</para>

    <para>Некоторые дополнительные системные сервисы могут быть не учтены
      в файле <filename>/etc/rc.conf</filename>.  Тогда для их запуска нужно
      прописать соответствующую команду в <filename>/etc/rc.local</filename>.
      Во &os;&nbsp;3.1 не предусмотрен <filename>/etc/rc.local</filename>;
      но считается признаком хорошего тона создание этого файла
      администратором.  Заметьте, что <filename>rc.local</filename>
      используется для запуска сервисов только в крайнем случае.
      Если есть лучший способ запустить сервис, используйте его.</para>

    <note><para><emphasis>Не</emphasis>  записывайте свои команды в
      <filename>/etc/rc.conf</filename>.  Для запуска демонов, или для
      выполнения вашей команды во время запуска - запишите ваш скрипт
      в <filename>/usr/local/etc/rc.d</filename>.</para>
    </note>

    <para>Также допускается использование &man.cron.8; для запуска системных
      сервисов.  Этот метод обладает рядом преимуществ, которые заключаются не
      только в том, что &man.cron.8; запускает эти процессы, как владелец
      <command>crontab</command>, но и в том, что сервисы могут быть
      запущены и не привилегированными пользователями.</para>

    <para>Очень удобно пользоваться возможностью
      &man.cron.8;, которая заключается в том, что если вместо времени
      указать <literal>@reboot</literal>, запланированная программа будет
      запущена сразу после запуска &man.cron.8; после перезагрузки
      системы.</para>
  </sect1>

  <sect1 id="configtuning-cron">
    <sect1info>
      <authorgroup>
        <author>
	<firstname>Tom</firstname>
	<surname>Rhodes</surname>
	<contrib>Предоставил </contrib>
	<!-- 20 May 2003 -->
	</author>
      </authorgroup>
    </sect1info>
    <title>Настройка утилиты <command>cron</command></title>

    <indexterm><primary>cron</primary>
      <secondary>настройка</secondary></indexterm>

    <para>Одна из наиболее полезных утилит &os; это &man.cron.8;.  Утилита
      <command>cron</command> работает в фоновом режиме и постоянно проверяет
      файл <filename>/etc/crontab</filename>.  Утилита <command>cron</command>
      проверяет также каталог <filename>/var/cron/tabs</filename> в поиске
      новый файлов <filename>crontab</filename>.  Файлы
      <filename>crontab</filename> содержат информацию об определенных
      функциях, которые <command>cron</command> выполняет в указанное
      время.</para>

    <para>Давайте заглянем в файл <filename>/etc/crontab</filename>:</para>

    <programlisting># /etc/crontab - root's crontab for &os;
#
# &dollar;&os;: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co id="co-comments">
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co id="co-env">
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <co id="co-field-descr">
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <co id="co-main">
</programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>Как и в большинстве файлов настройки FreeBSD, символы <quote>#</quote>
	  означают комментарии.  Комментарии нужны для напоминания о том,
	  что означает строка и зачем она добавлена.  Комментарии не могут
	  находиться на той же строке, что и команда, или они будут
	  восприняты как часть команды; располагайте их на новой строке.
	  Пустые строки игнорируются.</para>
      </callout>

      <callout arearefs="co-env">
	<para>Сначала должны быть заданы переменные окружения.  Знак равно
	  (<literal>=</literal>) используется для задания переменных
	  окружения, в этом примере <envar>SHELL</envar>,  <envar>PATH</envar>,
	  и <envar>HOME</envar>.  Если переменная для оболочки не задана,
	  <command>cron</command> использует оболочку по умолчанию,
	  <command>sh</command>.  Если не задана переменная
	  <envar>PATH</envar>, значение по умолчанию не устанавливается и
	  пути к файлам должны быть полными.  Если не задана переменная
	  <envar>HOME</envar>, <command>cron</command> будет использовать
	  домашний каталог соответствующего пользователя.</para>
      </callout>

      <callout arearefs="co-field-descr">
	<para>В строке всего семь полей.  Их значения
	  <literal>minute</literal>, <literal>hour</literal>,
	  <literal>mday</literal>, <literal>month</literal>,
	  <literal>wday</literal>, <literal>who</literal> (кто), и
	  <literal>command</literal>.  Значение полей почти очевидно.
	  <literal>minute</literal> это время в минутах, когда будет запущена
	  команда.  <literal>hour</literal> означает то же самое для часов.
	  <literal>mday</literal> означает день месяца.
	  <literal>month</literal>, это то же самое, что час и минута,
	  но для месяцев.  Параметр <literal>wday</literal> это день
	  недели.  Все эти поля должны быть в
	  числовом формате, время в двадцатичетырехчасовом исчислении.
	  Поле <literal>who</literal> имеет специальное значение, и
	  присутствует только в файле <filename>/etc/crontab</filename>.
	  Это поле определяет пользователя, с правами которого должна быть
	  запущена команда.  Когда пользователь устанавливает собственный
	  файл <filename>crontab</filename>, он не указывает этот параметр.
	  Последний параметр <literal>command</literal>.  Он указывает команду, которая должна
	  быть запущена.</para>
      </callout>

      <callout arearefs="co-main">
	<para>Последняя строка определяет параметры, описанные выше.  Здесь
	  задано значение <literal>*/5</literal>, и несколько символов
	  <literal>*</literal>.  Эти символы <literal>*</literal> означают
	  <quote>первый-последний</quote>, и могут быть интерпретированы как
	  <emphasis>каждый</emphasis>.  Таким образом, для этой строки
	  соответствующая команда <command>atrun</command> вызывается
	  под пользователем <username>root</username> каждые пять минут
	  независимо от дня или месяца.  За дополнительной информацией по
	  <command>atrun</command> обращайтесь к странице справочника
	  &man.atrun.8;.</para>

	<para>Команды могут принимать любое количество параметров; однако
	  команды, состоящие из нескольких строк, должны быть объединены
	  символом <quote>\</quote>.</para>
      </callout>
    </calloutlist>

    <para>Этот формат одинаков для каждого файла <filename>crontab</filename>,
      за исключением одной детали.  Шестое поле, где указано имя пользователя,
      присутствует только в файле <filename>/etc/crontab</filename>.  Это
      поле должно быть исключено из <filename>crontab</filename> файлов
      пользователей.</para>

    <sect2 id="configtuning-installcrontab">
      <title>Установка crontab</title>

      <para>Для установки готового <filename>crontab</filename>, используйте
	утилиту <command>crontab</command>.  Обычно она используется
	так:</para>

      <screen>&prompt.root; <userinput>crontab crontab</userinput></screen>

      <para>Существует также параметр для просмотра установленных файлов
	<filename>crontab</filename>, задайте <command>crontab</command>
	параметр <option>-l</option>.</para>

      <para>Для пользователей, составляющих crontab вручную, без временного
	файла, существует параметр <command>crontab -e</command>.
	Она вызовет редактор с пустым файлом.  Когда файл будет сохранен,
	<command>crontab</command> автоматически установит его.</para>

    </sect2>
  </sect1>

  <sect1 id="configtuning-rcNG">
    <sect1info>
      <authorgroup>
        <author>
	 <firstname>Tom</firstname>
	 <surname>Rhodes</surname>
	 <contrib>Предоставил </contrib>
	 <!-- 16 May 2003 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>Использование rc в FreeBSD 5.X</title>

    <indexterm><primary>rcNG</primary></indexterm>

    <para>В &os; недавно была интегрирована из NetBSD система
      <filename>rc.d</filename>, используемая для старта системы.
      Многие из файлов в каталоге <filename>/etc/rc.d</filename>
      предназначены для основных сервисов, они могут управляться
      параметрами <option>start</option>,
      <option>stop</option>, и
      <option>restart</option>.  Например, &man.sshd.8; может быть
      перезапущен следующей командой:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd restart</userinput></screen>

    <para>Эта процедура похожа для других сервисов.  Конечно, сервисы
      обычно запускаются автоматически, как указано в &man.rc.conf.5;.
      Например, включение даемона Network Address Translation
      при запуске выполняется простым добавлением следующей строки
      в <filename>/etc/rc.conf</filename>:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Если <option>natd_enable="NO"</option> уже присутствует,
      просто измените <option>NO</option> на <option>YES</option>.
      Скрипты rc автоматически загрузят все другие зависимые
      сервисы, как описано ниже.</para>

    <para>Поскольку система <filename>rc.d</filename> в основном предназначена
      для запуска/отключения сервисов во время запуска/отключения
      системы, стандартные параметры <option>start</option>,
      <option>stop</option> и <option>restart</option> будут работать
      только если установлена соответствующая переменная в
      <filename>/etc/rc.conf</filename>.  Например, команда выше
      <command>sshd restart</command> будет работать только если
      переменная <varname>sshd_enable</varname> в файле
      <filename>/etc/rc.conf</filename>установлена в <option>YES</option>.
      Для выполнения скриптов независимо от установок в
      <filename>/etc/rc.conf</filename>, параметры <option>start</option>,
      <option>stop</option> или <option>restart</option> необходимо
      задавать с префиксом <quote>force</quote>.  Например, для
      перезапуска <command>sshd</command> независимо от установок в
      <filename>/etc/rc.conf</filename>, выполните следующую
      команду:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd forcerestart</userinput></screen>

    <para>Проверить состояние переменной в файле
      <filename>/etc/rc.conf</filename> легко: запустите соответствующий
      скрипт из <filename>rc.d</filename> с параметром
      <option>rcvar</option>.  Проверка переменной для
      <command>sshd</command> выполняется следующей командой:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note>
      <para>Вторая строка (<literal># sshd</literal>) это вывод команды
	команды <command>sshd</command>, а не консоль
	<username>root</username>.</para>
    </note>

    <para>Чтобы определить, запущен ли сервис, существует параметр
      <option>status</option>.  Например для проверки того, запущен ли
      <command>sshd</command>, выполните:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>Возможна также перегрузка (<option>reload</option>) сервиса.
      Скрипт, запущенный с этим параметром, попытается отправить сервису
      сигнал, вызывающий перезагрузку файлов настройки.  В большинстве
      случаев это означает отправку сервису сигнала
      <literal>SIGHUP</literal>.</para>

    <para>Структура <application>rcNG</application> используется не только для
      сетевых серверов, она отвечает также за большую часть инициализации
      системы.
      Рассмотрим, к примеру, файл <filename>bgfsck</filename>.  Во время
      выполнения этот скрипт выводит следующее сообщение:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Следовательно, этот файл используется для фоновой проверки файловых
      систем, которая выполняется только в процессе инициализации
      системы.</para>

    <para>Функционирование многих сервисов системы зависит от корректной
      работы других сервисов.  Например, NIS и другие основанные на
      RPC сервисы могут не запуститься, пока не загрузится
      <command>rpcbind</command> (portmapper).  Для разрешения этой
      проблемы, в начале каждого скрипта в комментарии включаются
      информация о зависимостях и другие метаданные.  Программа
      &man.rcorder.8; для разбора этих комментариев во время старта
      системы для определения порядка, в котором должны вызываться
      системные сервисы в соответствии с зависимостями.  В начало
      каждого стартового файла должны быть включены следующие
      строки:</para>

    <itemizedlist>
      <listitem>
	<para>PROVIDE: Задает имя сервиса, предоставляемого этим файлом.</para>
      </listitem>

      <listitem>
	<para>REQUIRE: Список сервисов, необходимых этому сервису.  Этот
	  файл будет запущен <emphasis>после</emphasis> указанных
	  сервисов.</para>
      </listitem>

      <listitem>
	<para>BEFORE: Список сервисов, зависящих от этого сервиса.  Этот
	  файл будет запущен <emphasis>до</emphasis> указанных
	  сервисов.</para>
      </listitem>

      <listitem>
	<para>KEYWORD: &os; или NetBSD.  Используется для функций,
	  зависящих от версии *BSD.</para>
      </listitem>
    </itemizedlist>

    <para>Используя этот метод, администратор может легко контролировать
      системные сервисы без использования <quote>уровней запуска</quote>,
      как в некоторых других операционных системах &unix;.</para>

    <para>Дополнительную информацию о системе <filename>rc.d</filename>
      &os; 5.X можно найти на страницах справочника &man.rc.8; и
      and &man.rc.subr.8;.</para>
  </sect1>

  <sect1 id="config-network-setup">
    <sect1info>
      <authorgroup>
        <author>
	 <firstname>Marc</firstname>
	 <surname>Fonvieille</surname>
	 <contrib>Предоставил </contrib>
	 <!-- 6 October 2002 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>Настройка карт сетевых интерфейсов</title>

    <indexterm><primary>настройка сетевой карты</primary></indexterm>

    <para>В наши дни мы не представляем себе компьютера без сетевого
      подключения.  Добавление и настройка сетевой карты это
      обычная задача любого администратора &os;.</para>

    <sect2>
      <title>Поиск подходящего драйвера</title>

      <indexterm>
	<primary>настройка сетевой карты</primary>
	<secondary>поиск драйвера</secondary>
      </indexterm>

      <para>В первую очередь определите тип используемой карты (PCI или ISA),
	модель карты и используемый в ней чип.  &os; поддерживает
	многие PCI и ISA карты.  Обратитесь к Списку поддерживаемого
	оборудования вашего релиза чтобы узнать, поддерживается ли
	карта.</para>

      <para>Как только вы убедились, что карта поддерживается, потребуется
	определить подходящий драйвер.  В файле
	<filename>/usr/src/sys/i386/conf/LINT</filename> находится список
	драйверов сетевых интерфейсов с информацией о поддерживаемых
	чипсетах/картах.  Если вы сомневаетесь в том, какой драйвер
	подойдет, прочтите страницу справочника к драйверу.
	Страница справочника содержит больше информации о поддерживаемом
	оборудовании и даже о проблемах, которые могут возникнуть.</para>

      <para>Если ваша карта широко распространена, вам скорее всего
	не потребуется долго искать драйвер.  Драйверы для
	широко распространенных карт представлены в ядре
	<filename>GENERIC</filename>, так что ваша карта должна определиться
	при загрузке, примерно так:</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</screen>

      <para>В этом примере две карты используют имеющийся в системе
	драйвер &man.dc.4;.</para>

      <para>Для использования сетевой карты потребуется загрузить
	подходящий драйвер.  Это можно сделать двумя способами.
	Самый простой способ это загрузка модуля ядра для
	сетевой карты с помощью &man.kldload.8;.  Не для каждой
	сетевой карты есть модуль (например ISA карты и карты,
	использующие драйвер &man.ed.4;).  В качестве альтернативы,
	вы можете статически добавить поддержку сетевой карты
	в ядро.  Проверьте <filename>/usr/src/sys/i386/conf/LINT</filename>
	и страницу справочника драйвера, чтобы узнать, что добавить
	в файл конфигурации ядра.  За дополнительной информацией о
	пересборке ядра обращайтесь к <xref linkend="kernelconfig">.
	Если ваша карта была обнаружена ядром (<filename>GENERIC</filename>)
	во время загрузки, собирать новое ядро не потребуется.</para>
    </sect2>

    <sect2>
      <title>Настройка сетевой карты</title>

      <indexterm>
	<primary>настройка сетевой карты</primary>
	<secondary>настройка</secondary>
      </indexterm>

      <para>Как только для сетевой карты загружен подходящий драйвер,
	ее потребуется настроить.  Как и многое другое, сетевая
	карта может быть настроена во время установки с помощью
	<application>sysinstall</application>.</para>

      <para>Для вывода информации о настройке сетевых интерфейсов системы,
	введите следующую команду:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</screen>

      <note>
	<para>Старые версии &os; могут потребовать запуска
	  &man.ifconfig.8; с параметром <option>-a</option>, за
	  более подробным описанием синтаксиса &man.ifconfig.8;
	  обращайтесь к странице справочника.  Учтите также, что
	  строки, относящиеся к IPv6 (<literal>inet6</literal> и т.п.)
	  убраны из этого примера.</para>
      </note>

      <para>В этом примере были показаны следующие устройства:</para>

      <itemizedlist>
	<listitem>
	  <para><devicename>dc0</devicename>: первый Ethernet
	    интерфейс</para>
	</listitem>

	<listitem>
	  <para><devicename>dc1</devicename>:  второй Ethernet
	    интерфейс</para>
	</listitem>

	<listitem>
	  <para><devicename>lp0</devicename>: интерфейс параллельного
	    порта</para>
	</listitem>

	<listitem>
	  <para><devicename>lo0</devicename>: устройство loopback</para>
	</listitem>

	<listitem>
	  <para><devicename>tun0</devicename>: туннельное устройство,
	    используемое <application>ppp</application></para>
	</listitem>
      </itemizedlist>

      <para>Для присвоения имени сетевой карте &os; использует имя
	драйвера и порядковый номер, в котором карта обнаруживается
	при инициализации устройств.  Например, <devicename>sis2</devicename>
	это третья сетевая карта, использующая драйвер &man.sis.4;.</para>

      <para>В этом примере, устройство <devicename>dc0</devicename> включено
	и работает.  Ключевые признаки таковы:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> означает, что карта настроена и
	    готова.</para>
	</listitem>

	<listitem>
	  <para>У карты есть интернет (<literal>inet</literal>)
	    адрес (в данном случае
	    <hostid role="ipaddr">192.168.1.3</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Установлена маска подсети (<literal>netmask</literal>;
	    <hostid role="netmask">0xffffff00</hostid>, то же, что и
	    <hostid role="netmask">255.255.255.0</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Широковещательный адрес (в данном случае,
	    <hostid role="ipaddr">192.168.1.255</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Значение MAC адреса карты (<literal>ether</literal>)
	    <hostid role="mac">00:a0:cc:da:da:da</hostid></para>
	</listitem>

	<listitem>
	  <para>Выбор физической среды передачи данных в режиме автовыбора
	    (<literal>media: Ethernet autoselect (100baseTX
	    &lt;full-duplex&gt;)</literal>).  Мы видим, что
	    <devicename>dc1</devicename> была настроена для работы с
	    <literal>10baseT/UTP</literal>.  За более подробной
	    информацией о доступных драйверу типах среды обращайтесь
	    к странице справочника.</para>
	</listitem>

	<listitem>
	  <para>Статус соединения (<literal>status</literal>)
	    <literal>active</literal>, т.е. несущая обнаружена.
	    Для <devicename>dc1</devicename>, мы видим
	    <literal>status: no carrier</literal>.  Это нормально, когда
	    ethernet кабель не подключен к карте.</para>
	</listitem>
      </orderedlist>

      <para>Если &man.ifconfig.8; показывает примерно следующее:</para>

<screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
	        ether 00:a0:cc:da:da:da</screen>

      <para>это означает, что карта не была настроена.</para>

      <para>Для настройки карты вам потребуются привилегии пользователя
	<username>root</username>.  Настройка сетевой карты может быть
	выполнена из командной строки с помощью &man.ifconfig.8;, но
	вам потребуется делать это после каждой перезагрузки системы.
	Подходящее место для настройки сетевых карт это файл
	<filename>/etc/rc.conf</filename>.</para>

      <para>Откройте <filename>/etc/rc.conf</filename> в текстовом
	редакторе.  Вам потребуется добавить строку для каждой сетевой
	карты, имеющейся в системе, например, в нашем случае, было
	добавлено две строки:</para>

<programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>Замените <devicename>dc0</devicename>,
	<devicename>dc1</devicename>, и так далее на соответствующие
	имена ваших карт, подставьте соответствующие адреса.
	Обратитесь к страницам справочника сетевой карты и
	&man.ifconfig.8;, за подробной информацией о доступных
	опциях и к странице справочника &man.rc.conf.5; за дополнительной
	информацией о синтаксисе <filename>/etc/rc.conf</filename>.</para>

      <para>Если вы настроили сетевую карту в процессе установки системы,
	некоторые строки, касающиеся сетевой карты, могут уже присутствовать.
	Внимательно проверьте <filename>/etc/rc.conf</filename> перед
	добавлением каких-либо строк.</para>

      <para>Отредактируйте также файл <filename>/etc/hosts</filename>
	для добавления имен и IP адресов различных компьютеров сети,
	если их еще там нет.  За дополнительной информацией обращайтесь
	к man.hosts.5;
	и к <filename>/usr/share/examples/etc/hosts</filename>.</para>
    </sect2>

    <sect2>
      <title>Тестирование и решение проблем</title>

      <para>Как только вы внесете необходимые изменения в
	<filename>/etc/rc.conf</filename>, перегрузите компьютер.
	Изменения настроек интерфейсов будут применены, кроме того
	будет проверена	правильность настроек.</para>

      <para>Как только система перезагрузится, проверьте сетевые
	интерфейсы.</para>

      <sect3>
	<title>Проверка Ethernet карты</title>

	<indexterm>
	  <primary>настройка сетевой карты</primary>
	  <secondary>тестирование карты</secondary>
	</indexterm>

	<para>Для проверки правильности настройки сетевой карты,
	  попробуйте выполнить ping для самого интерфейса, а затем
	  для другой машины в локальной сети.</para>

	<para>Сначала проверьте локальный интерфейс:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

	<para>Затем проверьте другую машину в локальной сети:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

	<para>Вы можете также использовать имя машины вместо
	  <hostid role="ipaddr">192.168.1.2</hostid>, если настроен файл
	  <filename>/etc/hosts</filename>.</para>
      </sect3>

      <sect3>
	<title>Решение проблем</title>

      <indexterm>
	<primary>настройка сетевой карты</primary>
	<secondary>решение проблем</secondary>
      </indexterm>

      <para>Решение проблем с аппаратным и программным обеспечением всегда
	вызывает сложности, которые можно уменьшить, проверив сначала
	самые простые варианты.  Подключен ли сетевой кабель? Правильно ли
	настроены сетевые сервисы?  Правильно ли настроен межсетевой экран?
	Поддерживается ли используемая карта в &os;?  Всегда проверяйте
	информацию об оборудовании перед отправкой сообщения об ошибке.
	Обновите &os; до последней версии STABLE.  Просмотрите
	архивы списков рассылки, или поищите информацию в интернет.</para>

      <para>Если карта работает, но производительность низка, может помочь
	чтение страницы справочника &man.tuning.7;.  Проверьте также
	настройки сети, поскольку неправильные настройки могут стать причиной
	низкой скорости соединения.</para>

      <para>Некоторые пользователи встречаются с несколькими
	<quote>device timeouts</quote>, что нормально для некоторых сетевых
	карт.  Если это продолжается и надоедает, убедитесь, что
	устройство не конфликтует с другим устройством.  Внимательно
	проверьте подключение кабеля.  Возможно также, что вам просто надо
	установить другую карту.</para>

      <para>Время от времени, пользователи видят несколько ошибок
	<errorname>watchdog timeout</errorname>.  Первое, что требуется сделать,
	это проверить сетевой кабель.  Многие карты требуют поддержки
	Bus Mastering слотом PCI.  На некоторых старых материнских платах,
	только один PCI слот имеет такую поддержку (обычно слот 0).
	Сверьтесь с документацией на сетевую карту и материнскую плату,
	чтобы определить, может ли это быть проблемой.</para>

      <para>Сообщение <errorname>No route to host</errorname> появляются, если
	система не в состоянии доставить пакеты к хосту назначения.
	Это может случиться, если не определен маршрут по умолчанию,
	или кабель не подключен.  Проверьте вывод команды <command>netstat
	-rn</command> и убедитесь, что к соответствующему хосту
	есть работающий маршрут.  Если это не так, прочтите <xref
	linkend="advanced-networking">.</para>

      <para>Сообщения <errorname>ping: sendto: Permission denied</errorname>
	зачастую появляются при неправильно настроенном межсетевом экране.
	Если <command>ipfw</command> включен в ядре, но правила не
	определены, правило по умолчанию блокирует весь трафик,
	даже запросы ping!  Прочтите <xref
	linkend="firewalls"> с более подробной информацией.</para>

      <para>Иногда карты недостаточна, или ниже среднего.  В этих случаях
	лучше всего изменить режим выбора типа подключения с
	<literal>autoselect</literal> на правильный тип.
	Обычно это работает для большинства оборудования, но не может
	решить проблему во всех случаях.  Проверьте еще раз настройки сети
	и прочтите страницу руководства &man.tuning.7;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Настройка виртуальных серверов</title>

    <indexterm><primary>виртуальные сервера</primary></indexterm>
    <indexterm><primary>синонимы ip</primary></indexterm>

    <para>Очень часто &os; используется для размещения сайтов, когда
      один сервер работает в сети как несколько серверов.  Это достигается
      присвоением нескольких сетевых адресов одному интерфейсу.</para>

    <para>У сетевого интерфейса всегда есть один <quote>настоящий</quote> адрес, хотя он
      может иметь любое количество <quote>синонимов</quote> (alias).  Эти алиасы обычно
      добавляются путём помещения синонимов в
      <filename>/etc/rc.conf</filename>.</para>

    <para>Синоним для интерфейса <devicename>fxp0</devicename> выглядит
      следующим образом:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Заметьте, что алиас записи должны начинаться с alias0 и идти далее
      в определенном порядке, (например, _alias1, _alias2, и т.д.).
      Конфигурационный процесс остановится на первом отсутствующем по порядку
      числе.</para>

    <para>Определение маски подсети для синонима очень важно, но к счастью, так же
      просто.  Для каждого интерфейса должен быть один адрес с истинной маской
      подсети.  Любой другой адрес в сети должен иметь маску подсети, состоящую
      из всех единичек.</para>

    <para>Например, рассмотрим случай, когда интерфейс
      <devicename>fxp0</devicename> подключён к двум сетям, к сети
      <hostid role="ipaddr">10.1.1.0</hostid> с маской подсети
      <hostid role="netmask">255.255.255.0</hostid> и к сети
      <hostid role="ipaddr">202.0.75.16</hostid> с маской
      <hostid role="netmask">255.255.255.240</hostid>.  Мы хотим,
      чтобы система была видна по IP, начиная с
      <hostid role="ipaddr">10.1.1.1</hostid> по
      <hostid role="ipaddr">10.1.1.5</hostid> и с
      <hostid role="ipaddr">202.0.75.17</hostid> по
      <hostid role="ipaddr">202.0.75.20</hostid>.</para>

    <para>Для этого должны быть внесены следующие записи:</para>

<programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Файлы настройки</title>

    <sect2>
      <title>Каталог <filename>/etc</filename></title>
      <para>Во FreeBSD определён ряд директорий, предназначенных для
	хранения конфигурационных файлов.  Это:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>Основные файлы конфигурации системы.  Тут размещены
		системно&ndash;зависимые данные.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>Версии системных конфигурационных файлов по
		умолчанию.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>Дополнительные конфигурационные файлы &man.sendmail.8;
		остальные конфигурационные файлы MTA.
	      </entry>
	    </row>
	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>Настройка для user- и kernel-ppp программ.
	      </entry>
	    </row>
	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>Основное место расположения данных &man.named.8;.
		Обычно <filename>named.conf</filename> и файлы зон
		расположены здесь.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc</filename></entry>
	      <entry>Конфигурационные файлы установленных приложений.  Могут
		содержать подкаталоги приложений.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>Скрипты запуска/остановки установленных приложений.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>Автоматически генерируемые системно-специфичные файлы
		баз данных, такие как база данных пакетов, и так
		далее</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Имена хостов</title>

      <indexterm><primary>hostname</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm>
	  <primary><filename>resolv.conf</filename></primary>
	</indexterm>

	<para><filename>/etc/resolv.conf</filename> определяет, как
	  ресолвер (resolver) &os; получает доступ к Системе Доменных
	  Имён (DNS).</para>

	<para>Основные записи <filename>resolv.conf</filename>:
	</para>

	<informaltable frame="none">
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>
		<entry>IP адрес сервера имён.  Сервера опрашиваются в порядке
		  описания.  Максимальное количество адресов - три.</entry>
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Список доменов для поиска с помощью hostname lookup.
		  Обычно определяется доменом, в котором находится
		  компьютер.</entry>
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Домен, в котором находится компьютер.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Типичный вид <filename>resolv.conf</filename>:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note><para>Опции <literal>search</literal> и
	  <literal>domain</literal> нельзя использовать
	  совместно.</para></note>

	<para>Если вы используете DHCP, &man.dhclient.8; обычно перезаписывает
	  <filename>resolv.conf</filename> информацией, полученной от серверов
	   DHCP.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>
	
	<para><filename>/etc/hosts</filename> - простая текстовая база
	   данных, напоминающая старый Интернет.  Она работает совместно с
	   DNS и NIS, сопоставляя доменные имена IP адресу.
	   Отдельные компьютеры, соединённые с помощью локальной сети могут
	   быть записаны тут вместо &man.named.8; сервера с целью упрощения.
	   Кроме того, <filename>/etc/hosts</filename> используется для
	   записи IP адресов и соответствующих им доменов, избавляя от
	   внешнего трафика, используемого для запросов к DNS серверам.</para>

	<programlisting># &dollar;&os;&dollar;
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#</programlisting>

	<para>Формат <filename>/etc/hosts</filename>:</para>
	
	<programlisting>[IP адрес в Интернете] [имя компьютера] [alias1] [alias2] ...</programlisting>

	<para>Например:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>За дополнительной информацией обращайтесь к  &man.hosts.5;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Настройка лог файлов</title>

      <indexterm><primary>лог файлы</primary></indexterm>

      <sect3>
	<title><filename>syslog.conf</filename></title>
	
	<indexterm><primary>syslog.conf</primary></indexterm>
	
	<para><filename>syslog.conf</filename> is является файлом конфигурации
	  для &man.syslogd.8;.  В нём указываются, типы сообщений
	  генерируемые <command>syslog</command>, и лог файлы, в которые они
	  записываются.</para>

	<programlisting># &dollar;&os;&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

	<para>За более полной информацией обратитесь
	  к &man.syslog.conf.5;.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>
	
	<para><filename>newsyslog.conf</filename> - конфигурационный файл
	  &man.newsyslog.8;, программы, обычно контролируемой &man.cron.8;.
	  &man.newsyslog.8; определяет, когда лог-файлы нуждаются в
	  архивировании и перегруппировке.
	  <filename>logfile</filename> перемещается в
	  <filename>logfile.0</filename>, <filename>logfile.0</filename>
	  перемещается в <filename>logfile.1</filename>, и так далее.
	  Другое именование получится при архивировании с помощью
	  &man.gzip.1;: <filename>logfile.0.gz</filename>,
	  <filename>logfile.1.gz</filename>, и т.д.</para>

	<para><filename>newsyslog.conf</filename> показывает, какие лог файлы
	  должны быть проинспектированы, сколько их должно быть сохранено, и когда
	  они должны быть пересмотрены.  Лог файлы могут быть перегруппированы
	  и/или заархивированы, когда они либо достигнут определённого
	  размера, либо при достижении определённых даты/времени.</para>
	
	<programlisting># configuration file for newsyslog
# &dollar;&os;&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

	<para>За дополнительной информацией обращайтесь к
	  &man.newsyslog.8;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> очень похож на
	<filename>rc.conf</filename>.  Значения устанавливаются в виде
	<literal>variable=value</literal>.  Указанные значения устанавливаются
	после перевода системы в многопользовательский режим.  Однако не все
	переменные могут быть установлены в этом режиме.</para>

      <para>Пример <filename>sysctl.conf</filename> настроенной для выключения
	нотирования фатальных ошибок и разрешения Linux-программам определять,
	что они запускаются под &os;:</para>

      <programlisting>kern.logsigexit=0       # Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=&os;
compat.linux.osrelease=4.3-STABLE</programlisting>
    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Настройка с помощью sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm>
      <primary>настройка</primary>
      <secondary>с помощью sysctl</secondary>
    </indexterm>

    <para>&man.sysctl.8; - это интерфейс, позволяющий вам вносить изменения
      в работающую систему &os;.  Эти изменения могут касаться многих опций стека
      TCP/IP и виртуальной памяти и могут облегчить опытному администратору
      жизнь.  Более пяти тысяч системных переменных могут быть прочитаны и
      записаны с помощью &man.sysctl.8;.</para>

    <para>По своей сути, &man.sysctl.8; выполняет две функции: чтение
      и изменение настроек системы.</para>

    <para>Для просмотра всех доступных для чтения переменных::</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Чтобы прочитать определённую переменную, например,
      <varname>kern.maxproc</varname>, введите:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Для присвоения значения переменной, используйте выражение вида
      <replaceable>переменная</replaceable>=<replaceable>значение</replaceable>:</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>Изменяемые с помощью sysctl переменные обычно принимают значения
      либо строкового, либо целого, либо булевого типа.  Переменные булевого
      типа могут принимать два значения (<literal>1</literal> (истина) и
      <literal>0</literal> (ложь)).</para>

  <sect2 id="sysctl-readonly">
    <sect2info>
      <authorgroup>
        <author>
	 <firstname>Tom</firstname>
	 <surname>Rhodes</surname>
	 <contrib>Предоставил </contrib>
	 <!-- 31 January 2003 -->
        </author>
      </authorgroup>
    </sect2info>
    <title>Переменные &man.sysctl.8; только для чтения</title>

    <para>В некоторых случаях желательно изменить переменные
      &man.sysctl.8; только для чтения.  Хотя это не рекомендуется,
      иногда другого способа решить проблему нет.</para>

    <para>Например, на некоторых моделях лэптопов диапазон памяти устройства
      &man.cardbus.4; не определяется и выдается приблизительно такая
      ошибка:</para>

    <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

    <para>Ситуации, похожие на эту, требуют изменения некоторых значений
      &man.sysctl.8;, модификация которых запрещена.  Для разрешения этой
      ситуации пользователь может поместить &man.sysctl.8; <quote>OID</quote>
      в файл <filename>/boot/loader.conf.local</filename>.  Значения по
      умолчанию хранятся в файле
      <filename>/boot/defaults/loader.conf</filename>.</para>

    <para>Решение проблемы, приведенной выше, потребует помещения строки
      <option>hw.pci.allow_unsupported_io_range=1</option> в вышеупомянутый
      файл.  Теперь &man.cardbus.4; будет работать нормально.</para>

    </sect2>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Оптимизация дисков</title>

    <sect2>
      <title>Переменные Sysctl</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>
	
	<para>Значением переменной <varname>vfs.vmiodirenable</varname>
	  может быть установлено в 0 (выключено) или 1 (включено); по
	  умолчанию 1.  Эта переменная отвечает за метод кэширования
	  каталогов.  Размер большинства каталогов невелик.  Они могут
	  поместиться в одном фрагменте (обычно 1K), и могут занимать
	  ещё меньше места (обычно 512 байт) в кэше буфера.  Однако, при
	  работе в стандартном режиме буфер прокэширует только заданное число
	  каталогов даже если у вас много памяти.  Включение этого параметра
	  sysctl позволит использовать страничное кэширование VM,
	  делая доступным для кэширования каталогов
	  весь объём памяти.  Однако,
	  минимальный объём памяти, используемой для
	  кэширования каталогов стал равен объёму страницы (обычно 4&nbsp;K)
	  вместо 512&nbsp;байт.  Мы рекомендуем включить эту опцию, если ваш
	  компьютер исполняет программы, манипулирующие значительным
	  количеством файлов.  Примером таких программ могут быть кэширующие
	  прокси-серверы, большие почтовые серверы и серверы новостей.  Обычно
	  включение этой опции не понижает производительности, однако лучше
	  поэкспериментировать, чтобы узнать оптимальное значение для вашей
	  машины.</para>
      </sect3>

     <sect3>
 	<title><varname>vfs.write_behind</varname></title>

 	<indexterm>
 	  <primary><varname>vfs.write_behind</varname></primary>
 	</indexterm>

 	<para>Переменная sysctl <varname>vfs.write_behind</varname> по
	  умолчанию установлена в <literal>1</literal> (включено).  Она
	  указывает системе выполнять запись на носитель по кластерам,
	  что обычно делается для больших файлов.  Идея в том, чтобы
	  избежать заполнения кэша неполными буферами, когда это не
	  увеличивает производительность.  Однако, это может заблокировать
	  процессы и в некоторых случаях вам может понадобиться отключить
	  этот параметр.</para>
       </sect3>

       <sect3>
 	<title><varname>vfs.hirunningspace</varname></title>

 	<indexterm>
 	  <primary><varname>vfs.hirunningspace</varname></primary>
 	</indexterm>

 	<para>Переменная sysctl <varname>vfs.hirunningspace</varname>
	  определяет число запросов записи на диск, которые могут
	  быть поставлены в очередь.  Значение по умолчанию обычно подходит,
	  но на компьютерах с большим количеством дисков вы можете
	  увеличить его до четырех или пяти <emphasis>мегабайт</emphasis>.
	  Учтите, что установка слишком большого значения (превышающего
	  размер буфера записи) может привести к очень значительному
	  падению общей производительности.  Не делайте это значение
	  произвольно большим!  Большие значения могут привести к
	  задержкам чтения, выполняемого в то же время</para>

 	<para>Есть много других переменных sysctl, относящихся к кэшированию
	  в буфер и страничному кэшированию VM.  Мы не рекомендуем изменять
	  эти значения.  Начиная &os; 4.3, система VM делает отличную
	  работу по автоматической самонастройке.</para>
       </sect3>

       <sect3>
 	<title><varname>vm.swap_idle_enabled</varname></title>

 	<indexterm>
 	  <primary><varname>vm.swap_idle_enabled</varname></primary>
 	</indexterm>

 	<para>Переменная sysctl <varname>vm.swap_idle_enabled</varname>
	  полезна в больших многопользовательских системах, где есть
	  много пользователей, входящих и выходящих из системы, и
	  множество ожидающих процессов.  Такие системы обычно генерируют
	  большое количество запросов на выделение памяти.  Включение этой
	  переменной и настройка задержки выгрузки (swapout hysteresis,
	  в секундах) установкой переменных
 	  <varname>vm.swap_idle_threshold1</varname> и
 	  <varname>vm.swap_idle_threshold2</varname> позволит освобождать
	  страницы памяти, занятые ожидающими процессами, более быстро,
	  чем при нормальном алгоритме выгрузки.  Это помогает даемону
	  выгрузки страниц.  Не включайте этот параметр, пока он на самом
	  деле вам не понадобится, поскольку его действие в сущности
	  заключается в более ранней выгрузке страниц из памяти; это
	  повышает нагрузку на подкачку и диск.  В малых системах
	  эффект от включения этого параметра предсказуем, но в больших
	  системах нагруженной на подкачкой этот параметр позволяет
	  системе VM проще загружать и выгружать процессы из памяти.</para>
       </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>Во &os;&nbsp;4.3 кэширование записи на IDE диски было отключено.
	  Это понижало производительность IDE дисков в тестах, но было
	  необходимо для лучшей сохранности данных.  Проблема состоит в том,
	  что IDE диски неправильно указывают время завершения записи на диск.
	  При включенном кэшировании IDE диски могут не только записать данные
	  в неправильном порядке &ndash; при большой нагрузке на диск некоторые
	  блоки могут задержаться до бесконечности.  Сбой, или отключение
	  питания могут могут стать причиной серьёзных повреждений в файловой
	  системе.  Поэтому для безопасности системы значение по умолчанию
	  этого параметра было изменено.  К сожалению, результатом этого стало
	  столь значительная потеря производительности, что после выхода
	  релиза значение этого параметра было возвращено в первоначальное
	  состояние.  Вам следует проверить значение переменной sysctl
	  <varname>hw.ata.wc</varname> на вашей машине.  Если кэширование
	  выключено - вы можете включить его, установив значение переменной
	  ядра, равное 1.  Это должно быть сделано при помощи загрузчика при
	  загрузке.  Если вы сделаете это позже - изменения не будут иметь
	  силы.</para>
	
	<para>За более подробной информацией обращайтесь к &man.ata.4;.</para>
      </sect3>

      <sect3>
	<title><option>SCSI_DELAY</option>
	(<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm>
	  <primary><option>SCSI_DELAY</option></primary>
	  <secondary><varname>kern.cam.scsi_delay</varname></secondary>
	</indexterm>

	<para>Параметр настройки ядра <option>SCSI_DELAY</option> может
	  использоваться для уменьшения времени загрузки системы.
	  Значение по умолчанию велико и может составлять более
	  <literal>15</literal> секунд в процессе загрузки.  Уменьшение
	  его до <literal>5</literal> секунд обычно работает (особенно
	  с современными дисками).  В новые версии &os; (5.0+) должен
	  использоваться параметр <varname>kern.cam.scsi_delay</varname>,
	  настраиваемый во время загрузки.  Этот параметр и параметр
	  настройки ядра принимают значения в
	  <emphasis>милисекундах</emphasis>, а <emphasis>не</emphasis> в
	  <emphasis>секундах</emphasis>.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Программа &man.tunefs.8; используется для настройки файловой
	системы.  Эта программа может принимать большое количество параметров,
	но мы рассмотрим лишь один из них - включение и выключение
	Soft Updates, что может быть достигнуто следующим образом:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Нельзя изменять файловую систему с помощью &man.tunefs.8; когда
	она смонтирована.  Самое подходящее время для включения "Soft Updates"
	- перед монтированием разделов, в однопользовательском режиме.</para>

      <note><para>Начиная с &os;&nbsp;4.5, можно включить Soft Updates
	во время создания файловой системы, используя
	&man.newfs.8; с параметром <literal>-U</literal>.</para></note>

      <para>Soft Updates существенно увеличивают скорость создания и удаления
	файлов путём использования кэширования.  Мы рекомендуем использовать Soft
	Updates на всех ваших файловых системах.  Однако у Soft Updates есть
	и обратные стороны: во-первых, Soft Updates гарантирует целостность
	файловой системы в случае сбоя, но может наблюдаться задержка в
	несколько секунд (или даже минуту!) перед записью на жесткий диск.
	Если система зависнет - вы можете потерять
	больше, чем, если бы вы не включили Soft Updates.  Во-вторых,
	Soft Updates задерживает освобождение блоков файловой системы.
	Если ваша файловая система заполнена, выполнение значительного
	обновления, например.
	<command>make installworld</command>, может вызвать
	переполнение.</para>

      <sect3>
	<title>Дополнительная информация о Soft Updates</title>

	<indexterm>
	  <primary>Soft Updates</primary>
	  <secondary>детали</secondary>
	</indexterm>

	<para>Есть два традиционных способа записи метаданных файловых систем
	  на диск.  (Пример метаданных: индексные дескрипторы и
	  каталоги.)</para>

	<para>Исторически, поведение по умолчанию заключается в синхронном
	  обновлении метаданных.  Если каталог был изменен, система
	  ждет, пока изменение не будет физически записано на диск.
	  Содержимое файлов проходит через кэш и записывается на
	  диск асинхронно.  Преимущество этого способа в его
	  надежности.  При сбое во время обновления метаданные
	  остаются в нормальном состоянии.  Файл либо создается целиком,
	  либо вообще не создается.  Если блоки данных не были записаны
	  в файл из буфера во время сбоя, &man.fsck.8; сможет определить
	  это и восстановить файловую систему, установив длину файла в 0.
	  Кроме того, реализация этого способа проста и понятна.
	  Недостаток в том, что обновление метаданных занимает много
	  времени.  Команда <command>rm -r</command>, например,
	  последовательно удаляет все файлы в каталоге, и каждое изменение
	  в каталоге (удаление файла) будет синхронно записано на диск.
	  Сюда включаются обновления самого каталога, таблицы индексных
	  дескрипторов, и возможно блоков, занятых файлом.  Те же
	  соглашения работают при распаковке больших иерархий
	  (<command>tar -x</command>).</para>

	<para>Другой вариант это асинхронное обновление метаданных.  Это
	  поведение по умолчанию для Linux/ext2fs и *BSD ufs с параметром
  	  <command>mount -o async</command>.  Все обновления метаданных
	  просто пропускаются через кэш буфера, как и содержимое файлов.
	  Преимущество этой реализации в том, что нет необходимости ждать
	  каждый раз, пока метаданные будут записаны на диск, поэтому
	  все операции с большим объемом обновления метаданных будут
	  происходить гораздо быстрее чем при синхронном обновлении.
	  Кроме того, реализация все еще проста и понятна, поэтому
	  риск появления ошибок в коде невелик.  Недостаток в том,
	  что нет никаких гарантий исправности файловой системы.  Если во
	  время во время обновления большого объема метаданных произойдет
	  сбой (например, отключение питания, или нажатие кнопки reset),
	  файловая система останется в непредсказуемом состоянии.
	  Нет возможности определить состояние файловой системы после
	  такого сбоя; блоки данных файла могут быть уже записаны на диск,
	  а обновления таблицы индексных дескрипторов нет.  Невозможно
	  реализовать <command>fsck</command>, которая могла бы
	  исправить получившийся хаос (поскольку необходимой информации
	  нет на диске).  Если файловая система была уничтожена во
	  время восстановления, единственный способ восстановления
	  &mdash; запустить &man.newfs.8; и воспользоваться
	  резервной копией.</para>

	<para>Обычное решение этой проблемы состояло в реализации
	  <emphasis>протоколировании проблемной области (dirty region
	  logging)</emphasis>, известном как
	  <emphasis>журналирование</emphasis>, хотя этот термин
	  использовался неправильно и порой также применялся к другим
	  формам протоколирования транзакций.  Обновление метаданных
	  как и прежде происходит синхронно, но в отдельную область
	  диска.  Позже они перемещаются туда, где должны быть.
	  Поскольку область протоколирования это небольшая,
	  последовательная область диска, головкам жесткого диска
	  не приходится перемещаться на большие расстояния даже
	  во время значительных обновлений, поэтому такой способ
	  быстрее, чем синхронные обновления.
	  Кроме того, сложность реализации довольно ограничена, поэтому
	  риск внесения ошибок невелик.  Недостаток в том, что
	  все обновления метаданных записываются дважды (один раз
	  в область протоколирования и один раз окончательно),
	  поэтому при обычной работе производительность может
	  понизиться.  С другой стороны, в случае сбоя все
	  незаконченные действия с метаданными могут быть быстро
	  отменены, или завершены после загрузки системы,
	  поэтому система после сбоя загружается быстрее.</para>

	<para>Kirk McKusick, разработчик Berkeley FFS, решил эту проблему
	  с помощью Soft Updates: все незавершенные обновления метаданных
	  находятся в памяти и записываются на диск в упорядоченном
	  виде (<quote>упорядоченное обновления метаданных</quote>).
	  При значительных обновлениях метаданных более поздние обновления
	  <quote>присоединяются</quote> к предыдущим, если они все еще
	  находятся в памяти и еще не записаны на диск.  Поэтому все
	  операции, скажем, над каталогом, обычно выполняются в памяти
	  перед записью обновления на диск (блоки данных сортируются
	  в соответствии с их положением, так что они не будут записаны
	  на диск до метаданных.  При крахе операционной системы выполняется
	  <quote>откат</quote>: считается, что все операции, не записанные на
	  диск, никогда не происходили.  Файловая система находится в
	  том состоянии, в котором она была за 30&ndash;60 секунд до сбоя.
	  Используемый алгоритм гарантирует, что все используемые ресурсы
	  маркированы соответствующим образом в своих областях: блоки и
	  индексные дескрипторы.  После сбоя могут остаться только ошибки,
	  выделения ресурсов, они помечаются как <quote>используемые</quote>,
	  хотя на самом деле <quote>свободны</quote>.  &man.fsck.8;
	  разбирается в ситуации и освобождает более не используемые
	  ресурсы.  После сбоя система может быть безопасно смонтирована
	  с опцией <command>mount -f</command>.  Для освобождения ресурсов,
	  которые могут не использоваться, в дальнейшем потребуется
	  запустить &man.fsck.8;.  Эта идея лежит в основе
	  <emphasis>background (фоновая) fsck</emphasis>: во время запуска системы
	  записывается только <emphasis>снимок</emphasis> файловой системы.
	  Все системы могут быть смонтированы в <quote>грязном</quote>
	  состоянии, и система загружается в многопользовательский режим.
	  Затем, фоновые <command>fsck</command> ставятся в очередь для
	  всех систем, где это требуется, чтобы освободить неиспользуемые
	  ресурсы.  (Файловые системы, где не используются Soft Updates,
	  все еще требуют запуска <command>fsck</command> в обычном
	  режиме).</para>

	<para>Преимущество этого способа в том, что обновления метаданных
	  происходят почти так же быстро, как при асинхронных обновлениях
	  (т.е. быстрее, чем при <emphasis>журналировании</emphasis>,
	  когда метаданные записываются дважды).  Недостаток в сложности
	  кода (подразумевающим больший риск появления ошибок в области,
	  где вероятность потери данных пользователя особенно высока) и
	  в более высоких требованиях к объему памяти.  К тому же могут
	  возникнуть некоторые странные на первый взгляд ситуации.
	  После сбоя состояние файловой системы несколько более
	  <quote>старое</quote>.  В ситуации, когда стандартный способ
	  синхронизации оставит несколько файлов нулевой длины после
	  выполнения <command>fsck</command>, в файловой системе с
	  Soft Updates их не останется вовсе, поскольку ни метаданные,
	  ни содержимое файлов не были записаны на диск.  Дисковое
	  пространство не будет освобождено пока обновления не будут
	  записаны на диск, что может занять некоторое время после
	  выполнения <command>rm</command>.  Это может повлечь проблемы
	  при установке большого количества файлов на файловую
	  систему, где не хватает места для помещения всех файлов
	  дважды.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Изменение ограничений, накладываемых ядром</title>

    <indexterm>
      <primary>оптимизация</primary>
      <secondary>параметры ядра</secondary>
    </indexterm>

    <sect2 id="file-process-limits">
      <title>Ограничения на Файлы/Процессы</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>
	
	<para>Значение <varname>kern.maxfiles</varname> может быть увеличено
	  или уменьшено в зависимости от потребностей вашей системы.  Эта
	  переменная определяет максимальное число дескрипторов файлов.  Когда
	  таблица дескрипторов файлов полна, в очереди системных сообщений
	  появится сообщение <errorname>file: table is full</errorname>. Это
	  сообщение может быть прочитано с помощью команды
	  <command>dmesg</command>.</para>

	<para>Каждый открытый файл, сокет или буфер использует дескриптор
	  файла.  Широкомасштабному серверу может понадобиться много
	  тысяч дескрипторов файлов, в зависимости от количества программ,
	  одновременно выполняемых на сервере.</para>

	<para>Стандартное значение <varname>kern.maxfile</varname> определяется
	  переменной <option>MAXUSERS</option> в вашем файле конфигурации
	  ядра.  Значение <varname>kern.maxfiles</varname> увеличивается
	  пропорционально значению <option>MAXUSERS</option>.  При
	  компилировании ядра, нужно установить эту переменную согласно
	  потребностям вашей системы.  Исходя из значения этой переменной,
	  ядро устанавливает значения большинства предопределённых
	  переменных.  Даже если предполагается, что к компьютеру не будут
	  одновременно подсоединяться 256 пользователей, требуемые ресурсы
	  могут быть такими же, как у крупномасштабного сервера.</para>

	<note><para>Начиная с &os;&nbsp;4.5, установка значения
	  <option>MAXUSERS</option> в
	  <literal>0</literal> в файле конфигурации ядра выберет подходящее
	  значение по умолчанию, основанное на объеме оперативной памяти
	  системы.</para></note>
      </sect3>

      <sect3>
	<title><varname>kern.ipc.somaxconn</varname></title>

	<indexterm>
	  <primary><varname>kern.ipc.somaxconn</varname></primary>
	</indexterm>

	<para>Переменная sysctl <varname>kern.ipc.somaxconn</varname>
	  ограничивает размер очереди для приема новых TCP соединений.
	  Значение по умолчанию <literal>128</literal> слишком мало для
	  надежной обработки новых соединений для нагруженного web
	  сервера.  Для такого сервера рекомендуется увеличить это значение
	  до <literal>1024</literal> или выше.  Даемон сервиса может
	  сам ограничивать очередь приема новых соединений (например,
	  &man.sendmail.8;, или <application>Apache</application>), но
	  обычно в файле настройки даемона есть директива для настройки
	  длины очереди.  Более длинная очередь также помогает избежать
	  атак Denial of Service (<abbrev>DoS</abbrev>).</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Сетевые Ограничения</title>

      <para>Опция ядра <option>NMBCLUSTERS</option> обуславливает
	количество Mbuf, доступных на машине.  На сервере с большим трафиком
	и маленьким Mbuf производительность будет пониженной.  Каждый кластер
	представлен двумя килобайтами памяти, поэтому значение 1024 означает
	2 мегабайта памяти ядра, зарезервированной для сетевых буферов.
	Для определения оптимального значения необходимо провести простые
	вычисления.  Если у вас веб сервер, который может обслуживать 1000
	одновременных соединений, и каждое соединение <quote>съедает</quote> 16&nbsp;K буфера
	приема и 16&nbsp;K буфера отправки, вам потребуется 32&nbsp;MB памяти
	под буферы.  Хорошее правило &mdash; умножение этого значения на 2,
	2x32&nbsp;MB&nbsp;/&nbsp;2&nbsp;KB&nbsp;= 64&nbsp;MB&nbsp;/&nbsp;2&nbsp;kB&nbsp;= 32768.
	Мы рекомендуем значения между 4096 и 32768 для машин с большим объемом
	памяти.  Не указывайте произвольно большое значение параметра, это
	может привести к падению системы при загрузке.  Используйте
	&man.netstat.1; <option>-m</option> для определения количества
	используемых сетевых кластеров.</para>

      <para>Для настройки в процессе загрузки используйте в loader переменную
	<varname>kern.ipc.nmbclusters</varname>.  Только в старых версиях
	&os; потребуется пересобрать ядро (&man.config.8;) с измененным
	параметром <option>NMBCLUSTERS</option>.</para>

      <para>Для нагруженных серверов, интенсивно использующих системный
	вызов &man.sendfile.2;, может потребоваться увеличения буферов
	&man.sendfile.2; с помощью параметра конфирурации ядра
	<option>NSFBUFS</option>, или изменения значения путем установки
	переменной в <filename>/boot/loader.conf</filename>
	(обратитесь к &man.loader.8; за подробностями).  Общий
	признак того, что параметр требуется изменить &mdash;
	состояние процессов <errorname>sfbufa</errorname>.
	Переменная sysctl <varname>kern.ipc.nsfbufs</varname>
	установлена только для чтения.  Этот параметр увеличивается
	вместе с <varname>kern.maxusers</varname>, хотя может
	потребоваться увеличить его отдельно.</para>

      <important>
	<para>Даже если сокет помечен как неблокирующий, вызов
	  &man.sendfile.2; на неблокирующем сокете может вызвать блокирование
	  &man.sendfile.2;, пока не станет доступным достаточное количество
	  <literal>struct sf_buf</literal>.</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm>
	  <primary>net.inet.ip.portrange.*</primary>
	</indexterm>

	<para>Переменные sysctl <varname>net.inet.ip.portrange.*</varname>
	  контролируют диапазоны номеров портов, автоматически привязываемых
	  к TCP и UDP сокетам.  Есть три диапазона: нижний диапазон,
	  диапазон по умолчанию и верхний диапазон.  Большинство сетевых
	  программ используют диапазон по умолчанию, контролируемый
	  <varname>net.inet.ip.portrange.first</varname> и
	  <varname>net.inet.ip.portrange.last</varname>, установленными
	  соответственно в 1024 и 5000.  Диапазоны портов привязки
	  используются исходящих соединений и при некоторых условиях
	  портов может не хватить.  Это чаще всего происходит на
	  сильно загруженном прокси сервере.  Диапазон портов не
	  становится проблемой при работе серверов, которые обрабатывают
	  в основном входящие соединения, или с небольшим количеством
	  исходящих соединений, например mail relay.  Для ситуаций,
	  когда возможен недостаток портов, рекомендуется немного
	  увеличить <varname>net.inet.ip.portrange.last</varname>.
	  Может подойти значение <literal>10000</literal>,
	  <literal>20000</literal>, или <literal>30000</literal>.
	  Учтите также возможное влияние межсетевого экрана при
	  изменении диапазона портов.  Некоторые могут блокировать
	  большие диапазоны портов (обычно с небольшими номерами)
	  и вынуждают использовать более высокие диапазоны для
	  исходящих соединений.  По этой причине рекомендуется
	  настроить значение
	  <varname>net.inet.ip.portrange.first</varname>.</para>
      </sect3>

      <sect3>
	<title>TCP Bandwidth Delay Product</title>

	<indexterm>
	  <primary>TCP Bandwidth Delay Product Limiting</primary>
	  <secondary><varname>net.inet.tcp.inflight_enable</varname></secondary>
	</indexterm>

	<para>TCP Bandwidth Delay Product Limiting похоже на
	  TCP/Vegas в <application>NetBSD</application>.  Оно может быть
	  включено установкой переменной sysctl
	  <varname>net.inet.tcp.inflight_enable</varname> в
	  <literal>1</literal>.  Система попытается вычислить задержку
	  пакетов для каждого соединения и ограничить объем данных в
	  очереди сети до значения, требуемого для поддержания оптимальной
	  пропускной способности.</para>

	<para>Эта возможность полезна при передаче данных через модемы,
	  Gigabit Ethernet, или даже через высокоскоростные WAN соединения
	  (или любые другие соединения с большой задержкой передачи),
	  особенно если вы также используете изменение размера окна или
	  настроили большое окно передачи.  Если вы включили этот параметр,
	  убедитесь также, что переменная
	  <varname>net.inet.tcp.inflight_debug</varname> установлена в
	  <literal>0</literal> (отладка выключена), а для использования в
	  реальных может понадобиться установка переменной
	  <varname>net.inet.tcp.inflight_min</varname> к значению
	  как минимум <literal>6144</literal>.  Но учтите, что установка
	  большого значения этой переменной может фактически отключить
	  ограничение в зависимости от вида соединения.  Ограничение
	  уменьшает количество данных на определенном маршруте и
	  управляет очередью пакетов, как и уменьшает общее количество
	  данных в очереди локального интерфейса хоста.  С меньшим
	  количеством пакетов в очереди двусторонние интерактивные
	  соединения, особенно на медленных линиях, могут проходить
	  быстрее.  Но имейте ввиду, что эта функция работает только
	  при передаче данных (передача данных / сторона сервера).
	  Она не работает при получении данных (загрузке).</para>

	<para>Изменение значения переменной
	  <varname>net.inet.tcp.inflight_stab</varname>
	  <emphasis>не</emphasis> рекомендуется.  Этот параметр по умолчанию
	  равен 20, что означает добавление 2 пакетов к вычислению задержки
	  передачи.  Дополнительное окно требуется для стабилизации
	  алгоритма и улучшения ответной реакции на изменение условий,
	  но также приводит к большему времени ping на медленных соединениях
	  (задержка все же гораздо меньше, чем без алгоритма inflight).
	  Вы можете попробовать уменьшить этот параметр до 15, 10 или 5;
	  а также уменьшить <varname>net.inet.tcp.inflight_min</varname>
	  (например, до 3500) для получения желаемого эффекта.  Уменьшение
	  значений этих параметров может использоваться только как
	  крайняя мера.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Увеличение объема подкачки</title>

    <para>Вне зависимости от того, что вы планировали, иногда
      система ведет себя неожиданно.  Если вам потребовался
      дополнительный объем подкачки, его довольно просто добавить.
      Есть три способа увеличения объема подкачки: добавить новый
      жесткий диск, включить подкачку по NFS, или создать файл
      подкачки на существующем разделе.</para>

    <sect2 id="new-drive-swap">
      <title>Подкачка на новом жестком диске</title>

      <para>Лучший способ добавить подкачку, конечно, использовать
	еще один жесткий диск.  Вы можете сделать это в любой
	момент.  Если такой способ подходит, прочтите еще раз
	информацию по <ulink
	url="configtuning-initial.html#SWAP-DESIGN">разделу
	подкачки</ulink> из раздела Руководства по <ulink
	url="configtuning-initial.html">первоначальной настройке</ulink>,
	где рассказывается о наилучшем способе организации раздела
	подкачки.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Подкачка через NFS</title>

      <para>Подкачка через NFS рекомендуется только в том случае, если
	в системе отсутствует жесткий диск.  Подкачка через NFS
	медленна и неэффективна в версиях &os; до 4.X. Она
	довольно быстра и эффективна в 4.0-RELEASE и выше.  Но даже
	в новых версиях &os;, подкачка через NFS ограничена
	скоростью сетевого подключения и к тому же дополнительно
	нагружает NFS сервер.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>Файлы подкачки</title>

      <para>Вы можете создать файл определенного размера и использовать
	его как файл подкачки.  В нашем примере будет использован файл
	<filename>/usr/swap0</filename> размером 64MB.  Конечно, вы
	можете использовать любое имя.</para>

      <example>
        <title>Создание файла подкачки в &os; 4.X</title>

      <orderedlist>
        <listitem>
          <para>Убедитесь, что ядре включен драйвер vnode.  Он
	    <emphasis>не</emphasis>включен в последних версиях
            <filename>GENERIC</filename>.</para>

          <programlisting>pseudo-device   vn 1   #Vnode driver (turns a file into a device)</programlisting>
        </listitem>

	<listitem>
	  <para>Создайте устройство vn:</para>
	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Создайте файл подкачки (<filename>/usr/swap0</filename>):</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	</listitem>

	<listitem>
	  <para>Установите подходящие права на (<filename>/usr/swap0</filename>):</para>

	  <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Включите файл подкачки в <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	</listitem>

	<listitem>

          <para>Перегрузите компьютер, или для включения подкачки прямо
	    сейчас выполните:</para>

          <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
        </listitem>
      </orderedlist>

      </example>
      <example>
	<title>Создание файла подкачки в &os; 5.X</title>

      <orderedlist>
	<listitem>
	  <para>Убедитесь, что в файле настройки ядра присутствует драйвер
	    виртуального диска (&man.md.4;).  Он есть в ядре
	    <filename>GENERIC</filename>.</para>

	  <programlisting>device   md   # Memory "disks"</programlisting>
	</listitem>

	<listitem>
	  <para>Создайте файл подкачки (<filename>/usr/swap0</filename>):</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	</listitem>

	<listitem>
	  <para>Установите подходящие права на (<filename>/usr/swap0</filename>):</para>

	  <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	</listitem>

	<listitem>
	  <para>Включите файл подкачки в <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	</listitem>

	<listitem>

	  <para>Перегрузите компьютер или для включения подкачки прямо сейчас
            введите:</para>

	  <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 && swapon /dev/md0</userinput></screen>
        </listitem>
      </orderedlist>

      </example>
    </sect2>
  </sect1>

  <sect1 id="acpi-overview">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Hiten</firstname>
	  <surname>Pandya</surname>
	  <contrib>Написал </contrib>
	</author>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>Управление питанием и ресурсами</title>

    <para>Очень важно использовать аппаратные ресурсы эффективно.
      До того, как появился <acronym>ACPI</acronym>, управление
      потреблением питания и температурными характеристиками системы
      было очень сложной для операционной системы задачей.  Аппаратное
      обеспечение контролировалось одним из видов встроенного интерфейса
      <acronym>BIOS</acronym>, таким как: <emphasis>Plug and Play BIOS
      (PNPBIOS)</emphasis>, <emphasis>Advanced Power Management
      (APM)</emphasis> и так далее.  Управление питанием и ресурсами
      это один из ключевых компонентов современной операционной системы.
      Например, вам может потребоваться, чтобы операционная система
      следила за температурными ограничениями и возможно, предупреждала
      при неожиданном росте температуры.</para>

    <para>В этом разделе Руководства &os;, мы предоставим исчерпывающую
      информацию о <acronym>ACPI</acronym>.  В конце раздела есть ссылки
      для дальнейшего чтения.  Учтите, что <acronym>ACPI</acronym> есть
      только в &os;&nbsp;5.X и выше в качестве стандартного модуля ядра.
      В &os;&nbsp;4.9 <acronym>ACPI</acronym> можно включить добавлением
      строки <literal>device acpi</literal> к файлу настройки ядра и
      его пересборкой.</para>

    <sect2 id="acpi-intro">
      <title>Что такое ACPI?</title>

      <para>Advanced Configuration and Power Interface
	(<acronym>ACPI</acronym>) это стандарт, написанный объединением
	поставщиков в целях предоставления стандартного интерфейса для
	аппаратных ресурсов и управления питанием (отсюда и название).
	Это ключевой элемент <emphasis>Operating System-directed
	configuration and Power Management</emphasis>, т.е.: он предоставляет
	операционной системе (<acronym>OS</acronym>) больше контроля и более
	универсален.  Современные системы вышли за пределы ограничений
	существующих Plug and Play интерфейсов (таких как APM,
	использовавшийся в &os;&nbsp;4.X), до появления
	<acronym>ACPI</acronym>.  <acronym>ACPI</acronym> это прямой
	наследник <acronym>APM</acronym> (Advanced Power Management).</para>

    <sect2 id="acpi-old-spec">
      <title>Недостатки Advanced Power Management (APM)</title>

      <para>Средства <emphasis>Advanced Power Management (APM)</emphasis>
	управляют энергопотреблением системы в зависимости от
	нагрузки.  APM BIOS предоставляется поставщиком системы и
	специфичен для данной аппаратной платформы.  Драйвер APM
	в OS обеспечивает доступ к <emphasis>APM Software Interface</emphasis>,
	который позволяет управлять уровнями потребления питания.</para>

      <para>В APM имеется четыре основных проблемы.  Во-первых, управление
	энергопотреблением осуществляется через зависимый от поставщика
	BIOS, и OS ничего не знает нем.  Один пример: когда пользователь
	устанавливает время ожидания для жесткого диска в APM BIOS,
	и это время истекает, BIOS останавливает жесткий диск без согласования
	с OS.  Во-вторых, алгоритм APM встроен в BIOS, и все действия
	происходят вне контроля OS.  Это означает, что пользователи
	могут решить проблемы с APM BIOS только путем перепрошивки
	его ROM; это очень опасная процедура, и если она завершится
	неудачно, система может прийти в невосстановимое состояние.
	В-третьих, реализация технологии APM зависит от поставщика,
	что означает дублирование усилий и если в BIOS одного
	из поставщиков будет найдена и исправлена ошибка, ее могли
	не исправить другие поставщики.  Наконец, объем APM BIOS недостаточно
	велик для реализации сложной политики управления питанием, или
	такой политики, которая может хорошо адаптироваться к потребностям
	компьютера.</para>
      
      <para><emphasis>Plug and Play BIOS (PNPBIOS)</emphasis> был неудобен
	во многих ситуациях.  PNPBIOS это 16-битная технология,
	поэтому OS требовалось использовать 16-битную эмуляцию для
	<quote>взаимодействия</quote> с методами PNPBIOS.</para>

      <para>&os; драйвер <acronym>APM</acronym> документирован в странице
	справочника &man.apm.4;.</para>
    </sect2>

    <sect2 id="acpi-config">
      <title>Настройка <acronym>ACPI</acronym></title>

      <para>&man.loader.8; загружает драйвер <filename>acpi.ko</filename> по
	умолчанию, его <emphasis>не</emphasis> надо встраивать в ядро.
	Причина в том, что с модулями проще работать, например переключиться
	на другой <filename>acpi.ko</filename> без пересборки ядра.
	Преимущество в упрощении тестирования.  Другая причина в том, что
	запуск <acronym>ACPI</acronym> после старта системы не очень полезен
	и при некоторых условиях может приводить к краху.  Если вы
	сомневаетесь,  отключите <acronym>ACPI</acronym> совсем.  Драйвер не
	должен и не может быть выгружен, поскольку системная шина используется
	для различных взаимодействий оборудования.  <acronym>ACPI</acronym>
	может быть выключен с помощью утилиты &man.acpiconf.8;.  Фактически
	большинство взаимодействий с <acronym>ACPI</acronym> может быть
	выполнено через &man.acpiconf.8;.  В основном это означает, что если в
	выводе &man.dmesg.8; есть что-то об <acronym>ACPI</acronym>, он скорее
	всего работает.</para>

      <note><para><acronym>ACPI</acronym> и <acronym>APM</acronym> не могут
	сосуществовать и должны использоваться раздельно.  Каждый из них
	прервет загрузку, если обнаружит загруженный драйвер
	другого.</para></note>

      <para>В простейшей форме, <acronym>ACPI</acronym> может использоваться
	для перевода системы в спящий режим с помощью &man.acpiconf.8;, с
	флагом <option>-s</option> и параметром <literal>1-5</literal>.
	Большинству пользователей нужен только параметр <literal>1</literal>.
	Параметр <literal>5</literal> сделает <quote>мягкое</quote>
	завершение работы, так же как и:</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>

      <para>Доступны и другие параметры.  Обратитесь к странице справочника
	&man.acpiconf.8; за дополнительной информацией.</para>
    </sect2>

    <sect2 id="acpi-debug">
      <title>Отладка и отключение <acronym>ACPI</acronym></title>

      <para>Почти все в <acronym>ACPI</acronym> прозрачно, пока не начинаются
	проблемы.  Это обычно случается, когда пользователь узнает, что
	что-то работает неправильно.  Драйвер &man.acpi.4; поддерживает
	много параметров отладки, можно даже выборочно отключить некоторые
	части системы <acronym>ACPI</acronym>.  За более подробной информацией
	о средствах отладки обратитесь к странице справочника
	&man.acpi.4;.</para>

      <para>Иногда по различным причинам необходимо выгрузить модуль
	<filename>acpi.ko</filename>.  Это можно сделать только во
	время загрузки через &man.loader.8;.  Вы можете набирать
	<command>unset acpi_load</command> в приглашении
	&man.loader.8; при каждом старте системы, или отменить
	автозагрузку драйвера &man.acpi.4;, добавив в
	<filename>/boot/loader.conf</filename> следующую строку:</para>

      <programlisting>exec="unset acpi_load"</programlisting>

      <para>&os;&nbsp;5.1-RELEASE и более новые поставляются с меню,
	управляющим загрузкой &os;.  Один из предоставляемых параметров,
	это отключение <acronym>ACPI</acronym>.  Для отключения
	<acronym>ACPI</acronym> просто выберите в меню
	<guimenuitem>2. Boot &os; with ACPI disabled</guimenuitem>.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
