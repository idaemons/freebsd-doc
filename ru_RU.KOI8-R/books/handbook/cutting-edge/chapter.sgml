<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/cutting-edge/chapter.sgml,v 1.2 2001/01/15 15:45:03 phantom Exp $

     Original revision: 1.57
-->

<chapter id="cutting-edge">
  <title>На переднем крае разработок</title>

  <para><emphasis>Реструктуризацию, реорганизацию и добавление частей
    выполнил &a.jim; в марте 2000.  Оригинальный текст написали &a.jkh;,
    &a.phk;, &a.jdp; и &a.nik; при помощи многих других.</emphasis></para>

  <sect1>
    <title>Краткий обзор</title>

    <para>Между релизами над FreeBSD ведется постоянная работа.  Для тех,
      кто хочет быть не переднем крае, есть несколько простых методов для
      поддержания своей системы в соответствии с последними разработками.
      Будьте осторожны&mdash;передний край не для всех!  Эта глава поможет
      вам решить, хотите ли вы отслеживать систему в процессе работы над ней
      или останетесь верным одному из выпущенных релизов.</para>
  </sect1>

  <sect1 id="current-stable">
    <title>-CURRENT против -STABLE</title>

    <para>Во FreeBSD имеется две ветки разработки; -CURRENT и -STABLE.  Этот
      раздел описывает каждую из них и объясняет, как синхронизировать вашу
      систему с каждой соответствующей веткой.  Сначала будет обсуждена ветка
      -CURRENT, затем -STABLE.</para>

    <sect2 id="current">
      <title>Как оставаться с текущими разработками во FreeBSD</title>

      <para>Пока вы читаете этот текст, помните, что -CURRENT является
        <quote>передовым краем</quote> работ над FreeBSD, и если вы являетесь
        во FreeBSD новичком, вам лучше сначала дважды подумать, прежде чем
        работать с этой веткой.</para>

      <sect3>
        <title>Что такое FreeBSD-CURRENT?</title>

        <para>FreeBSD-CURRENT это, если точно, не более чем ежедневный слепок
          исходных текстов FreeBSD, над которыми ведется работа.  Сюда
          включаются неоконченные работы, экспериментальные изменения и
          промежуточные механизмы, которые могут присутствовать, а могут и
          отсутствовать в следующем официальном релизе программного
          обеспечения.  Хотя многие из нас выполняют компиляцию из исходных
          текстов FreeBSD-CURRENT практически ежедневно, случаются периоды
          времени, когда исходные тексты заведомо не могут быть
          откомпилированы.  Такие проблемы обычно решаются быстро, насколько
          это возможно, но содержат или нет исходные тексты FreeBSD-CURRENT
          мину замедленного действия или очень нужную функциональность,
          может оказаться зависящим от того, в какой момент из 24-часового
          периода времени вы их сгрузили!</para>
      </sect3>

      <sect3>
        <title>Кому нужна FreeBSD-CURRENT?</title>

        <para>FreeBSD-CURRENT в основном предназначается трем основным
          заинтересованным группам:</para>

        <orderedlist>
          <listitem>
            <para>Члены команды разработчиков FreeBSD, активно работающие над
              некоторой частью дерева исходных текстов и для кого работа в
              <quote>current</quote> является абсолютной
              необходимостью.</para>
          </listitem>

          <listitem>
            <para>Члены команды разработчиков FreeBSD, которые являются
              активными тестерами, тратящие время на работу с проблемами для
              того, чтобы определить, что FreeBSD-CURRENT остается, насколько
              это возможно, нормально работающей системой.  Есть также люди,
              которые вносят важные предложения по изменениям и общему
              направлению развития FreeBSD.</para>
          </listitem>

          <listitem>
            <para>Остальные члены групп разработчиков FreeBSD (или других
              групп), которые просто хотят быть в курсе всех изменений и
              используют текущие исходные тексты для ознакомительных целей (к
              примеру, для <emphasis>чтения</emphasis>, но не для
              использования).  Такие люди также иногда высказывают замечания
              или предоставляют код.</para>
          </listitem>
        </orderedlist>
      </sect3>

      <sect3>
        <title>Чем FreeBSD-CURRENT <emphasis>не</emphasis> является?</title>

        <orderedlist>
          <listitem>
            <para>Быстрым способом получить предварительную версию, потому
              что вы слышали, что здесь появилась некая крутая возможность
              и вы хотите быть первым в вашем микрорайоне, у кого она
              есть.</para>
          </listitem>

          <listitem>
            <para>Быстрым способом получения исправлений.</para>
          </listitem>

          <listitem>
            <para><quote>Официально поддерживаемой</quote> нами каким бы то
              ни было способом.  Мы прилагаем все усилия, чтобы помочь тем,
              кто изначально принадлежит одной из трех
              <quote>признанных</quote> категорий FreeBSD-CURRENT, но у нас
              просто <emphasis>нет времени</emphasis> на техническую
              поддержку этой ветки.  Это не потому, что мы гадкие и злые
              люди, которые не хотят помочь другим (если бы это было так, мы
              не создали бы FreeBSD), это исключительно потому, что мы не
              можем отвечать на 400 сообщений в день <emphasis>и</emphasis>
              что-то еще делать по FreeBSD!  Я уверен, что если бы стоял
              выбор между тем, отвечать ли нам на вопросы или продолжать
              усовершенствовать FreeBSD, большинство из вас проголосовали бы
              за нашу работу над усовершенствованием.</para>
          </listitem>
        </orderedlist>
      </sect3>

      <sect3>
        <title>Использование FreeBSD-CURRENT</title>

        <orderedlist>
          <listitem>
            <para>Присоединитесь к спискам рассылки &a.current; и &a.cvsall;.
              Это не просто хорошая мысль, это
              <emphasis>необходимо</emphasis>.  Если вы не являетесь
              участником списка рассылки
              <emphasis>FreeBSD-CURRENT</emphasis>, вы не увидите замечания,
              высказываемые о текущем состоянии системы и в итоге можете
              столкнуться со множеством проблем, которые уже были найдены и
              решены другими.  Еще хуже, если вы пропустите важные сообщения,
              касающиеся жизнеспособности вашей системы.</para>

            <para>Список рассылки &a.cvsall; позволит вам для каждого
              изменения увидеть соответствующую запись в журнале коммитов,
              так как они делаются вместе со всей относящейся к делу
              информацией о возможных посторонних эффектах.</para>

            <para>Чтобы подключиться к этим спискам, пошлите письмо на адрес
              &a.majordomo; указав в теле письма следующее:</para>

            <programlisting>
subscribe freebsd-current
subscribe cvs-all
            </programlisting>

            <para>Дополнительно вы можете также указать
              <literal>help</literal>, а Majordomo вышлет вам подробную
              справку о том, как подписаться и отказаться от подписки на
              различные другие списки рассылки, которые мы ведем.</para>
          </listitem>

          <listitem>
            <para>Сгрузите исходные тексты с <hostid
              role="fqdn">ftp.FreeBSD.org</hostid>.  Вы можете сделать это
              одним из трех способов:</para>

            <orderedlist>
              <listitem>
                <para>При помощи <application><link
                  linkend="ctm">CTM</link></application>.  Если у вас нет
                  хорошего подключения по TCP/IP с фиксированной абонентской
                  платой, то это то, что нужно.</para>
              </listitem>

              <listitem>
                <para>При помощи программы <link linkend="cvsup">cvsup</link>
                  с <ulink
                  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/src/share/examples/cvsup/standard-supfile">
                  таким sup-файлом</ulink>.  Это второй самый рекомендуемый
                  метод, так как он позволяет вам сгрузить набор исходных
                  текстов один раз полностью, а затем сгружать только
                  произошедшие изменения.  Многие запускают cvsup при помощи
                  прграммы cron и получают самые свежие исходные тексты
                  автоматически.  Для облегчения его получения просто
                  наберите:</para>

                <blockquote>
                  <screen>
&prompt.root; <userinput>pkg_add -f \
ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CVSup/cvsupit.tgz</userinput>
                  </screen>
                </blockquote>
              </listitem>

              <listitem>
                <para>При помощи <command>ftp</command>.  Дерево исходных
                  текстов для FreeBSD-CURRENT всегда
                  <quote>экспортируется</quote> на: <ulink
                  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/">
                  ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/</ulink>.
                  К тому же мы используем <command>wu-ftpd</command>,
                  позволяющий выполнять сгрузку полных деревьев каталогов
                  сжатых/упакованных при помощи tar, к примеру,
                  возьмем:</para>

                <screen>usr.bin/lex</screen>

                <para>Чтобы получить весь каталог в виде tar-файла, вы можете
                  сделать следующее:</para>

                <screen>
<prompt>ftp&gt;</prompt> <userinput>cd usr.bin</userinput>
<prompt>ftp&gt;</prompt> <userinput>get lex.tar</userinput>
                </screen>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Итак, если вам нужен быстрый доступ по требованию к
              исходным текстам и нагрузка на каналы связи для вас не
              представляет проблемы, то используйте <command>cvsup</command>
              или <command>ftp</command>.  В противном случае воспользуйтесь
              <application>CTM</application>.</para>

            <para>Если вам нужны исходные тексты для компиляции и запуска, а
              не просто для ознакомления, то сгружайте исходные тексты
              ветки current <emphasis>полностью</emphasis>, а не отдельные
              ее части.  Причиной является то, что многие части исходных
              текстов зависят от других обновлений где-то еще, и попытка
              компиляции лишь некоторой части программ гарантированно
              приведет к возникновению проблем.</para>

            <para>Перед тем, как компилировать current, внимательно прочтите
              файл <filename>Makefile</filename> в каталоге
              <filename>/usr/src</filename>.  В процессе обновления вы
              по крайней мере раз должны пройти через <link
              linkend="makeworld">make world</link>.  Чтение &a.current;
              позволит вам быть в курсе всех процедур начальной загрузки,
              которые иногда бывают необходимы при переходе к следующему
              релизу.</para>
          </listitem>

          <listitem>
            <para>Будьте активными подписчиками!  Если вы работаете с
              FreeBSD-CURRENT, мы хотим знать, что вы думаете о ней, особенно
              если у вас есть соображения по ее улучшению или исправлению
              ошибок.  Пожелания, к которым прилагается код, всегда
              принимаются с большим энтузиазмом!!</para>
          </listitem>
        </orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>Работа с веткой stable во FreeBSD</title>

      <para>Если вы используете FreeBSD в производстве и хотите быть
        уверенными, что у вас есть все последние исправления из ветки
        -CURRENT, то вам нужно работать со -STABLE.  Это та ветка, из которой
        делаются -RELEASE при их выпуске.  Например, если у вас есть копия
        3.4-RELEASE, то это всего лишь <quote>снэпшот</quote> ветки -STABLE,
        который мы поместили на компакт-диск.  Для того, чтобы получить все
        изменения, вошедшие в -STABLE после выхода -RELEASE, вам нужно
        <quote>отслеживать</quote> ветку -STABLE.</para>

      <sect3>
        <title>Что такое FreeBSD-STABLE?</title>

        <para>FreeBSD-STABLE является нашей веткой разработки для менее
          важных и более консервативных изменений, предназнанных для
          следующего основного релиза.  Экспериментальные или
          непротестированные изменения в эту ветку не преднаханчены для этой
          ветки (смотрите материал о <link linkend="current">
          FreeBSD-CURRENT</link>).</para>
      </sect3>

      <sect3>
        <title>Кому нужна FreeBSD-STABLE?</title>

        <para>Если вы корпоративный пользователь или тот, кто вопрос
          надежность работы своей системы FreeBSD ставит прежде всех других
          аспектов, то вам необходимо отслеживать ветку
          <emphasis>stable</emphasis>.  Это особенно важно, если вы
          установили самый последний релиз (<ulink
          url="ftp://ftp.FreeBSD.org/pub/FreeBSD/&rel.current;-RELEASE/">
          &rel.current;-RELEASE</ulink> на момент написания этого текста),
          так как ветка <emphasis>stable</emphasis> на самом деле является
          разработкой свободной от ошибок предыдущего релиза.</para>

        <warning>
          <para>Кроме всего прочего. дерево <emphasis>stable</emphasis>
            пытается быть всегда надежным и пригодным к компиляции, однако
            иногда мы делаем ошибки (в конце концов, это все таки активная
            разработка с часто происходящими обновлениями).  Мы также
            прилагаем все усилия, чтобы протестировать все исправления в
            <emphasis>current</emphasis> перед тем, как вносить их в
            <emphasis>stable</emphasis>, однако наши тесты иногда
            предусматривают не все возможные случаи.  Если у вас что-то
            работает в <emphasis>stable</emphasis> не так, то, пожалуйста,
            дайте нам знать <emphasis>немедленно!</emphasis> (смотрите
            следующий раздел).</para>
        </warning>
      </sect3>

      <sect3>
        <title>Использование FreeBSD-STABLE</title>

        <orderedlist>
          <listitem>
            <para>Подключитесь к списку рассылки &a.stable;.  Это позволит
              вам быть информированным о зависимостях этапа построения,
              которые могут появиться в ветке <emphasis>stable</emphasis> или
              любых других проблемах, требущих особого внимания.  В этом
              списке рассылки разработчики также делают объявления, когда
              они рассматривают некоторое спорное исправление или добавление,
              давая пользователям возможность ответить, возникли ли у них
              проблемы, вызванные предполагаемым изменением.</para>

            <para>Список рассылки &a.cvsall; позволит вам для каждого
              изменения увидеть соответствующую запись в журнале коммитов,
              так как они делаются вместе со всей относящейся к делу
              информацией о возможных посторонних эффектах.</para>

            <para>Чтобы подключиться к этим спискам, пошлите письмо на адрес
              &a.majordomo; указав в теле письма следующее:</para>

            <programlisting>
subscribe freebsd-stable
subscribe cvs-all
            </programlisting>

            <para>Дополнительно вы можете также указать
              <literal>help</literal>, а Majordomo вышлет вам подробную
              справку о том, как подписаться и отказаться от подписки на
              различные другие списки рассылки, которые мы ведем.</para>
          </listitem>

          <listitem>
            <para>Если вы устанавливаете новую систему и хотите, чтобы она
              работала максимально стабильно, то можете просто сгрузить
              самый последний по дате снэпшот ветки по адресу <ulink
              url="ftp://releng4.FreeBSD.org/pub/FreeBSD/">
              ftp://releng4.FreeBSD.org/pub/FreeBSD/</ulink> и установить
              его, как любой другой релиз.</para>

            <para>Если вы уже работаете с предыдущим релизом FreeBSD и хотите
              обновить его из исходных текстов, то вы можете легко это
              сделать с сервера <hostid role="fqdn">ftp.FreeBSD.org</hostid>.
              Это можно сделать одним из трех способов:</para>

            <orderedlist>
              <listitem>
                <para>При помощи <application><link
                  linkend="ctm">CTM</link></application>.  Если у вас нет
                  хорошего подключения по TCP/IP с фиксированной абонентской
                  платой, то это то, что нужно.</para>
              </listitem>

              <listitem>
                <para>При помощи программы <link linkend="cvsup">cvsup</link>
                  с <ulink
                  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-current/src/share/examples/cvsup/stable-supfile">
                  таким sup-файлом</ulink>.  Это второй самый рекомендуемый
                  метод, так как он позволяет вам сгрузить набор исходных
                  текстов один раз полностью, а затем сгружать только
                  произошедшие изменения.  Многие запускают cvsup при помощи
                  прграммы cron и получают самые свежие исходные тексты
                  автоматически.  Для облегчения его получения просто
                  наберите:</para>

                <blockquote>
                  <screen>
&prompt.root; <userinput>pkg_add -f \
ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CVSup/cvsupit.tgz</userinput>
                  </screen>
                </blockquote>
              </listitem>

              <listitem>
                <para>При помощи <command>ftp</command>.  Дерево исходных
                  текстов для FreeBSD-STABLE всегда
                  <quote>экспортируется</quote> на: <ulink
                  url="ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-stable/">
                  ftp://ftp.FreeBSD.org/pub/FreeBSD/FreeBSD-stable/</ulink>.
                  К тому же мы используем <command>wu-ftpd</command>,
                  позволяющий выполнять сгрузку полных деревьев каталогов
                  сжатых/упакованных при помощи tar, к примеру,
                  возьмем:</para>

                <screen>usr.bin/lex</screen>

                <para>Чтобы получить весь каталог в виде tar-файла, вы можете
                  сделать следующее:</para>

                <screen>
<prompt>ftp&gt;</prompt> <userinput>cd usr.bin</userinput>
<prompt>ftp&gt;</prompt> <userinput>get lex.tar</userinput>
                </screen>
              </listitem>
            </orderedlist>
          </listitem>

          <listitem>
            <para>Итак, если вам нужен быстрый доступ по требованию к
              исходным текстам и нагрузка на каналы связи для вас не
              представляет проблемы, то используйте <command>cvsup</command>
              или <command>ftp</command>.  В противном случае воспользуйтесь
              <application>CTM</application>.</para>
          </listitem>

          <listitem>
            <para>Перед тем, как компилировать stable, внимательно прочтите
              файл <filename>Makefile</filename> в каталоге
              <filename>/usr/src</filename>.  В процессе обновления вы
              по крайней мере раз должны пройти через <link
              linkend="makeworld">make world</link>.  Чтение &a.stable;
              позволит вам быть в курсе всех процедур начальной загрузки,
              которые иногда бывают необходимы при переходе к следующему
              релизу.</para>
          </listitem>
        </orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Синхронизация ваших исходных текстов</title>

    <para>Имеются различные способы использования Интернет (или почтового)
      подключения для того, чтобы иметь самые последние версии исходных
      текстов любого проекта FreeBSD, во всех областях, в зависимости от
      того, чем вы интересуетесь.  Основной сервисы, который мы предлагаем,
      это <link linkend="anoncvs">Анонимный CVS</link>, <link
      linkend="cvsup">CVSup</link> и <link linkend="ctm">CTM</link>.</para>

    <para><application>Анонимный CVS</application> и
      <application>CVSup</application> используют модель
      <emphasis>pull</emphasis> обновления исходных текстов.  В случае
      <application>CVSup</application> пользователь (или скрипт программы
      cron) вызывают <command>cvsup</command>, а она работает с каким-либо
      сервером <command>cvsupd</command>, чтобы выполнить обновление ваших
      файлов.  Обновления, которые вы получаете, обнолены с точностью до
      минуты и вы получаете их тогда и только тогда, когда сами захотите.
      Вы можете с легкостью ограничить ваши обновления конкретными файлами
      или каталогами, которые представляют для вас интерес.  Обновления
      создаются на лету сервером согласно тому, что у вас есть и что вы
      хотите иметь.  <application>Анонимный CVS</application> гораздо проще,
      чем CVSup в том смысле, что он представляет собой всего лишь расширение
      <application>CVS</application>, позволяющее сгрузить изменения
      непосредственно с удаленного хранилища CVS.
      <application>CVSup</application> может делать это гораздо более
      эффективно, однако <application>анонимным CVS</application> легче
      пользоваться.</para>

    <para><application>CTM</application>, с другой стороны, не сравнивает
      последовательно исходные тексты, имеющиеся у вас, с теми, что
      находятся в главном архиве и ни каким-либо другим способом их не
      сгружает..  Вмесо этого несколько раз в день на главной машине CTM
      запускается скрипт, идентифицирующий изменения в файлах с момента
      своего предыдущего запуска, все замеченные изменения подвергаются
      сжатию, пометке последовательным номером и кодировке для передачи по
      электронной почте (исключительно в форме печатаемых символов ASCII).
      После получения эти <quote>дельта-файлы CTM</quote> могут быть
      переданы утилите &man.ctm.rmail.1;, которая осуществит автоматическое
      декодирования, проверку и применение изменений к пользовательской
      копии исходных текстов.  Этот процесс гораздо более эффективен, чем
      <application>CVSup</application> и требует меньше ресурсов нашего
      сервера, так как он сделан по модели <emphasis>push</emphasis>, а не
      <emphasis>pull</emphasis>.</para>

    <para>Есть другие минусы, конечно.  Если вы случайно уничтожили
      часть вашего архива, то <application>CVSup</application> обнаружит
      и перестроит поврежденную часть.  <application>CTM</application> этого
      делать не будет, и если вы уничтожили какую-то часть вашего дерева
      исходных текстов (и у вас нет архивной копии), то вам нужно будет
      начать с самого начала (с самого последнего <quote>базового
      дельта-файла</quote> CVS), перестроив все с помощью CTM, или, используя
      anoncvs, просто удалить поврежденную часть и
      пересинхронизироваться.</para>

    <para>Более подробная информация об <application>анонимном
      CVS</application>, <application>CTM</application> и
      <application>CVSup</application> находится в этом разделе далее.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>Использование <command>make world</command></title>

    <para>После того, как вы засинхронизировали ваше локальное дерево
      исходных текстов с некоторой версией FreeBSD
      (<literal>stable</literal>, <literal>current</literal> и так далее),
      то должны использовать эти исходные тексты для перестроения
      системы.</para>

    <warning>
      <title>Создайте резервную копию</title>

      <para>Я не могу удивить вас тем, насколько важно сделать резервную
        копию вашей системы <emphasis>до того</emphasis>, как вы будете
        это делать.  Хотя перестроение всей системы (пока вы следуете этим
        инструкциям) является простой задачей, вы всегда можете допустить
        ошибку, или ошибка может оказаться в исходных текстах, что может
        привести к тому, что система перестанет загружаться.</para>

      <para>Обязательно сделайте резервную копию.  И держите под рукой
        аварийную дискету.  Мне никогда не приходилось ими пользоваться, но,
        постучав по дереву, всегда лучше подготовиться, чем потом
        извиняться.</para>
    </warning>

    <warning>
      <title>Подпишитесь на соответствующий список рассылки</title>

      <para>Ветки -STABLE и -CURRENT кода FreeBSD по природе своей являются
        <emphasis>изменяющимися</emphasis>.  В разработке FreeBSD участвуют
        люди, и время от времени случаются ошибки.</para>

      <para>Иногда эти ошибки достаточно безобидны и приводят к выводу
        нового диагностического сообщения.  Бывает, что изменение оказывается
        катастрофичным, и система не может загрузиться или разрушаются
        файловые системы (или еще хуже).</para>

      <para>Если возникают подобные проблемы, в соответствующем списке
        рассылки публикается сообщение <quote>heads up</quote>, в котором
        описывается природа проблемы и затрагиваемые системы.  Когда проблема
        решается, публикуется сообщение <quote>all clear</quote>.</para>

      <para>Если вы пытаетесь отслеживать -STABLE или -CURRENT и не читаете
        списки рассылки <email>stable@FreeBSD.org</email> или
        <email>current@FreeBSD.org</email>, то вы напрашиваетесь на
        неприятности.</para>
    </warning>

    <sect2>
      <title>Прочтите <filename>/usr/src/UPDATING</filename></title>

      <para>Перед тем, как делать что-либо, прочтите
        <filename>/usr/src/UPDATING</filename> (или соответствующий файл,
        если у вас есть копия исходных текстов).  В этом файле должна
        содержаться важная информация о проблемах, с которыми вы можете
        столкнуться, или указан порядок, в котором вы должны запускать
        определенные команды.  Если в файле <filename>UPDATING</filename>
        написано нечто, противоречающее тому, что вы здесь читаете, то
        нужно следовать указаниям в <filename>UPDATING</filename>.</para>

      <important>
        <para>Чтение <filename>UPDATING</filename> не заменит подписки на
          соответствующий список рассылки, как это и описано выше.  Эти два
          условия являются дополняющими, а не взаимоисключающими друг
          друга.</para>
      </important>
    </sect2>

    <sect2>
      <title>Проверьте содержимое <filename>/etc/make.conf</filename></title>

      <para>Просмотрите файлы <filename>/etc/defaults/make.conf</filename> и
        <filename>/etc/make.conf</filename>.  Первый содержит некоторые
        предопределенные по умолчанию значения &ndash; большинство из них
        закомментировано.  Чтобы воспользоваться ими при перестроении системы
        из исходных текстов, добавьте их в файл
        <filename>/etc/make.conf</filename>.  Имейте в виду, что все,
        добавляемое вами в <filename>/etc/make.conf</filename>, используется
        также каждый раз при запуске команды <command>make</command>, так что
        полезно задать здесь значения, подходящие вашей системе.</para>

      <para>Как обычный пользователь (не разработчик FreeBSD), вам может
        потребоваться скопировать строки <makevar>CFLAGS</makevar> и
        <makevar>NOPROFILE</makevar>, расположенные в
        <filename>/etc/defaults/make.conf</filename>, в файл
        <filename>/etc/make.conf</filename> и раскомментировать их.</para>

      <note>
        <title/Версии 2.1.7 и ниже/

        <para>Если в вашей машине имеется сопроцессор для работы с
          вещественными числами (машины класса 386DX, 486DX, Pentium и выше),
          то вы можете также раскомментировать строчку HAVE_FPU.</para>

        <para>Это определение было убрано в версиях FreeBSD 2.2.2 и
          выше.</para>
      </note>

      <para>Посмотрите на другие определения (COPTFLAGS, NOPORTDOCS и так
        далее) и решите, имеют ли они для вас значение.</para>
    </sect2>

    <sect2>
      <title>Обновите файл <filename>/etc/group</filename></title>

      <para>Каталог <filename>/etc</filename> содержит значительную часть
        информации о конфигурации вашей системы, а также скрипты, работающие
        в начале работы системы.  Некоторые из этих скриптов меняются от
        версии к версии FreeBSD.</para>

      <para>Некоторые конфигурационные файлы также используются в ежедневной
        работе системы.  В частности, файл
        <filename>/etc/group</filename>.</para>

      <para>Случалось, что установочная часть <quote>make world</quote>
        ожидала существования определенных имен пользователей или групп.  При
        обновлении вероятно, что эти группы не существуют.  Это вызывает
        проблемы при обновлении.</para>

      <para>Самым свежим примером этого является добавление группы
        <quote/ppp/ (позже переименованной в <quote/network/).  Пользователи
        сталкивались с прерыванием процесса установки, когда части подсистемы
        <filename>ppp</filename> устанавливались с использованием
        не существующего (для них) имени группы.</para>

      <para>Выходом является просмотр файла
        <filename>/usr/src/etc/group</filename> и сравнение списка групп в
        нем с вашим собственным.  Если в новом файле есть группы,
        отсутствующие в вашем, то скопируйте их.  Таким же образом вы должны
        переименовывать все группы в <filename>/etc/group</filename>, которые
        имеют тот же самый GID, но другое название в
        <filename>/usr/src/etc/group</filename>.</para>

      <tip>
        <para>Если ощущаете себя параноиком, вы можете проверить вашу систему
          в поиске файлов, владельцем которых является та группа, которую вы
          переименовываете или удаляете.</para>

        <screen>
&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput>
        </screen>

        <para>выдаст список всех файлов, владельцем которых является группа
          <replaceable>GID</replaceable> (задаваемая по имени группы или
          численному значению ID).</para>
      </tip>
    </sect2>

    <sect2>
      <title/Перейдите в однопользовательский режим/

      <para>Вам может понадобиться откомпилировать систему в
        однопользовательском режиме.  Кроме обычного выигрыша в значительном
        ускорении процесса, переустановка системы затрагивает много важных
        системных файлов, все стандартные выполнимые файлы системы,
        библиотеки, include-файлы и так далее.  Изменение их на работающей
        системе (в частности, в которой работают пользователи) может
        привести к неприятностям.</para>

      <para>Если вы смелы и предупреждены о неприятностях, то можете
        пропустить этот шаг.</para>

      <note>
        <title>Версия 2.2.5 и выше</title>

        <para>Как описывается более подробно ниже, в версиях FreeBSD 2.2.5 и
          выше процессы установки и построения разделены.  Таким образом, вы
          можете <emphasis>построить</emphasis> новую систему в
          многопользовательском режиме, а для установки затем перейти в
          однопользовательский режим.</para>
      </note>

      <para>Как администратор, вы можете выполнить</para>

      <screen>
&prompt.root; <userinput/shutdown now/
      </screen>

      <para>на работающей системе, что переведет ее в однопользовательский
        режим.</para>

      <para>Либо вы можете выполнить перезагрузку и в приглашении загрузчика
        задать флаг <option>-s</option>.  После этого система загрузится в
        однопользовательском режиме.  В приглашии командного процессора вы
        должны тогда запустить:</para>

      <screen>
&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput>
      </screen>

      <para>Эти команды выполнят проверку файловых систем, перемонтируют
        <filename>/</filename> в режиме чтения/записи, смонтируют все
        остальные файловые системы UFS, перечисленные в файле
        <filename>/etc/fstab</filename> и включат подкачку.</para>
    </sect2>

    <sect2>
      <title>Удалите <filename>/usr/obj</filename></title>

      <para>При перестроении частей системы они помещаются в каталоги,
        которые (по умолчанию) находятся в <filename>/usr/obj</filename>.
        Каталоги скрывают их в <filename>/usr/src</filename>.</para>

      <para>Вы можете ускорить выполнение процесса <quote>make world</quote>
        и, возможно, избавить себя от некоторой головной боли, связанной с
        зависимостями, удалив этот каталог.</para>

      <para>На некоторых файлах из <filename>/usr/obj</filename> будут
        установлены специальные флаги (обратитесь к &man.chflags.1; за
        дополнительной информацией), которые сначала должны быть
        сняты.</para>

      <screen>
&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput>
      </screen>
    </sect2>

    <sect2>
      <title/Перекомпилируйте исходные тексты и установите новую систему/

      <sect3>
        <title>Все версии</title>

        <para>Вы должны находиться в каталоге
          <filename>/usr/src</filename>...</para>

        <screen>
&prompt.root; <userinput>cd /usr/src</userinput>
        </screen>

        <para>(если, конечно, ваш исходный код находится где-то еще, в случае
          чего вам нужно перейти в соответствующий каталог).</para>

        <para>Для полного перестроения системы используется
          команда &man.make.1;.  Эта команда читает инструкции из файла
          <filename>Makefile</filename>, описывающего, как должны быть
          перестроены команды, которые составляют систему FreeBSD, в каком
          порядке они должны быть построены и так далее.</para>

        <para>Общий формат командной троки, которую вы будет набирать,
          таков:</para>

        <screen>
&prompt.root; <userinput>make <option>-<replaceable/x/</option> <option>-D<replaceable>VARIABLE</replaceable></option> <replaceable>target</replaceable></userinput>
        </screen>

        <para>В этом примере <option>-<replaceable>x</replaceable></option>
          является параметром, который вы передаете в &man.make.1;.
          Обратитесь к справочной странице программы &man.make.1;, в которой
          есть пример параметров, которые вы можете передать.</para>

        <para><option>-D<replaceable>VARIABLE</replaceable></option>
          передает переменную в <filename>Makefile</filename>.  Поведение
          <filename>Makefile</filename> определяется этими переменными.  Это
          те же самые переменные, которые задаются в
          <filename>/etc/make.conf</filename>, и это дает еще один способ
          их задания.</para>

        <screen>
&prompt.root; <userinput>make -DNOPROFILE=true <replaceable>target</replaceable></userinput>
        </screen>

        <para>является другим способом указания того, что библиотеки для
          профилирования строить не нужно, и соответствует строкам</para>

        <programlisting>
NOPROFILE=    true
#    Avoid compiling profiled libraries
        </programlisting>

        <para>в файле <filename>/etc/make.conf</filename>.</para>

        <para><replaceable>target</replaceable> указывает программе
          &man.make.1; на то, что вы хотите сделать.  Каждый файл
          <filename>Makefile</filename> определяет некоторое количество
          различных <quote>целей</quote>, и ваш выбор цели определяет то, что
          будет делаться.</para>

        <para>Некоторые цели перечислены в файле
          <filename>Makefile</filename>, но вам не нужно их вызывать.  Просто
          они используются в процессе построения для разбиения шагов,
          необходимых для перестроения системы, на несколько
          под-шажков.</para>

        <para>В большинстве случаев вам не нужно передавать никаких
          параметров в &man.make.1;, так что ваша команда будет выглядеть
          примерно так:</para>

        <screen>
&prompt.root; <userinput>make <replaceable>target</replaceable></userinput>
        </screen>
      </sect3>

      <sect3>
        <title>Сохраните вывода</title>

        <para>Неплохо сохранить вывод, получаемый при работе программы
          &man.make.1;, в другой файл.  Если что-то идет не так, вы будете
          иметь копию сообщения об ошибке и полную картину того, где она
          произошла.  Хотя это может и не помочь в определении причин
          происходящего, это может помочь другим, если вы опишите вашу
          проблему в одном из списков рассылки FreeBSD.</para>

        <para>Проще всего это сделать при помощи команды &man.script.1; с
          параметром, в котором указано имя файла, в который нужно сохранить
          вывод.  Вы должны сделать это непосредственно перед тем, как
          перестроить систему, а по окончании процесса набрать
          <userinput>exit</userinput>.</para>

        <screen>
&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make world</userinput>
<emphasis>&hellip; compile, compile, compile &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;
        </screen>

        <para>Если вы делаете это, <emphasis>не</emphasis> сохраняйте
          вывод в <filename>/tmp</filename>.  Этот каталог может быть
          очищен при следующей перезагрузке.  Лучше сохранить его в
          <filename>/var/tmp</filename> (как в предыдущем примере) или в
          домашнем каталоге пользователя <username>root</username>.</para>
      </sect3>

      <sect3>
        <title>Версия 2.2.2 и ниже</title>

        <para><filename>/usr/src/Makefile</filename> содержит цель
          <maketarget>world</maketarget>, при выполнении которой система
          перестраивается и переустанавливается полностью.</para>

        <para>Используйте ее вот так:</para>

        <screen>&prompt.root; <userinput>make world</userinput></screen>
      </sect3>

      <sect3>
        <title>Версия 2.2.5 и выше</title>

        <para>Начиная с версии FreeBSD 2.2.5 (на самом деле впервые это было
          сделано в ветке -CURRENT, а затем адаптировано в -STABLE где-то
          между 2.2.2 и 2.2.5) цель <maketarget>world</maketarget> была
          разделена на две. <maketarget>buildworld</maketarget> и
          <maketarget>installworld</maketarget>.</para>

        <para>Как указывают на это названия,
          <maketarget>buildworld</maketarget> строит полностью новое дерево
          в каталоге <filename>/usr/obj</filename>, а
          <maketarget>installworld</maketarget> устанавливает это дерево на
          используемой машине.</para>

        <para>Это весьма полезно по двум причинам.  Во-первых, это позволяет
          вам безопасно строить систему, зная, что компоненты вашей
          рабочей системы затронуты не будут.  Построение
          <quote>самодостаточно</quote>.  По этой причине вы можете
          спокойно запустить <maketarget>buildworld</maketarget> на машине,
          работающей в многопользовательском режиме без признаков каких-либо
          проблем.  Но все же я рекомендую запускать цель
          <maketarget>installworld</maketarget> в однопользовательском
          режиме.</para>

        <para>Во-вторых, это позволяет вам использовать монтирование по
          NFS для обновления многих машин в сети.  Если у вас есть три
          машины, A, B и C, которые вы хотите обновить, запустите
          <command>make buildworld</command> и
          <command>make installworld</command> на машине A.  B и C должны
          затем смонтировать по NFS каталоги <filename>/usr/src</filename>
          и <filename>/usr/obj</filename> с машины A, а вы сможете запустить
          <command>make installworld</command> для установки результатов
          построения на машинах B и C.</para>

        <para>Цель <maketarget>world</maketarget> все еще существует, и вы
          можете использовать ее точно также, как это делается для версии
          2.2.2.  <command>make world</command> выполняет <command>make
          buildworld</command>, за которым следует <command>make
          installworld</command>.</para>

        <note>
          <para>Если вы выполняете команды <command>make buildworld</command>
            и <command>make installworld</command> раздельно, вы должны
            передавать команде &man.make.1; каждый раз одни и те же
            параметры.</para>

          <para>Если вы запускаете:</para>

          <screen>
&prompt.root; <userinput>make -DNOPROFILE=true buildworld</userinput>
          </screen>

          <para>вы должны установить полученный результат командой:</para>

          <screen>
&prompt.root; <userinput>make -DNOPROFILE=true installworld</userinput>
          </screen>

          <para>в противном случае будет делаться попытка установить
            библиотеки для профилирования, которые не строились во время
            выполнения фазы <command>make buildworld</command>.</para>
        </note>
      </sect3>

      <sect3>
        <title>-CURRENT и выше</title>

        <para>Если вы отслеживаете -CURRENT, вы можете также передать команде
          <command>make</command> параметр <option>-j</option>.  Это позволит
          команде <command>make</command> запустить несколько параллельных
          процессов.</para>

        <para>Лучше всего это делать на многопроцессорных машинах.  Однако
          из-за того, что большая часть процесса компиляции заключается во
          вводе/выводе, а не обработке, это также полезно и в случае
          однопроцессорных машин.</para>

        <para>На типичной машине с одним CPU вы должны запускать:</para>

        <screen>
&prompt.root; <userinput>make -j4 <replaceable>target</replaceable></userinput>
        </screen>

        <para>&man.make.1; будет иметь до 4 одновременно работающих
          процессов.  Эмпирические замеры, публикуемые в списках рассылки,
          показывают, что в среднем это дает наибольшее улучшение
          производительности.</para>

        <para>Если у вас многопроцессорная машина и вы используете ядро с
          настройками для SMP, попробуйте использовать значения между 6 и
          10 и посмотрите, как это отразится на скорости работы.</para>

        <para>Имейте в виду, что (на момент написания этого текста) это
          остается экспериментальной возможностью, и изменения в дереве
          исходных текстов иногда могут это портить.  Если система не
          может быть построена с использованием этого параметра, попробуйте
          еще раз без него перед тем, как сообщать о проблемах.</para>
      </sect3>

      <sect3>
        <title>Время на построение</title>

        <para>Полагая, что все проходит нормально, приготовьтесь подождать от
          полутора часов до суток и больше.</para>

        <para>Примите во внимание, что P6 с тактовой частотой 200МГц с более
          чем 32МБ ОЗУ и нормальными дисками SCSI выполняет команду
          <command>make world</command> примерно за полтора часа.  P133 с
          32МБ делает это за 5 или 6 часов.  Увеличьте эти числа, если
          ваша машина медленнее&hellip;</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Обновите файлы, не обновленные по команде
        <command>make world</command></title>

      <para>При перестроении системы не будут обновляться некоторые каталоги
        (в частности, <filename>/etc</filename>, <filename>/var</filename> и
        <filename>/usr</filename>) с новыми или измененными конфигурационными
        файлами.</para>

      <para>Самым простым способом обновить такие файлы является запуск
        утилиты &man.mergemaster.8;, хотя можно сделать это и вручную, если
        вам так нравится.  Однако мы настоятельно рекомендуем использовать
        &man.mergemaster.8;, и если вы это сделаете, то можете сразу перейти
        к <link linkend="update-dev">следующему разделу</link>, так как
        программа &man.mergemaster.8; весьма проста в использовании.  Сначала
        вы должны прочитать справочную страницу и сделать резервную копию
        <filename>/etc</filename> на случай, если что-то пойдет не
        так.</para>

      <para>Если вы хотите произвести обновление вручную, то вы не можете
        просто скопировать файлы из <filename>/usr/src/etc</filename> в
        <filename>/etc</filename> и получить работающую систему.  Некоторые
        из этих файлов сначала нужно <quote>установить</quote>.  Это нужно
        потому, что каталог <filename>/usr/src/etc</filename>
        <emphasis>не</emphasis> является копией того, что должен содержать
        ваш каталог <filename>/etc</filename>.  Кроме того, есть файлы,
        которые должны присутствовать в <filename>/etc</filename>, но которых
        нет в <filename>/usr/src/etc</filename>.</para>

      <para>Вручную проще всего сделать это, установив файлы в новый каталог,
        а затем пройтись по ним, отмечая разницу.</para>

      <warning>
        <title>Сделайте резервную копию вашего каталога
          <filename>/etc</filename></title>

        <para>Хотя, теоретически, автоматически этот каталог не трогается,
          всегда лучше чувствовать себя уверенно.  Так что скопируйте
          имеющийся каталог <filename>/etc</filename> в какое-нибудь
          безопасное место.  Нечто вроде:</para>

        <screen>
&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput>
        </screen>

        <para><option>-R</option> задает выполнение рекурсивного копирования,
          а <option>-p</option> сохраняет даты, владельца файлов и тому
          подобное.</para>
      </warning>

      <para>Вам нужно создать простенький набор каталогов для установки
        нового каталога <filename>/etc</filename> и других файлов.  Обычно я
        размещаю этот каталог в <filename>/var/tmp/root</filename>, и к тому
        же сюда требуется разместить некоторое количество
        подкаталогов.</para>

      <screen>
&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput>
      </screen>

      <para>Эти команды приведут к созданию нужной структуры каталогов и
        установке файлов.  Множество каталогов, созданных в каталоге
        <filename>/var/tmp/root</filename>, пусты и должны быть удалены.
        Проще всего сделать это так:</para>

      <screen>
&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput>
      </screen>

      <para>Эти команды удалят все пустые каталоги.  (Стандартный поток
        диагностических сообщений перенаправляется в
        <filename>/dev/null</filename> для исключения предупреждений о
        непустых каталогах.)</para>

      <para>Теперь <filename>/var/tmp/root</filename> содержит все файлы,
        которые должны быть помещены в соответствующие места в
        <filename>/</filename>.  Теперь пройдитесь по каждому их этих файлов
        и определите, чем они отличаются от имеющихся у вас файлов.</para>

      <para>Заметьте, что некоторые из файлов, которые были установлены в
        <filename>/var/tmp/root</filename>, имеют первым символом <quote/./.
        На момент написания единственными такими файлами являлись файлы
        начальных скриптов командных процессоров в
        <filename>/var/tmp/root/</filename> и
        <filename>/var/tmp/root/root/</filename>, хотя могут быть и другие
        (зависи от того, когда вы это читаете.  Пользуйтесь командой
        <command/ls -a/, чтобы выявить их.</para>

      <para>Проще всего сделать это при помощи команды &man.diff.1; для
        сравнения двух файлов.</para>

      <screen>
&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput>
      </screen>

      <para>По это команде будет показана разница между вашим файлом
        <filename>/etc/shells</filename> и новым файлом
        <filename>/etc/shells</filename>.  Используйте это для определения
        того, переносить ли сделанные вами изменения или скопировать поверх
        вашего старого файла.</para>

      <tip>
        <title>Называйте новый корневой каталог
          (<filename>/var/tmp/root</filename>) по дате, чтобы вы смогли легко
          выявить разницу между версиями</title>

        <para>Частое перестроение системы означает также и частое обновление
          <filename>/etc</filename>, которое может быть несколько
          обременительным.</para>

        <para>Вы можете ускорить этот процесс, сохраняя копию последнего
          набора измененных файлов, которые вы перенесли в
          <filename>/etc</filename>.  Следующая процедура подаст вам одну
          идею о том, как это сделать.</para>

        <procedure>
          <step>
            <para>Выполните перестроение системы обычным образом.  Когда вы
              вам потребуется обновить <filename>/etc</filename> и другие
              каталоги, дайте целевому каталогу имя на основе текущей даты.
              Если вы делаете это 14 февраля 1998 года, то вы можете сделать
              следующее.</para>

            <screen>
&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput>
            </screen>
          </step>

          <step>
            <para>Перенесите изменение из этого каталога, как это описано
              выше.</para>

            <para><emphasis>Не</emphasis> удаляйте каталог
              <filename>/var/tmp/root-19980214</filename> после окончания
              этого процесса.</para>
          </step>

          <step>
            <para>Когда вы сгрузите самую последнюю версию исходного кода и
              перестроите систему, выполните шаг 1.  Это даст вам новый
              каталог, который может называться
              <filename>/var/tmp/root-19980221</filename> (если вы ждете
              неделю между обновлениями).</para>
          </step>

          <step>
            <para>Теперь вы можете видеть изменения, которые были сделаны
              за прошедшую неделю, выполнив при помощи команды &man.diff.1;
              рекурсивное сравнение двух каталогов.</para>

            <screen>
&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput>
            </screen>

            <para>Как правило, здесь содержится гораздо меньше отличий, чем
              между каталогами
              <filename>/var/tmp/root-19980221/etc</filename> и
              <filename>/etc</filename>.  Так как отличий мешьше, то и легче
              перенести эти изменения в ваш каталог
              <filename>/etc</filename>.</para>
          </step>

          <step>
            <para>Теперь вы можете удалить более старый из двух каталогов
              <filename>/var/tmp/root-*</filename>.</para>

            <screen>
&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput>
            </screen>
          </step>

          <step>
            <para>Повторяйте этот процесс всякий раз, когда вам нужно
              перенести изменения в каталог <filename>/etc</filename>.</para>
          </step>
        </procedure>

        <para>Для автоматической генерации имен каталогов вы можете
          использовать команду &man.date.1;.</para>

        <screen>
&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput>
        </screen>
      </tip>
    </sect2>

    <sect2 id="update-dev">
      <title>Обновите <filename>/dev</filename></title>

      <note>
        <title>DEVFS</title>

        <para>Если вы используете DEVFS, то вам это, скорее всего, делать не
          нужно.</para>
      </note>

      <para>Для безопасности этот процесс делается в несколько шагов.</para>

      <procedure>
        <step>
          <para>Скопируйте <filename>/var/tmp/root/dev/MAKEDEV</filename> в
            <filename>/dev</filename>.</para>

          <screen>
&prompt.root; <userinput>cp /var/tmp/root/dev/MAKEDEV /dev</userinput>
          </screen>

          <para>Если вы использовали &man.mergemaster.8; для обновления
            <filename>/etc</filename>, то ваш скрипт
            <filename>MAKEDEV</filename> уже должен быть обновлен, так что
            его не нужно проверять (утилитой &man.diff.1;) и копировать
            вручную в случае необходимости.</para>
        </step>

        <step>
          <para>Теперь выведите текущее содержимое вашего каталога
            <filename>/dev</filename>.  Этот список должен содержать права,
            владельцев, старшее и младшее числа каждого файла, но не должен
            содержать информацию о времени.  Проще всего это сделать,
            отрезав при помощи &man.awk.1; часть информации.</para>

          <screen>
&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>ls -l | awk '{print $1, $2, $3, $4, $5, $6, $NF}' > /var/tmp/dev.out</userinput>
          </screen>
        </step>

        <step>
          <para>Повторно создайте все устройства.</para>

          <screen>&prompt.root; <userinput/sh MAKEDEV all/</screen>
        </step>

        <step>
          <para>Создайте еще один список содержимого каталога, на этот раз в
            <filename>/var/tmp/dev2.out</filename>.  Теперь просмотрите оба
            эти файла и поищите устройства, которые вы забыли создать.  Таких
            быть не должно, но лишний раз удостовериться не помешает.</para>

          <screen>
&prompt.root; <userinput>diff /var/tmp/dev.out /var/tmp/dev2.out</userinput>
          </screen>

          <para>Скорее всего, вы заметите разногласия в именовании дисковых
            слайсов, что решается такими командами, как

            <screen>
&prompt.root; <userinput>sh MAKEDEV sd0s1</userinput>
            </screen>

            для повторного создания устройств слайсов.  Точное название
            зависит от вашей системы и может отличаться от
            приведенного.</para>
        </step>
      </procedure>
    </sect2>

    <sect2>
      <title>Обновите <filename>/stand</filename></title>

      <note>
        <para>Этот шаг описан только для полноты.  Он может быть
          безболезненно пропущен.</para>
      </note>

      <para>В целях полноты обновления вам может потребоваться обновить также
        файлы в каталоге <filename>/stand</filename>.  Эти файлы представляют
        собой жесткие ссылки на выполнимый файл
        <filename>/stand/sysinstall</filename>.  Этот файл должен быть
        статически скомпонован, чтобы его работа не зависела от других
        файловых систем (в частности, от наличия смонтированной файловой
        системы <filename>/usr</filename>).</para>

      <screen>
&prompt.root; <userinput>cd /usr/src/release/sysinstall</userinput>
&prompt.root; <userinput>make all install</userinput>
      </screen>

      <note>
        <title>Исходные тексты, старее, чем 2 апреля 1998</title>

        <para>Если ваш исходный код старше, чем 2 апреля 1998 или версия
          файла <filename>Makefile</filename> не равна 1.68 и выше (для
          текущих версий FreeBSD и систем 3.X) или 1.48.2.21 и выше (для
          систем 2.2.X), вам нужно добавить параметр
          <userinput>NOSHARED=yes</userinput>, как здесь;</para>

        <screen>
&prompt.root; <userinput>make NOSHARED=yes all install</userinput>
        </screen>
      </note>
    </sect2>

    <sect2>
      <title>Откомпилируйте и установите новое ядро</title>

      <para>Чтобы получить полную отдачу от вашей новой системы, вы должны
        перекомпилировать ядро.  Это практически необходимость, так как
        отдельные структуры в памяти могут меняться, и программы типа
        &man.ps.1; и &man.top.1; не будут работать, пока версии ядра и
        исходных текстов системы не будут совпадать.</para>

      <para>Для компиляции нового ядра следуйте указаниям в Руководстве.
        Если ранее вы строили собственное ядро, то внимательно
        проанализируйте конфигурационный файл <filename>LINT</filename> на
        предмет наличия новых параметров, которые вы должны
        использовать.</para>

      <para>В предыдущем варианте этого документа советуется выполнить
        перезагрузку перед тем, как перестраивать ядро.  Это неправильно,
        потому что:</para>

      <itemizedlist>
        <listitem>
          <para>Такие команды, как &man.ps.1;, &man.ifconfig.8; и
            &man.sysctl.8; могут отказаться работать.  Это может привести к
            невозможности подключиться к сети.</para>
        </listitem>

        <listitem>
          <para>Могут не работать основные утилиты, такие, как &man.mount.8;,
            приводя к невозможности монтирования <filename>/</filename>,
            <filename>/usr</filename> и так далее.  Скорее всего, этого не
            случится, если вы отслеживате кандидата на -STABLE, но весьма
            вероятно при отслеживании -CURRENT во время большого
            изменения.</para>
        </listitem>

        <listitem>
          <para>Загружаемые модули ядра (LKM на системах до 3.X, KLD в
            системах 3.X и выше) строящиеся как часть
            <quote>окружения</quote>, могут привести к сбою в работе старого
            ядра.</para>
        </listitem>
      </itemizedlist>

      <para>По этим причинам всегда лучше перестроить и установить новое ядро
        до перезагрузки.</para>

      <para>Вы должны строить свое новое ядро после того, как завершили
        процесс <userinput>make world</userinput> (или <userinput>make
        installworld</userinput>).  Если вы не хотите этого делать (может
        быть, вы хотите убедиться в построении ядра до обновления вашей
        системы), то у вас могут возникнуть проблемы.  Это может происходить
        из-за того, что ваша команда &man.config.8; старее, чем исходные
        тексты ядра.</para>

      <para>В этом случае вы можете построить ваше ядро с новой версией
        &man.config.8;</para>

      <screen>
&prompt.root; <userinput>/usr/obj/usr/src/usr.sbin/config/config <replaceable>KERNELNAME</replaceable></userinput>
      </screen>

      <para>Во всех случаях это может и не работать.  Рекомендуется, чтобы
        вы закончили выполнение команд <userinput>make world</userinput> (или
        <userinput>make installworld</userinput>) до компиляции нового
        ядра.</para>
    </sect2>

    <sect2>
      <title/Перезагрузка/

      <para>Теперь вы сделали все.  После того, как вы проверили, что все
        на месте, можете перегрузить систему.  Простая команда
        &man.fastboot.8; должна это сделать.</para>

      <screen>&prompt.root; <userinput>fastboot</userinput></screen>
    </sect2>

    <sect2>
      <title>Завершение</title>

      <para>Вы должны иметь успешно обновленную систему FreeBSD.
        Поздравляем.</para>

      <para>Вы можете заметить некоторые проблемы из-за того, что вы что-то
        забыли.  Например, однажды я удалил <filename>/etc/magic</filename>
        в процессе обновления, перенес это в <filename>/etc</filename>, и
        команда <command>file</command> перестала работать.  В результате
        недолгих размышлений оказалось, что команды

        <screen>
&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput/make all install/
        </screen>

        достаточно для исправления этой ситуации.</para>
    </sect2>

    <sect2>
      <title/Вопросы?/

      <qandaset>
        <qandaentry>
          <question>
            <para>Нужно ли полностью перестраивать систему при каждом
              изменении?</para>
          </question>

          <answer>
            <para>Простого ответа на этот вопрос нет, так как это зависит от
              характера изменения.  Например, я только что запустил CVSup, и
              он выдал, что с момента последнего его запуска были изменены
              следующие файлы;</para>

            <screen>
<filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename>
            </screen>

            <para>Здесь нет ничего, ради чего нужно перестраивать систему.
              Я перейду в соответствующие подкаталоги и выдам команду
              <command>make all install</command>, и этого достаточно.
              Однако, если меняется что-то важное, например,
              <filename>src/lib/libc/stdlib</filename>, то перестрою всю
              систему или по крайней мере те ее части, которые скомпонованы
              статически (а также все остальное, что добавлял я и что
              статически скомпоновано).</para>

            <para>В конце концов, выбор за вами.  Вам может быть достаточно
              перестраивать систему, скажем, каждый вечер, а изменения
              скачивать ночью.  Или вы можете захотеть перестраивать только
              те вещи, которые менялись, и проверять, что вы отследили все
              изменения.</para>

            <para>И, конечно же, это все зависит от того, как часто вы хотите
              делать обновление, и отслеживаете ли вы -STABLE или
              -CURRENT.</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>Компиляция прерывается с большим количеством ошибок по
              сигналу 11 (или с другим номером сигнала).  Что
              случилось?</para>
          </question>

          <answer>
            <para>Как правило, это говорит о проблемах с оборудованием.
              (Пере)построение системы является эффективным стресс-тестом для
              вашего оборудования и частенько выявляет проблемы с памятью.
              Обычно это проявляется в виде неожиданных сбоев компилятора
              или получения странных программных сигналов.</para>

            <para>Явным указателем на это является то, что при перезапуске
              процедуры построения она прекращается в различные моменты
              времени.</para>

            <para>В этом случае вы мало что можете сделать, разве что
              попробовать заменить комплектующие вашей машины для определения
              сбоящей компоненты.</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>Могу ли я удалить каталог <filename>/usr/obj</filename>
              после окончания?</para>
          </question>

          <answer>
            <para>Это зависит от того, как вы хотите выполнять построение
              системы в будущем.</para>

            <para>Каталог <filename>/usr/obj</filename> содержит все
              объектные файлы, которые создаются во время фазы компиляции.
              Обычно одним из первых шагов в процессе <quote/make world/
              является удаление этого каталога и начало с нуля.  В этом
              случае сохранение <filename>/usr/obj</filename> после окончания
              имеет мало смысла, и будет занимать большой объем дискового
              пространства (на данный момент около 150МБ).</para>

            <para>Однако если вы знаете, что делаете, то можете заставить
              процедуру <quote/make world/ пропустить этот шаг.  Это позволит
              последующие построения выполняться гораздо быстрее, так как
              большинство исходных текстов не нужно будет перекомпилировать.
              Оборотной стороной медали этого подхода является вероятность
              появления некоторых проблем с зависимостями, что может привести
              к прерыванию построения по странным причинам.  Это частенько
              вызывает шум в списках рассылки FreeBSD, когда кто-либо
              жалуется на прерывание процесса построения, не обращая
              внимания на то, что он пытается срезать углы на
              повороте.</para>

            <para>Если вы хотите так поступать, то выполняйте построение,
              задавая переменную <makevar>NOCLEAN</makevar> утилите make,
              как это сделано здесь:</para>

            <screen>
&prompt.root; <userinput>make -DNOCLEAN world</userinput>
            </screen>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>Могут ли быть продолжены прерванные процессы
              построения?</para>
          </question>

          <answer>
            <para>Это зависит от того, насколько далеко зашел процесс
              построения перед тем, как вы обнаружили проблему.</para>

            <para><emphasis>В общем случае</emphasis> (и это не сложное и
              быстрое правило) процесс <quote>make world</quote> строит
              новые копии необходимых инструментальных средств (таких, как
              &man.gcc.1; и &man.make.1;>) и системные библиотеки.  Затем эти
              средства и библиотеки устанавливаются.  Новые инструментальные
              средства и библиотеки затем используются для перестроения
              самих себя, и повторно устанавливаются.  Система в целом
              (теперь включая обычные пользовательские программы, такие,
              как &man.ls.1; или &man.grep.1;) теперь перестраивается с
              новыми системными файлами.</para>

            <para>Если вы на последнем шаге, и вы знаете это (потому что
              просматривали вывод, который сохраняете), то вы можете
              (достаточно безболезненно) выполнить команду</para>

            <screen>
<emphasis>&hellip; исправление проблемы &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNOCLEAN all</userinput>
            </screen>

            <para>При этом результат предыдущего запуска
              <quote>make world</quote> откатываться не будет.</para>

            <para>Если вы видите сообщение

            <screen>
--------------------------------------------------------------
Building everything..
--------------------------------------------------------------
            </screen>

              в выводе команды <quote>make world</quote>, то делать так
              достаточно безопасно.</para>

            <para>Если этого сообщения не было, или вы в этом не уверены, то
              всегда лучше обезопасить себя, и начать построение с самого
              начала.</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>Могу ли я использовать одну машину как <emphasis/главную/
              для обновления множества машин (NFS)?</para>
          </question>

          <answer>
            <para>В списках рассылки FreeBSD часто задается вопрос о том,
              можно ли выполнять всю компиляцию на одной машине, а затем
              использовать результаты этой компиляции для выполнения команды
              <command>make install</command> на других машинах в
              сети.</para>

            <para>Я этого не делал, так что рекомендации ниже исходят от
              других людей или вытекают из логики работы make-файлов.</para>

            <para>Точные инструкции зависят от вашей версии FreeBSD</para>

            <para>Вы все же должны будете обновить <filename>/etc</filename>
              и <filename>/dev</filename> на целевых машинах после выполнения
              этих рекомендаций.</para>

            <para>Для 2.1.7 и ниже, Antonio Bemfica рекомендует такую
              последовательность действий:</para>

            <screen>
Date: Thu, 20 Feb 1997 14:05:01 -0400 (AST)
From: Antonio Bemfica &lt;bemfica@militzer.me.tuns.ca&gt;
To: freebsd-questions@FreeBSD.org
Message-ID: &lt;Pine.BSI.3.94.970220135725.245C-100000@militzer.me.tuns.ca&gt;

Josef Karthauser спрашивал:

&gt; У кого-нибудь есть хороший метод обновления машин в сети

Во-первых, выполните процедуры make world и так далее на вашей главной машине

Во-вторых, смонтируйте / и /usr с удаленной машины:

main_machine% mount remote_machine:/   /mnt
main_machine% mount remote_machine:/usr /mnt/usr

В-третьих, выполните 'make install' с целевым каталогом /mnt:

main_machine% make install DESTDIR=/mnt

Повторите это для каждой удаленной машины в вашей сети.  У меня это
работает прекрасно.

Antonio
            </screen>

            <para>Этот механизм будет работать, если только (насколько я
              знаю) вы имеете право на запись в каталог
              <filename>/usr/src</filename> сервера NFS, так как цель
              <maketarget>install</maketarget> в 2.1.7 и ниже этого
              требует.</para>

            <para>Между 2.1.7 и 2.2.0 появилась цель
              <quote>reinstall</quote>.  Вы можете действовать точно также,
              как это было описано для 2.1.7, но вместо
              <quote>install</quote> использовать
              <quote>reinstall</quote>.</para>

            <para>Эта схема <emphasis>не</emphasis> требует доступа с правом
              на запись к каталогу <filename>/usr/src</filename> на сервере
              NFS.</para>

            <para>Между версиями 1.68 и 1.107 файла Makefile в этой цели
              присутствовала ошибка, которая приводила к тому, что доступ с
              правом записи к NFS-серверу все же
              <emphasis>требовался</emphasis>.  Эта ошибка была исправлена
              до выхода FreeBSD версии 2.2.0, но может быть причиной ошибок,
              если у вас старый сервер, на котором работает -STABLE с тех
              времен.</para>

            <para>Для версий 2.2.5 и выше вы можете воспользоваться целями
              <quote>buildworld</quote> и <quote>installworld</quote>.
              Используйте их для построения дерева исходных текстов на одной
              машине, затем смонтируйте по NFS <filename>/usr/src</filename>
              и <filename>/usr/obj</filename> на удаленной машине и
              устанавливайте все здесь.</para>
          </answer>
        </qandaentry>

        <qandaentry>
          <question>
            <para>Как ускорить процесс построения системы?</para>

            <itemizedlist>
              <listitem>
                <para>Работайте в однопользовательском режиме.</para>
              </listitem>

              <listitem>
                <para>Разместите каталоги <filename>/usr/src</filename> и
                  <filename>/usr/obj</filename> в отдельных файловых
                  системах, располагающихся на разных дисках.  Если это
                  возможно, то разместите эти диски на разных дисковых
                  контролерах.</para>
              </listitem>

              <listitem>
                <para>Еще лучше разместить эти файловые системы на нескольких
                  отдельных дисках при помощи устройства <quote>ccd</quote>
                  (драйвер объединенных дисков).</para>
              </listitem>

              <listitem>
                <para>Выключите генерацию профилирующего кода (установив
                  <quote>NOPROFILE=true</quote> в файле
                  <filename>/etc/make.conf</filename>).  Вам это практически
                  никогда не нужно.</para>
              </listitem>

              <listitem>
                <para>Также в <filename>/etc/make.conf</filename> установите
                  значение <quote>CFLAGS</quote> во что-то типа <quote>-O
                  -pipe</quote>.  Оптимизация <quote>-O2</quote> выполняется
                  гораздо медленнее, а разница между <quote>-O</quote> и
                  <quote>-O2</quote> обычно несущественна.
                  <quote>-pipe</quote> позволяет компилятору использовать для
                  связи вместо временных файлов программные каналы, что
                  уменьшает обращение к диску (за счет оперативной
                  памяти).</para>
              </listitem>

              <listitem>
                <para>Передайте утилите make параметры
                  <option>-j&lt;n&gt;</option> (если вы работаете с
                  достаточно свежей версией FreeBSD) для запуска параллельно
                  нескольких процессов.  Это поможет вне зависимости от того,
                  сколько процессоров установлено в вашей машине.</para>
              </listitem>

              <listitem>
                <para>Файловая система, на которой располагается каталог
                  <filename>/usr/src</filename>, может быть смонтирована (или
                  перемонтирована) с опцией <quote>noatime</quote>.  Это
                  отключит запись на диск информации о времени последнего
                  доступа к файлам.  Скорее всего, вам эта информация и
                  не нужна.

                  <note>
                    <para><quote>noatime</quote> есть в версии 2.2.0 и
                      выше.</para>
                  </note>

                  <screen>
&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput>
                  </screen>

                  <warning>
                    <para>В примере предполагается, что
                      <filename>/usr/src</filename> располагается на
                      собственной файловой системе.  Если это не так (то
                      есть он является частью, скажем,
                      <filename>/usr</filename>), то вам нужно использовать
                      точку монтирования той файловой системы, а не
                      <filename>/usr/src</filename>.</para>
                  </warning>
                </para>
              </listitem>

              <listitem>
                <para>Файловая система, на которой располагается
                  <filename>/usr/obj</filename>, может быть смонтирована (или
                  перемонтирована) с опцией <quote>async</quote>.  Это
                  приведет к тому, что операции записи на диск будут
                  выполняться асинхронно.  Другими словами, запись будет
                  завершаться немедленно, а данные записываться на диск
                  несколькими секундами позже.  Это позволит объединять
                  операции записи и приведет к значительному приросту
                  производительности.</para>

                <warning>
                  <para>Имейте в виду, что эта опция делает вашу файловую
                    систему менее устойчивой.  С этой опцией имеется больше
                    шансов, что при перезагрузке машины после неожиданного
                    сбоя при пропадании напряжения файловая система окажется
                    в невосстановимом состоянии.</para>

                  <para>Если каталог <filename>/usr/obj</filename> - это все,
                    что есть в этой фаловой системе, то это не проблема.
                    Если на той же самой файловой системе имеются какие-то
                    еще важные данные, то проверьте давность ваших резервных
                    копий перед включением этой опции.</para>
                </warning>

                <screen>
&prompt.root; <userinput>mount -u -o async /usr/obj</userinput>
                </screen>

                <warning>
                  <para>Как и раньше, если каталог
                    <filename>/usr/obj</filename> располагается не на
                    собственной файловой системе, то в примере замените его
                    на имя соответствующей точки монтирования.</para>
                </warning>
              </listitem>
            </itemizedlist>
          </question>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

