<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/advanced-networking/chapter.sgml,v 1.5 2000/10/15 13:40:28 andy Exp $
     Original revision: 1.29
-->

<chapter id="advanced-networking">
  <title>Сложные вопросы работы в сети</title>

  <sect1>
    <title>Краткий обзор</title>

    <para>Последующая глава посвящена некоторым более часто используемым
      сетевым службам UNIX-систем.  Это, конечно же, будет касаться настройки
      указанных служб в Вашей системе FreeBSD.</para>
  </sect1>

<sect1 id="routing">
  <title>Сетевые шлюзы и маршруты</title>

  <para><emphasis>Предоставил &a.gryphon;. 6 октября 1995.</emphasis></para>

  <para>Чтобы некоторая машина могла найти другую, должен иметься механизм
    описания того, как добраться от одной машине к другой.  Такой механизм
    называется маршрутизацией.	<quote>Маршрут</quote> задается парой
    адресов: <quote>адресом назначения</quote> (destination) и
    <quote>сетевым шлюзом</quote> (gateway).  Эта пара означает, что, если
    Вы пытаетесь соединиться с <emphasis>адресом назначения</emphasis>, то
    вам нужно будет пройти через <quote>сетевой шлюз</quote>.  Существует
    три типа адресов назначения: отдельные хосты, подсети и
    <quote>маршрут по умолчанию</quote> (default).  <quote>Маршрут по
    умолчанию</quote> (default route) используется, если не подходит ни один
    из других маршрутов.  Мы поговорим немного подробнее о маршрутах по
    умолчанию позже.  Также имеется и три типа сетевых шлюзов: отдельные
    хосты, интерфейсы (также называемые <quote>подключениями</quote>
    (links)) и аппаратные адреса ethernet.</para>

  <sect2>
    <title>Пример</title>

    <para>Для иллюстрации различных аспектов маршрутизации мы будем
      использовать следующий пример, который является результатом работы
      команды <command>netstat -r</command>:</para>

    <screen>
Destination	 Gateway	    Flags     Refs     Use     Netif Expire

default 	 outside-gw	    UGSc       37      418	ppp0
localhost	 localhost	    UH		0      181	 lo0
test0		 0:e0:b5:36:cf:4f   UHLW	5    63288	 ed0	 77
10.20.30.255	 link#1 	    UHLW	1     2421
foobar.com	 link#1 	    UC		0	 0
host1		 0:e0:a8:37:8:1e    UHLW	3     4601	 lo0
host2		 0:e0:a8:37:8:1e    UHLW	0	 5	 lo0 =>
host2.foobar.com link#1 	    UC		0	 0
224		 link#1 	    UC		0	 0
    </screen>

    <para>В первых двух строках фигурируют маршрут по умолчанию (который
      будет описан в следующем разделе) и маршрут на
      <hostid>localhost</hostid>.</para>

    <para>Интерфейс (колонка <literal>Netif</literal>), который будет
      использоваться для <literal>localhost</literal>, и который назван
      <devicename>lo0</devicename>, имеет также второе название, устройство
      loopback.  Это значит сохранение всего трафика для указанного адреса
      назначения внутри, без посылки его по сети, так как он все равно
      будет направлен туда, откуда был создан.</para>

    <para>Следующими выделяющимися адресами являются строчки <hostid
      role="mac">0:e0:...</hostid>.   Это аппаратные адреса ethernet.
      FreeBSD будет автоматически распознавать любой хост (в нашем
      примере это <hostid>test0</hostid>) в локальной сети ethernet и
      добавит маршрут для этого хоста, указывающий непосредственно на
      интерфейс ethernet, <devicename>ed0</devicename>.  С этим типом
      маршрута также связан параметр таймаута (колонка
      <literal>Expire</literal>), используемый в случае неудачной попытки
      услышать этот хост в течении некоторого периода времени.	В таком
      случае маршрут будет автоматически удален.  Такие хосты поддерживаются
      при помощи механизма, известного как RIP (Routing Information
      Protocol), который вычисляет маршруты к хостам локальной сети при
      помощи определения кратчайшего расстояния.</para>

    <para>FreeBSD добавит также все маршруты к подсетям для локальных
      подсетей (<hostid role="ipaddr">10.20.30.255</hostid> является
      широковещательным адресом для подсети <hostid
      role="ipaddr">10.20.30</hostid>, а имя <hostid
      role="domainname">foobar.com</hostid> является именем домена, связанным
      с этой подсетью).  Назначение <literal>link#1</literal> соответствует
      первому сетевому адаптеру в машине.  Отметьте отсутствие
      дополнительного интерфейса для этих строк.</para>

    <para>В обеих этих группах (хосты и подсети локальной сети) маршруты
      конфигурируются автоматически даемоном, который называется
      <command>routed</command>.  Если он не запущен, то будут существовать
      только статически заданные (то есть введенные явно) маршруты.</para>

    <para>Строка <literal>host1</literal> относится к нашему хосту, который
      известен по адресу ethernet.  Так как мы являемся посылающим хостом,
      FreeBSD знает, что нужно использовать loopback-интерфейс
      (<devicename>lo0</devicename>) вместо того, чтобы осуществлять
      посылку в интерфейс ethernet.</para>

    <para>Две строки <literal>host2</literal> являются примером того, что
      происходит при использовании алиасов в команде ifconfig (обратитесь
      к разделу об ethernet для объяснения того, почему мы это делаем).
      Символ <literal>=&gt;</literal> после интерфейса
      <devicename>lo0</devicename> указывает на то, что мы используем не
      просто интерфейс loopback (так как это адрес, обозначающий локальный
      хост), но к тому же это алиас.  Такие маршруты появляются только
      на хосте, поддерживающем алиасы; для всех остальных хостов в локальной
      сети в таких случаях будут показаны просто строчки
      <literal>link#1</literal>.</para>

    <para>Последняя строчка (подсеть назначения <literal>224</literal>)
      имеет отношение к многоадресной посылке, которая будет рассмотрена в
      другом разделе.</para>

    <para>Другим столбцом, о котором стоит сказать, является
      <literal>Flags</literal>.  Каждый маршрут имеет различные атрибуты,
      которые перечислены в этой колонке.  Ниже приведена краткая таблица
      значений некоторых этих флагов и их значений:</para>

    <informaltable frame="none">
    <tgroup cols="2">
    <tbody>
      <row>
	<entry>U</entry>
	<entry>Up: Маршрут актуален.</entry>
      </row>

      <row>
	<entry>H</entry>
	<entry>Host: Адресом назначения является отдельный хост.</entry>
      </row>

      <row>
	<entry>G</entry>
	<entry>Gateway: Посылать все для этого адреса назначения на указанную
	  удаленную систему, которая будет сама определять дальнейший путь
	  прохождения информации.</entry>
      </row>

      <row>
	<entry>S</entry>
	<entry>Static: Маршрут был настроен вручную, а не автоматически
	  сгенерирован системой.</entry>
      </row>

      <row>
	<entry>C</entry>
	<entry>Clone: Новый маршрут сгенерирован на основе указанного для
	  машин, к которым мы подключены.  Такой тип маршрута обычно
	  используется для локальных сетей.</entry>
      </row>

      <row>
	<entry>W</entry>
	<entry>WasCloned: Указывает на то, что маршрут был автоматически
	  сконфигурирован на основе маршрута в локальной
	  сети (Clone).</entry>
      </row>

      <row>
	<entry>L</entry>
	<entry>Link: Маршрут включает ссылку на аппаратный адрес
	  ethernet.</entry>
      </row>
    </tbody>
    </tgroup>
    </informaltable>
  </sect2>

  <sect2>
    <title>Маршруты по умолчанию</title>

    <para>Когда локальной системе нужно установить соединение с удаленным
      хостом, она обращается к таблице маршрутов для того, чтобы определить,
      существует ли такой маршрут.  Если удаленный хост попадает в подсеть,
      для которой известен способ ее достижения (маршруты типа Cloned), то
      система определяет возможность подключиться к ней по этому
      интерфейсу.</para>

    <para>Если все известные маршруты не подходят, у системы имеется
      последняя возможность: маршрут <quote>default</quote>.  Это маршрут
      с особым типом сетевого шлюза (обычно единственным, присутствующим
      в системе), и в поле флагов он всегда помечен как <literal>c</literal>.
      Для хостов в локальной сети этот сетевой шлюз указывает на машину,
      имеющую прямое подключение к внешнему миру (неважно, используется ли
      связь по протоколу PPP или устройство, подключенное к выделенной
      линии).</para>

    <para>Если вы настраиваете маршрут по умолчанию на машине, которая сама
      является сетевым шлюзом во внешний мир, то маршрутом по умолчанию
      будет являться сетевой шлюз у Вашего провайдера Интернет (ISP).</para>

    <para>Давайте взглянем на примеры маршрутов по умолчанию.  Вот типичная
      конфигурация:</para>

    <literallayout>
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
    </literallayout>

    <para>Хосты <hostid>Local1</hostid> и <hostid>Local2</hostid> находятся в
      нашей сети, первый хост служит для подключения по протоколу PPP к
      серверу доступа вашего ISP.  У Вашего провайдера имеется локальная
      сеть, в которой, кроме всего прочего, находится сервер, к которому вы
      подключены, и аппаратура (T1-GW) обеспечивающая собственное подключение
      провайдера к Интернет.</para>

    <para>Маршруты по умолчанию для каждой из ваших машин будут
      следующими:</para>

    <informaltable frame="none">
    <tgroup cols="3">
    <thead>
      <row>
	<entry>хост</entry>
	<entry>маршрут по умолчанию</entry>
	<entry>интерфейс</entry>
      </row>
    </thead>

    <tbody>
      <row>
	<entry>Local2</entry>
	<entry>Local1</entry>
	<entry>ethernet</entry>
      </row>

      <row>
	<entry>Local1</entry>
	<entry>T1-GW</entry>
	<entry>PPP</entry>
      </row>
    </tbody>
    </tgroup>
    </informaltable>

    <para>Часто задается вопрос <quote>Почему (или каким образом) в качестве
      шлюза по умолчанию для машины Local1 мы указываем T1-GW, а не сервер
      провайдера, к которому подключаемся?</quote>.</para>

    <para>Запомните, что из-за использования PPP-интерфейсом адреса в сети
      провайдера Интернет с вашей стороны соединения, маршруты для всех
      других машин в локальной сети провайдера будут сгенерированы
      автоматически.  Таким образом, вы уже будете знать, как достичь машины
      T1-GW, так что нет нужды в промежуточной точке при посылке трафика к
      серверу ISP.</para>

    <para>И напоследок отметим, что в локальной сети адрес <hostid
      role="ipaddr">...1</hostid> часто используется в качестве адреса
      сетевого шлюза.  Тогда (при использовании того же самого примера)
      если пространство адресов класса C вашей локальной сети было задано
      как <hostid role="ipaddr">10.20.30</hostid>, а ваш провайдер использует
      <hostid role="ipaddr">10.9.9</hostid>, то маршруты по умолчанию будут
      такие:</para>

    <literallayout>
Local2 (10.20.30.2)		--&gt;	Local1 (10.20.30.1)
Local1 (10.20.30.1, 10.9.9.30)	--&gt;	T1-GW (10.9.9.1)
    </literallayout>
  </sect2>

  <sect2>
    <title>Хосты с двойным подключением</title>

    <para>Есть еще один тип подключения, который мы должны рассмотреть, и
      это случай, когда хост находится в двух различных сетях.	Технически,
      любая машина, работающая как сетевой шлюз (в примере выше
      использовалось PPP-соединение), считается хостом с двойным
      подключением.  Однако этот термин реально используется для описания
      машины, находящейся в двух локальных сетях.</para>

    <para>В одном случае у машины имеется два адаптера ethernet, каждый
      имеющий адрес в разделенных подсетях.  Как альтернативу можно
      рассмотреть вариант с одним ethernet-адаптером и использованием
      алиасов в команде ifconfig.  В первом случае используются два физически
      разделенных сети ethernet, в последнем имеется один физический сегмент
      сети, но две логически разделенных подсети.</para>

    <para>В любом случае таблицы маршрутизации настраиваются так, что для
      каждой подсети эта машина определена как шлюз (входной маршрут) в
      другую подсеть.  Такая конфигурация, при которой машина выступает в
      роли моста между двумя подсетями, часто используется, если нужно
      реализовать систему безопасности на основе фильтрации пакетов или
      функций межсетевого экрана в одном или обоих направлениях.</para>
  </sect2>

  <sect2>
    <title>Распространение маршрутов</title>

    <para>Мы уже говорили о том, как мы задаем наши маршруты во внешний мир,
      но не упоминали о том, как внешний мир находит нас.</para>

    <para>Мы уже знаем, что таблицы маршрутизации могут быть настроены так,
      что весь трафик для некоторого диапазона адресов (в нашем примере это
      подсеть класса C) может быть направлен заданному хосту в той сети,
      которая будет перенаправлять входящие пакеты дальше.</para>

    <para>При получении адресного пространства, выделенного Вашей сети,
      Ваш провайдер настроит свои таблицы маршрутизации так, что весь трафик
      для Вашей подсети будет пересылаться по PPP-соединению к Вашей сети.
      Но как серверы по всей стране узнают, что Ваш трафик нужно посылать
      Вашему ISP?</para>

    <para>Существует система (подобная распределению информации DNS), которая
      отслеживает все назначенные пространства адресов и определяет точку
      подключения к магистрали Интернет.  <quote>Магистралью</quote> называют
      главные каналы, по которым идет трафик Интернет внутри страны и по
      всему миру.  Каждая магистральная машина имеет копию основного набора
      таблиц, согласно которой трафик для конкретной сети направляется по
      конкретному магистральному каналу, и затем, передаваясь по цепочке
      провайдеров, он достигает вашей сети.</para>

    <para>Задачей вашего провайдера является объявить на магистрали о том,
      что он отвечает за подключение (и поэтому на него указывает маршрут)
      вашей сети.  Этот процесс называется распространением маршрута.</para>
  </sect2>

  <sect2>
    <title>Устранение неполадок</title>

    <para>Иногда с распространением маршрута возникают проблемы, и некоторые
      сайты не могут к вам подключиться.  Наверное, самой полезной командой
      для определения точки неверной работы маршрутизации является
      &man.traceroute.8;.  Она также полезна и когда вы сами не можете
      подключиться к удаленной машине (то есть команда &man.ping.8; не
      срабатывает).</para>

    <para>Команда &man.traceroute.8; запускается с именем удаленного хоста, с
      которым вы хотите установить соединение, в качестве параметра.  Она
      показывает промежуточные сетевые шлюзы по пути следования, в конце
      концов достигая адрес назначения или прерывая свою работу из-за
      отсутствия соединения.</para>

    <para>За дополнительной информацией обратитесь к странице Справочника по
      &man.traceroute.8;.</para>
  </sect2>
</sect1>

<sect1 id="bridging">
  <title>Мосты</title>

  <para><emphasis>Написано Стивом Питерсоном (Steve Peterson)
    <email>steve@zpfe.com</email></emphasis>.</para>

  <sect2>
    <title>Введение</title>

    <para>Иногда полезно разделить одну физическую сеть (другими словами,
      сегмент Ethernet) на два отдельных сегмента сети без необходимости
      создания подсетей IP и использования маршрутизатора для соединения
      сегментов.  Устройство, которое соединяет две сети на такой манер,
      называется мостом, а система FreeBSD с двумя сетевыми адаптерами
      может выступать в роли моста.</para>

    <para>Мост работает на основе изучения адресов уровня MAC (то есть
      адресов Ethernet) устройств на каждом своем сетевом интерфейсе.
      Он перенаправляет трафик между двумя сетями, только когда адреса
      отправителя и получателя находятся в разных сетях.</para>

    <para>По многим параметрам мост работает также, как коммутатор Ethernet
      с малым количеством портов.</para>
  </sect2>

  <sect2>
    <title>Ситуации, когда можно использовать мосты</title>

    <para>На сегодняшний день есть две ситуации, когда можно использовать
      мост.</para>

    <sect3>
      <title>Большой трафик в сегменте</title>

      <para>Первая ситуация возникает, когда ваша физическая сеть перегружена
	трафиком, но по каким-то соображениям вы не хотите разделять сеть
	на подсети и соединять их с помощью маршрутизатора.</para>

      <para>Давайте рассмотрим в качестве примера газету, в которой
	редакторский и производственный отделы находятся в одной и той же
	подсети.  Пользователи в редакторском отделе все используют сервер A
	для служб доступа к файлам, а пользователи производственного отдела
	используют сервер B.  Для объединения всех пользователей используется
	Ethernet, а высокая нагрузка на сеть замедляет работу.</para>

      <para>Если пользователи редакторского отдела могут быть собраны в
	одном сегменте сети, а пользователи производственного отдела в
	другом, то два сетевых сегмента можно объединить мостом.  Только
	сетевой трафик, предназначенный для интерфейсов с "другой" стороны
	моста, будет посылаться в другую сеть, тем самым снижая уровень
	нагрузки на каждый сегмент сети.</para>
    </sect3>

    <sect3>
      <title>Межсетевой экран с возможностями фильтрации/ограничения
	пропускной способности трафика</title>

      <para>Второй распространенной ситуацией является необходимость в
	обеспечении функций межсетевого экрана без трансляции
	IP-адресов (NAT).</para>

      <para>Для примера можно взять маленькую компанию, которая подключена
	к своему провайдеру по каналу DSL или ISDN.  Для нее провайдер
	выделил 13 IP-адресов для имеющихся в сети 10 персональных
	компьютеров.  В такой ситуации использование межсетевого экрана
	на основе маршрутизатора затруднено из=а проблем с разделением на
	подсети.</para>

      <para>Межсетевой экран на основе моста может быть настроен и включен
	между маршрутизаторами DSL/ISDN без каких-либо проблем с
	IP-адресацией.</para>
    </sect3>
  </sect2>

  <sect2>
    <title>Настройка моста</title>

    <sect3>
      <title>Выбор сетевого адаптера</title>

      <para>Для работы моста требуются по крайней мере два сетевых адаптера.
	К сожалению, не все сетевые адаптеры во FreeBSD 4.0 поддерживают
	функции моста.	Прочтите страницу Справочника по &man.bridge.4; для
	выяснения подробностей о поддерживаемых адаптерах.</para>

      <para>Перед тем, как продолжить, сначала установите и протестируйте
	два сетевых адаптера.</para>
    </sect3>

    <sect3>
      <title>Изменения в конфигурации ядра</title>

      <para>Для включения поддержки функций моста в ядре, добавьте
	строчку</para>

      <programlisting>options BRIDGE</programlisting>

      <para>в файл конфигурации вашего ядра, и перестройте ядро.</para>
    </sect3>

    <sect3>
      <title>Поддержка функций межсетевого экрана</title>

      <para>Если вы планируете использовать мост в качестве межсетевого
	экрана, вам нужно также добавить опцию IPFIREWALL.  Прочтите раздел
	<xref linkend="firewalls">, содержащий общую информацию о настройке
	моста в качестве межсетевого экрана.</para>

      <para>Если вам необходимо обеспечить прохождение не-IP пакетов (таких,
	как ARP) через мост, то имеется недокументированная опция межсетевого
	экрана, которую можно задать.  Это опция
	<literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal>.  Заметьте, что при
	этом правило, используемое межсетевым экраном по умолчанию, меняется
	на разрешительное для всех пакетов.  Перед тем, как задавать эту
	опцию, убедитесь, что вы понимаете работу вашего набора
	правил.</para>
    </sect3>

    <sect3>
      <title>Поддержка функций ограничения пропускной способности</title>

      <para>Если вы хотите использовать мост в качестве машины,
	ограничивающей пропускную способность, то добавьте в файл
	конфигурации ядра опцию <literal>DUMMYNET</literal>.  Дополнительную
	информацию можно почерпнуть из страницы Справочника по
	&man.dummynet.4;.</para>
    </sect3>
  </sect2>

  <sect2>
    <title>Включение функций моста</title>

    <para>Добавьте строку</para>

    <programlisting>net.link.ether.bridge=1</programlisting>

    <para>в файл <filename>/etc/sysctl.conf</filename> для включения функций
      моста во время работы системы.  Если вы хотите, чтобы пакеты,
      проходящие через мост, фильтровались через ipfw, вы должны также туда
      добавить строчку</para>

    <programlisting>net.link.ether.bridge_ipfw=1</programlisting>
  </sect2>

  <sect2>
    <title>Производительность</title>

    <para>Я использую в качестве моста/межсетевого экрана машину Pentium 90 с
      двумя сетевыми адаптерами: 3Com 3C900B и 3C905B.	Защищенная часть сети
      работает в полудуплексном режиме на скорости 10Мбит/сек, а связь между
      мостом и моим маршрутизатором (Cisco 675) осуществляется на скорости
      100Мбит/сек в полнодуплексном режиме.  Без функций фильтрации пакетов
      дополнительная задержка составляет около 0.4 миллисекунды для пакета
      утилиты ping между защищенной сетью, работающей на скорости 10 Мбит,
      и маршрутизатором Cisco 675.</para>
  </sect2>

  <sect2>
    <title>Дополнительные замечания</title>

    <para>Если вы хотите осуществлять удаленный доступ на мост по протоколу
      telnet из сети, то нет проблем в назначении одному из сетевых адаптеров
      IP-адреса.  Общепринято, что назначение адреса обоим сетевым адаптерам
      является не самой хорошей идеей.</para>

    <para>Если в вашей сети присутствует несколько мостов, не должно быть
      более одного маршрута между любыми двумя рабочими станциями.  С
      технической точки зрения это означает отсутствие поддержки протокола
      spanning tree.</para>
  </sect2>
</sect1>

<sect1 id="nfs">
  <title>NFS</title>

  <para><emphasis>Этот раздел написал &a.unfurl;, 4 марта
    2000.</emphasis></para>

  <para>Среди многих типов файловых систем, которые поддерживаются во
    FreeBSD, особое место занимает система Network File System, или NFS.  NFS
    позволяет вам использовать каталоги и файлы, находящиеся на одной машине,
    совместно с еще одной или несколькими машинами по сети, к которой они
    подключены.  При помощи NFS пользователи и программы могут получать доступ
    к файлам на удаленных системах точно так же, как если бы это были
    файлы на собственных дисках.</para>

  <para>Использование NFS имеет несколько преимуществ:</para>

  <itemizedlist>
    <listitem>
      <para>Отдельно взятым рабочим станциям не нужно иметь столь много
	дискового пространства, так как совместно используемые данные могут
	храниться на одной отдельной машине и быть доступными для всех машин
	в сети.</para>
    </listitem>

    <listitem>
      <para>Пользователям не нужно иметь уникальные для каждой машины
	домашние каталоги.  Если у них есть каталог, доступный по NFS, он
	может использоваться отовсюду.</para>
    </listitem>

    <listitem>
      <para>Устройства хранения информации, такие, как дискеты и приводы
	компакт-дисков, могут использоваться другими машинами в сети,
	что избавляет от необходимости в приобретении дополнительного
	оборудования.</para>
    </listitem>
  </itemizedlist>

  <sect2>
    <title>Как это работает</title>

    <para>NFS строится их двух компонент &ndash; клиент и сервер.
      Представляйте их в связке хочу/имею.  Клиент <emphasis>хочет</emphasis>
      данные, которые сервер <emphasis>имеет</emphasis>.  Сервер делится
      своими данными с клиентом.  Для того, чтобы эта система нормально
      функционировала, нужно правильно настроить и запустить несколько
      процессов.</para>

    <para>На сервере работают следующие даемоны:</para>

    <itemizedlist>
      <listitem>
	<para><command>nfsd</command> - NFS Daemon, обслуживающий запросы от
	  клиентов NFS.</para>
      </listitem>

      <listitem>
	<para><command>mountd</command> - NFS Mount Daemon, который выполняет
	  запросы, передаваемые ему от nfsd.</para>
      </listitem>
    </itemizedlist>

    <para>На стороне клиента должен быть запущен только один-единственный
      даемон:</para>

    <itemizedlist>
      <listitem>
	<para><command>nfsiod</command> - NFS async I/O Daemon (даемон
	  асинхронного ввода/вывода), обслуживающий запросы от своего
	  NFS-сервера.</para>
      </listitem>
    </itemizedlist>
  </sect2>

  <sect2>
    <title>Настройка NFS</title>

    <para>К счастью для нас, на системах FreeBSD эта настройка проста.
      Процессы, которые должны быть запущены, все могут быть запущены
      во время загрузки ценой нескольких модификаций в вашем файле
      <filename>/etc/rc.conf</filename>.</para>

    <para>Проверьте, что на NFS-сервере у вас есть такие строки:</para>

    <programlisting>
nfs_server_enable="YES"
nfs_server_flags="-u -t -n 4"
mountd_flags="-r"
    </programlisting>

    <para><command>mountd</command> запускается автоматически, если включен
      сервер NFS.  Флаги <option>-u</option> и <option>-t</option> в команде
      <command>nfsd</command> указывают на обслуживание клиентов, работающих
      по протоколам UDP и TCP.	Параметр <option>-n 4</option> указывает
      команде <command>nfsd</command> на запуск 4 своих копий.</para>

    <para>На клиентской строне убедитесь в наличии таких строк:</para>

    <programlisting>
nfs_client_enable="YES"
nfs_client_flags="-n 4"
    </programlisting>

    <para>Как и в случае <command>nfsd</command>, параметр
      <option>-n 4</option> указывает <command>nfsiod</command> на запуск
      4 своих копий.</para>

    <para>Последний этап настройки требует создания файла с именем
      <filename>/etc/exports</filename>.  Файл экспортирования перечисляет,
      какие файловые системы на вашем сервере будут использоваться совместно
      с другими машинами (или <quote>экспортироваться</quote>), и с какими
      именно.  Каждая строка в файле описывает файловую систему, которая
      будет предоставляться на доступ.	Имеется полный набор параметров,
      который можно использовать, но я коснусь только некоторых.  Описания
      остальных параметров можно найти в Справочнике
      по &man.exports.5;.</para>

    <para>Вот несколько примерных строк из файла
      <filename>/etc/exports</filename>:</para>

    <para>В следующей строке экспортируется <filename>/cdrom</filename> для
      для трех машинок, находящихся в том же самом домене, что и сервер
      (из-за отсутствия доменного имени для каждой машины) или которые
      имеют описания в файле <filename>/etc/hosts</filename>.  Флаг
      <option>-ro</option> указывает на использование экспортируемой файловой
      системы в режиме только для чтения.  С этим флагом удаленная система не
      сможет никоим образом изменить экспортируемую файловую систему.</para>

    <programlisting>/cdrom -ro moe larry curly</programlisting>

    <para>В следующей строке экспортируется файловая система
      <filename>/home</filename>, которая становится доступной трем хостам,
      указанным по их IP-адресам.  Это полезно, если у вас есть собственная
      сеть, но сервис DNS не используется.  Флаг <option>-alldirs</option>
      позволяет также экспортировать все каталоги, находящиеся ниже в
      указанной файловой системе.</para>

    <programlisting>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

    <para>В строке, приведенной ниже, файловая система
      <filename>/a</filename> экспортируется для двух машин, которые
      находятся в различных, не совпадающих с серверным, доменах.  Флаг
      <option>-maproot=0</option> позволяет пользователю root удаленной
      системы осуществлять запись на совместно используемую файловую систему
      как пользователь root.  Без флага -maproot=0 даже если кто-то имеет
      права доступа root на удаленной системе, он не сможет модифицировать
      файлы на совместно используемой файловой системе.</para>

    <programlisting>
      /a  -maproot=0  host.domain.com box.example.com
    </programlisting>

    <para>Для того, чтобы клиент смог использовать экспортированную файловую
      систему, он должен иметь права сделать это.  Проверьте, что клиент
      указан в вашем файле <filename>/etc/exports</filename>.</para>

    <para>Теперь, после того, как вы сделали все эти изменения, вы можете
      просто перезагрузиться, а FreeBSD запустит все во время загрузки,
      либо последовательно запустить следующие команды, работая как
      пользователь root:</para>

    <para>На сервере NFS:</para>

    <screen>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput>
    </screen>

    <para>На клиенте NFS:</para>

    <screen>
&prompt.root; <userinput>nfsiod -n 4</userinput>
    </screen>

    <para>Теперь вы готовы к реальному монтированию удаленной файловой
      системы.	Это может быть сделано двумя способами.  В приводимых
      примерах сервер будет носить имя <literal>server</literal>, а клиент
      будет носить имя <literal>client</literal>.  Если вы просто хотите
      временно смонтировать удаленную файловую систему, или всего лишь
      протестировать ваши настройки, то вы можете запустить команды, подобные
      приводимым здесь, работая как пользователь root на клиентской
      машине:</para>

    <screen>
&prompt.root; <userinput>mount server:/home /mnt</userinput>
    </screen>

    <para>По этой команде файловая система <filename>/home</filename> на
      сервере будет смонтирована в каталог <filename>/mnt</filename> на
      клиенте.	Если все настроено правильно, вы сможете перейти в каталог
      /mnt на клиенте и увидеть файлы, находящиеся на сервере.</para>

    <para>Если вы хотите иметь удаленную файловую систему смонтированной
      постоянно (каждый раз при загрузке), то добавьте ее в ваш файл
      <filename>/etc/fstab</filename>.	Вот примерная строка:</para>

    <programlisting>
server:/home	  /mnt	  nfs	  rw	  0	  0
    </programlisting>

    <para>Read the &man.fstab.5; man page for more options.</para>
  </sect2>

  <sect2>
    <title>Практическое использование</title>

    <para>Имеется много способов использовать NFS в работе.  Я достаточно
      часто использую ее в локальной сети, которую администрирую.  Вот
      несколько способов ее полезного применения.</para>

    <para>В моей сети имеется несколько машин, но всего лишь на одной из них
      имеется привод компакт-дисков.   Почему?	Потому что этот единственный
      привод используется совместно всеми другими машинами через NFS.  То же
      самое может быть сделано с приводами НГМД.</para>

    <para>С таким большим количеством машин ваши личные файлы приходят в
      беспорядок и распределяются по всем машинам.  У меня сделан центральный
      сервер NFS, на котором размещены все домашние каталоги пользователей
      и они экспортируются на все другие машины в локальной сети, так что
      вне зависимости от того, с какой машины я вошел в сеть, я получаю один
      и тот же домашний каталог.</para>

    <para>Когда вы переустанавливаете FreeBSD на одной из ваших машин, это
      можно делать через NFS.  Просто поместите компакт-диск с дистрибутивом
      на файловый сервер.</para>

    <para>Каталог <filename>/usr/ports/distfiles</filename> у меня является
      общим для всех машин.  Таким образом, когда я устанавливаю порт,
      который уже устанавливался ранее на другой машине, мне не нужно
      снова скачивать архив с исходным кодом.</para>
  </sect2>

  <sect2>
    <title>Проблемы взаимодействия с другими системами</title>

    <para><emphasis>Предоставил &a.jlind;.</emphasis></para>

    <para>Некоторые сетевые адаптеры для систем PC с шиной ISA имеют
      ограничения, которые могут привести к серьезным проблемам в сети, в
      частности, с NFS.  Эти проблемы не специфичны для FreeBSD, однако
      эту систему они затрагивают.</para>

    <para>Проблема, которая возникает практически всегда при работе по сети
      систем PC (FreeBSD) с высокопроизводительными рабочими станциями,
      выпущенными такими производителями, как Silicon Graphics, Inc. и Sun
      Microsystems, Inc.  Монтирование по протоколу NFS будет работать
      нормально, и некоторые операции также будут выполняться успешно, но
      неожиданно сервер окажется недоступным для клиент, хотя запросы к и
      от других систем будут продолжаться обрабатываться.  Такое встречается
      с клиентскими системами, не зависимо от того, является ли клиент
      машиной с FreeBSD или рабочей станцией.  Во многих системах при
      возникновении этой проблемы нет способа корректно завершить работу
      клиента.	Единственным выходом зачастую является холодная перезагрузка
      клиента, потому что ситуация с NFS не может быть разрешена.</para>

    <para>Хотя <quote>правильным</quote> решением является установка более
      производительного и скоростного сетевого адаптера на систему FreeBSD,
      имеется простое решение, приводящее к удовлетворительным результатам.
      Если система FreeBSD является <emphasis>сервером</emphasis>, укажите
      параметр <option>-w=1024</option> на клиенте при монтировании.  Если
      система FreeBSD является <emphasis>клиентом</emphasis>, то смонтируйте
      файловую систему NFS с параметром <option>-r=1024</option>.  Эти
      параметры могут быть заданы в четвертом поле записи в файле
      <filename>fstab</filename> клиента при автоматическом монтировании,
      или при помощи параметра <option>-o</option> в команде mount при
      монтировании вручную.</para>

    <para>Нужно отметить, что имеется также другая проблема, ошибочно
      принимаемая за приведенную выше, когда серверы и клиенты NFS находятся
      в разных сетях.  Если это тот самый случай,
      <emphasis>проверьте</emphasis>, что ваши маршрутизаторы пропускают
      нужную информацию UDP, в противном случае вы ничего не получите, что
      бы вы ни предпринимали.</para>

    <para>В следующих примерах <hostid>fastws</hostid> является именем хоста
      (интерфейса) высокопроизводительной рабочей станции, а
      <hostid>freebox</hostid> является именем хоста (интерфейса) системы
      FreeBSD со слабым сетевым адаптером.  Кроме того,
      <filename>/sharedfs</filename> будет являться экспортируемой через NFS
      файловой системой (смотри команду <command>man exports</command>), а
      <filename>/project</filename> будет точкой монтирования экспортируемой
      файловой системы на клиенте.  В любом случае, отметьте, что для
      вашего приложения могут понадобиться дополнительные параметры, такие,
      как <option>hard</option>, <option>soft</option> или
      <option>bg</option>.</para>

    <para>Примеры для системы FreeBSD (<hostid>freebox</hostid>) является
      клиентом: в файле <filename>/etc/fstab</filename> на машине
      freebox:</para>

    <programlisting>
fastws:/sharedfs /project nfs rw,-r=1024 0 0
    </programlisting>

    <para>Команда, выдаваемая вручную на машине
      <hostid>freebox</hostid>:</para>

    <screen>
&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sharedfs /project</userinput>
    </screen>

    <para>Примеры для системы FreeBSD в качестве сервера: в файле
      <filename>/etc/fstab</filename> на машине
      <hostid>fastws</hostid>:</para>

    <programlisting>
freebox:/sharedfs /project nfs rw,-w=1024 0 0
    </programlisting>

    <para>Команда, выдаваемая вручную на машине
      <hostid>fastws</hostid>:</para>

    <screen>
&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sharedfs /project</userinput>
    </screen>

    <para>Практически все 16-разрядные сетевые адаптеры позволят работать
      без указанных выше ограничений на размер блоков при чтении и
      записи.</para>

    <para>Для тех, кто интересуется, ниже описывается, что же происходит в
      при появлении этой ошибки, и объясняется, почему ее невозможно
      устранить.  Как правило, NFS работает с <quote>блоками</quote> размером
      8 килобайт (хотя отдельные фрагменты могут иметь меньшие размеры).  Так
      пакет Ethernet имеет максимальный размер около 1500 байт, то
      <quote>блок</quote> NFS разбивается на несколько пакетов Ethernet, хотя
      на более высоком уровне это все тот же единый блок, который должен быть
      принят, собран и <emphasis>подтвержден</emphasis> как один блок.
      Высокопроизводительные рабочие станции могут посылать пакеты, которые
      соответствуют одному блоку NFS, сразу друг за другом, насколько это
      позволяет делать стандарт.  На слабых, низкопроизводительных адаптерах
      пакеты, пришедшие позже, накладываются поверх ранее пришедших пакетов
      того же самого блока до того, как они могут быть переданы хосту и
      блок как единое целое не может быть собран или подтвержден.  В
      результате рабочая станция входит в ситуацию таймаута и пытается
      повторить передачу, но уже с полным блоком в 8КБ, и процесс будет
      повторяться снова, до бесконечности.</para>

    <para>Задав размер блока меньше размера пакета Ethernet, мы достигаем
      того, что любой полностью полученный пакет Ethernet может быть
      подтвержден индивидуально, и избежим тупиковую ситуацию.</para>

    <para>Наложение пакетов может все еще проявляться, когда
      высокопроизводительные рабочие станции сбрасывают данные на PC-систему,
      однако повторение этой ситуации не обязательно с более скоростными
      адаптерами с <quote>блоками</quote> NFS.	Когда происходит наложение,
      затронутые блоки будут переданы снова, и скорее всего, они будут
      получены, собраны и подтверждены.</para>
  </sect2>
</sect1>

<sect1 id="diskless">
  <title>Работа с бездисковыми станциями</title>

  <para><emphasis>Текст предоставил &a.martin;.</emphasis></para>

  <para><filename>netboot.com</filename>/<filename>netboot.rom</filename>
    позволяют вам загрузить вашу машину с FreeBSD по сети и работать с
    FreeBSD даже без наличия диска на клиентской машине.  В версии 2.0
    возможно даже иметь локальный раздел подкачки.  Поддерживается также
    подкачка поверх NFS.</para>

  <para>Список поддерживаемых адаптеров Ethernet включает: Western
    Digital/SMC 8003, 8013, 8216 и совместимые с ними; NE1000/NE2000 и
    совместимые с ними (требуется перекомпиляция)</para>

  <sect2>
    <title>Инструкции по настройке</title>

    <procedure>
      <step>
	<para>Найдите машину, которая будет вашим сервером.  Эта машина должна
	  иметь достаточное количество дискового пространства для того, чтобы
	  на ней поместились бинарные файлы FreeBSD 2.0, и на ней должны
	  быть запущены сервисы bootp, tftp и NFS.  Протестированные
	  машины:</para>

	<itemizedlist>
	  <listitem>
	    <para>HP9000/8xx под управлением HP-UX 9.04 и выше (версии до
	      9.04 не работают)</para>
	  </listitem>

	  <listitem>
	    <para>Sun/Solaris 2.3. (вам может потребоваться найти
	      bootp)</para>
	  </listitem>
	</itemizedlist>
      </step>

      <step>
	<para>Настройте сервер bootp, чтобы он сообщал клиенту его IP,
	  сетевой шлюз и маску подсети.</para>

	<programlisting>
diskless:\
	:ht=ether:\
	:ha=0000c01f848a:\
	:sm=255.255.255.0:\
	:hn:\
	:ds=192.1.2.3:\
	:ip=192.1.2.4:\
	:gw=192.1.2.5:\
	:vm=rfc1048:
	</programlisting>
      </step>

      <step>
	<para>Настройте сервер TFTP (на той же самой машине, что и сервер
	  bootp) для того, чтобы он сообщал клиенту загрузочную информацию.
	  Имя этого файла
	  <filename>cfg.<replaceable>X.X.X.X</replaceable></filename> (или
	  <filename>/tftpboot/cfg.<replaceable>X.X.X.X</replaceable></filename>,
	  будут пробоваться оба), где <replaceable>X.X.X.X</replaceable> -
	  это IP-адрес клиента.  Этот файл может содержать любые корректные
	  команды netboot.  В версии 2.0 netboot воспринимает следующие
	  команды:</para>

	<informaltable frame="none">
	<tgroup cols="2">
	<tbody>
	  <row>
	    <entry>help</entry>
	    <entry>вывод справочной информации</entry>
	  </row>

	  <row>
	    <entry>ip
	      <option><replaceable>X.X.X.X</replaceable></option></entry>
	    <entry>вывод/задание IP-адреса клиента</entry>
	  </row>

	  <row>
	    <entry>server
	      <option><replaceable>X.X.X.X</replaceable></option></entry>
	    <entry>вывод/задание адреса сервера bootp/tftp</entry>
	  </row>

	  <row>
	    <entry>netmask
	      <option><replaceable>X.X.X.X</replaceable></option></entry>
	    <entry>вывод/задание маски подсети</entry>
	  </row>

	  <row>
	    <entry>hostname <replaceable>name</replaceable></entry>
	    <entry>вывод/задание имени хоста</entry>
	  </row>

	  <row>
	    <entry>kernel
	      <option><replaceable>name</replaceable></option></entry>
	    <entry>вывод/задание имени ядра</entry>
	  </row>

	  <row>
	    <entry>rootfs
	      <option><replaceable>ip:/fs</replaceable></option></entry>
	    <entry>вывод/задание корневой файловой системы</entry>
	  </row>

	  <row>
	    <entry>swapfs
	      <option><replaceable>ip:/fs</replaceable></option></entry>
	    <entry>вывод/задание файловой системы для подкачки</entry>
	  </row>

	  <row>
	    <entry>swapsize
	      <option><replaceable>size</replaceable></option></entry>
	    <entry>задание размера файла подкачки в КБайтах для бездисковой
	      работы</entry>
	  </row>

	  <row>
	    <entry>diskboot</entry>
	    <entry>загрузка с диска</entry>
	  </row>

	  <row>
	    <entry>autoboot</entry>
	    <entry>продолжить процесс загрузки</entry>
	  </row>

	  <row>
	    <entry>trans
	      <option>on</option>|<option>off</option></entry>
	    <entry>включить/выключить передатчик</entry>
	  </row>

	  <row>
	    <entry>flags
	      <option>b</option><option>c</option><option>d</option><option>h</option><option>s</option><option>v</option></entry>
	    <entry>задать параметры загрузки</entry>
	  </row>
	</tbody>
	</tgroup>
	</informaltable>

	<para>Типичный полный cfg-файл для бездисковой работы может
	  содержать следующее:</para>

	<programlisting>
rootfs 192.1.2.3:/rootfs/myclient
swapfs 192.1.2.3:/swapfs
swapsize 20000
hostname myclient.mydomain
	</programlisting>

	<para>cfg-файл для машины с локальным разделом подкачки может
	  содержать следующее:</para>

	<programlisting>
rootfs 192.1.2.3:/rootfs/myclient
hostname myclient.mydomain
	</programlisting>
      </step>

      <step>
	<para>Проверьте, что ваш сервер NFS экспортирует корневую файловую
	  систему (и, если нужно, подкачку) для вашего клиента, а клиент
	  имеет доступ с правами администратора к этим файловым системам.
	  Типичный файл <filename>/etc/exports</filename> на системе
	  FreeBSD может иметь такой вид:</para>

	<programlisting>
/rootfs/myclient -maproot=0:0 myclient.mydomain
/swapfs -maproot=0:0 myclient.mydomain
	</programlisting>

	<para>А на системе HP-UX:</para>

	<programlisting>
/rootfs/myclient -root=myclient.mydomain
/swapfs -root=myclient.mydomain
	</programlisting>
      </step>

      <step>
	<para>Если вы осуществляете подкачку поверх NFS (полностью
	  бездисковая конфигурация), то создайте файл подкачки для вашего
	  клиента при помощи команды <command>dd</command>.  Если команде
	  <command>swapfs</command> задан параметр
	  <filename>/swapfs</filename> и указан размер 20000, как в примере
	  выше, то файл подкачки для машины myclient будет называться
	  <filename>/swapfs/swap.<replaceable>X.X.X.X</replaceable></filename>,
	  где <replaceable>X.X.X.X</replaceable> является IP-адресом клиента,
	  например:</para>

	<screen>
&prompt.root; <userinput>dd if=/dev/zero of=/swapfs/swap.192.1.2.4 bs=1k count=20000</userinput>
	</screen>

	<para>Кроме того, дисковое пространство подкачки после начала его
	  использования может содержать важную информацию, так что
	  постарайтесь ограничить доступ к этому файлу для предотвращения
	  несанкционированного доступа:</para>

	<screen>
&prompt.root; <userinput>chmod 0600 /swapfs/swap.192.1.2.4</userinput>
	</screen>
      </step>

      <step>
	<para>Распакуйте корневую файловую систему в каталоге, который будет
	  использоваться клиентом для своей корневой файловой системы
	  (<filename>/rootfs/myclient</filename> в примере выше).</para>

	<itemizedlist>
	  <listitem>
	    <para>На системах HP-UX: Сервер должен работать под управлением
	      HP-UX версии 9.04 или выше для машин серий HP9000/800.  Более
	      ранние версии не допускают создания файлов устройств
	      поверх NFS.</para>
	  </listitem>

	  <listitem>
	    <para>При распаковке каталога <filename>/dev</filename> в
	      <filename>/rootfs/myclient</filename> обратите внимание то
	      то, что некоторые системы (HPUX) не создадут файлы устройств,
	      которые нужны FreeBSD.  Вам может потребоваться при первой
	      загрузке перейти в однопользовательский режим (нажав control-c
	      во время процесса загрузки), перейти в каталог
	      <filename>/dev</filename> и выполнить команду
	      <command>sh ./MAKEDEV all</command> с клиента для того, чтобы
	      все исправить.</para>
	  </listitem>
	</itemizedlist>
      </step>

      <step>
	<para>Запустите на клиентской машине программу
	  <command>netboot.com</command> или прошейте ПЗУ файлом
	  <filename>netboot.rom</filename></para>
      </step>
    </procedure>
  </sect2>

  <sect2>
    <title>Совместное использование файловых систем <filename>/</filename> и
      <filename>/usr</filename></title>

    <para>В настоящее время нет официально одобренного способа сделать это,
      хотя для каждого клиента я использую общую файловую систему
      <filename>/usr</filename> и индивидуальную <filename>/</filename>.
      Если у кого-либо появятся соображения о том, как сделать это корректно,
      пожалуйста, дайте знать мне и/или &a.core;.</para>
  </sect2>

  <sect2>
    <title>Компиляция netboot для специфичных ситуаций</title>

    <para>Netboot может быть перекомпилирован для поддержки адаптеров
      NE1000/2000 изменением настроек в файле
      <filename>/sys/i386/boot/netboot/Makefile</filename>.  Посмотрите
      комментарии в самом начале этого файла.</para>
  </sect2>
</sect1>

<sect1 id="isdn">
  <title>ISDN</title>

  <para><emphasis>Последний раз внес изменения &a.wlloyd;</emphasis>.</para>

  <para>Полезным источником информации о технологии ISDN и его аппаратном
    обеспечении является <ulink url="http://alumni.caltech.edu/~dank/isdn/">
    Страница Дэна Кегела (Dan Kegel) об ISDN</ulink>.</para>

  <para>Быстрое введение в ISDN:</para>

  <itemizedlist>
    <listitem>
      <para>Если вы живете в Европе, то рекомендую вам изучить раздел об
	ISDN-адаптерах.</para>
    </listitem>

    <listitem>
      <para>Если вы планируете использовать ISDN в основном для соединений
	с Интернет через провайдера по коммутируемому, невыделенному
	соединению, я рекомендую посмотреть информацию о терминальных
	адаптерах.  Это даст вам самую большую гибкость и наименьшее
	количество проблем при смене провайдера.</para>
    </listitem>

    <listitem>
      <para>Если вы объединяете две локальные сети или подключаетесь к
	Интернет через постоянное ISDN-соединение, я рекомендую остановиться
	на отдельном мосте/маршрутизаторе.</para>
    </listitem>
  </itemizedlist>

  <para>Стоимость является важным фактором при выборе вашего решения.
    Далее перечислены все возможности от самого дешевого до самого дорогого
    варианта.</para>

  <sect2>
    <title>Адаптеры ISDN</title>

    <para><emphasis>Текст предоставил &a.hm;.</emphasis></para>

    <para>Этот раздел на самом деле имеет отношение только к пользователям
      ISDN в странах, где поддерживается стандарт DSS1/Q.931.</para>

    <para>Некоторое все увеличивающееся количество ISDN-адаптеров для PC
      поддерживается во FreeBSD 2.2.x и выше пакетом isdn4bsd.	Он находится
      в разработке, но сообщения говорят о том, что он успешно используется
      по всей Европе.</para>

    <para>Самая последняя версия isdn4bsd доступна по адресу <ulink
      url="ftp://isdn4bsd@ftp.consol.de/pub/">
      ftp://isdn4bsd@ftp.consol.de/pub/</ulink>, на главном ftp-сервере
      isdn4bsd (войдите как пользователь <username>isdn4bsd</username>,
      указав свой адрес электронной почты в качестве пароля, и перейдите в
      каталог <filename>pub</filename>.  Вход на общедоступный ftp
      как пользователь <username>ftp</username> или
      <username>anonymous</username> <emphasis>не</emphasis> даст желаемого
      результата).</para>

    <para>Isdn4bsd позволяет вам подключаться к другим маршрутизаторам ISDN
      с использованием как IP поверх HDLC, так и PPP на синхронном канале.
      Имеется также программа-автоответчик.</para>

    <para>Поддерживаются многие ISDN-адаптеры для PC, в основном с набором
      ISDN-микросхем Siemens (ISAC/HSCX), поддержка других наборов (фирм
      Motorola, Cologne Chip Designs) находится в разработке.  Актуальный
      список поддерживаемых адаптеров находится в файле <ulink
      url="ftp://isdn4bsd@ftp.consol.de/pub/README">README</ulink>.</para>

    <para>Если вы заинтересованы в добавлении поддержки другого протокола
      ISDN, неподдерживаемого в данный момент адаптера или каком-то другом
      усовершенствовании isdn4bsd, то обратитесь по адресу
      <email>hm@kts.org</email>.</para>

    <para>Имеется список рассылки, управляемый пакетом majordomo.  Чтобы к
      нему присоединиться, пошлите письмо на адрес &a.majordomo; и
      укажите:</para>

    <programlisting>
subscribe freebsd-isdn
    </programlisting>

    <para>в тексте вашего сообщения.</para>
  </sect2>

  <sect2>
    <title>Терминальные адаптеры ISDN</title>

    <para>Терминальные адаптеры(TA) для ISDN выполняют ту же роль, что и
      модемы для обычных телефонных линий.</para>

    <para>Большинство TA используют стандартный набор модемных AT-команд,
      и могут использоваться в качестве простой замены для модемов.</para>

    <para>TA будут работать точно так же, как и модемы, за исключением
      скорости соединения и пропускной способности, которые будут гораздо
      выше, чем у вашего старого модема.  Вам потребуется настроить <link
      linkend="ppp">PPP</link> точно также, как и в случае использования
      модема.  Проверьте, что вы задали скорость работы последовательного
      порта максимально высокой.</para>

    <para>Главным преимуществом использования TA для подключения к провайдеру
      Интернет является возможность использования динамического PPP.  Так
      как пространство адресов IP истощается все больше, большинство
      провайдеров не хочет больше выдавать вам статический IP-адрес.
      Большинство же маршрутизаторов не может использовать динамическое
      выделение IP-адресов.</para>

    <para>TA полностью полагаются на даемон PPP, который используете из-за
      его возможностей и стабильности соединения.  Это позволяет вам при
      использовании FreeBSD легко заменить модем на ISDN, если у вас уже
      настроено соединение PPP.  Однако, в тоже время любые проблемы, которые
      возникают с программой PPP, отражаются и здесь.</para>

    <para>Если вы хотите максимальной надежности, используйте параметр ядра
      <link linkend="ppp">PPP</link>, а не пользовательский <link
      linkend="userppp">iijPPP</link>.</para>

    <para>Известно, что следующие TA работают с FreeBSD.</para>

    <itemizedlist>
      <listitem>
	<para>Motorola BitSurfer и Bitsurfer Pro</para>
      </listitem>

      <listitem>
	<para>Adtran</para>
      </listitem>
    </itemizedlist>

    <para>Большинство остальных TA, скорее всего, тоже будут работать,
      производители TA прилагают все усилия для обеспечения поддержки
      практически всего набора стандартных AT-команд модема.</para>

    <para>Как и в случае модемов проблемой использования внешнего TA является
      потребность в хорошем последовательном адаптере на вашем
      компьютере.</para>

    <para>Вы должны прочесть раздел о <link linkend="uart">последовательных
      портах</link> Руководства для того, чтобы в деталях понять работу
      последовательных устройств, и осознать различие асинхронными и
      синхронными последовательными портами.</para>

    <para>TA, работающий со стандартным последовательным (асинхронным) портом
      PC, ограничивает вас скоростью 115.2Кбс, хотя реально у вас соединение
      на скорости 128Кбс.  Чтобы использовать 128Кбс, которые обеспечивает
      ISDN, полностью, вы должны подключить TA к синхронному
      последовательному адаптеру.</para>

    <para>Не обманывайте себя, думая, что покупка встроенного TA поможет
      избежать проблемы синхронности/асинхронности.  Встроенные TA просто
      уже имеют внутри стандартный последовательный порт PC.  Все, что при
      этом достигается - это экономия дополнительных последовательного
      кабеля и электрической розетки.</para>

    <para>Синхронный адаптер с TA по крайней мере так же быстр, как и
      отдельный маршрутизатор, а если он работает под управлением машины
      класса 386 с FreeBSD, то это гораздо более гибкое решение.</para>

    <para>Выбор sync/TA по сравнению с отдельным маршрутизатором в большей
      степени вопрос религиозный.  По этому поводу в списках рассылки была
      некоторая дискуссия.  Рекомендую поискать в <ulink
      url="http://www.FreeBSD.org/search.html">архивах</ulink> обсуждение
      полностью.</para>
  </sect2>

  <sect2>
    <title>Отдельные мосты/маршрутизаторы ISDN</title>

    <para>Мосты или маршрутизаторы ISDN не так уж специфичны для FreeBSD
      или для любой другой операционной системы.  Для более подробного
      описания технологий маршрутизации и работы мостов, пожалуйста,
      обратитесь к книге по сетевым технологиям.</para>

    <para>В контексте этой страницы я буду использовать термины маршрутизатор
      и мост как взаимозаменяемые.</para>

    <para>Вместе с падением цен на простые мосты/маршрутизаторы ISDN, они
      становятся все более популярными.  Маршрутизатор ISDN представляет
      собой маленькую коробочку, которая подключается непосредственно в
      вашу сеть (или адаптер) Ethernet, и поддерживает связь с другим
      мостом/маршрутизатором.  Все программное обеспечение для работы по
      PPP и другим протоколам, встроено в маршрутизатор.</para>

    <para>Маршрутизатор обладает гораздо большей пропускной способностью, чем
      стандартный TA, так как он использует полное синхронное соединение
      ISDN.</para>

    <para>Основной проблемой с маршрутизаторами и мостами ISDN является то,
      что их совместная работа с оборудованием других производителей может
      оказаться под вопросом.  Если вы собираетесь подключаться к провайдеру,
      я рекомендую обсудить с ним то, что вам нужно.</para>

    <para>Если вы планируете объединить два сегмента локальной сети, то есть
      домашнюю сеть с сетью офиса, это самое простое решение с минимальными
      издержками на обслуживание.  Так как вы покупаете оборудование для
      обоих сторон соединения, то можете быть уверены, что связь будет
      работать нормально.</para>

    <para>Например, для соединения домашнего компьютера или сети
      подразделения к сети центрального офиса, может использоваться такая
      настройка.</para>

    <example>
      <title>Офис подразделения или домашняя сеть</title>

      <para>Сеть построена на основе 10 Base T Ethernet.  Подключите
	маршрутизатор к сетевому кабелю с помощью трансивера AUI/10BT,
	если это нужно.</para>

      <!-- Здесь должен быть рисунок -->
      <programlisting>
---Рабочая станция Sun
|
---Машина с FreeBSD
|
---Windows 95 (Do not admit to owning it)
|
Отдельный маршрутизатор
   |
Канал ISDN BRI
      </programlisting>

      <para>Если ваш домашний или удаленный офис представляет собой один
	компьютер, то для непосредственного подключения к маршрутизатору вы
	вы можете использовать витую пару с перекрестным соединениям.</para>
    </example>

    <example>
      <title>Центральный офис или другая локальная сеть</title>

      <para>Сеть построена на Ethernet с витой парой.</para>

      <!-- Здесь должен быть рисунок -->
      <programlisting>
    -------Сервер Novell
    | H |
    |	---Sun
    |	|
    | U ---FreeBSD
    |	|
    |	---Windows 95
    | B |
    |___---Отдельно стоящий маршрутизатор
		|
	 Канал ISDN BRI
      </programlisting>
    </example>

    <para>Одним большим преимуществом большинства маршрутизаторов/мостов
      является то, что они позволяют иметь 2 <emphasis>отдельных
      независимых</emphasis> соединения PPP к 2 различным сайтам
      <emphasis>одновременно</emphasis>.  Это не поддерживается в большинстве
      TA, кроме специальных (дорогих) моделей, имеющих по два
      последовательных порта.  Не путайте это с балансировкой нагрузки,
      MPP и так далее.</para>

    <para>Это может оказаться весьма полезной особенностью, например, если
      у вас имеется постоянное ISDN-соединение в вашем офисе, и вы хотите
      им воспользоваться, но не хотите задействовать дополнительный канал
      ISDN на работе.  Маршрутизатор, расположенный в офисе, может
      использовать выделенное соединение по каналу B (64Кбс) для Интернет,
      и одновременно другой канал B для отдельного соединения для передачи
      данных.  Второй канал B может использоваться для входящих, исходящих
      и динамически распределяемых соединений (MPP и другие) совместно с
      первым каналом B для повышения пропускной способности.</para>

    <para>Мост Ethernet также позволяет вам передавать больше, чем просто
      трафик IP, вы можете передавать IPX/SPX и любые другие протоколы,
      которые вы используете.</para>
  </sect2>
</sect1>

<sect1 id="nis">
  <title>NIS/YP</title>

  <para><emphasis>Текст написал &a.unfurl; 21 января 2000, дополнения и
    комментарии частично от Эрика Огрена (Eric Ogren)
    <email>eogren@earthlink.net</email> и Удо Эрделхоффа (Udo Erdelhoff)
    <email>ue@nathan.ruhr.de</email> сделаны в июне 2000.</emphasis></para>

  <sect2>
    <title>Что это такое?</title>

    <para>NIS, что является сокращением от Network Information Services
      (Сетевые Информационные Службы), которые были разработаны компанией
      Sun Microsystems для централизованного администрирования систем Unix
      (первоначально SunOS).  В настоящее время эти службы практически стали
      промышленным стандартом; все основные версии Unix (Solaris, HP-UX, AIX,
      Linux, NetBSD, OpenBSD, FreeBSD, и так далее) поддерживают NIS.</para>

    <para>NIS первоначально назывались Yellow Pages (или yp), но из-за
      проблем с авторскими правами, Sun была вынуждена изменить это
      название.</para>

    <para>Это система клиент/сервер на основе вызовов RPC, которая позволяет
      группе машин в одном домене NIS совместно использовать общий набор
      конфигурационных файлов.	Системный администратор может настроить
      клиентскую систему NIS только с минимальной настроечной информацией, а
      затем добавлять, удалять и модифицировать настроечную информацию из
      одного места.</para>

    <para>Это похоже на систему доменов Windows NT; хотя их внутренние
      реализации не так уж и похожи, основные функции сравнимы.</para>
  </sect2>

  <sect2>
    <title>Термины/программы, о которых вы должны знать</title>

    <para>Существует несколько терминов и некоторое количество
      пользовательских программ, которые будут нужны, когда вы будете
      пытаться сделать NIS во FreeBSD, и в случае создания сервера, и
      в случае работы в качестве клиента NIS:</para>

    <itemizedlist>
      <listitem>
	<para><emphasis>Имя домена NIS</emphasis>.  Главный сервер NIS и
	  все его клиенты (включая вторичные серверы), имеют доменное имя
	  NIS.	Как и в случае с именем домена NT, имя домена NIS не имеет
	  ничего общего с DNS.</para>
      </listitem>

      <listitem>
	<para><emphasis>portmap</emphasis>.  Для обеспечения работы RPC
	  (Remote Procedure Call, Удаленного Вызова Процедур, сетевого
	  протокола, используемого NIS), должен быть запущен даемон
	  <command>portmap</command>.  Если даемон <command>portmap</command>
	  не запущен, невозможно будет запустить сервер NIS, или работать как
	  NIS-клиент.</para>
      </listitem>

      <listitem>
	<para><emphasis>ypbind</emphasis>.  <command>ypbind</command>
	  &ldquo;связывает&rdquo; NIS-клиента с его NIS-сервером.  Он
	  определяет имя NIS-домена системы, и при помощи RPC подключается к
	  серверу.  <command>ypbind</command> является основой
	  клиент-серверного взаимодействия в среде NIS; если на клиентской
	  машине программа <command>ypbind</command> перестанет работать, то
	  эта машина не сможет получить доступ к серверу NIS.</para>
      </listitem>

      <listitem>
	<para><emphasis>ypserv</emphasis>.  Программа
	  <command>ypserv</command>, которая должна запускаться только на
	  серверах NIS, собственно и является сервером NIS.  Если ypserv
	  перестанет работать, то сервер не сможет отвечать на запросы NIS
	  (к счастью, на этот случай предусмотрен вторичный сервер).</para>

	<note>
	  <para>Есть несколько реализаций NIS (к FreeBSD это не относится),
	    в которых не производится попыток подключиться к другому серверу,
	    если ранее используемый сервер перестал работать.  Зачастую
	    единственным средством, помогающим в этой ситуации, является
	    перезапуск серверного процесса (или сервера полностью) или
	    процесса <command>ypbind</command> на клиентской машине.</para>
	</note>
      </listitem>

      <listitem>
	<para><emphasis>rpc.yppasswdd</emphasis>.  Программа
	  <command>rpc.yppasswdd</command>, другой процесс, который
	  запускается только на главных NIS-серверах, является даемоном,
	  позволяющим клиентам NIS изменять свои пароли NIS.  Если этот
	  даемон не запущен, то пользователи должны будут входить на
	  основной сервер NIS и там менять свои пароли.</para>
      </listitem>

      <!-- XXX Отсутствует: rpc.ypxfrd (хотя это не очень важно) Может
	   работать только на основном сервере -->
    </itemizedlist>
  </sect2>

  <sect2>
    <title>Как это работает?</title>

    <para>В системе NIS существует три типа хостов; основные (master)
      серверы, вторичные (slave) серверы и клиентские машины.  Серверы
      выполняют роль централизованного хранилища информации о конфигурации
      хостов.  Основные серверы хранят оригиналы этой информации, когда как
      вторичные серверы хранят ее копию для обеспечения избыточности.
      Клиенты связываются с серверами, чтобы предоставить им эту
      информацию.</para>

    <para>Информация во многих файлах может совместно использоваться
      следующим образом.  Файлы <filename>master.passwd</filename>,
      <filename>group</filename>, и <filename>hosts</filename> используются
      совместно через NIS.  Когда процессу, работающему на клиентской машине,
      требуется информация, как правило, находящаяся в этих файлах локально,
      он делает запрос к серверу, с которым связан, для получения этой
      информации.</para>

    <sect3>
      <title>Типы машин</title>

      <itemizedlist>
	<listitem>
	  <para><emphasis>Основной сервер NIS</emphasis>.
	    Такой сервер, по аналогии с первичным контроллером домена Windows
	    NT, хранит файлы, используемые всеми клиентами NIS.  Файлы
	    <filename>passwd</filename>, <filename>group</filename> и
	    различные другие файлы, используемые клиентами NIS, находятся
	    на основном сервере.</para>

	  <note>
	    <para>Возможно использование одной машины в качестве сервера для
	      более чем одного домена NIS.  Однако, в этом введении такая
	      ситуация не рассматривается, и предполагается менее масштабное
	      использование NIS.</para>
	  </note>
	</listitem>

	<listitem>
	  <para><emphasis>Вторичные серверы NIS</emphasis>.
	    Похожие на вторичные контроллеры доменов NT, вторичные серверы
	    NIS содержат копии оригинальных файлов данных NIS.	Вторичные
	    серверы NIS обеспечивают избыточность, что нужно в критичных
	    приложениях.  Они также помогают распределять нагрузку на
	    основной сервер: клиенты NIS всегда подключаются к тому серверу
	    NIS, который ответил первым, в том числе и к вторичным
	    серверам.</para>
	</listitem>

	<listitem>
	  <para><emphasis>Клиенты NIS</emphasis>.
	    Клиенты NIS, как и большинство машин NT Workstation,
	    аутентифицируются на сервере NIS (или на контроллере домена
	    в случае NT Workstation) во время входа в систему.</para>
	</listitem>
      </itemizedlist>
    </sect3>
  </sect2>

  <sect2>
    <title>Использование NIS/YP</title>

    <para>В этом разделе приводится пример настройки NIS.</para>

    <note>
      <para>В этом разделе предполагается, что вы работаете с FreeBSD версии
	3.3 или выше.  Указания, приводимые здесь, скорее всего,
	<emphasis>будут</emphasis> работать с любой версией FreeBSD, выше,
	чем 3.0, однако нет гарантий, что это на самом деле так.</para>
    </note>

    <sect3>
      <title>Планирование</title>

      <para>Давайте предположим, что вы являетесь администратором в маленькой
	университетской лаборатории.  В настоящий момент в этой лаборатории
	с 15 машинами отсутствует единая точка администрирования; на каждой
	машине имеются собственные файлы <filename>/etc/passwd</filename> и
	<filename>/etc/master.passwd</filename>.  Эти файлы синхронизируются
	друг с другом только вручную; сейчас, когда вы добавляете
	пользователя в лаборатории, вы должны выполнить команду
	<command>adduser</command> на всех 15 машинах.	Понятно, что такое
	положение вещей нужно исправлять, так что вы решили перевести
	сеть на использование NIS, используя две машины в качестве
	серверов.</para>

      <para>Итак, конфигурация лаборатории сейчас выглядит примерно
	так:</para>

      <informaltable>
      <tgroup cols="3">
      <thead>
	<row>
	  <entry>Имя машины</entry>
	  <entry>IP-адрес</entry>
	  <entry>Роль машины</entry>
	</row>
      </thead>

      <tbody>
	<row>
	  <entry><hostid>ellington</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.2</hostid></entry>
	  <entry>Основной сервер NIS</entry>
	</row>

	<row>
	  <entry><hostid>coltrane</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.3</hostid></entry>
	  <entry>Вторичный сервер NIS</entry>
	</row>

	<row>
	  <entry><hostid>basie</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.4</hostid></entry>
	  <entry>Факультетская рабочая станция</entry>
	</row>

	<row>
	  <entry><hostid>bird</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.5</hostid></entry>
	  <entry>Клиентская машина</entry>
	</row>

	<row>
	  <entry><hostid>cli[1-11]</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.[6-17]</hostid></entry>
	  <entry>Другие клиентские машины</entry>
	</row>
      </tbody>
      </tgroup>
      </informaltable>

      <para>Если вы определяете схему NIS первый раз, ее нужно хорошо
	обдумать.  Вне зависимости от размеров вашей сети, есть несколько
	ключевых моментов, которые требуют принятия решений.</para>

      <sect4>
	<title>Выбор имени домена NIS</title>

	<para>Это имя не должно быть <quote>именем домена</quote>, которое
	  вы использовали.  Более точно это имя называется <quote>именем
	  домена NIS</quote>.  Когда клиент рассылает запросы на получение
	  информации, он включает в них имя домена NIS, частью которого
	  является.  Таким способом многие сервера в сети могут указать,
	  какой сервер на какой запрос должен отвечать.  Думайте о домене
	  NIS как об имени группы хостов, которые каким-то образом
	  связаны.</para>

	<para>Некоторые организации в качестве имени домена NIS используют
	  свой домен Интернет.	Это не рекомендуется, так как может вызвать
	  проблемы в процессе решения сетевых проблем.	Имя домена NIS должно
	  быть уникальным в пределах вашей сети и хорошо, если оно будет
	  описывать группу машин, которые представляет.  Например,
	  художественный отдел в компании Acme Inc. может находиться в
	  домене NIS с именем "acme-art".  В нашем примере положим, что
	  мы выбрали имя <emphasis>test-domain</emphasis>.</para>

	<para>Несмотря на это, некоторые операционные системы (в частности,
	  SunOS) используют свое имя домена NIS в качестве имени домена
	  Интернет.  Если одна или более машин в вашей сети имеют такие
	  ограничения, вы <emphasis>обязаны</emphasis> использовать имя
	  домена Интернет в качестве имени домена NIS.</para>
      </sect4>

      <sect4>
	<title>Требования к серверу</title>

	<para>Есть несколько вещей, которые нужно иметь в виду при выборе
	  машины для использования в качестве сервера NIS.  Одной из
	  обескураживающей вещью, касающейся NIS, является уровень
	  зависимости клиентов от серверов.  Если клиент не может
	  подключиться к серверу своего домена NIS, зачастую машину просто
	  становится нельзя использовать.  Отсутствие информации о
	  пользователях и группах приводит к временной остановке работы
	  большинства систем.  Зная это, вы должны выбрать машину, которая
	  не должна подвергаться частым перезагрузкам и не используется
	  для разработки.  Сервер NIS в идеале должен быть отдельно стоящей
	  машиной, единственным целью в жизни которой является быть сервером
	  NIS.	Если вы работаете в сети, которая не так уж сильно загружена,
	  то можно поместить сервер NIS на машине, на которой запущены и
	  другие сервисы, просто имейте в виду, что если сервер NIS
	  становится недоступным, то это негативно отражается на
	  <emphasis>всех</emphasis> клиентах NIS.</para>
      </sect4>
    </sect3>

    <sect3>
      <title>Серверы NIS</title>

      <para>Оригинальные копии всей информации NIS хранится на единственной
	машине, которая называется главным сервером NIS.  Базы данных,
	которые используются для хранения информации, называются картами NIS.
	Во FreeBSD эти карты хранятся в
	<filename>/var/yp/[domainname]</filename>, где
	<filename>[domainname]</filename> является именем обслуживаемого
	домена NIS.  Один сервер NIS может поддерживать одновременно
	несколько доменов, так что есть возможность иметь несколько таких
	каталогов, по одному на каждый обслуживаемый домен.  Каждый домен
	будет иметь свой собственный независимый от других набор карт.</para>

      <para>Основной и вторичный серверы обслуживают все запросы NIS с
	помощью даемона <command>ypserv</command>.  <command>Ypserv</command>
	отвечает за получение входящих запросов от клиентов NIS,
	распознавание запрашиваемого домена и отображение имени в путь к
	соответствующему файлы базы данных, а также передаче информации из
	базы данных обратно клиенту.</para>

      <sect4>
	<title>Настройка основного сервера NIS</title>

	<para>Настройка основного сервера NIS может оказаться сравнительно
	  простой, в зависимости от ваших потребностей.  В поставку FreeBSD
	  сразу включена поддержка NIS.  Все, что вам нужно, это добавить
	  следующие строки в файл <filename>/etc/rc.conf</filename>, а
	  FreeBSD сделает за вас все остальное..</para>

	<itemizedlist>
	  <listitem>
	    <para><programlisting>nisdomainname="test-domain"</programlisting>
	      В этой строке задается имя домена NIS, которое будет
	      <emphasis>test-domain</emphasis>, еще до настройки сети
	      (например, после перезагрузки).</para>
	  </listitem>

	  <listitem>
	    <para><programlisting>nis_server_enable="YES"</programlisting>
	      Здесь указывается FreeBSD на запуск процессов серверов NIS,
	      когда дело доходит до сетевых настроек.</para>
	  </listitem>

	  <listitem>
	    <para><programlisting>nis_yppasswdd_enable="YES"</programlisting>
	      Здесь указывается на запуск даемона
	      <command>rpc.yppasswdd</command>, который, как это отмечено
	      выше, позволит пользователям менять свой пароль NIS с
	      клиентской машины.</para>
	  </listitem>
	</itemizedlist>

	<para>А теперь все, что вам нужно сделать, это запустить команду
	  <command>/etc/netstart</command>, работая как администратор.	По
	  ней произойдет настройка всего, при этом будут использоваться
	  значения, заданные в файле <filename>/etc/rc.conf</filename>.</para>
      </sect4>

      <sect4>
	<title>Инициализация карт NIS</title>

	<para><emphasis>Карты NIS</emphasis> являются файлами баз данных,
	  которые хранятся в каталоге <filename>/var/yp</filename>.
	  Они генерируются из конфигурационных файлов, находящихся в каталоге
	  <filename>/etc</filename> основного сервера NIS, за одним
	  исключением: файл <filename>/etc/master.passwd</filename>.
	  На это есть весомая причина; вам не нужно распространять пароли
	  пользователя root и других административных пользователей на все
	  серверы в домене NIS.  По этой причине, прежде чем инициализировать
	  карты NIS, вы должны сделать вот что:</para>

	<screen>
&prompt.root; <userinput>cp /etc/master.passwd /var/yp/master.passwd</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>vi master.passwd</userinput>
	</screen>

	<para>Вы должны удалить все записи, касающиеся системных
	  пользователей (bin, tty, kmem, games и так далее), а также записи,
	  которые вы не хотите распространять клиентам NIS (например, root
	  и другие пользователи с UID, равным 0 (администраторы)).</para>

	<note>
	  <para>Проверьте, чтобы файл
	    <filename>/var/yp/master.passwd</filename> был недоступен для
	    записи ни для группы, ни для остальных пользователей (режим
	    доступа 600)!  Воспользуйтесь командой <command>chmod</command>,
	    если это нужно.</para>
	</note>

	<para>Когда с этим будет покончено, самое время проинициализировать
	  карты NIS!  В поставку FreeBSD включен скрипт с именем
	  <command>ypinit</command>, который делает это (обратитесь к его
	  справочной странице за дополнительной информацией).  Отметьте, что
	  этот скрипт имеется на большинстве ОС UNIX, но не во всех.  В
	  системе Digital Unix/Compaq Tru64 Unix он называется
	  <command>ypsetup</command>.  Так как мы генерируем карты для
	  главного сервера NIS, то при вызове программы
	  <command>ypinit</command> мы передаем ей параметр
	  <option>-m</option>.	Для генерации карт NIS в предположении, что
	  вы уже сделали шаги, описанные выше, выполните следующее:</para>

	<screen>
ellington&prompt.root; <userinput>ypinit -m test-domain</userinput>
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] <userinput>n</userinput>
Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server	:  ellington
next host to add:  <userinput>coltrane</userinput>
next host to add:  <userinput>^D</userinput>
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] <userinput>y</userinput>

[..вывод при генерации карт..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.
	</screen>

	<para>Программа <command>ypinit</command> должна была создать файл
	  <filename>/var/yp/Makefile</filename> из
	  <filename>/var/yp/Makefile.dist</filename>.  При создании этого
	  файла предполагается, что вы работаете в окружении с единственным
	  сервером NIS и только с машинами FreeBSD.  Так как в домене
	  <emphasis>test-domain</emphasis> имеется также и вторичный сервер,
	  то вы должны отредактировать файл
	  <filename>/var/yp/Makefile</filename>:</para>

	<screen>
ellington&prompt.root; <userinput>vi /var/yp/Makefile</userinput>
	</screen>

	<para>Вы должны закомментировать строку, в которой указано
	  `NOPUSH = "True"' (она уже не раскомментирована).</para>
      </sect4>

      <sect4>
	<title>Настройка вторичного сервера NIS</title>

	<para>Настройка вторичного сервера NIS осуществляется еще проще,
	  чем настройка главного сервера.  Войдите на вторичный сервер и
	  отредактируйте файл <filename>/etc/rc.conf</filename> точно также,
	  как вы делали это ранее.  Единственным отличием является то, что
	  при запуске программы <command>ypinit</command> мы теперь должны
	  использовать опцию <option>-s</option>.  Применение опции
	  <option>-s</option> требует также указание имени главного сервера
	  NIS, так что наша команда должна выглядеть так:</para>

	<screen>
coltrane&prompt.root; <userinput>ypinit -s ellington test-domain</userinput>

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  <userinput>n</userinput>

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don't forget to update map ypservers on ellington.
	</screen>

	<para>Теперь у вас должен быть каталог с именем
	  <filename>/var/yp/test-domain</filename>.  Копии карт главного
	  сервера NIS должны быть в этом каталоге.  Вы должны удостовериться,
	  что этот каталог обновляется.  Следующие строки в
	  <filename>/etc/crontab</filename> вашего вторичного сервера должны
	  это делать:</para>

	<programlisting>
20	*	*	*	*	root   /usr/libexec/ypxfr passwd.byname
21	*	*	*	*	root   /usr/libexec/ypxfr passwd.byuid
	</programlisting>

	<para>Эти две строки заставляют вторичный сервер синхронизировать
	  свои карты с картами главного сервера.  Хотя делать это не
	  обязательно, потому что главный сервер делает попытки передать
	  все изменения в своих картах NIS на свои вторичные серверы,
	  информация для входа в систему настолько жизненно важна для
	  систем, зависящих от сервера, что выполнение регулярных обновлений
	  является совсем не плохой идеей.  Это еще более важно в загруженных
	  сетях, в которых обновления карт могут не всегда завершаться
	  успешно.</para>

	<para>А теперь точно также запустите команду
	  <command>/etc/netstart</command> на вторичном сервере, по которой
	  снова выполнится запуск сервера NIS.</para>
      </sect4>
    </sect3>

    <sect3>
      <title>Клиенты NIS</title>

      <para>Клиент NIS выполняет так называемую привязку к конкретному
	серверу NIS при помощи даемона <command>ypbind</command>.
	<command>ypbind</command> определяет домен, используемый в системе
	по умолчанию (тот, который устанавливается по команде
	<command>domainname</command>), и начинает широковещательную рассылку
	запросов RPC в локальной сети.	В этих запросах указано имя домена,
	к серверу которого <command>ypbind</command> пытается осуществить
	привязку.  Если сервер, который был настроен для обслуживания
	запрашиваемого домена, получит широковещательный запрос, он ответит
	<command>ypbind</command>, который, в свою очередь запомнит адрес
	сервера.  Если имеется несколько серверов (например, главный и
	несколько вторичных), то <command>ypbind</command> будет использовать
	адрес первого ответившего.  С этого момента клиентская система будет
	направлять все свои запросы NIS на этот сервер.  Время от времени
	<command>ypbind</command> будет обмениваться пакетами
	<quote>ping</quote> с сервером для проверки его работоспособности.
	Если на один из тестовых пакетов не удастся получить ответа за
	разумное время, то <command>ypbind</command> пометит этот домен как
	домен, с которым связка разорвана, и снова начнет процесс посылки
	широковещательных запросов в надежде найти другой сервер.</para>

      <sect4>
	<title>Настройка клиента NIS</title>

	<para>Настройка машины с FreeBSD в качестве клиента NIS достаточно
	  проста.</para>

	<itemizedlist>
	  <listitem>
	    <para>Отредактируйте файл <filename>/etc/rc.conf</filename>,
	      добавив туда следующие строки для того, чтобы задать имя домена
	      NIS и запустить <command>ypbind</command> во время запуска
	      сетевых служб:</para>

	    <programlisting>
nisdomainname="test-domain"
nis_client_enable="YES"
	    </programlisting>
	  </listitem>

	  <listitem>
	    <para>Для получения всех возможных учетных записей от сервера NIS
	      добавьте при помощи <command>vipw</command> в ваш файл
	      <filename>/etc/master.passwd</filename> такую строчку:</para>

	    <programlisting>
+:::::::::
	    </programlisting>

	    <note>
	      <para>Эта строчка даст всем пользователям с корректной учетной
		записью в картах учетных баз пользователей доступ к этой
		системе.  Есть множество способов настроить ваш клиент NIS,
		изменив эту строку.  Посмотрите ниже текст, касающийся <link
                linkend="netgroups">сетевых групп</link>, чтобы получить более
                подробную информацию.  Дополнительная информация для изучения
                находится в книге издательства O'Reilly под названием
		<literal>Managing NFS and NIS</literal>.</para>
	    </note>
	  </listitem>

	  <listitem>
	    <para>Для импортирования всех возможных записей о группах с
	      сервера NIS, добавьте в ваш файл
	      <filename>/etc/group</filename> такую строчку:</para>

	    <programlisting>
+:*::
	    </programlisting>
	  </listitem>
	</itemizedlist>

	<para>После завершения выполнения этих шагов у вас должно получиться
	  запустить команду <command>ypcat passwd</command> и увидеть
	  карту учетных записей сервера NIS.</para>
      </sect4>
    </sect3>
  </sect2>

  <sect2>
    <title>Безопасность NIS</title>

    <para>В общем-то любой пользователь, зная имя вашего домена, может
      выполнить запрос RPC к ypserv и получить содержимое ваших карт NIS.
      Для предотвращения такого неавторизованного обмена ypserv поддерживает
      так называемую систему securenets, которая может использоваться для
      ограничения доступа к некоторой группе хостов.  При запуске ypserv
      будет пытаться загрузить информацию, касающуюся securenets, из файла
      <filename>/var/yp/securenets</filename>.</para>

    <note>
      <para>Имя каталога зависит от параметра, указанного вместе с опцией
	<option>-p</option>.  Этот файл содержит записи, состоящие из
	указания сети и сетевой маски, разделенных пробелом.  Строчки,
	начинающиеся со знака <quote>#</quote>, считаются комментариями.
	Примерный файл securenets может иметь примерно такой вид:</para>
    </note>

    <programlisting>
# allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0
    </programlisting>

    <para>Если ypserv получает запрос от адреса, который соответствует одному
      из этих правил, он будет отрабатывать запрос обычным образом.  Если же
      адрес не подпадает ни под одно правило, запрос будет проигнорирован
      и в журнал будет записано предупреждающее сообщение.  Если файл
      <filename>/var/yp/securenets</filename> не существует, ypserv будет
      обслуживать соединения от любого хоста.</para>

    <para>Программа ypserv также поддерживает пакет программ
      <application>tcpwrapper</application> от Wietse Venema.  Это позволяет
      администратору для ограничения доступа вместо
      <filename>/var/yp/securenets</filename> использовать конфигурационные
      файлы tcpwrapper.</para>

    <note>
      <para>Хотя оба этих метода управления доступом обеспечивают некоторую
	безопасность, они, как основанные на проверке привилегированного
        порта, оба подвержены атакам типа <quote>IP spoofing</quote>.  Весь
        сетевой трафик, связанный с работой NIS, должен блокироваться вашим
        межсетевым экраном.</para>

      <para>Серверы, использующие файл <filename>/var/yp/securenets</filename>,
        могут быть не в состоянии обслуживать старых клиентов NIS с древней
        реализацией протокола TCP/IP.  Некоторые из этих реализаций при
        рассылке широковещательных запросов устанавливают все биты машинной
        части адреса в ноль и/или не в состоянии определить маску подсети при
        вычислении адреса широковещательной рассылки.  Хотя некоторые из этих
        проблем могут быть решены изменением конфигурации клиента, другие
        могут привести к отказу от использования
        <filename>/var/yp/securenets</filename>.</para>

      <para>Использование <filename>/var/yp/securenets</filename> на сервере
        с такой архаичной реализацией TCP/IP является весьма плохой идеей, и
        приведёт к потере работоспособности NIS в большой части вашей
        сети.</para>

      <para>Использование пакета <application>tcpwrapper</application> увеличит
        время отклика вашего сервера NIS.  Дополнительной задержки может
        оказаться достаточно для возникновения таймаутов в клиентских
        программах, особенно в загруженных сетях или с медленными серверами
        NIS.  Если одна или более ваших клиентских систем страдают от таких
        проблем, вы должны преобразовать такие клиентские системы во вторичные
        серверы NIS и сделать принудительную их привязку к самим себе.</para>
    </note>
  </sect2>

  <sect2>
    <title>Запрет входа некоторых пользователей</title>

    <para>В нашей лаборатории есть машина <hostid>basie</hostid>, о которой
      предполагается, что она является исключительно факультетской рабочей
      станцией.  Мы не хотим исключать эту машину из домена NIS, однако
      файл <filename>passwd</filename> на главном сервере NIS содержит
      учетные записи как для работников факультета, так и студентов.  Что мы
      можем сделать?</para>

    <para>Есть способ ограничить вход некоторых пользователей на этой машине,
      даже если они присутствуют в базе данных NIS.  Чтобы это сделать, вам
      достаточно добавить
      <emphasis>-<replaceable>username</replaceable></emphasis> в конец файла
      <filename>/etc/master.passwd</filename> на клиентской машине, где
      <replaceable>username</replaceable> является именем пользователя,
      которому вы хотите запретить вход.  Рекомендуется сделать это с помощью
      утилиты <command>vipw</command>, так как <command>vipw</command>
      проверит ваши изменения в <filename>/etc/master.passwd</filename>, а
      также автоматически перестроит базу данных паролей по окончании
      редактирования.  Например, если мы хотим запретить пользователю
      <emphasis>bill</emphasis> осуществлять вход на машине
      <hostid>basie</hostid>, то мы сделаем следующее:</para>

    <screen>
basie&prompt.root; <userinput>vipw</userinput>
<userinput>[add -bill to the end, exit]</userinput>
vipw: rebuilding the database...
vipw: done

basie&prompt.root; <userinput>cat /etc/master.passwd</userinput>

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/share/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
-bill

basie&prompt.root;
    </screen>
  </sect2>

    <sect2 id="netgroups">
      <title>Использование сетевых групп</title>

      <para><emphasis>Эта часть раздела о сетевых группах была предоставлена
	Удо Эрделхоффом (Udo Erdelhoff) <email>ue@nathan.ruhr.de</email> в
	июле 2000 года.</emphasis></para>

      <para>Способ, описанный в предыдущей главе, работает достаточно хорошо,
	если вам нужны особые правила для очень малой группы пользователей или
	машин.	В более крупных сетях вы <emphasis>забудете</emphasis> о
	запрете входа определенных пользователей на важные машины или даже
	будете настраивать каждую машину по отдельности, теряя таким образом
	главное преимущество использования NIS,
	<emphasis>централизованное</emphasis> администрирование.</para>

      <para>Ответом разработчиков NIS на эту проблему являются
	<emphasis>сетевые группы</emphasis>.  Их назначение и смысл можно
	сравнить с обычными группами, используемыми в файловых системах Unix.
	Главное отличие заключается в отсутствии числового идентификатора и
	возможности задать сетевую группу включением как пользователей, так и
	других сетевых групп.</para>

      <para>Сетевые группы были разработаны для работы с большими, сложными
	сетями с сотнями пользователей и машин.  С одной стороны, хорошо, если
	вам приходится с такой ситуацией.  С другой стороны, эта сложность
	делает невозмохным описание сетевых групп с помощью простых примеров.
	Пример, используемый в дальнейшем, демонстрирует эту проблему.</para>

      <para>Давайте предположим, что успешное внедрение системы NIS в вашей
	лаборатории заинтересовало ваше руководство.  Вашим следующим заданием
	стало расширение домена NIS для включения в него некоторых других
	машин студенческого городка.  В двух таблицах перечислены имена
	новых машин и пользователей, а также их краткое описание.</para>

      <informaltable>
      <tgroup cols="2">
      <thead>
	<row>
	  <entry>Имена пользователей</entry>
	  <entry>Описание</entry>
	</row>
      </thead>

      <tbody>
	<row>
	  <entry>alpha, beta</entry>
	  <entry>Обычные служащие IT-департамента</entry>
	</row>

	<row>
	  <entry>charlie, delta</entry>
	  <entry>Практиканты IT-департамента</entry>
	</row>
	
	<row>
	  <entry>echo, foxtrott, golf, ...</entry>
	  <entry>Обычные сотрудники</entry>
	</row>

	<row>
	  <entry>able, baker, ...</entry>
	  <entry>Проходящие интернатуру</entry>
	</row>
      </tbody>
      </tgroup>
      </informaltable>

      <informaltable>
      <tgroup cols="2">
      <thead>
	<row>
	  <entry>Имена машин</entry>
	  <entry>Описание</entry>
	</row>
      </thead>

      <tbody>
	<row>
	  <!--	Имена взяты из книги "Good Omens" (авторы Neil Gaiman и
		Terry Pratchett.  Большое спасибо за прекрасную книгу.	-->
	  <entry>war, death, famine, polution</entry>
	  <entry>Ваши самые важные серверы.  Только служащим IT позволяется
	    входить на эти машины.</entry>
	</row>

	<row>
	  <!-- gluttony был пропущен, потому что он был слишком толст ;-) -->
	  <entry>pride, greed, envy, wraith, lust, sloth</entry>
	  <entry>Менее важные серверы.	Все сотрудники департамента IT могут
	    входить на эти машины.</entry>
	</row>

	<row>
	  <entry>one, two, three, four, ...</entry>
	  <entry>Обычные рабочие станции.  Только
	    <emphasis>реально нанятым</emphasis> служащим позволяется
	    использовать эти машины.</entry>
	</row>

	<row>
	  <entry>trashcan</entry>
	  <entry>Очень старая машина без каких-либо критичных данных.  Даже
	    проходящим интернатуру разрешено ее использовать.</entry>
	</row>
      </tbody>
      </tgroup>
      </informaltable>

      <para>Если вы попытаетесь реализовать эти требования, ограничивая
	каждого пользователя по отдельности, то вам придется добавить
	на каждой машине в файл с паролями по одной строчке
	-<replaceable>user</replaceable> для каждого пользователя, которому
	запрещено входить на эту систему.  Если вы забудете даже одну строчку,
	у вас могут начаться проблемы.	Гораздо проще делать это правильно во
	время начальной установки, однако вы постепенно <emphasis>будете
	забывать</emphasis> добавлять строчки для новых пользователей во время
	повседневной работы.  В конце концов, Мерфи был оптимистом.</para>

      <para>Использование в этой ситуации сетевых групп дает несколько
	преимуществ.  Нет необходимости описывать по отдельности каждого
	пользователя; вы ставите в соответствие пользователю одну или
	несколько сетевых групп и разрешаете или запрещаете вход всем членам
	сетевой группы.  Если вы добавляете новую машину, вам достаточно
	определить ограничения на вход для сетевых групп.  Если добавляется
	новый пользователь, вам достаточно добавить его к одной или большему
	числу сетевых групп.  Эти изменения независимы друг от друга; нет
	больше комбинаций <quote>для каждого пользователя и машины</quote>.
	Если настройка вашей системы NIS тщательно спланирована, то для
	разрешения или запрещения доступа к машинам вам нужно будет
	модифицировать единственный конфигурационный файл.</para>

      <para>Первым шагом является инициализация карты NIS по имени netgroup.
	Программа ypinit во FreeBSD по умолчанию этой карты не создает, хотя
	реализация NIS будет ее поддерживает, как только она будет создана.
	Чтобы создать пустую карту, просто наберите</para>

      <screen>
ellington&prompt.root; <userinput>vi /var/yp/netgroup</userinput>
      </screen>

      <para>и начните добавлять содержимое.  Например, нам нужно по крайней
	мере четыре сетевых группы: сотрудники IT, практиканты IT, обычные
	сотрудники и интернатура.</para>

      <programlisting>
IT_EMP	(,alpha,test-domain)	(,beta,test-domain)
IT_APP	(,charlie,test-domain)	(,delta,test-domain)
USERS	(,echo,test-domain)	(,foxtrott,test-domain) \
	(,golf,test-domain)
INTERNS (,able,test-domain)	(,baker,test-domain)
      </programlisting>

      <para><literal>IT_EMP</literal>, <literal>IT_APP</literal> и так далее
	являются именами сетевых групп.  Несколько слов в скобках служат для
	добавления пользователей в группу.  Три поля внутри группы обозначают
	следующее:</para>

      <orderedlist>
	<listitem>
	  <para>Имя хоста или хостов, к которым применимы последующие записи.
	    Если имя хоста не указано, то запись применяется ко всем хостам.
	    Если же указывается имя хоста, то вы получите мир темноты, ужаса
	    и страшной путаницы.</para>
	</listitem>

	<listitem>
	  <para>Имя учетной записи, которая принадлежит этой сетевой
	    группе.</para>
	</listitem>

	<listitem>
	  <para>Домен NIS для учетной записи.  Вы можете импортировать в вашу
	    сетевую группу учетные записи из других доменов NIS, если вы один
	    из тех несчастных, имеющих более одного домена NIS.</para>
	</listitem>
      </orderedlist>

      <para>Каждое из этих полей может содержать шаблоны, подробности даны в
	странице справочника по &man.netgroup.5;.</para>

      <note>
	<para>Не нужно использовать имена сетевых групп длиннее 8 символов,
	  особенно если в вашем домене NIS имеются машины, работающие под
	  управлением других операционных систем.  Имена чувствительны к
	  регистру; использование заглавных букв для имен сетевых групп
	  облегчает распознавание пользователей, имен машин и сетевых
	  групп.</para>

	<para>Некоторые клиенты NIS (отличные от FreeBSD) не могут работать
	  с сетевыми группами, включающими большое количество записей.
	  Например, в некоторых старых версиях SunOS возникают проблемы, если
	  сетевая группа содержит более 15 <emphasis>записей</emphasis>.  Вы
	  можете обойти это ограничение, создав несколько подгрупп с 15 или
	  меньшим количеством пользователей и настоящую сетевую группу,
	  состоящую из подгрупп:</para>

	<programlisting>
BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe32,domain)  (,joe33,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3
	</programlisting>

	<para>Вы можете повторить этот процесс, если вам нужно иметь более 225
	  пользователей в одной сетевой группе.</para>
      </note>

      <para>Активация и распространение вашей карты NIS проста:</para>

      <screen>
ellington&prompt.root; <userinput>cd /var/yp</userinput>
ellington&prompt.root; <userinput>make</userinput>
      </screen>

      <para>Это приведет к созданию трех карт NIS
	<filename>netgroup</filename>, <filename>netgroup.byhost</filename> и
	<filename>netgroup.byuser</filename>.  Воспользуйтесь утилитой
	&man.ypcat.1; для проверки доступности вашей новой карты NIS:</para>

      <screen>
ellington&prompt.user; <userinput>ypcat -k netgroup</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byhost</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byuser</userinput>
      </screen>

      <para>Вывод первой команды должен соответствовать содержимому файла
	<filename>/var/yp/netgroup</filename>.	Вторая команда не выведет
	ничего, если вы не зададите сетевые группы, специфичные для хоста.
	Третья команда может использоваться пользователем для получения
	списка сетевых групп.</para>

      <para>Настройка клиента достатчно проста.  Чтобы настроить сервер
	<replaceable>war</replaceable>, вам достаточно запустить &man.vipw.8;
	и заменить строку</para>

      <programlisting>
+:::::::::
      </programlisting>

      <para>на</para>

      <programlisting>
+@IT_EMP:::::::::
      </programlisting>

      <para>Теперь только данные, касающиеся пользователей, определенных в
	сетевой группе <replaceable>IT_EMP</replaceable>, импортируются в
	базу паролей машины <replaceable>war</replaceable> и только этим
	пользователям будет разрешен вход.</para>

      <para>К сожалению, это ограичение также касается и функции ~ командного
	процессора и всех подпрограмм, выполняющих преобразование между
	именами пользователей и их численными идентификаторами.  Другими
	словами, команда cd ~<replaceable>user</replaceable> работать не
	будет, команда <command>ls -l</command> будет выдавать числовые
	идентификаторы вместо имен пользователей, а <command>find . -user
	joe -print</command> работать откажется, выдавая сообщение
	<quote>No such user</quote>.  Чтобы это исправить, вам нужно будет
	выполнить импорт всех записей о пользователях <emphasis>без
	разрешения на вход на ваши серверы</emphasis>.</para>

      <para>Это можно сделать, добавив еще одну строку в файл
	<filename>/etc/master.passwd</filename>.  Эта строка должна содержать
	<literal>+:::::::::/sbin/nologin</literal>, что означает
	<quote>Произвести импортирование всех записей с заменой командного
	процессора на <filename>/sbin/nologin</filename> в импортируемых
	записях</quote>.  Вы можете заменить любое поле в строке с паролем,
	указав значение по умолчанию в вашем
	<filename>/etc/master.passwd</filename>.</para>

      <!-- Been there, done that, got the scars to prove it - ue -->
      <warning>
	<para>Проверьте, что строка
	  <literal>+:::::::::/sbin/nologin</literal> помещена после
	  <literal>+@IT_EMP:::::::::</literal>.  В противном случае все
	  пользовательские записи, импортированные из NIS, будут иметь
	  /sbin/nologin в качестве оболочки.</para>
      </warning>

      <para>После этого изменения при появлении нового сотрудника IT вам будет
	достаточно изменять только одну карту NIS.  Вы можете применить
	подобный метод для менее важных серверов, заменяя
	старую строку <literal>+:::::::::</literal> в их файлах
	<filename>/etc/master.passwd</filename> на нечто, подобное
	следующему:</para>

      <programlisting>
+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin
      </programlisting>

      <para>Соответствующие строки для обычных рабочих станций могут иметь
	такой вид:</para>

      <programlisting>
+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin
      </programlisting>

      <para>И все было прекрасно до того момента, когда через несколько
	недель изменилась политика: Департамент IT начал нанимать интернатуру.
	Интернатуре в IT позволили использовать обычные рабочие станции и
	менее важные серверы; практикантам позволили входить на главные
	серверы.  Вы создали новую сетевую группу IT_INTERN, добавили в нее
	новую интернатуру и начали изменять настройки на всех и каждой
	машине...  Как говорит старая мудрость: <quote>Ошибки в
	централизованном планировании приводят к глобальному
	хаосу</quote>.</para>

      <para>Возможность в NIS создавать сетевые группы из других сетевых
	групп можт использоваться для предотвращения подобных ситуаций.  Одним
	из вариантов является создание сетевых групп на основе ролей.
	Например, вы можете создать сетевую группу с именем
	<replaceable>BIGSRV</replaceable> для задания ограничений на вход на
	важные серверы, другую сетевую группу с именем
	<replaceable>SMALLSRV</replaceable> для менее важных серверов и третью
	сетевую группу под названием <replaceable>USERBOX</replaceable> для
	обычных рабочих станций.  Каждая из этих сетевых групп содержит
	сетевые группы, которым позволено входить на эти машины.  Новые записи
	для вашей карты NIS сетевой группы должны выглядеть таким
	образом:</para>

      <programlisting>
BIGSRV	  IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS
      </programlisting>

      <para>Этот метод задания ограничений на вход работает весьма хорошо,
	если вы можете выделить группы машин с одинаковыми ограничениями.  К
	сожалению, такая ситуация может быть исключением, но не правилом.  В
	большинстве случаев вм нужна возможность определять ограничения на
	вход индивидуально для каждой машины.</para>

      <para>Задание сетевых групп в зависимости от машин является другой
	возможностью, которой можно воспользоваться при изменении политики,
	описанной выше.  При таком развитии событий файл
	<filename>/etc/master.passwd</filename> на каждой машине содержит две
	строки, начинающиеся с ``+''.  Первая из них добавляет сетевую группу
	с учетными записями, которым разрешено входить на эту машину, а вторая
	добавляет все оставшиеся учетные записи с
	<filename>/sbin/nologin</filename> в качестве командного процессора.
	Хорошей идеей является использование ИМЕНИ МАШИНЫ заглавными буквами
	для имени сетевой группы.  Другими словами, строки должны иметь такой
	вид:</para>

      <programlisting>
+@<replaceable>BOXNAME</replaceable>:::::::::
+:::::::::/sbin/nologin
      </programlisting>

      <para>Как только вы завершите эту работу для всех ваших машин, вам не
	нужно будет снова модифицировать локальные версии
	<filename>/etc/master.passwd</filename>.  Все будущие изменения могут
	быть выполнены изменением карты NIS.  Вот пример возможной карты
	сетевой группы для этого случая с некоторыми полезными
	дополнениями.</para>

      <programlisting>
# Сначала определяем группы пользователей
IT_EMP	  (,alpha,test-domain)	  (,beta,test-domain)
IT_APP	  (,charlie,test-domain)  (,delta,test-domain)
DEPT1	  (,echo,test-domain)	  (,foxtrott,test-domain)
DEPT2	  (,golf,test-domain)	  (,hotel,test-domain)
DEPT3	  (,india,test-domain)	  (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)	  (,lima,test-domain)
D_INTERNS (,able,test-domain)	  (,baker,test-domain)
#
# Теперь задаем несколько групп на основе ролей
USERS	  DEPT1   DEPT2     DEPT3
BIGSRV	  IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# И группы для специальных задач
# Открыть пользователям echo и golf доступ к антивирусной машине
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# Сетевые группы, специфичные для машин
# Наши главные серверы
WAR	  BIGSRV
FAMINE	  BIGSRV
# Пользователю india необходим доступ к этому серверу
POLUTION  BIGSRV  (,india,test-domain)
#
# Этот очень важен и ему требуются большие ограничения доступа
DEATH	  IT_EMP
#
# Антивирусная машина, упомянутая выше
ONE	  SECURITY
#
# Ограничить машину единственным пользователем
TWO	  (,hotel,test-domain)
# [...далее следуют другие группы]
      </programlisting>

      <para>Если вы используете какие-либо базы данных для управления
	учетными записями ваших пользователей, вы должны смочь создать первую
	часть карты с помощью инструментов построения отчетов вашей базы
	данных.  В таком случае новые пользователи автоматически получат
	доступ к машинам.</para>

      <para>И последнее замечание: Не всегда бывает разумно использовать
	сетевые группы на основе машин.  Если в студенческих лабораториях вы
	используете несколько десятков или даже сотен одинаковых машин, то
	вам нужно использовать сетевые группы на основе ролей, а не основе
	машин, для того, чтобы размеры карты NIS оставались в разумных
	пределах.</para>
    </sect2>

  <sect2>
    <title>Важные замечания</title>

    <para>Есть некоторые действия, которые нужно будет выполнять по-другому,
      если вы работаете с NIS.</para>

    <itemizedlist>
      <listitem>
	<para>Каждый раз, когда вы собираетесь добавить пользователя в
	  лаборатории, вы должны добавить его <emphasis>только</emphasis> на
	  главном сервере NIS и <emphasis>обязательно перестроить карты
	  NIS</emphasis>.  Если вы забудете сделать это, то новый
	  пользователь не сможет нигде войти, кроме как на главном сервере
	  NIS.	Например, если в лаборатории нам нужно добавить нового
	  пользователя &ldquo;jsmith&rdquo;, мы делаем вот что:</para>

	<screen>
&prompt.root; <userinput>pw useradd jsmith</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>make test-domain</userinput>
	</screen>

	<para>Вместо <command>pw useradd jsmith</command> вы можете также
	  запустить команду <command>adduser jsmith</command>.</para>
      </listitem>

      <listitem>
	<para><emphasis>Не помещайте административные учетные записи в карты
	  NIS</emphasis>.  Вам не нужно распространять административных
	  пользователей и их пароли на машины, которые не должны иметь доступ
	  к таким учетным записям.</para>
      </listitem>

      <listitem>
	<para><emphasis>Сделайте главный и вторичные серверы NIS безопасными
	  и минимизируйте их время простоя</emphasis>.	Если кто-то либо
	  взломает, либо просто отключит эти машины, то люди без права
	  входа в лабораторию с легкостью получат доступ.</para>

	<para>Это основное уязвимое место в любой централизованно
	  администрируемой системе, и это очень важный момент.	Если вы не
	  защищаете ваши серверы NIS, вы будете иметь дело с толпой
	  разозленных пользователей!</para>
      </listitem>
    </itemizedlist>
  </sect2>

  <sect2>
    <title>Совместимость с NIS v1</title>

    <para><application>ypserv</application> из поставки FreeBSD имеет
      встроенную поддержку для обслуживания клиентов NIS v1.  Реализация NIS
      во FreeBSD использует только протокол NIS v2, хотя другие реализации
      имеют поддержку протокола v1 для совместимости со старыми системами.
      Даемоны <application>ypbind</application>, поставляемые с такими
      системами, будут пытаться осуществить привязку к серверу NIS v1, даже
      если это им не нужно (и они будут постоянно рассылать широковещательные
      запросы в поиске такого сервера даже после получения ответа от сервера
      v2).  Отметьте, что хотя имеется поддержка обычных клиентских вызовов,
      эта версия ypserv не отрабатывает запросы на передачу карт v1;
      следовательно, она не может использоваться в качестве главного или
      вторичного серверов вместе с другими серверами NIS, поддерживающими
      только протокол v1.  К счастью, скорее всего, в настоящий момент
      такие серверы практически не используются.</para>
  </sect2>

  <sect2>
    <title>Серверы NIS, которые также являются клиентами NIS</title>

    <para>Особое внимание следует уделить использованию ypserv в домене со
      многими серверами, когда серверные машины являются также клиентами NIS.
      Неплохо бы заставить серверы осуществить привязку к самим себе,
      запретив рассылку запросов на привязку и возможно, перекрестную
      привязку друг к другу.  Если один сервер выйдет из строя, а другие
      будут зависеть от него, то в результате могут возникнуть странные
      ситуации.  Постепенно все клиенты попадут в таймаут и попытаются
      привязаться к другим серверам, но полученная задержка может быть
      значительной, а странности останутся, так как серверы снова могут
      привязаться друг к другу.</para>

    <para>Вы можете заставить хост выполнить привязку к конкретному серверу,
      запустив команду <command>ypbind</command> с флагом
      <option>-S</option>.</para>
  </sect2>

  <sect2>
    <title>Использование libscrypt или libdescrypt</title>

    <para>Одним из общих вопросов, которые возникают в начале работы с NIS,
      является вопрос совместимости криптографической библиотеки crypt.  Если
      ваш сервер NIS использует криптографические библиотеки DES, он сможет
      поддерживать клиентов, которые тоже используют DES.  Чтобы определить,
      что используют ваши сервер и клиенты, взгляните на символические ссылки
      в каталоге <filename>/usr/lib</filename>.  Если машина настроена на
      использование библиотек DES, это будет выглядеть примерно так:</para>

    <screen>
&prompt.user; <userinput>ls -l /usr/lib/*crypt*</userinput>
lrwxrwxrwx  1 root  wheel     13 Jul 15 08:55 /usr/lib/libcrypt.a@ -> libdescrypt.a
lrwxrwxrwx  1 root  wheel     14 Jul 15 08:55 /usr/lib/libcrypt.so@ -> libdescrypt.so
lrwxrwxrwx  1 root  wheel     16 Jul 15 08:55 /usr/lib/libcrypt.so.2@ -> libdescrypt.so.2
lrwxrwxrwx  1 root  wheel     15 Jul 15 08:55 /usr/lib/libcrypt_p.a@ -> libdescrypt_p.a
-r--r--r--  1 root  wheel  13018 Nov  8 14:27 /usr/lib/libdescrypt.a
lrwxr-xr-x  1 root  wheel     16 Nov  8 14:27 /usr/lib/libdescrypt.so@ -> libdescrypt.so.2
-r--r--r--  1 root  wheel  12965 Nov  8 14:27 /usr/lib/libdescrypt.so.2
-r--r--r--  1 root  wheel  14750 Nov  8 14:27 /usr/lib/libdescrypt_p.a
    </screen>

      <para>Если машина настроена на использование стандартных для FreeBSD
        криптографических библиотек MD5, то они будут иметь примерно такой
        вид:</para>

      <screen>
&prompt.user; <userinput>ls -l /usr/lib/*crypt*</userinput>
lrwxrwxrwx  1 root  wheel     13 Jul 15 08:55 /usr/lib/libcrypt.a@ -> libscrypt.a
lrwxrwxrwx  1 root  wheel     14 Jul 15 08:55 /usr/lib/libcrypt.so@ -> libscrypt.so
lrwxrwxrwx  1 root  wheel     16 Jul 15 08:55 /usr/lib/libcrypt.so.2@ -> libscrypt.so.2
lrwxrwxrwx  1 root  wheel     15 Jul 15 08:55 /usr/lib/libcrypt_p.a@ -> libscrypt_p.a
-r--r--r--  1 root  wheel   6194 Nov  8 14:27 /usr/lib/libscrypt.a
lrwxr-xr-x  1 root  wheel     14 Nov  8 14:27 /usr/lib/libscrypt.so@ -> libscrypt.so.2
-r--r--r--  1 root  wheel   7579 Nov  8 14:27 /usr/lib/libscrypt.so.2
-r--r--r--  1 root  wheel   6684 Nov  8 14:27 /usr/lib/libscrypt_p.a
      </screen>

      <para>Если у вас возникли проблемы с аутентификацией клиента NIS, начать
        её решать определённо стоит отсюда.  Если вы хотите
	использовать сервер NIS в гетерогенной сети, вам, наверное, нужно
	будет использовать DES на всех системах в силу того, что это
	минимальный общий стандарт.</para>
    </sect2>
  </sect1>

<sect1 id="dhcp">
  <title>DHCP</title>

  <para><emphasis>Текст написал &a.gsutter;, март 2000.</emphasis></para>

  <sect2>
    <title>Что такое DHCP?</title>

    <para>DHCP, или Dynamic Host Configuration Protocol (Протокол
      Динамической Конфигурации Хостов), описывает порядок, по которому
      система может подключиться к сети и получить необходимую информацию
      для работы в ней.  Во FreeBSD используется реализация DHCP от ISC
      (Internet Software Consortium), так что вся информация, описывающая
      особенности, зависящие от реализации, относится к дистрибутиву
      ISC.</para>
  </sect2>

  <sect2>
    <title>Что описывается в этом разделе</title>

    <para>В этом разделе Руководства делается попытка описать только те части
      системы DHCP, которые интегрированы с FreeBSD; таким образом, серверная
      часть не описывается.  Справочные страницы по DHCP, кроме ссылок,
      дающихся ниже, будут вам весьма полезны.</para>
  </sect2>

  <sect2>
    <title>Как это работает</title>

    <para>Когда на клиентской машине выполняется программа dhclient,
      являющаяся клиентом DHCP, она начинает широковещательную рассылку
      запросов на получение настроечной информации.  По умолчанию эти запросы
      делаются на 68 порт UDP.	Сервер отвечает на UDP 67, выдавая клиенту
      адрес IP и другую необходимую информацию, такую, как сетевую маску,
      маршрутизатор и серверы DNS.  Вся эта информация дается в форме
      "аренды" DHCP и верна только определенное время (что настраивается
      администратором сервера DHCP).  При таком подходе устаревшие адреса IP
      тех клиентов, которые больше не подключены к сети, могут быть
      автоматически использоваться повторно.</para>

    <para>Клиенты DHCP могут получить от сервера очень много информации.
      Подробный список находится в странице Справочника
      &man.dhcp-options.5;.</para>
  </sect2>

  <sect2>
    <title>Интеграция с FreeBSD</title>

    <para>Клиент DHCP от ISC, <command>dhclient</command>, полностью
      интегрирован во FreeBSD.	Поддержка клиента DHCP есть как в программе
      установки, так и в самой системе, что исключает необходимость в
      знании подробностей конфигурации сети в любой сети, имеющей сервер
      DHCP.  Утилита <command>dhclient</command> включена во все версии
      FreeBSD, начиная с 3.2.</para>

    <para>DHCP поддерживается утилитой <application>sysinstall</application>.
      При настройке сетевого интерфейса из программы sysinstall первый
      вопрос, который вам задается, это "Do you want to try dhcp
      configuration of this interface?" ("Хотите ли вы попробовать настроить
      этот интерфейс через dhcp?").  Утвердительный ответ приведёт к запуску
      программы dhclient, и при удачном его выполнении к автоматическому
      заданию информации для настройки интерфейса.</para>

      <para>Есть две вещи, которые вы должны сделать для того, чтобы ваша
        система использовала DHCP при загрузке:</para>

      <itemizedlist>
        <listitem>
          <para>Убедитесь, что устройство <devicename>bpf</devicename>
            включено в компиляцию вашего ядра.  Чтобы это сделать, добавьте
            строчку <literal>pseudo-device bpf</literal> в конфигурационный
            файл ядра и перестройте ядро.  Более подробная информация о
            построении ядер имеется в разделе <xref
            linkend="kernelconfig">.</para>

          <para>Устройство <devicename>bpf</devicename> уже является частью
            ядра <filename>GENERIC</filename>, которое поставляется вместе с
            FreeBSD, так что, если вы не используете другое ядро, то вам и
            не нужно его делать для того, чтобы работал DHCP.</para>

          <note>
            <para>Те, кто беспокоится о безопасности, должны иметь в виду, что
              устройство <devicename>bpf</devicename> является также тем самым
              устройством, которое позволяет работать программам-снифферам
              пакетов (хотя для этого они должны быть запущены пользователем
              root).  Наличие устройства <devicename>bpf</devicename>
              <emphasis>необходимо</emphasis> для использования DHCP, но если
              вы чересчур беспокоитесь о безопасности, то вам нельзя добавлять
              устройство <devicename>bpf</devicename> в ядро для того, чтобы
              в будущем использовать DHCP.</para>
          </note>
        </listitem>

        <listitem>
          <para>Отредактируйте ваш файл <filename>/etc/rc.conf</filename>,
            включив в него следующее:</para>

          <programlisting>
ifconfig_fxp0="DHCP"
          </programlisting>
        </listitem>
      </itemizedlist>

    <note>
      <para>Обязательно замените <literal>fxp0</literal> именем интерфейса,
	который вы хотите настроить динамически.</para>
    </note>

    <para>Если <command>dhclient</command> в вашей системе находится в другом
      месте или если вы хотите задать дополнительные параметры для
      <command>dhclient</command>, то также укажите следующее (изменив так,
      как вам нужно):</para>

    <programlisting>
dhcp_program="/sbin/dhclient"
dhcp_flags=""
    </programlisting>

    <para>Сервер DHCP, <command>dhcpd</command>, включен как часть порта
      <literal>isc-dhcp2</literal> в коллекции портов.	Этот порт содержит
      полный дистрибутив ISC DHCP, состоящий из клиента, сервера, агент
      для перенаправления запросов и документация.</para>
  </sect2>

  <sect2>
    <title>Файлы</title>

    <itemizedlist>
      <listitem>
	<para><filename>/etc/dhclient.conf</filename></para>

	<para><command>dhclient</command> требует наличия конфигурационного
	  файла, <filename>/etc/dhclient.conf</filename>.  Как правило, файл
	  содержит только комментарии, а настройки по умолчанию достаточно
	  хороши.  Этот настроечный файл описан в странице Справочника
	  &man.dhclient.conf.5;.</para>
      </listitem>

      <listitem>
	<para><filename>/sbin/dhclient</filename></para>

	<para><command>dhclient</command> скомпонован статически и находится
	  в каталоге <filename>/sbin</filename>.  На страница Справочника
	  &man.dhclient.8; дается более подробная информация о
	  <command>dhclient</command>.</para>
      </listitem>

      <listitem>
	<para><filename>/sbin/dhclient-script</filename></para>

	<para><command>dhclient-script</command> является специфичным для
	  FreeBSD скриптом настройки клиента DHCP.  Он описан в
	  &man.dhclient-script.8;, но для нормального функционирования
	  никаких модификаций со стороны пользователя не требуется.</para>
      </listitem>

      <listitem>
	<para><filename>/var/db/dhclient.leases</filename></para>

	<para>В этом файле клиент DHCP хранит базу данных выданных к
	  использованию адресов в виде журнала.  На странице
	  &man.dhclient.leases.5; дается гораздо более подробное
	  описание.</para>
      </listitem>
    </itemizedlist>
  </sect2>

  <sect2>
    <title>Дополнительная литература</title>

    <para>Полное описание протокола DHCP дается в <ulink
      url="http://www.freesoft.org/CIE/RFC/2131/">RFC 2131</ulink>.  Кроме
      того, дополнительная информация есть на сервере <ulink
      url="http://www.dhcp.org/">dhcp.org</ulink>.</para>
  </sect2>
</sect1>

</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
