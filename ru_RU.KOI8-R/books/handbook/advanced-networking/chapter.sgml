<!--
     The FreeBSD Russian Documentation Project

     $FreeBSD$
     $FreeBSDru: frdp/doc/ru_RU.KOI8-R/books/handbook/advanced-networking/chapter.sgml,v 1.85 2004/01/23 17:57:27 andy Exp $

     Original revision: 1.268
-->

<chapter id="advanced-networking">
  <title>Сложные вопросы работы в сети</title>

  <sect1 id="advanced-networking-synopsis">
    <title>Краткий обзор</title>

    <para>Эта глава посвящена некоторым наиболее часто используемым сетевым
      службам систем &unix;.  Мы опишем, как запустить, настроить,
      протестировать и поддерживать работу всех сетевых служб, используемых во
      FreeBSD.  Кроме того, для облегчения вашей работы в главу включены
      примеры конфигурационных файлов.</para>

    <para>После чтения этой главы вы будете знать:</para>

    <itemizedlist>
      <listitem>
        <para>Основные понятия о маршрутизации и маршрутах.</para>
      </listitem>

      <listitem>
        <para>Как заставить FreeBSD работать в качестве сетевого
          моста.</para>
      </listitem>

      <listitem>
        <para>Как настроить сетевую файловую систему.</para>
      </listitem>

      <listitem>
        <para>Как настроить загрузку по сети для бездисковой машины.</para>
      </listitem>

      <listitem>
        <para>Как настроить сетевой сервер информации для совместного
          использования учётных записей пользователей.</para>
      </listitem>

      <listitem>
        <para>Как настроить автоматическое конфигурирование сетевых параметров
          при помощи DHCP.</para>
      </listitem>

      <listitem>
        <para>Как настроить сервер имён.</para>
      </listitem>

      <listitem>
        <para>Как синхронизировать дату и время, а также настроить сервер
          времени с протоколом NTP.</para>
      </listitem>

      <listitem>
        <para>Как настроить трансляцию сетевых адресов.</para>
      </listitem>

      <listitem>
        <para>Как управлять даемоном <application>inetd</application>.</para>
      </listitem>

      <listitem>
        <para>Как соединить два компьютера посредством PLIP.</para>
      </listitem>

      <listitem>
        <para>Как настроить IPv6 на машине FreeBSD.</para>
      </listitem>
    </itemizedlist>

    <para>Перед чтением этой главы вы должны:</para>

    <itemizedlist>
      <listitem>
        <para>Понимать основы работы скриптов
          <filename>/etc/rc</filename>.</para>
      </listitem>

      <listitem>
        <para>Свободно владеть основными сетевыми терминами.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="network-routing">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Coranth</firstname>
          <surname>Gryphon</surname>
          <contrib>Текст предоставил</contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Сетевые шлюзы и маршруты</title>

    <indexterm><primary>маршрутизация</primary></indexterm>
    <indexterm><primary>шлюз</primary></indexterm>
    <indexterm><primary>подсеть</primary></indexterm>
    <para>Чтобы некоторая машина могла найти в сети другую, должен иметься
      механизм описания того, как добраться от одной машине к другой.  Такой
      механизм называется <firstterm>маршрутизацией</firstterm>.
      <quote>Маршрут</quote> задаётся
      парой адресов: <quote>адресом назначения</quote> (destination) и
      <quote>сетевым шлюзом</quote> (gateway).  Эта пара указывает на то, что
      если Вы пытаетесь соединиться с <emphasis>адресом назначения</emphasis>,
      то вам нужно устанавливать связь через <quote>сетевой шлюз</quote>.
      Существует три типа адресов назначения: отдельные хосты, подсети и
      <quote>маршрут по умолчанию</quote> (default).  <quote>Маршрут по
      умолчанию</quote> (default route) используется, если не подходит ни один
      из других маршрутов.  Мы поговорим немного подробнее о маршрутах по
      умолчанию позже.  Также имеется и три типа сетевых шлюзов: отдельные
      хосты, интерфейсы (также называемые <quote>подключениями</quote>
      (links)) и аппаратные адреса Ethernet (MAC-адреса).</para>

    <sect2>
      <title>Пример</title>

      <para>Для иллюстрации различных аспектов маршрутизации мы будем
        использовать следующий пример использования команды
        <command>netstat</command>:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default 	 outside-gw	    UGSc       37      418	ppp0
localhost	 localhost	    UH		0      181	 lo0
test0		 0:e0:b5:36:cf:4f   UHLW	5    63288	 ed0	 77
10.20.30.255	 link#1 	    UHLW	1     2421
example.com	 link#1 	    UC		0	 0
host1		 0:e0:a8:37:8:1e    UHLW	3     4601	 lo0
host2		 0:e0:a8:37:8:1e    UHLW	0	 5	 lo0 =>
host2.example.com link#1 	    UC		0	 0
224		 link#1 	    UC		0	 0</screen>

      <indexterm><primary>маршрут по умолчанию</primary></indexterm>

      <para>В первых двух строках задаются маршрут по умолчанию (который
        будет описан в <link linkend="network-routing-default">следующем
        разделе</link>) и маршрут на <hostid>localhost</hostid>.</para>

      <indexterm><primary>устройство loopback</primary></indexterm>
      <para>Интерфейс (колонка <literal>Netif</literal>), который указан в
        этой таблице маршрутов для использования с
        <literal>localhost</literal> и который назван
        <devicename>lo0</devicename>, имеет также второе название, устройство
        loopback.  Это значит сохранение всего трафика для указанного адреса
        назначения внутри, без посылки его по сети, так как он все равно
        будет направлен туда, где был создан.</para>

      <indexterm>
        <primary>Ethernet</primary>
        <secondary>MAC адрес</secondary>
      </indexterm>
      <para>Следующими выделяющимися адресами являются адреса, начинающиеся с
        <hostid role="mac">0:e0:...</hostid>.   Это аппаратные адреса Ethernet,
        или MAC-адреса.  FreeBSD будет автоматически распознавать любой хост
        (в нашем примере это <hostid>test0</hostid>) в локальной сети Ethernet
        и добавит маршрут для этого хоста, указывающий непосредственно на
        интерфейс Ethernet, <devicename>ed0</devicename>.  С этим типом
        маршрута также связан параметр таймаута (колонка
        <literal>Expire</literal>), используемый в случае неудачной попытки
        услышать этот хост в течении некоторого периода времени.  Если такое
        происходит, то маршрут до этого хоста будет автоматически удалён.
        Такие хосты поддерживаются
        при помощи механизма, известного как RIP (Routing Information
        Protocol), который вычисляет маршруты к хостам локальной сети при
        помощи определения кратчайшего расстояния.</para>

      <indexterm><primary>подсеть</primary></indexterm>
      <para>FreeBSD добавит также все маршруты к подсетям для локальных
        подсетей (<hostid role="ipaddr">10.20.30.255</hostid> является
        широковещательным адресом для подсети <hostid
        role="ipaddr">10.20.30</hostid>, а имя <hostid
        role="domainname">example.com</hostid> является именем домена, связанным
        с этой подсетью).  Назначение <literal>link#1</literal> соответствует
        первому адаптеру Ethernet в машине.  Отметьте отсутствие
        дополнительного интерфейса для этих строк.</para>

      <para>В обеих этих группах (хосты и подсети локальной сети) маршруты
        конфигурируются автоматически даемоном, который называется
        <application>routed</application>.  Если он не запущен, то будут
        существовать только статически заданные (то есть введенные явно)
        маршруты.</para>

      <para>Строка <literal>host1</literal> относится к нашему хосту, который
        известен по адресу Ethernet.  Так как мы являемся посылающим хостом,
        FreeBSD знает, что нужно использовать loopback-интерфейс
        (<devicename>lo0</devicename>) вместо того, чтобы осуществлять
        посылку в интерфейс Ethernet.</para>

      <para>Две строки <literal>host2</literal> являются примером того, что
        происходит при использовании алиасов в команде &man.ifconfig.8;
        (обратитесь к разделу об Ethernet для объяснения того, почему мы это
        делаем).  Символ <literal>=&gt;</literal> после интерфейса
        <devicename>lo0</devicename> указывает на то, что мы используем не
        просто интерфейс loopback (так как это адрес, обозначающий локальный
        хост), но к тому же это алиас.  Такие маршруты появляются только
        на хосте, поддерживающем алиасы; для всех остальных хостов в локальной
        сети для таких маршрутов будут показаны просто строчки
        <literal>link#1</literal>.</para>

      <para>Последняя строчка (подсеть назначения <hostid
        role="ipaddr">224</hostid>) имеет отношение к многоадресной посылке,
        которая будет рассмотрена в другом разделе.</para>

      <para>И наконец, различные атрибуты каждого маршрута перечисляются в
        колонке <literal>Flags</literal>.  Ниже приводится краткая таблица
        некоторых из этих флагов и их значений:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <tbody>
            <row>
	      <entry>U</entry>
	      <entry>Up: Маршрут актуален.</entry>
            </row>

            <row>
	      <entry>H</entry>
	      <entry>Host: Адресом назначения является отдельный хост.</entry>
            </row>

            <row>
	      <entry>G</entry>
	      <entry>Gateway: Посылать все для этого адреса назначения на
                указанную удаленную систему, которая будет сама определять
                дальнейший путь прохождения информации.</entry>
            </row>

            <row>
	      <entry>S</entry>
	      <entry>Static: Маршрут был настроен вручную, а не автоматически
	        сгенерирован системой.</entry>
            </row>

            <row>
	      <entry>C</entry>
	      <entry>Clone: Новый маршрут сгенерирован на основе указанного для
	        машин, к которым мы подключены.  Такой тип маршрута обычно
	        используется для локальных сетей.</entry>
            </row>

            <row>
	      <entry>W</entry>
	      <entry>WasCloned: Указывает на то, что маршрут был автоматически
	        сконфигурирован на основе маршрута в локальной
	        сети (Clone).</entry>
            </row>

            <row>
	      <entry>L</entry>
	      <entry>Link: Маршрут включает ссылку на аппаратный адрес
	        Ethernet.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2 id="network-routing-default">
      <title>Маршруты по умолчанию</title>

      <indexterm><primary>маршрут по умолчанию</primary></indexterm>
      <para>Когда локальной системе нужно установить соединение с удаленным
        хостом, она обращается к таблице маршрутов для того, чтобы определить,
        существует ли такой маршрут.  Если удаленный хост попадает в подсеть,
        для которой известен способ ее достижения (маршруты типа Cloned), то
        система определяет возможность подключиться к ней по этому
        интерфейсу.</para>

      <para>Если все известные маршруты не подходят, у системы имеется
        последняя возможность: маршрут <quote>default</quote>.  Это маршрут
        с особым типом сетевого шлюза (обычно единственным, присутствующим
        в системе), и в поле флагов он всегда помечен как <literal>c</literal>.
        Для хостов в локальной сети этот сетевой шлюз указывает на машину,
        имеющую прямое подключение к внешнему миру (неважно, используется ли
        связь по протоколу PPP, канал DSL, кабельный модем, T1 или какой-то
        другой сетевой интерфейс).</para>

      <para>Если вы настраиваете маршрут по умолчанию на машине, которая сама
        является сетевым шлюзом во внешний мир, то маршрутом по умолчанию
        будет являться сетевой шлюз у Вашего провайдера Интернет (ISP).</para>

      <para>Давайте взглянем на примеры маршрутов по умолчанию.  Вот типичная
        конфигурация:</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="advanced-networking/net-routing">
        </imageobject>

        <textobject>
          <literallayout class="monospaced">
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
          </literallayout>
        </textobject>
      </mediaobject>

      <para>Хосты <hostid>Local1</hostid> и <hostid>Local2</hostid> находятся в
        нашей сети.  <hostid>Local1</hostid> подключён к ISP через
        коммутируемое соединение по протоколу PPP.  Этот компьютер с сервером
        PPP подключён посредством локальной сети к другому шлюзовому компьютеру
        через внешний интерфейс самого ISP к Интернет.</para>

      <para>Маршруты по умолчанию для каждой из ваших машин будут
        следующими:</para>

      <informaltable frame="none">
        <tgroup cols="3">
          <thead>
            <row>
	      <entry>Хост</entry>
	      <entry>Маршрут по умолчанию</entry>
	      <entry>Интерфейс</entry>
            </row>
          </thead>

          <tbody>
            <row>
	      <entry>Local2</entry>
	      <entry>Local1</entry>
	      <entry>Ethernet</entry>
            </row>

            <row>
	      <entry>Local1</entry>
	      <entry>T1-GW</entry>
	      <entry>PPP</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Часто задаётся вопрос <quote>Почему (или каким образом) в качестве
        шлюза по умолчанию для машины <hostid>Local1</hostid> мы указываем
        <hostid>T1-GW</hostid>, а не сервер провайдера, к которому
        подключаемся?</quote>.</para>

      <para>Запомните, что из-за использования PPP-интерфейсом адреса в сети
        провайдера Интернет с вашей стороны соединения, маршруты для всех
        других машин в локальной сети провайдера будут сгенерированы
        автоматически.  Таким образом, вы уже будете знать, как достичь машины
        <hostid>T1-GW</hostid>, так что нет нужды в промежуточной точке при
        посылке трафика к серверу ISP.</para>

      <para>В локальных сетях адрес <hostid
        role="ipaddr">X.X.X.1</hostid> часто используется в качестве адреса
        сетевого шлюза.  Тогда (при использовании того же самого примера)
        если пространство адресов класса C вашей локальной сети было задано
        как <hostid role="ipaddr">10.20.30</hostid>, а ваш провайдер использует
        <hostid role="ipaddr">10.9.9</hostid>, то маршруты по умолчанию будут
        такие:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Хост</entry>
              <entry>Маршрут по умолчанию</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Local2 (10.20.30.2)</entry>
              <entry>Local1 (10.20.30.1)</entry>
            </row>

            <row>
              <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>
              <entry>T1-GW (10.9.9.1)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Вы можете легко задать используемый по умолчанию маршрутизатор
        посредством файла <filename>/etc/rc.conf</filename>.  В нашем примере
        на машине <hostid>Local2</hostid> мы добавили такую строку в файл
        <filename>/etc/rc.conf</filename>:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>Это также возможно сделать и непосредственно из командной строки
        при помощи команды &man.route.8;:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>Для получения дополнительной информации об управлении таблицами
        маршрутизации, обратитесь к справочной странице по команде
        &man.route.8;.</para>
    </sect2>

    <sect2>
      <title>Хосты с двойным подключением</title>

      <indexterm><primary>хосты с двойным подключением</primary></indexterm>
      <para>Есть еще один тип подключения, который мы должны рассмотреть, и это
        случай, когда хост находится в двух различных сетях.  Технически,
        любая машина, работающая как сетевой шлюз (в примере выше
        использовалось PPP-соединение), считается хостом с двойным
        подключением.  Однако этот термин реально используется для описания
        машины, находящейся в двух локальных сетях.</para>

      <para>В одном случае у машины имеется два адаптера Ethernet, каждый
        имеющий адрес в разделенных подсетях.  Как альтернативу можно
        рассмотреть вариант с одним Ethernet-адаптером и использованием
        алиасов в команде &man.ifconfig.8;.  В первом случае используются два
        физически разделённые сети Ethernet, в последнем имеется один
        физический сегмент сети, но две логически разделённые подсети.</para>

      <para>В любом случае таблицы маршрутизации настраиваются так, что для
        каждой подсети эта машина определена как шлюз (входной маршрут) в
        другую подсеть.  Такая конфигурация, при которой машина выступает в
        роли маршрутизатора между двумя подсетями, часто используется, если
        нужно реализовать систему безопасности на основе фильтрации пакетов или
        функций межсетевого экрана в одном или обоих направлениях.</para>

      <para>Если вы хотите, чтобы эта машина действительно перемещала пакеты
        между двумя интерфейсами, то вам нужно указать FreeBSD на включение
        этой функции.  Обратитесь к следующей главе, чтобы узнать, как это
        сделать.</para>
    </sect2>

    <sect2 id="network-dedicated-router">
      <title>Построение маршрутизатора</title>

      <indexterm><primary>маршрутизатор</primary></indexterm>

      <para>Сетевой маршрутизатор является обычной системой, которая
        пересылает пакеты с одного интерфейса на другой.  Стандарты Интернет и
        хорошая инженерная практика не позволяют Проекту FreeBSD включать эту
        функцию по умолчанию во FreeBSD.  Вы можете включить эту возможность,
        изменив значение следующей переменной в <literal>YES</literal> в файле
	&man.rc.conf.5;:</para>

      <programlisting>gateway_enable=YES          # Set to YES if this host will be a gateway</programlisting>

      <para>Этот параметр изменит значение &man.sysctl.8;-переменной
	<varname>net.inet.ip.forwarding</varname> в
	<literal>1</literal>.  Если вам временно нужно выключить маршрутизацию,
        вы можете на время сбросить это значение в <literal>0</literal>.</para>

      <para>Вашему новому маршрутизатору нужна информация о маршрутах для того,
        чтобы знать, куда пересылать трафик.  Если ваша сеть достаточно проста,
        то вы можете использовать статические маршруты.  С FreeBSD также
        поставляется стандартный даемон BSD для маршрутизации &man.routed.8;,
        который умеет работать с RIP (как версии 1, так и версии 2) и IRDP.
        Поддержка BGP v4, OSPF v2 и других сложных протоколов маршрутизации
        имеется в пакете <filename role="package">net/zebra</filename>.  Также
        существуют и коммерческие продукты, применяемые как более комплексное
        решение проблемы маршрутизации в сети, такие как
        <application>&gated;</application>.</para>

      <indexterm><primary>BGP</primary></indexterm>

      <indexterm><primary>RIP</primary></indexterm>

      <indexterm><primary>OSPF</primary></indexterm>

      <para>Даже когда FreeBSD настроена таким образом, она не полностью
        соответствует стандартным требованиям Интернет для маршрутизаторов.
        Однако для обычного использования такое неполное соответствие
        достаточно.</para>
    </sect2>

    <sect2>
      <title>Распространение маршрутов</title>

      <indexterm><primary>распространение маршрутов</primary></indexterm>
      <para>Мы уже говорили о том, как мы задаем наши маршруты во внешний мир,
        но не упоминали о том, как внешний мир находит нас.</para>

      <para>Мы уже знаем, что таблицы маршрутизации могут быть настроены так,
        что весь трафик для некоторого диапазона адресов (в нашем примере это
        подсеть класса C) может быть направлен заданному хосту в той сети,
        которая будет перенаправлять входящие пакеты дальше.</para>

      <para>При получении адресного пространства, выделенного Вашей сети,
        Ваш провайдер настроит свои таблицы маршрутизации так, что весь трафик
        для Вашей подсети будет пересылаться по PPP-соединению к Вашей сети.
        Но как серверы по всей стране узнают, что Ваш трафик нужно посылать
        Вашему ISP?</para>

      <para>Существует система (подобная распределению информации DNS), которая
        отслеживает все назначенные пространства адресов и определяет точку
        подключения к магистрали Интернет.  <quote>Магистралью</quote> называют
        главные каналы, по которым идет трафик Интернет внутри страны и по
        всему миру.  Каждая магистральная машина имеет копию основного набора
        таблиц, согласно которой трафик для конкретной сети направляется по
        конкретному магистральному каналу, и затем, передаваясь по цепочке
        провайдеров, он достигает вашей сети.</para>

      <para>Задачей вашего провайдера является объявить на магистрали о том,
        что он отвечает за подключение (и поэтому на него указывает маршрут)
        вашей сети.  Этот процесс называется распространением маршрута.</para>
    </sect2>

    <sect2>
      <title>Устранение неполадок</title>

      <indexterm>
        <primary>traceroute</primary>
      </indexterm>
      <para>Иногда с распространением маршрута возникают проблемы, и некоторые
        сайты не могут к вам подключиться.  Наверное, самой полезной командой
        для определения точки неверной работы маршрутизации является
        &man.traceroute.8;.  Она также полезна и когда вы сами не можете
        подключиться к удаленной машине (то есть команда &man.ping.8; не
        срабатывает).</para>

      <para>Команда &man.traceroute.8; запускается с именем удаленного хоста, с
        которым вы хотите установить соединение, в качестве параметра.  Она
        показывает промежуточные сетевые шлюзы по пути следования, в конце
        концов достигая адрес назначения или прерывая свою работу из-за
        отсутствия соединения.</para>

      <para>За дополнительной информацией обратитесь к странице Справочника по
        &man.traceroute.8;.</para>
    </sect2>

    <sect2>
      <title>Маршрутизация многоадресного трафика</title>

      <indexterm>
 	<primary>multicast</primary>

	<secondary>options MROUTING</secondary>
      </indexterm>

      <para>FreeBSD изначально поддерживает как приложения, работающие с
        многоадресным трафиком, так и его маршрутизацию.  Такие приложения не
        требуют особой настройки FreeBSD; обычно они работают сразу.
        Для маршрутизации многоадресного трафика требуется, чтобы поддержка
        этого была включена в ядро:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Кроме того, даемон многоадресной маршрутизации, &man.mrouted.8;,
        должен быть настроен посредством файла
        <filename>/etc/mrouted.conf</filename> на использование туннелей и
        DVMRP.  Дополнительную информацию о настройки многоадресного трафика
        можно найти на страницах справочной системы, посвящённых даемону
        &man.mrouted.8;.</para>
    </sect2>
  </sect1>

  <sect1 id="network-wireless">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Eric</firstname>
          <surname>Anderson</surname>
          <contrib>Текст предоставил </contrib>
        </author>

        <author>
          <firstname>Андрей</firstname>
          <surname>Захватов</surname>
          <contrib>Перевёл на русский язык</contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Беспроводные сети</title>

    <indexterm>
      <primary>беспроводные сети</primary>
    </indexterm>

    <indexterm>
      <primary>802.11</primary>
      <see>беспроводные сети</see>
    </indexterm>

    <sect2>
      <title>Введение</title>

      <para>Было бы весьма полезным иметь возможность использовать компьютер
        без хлопот, связанных с постоянно подключенным сетевым кабелем.
        FreeBSD может использоваться как клиент беспроводной сети, и даже
        в качестве <quote>точки доступа</quote> к ней.</para>
    </sect2>

    <sect2>
      <title>Режимы работы беспроводной связи</title>

      <para>Существуют два варианта конфигурации устройств беспроводного
        доступа 802.11: BSS и IBSS.</para>

      <sect3>
        <title>Режим BSS</title>                                              

        <para>Режим BSS является наиболее часто используемым.  Режим BSS также
          называют режимом инфраструктуры.  В этом режиме несколько точек
          доступа беспроводной сети подключаются к проводной сети передачи
          данных.  Каждое беспроводная сеть имеет собственное имя.  Это имя
          является идентификатором SSID сети.</para>

        <para>Клиенты беспроводной сети подключаются к этим точкам доступа
          беспроводной сети.  Стандарт IEEE 802.11 определяет протокол,
          используемый для связи в беспроводных сетях.  Клиент сети
          беспроводного доступа может подключаться к некоторой сети, если
          задан её SSID.  Клиент может также подключаться к любой сети, если
          SSID не задан.</para>
      </sect3>

      <sect3>
        <title>Режим IBSS</title>

        <para>Режим IBSS, также называемый ad-hoc, предназначен для соединений
          точка-точка.  На самом деле существуют два типа режима ad-hoc.  Один
          из них является режимом IBSS, называемый также режимом ad-hoc или
          IEEE ad-hoc.  Этот режим определён стандартами IEEE 802.11.  Второй
          режим называется демонстрационным режимом ad-hoc, или Lucent ad-hoc
          (или, иногда неправильно, режимом ad-hoc).  Это старый,
          существовавший до появления 802.11, режим ad-hoc, и он должен
          использоваться только для старых сетей. В дальнейшем мы не будем
          рассматривать ни один из режимов ad-hoc.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Режим инфраструктуры</title>

      <sect3>
        <title>Точки доступа</title>

        <para>Точки доступа представляют собой беспроводные сетевые устройства,
          позволяющие одному или большему количеству клиентов беспроводной сети
          использовать эти устройства в качестве центрального сетевого
          концентратора.  При использовании точки доступа все клиенты работают
          через неё.  Зачастую используются несколько точек доступа для полного
          покрытия беспроводной сетью некоторой зоны, такой, как дом, офис или
          парк.</para>

        <para>Точки доступа обычно имеют несколько подключений к сети: адаптер
          беспроводной связи и один или большее количество сетевых
          ethernet-адаптеров для подключения к остальной части сети.</para>

        <para>Точки доступа могут быть либо приобретены уже настроенными, либо
          вы можете создать собственную при помощи FreeBSD и поддерживаемого
          адаптера беспроводной связи.  Несколько производителей выпускают
          точки беспроводного доступа и адаптеры беспроводной связи с
          различными возможностями.</para>
      </sect3>

      <sect3>
        <title>Построение точки доступа с FreeBSD</title>

        <indexterm>
          <primary>беспроводные сети</primary>
          <secondary>точка доступа</secondary>
        </indexterm>

        <sect4>
          <title>Требования</title>

          <para>Для того, чтобы создать беспроводную точку доступа на FreeBSD,
            вам нужно иметь совместимый адаптер беспроводной связи.  На данный
            момент поддерживаются адаптеры только на основе набора микросхем
            Prism.  Вам также потребуется поддерживаемый FreeBSD адаптер
            проводной сети (найти такой будет нетрудно, FreeBSD поддерживает
            множество различных устройств).  В этом руководстве мы будем
            полагать, что вы будете строить сетевой мост (&man.bridge.4;) для
            пропуска всего трафика между устройством беспроводной связи и
            сетью, подключенной к обычному Ethernet-адаптеру.</para>

          <para>Функциональность hostap, которая используется FreeBSD для
            организации точки доступа, работает лучше всего с некоторыми
            версиями микрокода.  Адаптеры Prism 2 должны использовать микрокод
            версии 1.3.4 или более новый.  Адаптеры Prism 2.5 и Prism 3 должны
            использовать микрокод версии 1.4.9.  Более старые версии микрокода
            могут работать нормально, а могут и некорректно.  В настоящее время
            единственным способом обновления адаптеров является использование
            утилит обновления для &windows;, которые можно получить у
            производителя ваших адаптеров.</para>
        </sect4>

        <sect4>
          <title>Настройка</title>

          <para>Первым делом убедитесь, что ваша система распознаёт адаптер
            беспроводной связи:</para>

          <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7 
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
        status: no carrier
        ssid ""
        stationname "FreeBSD Wireless node"
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</screen>

          <para>На данном этапе не беспокойтесь о деталях, просто убедитесь,
            что выдаётся нечто, указывающее на установленный адаптер
            беспроводной связи.  Если при этом у вас есть проблемы с
            недоступностью интерфейса беспроводной связи, и вы используете
            PC Card, то обратитесь к страницам справочной системы, описывающим
            &man.pccardc.8; и &man.pccardd.8; для получения более полной
            информации.</para>

          <para>Теперь вам нужно загрузить модуль для подготовки той части
            FreeBSD, что отвечает за организацию сетевых мостов, для работы
            с точкой доступа.  Для загрузки модуля &man.bridge.4; просто
            выполните следующую команду:</para>

          <screen>&prompt.root; <userinput>kldload bridge</userinput></screen>

          <para>При загрузке модуля никаких сообщений об ошибках быть не
            должно.  Если это всё же произошло, вам может потребоваться
            вкомпилировать код для модуля &man.bridge.4; в ядро.  В этом вам
            должен помочь раздел Руководства об <link
            linkend="network-bridging">организации сетевых
            мостов</link>.</para>

          <para>Теперь, когда вы завершили с той частью, что касается
            организации сетевого моста, нам нужно указать ядру FreeBSD, какие
            интерфейсы должны объединяться в сетевом мосте.  Это мы делаем
            при помощи &man.sysctl.8;:</para>

          <screen>&prompt.root; <userinput>sysctl net.link.ether.bridge=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge_cfg="wi0 xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

          <para>Во &os;&nbsp;5.2-RELEASE и последующих версиях нужно
            использовать вместо указанных следующие параметры:</para>

          <screen>&prompt.root; <userinput>sysctl net.link.ether.bridge.enable=1</userinput>
&prompt.root; <userinput>sysctl net.link.ether.bridge.config="wi0 xl0"</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

          <para>Теперь необходимо настроить адаптер беспроводной сети.</para>

          <para>Следующая команда заставит адаптер работать в режиме точки
            доступа:</para>

          <screen>&prompt.root; <userinput>ifconfig wi0 ssid my_net channel 11 media DS/11Mbps mediaopt hostap up stationname "FreeBSD AP"</userinput></screen>

          <para>Строчка &man.ifconfig.8; активизирует интерфейс
            <devicename>wi0</devicename>, конфигурирует его SSID как
            <literal>my_net</literal>, а имя станции как <literal>FreeBSD
            AP</literal>.  <option>media DS/11Mbps</option> переводит адаптер в
            режим 11Mbps и нужен только для того, чтобы сработал параметр
            <option>mediaopt</option>.  Параметр <option>mediaopt
            hostap</option> переводит интерфейс в режим точки доступа.
            Параметр <option>channel 11</option> задаёт использование канала
            802.11b.  Страница справки по команде &man.wicontrol.8; перечисляет
            корректные значения каналов для ваших нужд.</para>

          <para>Теперь у вас должна получиться полнофункциональная работающая
            точка доступа.  Настоятельно советуем прочесть страницы справочной
            по &man.wicontrol.8;, &man.ifconfig.8;, и &man.wi.4; для
            получения дополнительной информации.</para>

          <para>Также полагаем, что вы прочтёте следующий раздел о
            шифровании.</para>
        </sect4>

        <sect4>                                                                 
          <title>Информация о состоянии</title>

          <para>После того, как точка доступа сконфигурирована и начала свою
            работу, операторам может понадобиться видеть клиентов, связанных
            с этой точкой.  В любой момент оператор может набрать:</para>

          <screen>&prompt.root; <userinput>wicontrol -l</userinput>             
1 station:
00:09:b7:7b:9d:16  asid=04c0, flags=3&lt;ASSOC,AUTH&gt;, caps=1&lt;ESS&gt;, rates=f&lt;1M,2M,5.5M,11M&gt;, sig=38/15</screen>

          <para>Это показывает, что имеется одна связанная станция с
            перечисленными характеристиками.  Выдаваемое значение сигнала должно
            использоваться только как сравнительный индикатор его силы.  Его
            перевод в dBm или другие единицы измерения различаются в разных
            версиях микрокода.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>Клиенты</title>

        <para>Клиент в беспроводной сети представляет собой систему, которая
          обращается к точке доступа или непосредственно к другому
          клиенту.</para>

        <para>Как правило, клиенты беспроводной сети имеют только один сетевой
          адаптер, а именно адаптер беспроводной сети.</para>

        <para>Существует несколько различных способов конфигурации клиента
          беспроводной сети.  Они основаны на различных режимах работы в
          беспроводной сети, обычно BSS (режим инфраструктуры, который требует
          точки доступа) или IBSS (ad-hoc или режим одноранговой сети).  В
          нашем примере мы будем использовать самый популярный их них, режим
          BSS, для связи с точкой доступа.</para>

        <sect4>
          <title>Требования</title>

          <para>Существует только одно жёсткое условие для настройки FreeBSD в
            качестве клиента беспроводной сети.  Вам нужен адаптер беспроводной
            связи, поддерживаемый FreeBSD.</para>
        </sect4>

        <sect4>
          <title>Конфигурация FreeBSD как клиента беспроводной сети</title>

          <para>Перед тем, как подключиться к беспроводной сети, вам нужно
            будет узнать о ней несколько вещей.  В этом примере мы подключаемся
            к сети, которая называется <literal>my_net</literal>, и шифрование
            в ней отключено.</para>

          <para>Замечание:  В этом примере мы не используем шифрование, но
            это небезопасно.  В следующем разделе вы узнаете, как её включить,
            почему это так важно, и почему некоторые технологии шифрования всё
            же не могут полностью обеспечить вашу информационную
            безопасность.</para>

          <para>Удостоверьтесь, что ваш адаптер распознаётся во FreeBSD:</para>

          <screen>&prompt.root; <userinput>ifconfig -a</userinput>
wi0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet6 fe80::202:2dff:fe2d:c938%wi0 prefixlen 64 scopeid 0x7 
        inet 0.0.0.0 netmask 0xff000000 broadcast 255.255.255.255
        ether 00:09:2d:2d:c9:50
        media: IEEE 802.11 Wireless Ethernet autoselect (DS/2Mbps)
        status: no carrier
        ssid ""
        stationname "FreeBSD Wireless node"
        channel 10 authmode OPEN powersavemode OFF powersavesleep 100
        wepmode OFF weptxkey 1</screen>

          <para>Теперь мы изменим настройки адаптера на те, что соответствуют
            нашей сети:</para>

          <screen>&prompt.root; <userinput>ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net</userinput></screen>

          <para>Замените <hostid role="IPAddr">192.168.0.20</hostid> и <hostid
            role="Netmask">255.255.255.0</hostid> на правильные IP-адрес и
            сетевую маску в вашей проводной сети.  Запомните, что наша точка
            доступа выступает в роли моста для данных между беспроводной и
            проводной сетями, так что они будут доступны для других устройств,
            находящихся в сети, как будто они тоже находятся в проводной
            сети.</para>

          <para>Как только вы это выполнили, то сможете получить ping от хостов
            в проводной сети, как будто вы подключены посредством обычных
            проводов.</para>

          <para>Если вы столкнулись с проблемами при работе в беспроводной
            сети, удостоверьтесь, что вы ассоциированы (подключены) с точкой
            доступа:</para>

          <screen>&prompt.root; <userinput>ifconfig wi0</userinput></screen>

          <para>должна выдать некоторую информацию, и вы должны увидеть:</para>

          <screen>status: associated</screen>

          <para>Если статус не будет соответствовать ассоциированному, то это
            может значить, что вы оказались вне зоны досягаемости точки
            доступа, не включили шифрование или, возможно, имеются проблемы с
            конфигурацией.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>Шифрование</title>

        <indexterm>
          <primary>беспроводные сети</primary>
          <secondary>шифрование</secondary>
        </indexterm>

        <para>Шифрование в беспроводной сети имеет важное значение, потому что
          у вас нет больше возможности ограничить сеть хорошо защищённой
          областью.  Данные вашей беспроводной сети вещаются по всей
          окрестности, так что любой заинтересовавшийся может их считать.  Вот
          здесь используется шифрование.  Шифруя данные, посылаемые в
          эфир, вы делаете их прямой перехват гораздо более сложным для всех
          любопытных.</para>

        <para>Двумя наиболее широко применяемыми способами шифрации данных
          между вашим клиентом и точкой доступа являются WEP
          и &man.ipsec.4;.</para>

        <sect4>
          <title>WEP</title>

          <indexterm>
            <primary>WEP</primary>
          </indexterm>

          <para>WEP является сокращением от Wired Equivalency Protocol
            (Протокол Соответствия Проводной сети).  WEP является попыткой
            сделать беспроводные сети такими же надёжными и безопасными, как
            проводные.  К сожалению, он был взломан и сравнительно легко
            поддаётся вскрытию.  Это означает также, что он не тот протокол,
            на который следует опираться, когда речь идёт о шифровании
            критически важных данных.</para>

          <para>Он лучше, чем ничего, так что используйте следующую команду для
            включения WEP в вашей новой точке доступа FreeBSD:</para>

          <screen>&prompt.root; <userinput>ifconfig wi0 inet up ssid my_net wepmode on wepkey 0x1234567890 media DS/11Mbps mediaopt hostap</userinput></screen>

          <para>Вы можете включить WEP на клиенте следующей командой:</para>

          <screen>&prompt.root; <userinput>ifconfig wi0 inet 192.168.0.20 netmask 255.255.255.0 ssid my_net wepmode on wepkey 0x1234567890</userinput></screen>

          <para>Отметьте, что вы должны заменить
            <literal>0x1234567890</literal> на более уникальный ключ.</para>
        </sect4>

        <sect4>
          <title>IPsec</title>

          <para>&man.ipsec.4; является гораздо более надёжным и мощным
            средством шифрования данных в сети.  Этот метод определённо
            является предпочтительным для шифрования данных в беспроводной
            сети.  Более детально ознакомиться с безопасностью и применением
            &man.ipsec.4; вы можете в разделе об <link
            linkend="ipsec">IPsec</link> Руководства.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>Утилиты</title>

        <para>Имеется несколько утилит, которые можно использовать для
          настройки и отладки вашей беспроводной сети, и здесь мы попытаемся
          описать некоторые из них и что они могут делать.</para>

        <sect4>
          <title>Пакет <application>bsd-airtools</application></title>

          <para>Пакет <application>bsd-airtools</application> представляет
            собой полный набор инструментов, включая инструменты для проверки
            беспроводной сети на предмет взлома WEP-ключа,
            обнаружения точки доступа и тому подобное.</para>
   
          <para>Утилиты <application>bsd-airtools</application> можно
            установить из порта <filename
            role="package">net/bsd-airtools</filename>.  Информацию
            об установке портов можно найти в Главе <xref linkend="ports">
            Руководства.</para>

          <para>Программа <command>dstumbler</command> является инструментом,
            предназначенным для обнаружения точки доступа и выдачи отношения
            уровня сигнала к шуму.  Если у вас с трудом получается запустить
            точку доступа, <command>dstumbler</command> может помочь вам
            начать.</para>

          <para>Для тестирования информационной безопасности вашей беспроводной
            сети, вы можете воспользоваться набором <quote>dweputils</quote>
            (<command>dwepcrack</command>, <command>dwepdump</command> и
            <command>dwepkeygen</command>), который может помочь
            понять, является ли WEP подходящим решением для обеспечения ваших
            потребностей в информационной безопасности.</para>
        </sect4>

        <sect4>
          <title>Утилиты <application>wicontrol</application>,
            <application>ancontrol</application> и
            <application>raycontrol</application></title>

          <para>Это инструменты, которые используются для управления поведением
            адаптера беспроводной связи в сети.  В примере выше мы выбирали
            &man.wicontrol.8;, так как нашим адаптером беспроводной сети был
            интерфейс <devicename>wi0</devicename>.  Если у вас установлено
            устройство беспроводного доступа от Cisco, этим интерфейсом будет
            <devicename>an0</devicename>, и тогда вы будете
            использовать &man.ancontrol.8;.</para>
        </sect4>

        <sect4>
          <title>Команда <application>ifconfig</application></title>

          <indexterm>
            <primary>ifconfig</primary>
          </indexterm>

          <para>Утилита &man.ifconfig.8; может использоваться для установки
            многих из тех параметров, что задаёт &man.wicontrol.8;, однако
            работа с некоторыми параметрами в ней отсутствует.  Обратитесь к
            &man.ifconfig.8; для выяснения параметров и опций командной
            строки.</para>
        </sect4>
      </sect3>

      <sect3>
        <title>Поддерживаемые адаптеры</title>

        <sect4>
          <title>Точки доступа</title>

          <para>Единственными адаптерами, которые на данный момент
            поддерживаются в режиме BSS (как точка доступа), являются те
            устройства, что сделаны на основе набора микросхем Prism 2, 2.5
            или 3).  Полный список можно увидеть в &man.wi.4;.</para>
        </sect4>

        <sect4>
          <title>Клиенты</title>

          <para>Практически все адаптеры беспроводной связи 802.11b на данный
            момент во FreeBSD поддерживаются.  Большинство адаптеров,
            построенных на основе Prism, Spectrum24, Hermes, Aironet и Raylink,
            будут работать в качестве адаптера беспроводной сети в режиме
            IBSS (ad-hoc, одноранговая сеть и BSS).</para>
        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-bluetooth">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Pav</firstname>

          <surname>Lucistnik</surname>

          <contrib>Текст предоставил</contrib>

          <affiliation>
            <address><email>pav@oook.cz</email></address>
          </affiliation>
        </author>
      </authorgroup>
    </sect1info>

    <title>Bluetooth</title>

    <indexterm><primary>Bluetooth</primary></indexterm>

    <sect2>
      <title>Введение</title>

      <para>Bluetooth является беспроводной технологией для создания
        персональных сетей на расстоянии не более 10 метров, работающей на
        частоте 2.4 ГГц, которая не подлежащит лицензированию.  Обычно такие
        сети формируются из портативных устройств, таких, как сотовые телефоны,
        КПК и лаптопы.  В отличие от Wi-Fi, другой популярной беспроводной
        технологии, Bluetooth предоставляет более высокий уровень сервиса,
        например, файловые серверы типа FTP, передачу файлов, голоса, эмуляцию
        последовательного порта и другие.</para>

      <para>Стек протоколов Bluetooth во &os; реализован на основе технологии
        Netgraph (обратитесь к &man.netgraph.4;).  Широкий спектр USB-устройств
        Bluetooth поддерживается драйвером &man.ng.ubt.4;.  Устройства
        Bluetooth на основе набора микросхем Broadcom BCM2033 поддерживается
        драйвером &man.ng.bt3c.4;.  Устройства Bluetooth, работающие через
        последовательные и UART-порты, поддерживаются драйверами &man.sio.4;,
        &man.ng.h4.4; и &man.hcseriald.8;. В этой главе описывается
        использование Bluetooth-устройств, подключаемых через USB.  Поддержка
        Bluetooth имеется во &os; 5.0 и более новых версиях системы.</para>
    </sect2>

    <sect2>
      <title>Подключение устройства</title>

      <para>По умолчанию драйверы устройств Bluetooth поставляются в виде
        модулей ядра.  Перед подключением устройства вам необходимо подгрузить
        драйвер в ядро.</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Если Bluetooth-устройство в момент запуска системы подключено, то
        загружайте модуль из файла
        <filename>/boot/loader.conf</filename>.</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Подключите ваше USB-устройство.  На консоли (или в журнале
        syslog) появится примерно такое сообщение.</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>Скопируйте файл
        <filename>/usr/share/examples/netgraph/bluetooth/rc.bluetooth</filename>
        в какое-нибудь подходящее место, например, в файл
        <filename>/etc/rc.bluetooth</filename>.  Этот скрипт используется для
        запуска и остановки работы Bluetooth-стека.  Перед отключением
        устройства рекомендуется остановить его работы, хотя (обычно) это не
        фатально.  При запуске стека вы получите сообщения, подобные
        следующим:</para>

      <screen>&prompt.root; <userinput>/etc/rc.bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>
    </sect2>

    <indexterm><primary>HCI</primary></indexterm>

    <sect2>
      <title>Host Controller Interface (HCI)</title>

      <para>Host Controller Interface (HCI) предоставляет интерфейс для
        управления контроллером передатчика и менеджером соединений, а также
        доступ к данным о состоянии оборудования и его управляющим регистрам.
        Этот интерфейс предоставляет унифицированный метод доступа к
        передающим возможностям Bluetooth.  Уровень HCI на управляющей машине
        обменивается данными и командами с микрокодом HCI в оборудовании
        Bluetooth.  Драйвер для Host Controller Transport Layer (то есть
        физической шины) предоставляет обоим слоям HCI возможность обмениваться
        данными друг с другом.</para>

      <para>Для одного Bluetooth-устройства создаётся один узел Netgraph типа
        <emphasis>hci</emphasis>.  HCI-узел обычно подключается к узлу драйвера
        устройства Bluetooth (входящий поток) и к узлу L2CAP (исходящий поток).
        Все операции с HCI должны выполняться на узле HCI, но не на узле
        драйвера устройства.  В качестве имени по умолчанию для узла HCI
        используется <quote>devicehci</quote>.  Дополнительные подробности
        можно найти на справочной странице &man.ng.hci.4;.</para>

      <para>Одной из самой часто выполняемой задач является обнаружение
        Bluetooth-устройств в радиусе RF-доступности.  Эта операция называется
        <emphasis>опросом</emphasis> (inquiry).  Опрос и другие операции,
        связанные с HCI, выполняются при помощи утилиты &man.hccontrol.8;.
        Пример ниже показывает, как найти доступные устройства Bluetooth.
        Список таких устройств должен быть получен в течение нескольких секунд.
        Заметьте, что удалённые устройства будут отвечать на опрос, если только
        они находятся в режиме <emphasis>обнаруживаемости</emphasis>
        (discoverable).</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para><literal>BD_ADDR</literal> является уникальным адресом устройства
        Bluetooth, вроде MAC-адресов сетевых адаптеров.  Этот адрес необходим
        для дальнейшей работы с устройством.  Адресу BD_ADDR можно присвоить
        удобное для чтения имя.  Файл <filename>/etc/bluetooth/hosts</filename>
        содержит информацию об известных хостах Bluetooth.  В следующем примере
        показано, как получить имя, назначенное удалённому устройству.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>Если вы выполните опрос на другом Bluetooth-устройстве, но ваш
        компьютер будет опознан как <quote>your.host.name (ubt0)</quote>.
        Имя, назначаемое локальному устройству, может быть в любой момент
        изменено.</para>

      <para>Система Bluetooth предоставляет услуги по соединениям типа
        точка-точка (при этом задействованы только два устройства Bluetooth)
        или точка-ко-многим-точкам.  В последнем случае соединение используется
        совместно несколькими устройствам Bluetooth.  В следующем примере
        показывается, как получить список активных для локального устройства
        соединений.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>Идентификатор соединения (<emphasis>connection handle</emphasis>)
        полезен, когда необходимо прекратить соединение.  Заметьте, что обычно
        нет нужды делать это вручную.  Стек будет автоматически разрывать
        неактивные соединения.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Обратитесь к помощи посредством <command>hccontrol help</command>
        для получения полного списка доступных HCI-команд.  Большинство команд
        HCI для выполнения не требуют прав администратора системы.</para>
    </sect2>

    <indexterm><primary>L2CAP</primary></indexterm>

    <sect2>
      <title>Logical Link Control and Adaptation Protocol (L2CAP)</title>

      <para>Протокол L2CAP (Logical Link Control and Adaptation Protocol)
        предоставляет услуги по работе с данными, как ориентированные на
        соединения, так и без ориентации на них, протоколам более высокого
        уровня с возможностями мультиплексирования и обеспечением операций по
        сегментации и обратной сборке.  L2CAP позволяет протоколам более
        высокого уровня и приложениям передавать и получать пакеты данных
        L2CAP длиной до 64 Кбайт.</para>

      <para>L2CAP основан на концепции <emphasis>каналов</emphasis>.  Каналом
        является логическое соединение поверх соединения по радиоканалу.
        Каждый канал привязан к некоторому протоколу по принципу
        многие-к-одному.  Несколько каналов могут быть привязаны к одному и
        тому же протоколу, но канал не может быть привязан к нескольким
        протоколам.  Каждый пакет L2CAP, получаемый каналом, перенаправляется
        к соответствующему протоколу более высокого уровня.  Несколько каналов
        могут совместно использовать одно и то же радиосоединение.</para>

      <para>Для одного Bluetooth-устройства создается один узел Netgraph типа
        <emphasis>l2cap</emphasis>.  Узел L2CAP обычно подключается к узлу
        Bluetooth HCI (нижестоящий) и узлам Bluetooth-сокетов (вышестоящие).
        По умолчанию для узла L2CAP используется имя
        <quote>devicel2cap</quote>.  Для получения дополнительной информации
        обратитесь к справочной странице по &man.ng.l2cap.4;.</para>

      <para>Полезной является программа &man.l2ping.8;, которая может
        использоваться для проверки связи с другими устройствами.  Некоторые
        реализации Bluetooth могут не возвращать все данные, посылаемые им,
        так что <emphasis>0 bytes</emphasis> в следующем примере - это
        нормально.</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>Утилита &man.l2control.8; используется для выполнения различных
        операций с узлами L2CAP.  В этом примере показано, как получить список
        логических соединений (каналов) и перечень радиосоединений локального
        устройства.</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

      <para>Ещё одним диагностическим инструментом является &man.btsockstat.1;.
        Она выполняет действия, подобные тем, что обычно выполняет
        &man.netstat.1;, но со структурами данных, связанных с работой в сети
        Bluetooth.  В примере ниже описывается то же самое логическое
        соединение, что и с &man.l2control.8; выше.</para>

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>
    </sect2>

    <indexterm><primary>RFCOMM</primary></indexterm>

    <sect2>
      <title>Протокол RFCOMM</title>

      <para>Протокол RFCOMM эмулирует последовательные порты поверх протокола
        L2CAP.  Он основан на ETSI-стандарте TS 07.10.  RFCOMM представляет
        собой простой транспортный протокол, с дополнительными возможностями по
        эмуляции 9 цепей последовательных портов RS-232 (EIATIA-232-E).
        Протокол RFCOMM поддерживает одновременно до 60 соединений (каналов
        RFCOMM) между двумя устройствами Bluetooth.</para>

      <para>В рамках RFCOMM полный коммуникационный маршрут включает два
        приложения, работающие на разных устройствах (конечные коммуникационные
        точки) с коммуникационным сегментом между ними.  RFCOMM предназначен
        для сокрытия приложений, использующих последовательные порты устройств,
        в которых они расположены.  Коммуникационный сегмент по сути является
        Bluetooth-связью от одного устройства к другому (прямое
        соединение).</para>

      <para>RFCOMM имеет дело с соединением между устройствами в случае прямого
        соединения, или между устройством и модемом в сетевом случае.  RFCOMM
        может поддерживать и другие конфигурации, такие, как модули, работающие
        через беспроводную технологию Bluetooth с одной стороны и
        предоставляющие проводное соединение с другой стороны.</para>

      <para>Во &os; протокол RFCOMM реализован на уровне сокетов
        Bluetooth.</para>
    </sect2>

    <indexterm><primary>pairing</primary></indexterm>

    <sect2>
      <title>Pairing of Devices</title>

      <para>По умолчанию связь Bluetooth не аутентифицируется, поэтому любое
        устройство может общаться с любым другим.  Устройство Bluetooth
        (например, сотовый телефон) может задать обязательность аутентификации
        для предоставления определённого сервиса (в частности, услугу доступа
        по коммутируемой линии).  Bluetooth-аутентификация обычно выполняется
        через <emphasis>PIN-коды</emphasis>.  PIN-код представляет из себя
        ASCII-строку длиной до 16 символов.  Пользователь обязан ввести один и
        тот же PIN-код на обоих устройствах.  Как только он введёт PIN-код,
        оба устройства сгенерируют <emphasis>ключ связи</emphasis>.  После
        этого ключ может быть сохранён либо в самом устройстве, либо на
        постоянном носителе.  В следующий раз оба устройства будут использовать
        ранее сгенерированный ключ соединения.  Процедура, описанная выше,
        носит название <emphasis>подгонки пары</emphasis> (pairing).  Заметьте,
        что если ключ связи потерян любой из сторон, то подбор пары должен быть
        повторен.</para>

      <para>За обработку всех запросов на Bluetooth-аутентификацию отвечает
        даемон &man.hcsecd.8;.  По умолчанию файл конфигурации называется
        <filename>/etc/bluetooth/hcsecd.conf</filename>.  Пример раздела,
        содержащего информацию о сотовом телефоне с явно заданным PIN-кодом
        <quote>1234</quote> приведен ниже.</para>

      <programlisting>device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</programlisting>

      <para>Кроме длины, на PIN-коды не накладывается никаких ограничений.
        Некоторые устройства (например, Bluetooth-гарнитуры) могут иметь
        фиксированный встроенный PIN-код.  Параметр <option>-d</option>
        позволяет запустить &man.hcsecd.8; как нефоновый процесс, что облегчает
        просмотр происходящих событий.  Задайте получение парного ключа на
        удалённом устройстве и инициируйте Bluetooth-соединение с этим
        устройством.  Удалённое устройство должно подтвердить получение пары и
        запросить PIN-код.  Введите тот же самый код, что находится в
        <filename>hcsecd.conf</filename>.  Теперь ваш ПК и удалённое устройство
        спарены.  Альтернативным способом является инициация процесса создания
        пары на удалённом устройстве.  Ниже даётся пример выдачи протокола
        команды <command>hcsecd</command>.</para>

<programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>
    </sect2>

    <indexterm><primary>SDP</primary></indexterm>

    <sect2>
      <title>Service Discovery Protocol (SDP)</title>

      <para>Протокол обнаружения сервисов SDP даёт возможность клиентским
        приложениям осуществлять поиск услуг, предоставляемых серверными
        приложениями, а также характеристик этих услуг.  В перечень атрибутов
        сервиса включается тип класса предлагаемого сервиса и информация о
        механизме или протоколе, требуемом для использования сервиса.</para>

      <para>SDP подразумевает коммуникации между SDP-сервером и SDP-клиентом.
        Сервер поддерживает список сервисов, в котором описываются параметры
        сервисов, связанных с сервером.  Каждая запись об услуге содержит
        информацию об одном сервисе.  Клиент может запросить информацию об
        опеределённом сервисе, обслуживаемом SDP-сервером, выдавая SDP-запрос.
        Если клиент или приложение, связанное с клиентом, решат воспользоваться
        сервисом, то для его использования необходимо открыть отдельное
        соединение к устройству, предоставляющему сервис.  SDP предоставляет
        механизм обнаружения услуг и их параметров, но не даёт механизма
        использования этих сервисов.</para>

      <para>Обычно SDP-клиент выполняет поиск услуг на основе некоторых
        желаемых характеристик услуг.  Однако иногда возникает необходимость
        выяснить полный перечень типов услуг, предоставляемых SDP-сервером,
        не имея никакой информации об имеющихся сервисах.  Такой процесс
        всех предлагаемых сервисов называется <emphasis>обзором</emphasis>
        (browsing).</para>

      <para>Существующие на данный момент серверы и клиенты SDP реализованы в
        пакете стороннего разработчика <application>sdp-1.5</application>,
        который можно сгрузить <ulink
        url="http://www.geocities.com/m_evmenkin/">здесь</ulink>.  Утилита
        <application>sdptool</application> является SDP-клиентом, управляемым
        из командной строки.  В следующем примере показано, как выполнять
        запрос на SDP-обзор.</para>

      <screen>&prompt.root; <userinput>sdptool browse 00:80:37:29:19:a4</userinput>
Browsing 00:80:37:29:19:A4 ...
Service Name: Dial-up Networking
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 1

Service Name: Fax
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 2

Service Name: Voice gateway
Service Class ID List:
 "Headset Audio Gateway" (0x1112)
 "Generic Audio" (0x1203)
Protocol Descriptor List:
 "L2CAP" (0x0100)
 "RFCOMM" (0x0003)
   Channel: 3</screen>

      <para>... и так далее.  Заметьте, что каждый сервис имеет перечень
        атрибутов (например, канал RFCOMM).  В зависимости от сервиса вам может
        потребоваться где-то сохранить эти атрибуты.  Некоторые реализации
        Bluetooth не поддерживают просмотр сервисов и могут возвращать пустой
        список.  В этом случае возможен поиск конкретной услуги.  В примере
        ниже показано, как выполнить поиск службы OBEX Object Push
        (OPUSH).</para>

      <screen>&prompt.root; <userinput>sdptool search --bdaddr 00:07:e0:00:0b:ca OPUSH</userinput></screen>

      <para>Во &os; предоставление сервисов клиентам Bluetooth осуществляется
        сервером <application>sdpd</application>.</para>

      <screen>&prompt.root; <userinput>sdpd</userinput></screen>

      <para>Для регистрации сервиса в локальном SDP-сервере также применяется
        утилита <application>sdptool</application>.  В примере ниже
        показывается, как зарегистрировать Network Access с услугой PPP (LAN).
        Заметьте, что некоторые сервисы требуют указания их атрибутов
        (например, канала RFCOMM).</para>

      <screen>&prompt.root; <userinput>sdptool add --channel=7 LAN</userinput></screen>

      <para>Перечень сервисов, зарегистрированных в локальном SDP-сервере,
        может быть получен посылкой SDP-запроса на просмотр
        <quote>специального</quote> адреса BD_ADDR.</para>

      <screen>&prompt.root; <userinput>sdptool browse ff:ff:ff:00:00:00</userinput></screen>
    </sect2>

    <sect2>
      <title>Доступ к сети по коммутируемой линии связи (DUN) и по протоколу
        PPP (LAN)</title>

      <para>Модуль работы с коммутируемым доступом к сети (DUN - Dial-Up
        Networking) в большинстве случаев используется с модемами и сотовыми
        телефонами.  Этот модуль покрывает следующие случаи:</para>

      <itemizedlist>
        <listitem>
          <para>сотовый телефон или модем используется вместе с компьютером
            в качестве беспроводного модема для подключения к серверу
            коммутируемого доступа в Интернет, или другой коммутируемой
            услуге;</para>
        </listitem>

        <listitem>
          <para>сотовый телефон или модем используется компьютером для приёма
            входящих соединений.</para>
        </listitem>
      </itemizedlist>

      <para>Модуль доступа к сети по протоколу PPP (Network Access with
        PPP - LAN) может использоваться в следующих ситуациях:</para>

      <itemizedlist>
        <listitem>
          <para>доступ к ЛВС для одного Bluetooth-устройства;</para>
        </listitem>

        <listitem>
          <para>доступ к ЛВС для нескольких Bluetooth-устройств;</para>
        </listitem>

        <listitem>
          <para>связь между двумя ПК (при помощи протокола PPP поверх
            эмулируемого последовательного канала связи).</para>
        </listitem>
      </itemizedlist>

      <para>Во &os; оба случая реализуются при помощи сервисных программ
        &man.ppp.8; и &man.rfcomm.pppd.8; - это обработчик, преобразующий
        RFCOMM-соединения Bluetooth в нечто, с чем может работать PPP.  Перед
        тем, как использовать любой модуль, в файле
        <filename>/etc/ppp/ppp.conf</filename> должна быть создана новая
        PPP-метка.  Примеры использования можно найти в справочной странице к
        &man.rfcomm.pppd.8;.</para>

      <para>В следующем примере &man.rfcomm.pppd.8; будет использоваться для
        открытия RFCOMM-соединения к удалённому устройству с BD_ADDR
        00:80:37:29:19:a4 на DUN RFCOMM-канале.  Реальный номер RFCOMM-канала
        будет получаться с удалённого устройства через SDP.  Возможно указать
        RFCOMM-канал вручную, и в этом случае &man.rfcomm.pppd.8; не будет
        выполнять SDP-запрос.  Для нахождения RFCOMM-канала на удалённом
        устройстве используйте утилиту
        <application>sdptool</application>.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>Для того, чтобы организовать сервис Network Access with PPP (LAN),
        необходимо запустить сервер <application>sdpd</application>.  Также
        необходимо зарегистрировать сервис LAN на локальном SDP-сервере.
        Заметьте, что сервис LAN требует наличия RFCONN-канала.  В файле
        <filename>/etc/ppp/ppp.conf</filename> должна быть создана новая запись
        для клиентов LAN.  Примеры можно найти в справке по
        &man.rfcomm.pppd.8;.  Наконец, должен быть запущен сервер RFCOMM PPP,
        который работает и прослушивает на том же самом RFCOMM-канале, что
        зарегистрирован на локальном SDP-сервере.  В примере ниже показано, как
        запустить сервер RFCOMM PPP.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>
    </sect2>

    <indexterm><primary>OBEX</primary></indexterm>

    <sect2>
      <title>OBEX Push (OPUSH) Profile</title>

      <para>OBEX является широкоиспользуемым протоколом для простой передачи
        файлов между мобильными устройствами.  В основном он используется в
        коммуникациях через инфракрасный порт для передачи файлов между
        ноутбуками или КПК компании Palm, а также для пересылки визитных
        карточек или календарных планов между сотовыми телефонами и
        другими устройствами с персональными информационными
        менеджерами.</para>

      <para>Сервер и клиент OBEX реализованы в виде пакета стороннего
        разработчика <application>obexapp-1.0</application>, который можно
        сгрузить <ulink
        url="http://www.geocities.com/m_evmenkin/">отсюда</ulink>.  Пакет
        требует наличия библиотеки <application>openobex</application> (она
        включена в пакет) и порта <filename
        role="package">devel/glib12</filename>.  Заметьте, что для работы
        <application>obexapp</application> привилегий администратора системы
        не требуются.</para>

      <para>Клиент OBEX используется для посылки или приёма объектов с сервера
        OBEX.  Объектом, к примеру, может быть визитная карточка или
        указание.  Клиент OBEX может получить номер RFCOMM-канала, указав
        вместо него имя сервиса.  Поддерживаются следующие имена сервиса: IrMC,
        FTRN и OPUSH.  Канал RFCOMM можно задать его номером.  Ниже даётся
        пример сеанса OBEX, где с сотового телефона забирается объект с
        информацией об устройстве, а новый объект (визитная карточка)
        передаётся в каталог сотового телефона.</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get
get: remote file&gt; telecom/devinfo.txt
get: local file&gt; devinfo-t39.txt
Success, response: OK, Success (0x20)
obex&gt; put
put: local file&gt; new.vcf
put: remote file&gt; new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>Для того, чтобы предоставить сервис OBEX Push, должен быть запущен
        сервер <application>sdpd</application>.  Он также требуется и для
        регистрации услуги OPUSH на локальном SDP-сервере.  Заметьте, что
        сервис OPUSH требует для своей работы RFCOMM-канал.  Должен быть создан
        корневой каталог, в котором будут сохраняться все поступающие объекты.
        По умолчанию корневым каталогом является
        <filename>/var/spool/obex</filename>.  Наконец, сервер OBEX должен
        работать и прослушивать тот же самый RFCOMM-канал, что зарегистрирован
        на локальном SDP-сервере.  В примере ниже показано, как запустить
        OBEX-сервер.</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>
    </sect2>

    <sect2>
      <title>Модуль последовательного порта (SP)</title>

      <para>Модуль последовательного порта (SP - Serial Port) позволяет
        Bluetooth-устройству осуществлять эмуляцию последовательного порта
        RS232 (или подобного).  Этот модуль покрывает случаи, касающиеся
        работы унаследованных приложений с Bluetooth в качестве замены
        кабельному соединению, при это используется абстракция виртуального
        последовательного порта.</para>

      <para>Утилита &man.rfcomm.sppd.1; является модулем, реализующим
        последовательный порт.  В качестве виртуального последовательного порта
        используется псевдотерминал.  В примере ниже показано, как подключиться
        к сервису Serial Port удалённого устройства.  Заметьте, что вы не
        указываете RFCOMM-канал - &man.rfcomm.sppd.1; может получить его с
        удалённого устройства через SDP.  Если вы хотите переопределить это,
        укажите RFCOMM-канал явно в командной строке.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>После подключения псевдотерминал можно использовать как
        последовательный порт.</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>
    </sect2>

    <sect2>
      <title>Решение проблем</title>

      <sect3>
        <title>Удалённое устройство не подключается</title>

        <para>Некоторые старые Bluetooth-устройства не поддерживают
          переключение ролей.  По умолчанию, когда &os; подтверждает новое
          соединение, она пытается выполнить переключение роли и стать ведущим
          устройством.  Устройства, которые это не поддерживают, не смогут
          подключиться.  Заметьте, что переключение ролей выполняется при
          установлении нового соединения, поэтому невозможно выяснить,
          поддерживает ли удалённое устройство переключение ролей.  На
          локальной машине имеется возможность отключить переключение ролей при
          помощи HCI-параметра.</para>

        <screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>
      </sect3>

      <sect3>
        <title>Что-то идёт не так, можно ли посмотреть, что в точности
          происходит?</title>

        <para>Да, можно.  Воспользуйтесь пакетом
          <application>hcidump-1.5</application> стороннего разработчика,
          который доступен для сгрузки <ulink
          url="http://www.geocities.com/m_evmenkin/">здесь</ulink>.  Утилита
          <application>hcidump</application> похожа на &man.tcpdump.1;.  Она
          может использоваться для вывода на терминал содержимого
          Bluetooth-пакетов и сбрасывать пакеты Bluetooth в файл.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-bridging">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Steve</firstname>
          <surname>Peterson</surname>
          <contrib>Текст создал</contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Мосты</title>

    <sect2>
      <title>Введение</title>

      <indexterm><primary>подсеть IP</primary></indexterm>
      <indexterm><primary>сетевой мост</primary></indexterm>
      <para>Иногда полезно разделить одну физическую сеть (такую, как
        сегмент Ethernet) на два отдельных сегмента сети без необходимости
        создания подсетей IP и использования маршрутизатора для соединения
        сегментов.  Устройство, которое соединяет две сети на такой манер,
        называется <quote>сетевым мостом</quote> (<quote>bridge</quote>).
        Система FreeBSD с двумя сетевыми адаптерами может выступать в роли
        моста.</para>

      <para>Мост работает на основе изучения адресов уровня MAC (адресов
        Ethernet) устройств на каждом из своих сетевых интерфейсах.
        Он перенаправляет трафик между двумя сетями, только когда адреса
        отправителя и получателя находятся в разных сетях.</para>

      <para>По многим параметрам мост работает также, как коммутатор Ethernet
        с малым количеством портов.</para>
    </sect2>

    <sect2>
      <title>Ситуации, когда можно использовать мосты</title>

      <para>На сегодняшний день есть две ситуации, когда можно использовать
        мост.</para>

      <sect3>
        <title>Большой трафик в сегменте</title>

        <para>Первая ситуация возникает, когда ваша физическая сеть перегружена
	  трафиком, но по каким-то соображениям вы не хотите разделять сеть
	  на подсети и соединять их с помощью маршрутизатора.</para>

        <para>Давайте рассмотрим в качестве примера газету, в которой
	  редакторский и производственный отделы находятся в одной и той же
	  подсети.  Пользователи в редакторском отделе все используют сервер
          <hostid>A</hostid> для служб доступа к файлам, а пользователи
          производственного отдела используют сервер <hostid>B</hostid>.  Для
          объединения всех пользователей используется сеть Ethernet, а высокая
          нагрузка на сеть замедляет работу.</para>

        <para>Если пользователи редакторского отдела могут быть собраны в
	  одном сегменте сети, а пользователи производственного отдела в
	  другом, то два сетевых сегмента можно объединить мостом.  Только
	  сетевой трафик, предназначенный для интерфейсов с
          <quote>другой</quote> стороны моста, будет посылаться в другую сеть,
          тем самым снижая уровень нагрузки на каждый сегмент сети.</para>
      </sect3>

      <sect3>
        <title>Межсетевой экран с возможностями фильтрации/ограничения
	  пропускной способности трафика</title>

        <indexterm><primary>межсетевой экран</primary></indexterm>

        <indexterm><primary>трансляция сетевых адресов</primary></indexterm>

        <para>Второй распространенной ситуацией является необходимость в
	  обеспечении функций межсетевого экрана без трансляции
	  сетевых адресов (NAT).</para>

        <para>Для примера можно взять маленькую компанию, которая подключена
	  к своему провайдеру по каналу DSL или ISDN.  Для неё провайдер выделил
          13 глобально доступных IP-адресов для имеющихся в сети 10 персональных
	  компьютеров.  В такой ситуации использование межсетевого экрана
	  на основе маршрутизатора затруднено из-за проблем с разделением на
	  подсети.</para>

        <indexterm><primary>маршрутизатор</primary></indexterm>
        <indexterm><primary>DSL</primary></indexterm>
        <indexterm><primary>ISDN</primary></indexterm>
        <para>Межсетевой экран на основе моста может быть настроен и включен
	  между маршрутизаторами DSL/ISDN без каких-либо проблем с
	  IP-адресацией.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Настройка моста</title>

      <sect3>
        <title>Выбор сетевого адаптера</title>

        <para>Для работы моста требуются по крайней мере два сетевых адаптера.
	  К сожалению, не все сетевые адаптеры во FreeBSD&nbsp;4.0 поддерживают
	  функции моста.  Прочтите страницу Справочника по &man.bridge.4; для
	  выяснения подробностей о поддерживаемых адаптерах.</para>

        <para>Перед тем, как продолжить, сначала установите и протестируйте
	  два сетевых адаптера.</para>
      </sect3>

      <sect3>
        <title>Изменения в конфигурации ядра</title>

        <indexterm>
          <primary>параметры ядра</primary>
          <secondary>options BRIDGE</secondary>
        </indexterm>

        <para>Для включения поддержки функций моста в ядре, добавьте
	  строчку</para>

        <programlisting>options BRIDGE</programlisting>

        <para>в файл конфигурации вашего ядра, и перестройте ядро.</para>
      </sect3>

      <sect3>
        <title>Поддержка функций межсетевого экрана</title>

        <indexterm><primary>межсетевой экран</primary></indexterm>

        <para>Если вы планируете использовать мост в качестве межсетевого
          экрана, вам нужно также добавить опцию <literal>IPFIREWALL</literal>.
          Прочтите раздел <xref linkend="firewalls">, содержащий общую
          информацию о настройке моста в качестве межсетевого экрана.</para>

        <para>Если вам необходимо обеспечить прохождение не-IP пакетов (таких,
	  как ARP) через мост, то имеется опция межсетевого
	  экрана, которую можно задать.  Это опция
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal>.  Заметьте, что при
	  этом правило, используемое межсетевым экраном по умолчанию, меняется
	  на разрешительное для всех пакетов.  Перед тем, как задавать эту
	  опцию, убедитесь, что вы понимаете работу вашего набора
	  правил.</para>
      </sect3>

      <sect3>
        <title>Поддержка функций ограничения пропускной способности</title>

        <para>Если вы хотите использовать мост в качестве машины,
	  ограничивающей пропускную способность, то добавьте в файл
	  конфигурации ядра опцию <literal>DUMMYNET</literal>.  Дополнительную
	  информацию можно почерпнуть из страницы Справочника по
	  &man.dummynet.4;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Включение функций моста</title>

      <para>Добавьте строку</para>

      <programlisting>net.link.ether.bridge=1</programlisting>

      <para>в файл <filename>/etc/sysctl.conf</filename> для включения функций
        моста во время работы системы, и строку:</para>

      <programlisting>net.link.ether.bridge_cfg=<replaceable>if1</replaceable>,<replaceable>if2</replaceable></programlisting>

      <para>для включения функций моста для указанных интерфейсов (замените
        <replaceable>if1</replaceable> и <replaceable>if2</replaceable> на
        имена двух ваших сетевых интерфейсов).  Если вы хотите, чтобы
        проходящие через мост пакеты фильтровались посредством &man.ipfw.8;,
        вы должны добавить строчку:</para>

      <programlisting>net.link.ether.bridge_ipfw=1</programlisting>

      <para>Во &os;&nbsp;5.2-RELEASE и последующих версиях нужно использовать
        вместо указанных следующие строки:</para>

      <programlisting>net.link.ether.bridge.enable=1
net.link.ether.bridge.config=<replaceable>if1</replaceable>,<replaceable>if2</replaceable>
net.link.ether.bridge.ipfw=1</programlisting>
    </sect2>

    <sect2>
      <title>Дополнительные замечания</title>

      <para>Если вы хотите осуществлять удалённый доступ на мост через
        &man.telnet.1; из сети, то корректно назначить одному из сетевых
        адаптеров IP-адрес.  Общепринято, что назначение адреса обоим сетевым
        адаптерам является не самой хорошей идеей.</para>

      <para>Если в вашей сети присутствует несколько мостов, не должно быть
        более одного маршрута между любыми двумя рабочими станциями.  С
        технической точки зрения это означает отсутствие поддержки протокола
        spanning tree.</para>

      <para>Сетевой мост может увеличить задержки в замерах командой
        &man.ping.8;, особенно для трафика между двумя разными
        сегментами.</para>
    </sect2>
  </sect1>

  <sect1 id="network-nfs">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
          <contrib>Реорганизация и улучшения </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Bill</firstname>
          <surname>Swingle</surname>
          <contrib>Текст создал</contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>NFS</title>

    <indexterm><primary>NFS</primary></indexterm>
    <para>Кроме поддержки многих прочих типов файловых систем, во FreeBSD
      встроена поддержка сетевой файловой системы (Network File System),
      известной как <acronym>NFS</acronym>.  <acronym>NFS</acronym> позволяет
      системе использовать каталоги и файлы совместно с другими машинами,
      посредством сети.  Посредством <acronym>NFS</acronym> пользователи и
      программы могут получать доступ к файлам на удалённых системах точно так
      же, как если бы это были файлы на собственных дисках.</para>

    <para>Вот некоторые из наиболее заметных преимуществ, которые даёт
      использование <acronym>NFS</acronym>:</para>

    <itemizedlist>
      <listitem>
        <para>Отдельно взятые рабочие станции используют меньше собственного
	  дискового пространства, так как совместно используемые данные могут
	  храниться на одной отдельной машине и быть доступными для других
          машин в сети.</para>
      </listitem>

      <listitem>
        <para>Пользователям не нужно иметь домашние каталоги, отдельные
          для каждой машины в вашей сети.  Домашние каталоги могут
          располагаться на сервере <acronym>NFS</acronym> и их можно сделать
          доступными отовсюду в сети.</para>
      </listitem>

      <listitem>
        <para>Устройства хранения информации, такие, как дискеты, приводы
	  CD-ROM и устройства ZIP, могут использоваться другими машинами в
          сети.  Это может привести к уменьшению переносимых устройств хранения
          информации в сети.</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Как работает <acronym>NFS</acronym></title>

      <para><acronym>NFS</acronym> строится по крайней мере из двух основных
        частей: сервера и одного или большего количества клиентов.  Клиент
        обращается к данным, находящимся на сервере, в режиме удалённого
        доступа.  Для того, чтобы это нормально функционировало, нужно
        настроить и запустить несколько процессов:</para>

      <note>
        <para>В &os; 5.X, утилита <application>portmap</application> была
          заменена на <command>rpcbind</command>.  Таким образом, при
          использовании &os; 5.X пользователю необходимо заменить в
          последующих примерах все команды <application>portmap</application>
          на <command>rpcbind</command>.</para>
      </note>

      <para>На сервере работают следующие даемоны:</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>сервер</secondary>
      </indexterm>

      <indexterm>
        <primary><application>portmap</application></primary>
      </indexterm>

      <indexterm>
        <primary><application>mountd</application></primary>
      </indexterm>

      <indexterm>
        <primary><application>nfsd</application></primary>
      </indexterm>

      <informaltable frame="none">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Даемон</entry>
              <entry>Описание</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>nfsd</entry>
              <entry>Даемон <acronym>NFS</acronym>, обслуживающий запросы от
                клиентов <acronym>NFS</acronym>.</entry>
            </row>

            <row>
	      <entry>mountd</entry>
              <entry>Даемон монтирования <acronym>NFS</acronym>, который
                выполняет запросы, передаваемые ему от &man.nfsd.8;.</entry>
            </row>

            <row>
              <entry>portmap</entry>
              <entry>Даемон отображения портов позволяет клиентам
                <acronym>NFS</acronym> определить порт, используемый сервером
                <acronym>NFS</acronym>.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Клиент может запустить также даемон, называемый
        <application>nfsiod</application>.  <application>nfsiod</application>
        обслуживает запросы, поступающие от сервера от сервера
        <acronym>NFS</acronym>.  Он необязателен, увеличивает
        производительность, однако для нормальной и правильной работы не
        требуется.  Для получения дополнительной информации обратитесь к
        разделу справочной системы о &man.nfsiod.8;.</para>
    </sect2>

    <sect2 id="network-configuring-nfs">
      <title>Настройка <acronym>NFS</acronym></title>

      <indexterm>
        <primary>NFS</primary>
        <secondary>настройка</secondary>
      </indexterm>

      <para>Настройка <acronym>NFS</acronym> является достаточно незамысловатым
        процессом.  Все процессы, которые должны быть запущены, могут быть
        стартованы во время загрузки посредством нескольких модификаций в
        вашем файле <filename>/etc/rc.conf</filename>.</para>

      <para>Проверьте, что на <acronym>NFS</acronym>-сервере в файле
        <filename>/etc/rc.conf</filename> имеются такие строки:</para>

      <programlisting>portmap_enable="YES"
nfs_server_enable="YES"
nfs_server_flags="-u -t -n 4"
mountd_flags="-r"</programlisting>

      <para><command>mountd</command> запускается автоматически, если включена
        функция сервера <acronym>NFS</acronym>.</para>

      <para>На клиенте убедитесь, что в файле <filename>/etc/rc.conf</filename>
        присутствует такой параметр:</para>

      <programlisting>nfs_client_enable="YES"</programlisting>

      <para>Файл <filename>/etc/exports</filename> определяет, какие 
        файловые системы на вашем сервере <acronym>NFS</acronym> будут
        экспортироваться (иногда их называют <quote>совместно
        используемыми</quote>).  Каждая строка в
        <filename>/etc/exports</filename> задаёт файловую систему, которая
        будет экспортироваться и какие машины будут иметь к ней доступ.  Кроме
        машин, имеющих доступ, могут задаваться другие параметры, влияющие на
        характеристики доступа.  Имеется полный набор параметров,
        которые можно использовать, но здесь пойдёт речь лишь о некоторых из
        них.  Описания остальных параметров можно найти на страницах справочной
        системы по &man.exports.5;.</para>

      <para>Вот несколько примерных строк из файла
        <filename>/etc/exports</filename>:</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>примеры экспортирования</secondary>
      </indexterm>

      <para>В следующих примерах даётся общая идея того, как экспортировать
        файловые системы, хотя конкретные параметры могут отличаться в
        зависимости от ваших условий и конфигурации сети.  К примеру, чтобы
        экспортировать каталог <filename>/cdrom</filename> для трёх машин,
        находящихся в том же самом домене, что и сервер (поэтому отсутствует
        доменное имя для каждой машины) или для которых имеются записи в
        файле <filename>/etc/hosts</filename>.  Флаг <option>-ro</option>
        указывает на использование экспортируемой файловой
        системы в режиме только чтения.  С этим флагом удалённая система не
        сможет никоим образом изменить экспортируемую файловую систему.</para>

      <programlisting>/cdrom -ro host1 host2 host3</programlisting>

      <para>В следующей строке экспортируется файловая система
        <filename>/home</filename>, которая становится доступной трем хостам,
        указанным по их IP-адресам.  Это полезно, если у вас есть собственная
        сеть без настроенного сервера <acronym>DNS</acronym>.  Как вариант,
        файл <filename>/etc/hosts</filename> может содержать внутренние имена
        хостов; пожалуйста, обратитесь к справочную систему по &man.hosts.5;
        для получения дополнительной информации.  Флаг
        <option>-alldirs</option> позволяет рассматривать подкаталоги в
        качестве точек монтирования.  Другими словами, это не монтирование
        подкаталогов, но разрешение клиентам монтировать только каталоги,
        которые им требуются или нужны.</para>

      <programlisting>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

      <para>В строке, приведённой ниже, файловая система
        <filename>/a</filename> экспортируется таким образом, что она доступна
        двум клиентам из других доменов.  Параметр
        <option>-maproot=root</option> позволяет пользователю
        <username>root</username> удалённой системы осуществлять запись на
        экспортируемую файловую систему как пользователь
        <username>root</username>.  Если параметр
        <literal>-maproot=root</literal> не задан,
        то даже если пользователь имеет права доступа <username>root</username>
        на удалённой системе, он не сможет модифицировать
        файлы на экспортированной файловой системе.</para>

      <programlisting>/a  -maproot=root  host.example.com box.example.org</programlisting>

      <para>Для того, чтобы клиент смог обратиться к экспортированной файловой
        системе, он должен иметь права сделать это.  Проверьте, что клиент
        указан в вашем файле <filename>/etc/exports</filename>.</para>

      <para>В файле <filename>/etc/exports</filename> каждая строка содержит
        информацию об экспортировании для отдельной файловой системы для
        отдельно взятого хоста.  Удалённый хост может быть задан только
        один раз для каждой файловой системы, и может иметь
        только одну запись, используемую по умолчанию, для каждой локальной
        файловой системы.  К примеру, предположим, что
        <filename>/usr</filename> является отдельной файловой системой.
        Следующий <filename>/etc/exports</filename> будет некорректен:</para>

      <programlisting>/usr/src   client
/usr/ports client</programlisting>

      <para>Одна файловая система, <filename>/usr</filename>, имеет две
        строки, задающие экспортирование для одного и того же хоста,
        <hostid>client</hostid>.  Правильный формат в этом случае таков:</para>

      <programlisting>/usr/src /usr/ports  client</programlisting>

      <para>Свойства отдельной файловой системы, экспортируемой некоторому
        хосту, должны задаваться в одной строке.  Строки без указания клиента
        воспринимаются как отдельный хост.  Это ограничивает то, как вы можете
        экспортировать файловые системы, но для большинства это не
        проблема.</para>

      <para>Ниже приведён пример правильного списка экспортирования, где
        <filename>/usr</filename> и <filename>/exports</filename> являются
        локальными файловыми системами:</para>

      <programlisting># Экспортируем src и ports для client01 и client02, но
# только client01 имеет права пользователя root на них
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# Клиентские машины имеют пользователя root и могут монтировать всё в
# каталоге /exports.  Кто угодно может монтировать /exports/obj в режиме чтения
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</programlisting>

      <para>Вы должны перезапустить <command>mountd</command> после того, как
        изменили <filename>/etc/exports</filename>, чтобы изменения вступили в
        силу.  Это может быть достигнуто посылкой сигнала HUP процессу
        <command>mountd</command>:</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>

      <para>Как вариант, при перезагрузке FreeBSD всё настроится правильно.
        Хотя выполнять перезагрузку вовсе не обязательно.  Выполнение следующих
        команд пользователем <username>root</username> запустит всё, что
        нужно.</para>

      <para>На сервере <acronym>NFS</acronym>:</para>

      <screen>&prompt.root; <userinput>portmap</userinput>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput></screen>

      <para>На клиенте <acronym>NFS</acronym>:</para>

      <screen>&prompt.root; <userinput>nfsiod -n 4</userinput></screen>

      <para>Теперь всё должно быть готово к реальному монтированию удалённой
        файловой системы.  В приводимых примерах сервер будет носить имя
        <literal>server</literal>, а клиент будет носить имя
        <literal>client</literal>.  Если вы только хотите
        временно смонтировать удалённую файловую систему, или всего лишь
        протестировать ваши настройки, то просто запустите команды, подобные
        приводимым здесь, работая как пользователь <username>root</username> на
        клиентской машине:</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>монтирование</secondary>
      </indexterm>

      <screen>&prompt.root; <userinput>mount server:/home /mnt</userinput></screen>

      <para>По этой команде файловая система <filename>/home</filename> на
        сервере будет смонтирована в каталог <filename>/mnt</filename> на
        клиенте.  Если всё настроено правильно, вы сможете войти в каталог
        <filename>/mnt</filename> на клиенте и увидеть файлы, находящиеся на
        сервере.</para>

      <para>Если вы хотите автоматически монтировать удалённую файловую
        систему при каждой загрузке компьютера, добавьте файловую систему в
        <filename>/etc/fstab</filename>.  Вот пример:</para>

      <programlisting>server:/home	  /mnt	  nfs	  rw	  0	  0</programlisting>

      <para>На страницах справочной системы по &man.fstab.5; перечислены все
        доступные параметры.</para>
    </sect2>

    <sect2>
      <title>Практическое использование</title>

      <para>У <acronym>NFS</acronym> есть много вариантов практического
        применения.  Ниже приводится несколько наиболее широко распространённых
        способов её использования:</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>использование</secondary>
      </indexterm>

      <itemizedlist>
        <listitem>
          <para>Настройка несколько машин для совместного использования CDROM
            или других носителей.  Это более дешёвый и зачастую более удобный
            способ установки программного обеспечения на несколько машин.</para>
        </listitem>

        <listitem>
          <para>В больших сетях может оказаться более удобным настроить
            центральный сервер <acronym>NFS</acronym>, на котором размещаются
            все домашние каталоги пользователей.  Эти домашние каталоги могут
            затем экспортироваться в сеть так, что пользователи всегда будут
            иметь один и тот же домашний каталог вне зависимости от того, на
            какой рабочей станции они работают.</para>
        </listitem>

        <listitem>
          <para>Несколько машин могут иметь общий каталог
            <filename>/usr/ports/distfiles</filename>.  Таким образом, когда
            вам нужно будет установить порт на несколько машин, вы сможете быстро
            получить доступ к исходным текстам без их сгрузки на каждой
            машине.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="network-amd">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Wylie</firstname>
	    <surname>Stilwell</surname>
	    <contrib>Текст предоставил</contrib>
	  </author>
	</authorgroup>

        <authorgroup>
          <author>
            <firstname>Chern</firstname>
            <surname>Lee</surname>
            <contrib>Текст переписал</contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Автоматическое монтирование с
        <application>amd</application></title>

      <indexterm>
        <primary>amd</primary>
      </indexterm>

      <indexterm>
        <primary>даемон автоматического монтирования</primary>
      </indexterm>

      <para>&man.amd.8; (даемон автоматического монтирования) автоматически
        монтирует удалённую файловую систему,
        как только происходит обращение к файлу или каталогу в этой файловой
        системе.  Кроме того, файловые системы, которые были неактивны
        некоторое время, будут автоматически размонтированы даемоном
  	<application>amd</application>.  Использование 
	<application>amd</application> является простой альтернативой
        статическому монтированию, так как в последнем случае обычно всё должно
        быть описано в файле <filename>/etc/fstab</filename>.</para>

      <para><application>amd</application> работает, сам выступая как сервер
        NFS для каталогов <filename>/host</filename> и
	<filename>/net</filename>.  Когда происходит обращение к файлу в одном
        из этих каталогов, <application>amd</application> ищет соответствующий
        удаленный ресурс для монтирования и автоматически его монтирует.
	<filename>/net</filename> используется для монтирования экспортируемой
        файловой системы по адресу IP, когда как каталог
        <filename>/host</filename> используется для монтирования ресурса по
        удаленному имени хоста.</para>

      <para>Обращение к файлу в каталоге
	<filename>/host/foobar/usr</filename> укажет
	<application>amd</application> на выполнение попытки монтирования
        ресурса	<filename>/usr</filename>, который находится на хосте
        <hostid>foobar</hostid>.</para>

      <example>
	<title>Монтирование ресурса при помощи
          <application>amd</application></title>

        <para>Вы можете посмотреть доступные для монтирования ресурсы
          отдалённого хоста командой <command>showmount</command>.  К примеру,
          чтобы посмотреть ресурсы хоста с именем <hostid>foobar</hostid>, вы
          можете использовать:</para>

	<screen>&prompt.user; <userinput>showmount -e foobar</userinput>
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
&prompt.user; <userinput>cd /host/foobar/usr</userinput></screen>
      </example>

      <para>Как видно из примера, <command>showmount</command> показывает
	<filename>/usr</filename> как экспортируемый ресурс.  При переходе в
        каталог	<filename>/host/foobar/usr</filename> даемон
        <application>amd</application> пытается разрешить имя хоста
        <hostid>foobar</hostid> и автоматически смонтировать требуемый
        ресурс.</para>

      <para><application>amd</application> может быть запущен из скриптов
        начальной загрузки, если поместить такую строку в файл
	<filename>/etc/rc.conf</filename>:</para>
 
      <programlisting>amd_enable="YES"</programlisting>

      <para>Кроме того, даемону <application>amd</application> могут быть
        переданы настроечные флаги через параметр
        <varname>amd_flags</varname>.  По умолчанию
        <varname>amd_flags</varname> настроен следующим образом:</para>

      <programlisting>amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"</programlisting>

      <para>Файл <filename>/etc/amd.map</filename> задает опции, используемые
        по умолчанию при монтировании экспортируемых ресурсов.  В файле
	<filename>/etc/amd.conf</filename> заданы настройки некоторых более
        сложных возможностей <application>amd</application>.</para>

      <para>Обратитесь к справочным страницам по &man.amd.8; и &man.amd.conf.5;
        для получения более полной информации.</para>
    </sect2>

    <sect2 id="network-nfs-integration">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>John</firstname>
            <surname>Lind</surname>
            <contrib>Текст предоставил</contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Проблемы взаимодействия с другими системами</title>

      <para>Некоторые сетевые адаптеры для систем PC с шиной ISA имеют
        ограничения, которые могут привести к серьезным проблемам в сети, в
        частности, с NFS.  Эти проблемы не специфичны для FreeBSD, однако
        эту систему они затрагивают.</para>

      <para>Проблема, которая возникает практически всегда при работе по сети
        систем PC (FreeBSD) с высокопроизводительными рабочими станциями,
        выпущенными такими производителями, как Silicon Graphics, Inc. и Sun
        Microsystems, Inc.  Монтирование по протоколу NFS будет работать
        нормально, и некоторые операции также будут выполняться успешно, но
        неожиданно сервер окажется недоступным для клиент, хотя запросы к и
        от других систем будут продолжаться обрабатываться.  Такое встречается
        с клиентскими системами, не зависимо от того, является ли клиент
        машиной с FreeBSD или рабочей станцией.  Во многих системах при
        возникновении этой проблемы нет способа корректно завершить работу
        клиента.  Единственным выходом зачастую является холодная перезагрузка
        клиента, потому что ситуация с NFS не может быть разрешена.</para>

      <para>Хотя <quote>правильным</quote> решением является установка более
        производительного и скоростного сетевого адаптера на систему FreeBSD,
        имеется простое решение, приводящее к удовлетворительным результатам.
        Если система FreeBSD является <emphasis>сервером</emphasis>, укажите
        параметр <option>-w=1024</option> на клиенте при монтировании.  Если
        система FreeBSD является <emphasis>клиентом</emphasis>, то смонтируйте
        файловую систему NFS с параметром <option>-r=1024</option>.  Эти
        параметры могут быть заданы в четвертом поле записи в файле
        <filename>fstab</filename> клиента при автоматическом монтировании,
        или при помощи параметра <option>-o</option> в команде mount при
        монтировании вручную.</para>

      <para>Нужно отметить, что имеется также другая проблема, ошибочно
        принимаемая за приведенную выше, когда серверы и клиенты NFS находятся
        в разных сетях.  Если это тот самый случай,
        <emphasis>проверьте</emphasis>, что ваши маршрутизаторы пропускают
        нужную информацию UDP, в противном случае вы ничего не получите, что
        бы вы ни предпринимали.</para>

      <para>В следующих примерах <hostid>fastws</hostid> является именем хоста
        (интерфейса) высокопроизводительной рабочей станции, а
        <hostid>freebox</hostid> является именем хоста (интерфейса) системы
        FreeBSD со слабым сетевым адаптером.  Кроме того,
        <filename>/sharedfs</filename> будет являться экспортируемой через NFS
        файловой системой (обратитесь к страницам справочной системы по команде
        &man.exports.5;), а <filename>/project</filename> будет точкой
        монтирования экспортируемой файловой системы на клиенте.  В любом
        случае, отметьте, что для вашего приложения могут понадобиться
        дополнительные параметры, такие, как <option>hard</option>,
        <option>soft</option> или <option>bg</option>.</para>

      <para>Пример системы FreeBSD (<hostid>freebox</hostid>) как клиента
        в файле <filename>/etc/fstab</filename> на машине freebox:</para>

      <programlisting>fastws:/sharedfs /project nfs rw,-r=1024 0 0</programlisting>

      <para>Команда, выдаваемая вручную на машине
        <hostid>freebox</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sharedfs /project</userinput></screen>

      <para>Пример системы FreeBSD в качестве сервера в файле
        <filename>/etc/fstab</filename> на машине
        <hostid>fastws</hostid>:</para>

      <programlisting>freebox:/sharedfs /project nfs rw,-w=1024 0 0</programlisting>

      <para>Команда, выдаваемая вручную на машине
        <hostid>fastws</hostid>:</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sharedfs /project</userinput></screen>

      <para>Практически все 16-разрядные сетевые адаптеры позволят работать
        без указанных выше ограничений на размер блоков при чтении и
        записи.</para>

      <para>Для тех, кто интересуется, ниже описывается, что же происходит в
        при появлении этой ошибки, и объясняется, почему ее невозможно
        устранить.  Как правило, NFS работает с <quote>блоками</quote> размером
        8&nbsp;килобайт (хотя отдельные фрагменты могут иметь меньшие
        размеры).  Так, пакет Ethernet имеет максимальный размер около
        1500&nbsp;байт, то
        <quote>блок</quote> NFS разбивается на несколько пакетов Ethernet, хотя
        на более высоком уровне это все тот же единый блок, который должен быть
        принят, собран и <emphasis>подтвержден</emphasis> как один блок.
        Высокопроизводительные рабочие станции могут посылать пакеты, которые
        соответствуют одному блоку NFS, сразу друг за другом, насколько это
        позволяет делать стандарт.  На слабых, низкопроизводительных адаптерах
        пакеты, пришедшие позже, накладываются поверх ранее пришедших пакетов
        того же самого блока до того, как они могут быть переданы хосту и
        блок как единое целое не может быть собран или подтвержден.  В
        результате рабочая станция входит в ситуацию таймаута и пытается
        повторить передачу, но уже с полным блоком в 8&nbsp;КБ, и процесс будет
        повторяться снова, до бесконечности.</para>

      <para>Задав размер блока меньше размера пакета Ethernet, мы достигаем
        того, что любой полностью полученный пакет Ethernet может быть
        подтвержден индивидуально, и избежим тупиковую ситуацию.</para>

      <para>Наложение пакетов может все еще проявляться, когда
        высокопроизводительные рабочие станции сбрасывают данные на PC-систему,
        однако повторение этой ситуации не обязательно с более скоростными
        адаптерами с <quote>блоками</quote> NFS.  Когда происходит наложение,
        затронутые блоки будут переданы снова, и скорее всего, они будут
        получены, собраны и подтверждены.</para>
    </sect2>
  </sect1>

  <sect1 id="network-diskless">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Jean-Fran&ccedil;ois</firstname>
          <surname>Dock&egrave;s</surname>
          <contrib>Текст обновил</contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Работа с бездисковыми станциями</title>

    <indexterm><primary>работа без диска</primary></indexterm>

    <para>Машина с FreeBSD может загружаться по сети и работать без наличия
      локального диска, используя файловые системы, монтируемые с сервера NFS.
      Кроме стандартных конфигурационных файлов, не нужны никакие модификации
      в системе.  Такую систему легко настроить, потому что все необходимые
      элементы уже готовы:</para>

    <itemizedlist>
      <listitem>
        <para>Имеется по крайней мере два возможных способа загрузки ядра по
          сети:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>PXE</emphasis>: Система &intel; Preboot Execution
              Environment является формой загрузочного ПЗУ, встроенного в
              некоторые сетевые адаптеры или материнские платы.  Обратитесь к
              справочной странице по &man.pxeboot.8; для получения более полной
              информации.</para>
          </listitem>


          <listitem>
            <para><emphasis>Порт
              <application>etherboot</application></emphasis> (<filename
              role="package">net/etherboot</filename>) генерирует код,
              который может применяться в ПЗУ для загрузки ядра по сети.  Код
              может быть либо прошит в загрузочный PROM на сетевом адаптере,
              либо загружен с локальной дискеты (или винчестера), или с
              работающей системы &ms-dos;.  Поддерживаются многие сетевые
              адаптеры.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Примерный скрипт
          (<filename>/usr/share/examples/diskless/clone_root</filename>)
          облегчает создание и поддержку корневой файловой системы рабочей
          станции на сервере.  Скрипт, скорее всего, потребует некоторых
          настроек, но он позволит вам быстро начать работу.</para>
      </listitem>

      <listitem>
        <para>Стандартные файлы начального запуска системы, располагающиеся в
          <filename>/etc</filename>, распознают и поддерживают загрузку системы
          в бездисковом варианте.</para>
      </listitem>

      <listitem>
        <para>Подкачка, если она нужна, может выполняться через файл NFS либо
          на локальный диск.</para>
      </listitem>
    </itemizedlist>

    <para>Существует много способов настройки бездисковой рабочей станции.  При
      этом задействованы многие компоненты, и большинство из них могут быть
      настроены для удовлетворения ваших вкусов.  Далее будет описана полная
      настройка системы, при этом упор будет делаться на простоту и
      совместимость с стандартной системой скриптов начальной загрузки FreeBSD.
      Описываемая система имеет такие характеристики:</para>

    <itemizedlist>
      <listitem>
        <para>Бездисковые рабочие станции совместно используют
          <filename>корневую</filename> файловую систему в режиме только
          чтения, а также используют <filename>/usr</filename> совместно тоже
          в режиме только чтения.</para>

        <para><filename>Корневая</filename> файловая система является копией
          стандартной корневой системы FreeBSD (обычно сервера), с некоторыми
          настроечными файлами, измененными кем-то специально для бездисковых
          операций или, возможно, для рабочей станции, которой она
          предназначена.</para>

        <para>Части <filename>корневой</filename> файловой системы, которые
          должны быть доступны для записи, перекрываются файловыми системами
          &man.mfs.8;.  Любые изменения будут потеряны при перезагрузках
          системы.</para>
      </listitem>

      <listitem>
        <para>Ядро загружается посредством
          <application>etherboot</application>, при помощи DHCP (или BOOTP) и
          TFTP.</para>
      </listitem>
    </itemizedlist>

    <caution>
      <para>Как описано, эта система незащищена.  Она должна располагаться в
        защищенной части сети, а другие хосты не должны на нее
        полагаться.</para>
    </caution>

    <sect2>
      <title>Инструкции по настройке</title>

      <sect3>
        <title>Настройка DHCP/BOOTP</title>

        <indexterm>
          <primary>бездисковые конфигурации</primary>
          <secondary>загрузка</secondary>
        </indexterm>

        <para>Есть два протокола, часто используемых для загрузки рабочих
          станций, которые запрашивают свою конфигурацию по сети: BOOTP и DHCP.
          При начальной загрузке рабочей станции они используются в нескольких
          местах:</para>

        <itemizedlist>
          <listitem>
            <para><application>etherboot</application> использует (по
              умолчанию) DHCP или BOOTP (требуется опция при настройке) для
              поиска ядра.  (PXE использует DHCP).</para>
          </listitem>

          <listitem>
            <para>Ядро использует BOOTP для поиска корневой файловой системы в
              NFS.</para>
          </listitem>
        </itemizedlist>

        <para>Возможна настройка системы на использование исключительно BOOTP.
          Программа сервера &man.bootpd.8; включена в базовую систему
          FreeBSD.</para>

        <para>Однако DHCP имеет некоторый набор преимуществ перед BOOTP (лучше
          настроечные файлы, возможность использования PXE, плюс множество
          других, напрямую не связанных к работе без диска), и мы опишем как
          конфигурацию с чистым BOOTP, так и BOOTP+DHCP, с упором на последнее,
          в котором используется пакет DHCP от ISC.</para>

        <sect4>
          <title>Конфигурация с использованием ISC DHCP</title>

          <indexterm>
            <primary>DHCP</primary>
            <secondary>бездисковые конфигурации</secondary>
          </indexterm>

          <para>Сервер <application>isc-dhcp</application> может обрабатывать
            как запросы BOOTP, так и запросы DHCP.</para>

          <para>Начиная с релиза 4.4, <application>isc-dhcp 3.0</application>
            не включается в поставку системы.  Сначала вам нужно будет
            установить порт <filename
            role="package">net/isc-dhcp3-server</filename>
            или соответствующий пакадж.  Пожалуйста, обратитесь к <xref
            linkend="ports"> для получения общего представления о портах и
            пакаджах.</para>

          <para>После установки <application>isc-dhcp</application> ему для
            работы требуется конфигурационный файл (обычно называемый
            <filename>/usr/local/etc/dhcpd.conf</filename>).  Вот
            прокомментированный пример:</para>

          <programlisting>
            default-lease-time 600;
            max-lease-time 7200;
            authoritative;

            option domain-name "example.com";
            option domain-name-servers 192.168.4.1;
            option routers 192.168.4.1;

            subnet 192.168.4.0 netmask 255.255.255.0 {
              use-host-decl-names on; <co id="co-dhcp-host-name">
              option subnet-mask 255.255.255.0;
              option broadcast-address 192.168.4.255;

              host margaux {
                hardware ethernet 01:23:45:67:89:ab;
                fixed-address margaux.example.com;
                next-server 192.168.4.4;<co id="co-dhcp-next-server">
                filename "/tftpboot/kernel.diskless";<co id="co-dhcp-filename">
                option root-path "192.168.4.4:/data/misc/diskless";<co
                id="co-dhcp-root-path">
              }
            }
          </programlisting>

          <calloutlist>
            <callout arearefs="co-dhcp-host-name">
              <para>Этот параметр указывает <command>dhcpd</command> посылать
                значения деклараций <literal>host</literal> как имя хоста для
                бездисковой машины.  Альтернативным способом было бы добавление
                <literal>option host-name
                <replaceable>margaux</replaceable></literal> внутри объявлений
                хоста.</para>
            </callout>


            <callout arearefs="co-dhcp-next-server">
              <para>Директива <literal>next-server</literal> определяет сервер
                TFTP (по умолчанию используется тот же самый хост, на котором
                расположен сервер DHCP).</para>
            </callout>

            <callout arearefs="co-dhcp-filename">
              <para>Директива <literal>filename</literal> определяет файл,
                который будет загружать <application>etherboot</application> в
                качестве ядра.
                <note>
                  <para>Похоже, что PXE предпочитает относительное имя файла,
                    и он загружает <command>pxeboot</command>, а не ядро
                    (<literal>option filename "pxeboot"</literal>).</para>
                </note>
              </para>
            </callout>

            <callout arearefs="co-dhcp-root-path">
              <para>Параметр <literal>root-path</literal> определяет путь к
                корневой файловой системе, в обычной нотации NFS.</para>
            </callout>
          </calloutlist>
        </sect4>

        <sect4>
          <title>Настройка с использованием BOOTP</title>

          <indexterm>
            <primary>BOOTP</primary>
            <secondary>бездисковые конфигурации</secondary>
          </indexterm>

          <para>Далее описана эквивалентная конфигурация с использованием
            <command>bootpd</command>.  Она будет располагаться в
            <filename>/etc/bootptab</filename>.</para>

          <para>Пожалуйста, отметьте, что <application>etherboot</application>
            должен быть откомпилирован с нестандартной опцией
            <literal>NO_DHCP_SUPPORT</literal> для того, чтобы можно было
            использовать BOOTP, и что для работы PXE
            <emphasis>необходим</emphasis> DHCP.  Единственным очевидным
            преимуществом <application>bootpd</application> является его
            наличие в поставке системы.</para>


          <programlisting>
          .def100:\
            :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
            :sm=255.255.255.0:\
            :ds=192.168.4.1:\
            :gw=192.168.4.1:\
            :hd="/tftpboot":\
            :bf="/kernel.diskless":\
            :rp="192.168.4.4:/data/misc/diskless":

          margaux:ha=0123456789ab:tc=.def100
          </programlisting>
        </sect4>
      </sect3>

      <sect3>
	<title>Подготовка программы загрузки при помощи
	  <application>Etherboot</application></title> 

        <indexterm>
          <primary>Etherboot</primary>
        </indexterm>

	<para><ulink url="http://etherboot.sourceforge.net">Сайт
          Etherboot</ulink> содержит <ulink
          url="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
          подробную документацию</ulink>, в основном предназначенную для систем
          Linux, но несомненно, она полезна.  Далее будет просто кратко
          описано, как вы должны использовать
          <application>etherboot</application> в системе FreeBSD.</para>

	<para>Сначала вы должны установить пакадж или порт <filename
          role="package">net/etherboot</filename>.  Порт
	  <application>etherboot</application> обычно расположен в
	  <filename>/usr/ports/net/etherboot</filename>.  Если в вашей системе
          установлено дерево портов, просто наберите <literal>make</literal> в
          этом каталоге, все остальное будет сделано за вас.  Либо обратитесь к
	  <xref linkend="ports"> для получения информации о портах и
          пакаджах.</para> 

	<para>В нашей ситуации мы будем использовать загрузочную дискету.  Для
          других методов (PROM или программа DOS) пожалуйста, обратитесь к
          документации по <application>etherboot</application>.</para>

	<para>Для создания загрузочной дискеты, вставьте дискету в дисковод на
          машине, где установлен <application>etherboot</application>, затем
          перейдите в каталог <filename>src</filename> в дереве
	  <application>etherboot</application> и наберите:</para> 

	<screen>
	  &prompt.root; <userinput>gmake bin32/<replaceable>devicetype</replaceable>.fd0</userinput>
	</screen>

	<para><replaceable>devicetype</replaceable> зависит от типа адаптера
          Ethernet на бездисковой рабочей станции.  Обратитесь к файлу
	  <filename>NIC</filename> в том же самом каталоге для определения
          правильного значения для
          <replaceable>devicetype</replaceable>.</para>
      </sect3>

      <sect3>
	<title>Настройка серверов TFTP и NFS</title> 

        <indexterm>
          <primary>TFTP</primary>
          <secondary>бездисковые конфигурации</secondary>
        </indexterm>

        <indexterm>
          <primary>NFS</primary>
          <secondary>бездисковые конфигурации</secondary>
        </indexterm>

	<para>Вам нужно включить <command>tftpd</command> на сервере
          TFTP:</para>

        <procedure>
          <step>
            <para>Создайте каталог, файлы которого будет обслуживать
              <command>tftpd</command>, например,
              <filename>/tftpboot</filename>.</para>
          </step>

          <step>
            <para>Добавьте в ваш <filename>/etc/inetd.conf</filename> такую
              строчку:</para>

	    <programlisting>tftp    dgram   udp     wait    root  /usr/libexec/tftpd    tftpd -s /tftpboot</programlisting>

	    <note>
              <para>Бывает, что некоторым версиям PXE требуется TCP-вариант
                TFTP.  В таком случае добавьте вторую строчку, заменяющую
		<literal>dgram udp</literal> на <literal>stream
                tcp</literal>.</para> 
	    </note>
          </step>

	  <step>
	    <para>Укажите <command>inetd</command> на повторное чтение своего
              конфигурационного файла:</para>

	    <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
	  </step>
        </procedure>

	<para>Вы можете поместить каталог <filename>tftpboot</filename> в любом
          месте на сервере.  Проверьте, что это местоположение указано как в
	  <filename>inetd.conf</filename>, так и в
	  <filename>dhcpd.conf</filename>.</para>

	<para>Вам также нужно включить NFS и экспортировать
          соответствующую файловую систему на сервере NFS.</para>

        <procedure>
          <step>
            <para>Добавьте следующее в
              <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>nfs_server_enable="YES"</programlisting>
          </step>
            
          <step>
            <para>Проэкспортируйте файловую систему, в которой расположен
              корневой каталог для бездисковой рабочей станции, добавив
              следующую строку в <filename>/etc/exports</filename> (подправьте
              точку монтирования и замените <replaceable>margaux</replaceable>
              на имя бездисковой рабочей станции):</para>

	    <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux</replaceable></programlisting>
          </step>

	  <step>
	    <para>Укажите <command>mountd</command> на повторное чтение
              настроечного файла.  На самом деле если вам потребовалось на
              первом шаге включить NFS в <filename>/etc/rc.conf</filename>, то
              вам нужно будет выполнить перезагрузку.</para>

	    <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>
	  </step>
        </procedure>
      </sect3>

      <sect3>
	<title>Построение ядра для бездисковой рабочей станции</title>

        <indexterm>
          <primary>бездисковые конфигурации</primary>
          <secondary>настройка ядра</secondary>
        </indexterm>

	<para>Создайте конфигурационный файл ядра для бездискового клиента со
          следующими параметрами (вдобавок к обычным):</para>

	<programlisting>
          options     BOOTP          # Use BOOTP to obtain IP address/hostname
          options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info
          options     BOOTP_COMPAT   # Workaround for broken bootp daemons.
	</programlisting>

	<para>Вам может потребоваться использовать
          <literal>BOOTP_NFSV3</literal> и <literal>BOOTP_WIRED_TO</literal>
          (посмотрите <filename>LINT</filename>).</para>

	<para>Постройте ядро (обратитесь к <xref linkend="kernelconfig">) и
	  скопируйте его в каталог tftp под именем, указанным в
	  <filename>dhcpd.conf</filename>.</para>
      </sect3>

      <sect3>
        <title>Подготовка корневой файловой системы</title>

        <indexterm>
          <primary>корневая файловая система</primary>
          <secondary>бездисковые конфигурации</secondary>
        </indexterm>

	<para>Вам нужно создать корневую файловую систему для бездисковых
          рабочих станций, в местоположении, заданном как
	  <literal>root-path</literal> в
          <filename>dhcpd.conf</filename>.</para>

	<para>Самым простым способом сделать это является использование скрипта
	  <filename>/usr/share/examples/diskless/clone_root</filename>.  Этот
          скрипт требуется настроить, по крайней мере, подправив место, где
          будет создана файловая система (переменная
          <literal>DEST</literal>).</para>

	<para>Прочтите комментарии в начале скрипта для получения указаний.
          Там описано, как строится основная файловая система, и как файлы
          могут быть выборочно заменены версиями, предназначенными для работы
          без диска, для подсети или для отдельной рабочей станции.  Также
          здесь даются примеры бездисковых файлов
          <filename>/etc/fstab</filename> и
          <filename>/etc/rc.conf</filename>.</para> 

        <para>Файлы <filename>README</filename> в
          <filename>/usr/share/examples/diskless</filename> много интересной
          информации, но вместе с другими примерами из каталога
          <filename>diskless</filename> они на самом деле описывают метод
          настройки, который отличается от того, что используется в
	  <filename>clone_root</filename> и
          <filename>/etc/rc.diskless[12]</filename>, этим несколько запутывая
          дело.  Используйте их только для справки, за исключением того случая,
          когда вы выберете метод, ими описываемый, и тогда вам нужны
          исправленные скрипты <filename>rc</filename>.</para>
      </sect3>

      <sect3>
	<title>Настройка области подкачки</title>

	<para>Если это нужно, то файл подкачки, расположенный на сервере, можно
          использовать посредством NFS.  Точные параметры
          <filename>bootptab</filename> или <filename>dhcpd.conf</filename>
          пока плохо документированы.  Сообщается, что работает следующая
          конфигурация с использованием isc-dhcp 3.0rc11.</para>

	<procedure>
	  <step>
            <para>Добавьте следующие строки в
              <filename>dhcpd.conf</filename>:</para>

	    <programlisting>
              # Global section
              option swap-path code 128 = string;
              option swap-size code 129 = integer 32;

              host margaux {
                ... # Стандартные строки, смотрите выше
                option swap-path <replaceable>"192.168.4.4:/netswapvolume/netswap"</replaceable>;
                option swap-size <replaceable>64000</replaceable>;
              }
	    </programlisting>

	    <para>Идея заключается в том, что, по крайней мере для клиента
              FreeBSD, дополнительный параметр DHCP/BOOTP под кодом 128
              является маршрутом к файлу подкачки NFS, а параметр с кодом 129
              задает размер области подкачки в килобайтах.  Более старые версии
	      <command>dhcpd</command> разрешали использовать синтаксис типа
	      <literal>option option-128 "...</literal>, который больше не
              работает.</para>

	    <para>Во <filename>/etc/bootptab</filename> будет использоваться
              такой синтаксис:</para>

            <para><literal>T128="192.168.4.4:/netswapvolume/netswap":T129=64000</literal></para>
	  </step>

	  <step>
	    <para>На файловом сервере NFS создайте файл (или файлы)
              подкачки</para>

            <screen>
              &prompt.root; <userinput>mkdir <replaceable>/netswapvolume/netswap</replaceable></userinput>
              &prompt.root; <userinput>cd <replaceable>/netswapvolume/netswap</replaceable></userinput>
              &prompt.root; <userinput>dd if=/dev/zero bs=1024 count=<replaceable>64000</replaceable> of=swap.<replaceable>192.168.4.6</replaceable></userinput>
              &prompt.root; <userinput>chmod 0600 swap.<replaceable>192.168.4.6</replaceable></userinput>
            </screen>

	    <para><replaceable>192.168.4.6</replaceable> является IP-адресом
              бездискового клиента.</para>
	  </step>

	  <step>
	    <para>На файловом сервере NFS, в <filename>/etc/exports</filename>
              добавьте такую строку:</para>

	    <programlisting>
	      <replaceable>/netswapvolume</replaceable>  -maproot=0:10 -alldirs <replaceable>margaux</replaceable> 
	    </programlisting>

	    <para>Затем укажите <application>mountd</application> на повторное
              чтение файла exports, как описано ранее.</para>
	  </step>
	</procedure>
      </sect3>

      <sect3>
	<title>Различные проблемы</title>
	
	<sect4>
	  <title>Работа с <filename>/usr</filename>, доступной только для
            чтения</title>

          <indexterm>
            <primary>бездисковые конфигурации</primary>
            <secondary>/usr только для чтения</secondary>
          </indexterm>

          <para>Если бездисковая рабочая станция настроена на запуск X, вам
            нужно подправить настроечный файл для xdm, который по умолчанию
            помещает протокол ошибок в <filename>/usr</filename>.</para>
	</sect4>

	<sect4>
	  <title>Использование не-FreeBSD сервера</title>

	  <para>Если сервер с корневой файловой системой работает не под
            управлением FreeBSD, вам потребуется создать корневую файловую
            систему на машине FreeBSD, а затем скопировать ее в нужно место,
            при помощи <command>tar</command> или
            <command>cpio</command>.</para>

	  <para>В такой ситуации иногда возникают проблемы со
            специальными файлами в <filename>/dev</filename> из-за различной
            разрядности целых чисел для старшего/младшего чисел.  Решением
            этой проблемы является экспортирование каталога с не-FreeBSD
            сервера, монтирование его на машине с FreeBSD и запуск
            скрипта <command>MAKEDEV</command> на машине с FreeBSD для создания
            правильных файлов устройств (во FreeBSD 5.0 и более поздних версиях
            используется &man.devfs.5; для создания файлов устройств прозрачно
            для пользователя, запуск <command>MAKEDEV</command> в этих версиях
            бесполезен).</para>
	</sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-isdn">
    <title>ISDN</title>

    <indexterm>
      <primary>ISDN</primary>
    </indexterm>

    <para>Полезным источником информации о технологии ISDN и его аппаратном
      обеспечении является <ulink
      url="http://www.alumni.caltech.edu/~dank/isdn/">
      Страница Дэна Кегела (Dan Kegel) об ISDN</ulink>.</para>

    <para>Быстрое введение в ISDN:</para>

    <itemizedlist>
      <listitem>
        <para>Если вы живёте в Европе, то вам может понадобиться изучить раздел
          об ISDN-адаптерах.</para>
      </listitem>

    <listitem>
      <para>Если вы планируете использовать ISDN в основном для соединений
	с Интернет через провайдера по коммутируемому, невыделенному
	соединению, рекомендуется посмотреть информацию о терминальных
	адаптерах.  Это даст вам самую большую гибкость и наименьшее
	количество проблем при смене провайдера.</para>
    </listitem>

    <listitem>
      <para>Если вы объединяете две локальные сети или подключаетесь к
	Интернет через постоянное ISDN-соединение, рекомендуем остановить свой
        выбор на отдельном мосте/маршрутизаторе.</para>
    </listitem>
  </itemizedlist>

  <para>Стоимость является важным фактором при выборе вашего решения.
    Далее перечислены все возможности от самого дешевого до самого дорогого
    варианта.</para>

    <sect2 id="network-isdn-cards">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Hellmuth</firstname>
            <surname>Michaelis</surname>
            <contrib>Текст предоставил</contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Адаптеры ISDN</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>адаптеры</secondary>
      </indexterm>

      <para>Реализация ISDN во FreeBSD поддерживает только стандарт DSS1/Q.931
        (или Евро-ISDN) при помощи пассивных адаптеров.  Начиная с
        FreeBSD&nbsp;4.4 поддерживаются некоторые активные адаптеры, прошивки
        которых поддерживают также другие сигнальные протоколы; также сюда
        впервые включена поддержка адаптеров ISDN Primary Rate (PRI).</para>

      <para>Пакет программ <application>isdn4bsd</application> позволяет вам
        подключаться к другим маршрутизаторам ISDN при помощи IP поверх DHLC,
        либо при помощи синхронного PPP; либо при помощи PPP на уровне ядра с
        <literal>isppp</literal>, модифицированного драйвера &man.sppp.4;, или
        при помощи пользовательского
        &man.ppp.8;.  При использовании пользовательского &man.ppp.8; возможно
        использование двух и большего числа B-каналов ISDN.  Также имеется
        приложение, работающее как автоответчик, и много утилит, таких, как
        программный модем на 300 Бод.</para>

      <para>Во FreeBSD поддерживается все возрастающее число адаптеров ISDN для
        ПК, и сообщения показывают, что они успешно используются по всей Европе
        и других частях света.</para>

      <para>Из пассивных адаптеров ISDN поддерживаются в основном те, которые
        сделаны на основе микросхем Infineon (бывший Siemens) ISAC/HSCX/IPAC
        ISDN, а также адаптеры ISDN с микросхемами от Cologne Chip (только для
        шины ISA), адаптеры PCI с микросхемами Winbond W6692, некоторые
        адаптеры с набором микросхем Tiger300/320/ISAC и несколько адаптеров,
        построенных на фирменных наборах микросхем, такие, как AVM Fritz!Card
        PCI V.1.0 и AVM Fritz!Card PnP.</para>

      <para>На данный момент из активных адаптеров ISDN поддерживаются AVM B1
	(ISA и PCI) адаптеры BRI и AVM T1 PCI адаптеры PRI.</para>

      <para>Документацию по <application>isdn4bsd</application> можно найти в
	каталоге <filename>/usr/share/examples/isdn/</filename> вашей системы
	FreeBSD или на <ulink url="http://www.freebsd-support.de/i4b/">домашней
        странице isdn4bsd</ulink>, на которой также размещены ссылки на советы,
        замечания по ошибкам и более подробную информацию, например, на <ulink
        url="http://people.FreeBSD.org/~hm/">руководство по
        isdn4bsd</ulink>.</para>

      <para>Если вы заинтересованы в добавлении поддержки для различных
        протоколов ISDN, неподдерживаемых на данный момент адаптеров ISDN для
        PC или каких-то других усовершенствованиях
        <application>isdn4bsd</application>, пожалуйста, свяжитесь с
        &a.hm;.</para>

      <para>Для обсуждения вопросов, связанных с установкой, настройкой и
        устранением неисправностей <application>isdn4bsd</application>,
        имеется список рассылки &a.isdn.name;.</para>

      <para><literal>subscribe freebsd-isdn</literal></para>
    </sect2>

  <sect2>
    <title>Терминальные адаптеры ISDN</title>

    <para>Терминальные адаптеры (TA) для ISDN выполняют ту же роль, что и
      модемы для обычных телефонных линий.</para>

    <indexterm><primary>модем</primary></indexterm>

    <para>Большинство TA используют стандартный набор AT-команд Hayes-модемов,
      и могут использоваться в качестве простой замены для модемов.</para>

    <para>TA будут работать точно так же, как и модемы, за исключением
      скорости соединения и пропускной способности, которые будут гораздо
      выше, чем у вашего старого модема.  Вам потребуется настроить <link
      linkend="ppp">PPP</link> точно также, как и в случае использования
      модема.  Проверьте, что вы задали скорость работы последовательного
      порта максимально высокой.</para>

    <indexterm><primary>PPP</primary></indexterm>
    <para>Главным преимуществом использования TA для подключения к провайдеру
      Интернет является возможность использования динамического PPP.  Так
      как пространство адресов IP истощается все больше, большинство
      провайдеров не хочет больше выдавать вам статический IP-адрес.
      Большинство же маршрутизаторов не может использовать динамическое
      выделение IP-адресов.</para>

    <para>TA полностью полагаются на даемон PPP, который используете из-за
      его возможностей и стабильности соединения.  Это позволяет вам при
      использовании FreeBSD легко заменить модем на ISDN, если у вас уже
      настроено соединение PPP.  Однако, в тоже время любые проблемы, которые
      возникают с программой PPP, отражаются и здесь.</para>

    <para>Если вы хотите максимальной надёжности, используйте <link
      linkend="ppp">PPP</link> на уровне параметра ядра, а не <link
      linkend="userppp">пользовательский PPP</link>.</para>

    <para>Известно, что следующие TA работают с FreeBSD:</para>

    <itemizedlist>
      <listitem>
	<para>Motorola BitSurfer и Bitsurfer Pro</para>
      </listitem>

      <listitem>
	<para>Adtran</para>
      </listitem>
    </itemizedlist>

    <para>Большинство остальных TA, скорее всего, тоже будут работать,
      производители TA прилагают все усилия для обеспечения поддержки
      практически всего набора стандартных AT-команд модема.</para>

    <para>Как и в случае модемов проблемой использования внешнего TA является
      потребность в хорошем последовательном адаптере на вашем
      компьютере.</para>

    <para>Вы должны прочесть учебник <ulink
      url="../../articles/serial-uart/index.html">Последовательные устройства
      во FreeBSD</ulink> для того, чтобы в деталях понять работу
      последовательных устройств и осознать различие между асинхронными и
      синхронными последовательными портами.</para>

    <para>TA, работающий со стандартным последовательным (асинхронным) портом
      PC, ограничивает вас скоростью 115.2&nbsp;Кбит/с, хотя реально у вас
      соединение на скорости 128&nbsp;Кбит/с.  Чтобы использовать
      128&nbsp;Кбит/с, которые обеспечивает ISDN, полностью, вы должны
      подключить TA к синхронному последовательному адаптеру.</para>

    <para>Не обманывайте себя, думая, что покупка встроенного TA поможет
      избежать проблемы синхронности/асинхронности.  Встроенные TA просто
      уже имеют внутри стандартный последовательный порт PC.  Все, что при
      этом достигается - это экономия дополнительных последовательного
      кабеля и электрической розетки.</para>

    <para>Синхронный адаптер с TA по крайней мере так же быстр, как и
      отдельный маршрутизатор, а если он работает под управлением машины
      класса 386 с FreeBSD, то это гораздо более гибкое решение.</para>

    <para>Выбор между использованием синхронного адаптера/TA или отдельного
      маршрутизатора в большей степени является религиозным вопросом.  По этому
      поводу в списках рассылки была некоторая дискуссия.  Рекомендуем поискать
      в <ulink url="../../../../search/index.html">архивах</ulink> обсуждение
      полностью.</para>
  </sect2>

  <sect2>
    <title>Отдельные мосты/маршрутизаторы ISDN</title>

    <indexterm>
      <primary>ISDN</primary>
      <secondary>отдельно стоящие мосты/маршрутизаторы</secondary>
    </indexterm>

    <para>Мосты или маршрутизаторы ISDN не так уж специфичны для FreeBSD
      или для любой другой операционной системы.  Для более подробного
      описания технологий маршрутизации и работы мостов, пожалуйста,
      обратитесь к справочникам по сетевым технологиям.</para>

    <para>В контексте этого раздела термины маршрутизатор и сетевой мост будут
      использоваться как взаимозаменяемые.</para>

    <para>Вместе с падением цен на простые мосты/маршрутизаторы ISDN, они
      становятся все более популярными.  Маршрутизатор ISDN представляет
      собой маленькую коробочку, которая подключается непосредственно в
      вашу сеть Ethernet, и поддерживает связь с другим мостом/маршрутизатором.
      Всё программное обеспечение для работы по PPP и другим протоколам
      встроено в маршрутизатор.</para>

    <para>Маршрутизатор обладает гораздо большей пропускной способностью, чем
      стандартный TA, так как он использует полное синхронное соединение
      ISDN.</para>

    <para>Основной проблемой с маршрутизаторами и мостами ISDN является то,
      что их совместная работа с оборудованием других производителей может
      оказаться под вопросом.  Если вы собираетесь подключаться к провайдеру,
      то вы должны обсудить с ним то, что вам нужно.</para>

    <para>Если вы планируете объединить два сегмента локальной сети, например,
      домашнюю сеть с сетью офиса, это самое простое решение с минимальными
      издержками на обслуживание.  Так как вы покупаете оборудование для
      обоих сторон соединения, то можете быть уверены, что связь будет
      работать нормально.</para>

    <para>Например, для соединения домашнего компьютера или сети
      подразделения к сети центрального офиса, может использоваться такая
      настройка:</para>

    <example>
      <title>Офис подразделения или домашняя сеть</title>

      <indexterm><primary>10 base 2</primary></indexterm>
      <para>Сеть построена в топологии общей шины на основе 10 base 2 Ethernet
        (<quote>thinnet</quote> - <quote>тонкий Ethernet</quote>).  Подключите
        маршрутизатор к сетевому кабелю с помощью трансивера AUI/10BT, если
        это нужно.</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="advanced-networking/isdn-bus">
        </imageobject>

        <textobject>
          <literallayout class="monospaced">---Рабочая станция Sun
|
---Машина с FreeBSD
|
---Windows 95
|
Отдельный маршрутизатор
   |
Канал ISDN BRI</literallayout>
        </textobject>

        <textobject>
          <phrase>10 Base 2 Ethernet</phrase>
        </textobject>
      </mediaobject>

      <para>Если ваш домашний или удаленный офис представляет собой один
	компьютер, то для непосредственного подключения к маршрутизатору вы
	вы можете использовать витую пару с перекрестным соединениям.</para>
    </example>

    <example>
      <title>Центральный офис или другая локальная сеть</title>

      <indexterm><primary>10 base T</primary></indexterm>
      <para>Сеть построена в топологии звезды на основе 10 Base T Ethernet
        (<quote>витая пара</quote>).</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="advanced-networking/isdn-twisted-pair">
        </imageobject>

        <textobject>
          <literallayout class="monospaced">    -------Сервер Novell
    | H |
    |	---Sun
    |	|
    | U ---FreeBSD
    |	|
    |	---Windows 95
    | B |
    |___---Отдельно стоящий маршрутизатор
		|
	 Канал ISDN BRI</literallayout>
        </textobject>

        <textobject>
          <phrase>Схема сети с ISDN</phrase>
        </textobject>
      </mediaobject>
    </example>

    <para>Одним большим преимуществом большинства маршрутизаторов/мостов
      является то, что они позволяют иметь 2 <emphasis>отдельных
      независимых</emphasis> соединения PPP к 2 различным сайтам
      <emphasis>одновременно</emphasis>.  Это не поддерживается в большинстве
      TA, кроме специальных (обычно дорогих) моделей, имеющих по два
      последовательных порта.  Не путайте это с балансировкой нагрузки,
      MPP и так далее.</para>

    <para>Это может оказаться весьма полезной особенностью, например, если
      у вас имеется постоянное ISDN-соединение в вашем офисе, и вы хотите
      им воспользоваться, но не хотите задействовать дополнительный канал
      ISDN на работе.  Маршрутизатор, расположенный в офисе, может
      использовать выделенное соединение по каналу B (64&nbsp;Кбит/с) для
      Интернет,
      и одновременно другой канал B для отдельного соединения для передачи
      данных.  Второй канал B может использоваться для входящих, исходящих
      и динамически распределяемых соединений (MPP и так далее) совместно с
      первым каналом B для повышения пропускной способности.</para>

    <indexterm><primary>IPX/SPX</primary></indexterm>
    <para>Мост Ethernet также позволяет вам передавать больше, чем просто
      трафик IP.  Вы сможете передавать IPX/SPX и любые другие протоколы,
      которые вы используете.</para>
  </sect2>
</sect1>

  <sect1 id="network-nis">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Bill</firstname>
          <surname>Swingle</surname>
          <contrib>Текст создал</contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Eric</firstname>
          <surname>Ogren</surname>
          <contrib>Внёс добавления</contrib>
        </author>
        <author>
          <firstname>Udo</firstname>
          <surname>Erdelhoff</surname>
        </author>
      </authorgroup>
    </sect1info>

    <title>NIS/YP</title>

    <sect2>
      <title>Что это такое?</title>

      <indexterm><primary>NIS</primary></indexterm>
      <indexterm><primary>Solaris</primary></indexterm>
      <indexterm><primary>HP-UX</primary></indexterm>
      <indexterm><primary>AIX</primary></indexterm>
      <indexterm><primary>Linux</primary></indexterm>
      <indexterm><primary>NetBSD</primary></indexterm>
      <indexterm><primary>OpenBSD</primary></indexterm>

      <para>NIS, что является сокращением от Network Information Services
        (Сетевые Информационные Службы), которые были разработаны компанией
        Sun Microsystems для централизованного администрирования систем &unix;
        (изначально &sunos;).  В настоящее время эти службы практически стали
        промышленным стандартом; все основные &unix;-подобные системы
        (&solaris;, HP-UX, &aix;, Linux, NetBSD, OpenBSD, FreeBSD и так далее)
        поддерживают NIS.</para>

      <indexterm>
        <primary>yellow pages</primary>
        <see>NIS</see>
      </indexterm>

      <para>NIS первоначально назывались Yellow Pages (или yp), но из-за
        проблем с торговым знаком Sun изменила это название.  Старое название
        (и yp) всё ещё часто употребляется.</para>

      <indexterm>
        <primary>NIS</primary>
        <secondary>домены</secondary>
      </indexterm>

      <para>Это система клиент/сервер на основе вызовов RPC, которая позволяет
        группе машин в одном домене NIS совместно использовать общий набор
        конфигурационных файлов.  Системный администратор может настроить
        клиентскую систему NIS только с минимальной настроечной информацией, а
        затем добавлять, удалять и модифицировать настроечную информацию из
        одного места.</para>

      <indexterm><primary>Windows NT</primary></indexterm>

      <para>Это похоже на систему доменов &windowsnt;; хотя их внутренние
        реализации не так уж и похожи, основные функции сравнимы.</para>
    </sect2>

    <sect2>
      <title>Термины/программы, о которых вы должны знать</title>

      <para>Существует несколько терминов и некоторое количество
        пользовательских программ, которые будут нужны, когда вы будете
        пытаться сделать NIS во FreeBSD, и в случае создания сервера, и
        в случае работы в качестве клиента NIS:</para>

      <indexterm>
        <primary><application>portmap</application></primary>
      </indexterm>

      <informaltable>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Термин</entry>
              <entry>Описание</entry>
            </row>
          </thead>

          <tbody>
            <row>
	      <entry>Имя домена NIS</entry>

              <entry>Главный сервер NIS и все его клиенты (включая вторичные
                серверы), имеют доменное имя NIS.  Как и в случае с именем
                домена &windowsnt;, имя домена NIS не имеет ничего общего с
                DNS.</entry>
            </row>

            <row>
	      <entry>portmap</entry>

              <entry>Для обеспечения работы RPC (Remote Procedure Call,
                Удалённого Вызова Процедур, сетевого протокола, используемого
                NIS), должен быть запущен даемон <command>portmap</command>.
                Если даемон <command>portmap</command> не запущен, невозможно
                будет запустить сервер NIS, или работать как
                NIS-клиент.</entry>
            </row>

            <row>
              <entry>ypbind</entry>

	      <entry><quote>Связывает</quote>
                NIS-клиента с его NIS-сервером.  Он определяет имя NIS-домена
                системы, и при помощи RPC подключается к серверу.
                <command>ypbind</command> является основой клиент-серверного
                взаимодействия в среде NIS; если на клиентской машине
                программа <command>ypbind</command> перестанет работать, то
	        эта машина не сможет получить доступ к серверу NIS.</entry>
            </row>

            <row>
	      <entry>ypserv</entry>

              <entry>Программа <command>ypserv</command>, которая должна
                запускаться только на серверах NIS: это и есть
                сервер NIS.  Если &man.ypserv.8; перестанет работать, то
                сервер не сможет отвечать на запросы NIS (к счастью, на этот
                случай предусмотрен вторичный сервер).  Есть несколько
                реализаций NIS (к FreeBSD это не относится), в которых не
                производится попыток подключиться к другому серверу, если ранее
                используемый сервер перестал работать.  Зачастую единственным
                средством, помогающим в этой ситуации, является перезапуск
                серверного процесса (или сервера полностью) или процесса
                <command>ypbind</command> на клиентской машине.</entry>
            </row>

            <row>
	      <entry>rpc.yppasswdd</entry>

              <entry>Программа <command>rpc.yppasswdd</command>, другой
                процесс, который запускается только на главных NIS-серверах:
                это даемон, позволяющий клиентам NIS изменять свои
                пароли NIS.  Если этот даемон не запущен, то пользователи
                должны будут входить на основной сервер NIS и там менять свои
                пароли.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <!-- XXX Отсутствует: rpc.ypxfrd (хотя это не очень важно) Может
	   работать только на основном сервере -->
    </sect2>

  <sect2>
    <title>Как это работает?</title>

    <para>В системе NIS существует три типа хостов: основные (master)
      серверы, вторичные (slave) серверы и клиентские машины.  Серверы
      выполняют роль централизованного хранилища информации о конфигурации
      хостов.  Основные серверы хранят оригиналы этой информации, когда как
      вторичные серверы хранят ее копию для обеспечения избыточности.
      Клиенты связываются с серверами, чтобы предоставить им эту
      информацию.</para>

    <para>Информация во многих файлах может совместно использоваться
      следующим образом.  Файлы <filename>master.passwd</filename>,
      <filename>group</filename> и <filename>hosts</filename> используются
      совместно через NIS.  Когда процессу, работающему на клиентской машине,
      требуется информация, как правило, находящаяся в этих файлах локально,
      то он делает запрос к серверу NIS, с которым связан.</para>

    <sect3>
      <title>Типы машин</title>

      <itemizedlist>
        <indexterm>
          <primary>NIS</primary>
          <secondary>главный сервер</secondary>
        </indexterm>

	<listitem>
	  <para><emphasis>Основной сервер NIS</emphasis>.
	    Такой сервер, по аналогии с первичным контроллером домена
            &windowsnt;, хранит файлы, используемые всеми клиентами NIS.  Файлы
	    <filename>passwd</filename>, <filename>group</filename> и
	    различные другие файлы, используемые клиентами NIS, находятся
	    на основном сервере.</para>

	  <note>
	    <para>Возможно использование одной машины в качестве сервера для
	      более чем одного домена NIS.  Однако, в этом введении такая
	      ситуация не рассматривается, и предполагается менее масштабное
	      использование NIS.</para>
	  </note>
	</listitem>

        <indexterm>
          <primary>NIS</primary>
          <secondary>вторичный сервер</secondary>
        </indexterm>
	<listitem>
	  <para><emphasis>Вторичные серверы NIS</emphasis>.  Похожие на
            вторичные контроллеры доменов &windowsnt;, вторичные серверы
	    NIS содержат копии оригинальных файлов данных NIS.	Вторичные
	    серверы NIS обеспечивают избыточность, что нужно в критичных
	    приложениях.  Они также помогают распределять нагрузку на
	    основной сервер: клиенты NIS всегда подключаются к тому серверу
	    NIS, который ответил первым, в том числе и к вторичным
	    серверам.</para>
	</listitem>

        <indexterm>
          <primary>NIS</primary>
          <secondary>клиент</secondary>
        </indexterm>
	<listitem>
	  <para><emphasis>Клиенты NIS</emphasis>.
	    Клиенты NIS, как и большинство рабочих станций &windowsnt;,
	    аутентифицируются на сервере NIS (или на контроллере домена
            &windowsnt; в случае работы с &windowsnt; Workstation) во время
            входа в систему.</para>
	</listitem>
      </itemizedlist>
    </sect3>
  </sect2>

  <sect2>
    <title>Использование NIS/YP</title>

    <para>В этом разделе приводится пример настройки NIS.</para>

    <note>
      <para>В этом разделе предполагается, что вы работаете с FreeBSD&nbsp;3.3
        или выше.  Указания, приводимые здесь, скорее всего,
	<emphasis>будут</emphasis> работать с любой версией FreeBSD, выше,
	чем 3.0, однако нет гарантий, что это на самом деле так.</para>
    </note>

    <sect3>
      <title>Планирование</title>

      <para>Давайте предположим, что вы являетесь администратором в маленькой
	университетской лаборатории.  В настоящий момент в этой лаборатории
	с 15 машинами отсутствует единая точка администрирования; на каждой
	машине имеются собственные файлы <filename>/etc/passwd</filename> и
	<filename>/etc/master.passwd</filename>.  Эти файлы синхронизируются
	друг с другом только вручную; сейчас, когда вы добавляете
	пользователя в лаборатории, вы должны выполнить команду
	<command>adduser</command> на всех 15 машинах.	Понятно, что такое
	положение вещей нужно исправлять, так что вы решили перевести
	сеть на использование NIS, используя две машины в качестве
	серверов.</para>

      <para>Итак, конфигурация лаборатории сейчас выглядит примерно
	так:</para>

      <informaltable>
      <tgroup cols="3">
      <thead>
	<row>
	  <entry>Имя машины</entry>
	  <entry>IP-адрес</entry>
	  <entry>Роль машины</entry>
	</row>
      </thead>

      <tbody>
	<row>
	  <entry><hostid>ellington</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.2</hostid></entry>
	  <entry>Основной сервер NIS</entry>
	</row>

	<row>
	  <entry><hostid>coltrane</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.3</hostid></entry>
	  <entry>Вторичный сервер NIS</entry>
	</row>

	<row>
	  <entry><hostid>basie</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.4</hostid></entry>
	  <entry>Факультетская рабочая станция</entry>
	</row>

	<row>
	  <entry><hostid>bird</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.5</hostid></entry>
	  <entry>Клиентская машина</entry>
	</row>

	<row>
	  <entry><hostid>cli[1-11]</hostid></entry>
	  <entry><hostid role="ipaddr">10.0.0.[6-17]</hostid></entry>
	  <entry>Другие клиентские машины</entry>
	</row>
      </tbody>
      </tgroup>
      </informaltable>

      <para>Если вы определяете схему NIS первый раз, ее нужно хорошо
	обдумать.  Вне зависимости от размеров вашей сети, есть несколько
	ключевых моментов, которые требуют принятия решений.</para>

      <sect4>
	<title>Выбор имени домена NIS</title>

        <indexterm>
          <primary>NIS</primary>
          <secondary>имя домена</secondary>
        </indexterm>
	<para>Это имя не должно быть <quote>именем домена</quote>, которое
	  вы использовали.  Более точно это имя называется <quote>именем
	  домена NIS</quote>.  Когда клиент рассылает запросы на получение
	  информации, он включает в них имя домена NIS, частью которого
	  является.  Таким способом многие сервера в сети могут указать,
	  какой сервер на какой запрос должен отвечать.  Думайте о домене
	  NIS как об имени группы хостов, которые каким-то образом
	  связаны.</para>

	<para>Некоторые организации в качестве имени домена NIS используют
	  свой домен Интернет.	Это не рекомендуется, так как может вызвать
	  проблемы в процессе решения сетевых проблем.	Имя домена NIS должно
	  быть уникальным в пределах вашей сети и хорошо, если оно будет
	  описывать группу машин, которые представляет.  Например,
	  художественный отдел в компании Acme Inc. может находиться в
	  домене NIS с именем <quote>acme-art</quote>.  В нашем примере
          положим, что мы выбрали имя <emphasis>test-domain</emphasis>.</para>

        <indexterm><primary>SunOS</primary></indexterm>
	<para>Несмотря на это, некоторые операционные системы (в частности,
	  &sunos;) используют свое имя домена NIS в качестве имени домена
	  Интернет.  Если одна или более машин в вашей сети имеют такие
	  ограничения, вы <emphasis>обязаны</emphasis> использовать имя
	  домена Интернет в качестве имени домена NIS.</para>
      </sect4>

      <sect4>
	<title>Требования к серверу</title>

	<para>Есть несколько вещей, которые нужно иметь в виду при выборе
	  машины для использования в качестве сервера NIS.  Одной из
	  обескураживающей вещью, касающейся NIS, является уровень
	  зависимости клиентов от серверов.  Если клиент не может
	  подключиться к серверу своего домена NIS, зачастую машину просто
	  становится нельзя использовать.  Отсутствие информации о
	  пользователях и группах приводит к временной остановке работы
	  большинства систем.  Зная это, вы должны выбрать машину, которая
	  не должна подвергаться частым перезагрузкам и не используется
	  для разработки.  Сервер NIS в идеале должен быть отдельно стоящей
	  машиной, единственным целью в жизни которой является быть сервером
	  NIS.	Если вы работаете в сети, которая не так уж сильно загружена,
	  то можно поместить сервер NIS на машине, на которой запущены и
	  другие сервисы, просто имейте в виду, что если сервер NIS
	  становится недоступным, то это негативно отражается на
	  <emphasis>всех</emphasis> клиентах NIS.</para>
      </sect4>
    </sect3>

    <sect3>
      <title>Серверы NIS</title>

      <para>Оригинальные копии всей информации NIS хранится на единственной
	машине, которая называется главным сервером NIS.  Базы данных,
	которые используются для хранения информации, называются картами NIS.
	Во FreeBSD эти карты хранятся в
	<filename>/var/yp/[domainname]</filename>, где
	<filename>[domainname]</filename> является именем обслуживаемого
	домена NIS.  Один сервер NIS может поддерживать одновременно
	несколько доменов, так что есть возможность иметь несколько таких
	каталогов, по одному на каждый обслуживаемый домен.  Каждый домен
	будет иметь свой собственный независимый от других набор карт.</para>

      <para>Основной и вторичный серверы обслуживают все запросы NIS с
	помощью даемона <command>ypserv</command>.  <command>ypserv</command>
	отвечает за получение входящих запросов от клиентов NIS,
	распознавание запрашиваемого домена и отображение имени в путь к
	соответствующему файлы базы данных, а также передаче информации из
	базы данных обратно клиенту.</para>

      <sect4>
	<title>Настройка основного сервера NIS</title>

        <indexterm>
          <primary>NIS</primary>
          <secondary>настройка сервера</secondary>
        </indexterm>
	<para>Настройка основного сервера NIS может оказаться сравнительно
	  простой, в зависимости от ваших потребностей.  В поставку FreeBSD
	  сразу включена поддержка NIS.  Все, что вам нужно, это добавить
	  следующие строки в файл <filename>/etc/rc.conf</filename>, а
	  FreeBSD сделает за вас всё остальное..</para>

        <procedure>
          <step>
	    <para><programlisting>nisdomainname="test-domain"</programlisting>
	      В этой строке задается имя домена NIS, которое будет
	      <emphasis>test-domain</emphasis>, еще до настройки сети
	      (например, после перезагрузки).</para>
          </step>

          <step>
	    <para><programlisting>nis_server_enable="YES"</programlisting>
	      Здесь указывается FreeBSD на запуск процессов серверов NIS,
	      когда дело доходит до сетевых настроек.</para>
          </step>

          <step>
	    <para><programlisting>nis_yppasswdd_enable="YES"</programlisting>
	      Здесь указывается на запуск даемона
	      <command>rpc.yppasswdd</command>, который, как это отмечено
	      выше, позволит пользователям менять свой пароль NIS с
	      клиентской машины.</para>
          </step>
        </procedure>

        <note>
          <para>В зависимости от ваших настроек NIS, вам могут понадобиться
            дополнительные строки.  Обратитесь к <link
            linkend="network-nis-server-is-client">разделу о серверах NIS,
            которые являются и клиентами NIS</link> ниже для получения
            подробной информации.</para>
        </note>

	<para>А теперь всё, что вам нужно сделать, это запустить команду
	  <command>/etc/netstart</command>, работая как администратор.	По
	  ней произойдет настройка всего, при этом будут использоваться
	  значения, заданные в файле <filename>/etc/rc.conf</filename>.</para>
      </sect4>

      <sect4>
	<title>Инициализация карт NIS</title>

        <indexterm>
          <primary>NIS</primary>
          <secondary>карты</secondary>
        </indexterm>
	<para><emphasis>Карты NIS</emphasis> являются файлами баз данных,
	  которые хранятся в каталоге <filename>/var/yp</filename>.
	  Они генерируются из конфигурационных файлов, находящихся в каталоге
	  <filename>/etc</filename> основного сервера NIS, за одним
	  исключением: файл <filename>/etc/master.passwd</filename>.
	  На это есть весомая причина; вам не нужно распространять пароли
	  пользователя <username>root</username> и других административных
          пользователей на все серверы в домене NIS.  По этой причине, прежде
          чем инициализировать карты NIS, вы должны сделать вот что:</para>

	<screen>&prompt.root; <userinput>cp /etc/master.passwd /var/yp/master.passwd</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>vi master.passwd</userinput></screen>

	<para>Вы должны удалить все записи, касающиеся системных
	  пользователей (<username>bin</username>, <username>tty</username>,
          <username>kmem</username>, <username>games</username> и так далее), а
          также записи, которые вы не хотите распространять клиентам NIS
          (например, <username>root</username> и другие пользователи с UID,
          равным 0 (администраторы)).</para>

	<note>
	  <para>Проверьте, чтобы файл
	    <filename>/var/yp/master.passwd</filename> был недоступен для
	    записи ни для группы, ни для остальных пользователей (режим
	    доступа 600)!  Воспользуйтесь командой <command>chmod</command>,
	    если это нужно.</para>
	</note>

        <indexterm><primary>Tru64 UNIX</primary></indexterm>
	<para>Когда с этим будет покончено, самое время проинициализировать
	  карты NIS!  В поставку FreeBSD включен скрипт с именем
	  <command>ypinit</command>, который делает это (обратитесь к его
	  справочной странице за дополнительной информацией).  Отметьте, что
	  этот скрипт имеется в большинстве операционных систем &unix;, но не
          во всех.  В системе Digital Unix/Compaq Tru64 UNIX он называется
	  <command>ypsetup</command>.  Так как мы генерируем карты для
	  главного сервера NIS, то при вызове программы
	  <command>ypinit</command> мы передаем ей параметр
	  <option>-m</option>.	Для генерации карт NIS в предположении, что
	  вы уже сделали шаги, описанные выше, выполните следующее:</para>

	<screen>ellington&prompt.root; <userinput>ypinit -m test-domain</userinput>
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] <userinput>n</userinput>
Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server	:  ellington
next host to add:  <userinput>coltrane</userinput>
next host to add:  <userinput>^D</userinput>
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] <userinput>y</userinput>

[..вывод при генерации карт..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</screen>

	<para>Программа <command>ypinit</command> должна была создать файл
	  <filename>/var/yp/Makefile</filename> из
	  <filename>/var/yp/Makefile.dist</filename>.  При создании этого
	  файла предполагается, что вы работаете в окружении с единственным
	  сервером NIS и только с машинами FreeBSD.  Так как в домене
	  <emphasis>test-domain</emphasis> имеется также и вторичный сервер,
	  то вы должны отредактировать файл
	  <filename>/var/yp/Makefile</filename>:</para>

	<screen>ellington&prompt.root; <userinput>vi /var/yp/Makefile</userinput></screen>

	<para>Вы должны закомментировать строку, в которой указано</para>

        <programlisting>NOPUSH = "True"</programlisting>

	<para>(она уже не раскомментирована).</para>
      </sect4>

      <sect4>
	<title>Настройка вторичного сервера NIS</title>

        <indexterm>
          <primary>NIS</primary>
          <secondary>вторичный сервер</secondary>
        </indexterm>

	<para>Настройка вторичного сервера NIS осуществляется ещё проще,
	  чем настройка главного сервера.  Войдите на вторичный сервер и
	  отредактируйте файл <filename>/etc/rc.conf</filename> точно также,
	  как вы делали это ранее.  Единственным отличием является то, что
	  при запуске программы <command>ypinit</command> мы теперь должны
	  использовать опцию <option>-s</option>.  Применение опции
	  <option>-s</option> требует также указание имени главного сервера
	  NIS, так что наша команда должна выглядеть так:</para>

	<screen>coltrane&prompt.root; <userinput>ypinit -s ellington test-domain</userinput>

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  <userinput>n</userinput>

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don't forget to update map ypservers on ellington.</screen>

	<para>Теперь у вас должен быть каталог с именем
	  <filename>/var/yp/test-domain</filename>.  Копии карт главного
	  сервера NIS должны быть в этом каталоге.  Вы должны удостовериться,
	  что этот каталог обновляется.  Следующие строки в
	  <filename>/etc/crontab</filename> вашего вторичного сервера должны
	  это делать:</para>

	<programlisting>20	*	*	*	*	root   /usr/libexec/ypxfr passwd.byname
21	*	*	*	*	root   /usr/libexec/ypxfr passwd.byuid</programlisting>

	<para>Эти две строки заставляют вторичный сервер синхронизировать
	  свои карты с картами главного сервера.  Хотя эти строчки не
          обязательны, так как главный сервер делает попытки передать все
          изменения в своих картах NIS на свои вторичные серверы, но из-за
          того, что информация для входа в систему настолько жизненно важна для
	  систем, зависящих от сервера, что выполнение регулярных обновлений
	  является совсем не плохой идеей.  Это ещё более важно в загруженных
	  сетях, в которых обновления карт могут не всегда завершаться
	  успешно.</para>

	<para>А теперь точно также запустите команду
	  <command>/etc/netstart</command> на вторичном сервере, по которой
	  снова выполнится запуск сервера NIS.</para>
      </sect4>
    </sect3>

    <sect3>
      <title>Клиенты NIS</title>

      <para>Клиент NIS выполняет так называемую привязку к конкретному
	серверу NIS при помощи даемона <command>ypbind</command>.
	<command>ypbind</command> определяет домен, используемый в системе
	по умолчанию (тот, который устанавливается по команде
	<command>domainname</command>), и начинает широковещательную рассылку
	запросов RPC в локальной сети.	В этих запросах указано имя домена,
	к серверу которого <command>ypbind</command> пытается осуществить
	привязку.  Если сервер, который был настроен для обслуживания
	запрашиваемого домена, получит широковещательный запрос, он ответит
	<command>ypbind</command>, который, в свою очередь запомнит адрес
	сервера.  Если имеется несколько серверов (например, главный и
	несколько вторичных), то <command>ypbind</command> будет использовать
	адрес первого ответившего.  С этого момента клиентская система будет
	направлять все свои запросы NIS на этот сервер.  Время от времени
	<command>ypbind</command> будет <quote>пинать</quote> сервер для
        проверки его работоспособности.
	Если на один из тестовых пакетов не удастся получить ответа за
	разумное время, то <command>ypbind</command> пометит этот домен как
	домен, с которым связка разорвана, и снова начнет процесс посылки
	широковещательных запросов в надежде найти другой сервер.</para>

      <sect4>
	<title>Настройка клиента NIS</title>

        <indexterm>
          <primary>NIS</primary>
          <secondary>настройка клиента</secondary>
        </indexterm>
	<para>Настройка машины с FreeBSD в качестве клиента NIS достаточно
	  проста.</para>

        <procedure>
          <step>
	    <para>Отредактируйте файл <filename>/etc/rc.conf</filename>,
	      добавив туда следующие строки для того, чтобы задать имя домена
	      NIS и запустить <command>ypbind</command> во время запуска
	      сетевых служб:</para>

	    <programlisting>nisdomainname="test-domain"
nis_client_enable="YES"</programlisting>
          </step>

          <step>
	    <para>Для импортирования всех возможных учётных записей от сервера
              NIS, удалите все записи пользователей из вашего файла
              <filename>/etc/master.passwd</filename> и воспользуйтесь
              командой <command>vipw</command> для добавления следующей строки
              в конец файла:</para>

	    <programlisting>+:::::::::</programlisting>

	    <note>
	      <para>Эта строчка даст всем пользователям с корректной учетной
		записью в картах учетных баз пользователей доступ к этой
		системе.  Есть множество способов настроить ваш клиент NIS,
		изменив эту строку.  Посмотрите ниже текст, касающийся <link
                linkend="network-netgroups">сетевых групп</link>, чтобы
                получить более подробную информацию.  Дополнительная информация
                для изучения находится в книге издательства O'Reilly под
                названием <literal>Managing NFS and NIS</literal>.</para>
	    </note>

            <note>
              <para>Вы должны оставить хотя бы одну локальную запись (то есть
                не импортировать ее через NIS) в вашем
                <filename>/etc/master.passwd</filename> и эта запись должна
                быть также членом группы <groupname>wheel</groupname>.  Если
                с NIS что-то случится, эта запись может использоваться для
                удаленного входа в систему, перехода в режим администратора и
                исправления неисправностей.</para>
              </note>
            </step>

            <step>
	      <para>Для импортирования всех возможных записей о группах с
	        сервера NIS, добавьте в ваш файл
	        <filename>/etc/group</filename> такую строчку:</para>

	      <programlisting>+:*::</programlisting>
            </step>
          </procedure>

	  <para>После завершения выполнения этих шагов у вас должно получиться
	    запустить команду <command>ypcat passwd</command> и увидеть
	    карту учетных записей сервера NIS.</para>
        </sect4>
      </sect3>
    </sect2>

  <sect2>
    <title>Безопасность NIS</title>

    <para>В общем-то любой пользователь, зная имя вашего домена, может
      выполнить запрос RPC к &man.ypserv.8; и получить содержимое ваших карт
      NIS.  Для предотвращения такого неавторизованного обмена &man.ypserv.8;
      поддерживает так называемую систему securenets, которая может
      использоваться для ограничения доступа к некоторой группе хостов.  При
      запуске &man.ypserv.8; будет пытаться загрузить информацию, касающуюся
      securenets, из файла <filename>/var/yp/securenets</filename>.</para>

    <note>
      <para>Имя каталога зависит от параметра, указанного вместе с опцией
	<option>-p</option>.  Этот файл содержит записи, состоящие из
	указания сети и сетевой маски, разделенных пробелом.  Строчки,
	начинающиеся со знака <quote>#</quote>, считаются комментариями.
	Примерный файл securenets может иметь примерно такой вид:</para>
    </note>

    <programlisting># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0</programlisting>

    <para>Если &man.ypserv.8; получает запрос от адреса, который соответствует
      одному из этих правил, он будет отрабатывать запрос обычным образом.
      Если же адрес не подпадает ни под одно правило, запрос будет
      проигнорирован и в журнал будет записано предупреждающее сообщение.  Если
      файл <filename>/var/yp/securenets</filename> не существует,
      <command>ypserv</command> будет обслуживать соединения от любого
      хоста.</para>

    <para>Программа <command>ypserv</command> также поддерживает пакет программ
      <application>tcpwrapper</application> от Wietse Venema.  Это позволяет
      администратору для ограничения доступа вместо
      <filename>/var/yp/securenets</filename> использовать конфигурационные
      файлы <application>tcpwrapper</application>.</para>

    <note>
      <para>Хотя оба этих метода управления доступом обеспечивают некоторую
	безопасность, они, как основанные на проверке привилегированного
        порта, оба подвержены атакам типа <quote>IP spoofing</quote>.  Весь
        сетевой трафик, связанный с работой NIS, должен блокироваться вашим
        межсетевым экраном.</para>

      <para>Серверы, использующие файл <filename>/var/yp/securenets</filename>,
        могут быть не в состоянии обслуживать старых клиентов NIS с древней
        реализацией протокола TCP/IP.  Некоторые из этих реализаций при
        рассылке широковещательных запросов устанавливают все биты машинной
        части адреса в ноль и/или не в состоянии определить маску подсети при
        вычислении адреса широковещательной рассылки.  Хотя некоторые из этих
        проблем могут быть решены изменением конфигурации клиента, другие
        могут привести к отказу от использования
        <filename>/var/yp/securenets</filename>.</para>

      <para>Использование <filename>/var/yp/securenets</filename> на сервере
        с такой архаичной реализацией TCP/IP является весьма плохой идеей, и
        приведёт к потере работоспособности NIS в большой части вашей
        сети.</para>

      <indexterm><primary>tcpwrapper</primary></indexterm>
      <para>Использование пакета <application>tcpwrapper</application> увеличит
        время отклика вашего сервера NIS.  Дополнительной задержки может
        оказаться достаточно для возникновения таймаутов в клиентских
        программах, особенно в загруженных сетях или с медленными серверами
        NIS.  Если одна или более ваших клиентских систем страдают от таких
        проблем, вы должны преобразовать такие клиентские системы во вторичные
        серверы NIS и сделать принудительную их привязку к самим себе.</para>
    </note>
  </sect2>

  <sect2>
    <title>Запрет входа некоторых пользователей</title>

    <para>В нашей лаборатории есть машина <hostid>basie</hostid>, о которой
      предполагается, что она является исключительно факультетской рабочей
      станцией.  Мы не хотим исключать эту машину из домена NIS, однако
      файл <filename>passwd</filename> на главном сервере NIS содержит
      учетные записи как для работников факультета, так и студентов.  Что мы
      можем сделать?</para>

    <para>Есть способ ограничить вход некоторых пользователей на этой машине,
      даже если они присутствуют в базе данных NIS.  Чтобы это сделать, вам
      достаточно добавить
      <emphasis>-<replaceable>username</replaceable></emphasis> в конец файла
      <filename>/etc/master.passwd</filename> на клиентской машине, где
      <replaceable>username</replaceable> является именем пользователя,
      которому вы хотите запретить вход.  Рекомендуется сделать это с помощью
      утилиты <command>vipw</command>, так как <command>vipw</command>
      проверит ваши изменения в <filename>/etc/master.passwd</filename>, а
      также автоматически перестроит базу данных паролей по окончании
      редактирования.  Например, если мы хотим запретить пользователю
      <emphasis>bill</emphasis> осуществлять вход на машине
      <hostid>basie</hostid>, то мы сделаем следующее:</para>

    <screen>basie&prompt.root; <userinput>vipw</userinput>
<userinput>[add -bill to the end, exit]</userinput>
vipw: rebuilding the database...
vipw: done

basie&prompt.root; <userinput>cat /etc/master.passwd</userinput>

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/share/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
-bill

basie&prompt.root;</screen>
  </sect2>

    <sect2 id="network-netgroups">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Udo</firstname>
            <surname>Erdelhoff</surname>
            <contrib>Текст предоставил</contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Использование сетевых групп</title>
      <indexterm><primary>сетевые группы</primary></indexterm>

      <para>Способ, описанный в предыдущем разделе, работает достаточно хорошо,
	если вам нужны особые правила для очень малой группы пользователей или
	машин.	В более крупных сетях вы <emphasis>забудете</emphasis> о
	запрете входа определенных пользователей на важные машины или даже
	будете настраивать каждую машину по отдельности, теряя таким образом
	главное преимущество использования NIS,
	<emphasis>централизованное</emphasis> администрирование.</para>

      <para>Ответом разработчиков NIS на эту проблему являются
	<emphasis>сетевые группы</emphasis>.  Их назначение и смысл можно
	сравнить с обычными группами, используемыми в файловых системах &unix;.
	Главное отличие заключается в отсутствии числового идентификатора и
	возможности задать сетевую группу включением как пользователей, так и
	других сетевых групп.</para>

      <para>Сетевые группы были разработаны для работы с большими, сложными
	сетями с сотнями пользователей и машин.  С одной стороны, хорошо, если
	вам приходится с такой ситуацией.  С другой стороны, эта сложность
	делает невозможным описание сетевых групп с помощью простых примеров.
	Пример, используемый в дальнейшем, демонстрирует эту проблему.</para>

      <para>Давайте предположим, что успешное внедрение системы NIS в вашей
	лаборатории заинтересовало ваше руководство.  Вашим следующим заданием
	стало расширение домена NIS для включения в него некоторых других
	машин студенческого городка.  В двух таблицах перечислены имена
	новых машин и пользователей, а также их краткое описание.</para>

      <informaltable>
      <tgroup cols="2">
      <thead>
	<row>
	  <entry>Имена пользователей</entry>
	  <entry>Описание</entry>
	</row>
      </thead>

      <tbody>
	<row>
	  <entry>alpha, beta</entry>
	  <entry>Обычные служащие IT-департамента</entry>
	</row>

	<row>
	  <entry>charlie, delta</entry>
	  <entry>Практиканты IT-департамента</entry>
	</row>
	
	<row>
	  <entry>echo, foxtrott, golf, ...</entry>
	  <entry>Обычные сотрудники</entry>
	</row>

	<row>
	  <entry>able, baker, ...</entry>
	  <entry>Проходящие интернатуру</entry>
	</row>
      </tbody>
      </tgroup>
      </informaltable>

      <informaltable>
      <tgroup cols="2">
      <thead>
	<row>
	  <entry>Имена машин</entry>
	  <entry>Описание</entry>
	</row>
      </thead>

      <tbody>
	<row>
	  <!--	Имена взяты из книги "Good Omens" (авторы Neil Gaiman и
		Terry Pratchett.  Большое спасибо за прекрасную книгу.	-->
	  <entry>war, death, famine, pollution</entry>
	  <entry>Ваши самые важные серверы.  Только служащим IT позволяется
	    входить на эти машины.</entry>
	</row>

	<row>
	  <!-- gluttony был пропущен, потому что он был слишком толст -->
	  <entry>pride, greed, envy, wrath, lust, sloth</entry>
	  <entry>Менее важные серверы.	Все сотрудники департамента IT могут
	    входить на эти машины.</entry>
	</row>

	<row>
	  <entry>one, two, three, four, ...</entry>
	  <entry>Обычные рабочие станции.  Только
	    <emphasis>реально нанятым</emphasis> служащим позволяется
	    использовать эти машины.</entry>
	</row>

	<row>
	  <entry>trashcan</entry>
	  <entry>Очень старая машина без каких-либо критичных данных.  Даже
	    проходящим интернатуру разрешено ее использовать.</entry>
	</row>
      </tbody>
      </tgroup>
      </informaltable>

      <para>Если вы попытаетесь реализовать эти требования, ограничивая
	каждого пользователя по отдельности, то вам придется добавить на каждой
        машине в файл <filename>passwd</filename> по одной строчке
	-<replaceable>user</replaceable> для каждого пользователя, которому
	запрещено входить на эту систему.  Если вы забудете даже одну строчку,
	у вас могут начаться проблемы.	Гораздо проще делать это правильно во
	время начальной установки, однако вы постепенно <emphasis>будете
	забывать</emphasis> добавлять строчки для новых пользователей во время
	повседневной работы.  В конце концов, Мерфи был оптимистом.</para>

      <para>Использование в этой ситуации сетевых групп дает несколько
	преимуществ.  Нет необходимости описывать по отдельности каждого
	пользователя; вы ставите в соответствие пользователю одну или
	несколько сетевых групп и разрешаете или запрещаете вход всем членам
	сетевой группы.  Если вы добавляете новую машину, вам достаточно
	определить ограничения на вход для сетевых групп.  Если добавляется
	новый пользователь, вам достаточно добавить его к одной или большему
	числу сетевых групп.  Эти изменения независимы друг от друга; нет
	больше комбинаций <quote>для каждого пользователя и машины</quote>.
	Если настройка вашей системы NIS тщательно спланирована, то для
	разрешения или запрещения доступа к машинам вам нужно будет
	модифицировать единственный конфигурационный файл.</para>

      <para>Первым шагом является инициализация карты NIS по имени netgroup.
	Программа &man.ypinit.8; во FreeBSD по умолчанию этой карты не
        создаёт, хотя реализация NIS будет её поддерживает, как только она
        будет создана.  Чтобы создать пустую карту, просто наберите</para>

      <screen>ellington&prompt.root; <userinput>vi /var/yp/netgroup</userinput></screen>

      <para>и начните добавлять содержимое.  Например, нам нужно по крайней
	мере четыре сетевых группы: сотрудники IT, практиканты IT, обычные
	сотрудники и интернатура.</para>

      <programlisting>IT_EMP	(,alpha,test-domain)	(,beta,test-domain)
IT_APP	(,charlie,test-domain)	(,delta,test-domain)
USERS	(,echo,test-domain)	(,foxtrott,test-domain) \
	(,golf,test-domain)
INTERNS (,able,test-domain)	(,baker,test-domain)</programlisting>

      <para><literal>IT_EMP</literal>, <literal>IT_APP</literal> и так далее
	являются именами сетевых групп.  Несколько слов в скобках служат для
	добавления пользователей в группу.  Три поля внутри группы обозначают
	следующее:</para>

      <orderedlist>
	<listitem>
	  <para>Имя хоста или хостов, к которым применимы последующие записи.
	    Если имя хоста не указано, то запись применяется ко всем хостам.
	    Если же указывается имя хоста, то вы получите мир темноты, ужаса
	    и страшной путаницы.</para>
	</listitem>

	<listitem>
	  <para>Имя учетной записи, которая принадлежит этой сетевой
	    группе.</para>
	</listitem>

	<listitem>
	  <para>Домен NIS для учетной записи.  Вы можете импортировать в вашу
	    сетевую группу учетные записи из других доменов NIS, если вы один
	    из тех несчастных, имеющих более одного домена NIS.</para>
	</listitem>
      </orderedlist>

      <para>Каждое из этих полей может содержать шаблоны, подробности даны в
	странице справочника по &man.netgroup.5;.</para>

      <note>
        <indexterm><primary>сетевые группы</primary></indexterm>
	<para>Не нужно использовать имена сетевых групп длиннее 8 символов,
	  особенно если в вашем домене NIS имеются машины, работающие под
	  управлением других операционных систем.  Имена чувствительны к
	  регистру; использование заглавных букв для имен сетевых групп
	  облегчает распознавание пользователей, имен машин и сетевых
	  групп.</para>

	<para>Некоторые клиенты NIS (отличные от FreeBSD) не могут работать
	  с сетевыми группами, включающими большое количество записей.
	  Например, в некоторых старых версиях &sunos; возникают проблемы, если
	  сетевая группа содержит более 15 <emphasis>записей</emphasis>.  Вы
	  можете обойти это ограничение, создав несколько подгрупп с 15 или
	  меньшим количеством пользователей и настоящую сетевую группу,
	  состоящую из подгрупп:</para>

	<programlisting>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</programlisting>

	<para>Вы можете повторить этот процесс, если вам нужно иметь более 225
	  пользователей в одной сетевой группе.</para>
      </note>

      <para>Активация и распространение вашей карты NIS проста:</para>

      <screen>ellington&prompt.root; <userinput>cd /var/yp</userinput>
ellington&prompt.root; <userinput>make</userinput></screen>

      <para>Это приведет к созданию трех карт NIS
	<filename>netgroup</filename>, <filename>netgroup.byhost</filename> и
	<filename>netgroup.byuser</filename>.  Воспользуйтесь утилитой
	&man.ypcat.1; для проверки доступности ваших новых карт NIS:</para>

      <screen>ellington&prompt.user; <userinput>ypcat -k netgroup</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byhost</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byuser</userinput></screen>

      <para>Вывод первой команды должен соответствовать содержимому файла
	<filename>/var/yp/netgroup</filename>.	Вторая команда не выведет
	ничего, если вы не зададите сетевые группы, специфичные для хоста.
	Третья команда может использоваться пользователем для получения
	списка сетевых групп.</para>

      <para>Настройка клиента достаточно проста.  Чтобы настроить сервер
	<replaceable>war</replaceable>, вам достаточно запустить &man.vipw.8;
	и заменить строку</para>

      <programlisting>+:::::::::</programlisting>

      <para>на</para>

      <programlisting>+@IT_EMP:::::::::</programlisting>

      <para>Теперь только данные, касающиеся пользователей, определенных в
	сетевой группе <replaceable>IT_EMP</replaceable>, импортируются в
	базу паролей машины <replaceable>war</replaceable> и только этим
	пользователям будет разрешен вход.</para>

      <para>К сожалению, это ограничение также касается и функции ~ командного
	процессора и всех подпрограмм, выполняющих преобразование между
	именами пользователей и их числовыми ID.  Другими
	словами, команда <command>cd ~<replaceable>user</replaceable></command>
        работать не будет, команда <command>ls -l</command> будет выдавать
        числовые идентификаторы вместо имён пользователей, а
        <command>find . -user joe -print</command> работать откажется, выдавая
        сообщение <errorname>No such user</errorname>.  Чтобы это исправить,
        вам нужно будет выполнить импорт всех записей о пользователях
        <emphasis>без разрешения на вход на ваши серверы</emphasis>.</para>

      <para>Это можно сделать, добавив еще одну строку в файл
	<filename>/etc/master.passwd</filename>.  Эта строка должна
        содержать:</para>

      <para><literal>+:::::::::/sbin/nologin</literal>, что означает
	<quote>Произвести импортирование всех записей с заменой командного
	процессора на <filename>/sbin/nologin</filename> в импортируемых
	записях</quote>.  Вы можете заменить любое поле в строке с паролем,
	указав значение по умолчанию в вашем
	<filename>/etc/master.passwd</filename>.</para>

      <!-- Been there, done that, got the scars to prove it - ue -->
      <warning>
	<para>Проверьте, что строка
	  <literal>+:::::::::/sbin/nologin</literal> помещена после
	  <literal>+@IT_EMP:::::::::</literal>.  В противном случае все
	  пользовательские записи, импортированные из NIS, будут иметь
	  /sbin/nologin в качестве оболочки.</para>
      </warning>

      <para>После этого изменения при появлении нового сотрудника IT вам будет
	достаточно изменять только одну карту NIS.  Вы можете применить
	подобный метод для менее важных серверов, заменяя
	старую строку <literal>+:::::::::</literal> в их файлах
	<filename>/etc/master.passwd</filename> на нечто, подобное
	следующему:</para>

      <programlisting>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Соответствующие строки для обычных рабочих станций могут иметь
	такой вид:</para>

      <programlisting>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>И все было прекрасно до того момента, когда через несколько
	недель изменилась политика: Департамент IT начал нанимать интернатуру.
	Интернатуре в IT позволили использовать обычные рабочие станции и
	менее важные серверы; практикантам позволили входить на главные
	серверы.  Вы создали новую сетевую группу IT_INTERN, добавили в нее
	новую интернатуру и начали изменять настройки на всех и каждой
	машине...  Как говорит старая мудрость: <quote>Ошибки в
	централизованном планировании приводят к глобальному
	хаосу</quote>.</para>

      <para>Возможность в NIS создавать сетевые группы из других сетевых
	групп может использоваться для предотвращения подобных ситуаций.  Одним
	из вариантов является создание сетевых групп на основе ролей.
	Например, вы можете создать сетевую группу с именем
	<replaceable>BIGSRV</replaceable> для задания ограничений на вход на
	важные серверы, другую сетевую группу с именем
	<replaceable>SMALLSRV</replaceable> для менее важных серверов и третью
	сетевую группу под названием <replaceable>USERBOX</replaceable> для
	обычных рабочих станций.  Каждая из этих сетевых групп содержит
	сетевые группы, которым позволено входить на эти машины.  Новые записи
	для вашей карты NIS сетевой группы должны выглядеть таким
	образом:</para>

      <programlisting>BIGSRV	  IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</programlisting>

      <para>Этот метод задания ограничений на вход работает весьма хорошо,
	если вы можете выделить группы машин с одинаковыми ограничениями.  К
	сожалению, такая ситуация может быть исключением, но не правилом.  В
	большинстве случаев вам нужна возможность определять ограничения на
	вход индивидуально для каждой машины.</para>

      <para>Задание сетевых групп в зависимости от машин является другой
	возможностью, которой можно воспользоваться при изменении политики,
	описанной выше.  При таком развитии событий файл
	<filename>/etc/master.passwd</filename> на каждой машине содержит две
	строки, начинающиеся с <quote>+</quote>.  Первая из них добавляет
        сетевую группу с учётными записями, которым разрешено входить на эту
        машину, а вторая добавляет все оставшиеся учетные записи с
	<filename>/sbin/nologin</filename> в качестве командного процессора.
	Хорошей идеей является использование ИМЕНИ МАШИНЫ заглавными буквами
	для имени сетевой группы.  Другими словами, строки должны иметь такой
	вид:</para>

      <programlisting>+@<replaceable>BOXNAME</replaceable>:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>Как только вы завершите эту работу для всех ваших машин, вам не
	нужно будет снова модифицировать локальные версии
	<filename>/etc/master.passwd</filename>.  Все будущие изменения могут
	быть выполнены изменением карты NIS.  Вот пример возможной карты
	сетевой группы для этого случая с некоторыми полезными
	дополнениями.</para>

      <programlisting># Сначала определяем группы пользователей
IT_EMP	  (,alpha,test-domain)	  (,beta,test-domain)
IT_APP	  (,charlie,test-domain)  (,delta,test-domain)
DEPT1	  (,echo,test-domain)	  (,foxtrott,test-domain)
DEPT2	  (,golf,test-domain)	  (,hotel,test-domain)
DEPT3	  (,india,test-domain)	  (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)	  (,lima,test-domain)
D_INTERNS (,able,test-domain)	  (,baker,test-domain)
#
# Теперь задаем несколько групп на основе ролей
USERS	  DEPT1   DEPT2     DEPT3
BIGSRV	  IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# И группы для специальных задач
# Открыть пользователям echo и golf доступ к антивирусной машине
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# Сетевые группы, специфичные для машин
# Наши главные серверы
WAR	  BIGSRV
FAMINE	  BIGSRV
# Пользователю india необходим доступ к этому серверу
POLLUTION  BIGSRV  (,india,test-domain)
#
# Этот очень важен и ему требуются большие ограничения доступа
DEATH	  IT_EMP
#
# Антивирусная машина, упомянутая выше
ONE	  SECURITY
#
# Ограничить машину единственным пользователем
TWO	  (,hotel,test-domain)
# [...далее следуют другие группы]</programlisting>

      <para>Если вы используете какие-либо базы данных для управления
	учетными записями ваших пользователей, вы должны смочь создать первую
	часть карты с помощью инструментов построения отчетов вашей базы
	данных.  В таком случае новые пользователи автоматически получат
	доступ к машинам.</para>

      <para>И последнее замечание: Не всегда бывает разумно использовать
	сетевые группы на основе машин.  Если в студенческих лабораториях вы
	используете несколько десятков или даже сотен одинаковых машин, то
	вам нужно использовать сетевые группы на основе ролей, а не основе
	машин, для того, чтобы размеры карты NIS оставались в разумных
	пределах.</para>
    </sect2>

  <sect2>
    <title>Важные замечания</title>

    <para>Есть некоторые действия, которые нужно будет выполнять по-другому,
      если вы работаете с NIS.</para>

    <itemizedlist>
      <listitem>
	<para>Каждый раз, когда вы собираетесь добавить пользователя в
	  лаборатории, вы должны добавить его <emphasis>только</emphasis> на
	  главном сервере NIS и <emphasis>обязательно перестроить карты
	  NIS</emphasis>.  Если вы забудете сделать это, то новый
	  пользователь не сможет нигде войти, кроме как на главном сервере
	  NIS.	Например, если в лаборатории нам нужно добавить нового
	  пользователя <quote>jsmith</quote>, мы делаем вот что:</para>

	<screen>&prompt.root; <userinput>pw useradd jsmith</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>make test-domain</userinput></screen>

	<para>Вместо <command>pw useradd jsmith</command> вы можете также
	  запустить команду <command>adduser jsmith</command>.</para>
      </listitem>

      <listitem>
	<para><emphasis>Не помещайте административные учетные записи в карты
	  NIS</emphasis>.  Вам не нужно распространять административных
	  пользователей и их пароли на машины, которые не должны иметь доступ
	  к таким учётным записям.</para>
      </listitem>

      <listitem>
	<para><emphasis>Сделайте главный и вторичные серверы NIS безопасными
	  и минимизируйте их время простоя</emphasis>.	Если кто-то либо
	  взломает, либо просто отключит эти машины, то люди без права
	  входа в лабораторию с легкостью получат доступ.</para>

	<para>Это основное уязвимое место в любой централизованно
	  администрируемой системе.  Если вы не
	  защищаете ваши серверы NIS, вы будете иметь дело с толпой
	  разозлённых пользователей!</para>
      </listitem>
    </itemizedlist>
  </sect2>

  <sect2>
    <title>Совместимость с NIS v1</title>

    <para><application>ypserv</application> из поставки FreeBSD имеет
      встроенную поддержку для обслуживания клиентов NIS v1.  Реализация NIS
      во FreeBSD использует только протокол NIS v2, хотя другие реализации
      имеют поддержку протокола v1 для совместимости со старыми системами.
      Даемоны <application>ypbind</application>, поставляемые с такими
      системами, будут пытаться осуществить привязку к серверу NIS v1, даже
      если это им не нужно (и они будут постоянно рассылать широковещательные
      запросы в поиске такого сервера даже после получения ответа от сервера
      v2).  Отметьте, что хотя имеется поддержка обычных клиентских вызовов,
      эта версия ypserv не отрабатывает запросы на передачу карт v1;
      следовательно, она не может использоваться в качестве главного или
      вторичного серверов вместе с другими серверами NIS, поддерживающими
      только протокол v1.  К счастью, скорее всего, в настоящий момент
      такие серверы практически не используются.</para>
  </sect2>

    <sect2 id="network-nis-server-is-client">
      <title>Серверы NIS, которые также являются клиентами NIS</title>

      <para>Особое внимание следует уделить использованию ypserv в домене со
        многими серверами, когда серверные машины являются также клиентами NIS.
        Неплохо бы заставить серверы осуществить привязку к самим себе,
        запретив рассылку запросов на привязку и возможно, перекрестную
        привязку друг к другу.  Если один сервер выйдет из строя, а другие
        будут зависеть от него, то в результате могут возникнуть странные
        ситуации.  Постепенно все клиенты попадут в таймаут и попытаются
        привязаться к другим серверам, но полученная задержка может быть
        значительной, а странности останутся, так как серверы снова могут
        привязаться друг к другу.</para>

      <para>Вы можете заставить хост выполнить привязку к конкретному серверу,
        запустив команду <command>ypbind</command> с флагом
        <option>-S</option>.  Если вы не хотите делать это вручную каждый
        раз при перезагрузке
        вашего сервера NIS, то можете добавить в файл
        <filename>/etc/rc.conf</filename> такие строки:</para>

      <programlisting>nis_client_enable="YES"   # run client stuff as well
nis_client_flags="-S <replaceable>NIS domain</replaceable>,<replaceable>server</replaceable>"</programlisting>

      <para>Дополнительную информацию можно найти на странице справки по
        &man.ypbind.8;.</para>
    </sect2>

    <sect2>
      <title>Форматы паролей</title>

      <indexterm>
        <primary>NIS</primary>
        <secondary>форматы паролей</secondary>
      </indexterm>

      <para>Одним из общих вопросов, которые возникают в начале работы с NIS,
        является вопрос совместимости форматов паролей.  Если ваш сервер NIS
        использует пароли, зашифрованные алгоритмом DES, то он будет
        поддерживать только тех клиентов, что также используют DES.  К
        примеру, если в вашей сети имеются клиенты NIS, использующие &solaris;,
        то вам, скорее всего, необходимо использовать пароли с шифрованием по
        алгоритму DES.</para>

      <para>Чтобы понять, какой формат используют ваши серверы и клиенты,
        загляните в файл <filename>/etc/login.conf</filename>.  Если хост
        настроен на использование паролей, зашифрованных по алгоритму DES,
        то класс <literal>default</literal> будет содержать запись вроде
        следующей:</para>

      <programlisting>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Последующие строки опущены]</programlisting>

      <para>Другими возможными значениями для <literal>passwd_format</literal>
        являются <literal>blf</literal> и <literal>md5</literal> (для паролей,
        шифруемых по стандартам Blowfish и MD5 соответственно).</para>

      <para>Если вы внесли изменения в файл
        <filename>/etc/login.conf</filename>, то вам также нужно перестроить
        базу данных параметров входа в систему, что достигается запуском
        следующей команды пользователем <username>root</username>:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>

      <note>
        <para>Формат паролей, которые уже находятся в файле
	  <filename>/etc/master.passwd</filename>, не будет изменён до тех пор,
          пока пользователь не сменит свой пароль <emphasis>после</emphasis>
          перестроения базы данных параметров входа в систему.</para>
      </note>

      <para>После этого, чтобы удостовериться в том, что пароли зашифрованы
        в том формате, который выбран вами, нужно проверить, что строка
	<literal>crypt_default</literal> в <filename>/etc/auth.conf</filename>
        указывает предпочтение выбранного вами формата паролей.  Для этого
        поместите выбранный формат первым в списке.  Например, при
        использовании DES-шифрования паролей строка будет выглядеть так:</para>

      <programlisting>crypt_default	=	des blf md5</programlisting>

      <para>Выполнив вышеперечисленные шаги на каждом из серверов и клиентов
        NIS, работающих на FreeBSD, вы можете обеспечить их согласованность
        относительно используемого в вашей сети формата паролей.  Если у вас
        возникли проблемы с аутентификацией клиента NIS, начать
        её решать определённо стоит отсюда.  Запомните: если вы хотите
	использовать сервер NIS в гетерогенной сети, вам, наверное, нужно
	будет использовать DES на всех системах в силу того, что это
	минимальный общий стандарт.</para>
    </sect2>
  </sect1>

  <sect1 id="network-dhcp">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Greg</firstname>
          <surname>Sutter</surname>
          <contrib>Текст написал</contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>DHCP</title>

  <sect2>
    <title>Что такое DHCP?</title>
    <indexterm>
      <primary>Dynamic Host Configuration Protocol</primary>
      <see>DHCP</see>
    </indexterm>
    <indexterm>
      <primary>Internet Software Consortium (ISC)</primary>
    </indexterm>

    <para>DHCP, или Dynamic Host Configuration Protocol (Протокол
      Динамической Конфигурации Хостов), описывает порядок, по которому
      система может подключиться к сети и получить необходимую информацию
      для работы в ней.  Во FreeBSD используется реализация DHCP от ISC
      (Internet Software Consortium), так что вся информация, описывающая
      особенности, зависящие от реализации, относится к дистрибутиву
      ISC.</para>
  </sect2>

  <sect2>
    <title>Что описывается в этом разделе</title>

    <para>В этом разделе описываются компоненты системы ISC DHCP как со стороны
      клиента, так и со стороны сервера.  Программа, работающая на клиентской
      стороне, <command>dhclient</command>, интегрирована в поставку FreeBSD,
      а серверная часть доступна в виде порта <filename
      role="package">net/isc-dhcp3-server</filename>.  Кроме ссылок ниже,
      много полезной информации находится на страницах справочной системы,
      описывающих &man.dhclient.8;, &man.dhcp-options.5; и
      &man.dhclient.conf.5;.</para>
  </sect2>

  <sect2>
    <title>Как это работает</title>

    <indexterm><primary>UDP</primary></indexterm>
    <para>Когда на клиентской машине выполняется программа
      <command>dhclient</command>, являющаяся клиентом DHCP, она начинает
      широковещательную рассылку запросов на получение настроечной информации.
      По умолчанию эти запросы делаются на 68 порт UDP.	Сервер отвечает на UDP
      67, выдавая клиенту адрес IP и другую необходимую информацию, такую, как
      сетевую маску, маршрутизатор и серверы DNS.  Вся эта информация даётся в
      форме <quote>аренды</quote> DHCP и верна только определенное время (что
      настраивается администратором сервера DHCP).  При таком подходе
      устаревшие адреса IP тех клиентов, которые больше не подключены к сети,
      могут автоматически использоваться повторно.</para>

    <para>Клиенты DHCP могут получить от сервера очень много информации.
      Подробный список находится в странице Справочника
      &man.dhcp-options.5;.</para>
  </sect2>

  <sect2>
    <title>Интеграция с FreeBSD</title>

    <para>Клиент DHCP от ISC, <command>dhclient</command>, полностью
      интегрирован во FreeBSD.	Поддержка клиента DHCP есть как в программе
      установки, так и в самой системе, что исключает необходимость в
      знании подробностей конфигурации сети в любой сети, имеющей сервер
      DHCP.  Утилита <command>dhclient</command> включена во все версии
      FreeBSD, начиная с 3.2.</para>

    <indexterm>
      <primary><application>sysinstall</application></primary>
    </indexterm>
    <para>DHCP поддерживается утилитой <application>sysinstall</application>.
      При настройке сетевого интерфейса из программы sysinstall первый
      вопрос, который вам задается, это <quote>Do you want to try DHCP 
      configuration of this interface?</quote> (<quote>Хотите ли вы попробовать
      настроить этот интерфейс через DHCP?</quote>).  Утвердительный ответ
      приведёт к запуску программы <command>dhclient</command>, и при удачном
      его выполнении к автоматическому заданию информации для настройки
      интерфейса.</para>

    <para>Есть две вещи, которые вы должны сделать для того, чтобы ваша
      система использовала DHCP при загрузке:</para>

    <indexterm>
      <primary>DHCP</primary>
      <secondary>требования</secondary>
    </indexterm>
    <itemizedlist>
      <listitem>
        <para>Убедитесь, что устройство <devicename>bpf</devicename>
          включено в компиляцию вашего ядра.  Чтобы это сделать, добавьте
          строчку <literal>pseudo-device bpf</literal> в конфигурационный
          файл ядра и перестройте ядро.  Более подробная информация о
          построении ядер имеется в разделе <xref
          linkend="kernelconfig">.</para>

        <para>Устройство <devicename>bpf</devicename> уже является частью
          ядра <filename>GENERIC</filename>, которое поставляется вместе с
          FreeBSD, так что, если вы не используете другое ядро, то вам и
          не нужно его делать для того, чтобы работал DHCP.</para>

        <note>
          <para>Те, кто беспокоится о безопасности, должны иметь в виду, что
            устройство <devicename>bpf</devicename> является также тем самым
            устройством, которое позволяет работать программам-снифферам
            пакетов (хотя для этого они должны быть запущены пользователем
            <username>root</username>).  Наличие устройства
            <devicename>bpf</devicename> <emphasis>необходимо</emphasis> для
            использования DHCP, но если вы чересчур беспокоитесь о
            безопасности, то вам нельзя добавлять устройство
            <devicename>bpf</devicename> в ядро только для того, чтобы
            в неопределённом будущем использовать DHCP.</para>
        </note>
      </listitem>

      <listitem>
        <para>Отредактируйте ваш файл <filename>/etc/rc.conf</filename>,
          включив в него следующее:</para>

        <programlisting>ifconfig_fxp0="DHCP"</programlisting>
      </listitem>
    </itemizedlist>

    <note>
      <para>Обязательно замените <literal>fxp0</literal> на имя интерфейса,
        который вы хотите настраивать динамически, как это описано в <xref
        linkend="config-network-setup">.</para>
    </note>

    <para>Если <command>dhclient</command> в вашей системе находится в другом
      месте или если вы хотите задать дополнительные параметры для
      <command>dhclient</command>, то также укажите следующее (изменив так,
      как вам нужно):</para>

    <programlisting>dhcp_program="/sbin/dhclient"
dhcp_flags=""</programlisting>

    <indexterm>
      <primary>DHCP</primary>

      <secondary>сервер</secondary>
    </indexterm>

    <para>Сервер DHCP, <command>dhcpd</command>, включён как часть порта
      <filename role="package">net/isc-dhcp3-server</filename> в коллекцию
      портов.  Этот порт содержит DHCP-сервер от ISC и документацию.</para>
  </sect2>

  <sect2>
    <title>Файлы</title>

    <indexterm>
      <primary>DHCP</primary>
      <secondary>конфигурационные файлы</secondary>
    </indexterm>
    <itemizedlist>
      <listitem>
	<para><filename>/etc/dhclient.conf</filename></para>

	<para><command>dhclient</command> требует наличия конфигурационного
	  файла, <filename>/etc/dhclient.conf</filename>.  Как правило, файл
	  содержит только комментарии, а настройки по умолчанию достаточно
	  хороши.  Этот настроечный файл описан на страницах справочной
          системы по &man.dhclient.conf.5;.</para>
      </listitem>

      <listitem>
	<para><filename>/sbin/dhclient</filename></para>

	<para><command>dhclient</command> скомпонован статически и находится
	  в каталоге <filename>/sbin</filename>.  На страница Справочника
	  &man.dhclient.8; дается более подробная информация о
	  <command>dhclient</command>.</para>
      </listitem>

      <listitem>
	<para><filename>/sbin/dhclient-script</filename></para>

	<para><command>dhclient-script</command> является специфичным для
	  FreeBSD скриптом настройки клиента DHCP.  Он описан в
	  &man.dhclient-script.8;, но для нормального функционирования
	  никаких модификаций со стороны пользователя не требуется.</para>
      </listitem>

      <listitem>
	<para><filename>/var/db/dhclient.leases</filename></para>

	<para>В этом файле клиент DHCP хранит базу данных выданных к
	  использованию адресов в виде журнала.  На странице
	  &man.dhclient.leases.5; дается гораздо более подробное
	  описание.</para>
      </listitem>
    </itemizedlist>
  </sect2>

    <sect2>
      <title>Дополнительная литература</title>

      <para>Полное описание протокола DHCP дается в <ulink
        url="http://www.freesoft.org/CIE/RFC/2131/">RFC 2131</ulink>.  Кроме
        того, дополнительная информация есть на сервере <ulink
        url="http://www.dhcp.org/">dhcp.org</ulink>.</para>
    </sect2>

    <sect2 id="network-dhcp-server">
      <title>Установка и настройка сервера DHCP</title>

      <sect3>
        <title>Чему посвящён этот раздел</title>

        <para>Этот раздел даёт информацию о том, как настроить систему
          FreeBSD для работы в качестве сервера DHCP на основе реализации
          пакета DHCP от ISC (Internet Software Consortium).</para>

	<para>Серверная часть пакета не поставляется как часть FreeBSD, так
          что вам потребуется установить порт <filename
          role="package">net/isc-dhcp3-server</filename> для получения
          этого сервиса.  Обратитесь к <xref linkend="ports"> для получения
          более полной информации об использовании коллекции портов.</para>
      </sect3>
 
      <sect3>
        <title>Установка сервера DHCP</title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>установка</secondary>
	</indexterm>

	<para>Для того, чтобы настроить систему FreeBSD на работу в качестве
          сервера DHCP, вам необходимо обеспечить присутствие устройства
          &man.bpf.4;, вкомпилированного в ядро.  Для этого
          добавьте строку <literal>pseudo-device bpf</literal> в файл
          конфигурации вашего ядра.  Для получения более полной информации о
          построении ядер, обратитесь к <xref linkend="kernelconfig">.</para>

	<para>Устройство <devicename>bpf</devicename> уже входит в состав
          ядра <filename>GENERIC</filename>, поставляемого с FreeBSD, так что
          вам не нужно создавать собственное ядро для обеспечения работы
          DHCP.</para>

        <note>
          <para>Те, кто обращает особое внимание на вопросы безопасности,
            должны заметить, что <devicename>bpf</devicename> является тем
            устройством, что позволяет нормально работать снифферам пакетов
            (хотя таким программам требуются привилегированный доступ).
            Наличие устройства <devicename>bpf</devicename>
            <emphasis>обязательно</emphasis> для использования DHCP, но если
            вы очень обеспокоены безопасностью, наверное, вам не нужно
            включать <devicename>bpf</devicename> в ваше ядро только потому,
            что в отдалённом будущем вы собираетесь использовать DHCP.</para>
        </note>

	<para>Следующим действием, которое вам нужно выполнить, является
          редактирование примерного <filename>dhcpd.conf</filename>, который
          устанавливается в составе порта <filename
          role="package">net/isc-dhcp3-server</filename>.  По умолчанию это
          файл <filename>/usr/local/etc/dhcpd.conf.sample</filename>, и вы
          должны скопировать его в файл
          <filename>/usr/local/etc/dhcpd.conf</filename> перед тем, как его
          редактировать.</para>
      </sect3>

      <sect3>
	<title>Настройка сервера DHCP</title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>dhcpd.conf</secondary>
	</indexterm>

	<para><filename>dhcpd.conf</filename> состоит из деклараций
          относительно подсетей и хостов, и проще всего описывается на
          примере:</para>

	<programlisting>option domain-name "example.com";<co id="domain-name">
option domain-name-servers 192.168.4.100;<co id="domain-name-servers">
option subnet-mask 255.255.255.0;<co id="subnet-mask">

default-lease-time 3600;<co id="default-lease-time">
max-lease-time 86400;<co id="max-lease-time">
ddns-update-style none;<co id="ddns-update-style">

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<co id="range">
  option routers 192.168.4.1;<co id="routers">
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<co id="hardware">
  fixed-address mailhost.example.com;<co id="fixed-address">
}</programlisting>
 
	<calloutlist>
	  <callout arearefs="domain-name">
	    <para>Этот параметр задаёт домен, который будет выдаваться
              клиентам в качестве домена, используемого по умолчанию при
              поиске.  Обратитесь к страницам справочной системы по
	      &man.resolv.conf.5; для получения дополнительной информации о
              том, что это значит.</para>
          </callout>
 
          <callout arearefs="domain-name-servers">
	    <para>Этот параметр задаёт список разделённых запятыми серверов
              DNS, которые должен использовать клиент.</para>
	  </callout>

	  <callout arearefs="subnet-mask">
	    <para>Маска сети, которая будет выдаваться клиентам.</para>
	  </callout>
 
	  <callout arearefs="default-lease-time">
	    <para>Клиент может запросить определённое время, которое будет
              действовать выданная информация.  В противном случае сервер
              выдаст настройки с этим сроком (в секундах).</para>
	  </callout>
 
	  <callout arearefs="max-lease-time">
	    <para>Это максимальное время, на которое сервер будет выдавать
              конфигурацию.  Если клиент запросит больший срок, он будет
              подтверждён, но будет действовать только
	      <literal>max-lease-time</literal> секунд.</para>
	  </callout>
 
	  <callout arearefs="ddns-update-style">
	    <para>Этот параметр задаёт, будет ли сервер DHCP пытаться
              обновить DNS при выдаче или освобождении конфигурационной
              информации.  В реализации ISC этот параметр является
	      <emphasis>обязательным</emphasis>.</para>
	  </callout>
 
	  <callout arearefs="range">
	    <para>Это определение того, какие IP-адреса должны использоваться
              в качестве резерва для выдачи клиентам.  IP-адреса между и
              включая границы, будут выдаваться клиентам.</para>
	  </callout>
 
	  <callout arearefs="routers">
	    <para>Объявление маршрутизатора, используемого по умолчанию,
              который будет выдаваться клиентам.</para>
	  </callout>
 
	  <callout arearefs="hardware">
	    <para>Аппаратный MAC-адрес хоста (чтобы сервер DHCP мог
              распознать хост, когда тот делает запрос).</para>
	  </callout>
 
	  <callout arearefs="fixed-address">
	    <para>Определение того, что хосту всегда будет выдаваться один и
              тот же IP-адрес.  Заметьте, что указание здесь имени хоста
              корректно, так как сервер DHCP будет разрешать имя хоста
              самостоятельно до того, как выдать конфигурационную
              информацию.</para>
	  </callout>
	</calloutlist>
 
	<para>Как только вы закончите составлять свой
	  <filename>dhcpd.conf</filename>, вы можете продолжить работу
          запуском сервера при помощи следующей команды:</para>
        
        <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/isc-dhcpd.sh start</userinput></screen>

	<para>Если в будущем вам понадобится сделать изменения в настройке
          вашего сервера, то важно заметить, что посылка сигнала
	  <literal>SIGHUP</literal> приложению
          <application>dhcpd</application> <emphasis>не приведёт</emphasis> к
          перезагрузке настроек, как это бывает для большинства даемонов.
          Вам нужно послать сигнал <literal>SIGTERM</literal> для остановки
          процесса, а затем перезапустить его при помощи вышеприведённой
          команды.</para>
      </sect3>
 
      <sect3>
	<title>Файлы</title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>конфигурационный файлы</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
            <para><filename>/usr/local/sbin/dhcpd</filename></para>

	    <para><application>dhcpd</application> скомпонован статически и
              расположен в каталоге <filename>/usr/local/sbin</filename>.
              Страницы справочной системы &man.dhcpd.8;,
              устанавливаемые портом, содержат более полную информацию о
	      <application>dhcpd</application>.</para>
          </listitem>
 
	  <listitem>
            <para><filename>/usr/local/etc/dhcpd.conf</filename></para>

	    <para><application>dhcpd</application> требует наличия
              конфигурационного файла,
              <filename>/usr/local/etc/dhcpd.conf</filename>, до того, как
              он будет запущен и начнёт предоставлять сервис клиентам.
              Необходимо, чтобы этот файл содержал все данные, которая
              будет выдаваться обслуживаемым клиентам, а также информацию о
              работе сервера.  Этот конфигурационный файл описывается на
              страницах справочной системы &man.dhcpd.conf.5;, которые
              устанавливаются портом.</para>
	  </listitem>
 
	  <listitem>
            <para><filename>/var/db/dhcpd.leases</filename></para>

	    <para>Сервер DHCP ведёт базу данных выданной информации в этом
              файле, который записывается в виде протокола.  Страницы
              справочной системы &man.dhcpd.leases.5;, устанавливаемые портом,
              дают гораздо более подробное описание.</para>
	  </listitem>
 
	  <listitem>
            <para><filename>/usr/local/sbin/dhcrelay</filename></para>

	    <para><application>dhcrelay</application> используется в сложных
              ситуациях, когда сервер DHCP пересылает запросы от клиента
              другому серверу DHCP в отдельной сети.  Если вам нужна такая
              функциональность, то установите порт <filename
              role="package">net/isc-dhcp3-server</filename>.  На страницах
              справочной системы &man.dhcrelay.8;, которые устанавливаются
              портом, даётся более полное описание.</para>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-dns">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Текст предоставил</contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>DNS</title>

    <sect2>
      <title>Обзор</title>

      <indexterm><primary>BIND</primary></indexterm>
      <para>По умолчанию во FreeBSD используется одна из версий программы BIND
        (Berkeley Internet Name Domain), являющейся самой распространенной
        реализацией протокола DNS.  DNS - это протокол, при помощи которого
        имена преобразуются в IP-адреса и наоборот.  Например, в ответ на
        запрос о <hostid>www.FreeBSD.org</hostid> будет получен IP-адрес
        веб-сервера Проекта FreeBSD, а запрос о
        <hostid>ftp.FreeBSD.org</hostid> возвратит IP-адрес соответствующей
        машины с FTP-сервером.  Точно также происходит и обратный процесс.
        Запрос, содержащий IP-адрес машины, возвратит имя хоста.  Для
        выполнения запросов к DNS вовсе не обязательно иметь в системе
        работающий сервер имён.</para>

      <indexterm><primary>DNS</primary></indexterm>
      <para>В сети Интернет DNS управляется через достаточно сложную систему
        авторизированных корневых серверов имён, и других менее крупных
        серверов имён, которые содержат и кэшируют информацию о конкретных
        доменах.</para>

      <para>В этом документа рассматривается BIND 8.x, так как это стабильная
        версия, используемая во FreeBSD.  BIND 9.x может быть установлен как
        порт <filename role="package">net/bind9</filename>.</para>

      <para>Протокол DNS стандартизован в RFC1034 и RFC1035.</para>

      <para>На данный момент пакет BIND поддерживается <ulink
        url="http://www.isc.org/">Internet Software Consortium
        (www.isc.org)</ulink>.</para>
    </sect2>

    <sect2>
      <title>Используемая терминология</title>

      <para>Для понимания этого документа нужно понимать значения некоторых
        терминов, связанных с работой DNS.</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Термин</entry>
              <entry>Определение</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Прямой запрос к DNS (forward DNS)</entry>

              <entry>Преобразование имён хостов в адреса IP</entry>
            </row>

            <row>
              <entry>Ориджин (origin)</entry>

              <entry>Обозначает домен, покрываемый конкретным файлом
                зоны</entry>
            </row>

            <row>
              <entry><application>named</application>, bind, сервер
                имён</entry>

              <entry>Общеупотребительные названия для обозначения пакета BIND,
                обеспечивающего работу сервера имён во FreeBSD.</entry>
            </row>

            <indexterm><primary>ресолвер</primary></indexterm>

            <row>
              <entry>Ресолвер</entry>

              <entry>Системный процесс, посредством которого машина обращается
                к серверу имён для получения информации о зоне</entry>
            </row>

            <indexterm><primary>обратный DNS</primary></indexterm>

            <row>
              <entry>Обратный DNS (reverse DNS)</entry>

              <entry>Операция, обратная прямому запросу к DNS; преобразование
                адресов IP в имена хостов</entry>
            </row>

            <indexterm><primary>корневая зона</primary></indexterm>

            <row>
              <entry>Корневая зона</entry>

              <entry>Начало иерархии зон Интернет.  Все зоны находятся под
                корневой зоной, подобно тому, как все файлы располагаются ниже
                корневого каталога.</entry>
            </row>

            <row>
              <entry>Зона</entry>

              <entry>Отдельный домен, поддомен или часть DNS, управляемая
                одним сервером.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <indexterm>
        <primary>зоны</primary>
        <secondary>примеры</secondary>
      </indexterm>

      <para>Примеры зон:</para>

      <itemizedlist>
        <listitem>
          <para><hostid>.</hostid> является корневой зоной</para>
        </listitem>

        <listitem>
          <para><hostid>org.</hostid> является зоной ниже корневой зоны</para>
        </listitem>

        <listitem>
          <para><hostid>example.org</hostid> является зоной под зоной
            <hostid>org.</hostid></para>
        </listitem>

        <listitem>
          <para><hostid>foo.example.org.</hostid> является поддоменом,
            зоной под зоной <hostid>example.org.</hostid></para>
        </listitem>
  
        <listitem>
          <para><hostid>1.2.3.in-addr.arpa</hostid> является зоной, в которую
            включены все IP-адреса, формирующие пространство адресов
            3.2.1.*.</para>
        </listitem>
      </itemizedlist>

      <para>Как можно видеть, уточняющая часть имени хоста появляется слева.
        Например, <hostid>example.org.</hostid> более точен, чем
        <hostid>org.</hostid>, также, как <hostid>org.</hostid> более
        точен, чем корневая зона.  Расположение каждой части имени хоста сильно
        похоже на файловую систему: каталог <filename>/dev</filename>
        расположен в корневой файловой системе, и так далее.</para>
    </sect2>

    <sect2>
      <title>Причины, по которым вам может понадобиться сервер имён</title>

      <para>Сервера имён обычно используются в двух видах: авторитетный сервер
        имён и кэширующий сервер имён.</para>

      <para>Авторитетный сервер имён нужен, когда:</para>

      <itemizedlist>
        <listitem>
          <para>нужно предоставлять информацию о DNS остальному миру, отвечая
            на запросы авторизированно.</para>
        </listitem>

        <listitem>
          <para>зарегистрирован домен, такой, как
            <hostid>example.org</hostid> и в этом домене требуется
            поставить имена машин в соответствие с их адресами IP.</para>
        </listitem>

        <listitem>
          <para>блоку адресов IP требуется обратные записи DNS (IP в имена
            хостов).</para>
        </listitem>

        <listitem>
          <para>резервный (slave) сервер имён должен отвечать на запросы о
            домене, когда основной не работает или не доступен.</para>
        </listitem>
      </itemizedlist>

      <para>Кэширующий сервер имён нужен, когда:</para>

      <itemizedlist>
        <listitem>
          <para>локальный сервер DNS может кэшировать информацию и отвечать на
            запросы быстрее, чем это происходит при прямом опросе внешнего
            сервера имён.</para>
        </listitem>

        <listitem>
          <para>требуется уменьшение общего сетевого трафика (DNS
            составляет около 5% всего трафика Интернет, или чуть
            больше).</para>
        </listitem>
      </itemizedlist>

      <para>Например, когда кто-нибудь запрашивает информацию о
        <hostid>www.FreeBSD.org</hostid>, то обычно ресолвер обращается к
        серверу имён вашего провайдера, посылает запрос и ожидает ответа.  С
        локальным кэширующим сервером DNS запрос во внешний мир будет делаться
        всего один раз.  Каждый дополнительный запрос не будет посылаться за
        пределы локальной сети, потому что информация уже имеется в
        кэше.</para>
    </sect2>

    <sect2>
      <title>Как это работает</title>

      <para>Во FreeBSD даемон BIND, по очевидным причинам, называется
        <application>named</application>.</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Файл</entry>
              <entry>Описание</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><application>named</application></entry>
              <entry>даемон BIND</entry>
            </row>

            <row>
              <entry><command>ndc</command></entry>
              <entry>программа управления даемоном сервера имён</entry>
            </row>

            <row>
              <entry><filename>/etc/namedb</filename></entry>
              <entry>каталог, в котором располагается вся информация о зонах
                BIND</entry>
            </row>

            <row>
              <entry><filename>/etc/namedb/named.conf</filename></entry>
              <entry>конфигурационный файл для даемона</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Файлы зон обычно располагаются в каталоге
        <filename>/etc/namedb</filename> и содержат информацию о зоне DNS,
        за которую отвечает сервер имён.</para>
    </sect2>

    <sect2>
      <title>Запуск BIND</title>

      <indexterm>
        <primary>BIND</primary>
        <secondary>запуск</secondary>
      </indexterm>
      <para>Так как сервер имён BIND устанавливается по умолчанию, его
        настройка сравнительно проста.</para>

      <para>Чтобы даемон named запускался во время загрузки, сделайте следующие
        изменения в файле <filename>/etc/rc.conf</filename></para>

      <programlisting>named_enable="YES"</programlisting>

      <para>Для запуска даемона вручную (после его настройки)</para>

      <screen>&prompt.root; <userinput>ndc start</userinput></screen>
    </sect2>

    <sect2>
      <title>Конфигурационные файлы</title>

      <indexterm>
        <primary>BIND</primary>
        <secondary>конфигурационные файлы</secondary>
      </indexterm>

      <sect3>
        <title>Использование <command>make-localhost</command></title>

        <para>Обязательно выполните следующие команды:</para>

        <screen>&prompt.root; <userinput>cd /etc/namedb
&prompt.root; sh make-localhost</userinput></screen> 

        <para>для того, чтобы правильно создать файл
          <filename>/etc/namedb/localhost.rev</filename> локальной обратной
          зоны для loopback-интерфейса.</para>
      </sect3>

      <sect3>
        <title><filename>/etc/namedb/named.conf</filename></title>

        <programlisting>// &dollar;FreeBSD$
//
// Refer to the named(8) manual page for details.  If you are ever going
// to setup a primary server, make sure you've understood the hairy
// details of how DNS is working.  Even with simple mistakes, you can
// break connectivity for affected parties, or cause huge amount of
// useless Internet traffic.

options {
        directory "/etc/namedb";

// In addition to the "forwarders" clause, you can force your name
// server to never initiate queries of its own, but always ask its
// forwarders only, by enabling the following line:
//
//      forward only;

// If you've got a DNS server around at your upstream provider, enter
// its IP address here, and enable the line below.  This will make you
// benefit from its cache, thus reduce overall DNS traffic in the
Internet.
/*
        forwarders {
                127.0.0.1;
        };
*/</programlisting>

      <para>Как и говорится в комментариях, если вы хотите получить эффект от
        использования кэша провайдера, то можно включить раздел
        <literal>forwarders</literal>.  В обычном случае сервер имён будет
        рекурсивно опрашивать определённые серверы имён Интернет до тех пор,
        пока не получит ответ на свой запрос.  При включении этого раздела
        он будет автоматически опрашивать сервер имён вашего провайдера (или
        тот, который здесь указан), используя преимущества его кэша.  
        наличия нужной информации.  Если соответствующий сервер имён провайдера
        работает быстро и имеет хороший канал связи, то в результате такой
        настройки вы можете получить хороший результат.

      <warning>
        <para><hostid role="ipaddr">127.0.0.1</hostid> здесь
          работать <emphasis>не будет</emphasis>.  Измените
          его на IP-адрес сервера имён провайдера.</para>
      </warning>

      <programlisting>/*
         * If there is a firewall between you and name servers you want
         * to talk to, you might need to uncomment the query-source
         * directive below.  Previous versions of BIND always asked
         * questions using port 53, but BIND 8.1 uses an unprivileged
         * port by default.
         */
        // query-source address * port 53;

        /*
         * If running in a sandbox, you may have to specify a different
         * location for the dumpfile.
         */
        // dump-file "s/named_dump.db";
};

// Note: the following will be supported in a future release.
/*
host { any; } {
        topology {
                127.0.0.0/8;
        };
};
*/

// Setting up secondaries is way easier and the rough picture for this
// is explained below.
//
// If you enable a local name server, don't forget to enter 127.0.0.1
// into your /etc/resolv.conf so this server will be queried first.
// Also, make sure to enable it in /etc/rc.conf.

zone "." {
        type hint;
        file "named.root";
};

zone "0.0.127.IN-ADDR.ARPA" {
        type master;
        file "localhost.rev";
};

zone
"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.INT" {
        type master;
        file "localhost.rev";
};

// NB: Do not use the IP addresses below, they are faked, and only
// serve demonstration/documentation purposes!
//
// Example secondary config entries.  It can be convenient to become
// a secondary at least for the zone where your own domain is in.  Ask
// your network administrator for the IP address of the responsible
// primary.
//
// Never forget to include the reverse lookup (IN-ADDR.ARPA) zone!
// (This is the first bytes of the respective IP address, in reverse
// order, with ".IN-ADDR.ARPA" appended.)
//
// Before starting to setup a primary zone, better make sure you fully
// understand how DNS and BIND works, however.  There are sometimes
// unobvious pitfalls.  Setting up a secondary is comparably simpler.
//
// NB: Don't blindly enable the examples below. :-)  Use actual names
// and addresses instead.
//
// NOTE!!! FreeBSD runs bind in a sandbox (see named_flags in rc.conf).
// The directory containing the secondary zones must be write accessible
// to bind.  The following sequence is suggested:
//
//      mkdir /etc/namedb/s
//      chown bind:bind /etc/namedb/s
//      chmod 750 /etc/namedb/s</programlisting>

      <para>Дополнительная информация о запуске BIND в ограниченном окружении
        находится в <link linkend="network-named-sandbox">соответствующем
        разделе</link>.</para>

      <programlisting>/*
zone "example.com" {
        type slave;
        file "s/example.com.bak";
        masters {
                192.168.1.1;
        };
};

zone "0.168.192.in-addr.arpa" {
        type slave;
        file "s/0.168.192.in-addr.arpa.bak";
        masters {
                192.168.1.1;
        };
};
*/</programlisting>

      <para>Это примеры описаний прямой и обратной зон из файла
        <filename>named.conf</filename> для вторичных серверов.</para>

      <para>Для каждого новой зоны, которую будет обслуживать сервер имён,
        в файл <filename>named.conf</filename> должна быть добавлена
        запись</para>

      <para>К примеру, самая простая запись для домена <hostid
        role="domainname">example.org</hostid> может выглядеть вот так:</para>

      <programlisting>zone "example.org" {
	type master;
	file "example.org";
};</programlisting>

      <para>Зона является первичной, что отражается в поле
        <option>type</option>, и информация о зоне хранится в файле 
        <filename>/etc/namedb/example.org</filename>, что указывается в
        поле <option>file</option>.</para>

      <programlisting>zone "example.org" {
	type slave;
	file "example.org";
};</programlisting>

      <para>В случае вторичной зоны информация о ней передается с основного
        сервера имён для заданной зоны и сохраняется в указанном файле.  Если
        и когда основной сервер имён выходит и строя или недосягаем, то
        скачанная информация о зоне будет находиться на вторичных серверах и
        они смогут обслуживать эту зону.</para>
    </sect3>

    <sect3>
      <title>Файлы зон</title>  

      <para>Пример файла зоны <hostid>example.org</hostid> для основного
        сервера  (располагающийся в файле
        <filename>/etc/namedb/example.org</filename>) имеет такой
        вид:</para>

      <programlisting>$TTL 3600

example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        86400 )         ; Minimum TTL

; DNS Servers
@       IN NS           ns1.example.org.
@       IN NS           ns2.example.org.

; Machine Names
localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30

; Aliases
www             IN CNAME        @

; MX Record
@               IN MX   10      mail.example.org.</programlisting>

      <para>Заметьте, что все имена хостов, оканчивающиеся на <quote>.</quote>,
        задают полное имя, тогда как все имена без символа <quote>.</quote> на
        конце считаются заданными относительно ориджина.  Например,
        <literal>www</literal> преобразуется в <literal>www + origin</literal>.
        В нашем воображаемом файле ориджином является
        <hostid>example.org.</hostid>, так что
        <literal>www</literal> преобразуется в
        <hostid>www.example.org.</hostid></para>
 
      <para>Файл зоны имеет следующий формат:</para>

      <programlisting>recordname      IN recordtype  value</programlisting>

      <indexterm>
        <primary>DNS</primary>
        <secondary>записи</secondary>
      </indexterm>
      <para>Наиболее часто используемые записи DNS:</para>

      <variablelist>
        <varlistentry>
          <term>SOA</term>

          <listitem>
            <para>начало зоны ответственности</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>NS</term>

          <listitem>
            <para>авторитативный сервер имен</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>A</term>

          <listitem>
            <para>адрес хоста</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>CNAME</term>

          <listitem>
            <para>каноническое имя для алиаса</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>MX</term>

          <listitem>
            <para>обмен почтой</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>PTR</term>

          <listitem>
            <para>указатель на доменное имя (используется в обратных
              зонах DNS)</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <programlisting>example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        86400 )         ; Minimum TTL of 1 day</programlisting>

      <variablelist>
        <varlistentry>
          <term><hostid>example.org.</hostid></term>

          <listitem>
            <para>имя домена, а также ориджин для этого файла зоны.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><hostid>ns1.example.org.</hostid></term>

          <listitem>
            <para>основной/авторитативный сервер имён для этой зоны</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>admin.example.org.</literal></term>

          <listitem>
            <para>человек, отвечающий за эту зону, адрес электронной почты с
              подменённым символом @.  (<email>admin@example.org</email>
              становится <literal>admin.example.org</literal>)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal>5</literal></term>

          <listitem>
            <para>последовательный номер файла.  При каждом изменении файла
              зоны это число должно увеличиваться.  В настоящее время для
              нумерации многие администраторы предпочитают формат
              <literal>ггггммддвв</literal>.  2001041002 будет означать, что
              файл последний раз изменялся 10.04.2001, а последнее число 02
              означает, что это была вторая модификация файла за день.
              Последовательный номер важен, так как он служит для того, чтобы
              вторичные серверы узнавали об обновлении зоны.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <programlisting>@       IN NS           ns1.example.org.</programlisting>

      <para>Это <varname>NS</varname>-запись.   Такие записи должны иметься для
        всех серверов имён, которые будут отвечать за зону.  Символ
        <literal>@</literal>, используемый здесь, преобразуется в
        <hostid role="domainname">example.org.</hostid>  Этот
        символ <literal>@</literal> соответствует ориджину.</para>

      <programlisting>localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30</programlisting>

      <para>Записи типа A служат для обозначения имён машин.  Как это видно
        выше, имя <hostid>ns1.example.org</hostid> будет преобразовано в
        <hostid role="ipaddr">3.2.1.2</hostid>.  И снова здесь используется
        символ ориджина <literal>@</literal>, обозначая, что
        <hostid>example.org</hostid> будет преобразовано в <hostid
        role="ipaddr">3.2.1.30</hostid>.</para>

      <programlisting>www             IN CNAME        @</programlisting>

      <para>Записи с каноническими именами обычно используются для присвоения
        машинам псевдонимов.  В этом примере <hostid>www</hostid> является
        псевдонимом для машины, соответствующей ориджину, то есть
        <hostid>example.org</hostid> (<hostid role="ipaddr">3.2.1.30</hostid>).
        Записи <varname>CNAME</varname> могут использоваться для присвоения
        псевдонимов именам хостов или для использования одного имени
        несколькими машинами по очереди.</para>

      <programlisting>@               IN MX   10      mail.example.org.</programlisting>

      <para><varname>MX</varname>-запись указывает, какие почтовые серверы
        отвечают за обработку входящей электронной почты для зоны.  <hostid
        role="fqdn">mail.example.org</hostid> является именем почтового
        сервера, а 10 обозначает приоритет этого почтового сервера.</para>

      <para>Можно иметь несколько почтовых серверов с приоритетами 3, 2 и 1.
        Почтовый сервер, пытающийся доставить почту для <hostid
        role="domainname">example.org</hostid>,
        сначала попробует связаться с машиной, имеющий MX-запись с самым
        большим приоритетом, затем с приоритетом поменьше и так далее, до тех
        пор, пока почта не будет отправлена.</para>

      <para>Для файлов зон in-addr.arpa (обратные записи DNS) используется тот
        же самый формат, отличающийся только использованием записей
        <varname>PTR</varname> вместо <varname>A</varname> или
        <varname>CNAME</varname>.</para>

      <programlisting>$TTL 3600

1.2.3.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        3600 )          ; Minimum

@       IN NS   ns1.example.org.
@       IN NS   ns2.example.org.

2       IN PTR  ns1.example.org.
3       IN PTR  ns2.example.org.
10      IN PTR  mail.example.org.
30      IN PTR  example.org.</programlisting>

      <para>В этом файле дается полное соответствие имён хостов IP-адресам в
        нашем описанном ранее вымышленном домене.</para>
    </sect3>
  </sect2>

    <sect2>
      <title>Кэширующий сервер имён</title>
      <indexterm>
        <primary>BIND</primary>
        <secondary>кэширующий сервер имён</secondary>
      </indexterm>

      <para>Кэширующий сервер имён - это сервер имён, не отвечающий ни
        за какую зону.  Он просто выполняет запросы от своего имени и сохраняет
        результаты для последующего использования.  Для настройки такого
        сервера достаточно исключить все описания зон из стандартной
        конфигурации сервера имён.</para>
    </sect2>

    <sect2 id="network-named-sandbox">
      <title>Запуск <application>named</application> в песочнице</title>

      <indexterm>
        <primary>BIND</primary>
        <secondary>работа в песочнице</secondary>
      </indexterm>

      <indexterm>
        <primary><command>chroot</command></primary>
      </indexterm>

      <para>Для дополнительной безопасности вам может потребоваться запускать
        &man.named.8; с правами непривилегированного пользователя и настроить
        его на выполнение &man.chroot.8; в каталог-песочницу.  Это позволит
        сделать недоступным для даемона <application>named</application> все,
        что расположено вне песочницы.  Если <application>named</application>
        будет взломан, то это поможет уменьшить возможный ущерб.  По умолчанию
        во FreeBSD имеются пользователь и группа с именами
        <groupname>bind</groupname>, которые предназначены именно для такого
        использования.</para>

      <note>
        <para>Многие рекомендуют вместо настройки
          <application>named</application> на использование
          <command>chroot</command>, запускать <application>named</application>
          внутри &man.jail.8;.  В этом разделе такой подход не
          рассматривается.</para>
      </note>

      <para>Так как <application>named</application> не сможет обратиться ни к
        чему вне песочницы (например, совместно используемым библиотекам,
        сокетам протоколов и так далее), то нужно выполнить несколько шагов,
        чтобы <application>named</application> смог работать нормально.  В
        следующем списке предполагается, что каталогом песочницы является
	<filename>/etc/namedb</filename> и что вы не делали никаких изменений
        в содержимом этого каталога.  Выполните следующие шаги, работая как
        пользователь <username>root</username>.</para>

      <itemizedlist>
        <listitem>
	  <para>Создайте все каталоги, которые ожидает увидеть
            <application>named</application>:</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>mkdir -p bin dev etc var/tmp var/run master slave</userinput>
&prompt.root; <userinput>chown bind:bind slave var/*</userinput><co id="chown-slave"></screen>

	  <calloutlist>
	    <callout arearefs="chown-slave">
	      <para>Программе <application>named</application> нужен доступ с
                правом записи в эти каталоги, так что это все, что мы ей
                предоставим.</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
	  <para>Измените и создайте базовые файлы зоны и настроек:</para>

	  <screen>&prompt.root; <userinput>cp /etc/localtime etc</userinput><co id="localtime">
&prompt.root; <userinput>mv named.conf etc && ln -sf etc/named.conf</userinput>
&prompt.root; <userinput>mv named.root master</userinput>
<!-- Следующее мне не нравится -->
&prompt.root; <userinput>sh make-localhost && mv localhost.rev localhost-v6.rev master</userinput>
&prompt.root; <userinput>cat > master/named.localhost
$ORIGIN localhost.
$TTL 6h
@	IN	SOA	localhost. postmaster.localhost. (
			1	; serial
			3600	; refresh
			1800	; retry
			604800	; expiration
			3600 )	; minimum
	IN	NS	localhost.
	IN	A		127.0.0.1
^D</userinput></screen>

	  <calloutlist>
	    <callout arearefs="localtime">
	      <para>Это позволит программе <application>named</application> 
	        протоколировать правильное время в &man.syslogd.8;</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
	  <para>Если вы используете &os; версии ранее 4.9-RELEASE, то постройте
            статически скомпонованную копию
	    <application>named-xfer</application> и скопируйте её в
            песочницу:</para>

          <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make NOSHARED=yes all</userinput>
&prompt.root; <userinput>cp named-xfer /etc/namedb/bin && chmod 555 /etc/namedb/bin/named-xfer</userinput><co id="clean-cruft"></screen>

          <para>После установки статически скомпонованного
            <command>named-xfer</command>, во избежание появления старых копий
            библиотек и программ в дереве исходного кода, требуется некоторая
            зачистка:</para>

          <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

          <calloutlist>
            <callout arearefs="clean-cruft">
              <para>Иногда при выполнении этого шага возникают ошибки.  Если
                это случилось, выполните такую команду:</para>

              <screen>&prompt.root; <userinput>cd /usr/src && make cleandir && make cleandir</userinput></screen>

              <para>и удалите ваше дерево <filename>/usr/obj</filename>:</para>

              <screen>&prompt.root; <userinput>rm -fr /usr/obj && mkdir /usr/obj</userinput></screen>

              <para>При этом из вашего дерева исходных текстов будет удалён
                весь <quote>мусор</quote>, и повторение вышеописанных шагов
                должно выполниться успешно.</para>
            </callout>
          </calloutlist>

          <para>Если вы используете &os; 4.9-RELEASE или более позднюю версию,
            то копия <command>named-xfer</command> в каталоге
            <filename>/usr/libexec</filename> по умолчанию является статически
            скомпонованной, и вы можете просто скопировать её в песочницу при
            помощи команды &man.cp.1;.</para>
	</listitem>

	<listitem>
	  <para>Создайте файл устройства <devicename>dev/null</devicename>,
	    который <application>named</application> может видеть и писать в
            него:</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb/dev && mknod null c 2 2</userinput>
&prompt.root; <userinput>chmod 666 null</userinput></screen>
	</listitem>

	<listitem>
	  <para>Создайте символическую ссылку
            <filename> /var/run/ndc</filename> на
	    <filename>/etc/namedb/var/run/ndc</filename>:</para>

	  <screen>&prompt.root; <userinput>ln -sf /etc/namedb/var/run/ndc /var/run/ndc</userinput></screen>

	  <note>
	    <para>Это просто для того, чтобы не задавать опцию
              <option>-c</option> при каждом запуске &man.ndc.8;.  Так как
              содержимое каталога /var/run удаляется при загрузке, и если это
              показалось вам полезным, то вы можете добавить эту команду
              в cron-таблицу для root с использованием параметра
	      <option>@reboot</option>.  Обратитесь к справочной странице по
	      &man.crontab.5; для получения более полной информации
              относительно этого.</para>
	  </note>
	</listitem>

	<listitem>
	  <para>Настройте &man.syslogd.8; на создание дополнительного
            протоколирующего сокета <devicename>log</devicename>, в который
            может писать <application>named</application>.  Для этого добавьте
	    <literal>-l /etc/namedb/dev/log</literal> к переменной
	    <varname>syslogd_flags</varname> из файла
	    <filename>/etc/rc.conf</filename>.</para>
	</listitem>

	<listitem>
	  <para>Задайте запуск <application>named</application> и выполнение
	    <command>chroot</command> в песочницу, добавив следующее в
	    <filename>/etc/rc.conf</filename>:</para>

	  <programlisting>named_enable="YES"
named_flags="-u bind -g bind -t /etc/namedb /etc/named.conf"</programlisting>

	  <note>
	    <para>Заметьте, что конфигурационный файл
	      <replaceable>/etc/named.conf</replaceable> именуется по полному
              имени <emphasis>относительно песочницы</emphasis>, то есть в
              вышеприведённой строке указывается файл, который на самом деле
              является файлом
              <filename>/etc/namedb/etc/named.conf</filename>.</para>
	  </note>
	</listitem>
      </itemizedlist>

      <para>Следующим шагом является редактирование файла
	<filename>/etc/namedb/etc/named.conf</filename> так, чтобы
	<application>named</application> знал, какую зону загружать и где найти
        их на диске.  Далее следует прокомментированный пример (все, что
        специально не прокомментировано, ничем не отличается от настройки
        сервера DNS, работающего не в песочнице):</para>

      <programlisting>options {
        directory "/";<co id="directory">
        named-xfer "/bin/named-xfer";<co id="named-xfer">
        version "";		// Не выдавайте версию BIND
        query-source address * port 53;
};
// управляющий сокет ndc
controls {
        unix "/var/run/ndc" perm 0600 owner 0 group 0;
};
// Далее следуют зоны:
zone "localhost" IN {
        type master;
        file "master/named.localhost";<co id="master">
        allow-transfer { localhost; };
        notify no;
};
zone "0.0.127.in-addr.arpa" IN {
        type master;
        file "master/localhost.rev";
        allow-transfer { localhost; };
        notify no;
};
zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.int" {
       type master;
       file "master/localhost-v6.rev";
       allow-transfer { localhost; };
       notify no;
};
zone "." IN {
        type hint;
        file "master/named.root";
};
zone "private.example.net" in {
        type master;
        file "master/private.example.net.db";
	allow-transfer { 192.168.10.0/24; };
};
zone "10.168.192.in-addr.arpa" in {
        type slave;
        masters { 192.168.10.2; };
        file "slave/192.168.10.db";<co id="slave">
};</programlisting>

      <calloutlist>
	<callout arearefs="directory">
	  <para>В директиве <literal>directory</literal> указан каталог
	    <filename>/</filename>, так как все файлы, которые нужны для
	    <application>named</application>, находятся внутри этого каталога
            (вспомните, что это равнозначно <quote>обычному</quote>
            пользовательскому <filename>/etc/namedb</filename>.</para>
	</callout>

	<callout arearefs="named-xfer">
	  <para>Задает полный путь к двоичному выполнимому файлу
	    <command>named-xfer</command> (внутри границ видимости
	    <application>named</application>).  Это необходимо, так как
	    <application>named</application> компилируется с тем, чтобы
            брать <command>named-xfer</command> по умолчанию из
	    <filename>/usr/libexec</filename>.</para>
	</callout>

	<callout arearefs="master">
          <para>Задает имя файла (относительно директивы
	    <literal>directory</literal> выше), в котором
            <application>named</application> может найти файл зоны для этой
            зоны.</para>
	</callout>

	<callout arearefs="slave">
          <para>Задает имя файла (относительно директивы
	    <literal>directory</literal> выше), в котором
            <application>named</application> должен записывать копию файла
            зоны для этой зоны после успешной передачи ее с основного сервера.
            Вот почему нам нужно изменить владельца каталога 
	    <filename>slave</filename> на <groupname>bind</groupname> на этапах
            настроек выше.</para>
	</callout>
      </calloutlist>

      <para>После выполнения шагов выше либо перезагрузите ваш сервер, либо
        перезапустите &man.syslogd.8; и запустите &man.named.8;, не забыв
        использовать новые опции, заданные в <varname>syslogd_flags</varname> и
	<varname>named_flags</varname>.  Теперь
        <application>named</application> должен заработать в песочнице!</para>
    </sect2>

    <sect2>
      <title>Безопасность</title>

      <para>Хотя BIND является самой распространенной реализацией DNS, всегда
        стоит вопрос об обеспечении безопасности.  Время от времени
        обнаруживаются возможные и реальные бреши в безопасности.</para>

      <para>Весьма полезно подписаться на списки рассылки <ulink 
        url="http://www.cert.org/">CERT</ulink> и <ulink
        url="../handbook/eresources.html#ERESOURCES-MAIL">
        freebsd-security-notifications</ulink> для того, чтобы быть в курсе
        текущих проблем с обеспечением безопасности Internet и FreeBSD.</para>

      <tip>
        <para>Если возникают проблемы, то наличие последних исходных текстов и
          свежеоткомпилированного named не помешает.</para>
      </tip>
    </sect2>

    <sect2>
      <title>Дополнительная литература</title>

      <para>Справочная информация по BIND/named: &man.ndc.8; &man.named.8; и
        &man.named.conf.5;</para>

      <itemizedlist>
        <listitem>
          <para><ulink url="http://www.isc.org/products/BIND/">
            Официальная страница ISC BIND</ulink></para>
        </listitem>

        <listitem>
          <para><ulink
            url="http://www.nominum.com/getOpenSourceResource.php?id=6">
            FAQ по BIND</ulink></para>
        </listitem>

        <listitem>
          <para><ulink url="http://www.oreilly.com/catalog/dns4/">
            Книга издательства O'Reilly DNS and BIND 4th
            Edition</ulink></para>
        </listitem>

        <listitem>
          <para><ulink
            url="ftp://ftp.isi.edu/in-notes/rfc1034.txt">RFC1034 - Domain
            Names - Concepts and Facilities</ulink></para>
        </listitem>

        <listitem>
          <para><ulink
            url="ftp://ftp.isi.edu/in-notes/rfc1035.txt">RFC1035 - Domain
            Names - Implementation and Specification</ulink></para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="network-ntp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Hukins</surname>
	  <contrib>Текст предоставил</contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>NTP</title>

    <indexterm><primary>NTP</primary></indexterm>

    <sect2>
      <title>Обзор</title>

      <para>С течением времени часы компьютера имеют тенденцию отставать.  Со
        временем они становятся все более неточными.  NTP (Network Time
        Protocol - Сетевой Протокол Времени) является одним из способов
        вести точное время.</para>

      <para>Многие сервисы Интернет опираются или сильно зависят от точности
        часов компьютеров.  К примеру, веб-сервер может получать запрос на
        посылку файла, который был недавно модифицирован.  Такие службы, как
        &man.cron.8;, запускают команды в определенное время.  Если часы идут
        неточно, то эти команды могут запуститься не тогда, когда это
        ожидается.</para>

      <indexterm>
        <primary>NTP</primary>
        <secondary>ntpd</secondary>
      </indexterm>
      <para>FreeBSD поставляется с сервером NTP &man.ntpd.8;, который можно
        использовать для опроса других серверов NTP для установки часов на
        вашей машине или предоставления услуг точного времени.</para>
    </sect2>

    <sect2>
      <title>Выбор подходящих серверов NTP</title>

      <indexterm>
        <primary>NTP</primary>
        <secondary>выбор серверов</secondary>
      </indexterm>

      <para>Для синхронизации ваших часов вам нужно найти для использования
        один или большее количество серверов NTP.  Ваш сетевой администратор
        или провайдер могут иметь сервер NTP для этой цели&mdash;обратитесь к
        ним, так ли это в вашем случае.  Существует <ulink
	url="http://www.eecis.udel.edu/~mills/ntp/servers.html">список
	общедоступных серверов NTP</ulink>, которым можно воспользоваться для
        поиска ближайшего к вам сервера NTP.  Не забудьте выяснить политику
        выбранного вами сервера и спросить разрешения, если это
        требуется.</para>

      <para>Выбор нескольких несвязанных серверов NTP является хорошей идеей в
        том случае, если один из используемых вами серверов станет недоступным
        или его часы неточны.  &man.ntpd.8; использует ответы, которые он
        получает от других серверов с умом&mdash;он делает предпочтение
        надежным серверам.</para>
    </sect2>

    <sect2>
      <title>Настройка вашей машины</title>

      <indexterm>
        <primary>NTP</primary>
        <secondary>настройка</secondary>
      </indexterm>

      <sect3>
	<title>Базовая конфигурация</title>

	<indexterm><primary>ntpdate</primary></indexterm>

	<para>Если вам нужно только синхронизировать ваши часы при загрузке
          машины, вы можете воспользоваться утилитой &man.ntpdate.8;.  Это
          может подойти для некоторых настольных машин, которые часто
          перезагружаются и только требуют изредка синхронизироваться, но
          на большинстве машин должен работать &man.ntpd.8;.</para>

	<para>Использование &man.ntpdate.8; при загрузке также хорошо для
          машин, на которых запущен даемон &man.ntpd.8;.  Программа
          &man.ntpd.8; изменяет время постепенно, тогда как &man.ntpdate.8;
          устанавливает время вне
          зависимости от того, насколько велика разница между текущим временем
          машины и точным временем.</para>

	<para>Для включения &man.ntpdate.8; во время загрузки, добавьте строчку
	  <literal>ntpdate_enable="YES"</literal> в файл
	  <filename>/etc/rc.conf</filename>.  Вам также потребуется указать
          все серверы, с которыми вы хотите синхронизироваться, и все
          параметры, которые передаются в &man.ntpdate.8;, в
	  <varname>ntpdate_flags</varname>.</para>
      </sect3>

      <sect3>
        <indexterm>
          <primary>NTP</primary>

          <secondary>ntp.conf</secondary>
        </indexterm>

	<title>Общие настройки</title>

	<para>NTP настраивается в файле <filename>/etc/ntp.conf</filename>,
          формат которого описан в &man.ntp.conf.5;.  Вот простой
          пример:</para>

	<programlisting>server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift</programlisting>

	<para>Параметр <literal>server</literal> задает, какие серверы будут
          использоваться, по одному в каждой строке.  Если сервер задан с
          аргументом <literal>prefer</literal>, как <hostid
	  role="fqdn">ntplocal.example.com</hostid>, то этому серверу отдается
          предпочтение перед остальными.  Ответ от предпочтительного сервера
          будет отброшен, если он значительно отличается от ответов других
          серверов, в противном случае он будет использоваться безотносительно
          к другим ответам.  Аргумент <literal>prefer</literal> обычно
          используется для серверов NTP, о которых известно, что они очень
          точны, такими, на которых используется специальное оборудование
          точного времени.</para>

	<para>Параметр <literal>driftfile</literal> задает файл, который
          используется для хранения смещения частоты системных часов.
          Программа &man.ntpd.8; использует его для автоматической компенсации
          естественного смещения часов, позволяя ему поддерживать достаточно
          правильную настройку, даже если он на некоторый период отключается от
          внешнего источника информации о времени.</para>

	<para>Параметр <literal>driftfile</literal> задает, какой файл
          используется для сохранения информации о предыдущих ответах от
          серверов NTP, которые вы используете.  Этот файл содержит внутреннюю
          информацию для NTP.  Он не должен изменяться никакими другими
          процессами.</para>
      </sect3>

      <sect3>
	<title>Управление доступом к вашему серверу</title>

	<para>По умолчанию ваш сервер NTP будет доступен всем хостам в
          Интернет.  Параметр <literal>restrict</literal> в файле
          <filename>/etc/ntp.conf</filename> позволяет вам контролировать,
          какие машины могут обращаться к вашему серверу.</para>

	<para>Если вы хотите запретить всем машинам обращаться к вашему серверу
          NTP, добавьте следующую строку в
          файл <filename>/etc/ntp.conf</filename>:</para>

        <programlisting>restrict default ignore</programlisting>

        <para>Если вы хотите разрешить синхронизировать свои часы с вашим
          сервером только машинам в вашей сети, но запретить им настраивать
          сервер или быть равноправными участниками синхронизации времени, то
          вместо указанной добавьте строчку</para>

        <programlisting>restrict 192.168.1.0 mask 255.255.255.0 notrust nomodify notrap</programlisting>

        <para>где <hostid role="ipaddr">192.168.1.0</hostid> является адресом
          IP вашей сети, а <hostid role="netmask">255.255.255.0</hostid> её
          сетевой маской.</para>

	<para><filename>/etc/ntp.conf</filename> может содержать несколько
          директив <literal>restrict</literal>.  Для получения подробной
          информации обратитесь к подразделу <literal>Access Control
          Support</literal> (Поддержка Управления Доступом) в
          &man.ntp.conf.5;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Запуск сервера NTP</title>

      <para>Для того, чтобы сервер NTP запускался при загрузке, добавьте строку
	<literal>xntpd_enable="YES"</literal> в файл
	<filename>/etc/rc.conf</filename>.  Если вы хотите передать
        дополнительные опции в &man.ntpd.8;, то отредактируйте параметр
	<varname>xntpd_flags</varname> в файле
        <filename>/etc/rc.conf</filename>.</para>

      <para>Для запуска сервера без перезагрузки вашей машины, выполните
        команду <command>ntpd</command>, не забыв задать дополнительные
        параметры из переменной <varname>xntpd_flags</varname> в файле
	<filename>/etc/rc.conf</filename>.  К примеру:</para>

      <screen>&prompt.root; <userinput>ntpd -p /var/run/ntpd.pid</userinput></screen>

      <note>
        <para>Во &os;&nbsp;5.X различные параметры из
          <filename>/etc/rc.conf</filename> были переименованы.  В частности,
          в списке параметров вам необходимо заменить каждую строчку
          <literal>xntpd</literal> на <literal>ntpd</literal>.</para>
      </note>
    </sect2>

    <sect2>
      <title>Использование ntpd с временным подключением к
        Интернет</title>

      <para>Для нормальной работы программе &man.ntpd.8; не требуется
        постоянное подключение к Интернет.  Однако если ваше временное
        подключение к Интернет настроено для дозвонки по требованию, хорошо бы
        запретить трафику NTP вызывать дозвонку или поддерживать соединение
        постоянно.  Если вы используете пользовательский PPP, то можете
        воспользоваться директивами <literal>filter</literal> в файле
	<filename>/etc/ppp/ppp.conf</filename>.  К примеру:</para>

      <programlisting> set filter dial 0 deny udp src eq 123
 # Prevent NTP traffic from initiating dial out
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Prevent incoming NTP traffic from keeping the connection open
 set filter alive 1 deny udp dst eq 123
 # Prevent outgoing NTP traffic from keeping the connection open
 set filter alive 2 permit 0/0 0/0</programlisting>

      <para>Более подробную информацию можно найти в разделе <literal>PACKET
	FILTERING</literal> (ФИЛЬТРАЦИЯ ПАКЕТОВ) в &man.ppp.8;, а примеры в
	<filename>/usr/share/examples/ppp/</filename>.</para>

      <note>
	<para>Некоторые провайдеры Интернет блокируют трафик по портам с
          маленькими номерами, что приводит к неработоспособности NTP, так как
          ответы никогда не достигают вашей машины.</para>
      </note>
    </sect2>

    <sect2>
      <title>Дополнительная литература</title>

      <para>Документация по серверу NTP может быть найдена в каталоге
	<filename>/usr/share/doc/ntp/</filename> в формате HTML.</para>
    </sect2>
  </sect1>

  <sect1 id="network-natd">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>

          <surname>Lee</surname>

          <contrib>Текст предоставил</contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Даемон преобразования сетевых адресов (natd)</title>

    <sect2 id="network-natoverview">
      <title>Обзор</title>
      <indexterm>
        <primary><application>natd</application></primary>
      </indexterm>

      <para>Даемон преобразования сетевых адресов (Network Address
        Translation) во FreeBSD, широко известный как &man.natd.8;, является
        даемоном, который принимает входящие IP-пакеты, изменяет адрес
        отправителя на адрес локальной машины и повторно отправляет эти пакеты
        в потоке исходящих пакетов.  &man.natd.8; делает это, меняя IP-адрес
        отправителя и порт таким образом, что когда данные принимаются
        обратно, он может определить расположение источника начальных данных
        и переслать их машине, которая запрашивала данные изначально.</para>

      <indexterm>
        <primary>совместное использование доступа в Интернет</primary>
      </indexterm>
      <indexterm>
        <primary>сокрытие IP</primary>
      </indexterm>
      <para>Чаще всего NAT используется для организации так называемого
        Совместного Использования Интернет.</para>
    </sect2>

    <sect2 id="network-natsetup">
      <title>Настройка</title>

      <para>Из-за исчерпания пространства адресов в IPv4 и увеличения
        количества пользователей высокоскоростных каналов связи, таких, как
        кабельное подключение или DSL, необходимость в решении по Совместному
        Использованию Интернет растёт.  Возможность подключить несколько
        компьютеров через единственное соединение и IP-адрес делает
        &man.natd.8; подходящим решением.</para>

      <para>Чаще всего у пользователя имеется машина, подключенная к кабельному
        каналу или каналу DSL с одним IP-адресом и есть желание использовать
        этот единственный подключенный компьютер для организации доступа в
        Интернет другим компьютерам в локальной сети.</para>

      <para>Для этого машина FreeBSD, находящаяся в Интернет, должна выступать
        в роли шлюза.  Эта шлюзовая машина должна иметь два сетевых
        адаптера&mdash;один для подключения к маршрутизатору Интернет, а
        другой для подключения к ЛВС.  Все машины в локальной сети
        подключаются через сетевой концентратор или коммутатор.</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="advanced-networking/natd">
        </imageobject>

        <textobject>
          <literallayout class="monospaced">  _______       __________       ________
 |       |     |          |     |        |
 |  Hub  |-----| Client B |-----| Router |----- Internet
 |_______|     |__________|     |________|
     |
 ____|_____
|          |
| Client A |
|__________|</literallayout>
        </textobject>

        <textobject>
          <phrase>Структура сети</phrase>
        </textobject>
      </mediaobject>

      <para>Подобная конфигурация часто используется для совместного
        использования доступа в Интернет.  Одна из подключенных к локальной
        сети машин подключается к Интернет.  Остальные машины работают с
        Интернет посредством этой <quote>шлюзовой</quote> машины.</para>
    </sect2>

    <sect2 id="network-natdkernconfiguration">
      <indexterm>
        <primary>ядро</primary>
        <secondary>настройка</secondary>
      </indexterm>
      <title>Настройка</title>

      <para>В файле конфигурации ядра должны присутствовать следующие
        параметры:</para>

      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>Дополнительно, если это нужно, можно добавить следующее:</para>

      <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>

      <para>В файле <filename>/etc/rc.conf</filename> должны быть такие
        строки:</para>

      <programlisting>gateway_enable="YES"
firewall_enable="YES"
firewall_type="OPEN"
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>"
natd_flags=""</programlisting>

      <informaltable frame="none">
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>gateway_enable="YES"</entry>
              <entry>Указывает машине выступать в качестве шлюза.  Выполнение
                команды <command>sysctl net.inet.ip.forwarding=1</command>
                приведёт к тому же самому результату.</entry>
            </row>

            <row>
              <entry>firewall_enable="YES"</entry>
              <entry>При загрузке включает использование правил межсетевого
                экрана из файла <filename>/etc/rc.firewall</filename>.</entry>
            </row>

            <row>
              <entry>firewall_type="OPEN"</entry>
              <entry>Здесь задается предопределенный набор правил межсетевого
                экрана, который разрешает все.  Посмотрите файл
                <filename>/etc/rc.firewall</filename> для нахождения
                дополнительных типов.</entry>
            </row>

            <row>
              <entry>natd_interface="fxp0"</entry>
              <entry>Указывает, через какой интерфейс передавать пакеты
                (интерфейс, подключенный к Интернет).</entry>
            </row>

            <row>
              <entry>natd_flags=""</entry>
              <entry>Любые дополнительный параметры, передаваемые при запуске
                даемону &man.natd.8;.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>При использовании вышеуказанных параметров в файле
        <filename>/etc/rc.conf</filename> при загрузке будет запущена команда
        <command>natd -interface fxp0</command>.  Эту команду можно запустить и
        вручную.</para>

      <para>Каждой машине и интерфейсу в ЛВС должен быть назначен IP-адрес из
        адресного пространства частных сетей, как это определено в <ulink
        url="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC 1918</ulink>, а в
        качестве маршрутизатора по умолчанию должен быть задан IP-адрес машины
        с <application>natd</application> из внутренней сети.</para>

      <para>Например, клиенты <hostid>A</hostid> и <hostid>B</hostid> в ЛВС
        имеют IP-адреса <hostid role="ipaddr">192.168.0.2</hostid> и <hostid
        role="ipaddr">192.168.0.3</hostid>, а интерфейс машины с natd в
        локальной сети имеет IP-адрес <hostid
        role="ipaddr">192.168.0.1</hostid>.  Маршрутизатором по умолчанию для
        клиентов <hostid>A</hostid> и <hostid>B</hostid> должна быть назначена
        машина с <application>natd</application>, то есть <hostid
        role="ipaddr">192.168.0.1</hostid>.  Внешний, или Интернет-интерфейс
        машины с <application>natd</application> не требует особых
        настроек для работы &man.natd.8;.</para>
    </sect2>

    <sect2 id="network-natdport-redirection">
      <title>Перенаправление портов</title>

      <para>Минусом использования &man.natd.8; является то, что машины в
        локальной сети
        недоступны из Интернет.  Клиенты в ЛВС могут выполнять исходящие
        соединения во внешний мир, но не могут обслуживать входящие.  Это
        является проблемой при запуске служб Интернет на клиентских машинах в
        локальной сети.  Простым решением является перенаправление некоторых
        портов Интернет машины с <application>natd</application> на клиента
        локальной сети.</para>

      <para>Пусть, к примеру, сервер IRC запущен на клиенте <hostid>A</hostid>,
        а веб-сервер работает на клиенте <hostid>B</hostid>.  Чтобы это
        работало, соединения, принимаемые на портах 6667 (IRC) и 80 (веб),
        должны перенаправляться на соответствующие машины.</para>

      <para>Программе &man.natd.8; должна быть передана команда
        <option>-redirect_port</option> с соответствующими параметрами.
        Синтаксис следующий:</para>

      <programlisting>     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

      <para>В примере выше аргументы должен быть такими:</para>

      <programlisting>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>При этом будут перенаправлены соответствующие порты
        <emphasis>tcp</emphasis> на клиентские машины в локальной сети.</para>

      <para>Аргумент <option>-redirect_port</option> может использоваться для
        указания диапазонов портов, а не конкретного порта.  Например,
        <replaceable>tcp 192.168.0.2:2000-3000 2000-3000</replaceable> будет
        перенаправлять все соединения, принимаемые на портах от 2000 до 3000,
        на порты от 2000 до 3000 клиента <hostid>A</hostid>.</para>

      <para>Эти параметры могут использоваться при непосредственном запуске
        &man.natd.8; или их можно поместить в параметр
        <literal>natd_flags=""</literal> из файла
        <filename>/etc/rc.conf</filename>.</para>

      <para>Для получение информации о других параметрах настройки обратитесь
        к справочной странице по &man.natd.8;</para>
    </sect2>

    <sect2 id="network-natdaddress-redirection">
      <title>Перенаправление адреса</title>
      <indexterm><primary>перенаправление адреса</primary></indexterm>

      <para>Перенаправление адреса полезно, если имеется несколько адресов IP,
        и они должны быть на одной машине.  В этой ситуации &man.natd.8; может
        назначить каждому клиенту ЛВС свой собственный внешний IP-адрес.  Затем
        &man.natd.8; преобразует исходящие от клиентов локальной сети пакеты,
        заменяя IP-адреса на соответствующие внешние, и перенаправляет весь
        трафик, входящий на некоторый IP-адрес, обратно конкретному клиенту
        локальной сети.  Это также называют статическим NAT.  К примеру, пусть
        IP-адреса <hostid role="ipaddr">128.1.1.1</hostid>, <hostid
        role="ipaddr">128.1.1.2</hostid> и <hostid
        role="ipaddr">128.1.1.3</hostid> принадлежат шлюзовой машине
        <application>natd</application>.  <hostid
        role="ipaddr">128.1.1.1</hostid> может использоваться в качестве
        внешнего IP-адреса шлюзовой машины <application>natd</application>,
        тогда как <hostid role="ipaddr">128.1.1.2</hostid> и <hostid
        role="ipaddr">128.1.1.3</hostid> будут перенаправляться обратно
        к клиентам ЛВС <hostid>A</hostid> и <hostid>B</hostid>.</para>

      <para>Синтаксис для <option>-redirect_address</option> таков:</para>

      <programlisting>-redirect_address localIP publicIP</programlisting>

      <informaltable frame="none">
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>localIP</entry>
              <entry>Внутренний IP-адрес клиента локальной сети.</entry>
            </row>

            <row>
              <entry>publicIP</entry>
              <entry>Внешний IP, соответствующий клиенту локальной сети.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>В примере этот аргумент будет выглядеть так:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>Как и для <option>-redirect_port</option>, эти аргументы также
        помещаются в строку <literal>natd_flags=""</literal> файла
        <filename>/etc/rc.conf</filename>.  При
        перенаправлении адресов нет нужды в перенаправлении портов, потому что
        перенаправляются все данные, принимаемые для конкретного
        IP-адреса.</para>

      <para>Внешние IP-адреса машины с <application>natd</application> должны
        быть активизированы и являться алиасами для внешнего интерфейса.
        Обратитесь к &man.rc.conf.5;, чтобы это сделать.</para>
    </sect2>
  </sect1>

  <sect1 id="network-inetd">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Текст предоставил</contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title><quote>Супер-сервер</quote> <application>inetd</application></title>

    <sect2 id="network-inetd-overview">
      <title>Обзор</title>

      <para>&man.inetd.8; называют также <quote>супер-сервером
        Интернет</quote>, потому что он управляет соединениями к нескольким
        даемонам.  Программы, которые предоставляют сетевые услуги, называют
        даемонами.  <application>inetd</application> выступает в качестве
        управляющего сервера для других даемонов.  Когда
        <application>inetd</application> принимает соединение, он определяет,
        для какого даемона предназначено соединение, вызывает соответствующий
        даемон и предоставляет ему сокет.  Запуск одного экземпляра
        <application>inetd</application> уменьшает общую нагрузку на систему по
        сравнению с запуском каждого даемона индивидуально в выделенном
        режиме.</para>

      <para>В первую очередь <application>inetd</application> используется для
        вызова других даемонов, но несколько простых протоколов, таких, как
        <application>chargen</application>, <application>auth</application> и
        <application>daytime</application>, обслуживаются
        непосредственно.</para>

      <para>Этот раздел посвящен основам настройки
        <application>inetd</application> посредством его параметров командной
        строки и его конфигурационного файла,
        <filename>/etc/inetd.conf</filename>.</para>
    </sect2>

    <sect2 id="network-inetd-settings">
      <title>Настройки</title>

      <para><application>inetd</application> инициализируется посредством
        системы <filename>/etc/rc.conf</filename>.  Параметр
        <literal>inetd_enable</literal> по умолчанию установлен в
        <quote>NO</quote>, однако часто включается утилитой
	<application>sysinstall</application> при выборе профиля среднего
        уровня безопасности.  Указание
	<programlisting>inetd_enable="YES"</programlisting> или
	<programlisting>inetd_enable="NO"</programlisting> в файле
	<filename>/etc/rc.conf</filename> может задать или запретить запуск
        <application>inetd</application> во время загрузки.</para>

      <para>Кроме того, через <literal>inetd_flags</literal> даемону
        <application>inetd</application> могут быть переданы различные
        параметры командной строки.</para>
    </sect2>

    <sect2 id="network-inetd-cmdline">
      <title>Параметры командной строки</title>

      <para>Формат вызова <application>inetd</application>:</para>

      <para><option>     inetd [-d] [-l] [-w] [-W] [-c maximum] [-C rate] [-a address | hostname]
           [-p filename] [-R rate] [configuration file]</option></para>

      <variablelist>
	<varlistentry>
	  <term>-d</term>

	  <listitem>
	    <para>Включение отладочной информации.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-l</term>

	  <listitem>
	    <para>Включение регистрации успешных соединений.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-w</term>

	  <listitem>
	    <para>Включение механизма TCP Wrapping для внешних служб (по
              умолчанию включено).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-W</term>

	  <listitem>
	    <para>Включение механизма TCP Wrapping для внутренних служб,
              которые встроены в <application>inetd</application> (по
              умолчанию включено).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-c maximum</term>

	  <listitem>
	    <para>Определение максимального числа одновременных запусков каждой
              службы; по умолчание не ограничено.  Может быть переопределено
              индивидуально для каждой службы при помощи параметра
	      <option>max-child</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-C rate</term>

	  <listitem>
	    <para>Определение по умолчанию максимального количества раз,
              которое служба может быть вызвана с одного IP-адреса в минуту; по
              умолчанию не ограничено.  Может быть переопределено для каждой
              службы параметром
              <option>max-connections-per-ip-per-minute</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-R rate</term>
	  
	  <listitem>
	    <para>Определяет максимальное количество раз, которое служба может
              быть вызвана в минуту; по умолчанию 256.  Частота, равная 0,
              не ограничивает число вызовов.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-a</term>

	  <listitem>
	    <para>Задает один IP-адрес, к которому делается привязка.
              Альтернативно может быть указано имя хоста, и в этом случае
              используется соответствующий этому имени хоста адрес IPv4 или
              IPv6.  Обычно имя хоста задается, когда
              <application>inetd</application> запускается в окружении
	      &man.jail.8;, и в этом случае имя хоста соответствует этому
	      &man.jail.8;-окружению.</para>

	    <para>Если используется формат с именем хоста и требуется привязка
              как для IPv4, так и для IPv6, то для каждой привязки требуется
              запись с соответствующим типом протокола для каждой службы в
              файле <filename>/etc/inetd.conf</filename>.  К примеру, службе
              на основе TCP потребуется две записи, в одной для протокола
              используется <quote>tcp4</quote>, а в другой
              используется <quote>tcp6</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-p</term>

	  <listitem>
	    <para>Задает альтернативный файл для хранения ID процесса.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Эти параметры могут быть переданы в
	<application>inetd</application> при помощи
        <literal>inetd_flags</literal> в файле
    	<filename>/etc/rc.conf</filename>.  По умолчанию значение
	<literal>inetd_flags</literal> установлено в <quote>-wW</quote>,
        что включает механизм TCP wrapping для внутренних и внешних служб
	<application>inetd</application>.  Новичкам эти параметры изменять и
        даже задавать их в файле <filename>/etc/rc.conf</filename> не
        нужно.</para>

      <note>
	<para>Внешняя служба является даемоном вне
	  <application>inetd</application>, который запускается при получении
          соединения к нему.  С другой стороны, внутренней службой является
          услуга, которую <application>inetd</application> предоставляет
          сам.</para>
      </note>
    </sect2>

    <sect2 id="network-inetd-conf">
      <title><filename>inetd.conf</filename></title>

      <para>Настройка <application>inetd</application> управляется через файл
        <filename>/etc/inetd.conf</filename>.</para>

      <para>Если в файле <filename>/etc/inetd.conf</filename> делались
        изменения, то <application>inetd</application> можно заставить считать
        его конфигурационный файл повторно, послав сигнал HangUP процессу
	<application>inetd</application>, как показано здесь:</para>

      <example id="network-inetd-hangup">
	<title>Посылка сигнала HangUP процессу
          <application>inetd</application></title>

	<screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
      </example>

      <para>В каждой строке конфигурационного файла описывается отдельный
        даемон.  Комментариям в файле предшествует знак	<quote>#</quote>.  Файл
	<filename>/etc/inetd.conf</filename> имеет такой формат:</para>

      <programlisting>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]
user[:group][/login-class]
server-program
server-program-arguments</programlisting>

      <para>Пример записи для даемона <application>ftpd</application>,
        использующего IPv4:</para>

      <programlisting>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</programlisting>

      <variablelist>
	<varlistentry>
	  <term>service-name</term>

	  <listitem>
	    <para>Это имя сервиса, предоставляемого конкретным даемоном.  Оно
              должно соответствовать сервису, указанному в файле
	      <filename>/etc/services</filename>.  Здесь определяется, какой
              порт должен обслуживать <application>inetd</application>.  При
              создании нового сервиса он должен помещаться сначала в файл
	      <filename>/etc/services</filename>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>socket-type</term>

	  <listitem>
	    <para><literal>stream</literal>, <literal>dgram</literal>,
              <literal>raw</literal> либо <literal>seqpacket</literal>.
              <literal>stream</literal> должен использоваться для
              ориентированных на соединение даемонов TCP, когда как
	      <literal>dgram</literal> используется для даемонов, использующих
              транспортный протокол UDP.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>protocol</term>

	  <listitem>
	    <para>Одно из следующих:</para>

	    <informaltable>
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry>Протокол</entry>
		    <entry>Описание</entry>
		  </row>
		</thead>
		<tbody>
		  <row>
		    <entry>tcp, tcp4</entry>
		    <entry>TCP IPv4</entry>
		  </row>

		  <row>
		    <entry>udp, udp4</entry>
		    <entry>UDP IPv4</entry>
		  </row>

		  <row>
		    <entry>tcp6</entry>
		    <entry>TCP IPv6</entry>
		  </row>

		  <row>
		    <entry>udp6</entry>
		    <entry>UDP IPv6</entry>
		  </row>

		  <row>
		    <entry>tcp46</entry>
		    <entry>TCP как для IPv4, так и для v6</entry>
		  </row>

		  <row>
		    <entry>udp46</entry>
		    <entry>UDP как для IPv4, так и для v6</entry>
		  </row>
	        </tbody>
	      </tgroup>
	    </informaltable>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]</term>

	  <listitem>
	    <para><option>wait|nowait</option> определяет, может ли даемон,
              вызванный из <application>inetd</application>, работать с
              собственным сокетом, или нет.  Сокеты типа <option>dgram</option>
              должны использовать параметр wait, когда как даемоны с потоковыми
              сокетами, которые обычно многопоточны, должны использовать
              <option>nowait</option>.  <option>wait</option> обычно передает
              много сокетов одному даемону, когда как <option>nowait</option>
              порождает даемон для каждого нового сокета.</para>

	    <para>Максимальное число порожденных даемонов, которых может
              создать <application>inetd</application>, может быть задано
              параметром <option>max-child</option>.  Если нужно ограничение в
              десять экземпляров некоторого даемона, то после параметра
              <option>nowait</option> нужно задать
              <literal>/10</literal>.</para>

	    <para>Кроме <option>max-child</option>, может быть задействован
              другой параметр, ограничивающий максимальное число соединений от
              одного источника.
              <option>max-connections-per-ip-per-minute</option> служит именно
              для этого.  Здесь значение, равное десяти, будет ограничивать
              любой заданный IP-адрес на выполнение десяти попыток подключения
              к некоторому сервису в минуту.  Это полезно для предотвращения
              намеренного или ненамеренного расходования ресурсов и атак типа
	      Denial of Service (DoS) на машину.</para>

	    <para>В этом поле <option>wait</option> или <option>nowait</option>
              обязательны.  <option>max-child</option> и
	      <option>max-connections-per-ip-per-minute</option>
              опциональны.</para>

	    <para>Многопоточный даемон типа stream без ограничений
	      <option>max-child</option> или
	      <option>max-connections-per-ip-per-minute</option> будет
              определен просто вот так: <literal>nowait</literal></para>

	    <para>Тот же самый даемон с ограничением в максимум десять даемонов
              будет определен так: <literal>nowait/10</literal></para>

	    <para>Наконец, та же конфигурация с ограничением в двадцать
              соединений на IP-адрес в минуту и общим ограничением в максимум
              десять порожденных даемонов выглядит так:
	      <literal>nowait/10/20</literal></para>

	    <para>Эти параметры, используемые все со значениями по умолчанию
              даемоном <application>fingerd</application>, имеют такой
              вид:</para>

	    <programlisting>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</programlisting>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>user</term>

	  <listitem>
	    <para>Поле user является именем пользователем, под которым должен
              работать соответствующий даемон.  Чаще всего даемоны работают
              как пользователь <username>root</username>.  Для обеспечения
              безопасности некоторые серверы запускаются как пользователь
	      <username>daemon</username> или как пользователь с минимальными
              правами <username>nobody</username>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program</term>

	  <listitem>
	    <para>Полный маршрут к даемону, который будет выполняться при
              установлении соединения.  Если даемон является сервисом,
              предоставляемым самим <application>inetd</application>, то нужно
              задать ключевое слово <option>internal</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program-arguments</term>

	  <listitem>
	    <para>Этот параметр работает вместе с параметром
	      <option>server-program</option>, задавая параметры, начиная с
              argv[0], передаваемые даемону при запуске.  Если в командной
              строке задано <application>mydaemon -d</application>, то
              <literal>mydaemon -d</literal> будет являться значением для
	      <option>server program arguments</option>.  И снова, если даемон
              является внутренней службой, то здесь нужно использовать
	      <option>internal</option>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="network-inetd-security">
      <title>Безопасность</title>

      <para>В зависимости от схемы безопасности, выбранной при установке,
        многие из даемонов <application>inetd</application> могут оказаться по
        умолчанию включенными.  Если нет особой нужды в некотором даемоне, то
        выключите его!  Поместите знак <quote>#</quote> перед ненужным даемоном
        и <link linkend="network-inetd-hangup">пошлите сигнал для inetd</link>.
        Некоторые даемоны, такие, как <application>fingerd</application>,
        вообще нежелательны, потому что они дают атакующему слишком много
        информации.</para>

      <para>Некоторые даемоны не заботятся о безопасности и имеют большие
        таймауты для соединений или вообще их не имеют.  Это позволяет
        атакующему неспешно устанавливать соединения к конкретному даемону,
        истощая имеющиеся ресурсы.  Может оказаться полезным задать для
        некоторых даемонов ограничения <option>ip-per-minute</option> и
        <option>max-child</option>.</para>

      <para>По умолчанию механизм TCP wrapping включен.  Обратитесь к
        справочной странице по &man.hosts.access.5; для получения более
        подробной информации о задании ограничений TCP для различных даемонов,
        запускаемых посредством <application>inetd</application>.</para>
    </sect2>

    <sect2 id="network-inetd-misc">
      <title>Разное</title>

      <para><application>daytime</application>,
	<application>time</application>,
	<application>echo</application>,
	<application>discard</application>,
	<application>chargen</application> и
	<application>auth</application> все являются услугами, предоставляемыми
        самим <application>inetd</application>.</para>

      <para>Сервис <application>auth</application> предоставляет
        идентификационные сетевые услуги (ident, identd) и поддается
        настройке.</para>

      <para>Обратитесь к справочной странице по &man.inetd.8; для получения
        более подробной информации.</para>
    </sect2>
  </sect1>

  <sect1 id="network-plip">
    <title>IP по параллельному порту (PLIP)</title>

    <indexterm><primary>PLIP</primary></indexterm>
    <indexterm><primary>IP по параллельному порту</primary></indexterm>

    <para>PLIP позволяет нам работать с TCP/IP по параллельному порту.  Это
      полезно для машин без сетевых адаптеров или для установки на лаптопы.
      В этом разделе мы обсудим:</para>

    <itemizedlist>
      <listitem>
	<para>создание кабеля для параллельного порта (laplink).</para>
      </listitem>

      <listitem>
	<para>Соединение двух компьютеров посредством PLIP.</para>
      </listitem>
    </itemizedlist>

    <sect2 id="network-create-parallel-cable">
      <title>Создание параллельного кабеля</title>

      <para>Вы можете приобрести кабель для параллельного порта в большинстве
        магазинов, торгующих комплектующими.  Если вы его не найдете, или же
        просто хотите знать, как он делается, то следующая таблица поможет вам
        сделать такой кабель из обычного принтерного кабеля для параллельного
        порта.</para>

      <table>
	<title>Распайка кабеля для параллельного порта для сетевой
          работы</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>A-name</entry>

	      <entry>A-End</entry>

	      <entry>B-End</entry>

	      <entry>Описание</entry>

	      <entry>Post/Bit</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literallayout>DATA0
-ERROR</literallayout></entry>

	      <entry><literallayout>2
15</literallayout></entry>

	      <entry><literallayout>15
2</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA1
+SLCT</literallayout></entry>

	      <entry><literallayout>3
13</literallayout></entry>

	      <entry><literallayout>13
3</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA2
+PE</literallayout></entry>

	      <entry><literallayout>4
12</literallayout></entry>

	      <entry><literallayout>12
4</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA3
-ACK</literallayout></entry>

	      <entry><literallayout>5
10</literallayout></entry>

	      <entry><literallayout>10
5</literallayout></entry>

	      <entry>Strobe</entry>

	      <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA4
BUSY</literallayout></entry>

	      <entry><literallayout>6
11</literallayout></entry>

	      <entry><literallayout>11
6</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
	    </row>

	    <row>
	      <entry>GND</entry>

	      <entry>18-25</entry>

	      <entry>18-25</entry>

	      <entry>GND</entry>

	      <entry>-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2 id="network-plip-setup">
      <title>Настройка PLIP</title>

      <para>Прежде всего вы должны найти laplink-кабель.  Затем
        удостоверьтесь, что на обоих компьютерах в ядро включена поддержка
        драйвера &man.lpt.4;:</para>

      <screen>&prompt.root; <userinput>grep lp /var/run/dmesg.boot</userinput>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</screen>

      <para>Управление параллельным портом должно выполняться по прерываниям.
        Во &os;&nbsp;4.X в файле конфигурации ядра должна присутствовать
        строка, подобная следующей:</para>

      <programlisting>device ppc0 at isa? irq 7</programlisting>

      <para>Во &os;&nbsp;5.X файл <filename>/boot/device.hints</filename>
        должен содержать следующие строки:</para>

      <programlisting>hint.ppc.0.at="isa"
hint.ppc.0.irq="7"</programlisting>

      <para>Затем проверьте, что файл конфигурации ядра имеет строку
        <literal>device plip</literal>, или загружен ли модуль ядра
        <filename>plip.ko</filename>.  В обоих случаях интерфейс работы с
        сетью по параллельному порту должен присутствовать на момент прямого
        использования команды &man.ifconfig.8;.  Во &os;&nbsp;4.X это должно
        быть примерно так:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0</userinput>
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <para>а для &os;&nbsp;5.X:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <note>
        <para>Имя устройства, используемого для параллельного интерфейса,
          во &os;&nbsp;4.X
          (<devicename>lp<replaceable>X</replaceable></devicename>) и
          &os;&nbsp;5.X
          (<devicename>plip<replaceable>X</replaceable></devicename>).</para>
      </note>

      <para>Подключите кабель laplink к параллельным интерфейсам на обоих
        компьютерах.</para>

      <para>Настройте параметры сетевого интерфейса с обеих сторон, работая как
        пользователь <username>root</username>.  К примеру, если вы хотите
        соединить хост <hostid>host1</hostid>, на котором работает
        &os;&nbsp;4.X, с хостом <hostid>host2</hostid> под управлением
        &os;&nbsp;5.X:</para>

      <programlisting>                 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</programlisting>

      <para>Настройте интерфейс на машине <hostid>host1</hostid>,
        выполнив:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.1 10.0.0.2</userinput></screen>

      <para>Настройте интерфейс на машине <hostid>host2</hostid>,
        выполнив:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0 10.0.0.2 10.0.0.1</userinput></screen>

      <para>Теперь вы должны получить работающее соединение.  Пожалуйста,
        прочтите страницы руководства по &man.lp.4; и &man.lpt.4; для выяснения
        деталей.</para>

      <para>Вы должны также добавить оба хоста в
	<filename>/etc/hosts</filename>:</para>

      <programlisting>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain</programlisting>

      <para>Чтобы проверить работу соединения, перейдите к каждому хосту и
        выполните тестирование соединения с другой машиной посредством команды
        ping.  К примеру, на машине <hostid>host1</hostid>:</para>

      <screen>&prompt.root; <userinput>ifconfig lp0</userinput>
lp0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       lp0
&prompt.root; <userinput>ping -c 4 host2</userinput>
PING host2 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- host2 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>

    </sect2>
  </sect1>

  <sect1 id="network-ipv6">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Aaron</firstname>
	  <surname>Kaplan</surname>
	  <contrib>Первоначальный текст написал</contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Реструктуризацию и добавления внёс</contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>IPv6</title>

    <para>IPv6 (также называемый IPng <quote>IP next generation</quote> -
      следующее поколение IP) является новой версией широко известного
      протокола IP (называемого также <acronym>IPv4</acronym>).  Как и другие
      современные системы *BSD, FreeBSD включает эталонную реализацию IPv6 от
      <acronym>KAME</acronym>.  Так что система FreeBSD поставляется со всем,
      что вам нужно для экспериментирования с IPv6.  Этот раздел посвящён
      настройке и запуску в работу IPv6.</para>

    <para>В начале 1990-х люди стали беспокоиться о быстро иссякающем адресном
      пространстве IPv4.  Принимая во внимание темпы роста Интернет, имелись
      основные проблемы:</para>

    <itemizedlist>
      <listitem>
	<para>Нехватка адресов.  Сегодня это не такая большая проблема, так как
          стали применяться адресные пространства для частных сетей
          (<hostid role="ipaddr">10.0.0.0/8</hostid>, <hostid
          role="ipaddr">192.168.0.0/24</hostid> и так далее) и технология
          преобразования сетевых адресов (<acronym>NAT</acronym> - Network
          Address Translation).</para>
      </listitem>

      <listitem>
	<para>Таблицы маршрутов становятся чересчур большими.  Это всё ещё
          является проблемой сегодня.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 решает эти и многие другие вопросы:</para>

    <itemizedlist>
      <listitem>
	<para>128-битное адресное пространство.  Другими словами, теоретически
          доступны 340,282,366,920,938,463,463,374,607,431,768,211,456 адреса.
          Это означает плотность примерно в 6.67 * 10^27 адресов IPv6 на
          квадратный метр нашей планеты.</para>
      </listitem>

      <listitem>
	<para>Маршрутизаторы будут хранить в своих таблицах только
          агрегированные адреса сетей, что уменьшает средний размер таблицы
          маршрутизации до 8192 записей.</para>
      </listitem>
    </itemizedlist>

    <para>Имеется также множество других полезных особенностей IPv6, таких,
      как:</para>

    <itemizedlist>
      <listitem>
	<para>Автоматическая настройка адреса (RFC2462)</para>
      </listitem>

      <listitem>
	<para>Групповые адреса (<quote>один к нескольким из
          многих</quote>)</para>
      </listitem>

      <listitem>
	<para>Обязательные адреса множественной рассылки</para>
      </listitem>

      <listitem>
	<para>IPsec (IP security - безопасный IP)</para>
      </listitem>

      <listitem>
	<para>Упрощённая структура заголовка</para>
      </listitem>

      <listitem>
	<para>Мобильный <acronym>IP</acronym></para>
      </listitem>

      <listitem>
	<para>Механизмы преобразования IPv4-в-IPv6</para>
      </listitem>
    </itemizedlist>

    <para>Для получения дополнительной информации посмотрите:</para>

    <itemizedlist>
      <listitem>
	<para>Обзор IPv6 на сайте <ulink
          url="http://www.sun.com">Sun.com</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.ipv6.org">IPv6.org</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.kame.net">KAME.net</ulink></para>
      </listitem>

      <listitem>
	<para><ulink url="http://www.6bone.net">6bone.net</ulink></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Основы адресации IPv6</title>

      <para>Существуют различные типы адресов IPv6: одноадресные (Unicast),
        групповые (Anycast) и многоадресные (Multicast).</para>

      <para>Адреса типа Unicast хорошо всем известны.  Пакет, посланный на
        такой адрес, достигает в точности интерфейса, который этому адресу
        соответствует.</para>

      <para>Адреса типа Anycast синтаксически неотличимы от адресов Unicast,
        но они адресуют группу интерфейсов.  Пакет, направленный такому адресу,
        попадёт в ближайший (согласно метрике маршрутизатора) интерфейс.
        Адреса Anycast могут использоваться только маршрутизаторами.</para>

      <para>Адреса типа Multicast идентифицируют группу интерфейсов.  Пакет,
        посланный на такой адрес, достигнет всех интерфейсов, привязанных к
        группе многоадресного вещания.</para>

      <note>
        <para>Широковещательные адреса IPv4 (обычно <hostid
          role="ipaddr">xxx.xxx.xxx.255</hostid>) выражаются адресами
          многоадресного вещания IPv6.</para>
      </note>

      <para>Зарезервированные адреса IPv6:</para>

<screen>ipv6-address 	prefixlength(Bits)	description	Notes

	::			128 Bits			unspecified cf. 0.0.0.0 in IPv4 address
	::1			128 Bits			loopback address cf. 127.0.0.1 in IPv4
	::00:xx:xx:xx:xx	96 Bits				embedded IPv4	The lower 32 bits are the
								address	IPv4 address. Also called
								<quote>IPv4 compatible IPv6
								address</quote>
	::ff:xx:xx:xx:xx	96 Bits		IPv4 mapped     The lower 32 bits are the
						IPv6 address	IPv4 address. For hosts
								which do not support IPv6
	fe80:: - feb::		10 Bits		link-local	cf. loopback address in
						IPv4
	fec0:: - fef::		10 Bits		site-local
	ff::			8 Bits		multicast
	001 (base 2)		3 Bits		global unicast	All global unicast
								addresses are assigned from
								this pool. The first 3 Bits
								are <quote>001</quote>.</screen>

    </sect2>

    <sect2>
      <title>Чтение адресов IPv6</title>

      <para>Каноническая форма представляется в виде <hostid
        role="ip6addr">x:x:x:x:x:x:x:x</hostid>, где каждый символ
        <quote>x</quote> является 16-битовым шестнадцатиричным числом.  К
        примеру, <hostid
        role="ip6addr">FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</hostid></para>

      <para>Часто в адресе присутствуют длинные строчки, заполненные нулями,
        поэтому каждая такая последовательность может быть сокращена до
	<quote>::</quote>.  К примеру, <hostid role="ip6addr">fe80::1</hostid>
        соответствует канонической форме <hostid
        role="ip6addr">fe80:0000:0000:0000:0000:0000:0000:0001</hostid></para>

      <para>В третьей форме последние 32 бита записываются в широко известном
        (десятичном) стиле IPv4 с точками <quote>.</quote> в качестве
        разделителей.  Например, <hostid
        role="ip6addr">f2002::10.0.0.1</hostid> соответствует
        (шестнадцатеричному) каноническому представлению <hostid
        role="ip6addr">2002:0000:0000:0000:0000:0000:0a00:0001</hostid>,
        которое, в свою очередь, равнозначно записи <hostid
        role="ip6addr">2002::a00:1</hostid></para>

      <para>Теперь читатель должен понять следующую запись:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput></screen>

      <programlisting>rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</programlisting>

      <para><hostid role="ip6addr">fe80::200:21ff:fe03:8e1%rl0</hostid>
        является автоматически отконфигурированным локальным адресом.  В
        процессе автоматической конфигурации в него включается MAC-адрес
        Ethernet.</para>

      <para>Для получения дополнительной информации о структуре адресов IPv6
        обратитесь к RFC3513.</para>
    </sect2>

    <sect2>
      <title>Настройка подключения</title>

      <para>На данный момент существуют четыре способа подключиться к другим
        хостам и сетям IPv6:</para>

      <itemizedlist>
	<listitem>
	  <para>Подключиться к экспериментальному 6bone</para>
	</listitem>

	<listitem>
	  <para>Получить сеть IPv6 от вышестоящего провайдера.  Для получения
            рекомендаций обратитесь к вашему провайдеру Интернет.</para>
	</listitem>

	<listitem>
	  <para>Туннелировать посредством 6-в-4</para>
	</listitem>

	<listitem>
	  <para>Использовать порт freenet6, если вы используете коммутируемое
            соединение.</para>
	</listitem>
      </itemizedlist>

      <para>Здесь мы будем рассматривать подключение к 6bone, так как на
        данный момент это является самым популярным способом.</para>

      <para>Сначала взгляните на сайт 6bone и найдите ближайшую к вам точку
        подключения к 6bone.  Напишите ответственному и при некоторой удаче вам
        дадут инструкции по настройке соединения.  Обычно это касается
        настройки туннеля GRE (gif).</para>

      <para>Вот типичный пример настройки туннеля &man.gif.4;:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput>
&prompt.root; <userinput>ifconfig gif0</userinput>
gif0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1280
&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>MY_IPv4_ADDR</replaceable>  <replaceable>HIS_IPv4_ADDR</replaceable></userinput>
&prompt.root; <userinput>ifconfig gif0 inet6 alias <replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable></userinput></screen>

      <para>Замените слова, написанные заглавными буквами, информацией, которую
        вам дал вышестоящий узел 6bone.</para>

      <para>При этом установится туннель.  Проверьте работу туннеля утилитой
        &man.ping6.8; с адресом <hostid role="ip6addr">ff02::1%gif0</hostid>.
        Вы должны получить два положительных ответа.</para>

      <note>
        <para>Если вы заинтригованы адресом <hostid
          role="ip6addr">ff02:1%gif0</hostid>, скажем, что это адрес
          многоадресного вещания.  <literal>%gif0</literal> указывает на
          использование такого адреса с сетевым интерфейсом
          <devicename>gif0</devicename>.  Так как мы выполняем
          <command>ping</command> над адресом многоадресного вещания, то другая
          сторона туннеля также должна ответить).</para>
      </note>

      <para>Теперь настройка маршрута к вашей вышестоящей точке подключения
        6bone должна быть весьма проста:</para>

      <screen>&prompt.root; <userinput>route add -inet6 default -interface gif0</userinput>
&prompt.root; <userinput>ping6 -n <replaceable>MY_UPLINK</replaceable></userinput></screen>

      <screen>&prompt.root; <userinput>traceroute6 www.jp.FreeBSD.org</userinput>
(3ffe:505:2008:1:2a0:24ff:fe57:e561) from 3ffe:8060:100::40:2, 30 hops max, 12 byte packets
     1  atnet-meta6  14.147 ms  15.499 ms  24.319 ms
     2  6bone-gw2-ATNET-NT.ipv6.tilab.com  103.408 ms  95.072 ms *
     3  3ffe:1831:0:ffff::4  138.645 ms  134.437 ms  144.257 ms
     4  3ffe:1810:0:6:290:27ff:fe79:7677  282.975 ms  278.666 ms  292.811 ms
     5  3ffe:1800:0:ff00::4  400.131 ms  396.324 ms  394.769 ms
     6  3ffe:1800:0:3:290:27ff:fe14:cdee  394.712 ms  397.19 ms  394.102 ms</screen>

      <para>Эта выдача будет отличаться от машины к машине.  Теперь вы должны
        суметь достигнуть сайта IPv6 <ulink
        url="http://www.kame.net">www.kame.net</ulink> и увидеть танцующую
        черепаху &mdash; в случае, если ваш браузер поддерживает IPv6, как,
        например, <filename role="package">www/mozilla</filename>.</para>
    </sect2>

    <sect2>
      <title>DNS в мире IPv6</title>

      <para>Для IPv6 имеются два новых типа записей DNS:</para>

      <itemizedlist>
	<listitem>
	  <para>Записи AAAA,</para>
	</listitem>

	<listitem>
	  <para>Записи A6</para>
	</listitem>
      </itemizedlist>

      <para>Использование записей AAAA достаточно просто.  Назначение вашему
        имени хоста нового адреса IPv6 достигается просто добавлением:</para>

      <programlisting>MYHOSTNAME           AAAA    MYIPv6ADDR</programlisting>

      <para>к вашему первичному файлу DNS зоны.  В случае, если вы не
        обслуживаете собственные зоны <acronym>DNS</acronym>, обратитесь к
        вашему провайдеру <acronym>DNS</acronym>.  Имеющиеся версии
        <application>bind</application> (версий 8.3 и 9) поддерживают записи
        AAAA.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
<!--  LocalWords:  config mnt www -->
