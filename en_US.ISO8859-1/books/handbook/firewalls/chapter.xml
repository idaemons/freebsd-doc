<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="firewalls">

  <info>
    <title>Firewalls</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Joseph J.</firstname>
	  <surname>Barbish</surname>
	</personname>
	<contrib>Contributed by </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Brad</firstname>
	  <surname>Davis</surname>
	</personname>
	<contrib>Converted to SGML and updated by </contrib>
      </author>
    </authorgroup>
  </info>

  <indexterm><primary>firewall</primary></indexterm>

  <indexterm>
    <primary>security</primary>

    <secondary>firewalls</secondary>
  </indexterm>

  <sect1 xml:id="firewalls-intro">
    <title>Synopsis</title>

    <para>Firewalls make it possible to filter the incoming and
      outgoing traffic that flows through a system.  A firewall can
      use one or more sets of <quote>rules</quote> to inspect network
      packets as they come in or go out of network connections and
      either allows the traffic through or blocks it.  The rules of
      a firewall can inspect one or more characteristics of the
      packets such as the protocol type, source or destination host
      address, and source or destination port.</para>

    <para>Firewalls can enhance the security of a host or a network.
      They can be used to do one or more of the following:</para>

    <itemizedlist>
      <listitem>
	<para>Protect and insulate the applications, services, and
	  machines of an internal network from unwanted traffic from
	  the public Internet.</para>
      </listitem>

      <listitem>
	<para>Limit or disable access from hosts of the internal
	  network to services of the public Internet.</para>
      </listitem>

      <listitem>
	<para>Support network address translation
	  (<acronym>NAT</acronym>), which allows an internal network
	  to use private <acronym>IP</acronym> addresses and share a
	  single connection to the public Internet using either a
	  single <acronym>IP</acronym> address or a shared pool of
	  automatically assigned public addresses.</para>
      </listitem>
    </itemizedlist>

    <para>&os; has three firewalls built into the base system:
      <application>PF</application>,
      <application>IPFILTER</application>, also known as
      <application>IPF</application>, and
      <application>IPFW</application>.
      &os; also provides two traffic shapers for controlling bandwidth
      usage: &man.altq.4; and &man.dummynet.4;.
      <application>ALTQ</application> has
      traditionally been closely tied with
      <application>PF</application> and
      <application>dummynet</application> with
      <application>IPFW</application>.  Each firewall uses rules to
      control the access of packets to and from a &os; system,
      although they go about it in different ways and each has a
      different rule syntax.</para>

    <para>&os; provides multiple firewalls in order to meet the
      different requirements and preferences for a wide variety of
      users.  Each user should evaluate which firewall best meets
      their needs.</para>

    <para>After reading this chapter, you will know:</para>

    <itemizedlist>
      <listitem>
	<para>How to define packet filtering rules.</para>
      </listitem>

      <listitem>
	<para>The differences between the firewalls built into
	  &os;.</para>
      </listitem>

      <listitem>
	<para>How to use and configure the
	  <application>PF</application> firewall.</para>
      </listitem>

      <listitem>
	<para>How to use and configure the
	  <application>IPFILTER</application> firewall.</para>
      </listitem>

      <listitem>
	<para>How to use and configure the
	  <application>IPFW</application> firewall.</para>
      </listitem>
    </itemizedlist>

    <para>Before reading this chapter, you should:</para>

    <itemizedlist>
      <listitem>
	<para>Understand basic &os; and Internet concepts.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Since all firewalls are based on inspecting the values of
	selected packet control fields, the creator of the firewall
	ruleset must have an understanding of how
	<acronym>TCP/IP</acronym> works, what the different values in
	the packet control fields are, and how these values are used
	in a normal session conversation.  For a good introduction,
	refer to <link
	  xlink:href="http://www.ipprimer.com/overview.cfm">Daryl's
	  TCP/IP Primer</link>.</para>
    </note>
  </sect1>

  <sect1 xml:id="firewalls-concepts">
    <title>Firewall Concepts</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>rulesets</secondary>
    </indexterm>

    <para>A firewall ruleset can be either
      <quote>exclusive</quote> or <quote>inclusive</quote>.  An
      exclusive firewall allows all traffic through except for the
      traffic matching the ruleset.  An inclusive firewall does the
      reverse as it only allows traffic matching the rules through and
      blocks everything else.</para>

    <para>An inclusive firewall offers better control of the outgoing
      traffic, making it a better choice for systems that offer
      services to the public Internet.  It also controls the type of
      traffic originating from the public Internet that can gain
      access to a private network.  All traffic that does not match
      the rules is blocked and logged.  Inclusive firewalls are
      generally safer than exclusive firewalls because they
      significantly reduce the risk of allowing unwanted
      traffic.</para>

    <note>
      <para>Unless noted otherwise, all configuration and example
	rulesets in this chapter create inclusive firewall
	rulesets.</para>
    </note>

    <para>Security can be tightened further using a <quote>stateful
	firewall</quote>.  This type of firewall keeps track of open
      connections and only allows traffic which either matches an
      existing connection or opens a new, allowed connection.  The
      disadvantage of a stateful firewall is that it can be vulnerable
      to Denial of Service (<acronym>DoS</acronym>) attacks if a lot
      of new connections are opened very fast.  Most firewalls use a
      combination of stateful and non-stateful behavior.</para>
  </sect1>

  <sect1 xml:id="firewalls-pf">
    <info>
      <title>PF</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>John</firstname>
	    <surname>Ferrell</surname>
	  </personname>
	  <contrib>Revised and updated by </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>firewall</primary>

      <secondary>PF</secondary>
    </indexterm>

    <para>Since &os;&nbsp;5.3, a ported version of OpenBSD's
      <application>PF</application> firewall has been included as an
      integrated part of the base system.
      <application>PF</application> is a complete, full-featured
      firewall that has optional support for
      <application>ALTQ</application> (Alternate Queuing), which
      provides Quality of Service (<acronym>QoS</acronym>).</para>

    <para>The OpenBSD Project maintains the definitive reference for
      <application>PF</application> in the <link
	xlink:href="http://www.openbsd.org/faq/pf/">PF FAQ</link>.
      Peter Hansteen maintains a thorough
      <application>PF</application> tutorial at <link
	xlink:href="http://home.nuug.no/~peter/pf/">http://home.nuug.no/~peter/pf/</link>.</para>

    <warning>
      <para>When reading the <link
	  xlink:href="http://www.openbsd.org/faq/pf/">PF FAQ</link>,
	keep in mind that different versions of &os; contain
	different versions of <application>PF</application>.
	&os;&nbsp;8.<replaceable>X</replaceable> uses the same
	version of <application>PF</application> as
	OpenBSD&nbsp;4.1 and  &os;&nbsp;9.<replaceable>X</replaceable>
	and later uses the same version of
	<application>PF</application> as OpenBSD&nbsp;4.5.</para>
    </warning>

    <para>The &a.pf; is a good place to ask questions about
      configuring and running the <application>PF</application>
      firewall.  Check the mailing list archives before asking a
      question as it may have already been answered.</para>

    <para>More information about porting <application>PF</application>
      to &os; can be found at <uri
	xlink:href="http://pf4freebsd.love2party.net/">http://pf4freebsd.love2party.net/</uri>.</para>

    <para>This section of the Handbook focuses on
      <application>PF</application> as it pertains to &os;.  It
      demonstrates how to enable <application>PF</application> and
      <application>ALTQ</application>.  It then provides several
      examples for creating rulesets on a &os; system.</para>

    <sect2>
      <title>Enabling <application>PF</application></title>

      <para>In order to use <application>PF</application>, its kernel
	module must be first loaded.  This section describes the
	entries that can be added to <filename>/etc/rc.conf</filename>
	in order to enable <application>PF</application>.</para>

      <para>Start by adding the following line to
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>pf_enable="YES"</programlisting>

      <para>Additional options, described in &man.pfctl.8;, can be
	passed to <application>PF</application> when it is started.
	Add this entry to  <filename>/etc/rc.conf</filename> and
	specify any required flags between the two quotes
	(<literal>""</literal>):</para>

      <programlisting>pf_flags=""                     # additional flags for pfctl startup</programlisting>

      <para><application>PF</application> will not start if it cannot
	find its ruleset configuration file.  The default ruleset is
	already created and is named
	<filename>/etc/pf.conf</filename>.  If a custom ruleset has
	been saved somewhere else, add a line to
	<filename>/etc/rc.conf</filename> which specifies the full
	path to the file:</para>

      <programlisting>pf_rules="<replaceable>/path/to/pf.conf</replaceable>"</programlisting>

      <para>Logging support for <application>PF</application> is
	provided by &man.pflog.4;.  To enable logging support, add
	this line to <filename>/etc/rc.conf</filename>:</para>

      <programlisting>pflog_enable="YES"</programlisting>

      <para>The following lines can also be added in order to
	change the default location of the log file or to specify any
	additional flags to pass to &man.pflog.4; when it is
	started:</para>

      <programlisting>pflog_logfile="/var/log/pflog"  # where pflogd should store the logfile
pflog_flags=""                  # additional flags for pflogd startup</programlisting>

      <para>Finally, if there is a <acronym>LAN</acronym> behind the
	firewall and packets need to be forwarded for the computers on
	the <acronym>LAN</acronym>, or <acronym>NAT</acronym> is
	required, add the following option:</para>

      <programlisting>gateway_enable="YES"            # Enable as LAN gateway</programlisting>

      <para>After saving the needed edits,
	<application>PF</application> can be started with logging
	support by typing:</para>

      <screen>&prompt.root; <userinput>service pf start</userinput>
&prompt.root; <userinput>service pflog start</userinput></screen>

<!--
This is no longer true as of 9.x. It also references the CARP section
which doesn't explain how to use it...At some point it should.
     <indexterm>
	<primary>kernel options</primary>
	<secondary>device pf</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>
	<secondary>device pflog</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>
	<secondary>device pfsync</secondary>
      </indexterm>

      <note>
      <para>While it is not necessary to compile
	<application>PF</application> support into the &os; kernel,
	some advanced features are not included, namely &man.pfsync.4;, which is a
	pseudo-device that exposes certain changes to the state table
	used by <application>PF</application>.  It can be paired with
	&man.carp.4; to create failover firewalls using
	<application>PF</application>.  More information on
	<acronym>CARP</acronym> can be found in <xref linkend="carp"/>.</para>

      <para>The following <application>PF</application> kernel options
	are available:</para>

      <programlisting>device pf
device pflog
device pfsync</programlisting>

      <para>where:</para>

      <para><literal>device pf</literal> enables PF support.</para>

      <para><literal>device pflog</literal> enables the optional
	&man.pflog.4; pseudo network device which can be used to log
	traffic to a &man.bpf.4; descriptor.  The &man.pflogd.8;
	daemon can then be used to store the logging information to
	disk.</para>

      <para><literal>device pfsync</literal> enables the optional
	&man.pfsync.4; pseudo-network device that is used to monitor
	<quote>state changes</quote>.</para>
    </note>
    -->

      <para>By default, <application>PF</application> reads its
	configuration rules from <filename>/etc/pf.conf</filename> and
	modifies, drops, or passes packets according to the rules or
	definitions specified in this file.  The &os; installation
	includes several sample files located in
	<filename>/usr/share/examples/pf/</filename>.  Refer to the
	<link xlink:href="http://www.openbsd.org/faq/pf/">PF
	  FAQ</link> for complete coverage
	of <application>PF</application> rulesets.</para>

      <para>To control <application>PF</application>, use
	<command>pfctl</command>.  <xref linkend="pfctl"/> summarizes
	some useful options to this command.  Refer to &man.pfctl.8;
	for a description of all available options:</para>

      <table xml:id="pfctl" frame="none" pgwide="1">
	<title>Useful <command>pfctl</command> Options</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Command</entry>
	      <entry>Purpose</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><command>pfctl
		  -e</command></entry>
	      <entry>Enable <application>PF</application>.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl
		  -d</command></entry>
	      <entry>Disable <application>PF</application>.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -F all
		  -f /etc/pf.conf</command></entry>
	      <entry>Flush all <acronym>NAT</acronym>, filter, state,
		and table rules and reload
		<filename>/etc/pf.conf</filename>.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -s [ rules | nat
		  state ]</command></entry>
	      <entry>Report on the filter rules,
		<acronym>NAT</acronym> rules, or state
		table.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -vnf
		  /etc/pf.conf</command></entry>
	      <entry>Check <filename>/etc/pf.conf</filename> for
		errors, but do not load ruleset.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <tip>
	<para><package>security/sudo</package> is useful for running
	  commands like <command>pfctl</command> that require elevated
	  privileges.  It can be installed from the Ports
	  Collection.</para>
      </tip>

      <para>To keep an eye on the traffic that passes through the
	<application>PF</application> firewall, consider installing
	the <package>sysutils/pftop</package> package or port.  Once
	installed, <application>pftop</application> can be run to
	view a running snapshot of traffic in a format which is
	similar to &man.top.1;.</para>
    </sect2>

    <sect2>
      <title>Enabling <application>ALTQ</application></title>

      <para>On &os;, <application>ALTQ</application> can be used with
	<application>PF</application> to provide Quality of Service
	(<acronym>QOS</acronym>).  Once
	<application>ALTQ</application> is enabled, queues can be
	defined in the ruleset which determine the processing priority
	of outbound packets.</para>

      <para>Before enabling <application>ALTQ</application>, refer to
	&man.altq.4; to determine if the drivers for the network cards
	installed on the system support it.</para>

      <para><application>ALTQ</application> is not available as a
	loadable kernel module.  If the system's interfaces support
	<application>ALTQ</application>, create a custom kernel using
	the instructions in <xref linkend="kernelconfig"/>.  The
	following kernel options are available.  The first is needed
	to enable <application>ALTQ</application>.  At least one of
	the other options is necessary to specify the queueing
	scheduler algorithm:</para>

      <programlisting>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</programlisting>

      <para>The following scheduler algorithms are available:</para>

      <variablelist>
	<varlistentry>
	  <term>CBQ</term>
	  <listitem>
	    <para>Class Based Queuing (<acronym>CBQ</acronym>) is
	      used to divide a connection's bandwidth into different
	      classes or queues to prioritize traffic based on filter
	      rules.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RED</term>
	  <listitem>
	    <para>Random Early Detection (<acronym>RED</acronym>) is
	      used to avoid network congestion by measuring the length
	      of the queue and comparing it to the minimum and maximum
	      thresholds for the queue.  When the queue is over the
	      maximum, all new packets are randomly dropped.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RIO</term>
	  <listitem>
	    <para>In Random Early Detection In and Out
	      (<acronym>RIO</acronym>) mode, <acronym>RED</acronym>
	      maintains multiple average queue lengths and multiple
	      threshold values, one for each
	      <acronym>QOS</acronym> level.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>HFSC</term>
	  <listitem>
	    <para>Hierarchical Fair Service Curve Packet Scheduler
	      (<acronym>HFSC</acronym>) is described in <uri
		xlink:href="http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html">http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</uri>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>PRIQ</term>
	  <listitem>
	    <para>Priority Queuing (<acronym>PRIQ</acronym>) always
	      passes traffic that is in a higher queue first.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>More information about the scheduling
	algorithms and example rulesets are available at <uri
	  xlink:href="http://www.openbsd.org/faq/pf/queueing.html">http://www.openbsd.org/faq/pf/queueing.html</uri>.</para>
    </sect2>

    <sect2 xml:id="pf-tutorial">
      <info>
	<title><application>PF</application> Rulesets</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Peter</firstname>
	      <surname>Hansteen</surname>
	      <othername>N. M.</othername>
	    </personname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>This section demonstrates how to create a customized
	ruleset.  It starts with the simplest of rulesets and builds
	upon its concepts using several examples to demonstrate
	real-world usage of <application>PF</application>'s many
	features.</para>

      <para>The simplest possible ruleset is for a single machine
	that does not run any services and which needs access to one
	network, which may be the Internet.  To create this minimal
	ruleset, edit <filename>/etc/pf.conf</filename> so it looks
	like this:</para>

      <programlisting>block in all
pass out all keep state</programlisting>

      <para>The first rule denies all incoming traffic by default.
	The second rule allows connections created by this system to
	pass out, while retaining state information on those
	connections.  This state information allows return traffic for
	those connections to pass back and should only be used on
	machines that can be trusted.  The ruleset can be loaded
	with:</para>

      <screen>&prompt.root; <userinput>pfctl -e ; pfctl -f /etc/pf.conf</userinput></screen>

      <para>In addition to keeping state,
	<application>PF</application> provides
	<firstterm>lists</firstterm> and
	<firstterm>macros</firstterm> which can be defined for use
	when creating rules.  Macros can include lists and need to be
	defined before use.  As an example, insert these lines at the
	very top of the ruleset:</para>

      <programlisting>tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"</programlisting>

      <para><application>PF</application> understands port names as
	well as port numbers, as long as the names are listed in
	<filename>/etc/services</filename>.  This example creates two
	macros.  The first is a list of seven
	<acronym>TCP</acronym> port names and the second is one
	<acronym>UDP</acronym> port name.  Once defined, macros can be
	used in rules.  In this example, all traffic is blocked except
	for the  connections initiated by this system for the seven
	specified <acronym>TCP</acronym> services and the one
	specified <acronym>UDP</acronym> service:</para>

      <programlisting>tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</programlisting>

      <para>Even though <acronym>UDP</acronym> is considered to be a
	stateless protocol, <application>PF</application> is able to
	track some state information.  For example, when a
	<acronym>UDP</acronym> request is passed which asks a name
	server about a domain name, <application>PF</application> will
	watch for the response in order to pass it back.</para>

      <para>Whenever an edit is made to a ruleset, the new rules must
	be loaded so they can be used:</para>

      <screen>&prompt.root; <userinput>pfctl -f /etc/pf.conf</userinput></screen>

      <para>If there are no syntax errors, <command>pfctl</command>
	will not output any messages during the rule load.  Rules can
	also be tested before attempting to load them:</para>

      <screen>&prompt.root; <userinput>pfctl -nf /etc/pf.conf</userinput></screen>

      <para>Including <option>-n</option> causes the rules to be
	interpreted only, but not loaded.  This provides an
	opportunity to correct any errors.  At all times, the last
	valid ruleset loaded will be enforced until either
	<application>PF</application> is disabled or a new ruleset is
	loaded.</para>

      <tip>
	<para>Adding <option>-v</option> to a <command>pfctl</command>
	  ruleset verify or load will display the fully parsed rules
	  exactly the way they will be loaded.  This is extremely
	  useful when debugging rules.</para>
      </tip>

      <sect3 xml:id="pftut-gateway">
	<title>A Simple Gateway with NAT</title>

	<para>This section demonstrates how to configure a &os; system
	  running <application>PF</application> to act as a gateway
	  for at least one other machine.  The gateway needs at least
	  two network interfaces, each connected to a separate
	  network.  In this example, <filename>xl1</filename> is
	  connected to the Internet and <filename>xl0</filename> is
	  connected to the internal network.</para>

	<para>First, enable the gateway in order to let the machine
	  forward the network traffic it receives on one interface to
	  another interface.  This <application>sysctl</application>
	  setting will forward <acronym>IPv4</acronym> packets:</para>

	<screen>&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	<para>To forward <acronym>IPv6</acronym> traffic, use:</para>

	<screen>&prompt.root; <userinput>sysctl net.inet6.ip6.forwarding=1</userinput></screen>

	<para>To enable these settings at system boot, add the
	  following to <filename>/etc/rc.conf</filename>:</para>

	<programlisting>gateway_enable="YES"		#for ipv4
ipv6_gateway_enable="YES"	#for ipv6</programlisting>

	<para>Verify with <command>ifconfig</command> that both of the
	  interfaces are up and running.</para>

	<para>Next, create the <application>PF</application> rules to
	  allow the gateway to pass traffic.  While the following rule
	  allows stateful traffic to pass from the Internet  to hosts
	  on the network, the <literal>to</literal> keyword does not
	  guarantee passage all the way from source to
	  destination:</para>

	<programlisting>pass in on xl1 from xl1:network to xl0:network port $ports keep state</programlisting>

	<para>That rule only lets the traffic pass in to the gateway
	  on the internal interface.  To let the packets go further, a
	  matching rule is needed:</para>

	<programlisting>pass out on xl0 from xl1:network to xl0:network port $ports keep state</programlisting>

	<para>While these two rules will work, rules this specific are
	  rarely needed.  For a busy network admin, a readable ruleset
	  is a safer ruleset.  The remainder of this section
	  demonstrates how to keep the rules as simple as possible for
	  readability.  For example, those two rules could be
	  replaced with one rule:</para>

	<programlisting>pass from xl1:network to any port $ports keep state</programlisting>

	<para>The <literal>interface:network</literal> notation can be
	  replaced with a macro to make the ruleset even more
	  readable.  For example, a <literal>$localnet</literal> macro
	  could be defined as the network directly attached to the
	  internal interface (<literal>$xl1:network</literal>).
	  Alternatively, the definition of
	  <literal>$localnet</literal> could be changed to an
	  <emphasis>IP address/netmask</emphasis> notation to denote
	  a network, such as <literal>192.168.100.1/24</literal> for a
	  subnet of private addresses.</para>

	<para>If required, <literal>$localnet</literal> could even be
	  defined as a list of networks.  Whatever the specific needs,
	  a sensible <literal>$localnet</literal> definition could be
	  used in a typical pass rule as follows:</para>

	<programlisting>pass from $localnet to any port $ports keep state</programlisting>

	<para>The following sample ruleset allows all traffic
	  initiated by machines on the internal network.  It first
	  defines two macros to represent the external and internal
	  3COM interfaces of the gateway.</para>

	<note>
	  <para>For dialup users, the external interface will use
	    <filename>tun0</filename>.  For an
	    <acronym>ADSL</acronym> connection, specifically those
	    using <acronym>PPP</acronym> over Ethernet
	    (<acronym>PPPoE</acronym>), the correct external
	    interface is <filename>tun0</filename>, not the physical
	    Ethernet interface.</para>
	</note>

	<programlisting>ext_if = "xl0"	# macro for external interface - use tun0 for PPPoE
int_if = "xl1"	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</programlisting>

	<para>This ruleset introduces the <literal>nat</literal> rule
	  which is used to handle the network address translation from
	  the non-routable addresses inside the internal network to
	  the <acronym>IP</acronym> address assigned to the external
	  interface.  The parentheses surrounding the last part of the
	  nat rule <literal>($ext_if)</literal> is included when the
	  <acronym>IP</acronym> address of the external interface is
	  dynamically assigned.  It ensures that network traffic runs
	  without serious interruptions even if the external
	  <acronym>IP</acronym> address changes.</para>

	<para>Note that this ruleset probably allows more traffic to
	  pass out of the network than is needed.  One reasonable
	  setup could create this macro:</para>

	<programlisting>client_out = "{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }"</programlisting>

	<para>to use in the main pass rule:</para>

	<programlisting>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</programlisting>

	<para>A few other pass rules may be needed.  This one enables
	  <acronym>SSH</acronym> on the external interface::</para>

	<programlisting>pass in inet proto tcp to $ext_if port ssh</programlisting>

	<para>This macro definition and rule allows
	  <acronym>DNS</acronym> and <acronym>NTP</acronym> for
	  internal clients:</para>

	<programlisting>udp_services = "{ domain, ntp }"
pass quick inet proto { tcp, udp } to any port $udp_services keep state</programlisting>

	<para>Note the <literal>quick</literal> keyword in this rule.
	  Since the ruleset consists of several rules, it is important
	  to understand the relationships between the rules in a
	  ruleset.  Rules are evaluated from top to bottom, in the
	  sequence they are written.  For each packet or connection
	  evaluated by <application>PF</application>,
	  <emphasis>the last matching rule</emphasis> in the ruleset
	  is the one which is applied.  However, when a packet matches
	  a rule which contains the <literal>quick</literal> keyword,
	  the rule processing stops and the packet is treated
	  according to that rule.  This is very useful when an
	  exception to the general rules is needed.</para>
      </sect3>

      <sect3 xml:id="pftut-ftp">
	<title>Creating an <acronym>FTP</acronym> Proxy</title>

	<para>Configuring working <acronym>FTP</acronym> rules can be
	  problematic due to the nature of the <acronym>FTP</acronym>
	  protocol.  <acronym>FTP</acronym> pre-dates firewalls by
	  several decades and is insecure in its design.  The most
	  common points against using <acronym>FTP</acronym>
	  include:</para>

	<itemizedlist>
	  <listitem>
	    <para>Passwords are transferred in the clear.</para>
	  </listitem>

	  <listitem>
	    <para>The protocol demands the use of at least two
	      <acronym>TCP</acronym> connections (control and data) on
	      separate ports.</para>
	  </listitem>

	  <listitem>
	    <para>When a session is established, data is communicated
	      using randomly selected ports.</para>
	  </listitem>
	</itemizedlist>

	<para>All of these points present security challenges, even
	  before considering any potential security weaknesses in
	  client or server software.  More secure alternatives for
	  file transfer exist, such as &man.sftp.1; or &man.scp.1;,
	  which both feature authentication and data transfer over
	  encrypted connections..</para>

	<para>For those situations when <acronym>FTP</acronym> is
	  required, <application>PF</application> provides
	  redirection of <acronym>FTP</acronym> traffic to a small
	  proxy program called &man.ftp-proxy.8;, which is included in
	  the base system of &os;.  The role of the proxy is to
	  dynamically insert and delete rules in the ruleset, using a
	  set of anchors, in order to correctly handle
	  <acronym>FTP</acronym> traffic.</para>

	<para>To enable the <acronym>FTP</acronym> proxy, add this
	  line to <filename>/etc/rc.conf</filename>:</para>

	<programlisting>ftpproxy_enable="YES"</programlisting>

	<para>Then start the proxy by running <command>service
	    ftp-proxy start</command>.</para>

	<para>For a basic configuration, three elements need to be
	  added to <filename>/etc/pf.conf</filename>.  First, the
	  anchors which the proxy will use to insert the rules it
	  generates for the <acronym>FTP</acronym> sessions:</para>

	<programlisting>nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"</programlisting>

	<para>Second, a pass rule is needed to allow
	  <acronym>FTP</acronym> traffic in to the proxy.</para>

	<para>Third, redirection and <acronym>NAT</acronym> rules need
	  to be defined before the filtering rules.  Insert this
	  <literal>rdr</literal> rule immediately after the
	  <literal>nat</literal> rule:</para>

	<programlisting>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</programlisting>

	<para>Finally, allow the redirected traffic to pass:</para>

	<programlisting>pass out proto tcp from $proxy to any port ftp</programlisting>

	<para>where <literal>$proxy</literal> expands to the address
	  the proxy daemon is bound to.</para>

	<para>Save <filename>/etc/pf.conf</filename>, load the new
	  rules, and verify from a client that <acronym>FTP</acronym>
	  connections are working:</para>

	<screen>&prompt.root; <userinput>pfctl -f /etc/pf.conf</userinput></screen>

	<para>This example covers a basic setup where the clients in
	  the local network need to contact <acronym>FTP</acronym>
	  servers elsewhere.  This basic configuration should
	  work well with most combinations of <acronym>FTP</acronym>
	  clients and servers.  As shown in &man.ftp-proxy.8;, the
	  proxy's behavior can be changed in various ways by adding
	  options to the <literal>ftpproxy_flags=</literal> line.
	  Some clients or servers may have specific quirks that must
	  be compensated for in the configuration, or there may be a
	  need to integrate the proxy in specific ways such as
	  assigning <acronym>FTP</acronym> traffic to a specific
	  queue.</para>

	<para>For ways to run an <acronym>FTP</acronym> server
	  protected by <application>PF</application> and
	  &man.ftp-proxy.8;, configure a separate
	  <command>ftp-proxy</command> in reverse mode, using
	  <option>-R</option>, on a separate port with its own
	  redirecting pass rule.</para>
      </sect3>

      <sect3 xml:id="pftut-icmp">
	<title>Managing <acronym>ICMP</acronym></title>

	<para>Many of the tools used for debugging or troubleshooting
	  a <acronym>TCP/IP</acronym> network rely on the Internet
	  Control Message Protocol (<acronym>ICMP</acronym>), which
	  was designed specifically with debugging in mind.</para>

	<para>The <acronym>ICMP</acronym> protocol sends and receives
	  <emphasis>control messages</emphasis> between hosts and
	  gateways, mainly to provide feedback to a sender about any
	  unusual or difficult conditions enroute to the target host.
	  Routers use <acronym>ICMP</acronym> to negotiate packet
	  sizes and other transmission parameters in a process often
	  referred to as <emphasis>path <acronym>MTU</acronym>
	    discovery</emphasis>.</para>

	<para>From a firewall perspective, some
	  <acronym>ICMP</acronym> control messages are vulnerable to
	  known attack vectors.  Also, letting all diagnostic traffic
	  pass unconditionally makes debugging easier, but it also
	  makes it easier for others to extract information about the
	  network.  For these reasons, the following rule may not be
	  optimal:</para>

	<programlisting>pass inet proto icmp from any to any</programlisting>

	<para>One solution is to let all <acronym>ICMP</acronym>
	  traffic from the local network through while stopping all
	  probes from outside the network:</para>

	<programlisting>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</programlisting>

	<para>Additional options are available which demonstrate some
	  of <application>PF</application>'s flexibility.  For
	  example, rather than allowing all <acronym>ICMP</acronym>
	  messages, one can specify the messages used by &man.ping.8;
	  and &man.traceroute.8;.  Start by defining a macro for that
	  type of message:</para>

	<programlisting>icmp_types = "echoreq"</programlisting>

	<para>and a rule which uses the macro:</para>

	<programlisting>pass inet proto icmp all icmp-type $icmp_types keep state</programlisting>

	<para>If other types of <acronym>ICMP</acronym> packets are
	  needed, expand <literal>icmp_types</literal> to a list of
	  those packet types.  Type <command>more
	    /usr/src/contrib/pf/pfctl/pfctl_parser.c</command> to see
	  the list of <acronym>ICMP</acronym> message types supported
	  by <application>PF</application>.  Refer to <link
	      xlink:href="http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml">http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</link>
	  for an explanation of each message type.</para>

	<para>Since Unix <command>traceroute</command> uses
	  <acronym>UDP</acronym> by default, another rule is needed to
	  allow Unix <command>traceroute</command>:</para>

	<programlisting># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</programlisting>

	<para>Since <command>TRACERT.EXE</command> on Microsoft
	  Windows systems uses <acronym>ICMP</acronym> echo request
	  messages, only the first rule is needed to allow network
	  traces from those systems.  Unix
	  <command>traceroute</command> can be instructed to use other
	  protocols as well, and will use <acronym>ICMP</acronym> echo
	  request messages if <option>-I</option> is used.  Check the
	  &man.traceroute.8; man page for details.</para>

	<sect4 xml:id="pftut-pathmtudisc">
	  <title>Path <acronym>MTU</acronym> Discovery</title>

	  <para>Internet protocols are designed to be device
	    independent, and one consequence of device independence is
	    that the optimal packet size for a given connection cannot
	    always be predicted reliably.  The main constraint on
	    packet size is the <firstterm>Maximum Transmission
	      Unit</firstterm> (<acronym>MTU</acronym>) which sets the
	    upper limit on the packet size for an interface.  Type
	    <command>ifconfig</command> to view the
	    <acronym>MTU</acronym>s for a system's network
	    interfaces.</para>

	  <para><acronym>TCP/IP</acronym> uses a process known as path
	    <acronym>MTU</acronym> discovery to determine the right
	    packet size for a connection.  This process sends packets
	    of varying sizes with the <quote>Do not fragment</quote>
	    flag set, expecting an <acronym>ICMP</acronym> return
	    packet of <quote>type 3, code 4</quote> when the upper
	    limit has been reached.  Type 3 means <quote>destination
	      unreachable</quote>, and code 4 is short for
	    <quote>fragmentation needed, but the do-not-fragment flag
	      is set</quote>.  To allow path MTU discovery in order
	    to support connections to other <acronym>MTU</acronym>s,
	    add the <literal>destination unreachable</literal> type to
	    the <literal>icmp_types</literal> macro:</para>

	  <programlisting>icmp_types = "{ echoreq, unreach }"</programlisting>

	  <para>Since the pass rule already uses that macro, it does
	    not need to be modified in order to support the new
	    <acronym>ICMP</acronym> type:</para>

	  <programlisting>pass inet proto icmp all icmp-type $icmp_types keep state</programlisting>

	  <para><application>PF</application> allows filtering on all
	    variations of <acronym>ICMP</acronym> types and codes.
	    The list of possible types and codes are documented in
	    &man.icmp.4; and &man.icmp6.4;.</para>
	</sect4>
      </sect3>

      <sect3 xml:id="pftut-tables">
	<title>Using Tables</title>

	<para>Some types of data are relevant to filtering and
	  redirection at a given time, but their definition is too
	  long to be included in the ruleset file.
	  <application>PF</application> supports the use of tables,
	  which are defined lists that can be manipulated without
	  needing to reload the entire ruleset, and which can provide
	  fast lookups.  Table names are always enclosed within
	  <literal>&lt; &gt;</literal>, like this:</para>

	<programlisting>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</programlisting>

	<para>In this example, the <literal>192.168.2.0/24</literal>
	  network is part of the table, except for the address
	  <literal>192.168.2.5</literal>, which is excluded using the
	  <literal>!</literal> operator.  It is also possible to load
	  tables from files where each item is on a separate line, as
	  seen in this example
	  <filename>/etc/clients</filename>:</para>

	<programlisting>192.168.2.0/24
!192.168.2.5</programlisting>

	<para>To refer to the file, define the table like this:</para>

	<programlisting>table &lt;clients&gt; persist file "/etc/clients"</programlisting>

	<para>Once the table is defined, it can be referenced by a
	  rule:</para>

	<programlisting>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</programlisting>

	<para>A table's contents can be manipulated live, using
	  <command>pfctl</command>.  This example adds another network
	  to the table:</para>

	<screen>&prompt.root; <userinput>pfctl -t clients -T add 192.168.1.0/16</userinput></screen>

	<para>Note that any changes made this way will take affect
	  now, making them ideal for testing, but will not survive a
	  power failure or reboot.  To make the changes permanent,
	  modify the definition of the table in the ruleset or edit
	  the file that the table refers to.  One can maintain the
	  on-disk copy of the table using a &man.cron.8; job which
	  dumps the table's contents to disk at regular intervals,
	  using a command such as <command>pfctl -t clients -T show
	    &gt;/etc/clients</command>.  Alternatively,
	  <filename>/etc/clients</filename> can be updated with the
	  in-memory table contents:</para>

	<screen>&prompt.root; <userinput>pfctl -t clients -T replace -f /etc/clients</userinput></screen>
      </sect3>

      <sect3 xml:id="pftut-overload">
	<title>Using Overload Tables to Protect
	  <acronym>SSH</acronym></title>

	<para>Those who run <acronym>SSH</acronym> on an external
	  interface have probably seen something like this in the
	  authentication logs:</para>

	<programlisting>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</programlisting>

	<para>This is indicative of a brute force attack where
	  somebody or some program is trying to discover the user name
	  and password which will let them into the system.</para>

	<para>If external <acronym>SSH</acronym> access is needed for
	  legitimate users, changing the default port used by
	  <acronym>SSH</acronym> can offer some protection.  However,
	  <application>PF</application> provides a more elegant
	  solution.  Pass rules can contain limits on what connecting
	  hosts can do and violators can be banished to a table of
	  addresses which are denied some or all access.  It is even
	  possible to drop all existing connections from machines
	  which overreach the limits.</para>

	<para>To configure this, create this table in the tables
	  section of the ruleset:</para>

	<programlisting>table &lt;bruteforce&gt; persist</programlisting>

	<para>Then, somewhere early in the ruleset, add rules to block
	  brute access while allowing legitimate access:</para>

	<programlisting>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn <replaceable>100</replaceable>, max-src-conn-rate <replaceable>15/5</replaceable>, \
    overload &lt;bruteforce&gt; flush global)</programlisting>

	<para>The part in parentheses defines the limits and the
	  numbers should be changed to meet local requirements.  It
	  can be read as follows:</para>

	<para><literal>max-src-conn</literal> is the number of
	  simultaneous connections allowed from one host.</para>

	<para><literal>max-src-conn-rate</literal> is the rate of new
	  connections allowed from any single host
	  (<replaceable>15</replaceable>) per number of seconds
	  (<replaceable>5</replaceable>).</para>

	<para><literal>overload &lt;bruteforce&gt;</literal> means
	  that any host which exceeds these limits gets its address
	  added to the <literal>bruteforce</literal> table.  The
	  ruleset blocks all traffic from addresses in the
	  <literal>bruteforce</literal> table.</para>

	<para>Finally, <literal>flush global</literal> says that when
	  a host reaches the limit, that all
	  (<literal>global</literal>) of that host's connections will
	  be terminated (<literal>flush</literal>).</para>

	<note>
	  <para>These rules will <emphasis>not</emphasis> block slow
	    bruteforcers, as described in <link
	      xlink:href="http://home.nuug.no/~peter/hailmary2013/">http://home.nuug.no/~peter/hailmary2013/</link>.</para>
	</note>

	<para>This example ruleset is intended mainly as an
	  illustration.  For example, if a generous number of
	  connections in general are wanted, but the desire is to be
	  more restrictive when it comes to
	  <application>ssh</application>, supplement the rule above
	  with something like the one below, early on in the rule
	  set:</para>

	<programlisting>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</programlisting>

	<note>
	  <title>It May Not be Necessary to Block All
	    Overloaders</title>

	  <para>It is worth noting that the overload mechanism is a
	    general technique which does not apply exclusively to
	    <acronym>SSH</acronym>, and it is not always optimal to
	    entirely block all traffic from offenders.</para>

	  <para>For example, an overload rule could be used to
	    protect a mail service or a web service, and the overload
	    table could be used in a rule to assign offenders to a
	    queue with a minimal bandwidth allocation or to redirect
	    to a specific web page.</para>
	</note>

	<para>Over time, tables will be filled by overload rules and
	  their size will grow incrementally, taking up more memory.
	  Sometimes an <acronym>IP</acronym> address that is blocked
	  is a dynamically assigned one, which has since been assigned
	  to a host who has a legitimate reason to communicate with
	  hosts in the local network.</para>

	<para>For situations like these,
	  <application>pfctl</application> provides the ability to
	  expire table entries.  For example, this command will remove
	  <literal>&lt;bruteforce&gt;</literal> table entries which
	  have not been referenced for <literal>86400</literal>
	  seconds:</para>

	<screen>&prompt.root; <userinput>pfctl -t bruteforce -T expire 86400</userinput></screen>

	<para>Similar functionality is provided by
	  <package>security/expiretable</package>, which removes table
	  entries which have not been accessed for a specified period
	  of time.</para>

	<para>Once installed, <application>expiretable</application>
	  can be run to remove <literal>&lt;bruteforce&gt;</literal>
	  table entries older than a specified age.  This example
	  removes all entries older than 24 hours:</para>

	<programlisting>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</programlisting>
      </sect3>

      <sect3 xml:id="pftut-spamd">
	<title>Protecting Against <acronym>SPAM</acronym></title>

	<para>Not to be confused with the
	  <application>spamd</application> daemon which comes bundled
	  with <application>spamassassin</application>,
	  <package>mail/spamd/</package> can be configured with
	  <application>PF</application> to provide an outer defense
	  against <acronym>SPAM</acronym>.  This
	  <application>spamd</application> hooks into the
	  <application>PF</application> configuration using a set of
	  redirections.</para>

	<para>Spammers tend to send a large number of messages, and
	  <acronym>SPAM</acronym> is mainly sent from a few spammer
	  friendly networks and a large number of hijacked machines,
	  both of which are reported to
	  <firstterm>blacklists</firstterm> fairly quickly.</para>

	<para>When an <acronym>SMTP</acronym> connection from an
	  address in a blacklist is received,
	  <application>spamd</application> presents its banner and
	  immediately switches to a mode where it answers
	  <acronym>SMTP</acronym> traffic one byte at a time.  This
	  technique, which is intended to waste as much time as
	  possible on the spammer's end, is called
	  <firstterm>tarpitting</firstterm>.  The specific
	  implementation which uses one byte <acronym>SMTP</acronym>
	  replies is often referred to as
	  <firstterm>stuttering</firstterm>.</para>

	<para>This example demonstrates the basic procedure for
	  setting up <application>spamd</application> with
	  automatically updated blacklists.  Refer to the man pages
	  which are installed with <package>mail/spamd/</package> for
	  more information.</para>

	<procedure>
	  <title>Configuring <application>spamd</application></title>

	  <step>
	    <para>Install the <package>mail/spamd/</package> package
	      or port.  In order to use
	      <application>spamd</application>'s greylisting
	      features, &man.fdescfs.5; must be mounted at <filename
		class="directory">/dev/fd</filename>.  Add the
	      following line to
	      <filename>/etc/fstab</filename>:</para>

	    <programlisting> fdescfs /dev/fd fdescfs rw 0 0</programlisting>

	    <para>Then, mount the filesystem:</para>

	    <programlisting>&prompt.root; mount fdescfs</programlisting>
	  </step>

	  <step>
	    <para>Next, edit the <application>PF</application> ruleset
	      to include:</para>

	    <programlisting>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</programlisting>

	    <para>The two tables <literal>&lt;spamd&gt;</literal> and
	      <literal>&lt;spamd-white&gt;</literal> are essential.
	      <acronym>SMTP</acronym> traffic from an address listed
	      in<literal> &lt;spamd&gt;</literal> but not in
	      <literal>&lt;spamd-white&gt;</literal> is redirected to
	      the <application>spamd</application> daemon listening at
	      port 8025.</para>
	  </step>

	  <step>
	    <para>The next step is to configure
	      <application>spamd</application> in
	      <filename>/usr/local/etc/spamd.conf</filename> and to
	      add some <filename>rc.conf</filename> parameters.</para>

	    <para>The installation of <package>mail/spamd/</package>
	      includes a sample configuration file
	      (<filename>/usr/local/etc/spamd.conf.sample</filename>)
	      and a man page for <filename>spamd.conf</filename>.
	      Refer to these for additional configuration options
	      beyond those shown in this example.</para>

	    <para>One of the first lines in the configuration file
	      that does not begin with a <literal>#</literal> comment
	      sign contains the block which defines the
	      <literal>all</literal> list, which specifies the lists
	      to use:</para>

	    <programlisting>all:\
    :traplist:whitelist:</programlisting>

	    <para>This entry adds the desired blacklists, separated by
	      colons (<literal>:</literal>).  To use a whitelist to
	      subtract addresses from a blacklist, add the name of the
	      whitelist <emphasis>immediately</emphasis> after the
	      name of that blacklist.  For example:
	      <literal>:blacklist:whitelist:</literal>.</para>

	    <para>This is followed by the specified blacklist's
	      definition:</para>

	    <programlisting>traplist:\
    :black:\
    :msg="SPAM. Your address %A has sent spam within the last 24 hours":\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</programlisting>

	    <para>where the first line is the name of the blacklist
	      and the second line specifies the list type.  The
	      <literal>msg</literal> field contains the message to
	      display to blacklisted senders during the
	      <acronym>SMTP</acronym> dialogue.  The
	      <literal>method</literal> field specifies how
	      <application>spamd-setup</application> fetches the list
	      data; supported methods are <literal>http</literal>,
	      <literal>ftp</literal>, from a
	      <literal>file</literal> in a mounted file system, and
	      via <literal>exec</literal> of an external program.
	      Finally, the <literal>file</literal> field specifies
	      the name of the file <application>spamd</application>
	      expects to receive.</para>

	    <para>The definition of the specified whitelist is
	      similar, but omits the <literal>msg</literal> field
	      since a message is not needed:</para>

	    <programlisting>whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</programlisting>

	    <tip>
	      <title>Choose Data Sources with Care</title>

	      <para>Using all the blacklists in the sample
		<filename>spamd.conf</filename> will blacklist large
		blocks of the Internet.  Administrators need to edit
		the file to create an optimal configuration which uses
		applicable data sources and, when necessary, uses
		custom lists.</para>
	    </tip>

	    <para>Next, add this entry to
	      <filename>/etc/rc.conf</filename>.  Additional flags are
	      described in the man page specified by the
	      comment:</para>

	    <programlisting>spamd_flags="-v" # use "" and see spamd-setup(8) for flags</programlisting>

	    <para>When finished, reload the ruleset, start
	      <application>spamd</application> by typing
	      <command>service start obspamd</command>, and complete
	      the configuration using <command>spamd-setup</command>.
	      Finally, create a &man.cron.8; job which calls
	      <command>spamd-setup</command> to update the tables at
	      reasonable intervals.</para>
	  </step>
	</procedure>

	<para>On a typical gateway in front of a mail server, hosts
	  will soon start getting trapped within a few seconds to
	  several minutes.</para>

	<para><application>PF</application> also supports
	  <firstterm>greylisting</firstterm>, which temporarily
	  rejects messages from unknown hosts with
	  <replaceable>45n</replaceable> codes.  Messages from
	  greylisted hosts which try again within a reasonable time
	  are let through.  Traffic from senders which are set up to
	  behave within the limits set by RFC 1123 and RFC 2821 are
	  immediately let through.</para>

	<para>More information about greylisting as a technique can be
	  found at the <link
	    xlink:href="http://www.greylisting.org/">greylisting.org</link>
	  web site.  The most amazing thing about greylisting, apart
	  from its simplicity, is that it still works.  Spammers and
	  malware writers have been very slow to adapt in order to
	  bypass this technique.</para>

	<para>The basic procedure for configuring greylisting is as
	  follows:</para>

	<procedure>
	  <title>Configuring Greylisting</title>

	  <step>
	    <para>Make sure that &man.fdescfs.5; is mounted as
	      described in Step 1 of the previous Procedure.</para>
	  </step>

	  <step>
	    <para>To run <application>spamd</application> in
	      greylisting mode, add this line to
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>spamd_grey="YES"  # use spamd greylisting if YES</programlisting>

	    <para>Refer to the <application>spamd</application> man
	      page for descriptions of additional related
	      parameters.</para>
	  </step>

	  <step>
	    <para>To complete the greylisting setup:</para>

	    <programlisting>&prompt.root; <command>service restart obspamd</command>
&prompt.root; <command>service start spamlogd</command></programlisting>
	  </step>
	</procedure>

	<para>Behind the scenes, the <application>spamdb</application>
	  database tool and the <application>spamlogd</application>
	  whitelist updater perform essential functions for the
	  greylisting feature.  <application>spamdb</application> is
	  the administrator's main interface to managing the black,
	  grey, and white lists via the contents of the
	  <filename>/var/db/spamdb</filename> database.</para>
      </sect3>

      <sect3 xml:id="pftut-hygiene">
	<title>Network Hygiene</title>

	<para>This section describes how
	  <literal>block-policy</literal>, <literal>scrub</literal>,
	  and <literal>antispoof</literal> can be used to make the
	  ruleset behave sanely.</para>

	<para>The <literal>block-policy</literal> is an option which
	  can be set in the <literal>options</literal> part of the
	  ruleset, which precedes the redirection and filtering rules.
	  This option determines which feedback, if any,
	  <application>PF</application> sends to hosts that are
	  blocked by a rule.  The option has two possible values:
	  <literal>drop</literal> drops blocked packets with no
	  feedback, and <literal>return</literal> returns a status
	  code such as
	  <computeroutput>Connection refused</computeroutput>.</para>

	<para>If not set, the default policy is
	  <literal>drop</literal>.  To change the
	  <literal>block-policy</literal>, specify the desired
	  value:</para>

	<programlisting>set block-policy return</programlisting>

	<para>In <application>PF</application>,
	  <literal>scrub</literal> is a keyword which enables network
	  packet normalization.  This process reassembles fragmented
	  packets and drops TCP packets that have invalid flag
	  combinations.  Enabling <literal>scrub</literal> provides a
	  measure of protection against certain kinds of attacks
	  based on incorrect handling of packet fragments.  A number
	  of options are available, but the simplest form is suitable
	  for most configurations:</para>

	<programlisting>scrub in all</programlisting>

	<para>Some services, such as <acronym>NFS</acronym>, require
	  specific fragment handling options.  Refer to <link
	      xlink:href="http://www.openbsd.gr/faq/pf/scrub.html">http://www.openbsd.gr/faq/pf/scrub.html</link>
	  for more information.</para>

	<para>This example reassembles fragments, clears the
	  <quote>do not fragment</quote> bit, and sets the maximum
	  segment size to 1440 bytes:</para>

	<programlisting>scrub in all fragment reassemble no-df max-mss 1440</programlisting>

	<para>The <literal>antispoof</literal> mechanism protects
	  against activity from spoofed or forged
	  <acronym>IP</acronym> addresses, mainly by blocking packets
	  appearing on interfaces and in directions which are
	  logically not possible.</para>

	<para>These rules weed out spoofed traffic coming in from the
	  rest of the world as well as any spoofed packets which
	  originate in the local network:</para>

	<programlisting>antispoof for $ext_if
antispoof for $int_if</programlisting>
      </sect3>

      <sect3 xml:id="pftut-unrouteables">
	<title>Handling Non-Routable Addresses</title>

	<para>Even with a properly configured gateway to handle
	  network address translation, one may have to compensate for
	  other people's misconfigurations.  A common misconfiguration
	  is to let traffic with non-routable addresses out to the
	  Internet.  Since traffic from non-routeable addresses can
	  play a part in several <acronym>DoS</acronym> attack
	  techniques, consider explicitly blocking traffic from
	  non-routeable addresses from entering the network through
	  the external interface.</para>

	<para>In this example, a macro containing non-routable
	  addresses is defined, then used in blocking rules.  Traffic
	  to and from these addresses is quietly dropped on the
	  gateway's external
	  interface.</para>

	<programlisting>martians = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }"

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipf">
    <title>IPFILTER (IPF)</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary><application>IPFILTER</application></secondary>
    </indexterm>

    <para><application>IPFILTER</application>, also known as
      <application>IPF</application>, is a cross-platform, open source firewall which
      has been ported to several operating systems, including &os;, NetBSD, OpenBSD, and
      &solaris;.</para>

    <para><application>IPFILTER</application> is a kernel-side firewall and
      <acronym>NAT</acronym> mechanism that can be controlled and
      monitored by userland programs.  Firewall rules
      can be set or deleted using <application>ipf</application>,
      <acronym>NAT</acronym> rules can be set or deleted using
      <application>ipnat</application>, run-time statistics for the kernel parts of
      <application>IPFILTER</application> can be printed using
      <application>ipfstat</application>, and
      <application>ipmon</application> can be used to log <application>IPFILTER</application>
      actions to the system log files.</para>

    <para><application>IPF</application> was originally written using a rule processing logic
      of <quote>the last matching rule wins</quote> and only used
      stateless rules.  Since then, <application>IPF</application> has been enhanced to include
      the <literal>quick</literal> and
      <literal>keep state</literal> options.</para>

    <para>For a detailed explanation of the legacy rules processing
      method, refer to <uri
	xlink:href="http://coombs.anu.edu.au/~avalon/ip-filter.html">http://coombs.anu.edu.au/~avalon/ip-filter.html</uri>.</para>

    <para>The <application>IPF</application> FAQ is at <uri
	xlink:href="http://www.phildev.net/ipf/index.html">http://www.phildev.net/ipf/index.html</uri>.
      A searchable archive of the IPFilter mailing list is
      available at <uri
	xlink:href="http://marc.info/?l=ipfilter">http://marc.info/?l=ipfilter</uri>.</para>

    <para>This section of the Handbook focuses on
      <application>IPF</application> as it pertains to FreeBSD.
      It provides examples which uses
      rules that contain the <literal>quick</literal> and
      <literal>keep state</literal> options.</para>
    <sect2>
      <title>Enabling <application>IPF</application></title>

      <indexterm>
	<primary><application>IPFILTER</application></primary>

	<secondary>enabling</secondary>
      </indexterm>

      <para><application>IPF</application> is included in the basic &os; install as a kernel
	loadable module, meaning that a custom kernel is not needed in
	order to enable <application>IPF</application>.</para>

      <indexterm>
	<primary>kernel options</primary>

	<secondary><application>IPFILTER</application></secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFILTER_LOG</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFILTER_DEFAULT_BLOCK</secondary>
      </indexterm>

      <indexterm>
	<primary><application>IPFILTER</application></primary>

	<secondary>kernel options</secondary>
      </indexterm>

      <para>For users who prefer to statically compile <application>IPF</application> support
	into a custom kernel, refer to the instructions in <xref
	  linkend="kernelconfig"/>.  The following kernel options are
	available:</para>

      <programlisting>options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</programlisting>

      <para>where <literal>options IPFILTER</literal> enables support for
	<application>IPFILTER</application>, <literal>options IPFILTER_LOG</literal> enables <application>IPF</application>
	logging using the <filename>ipl</filename> packet logging
	pseudo device for every rule that has the
	<literal>log</literal> keyword,
	<literal>IPFILTER_LOOKUP</literal> enables <acronym>IP</acronym> pools in
	order to speed up <acronym>IP</acronym> lookups, and <literal>options IPFILTER_DEFAULT_BLOCK</literal> changes
	the default behavior so that any packet not matching a
	firewall <literal>pass</literal> rule gets blocked.</para>

      <para>To configure the system to enable <application>IPF</application>
	at boot time, add
	the following entries to
	<filename>/etc/rc.conf</filename>.  These entries will also enable logging and
	<literal>default pass all</literal>.  To change the
	default policy to <literal>block all</literal> without 
	compiling a custom kernel, remember to add a
	<literal>block all</literal> rule at the end of the
	ruleset.</para>

      <programlisting>ipfilter_enable="YES"             # Start ipf firewall
ipfilter_rules="/etc/ipf.rules"   # loads rules definition text file
ipmon_enable="YES"                # Start IP monitor log
ipmon_flags="-Ds"                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</programlisting>

      <para>If <acronym>NAT</acronym>
	functionality is needed, also add these lines:</para>

      <programlisting>gateway_enable="YES"              # Enable as LAN gateway
ipnat_enable="YES"                # Start ipnat function
ipnat_rules="/etc/ipnat.rules"    # rules definition file for ipnat</programlisting>

      <para>Then, to start <application>IPF</application> now:</para>
      
      <programlisting>&prompt.root; <command>service ipfilter start</command></programlisting>
 
    </sect2>

    <sect2>
      <title>IPF Rulesets</title>

      <para>A ruleset contains a group of IPF rules which pass or
	block packets based on the values contained in the packet.
	The bi-directional exchange of packets between hosts comprises
	a session conversation.  The firewall ruleset processes both
	the packets arriving from the public Internet, as well as the
	packets produced by the system as a response to them.
	Each <acronym>TCP/IP</acronym> service is predefined by its
	protocol and listening port.  Packets destined for a specific
	service originate from the source address using an
	unprivileged port and target the specific service port on the
	destination address.  All the above parameters can be used as
	selection criteria to create rules which will pass or block
	services.</para>

      <indexterm>
	<primary><application>IPFILTER</application></primary>

	<secondary>rule processing order</secondary>
      </indexterm>

      <warning>
	<para>When working with the firewall rules, be <emphasis>very
	    careful</emphasis>.  Some configurations <emphasis>can
	  lock the administrator out</emphasis> of the server.  To be
	  on the safe side, consider performing the initial firewall
	  configuration from the local console rather than doing it
	  remotely over <application>ssh</application>.</para>
      </warning>

      <para>To load the ruleset file, use &man.ipf.8;.  Custom rules
	are normally placed in a file, and the following command can
	be used to replace the currently running firewall
	rules:</para>

      <screen>&prompt.root; <userinput>ipf -Fa -f /etc/ipf.rules</userinput></screen>

      <para><option>-Fa</option> flushes all the internal rules
	tables.</para>

      <para><option>-f</option> specifies the file containing the
	rules to load.</para>

      <para>This provides the ability to make changes to a custom
	rules file, run the above IPF command, and thus update the
	running firewall with a fresh copy of the rules without having
	to reboot the system.  This method is convenient for testing
	new rules as the procedure can be executed as many times as
	needed.</para>

      <para>Refer to &man.ipf.8; for details on the other flags
	available with this command.</para>

      <para>&man.ipf.8; expects the rules file to be a standard text
	file.  It will not accept a rules file written as a script
	with symbolic substitution.</para>

      <para>There is a way to build IPF rules that utilize the power
	of script symbolic substitution.  For more information, see
	<xref linkend="firewalls-ipf-rules-script"/>.</para>     

      <indexterm>
	<primary><application>IPFILTER</application></primary>

	<secondary>rule syntax</secondary>
      </indexterm>

      <para>The rule syntax presented here has been simplified to
	only address the modern stateful rule context and <quote>first
	matching rule wins</quote> logic.  For the complete legacy
	rule syntax, refer to &man.ipf.8;.</para>

      <para>A <literal>#</literal> character is used to mark the
	start of a comment and may appear at the end of a rule line
	or on its own line.  Blank lines are ignored.</para>

      <para>Rules contain keywords which must be written in a specific
	order from left to right on the line.  Keywords are identified
	in bold type.  Some keywords have sub-options which may be
	keywords themselves and also include more sub-options.  Each
	of the headings in the below syntax has a bold section header
	which expands on the content.</para>

      <!-- This section is probably wrong. See the OpenBSD flag -->
      <!-- What is the "OpenBSD flag"?  Reference please -->

      <para><replaceable>ACTION IN-OUT OPTIONS SELECTION STATEFUL
	  PROTO SRC_ADDR,DST_ADDR OBJECT PORT_NUM TCP_FLAG
	  STATEFUL</replaceable></para>

      <para>Each keyword and its options are described below.</para>

      <variablelist>
	<varlistentry>
	<term>ACTION</term>
	<listitem>
	<para>The action keyword indicates what to do with the packet
	  if it matches the rest of the filter rule.  Each rule
	  <emphasis>must</emphasis> have an action.  The following
	  actions are recognized:</para>

	<para><literal>block</literal> indicates that the packet
	  should be dropped if the selection parameters match the
	  packet.</para>

	<para><literal>pass</literal> indicates that the packet should
	  exit the firewall if the selection parameters match the
	  packet.</para>
      </listitem>
    </varlistentry>

      <varlistentry>
	<term>IN-OUT</term>
	<listitem>
	<para>A mandatory requirement is that each filter rule
	  explicitly state which side of the I/O it is to be used
	  on.  The next keyword must be either <literal>in</literal>
	  or <literal>out</literal> and one or the other has to be
	  included or the rule will not pass syntax checks.</para>

	<para><literal>in</literal> means this rule is being applied
	  against an inbound packet which has just been received on
	  the interface facing the public Internet.</para>

	<para><literal>out</literal> means this rule is being applied
	  against an outbound packet destined for the interface facing
	  the public Internet.</para>
      </listitem>
    </varlistentry>

      <varlistentry>
	<term>OPTIONS</term>
	<listitem>
	<note>
	  <para>These options must be used in the order shown
	    here.</para>
	</note>

	<para><literal>log</literal> indicates that the packet header
	  will be written to the &man.ipl.4; packet log pseudo-device
	  if the selection parameters match the packet.</para>

	<para><literal>quick</literal> indicates that if the selection
	  parameters match the packet, this rule will be the last
	  rule checked, and no further processing of any following
	  rules will occur for this packet.</para>

	<para><literal>on</literal> indicates the interface name to
	  be incorporated into the selection parameters.  Interface
	  names are as displayed by &man.ifconfig.8;.  Using this
	  option, the rule will only match if the packet is going
	  through that interface in the specified direction.</para>

	<para>When a packet is logged, the headers of the packet are
	  written to the &man.ipl.4; packet logging pseudo-device.
	  Immediately following the <literal>log</literal> keyword,
	  the following qualifiers may be used in this order:</para>

	<para><literal>body</literal> indicates that the first 128
	  bytes of the packet contents will be logged after the
	  headers.</para>

	<para><literal>first</literal>.  If the <literal>log</literal>
	  keyword is being used in conjunction with a <literal>keep
	    state</literal> option, this option is recommended so that
	  only the triggering packet is logged and not every packet
	  which matches the stateful connection.</para>
      </listitem>
    </varlistentry>

      <varlistentry>
	<term>SELECTION</term>
	<listitem>
	<para>The keywords described in this section are used to
	  describe attributes of the packet to be checked when
	  determining whether or not rules match.  There is a
	  keyword subject, and it has sub-option keywords, one of
	  which has to be selected.  The following general-purpose
	  attributes are provided for matching, and must be used in
	  this order:</para>
      </listitem>
    </varlistentry>

      <varlistentry>
	<term>PROTO</term>
	<listitem>
	<para><literal>proto</literal> is the subject keyword which
	  must include one of its corresponding keyword sub-option
	  values.  The sub-option indicates a specific protocol to be
	  matched against.</para>

	<para><literal>tcp/udp | udp | tcp | icmp</literal> or any
	  protocol names found in <filename>/etc/protocols</filename>
	  are recognized and may be used.  The special protocol
	  keyword <literal>tcp/udp</literal> may be used to match
	  either a <acronym>TCP</acronym> or a <acronym>UDP</acronym>
	  packet, and has been added as a convenience to save
	  duplication of otherwise identical rules.</para>
      </listitem>
    </varlistentry>

      <varlistentry>
	<term>SRC_ADDR/DST_ADDR</term>
	<listitem>
	<para>The <literal>all</literal> keyword is equivalent to
	  <quote>from any to any</quote> with no other match
	  parameters.</para>

	<para><literal>from | to src to dst</literal>: the
	  <literal>from</literal> and <literal>to</literal>
	  keywords are used to match against IP addresses.  Rules
	  must specify <emphasis>both</emphasis> the source and
	  destination parameters.  <literal>any</literal> is a special
	  keyword that matches any IP address.  Examples include:
	  <literal>from any to any</literal>, <literal>from 0.0.0.0/0
	    to any</literal>, <literal>from any to
	    0.0.0.0/0</literal>, <literal>from 0.0.0.0 to
	    any</literal>, and <literal>from any to
	    0.0.0.0</literal>.</para>

	<para>There is no way to match ranges of IP addresses which
	  do not express themselves easily using the dotted numeric
	  form / mask-length notation.  The
	  <package>net-mgmt/ipcalc</package> port may be used to ease
	  the calculation.  Additional information is available at the
	  utility's web page: <uri
	    xlink:href="http://jodies.de/ipcalc">http://jodies.de/ipcalc</uri>.</para>
      </listitem>
    </varlistentry>

      <varlistentry>
	<term>PORT</term>
	<listitem>
	<para>If a port match is included, for either or both of
	  source and destination, it is only applied to
	  <acronym>TCP</acronym> and <acronym>UDP</acronym> packets.
	  When composing port comparisons, either the service name
	  from <filename>/etc/services</filename> or an integer port
	  number may be used.  When the port appears as part of the
	  <literal>from</literal> object, it matches the source port
	  number.  When it appears as part of the
	  <literal>to</literal> object, it matches the destination
	  port number.  An example usage is
	  <literal>from any to any port = 80</literal></para>

	<para>Single port comparisons may be done in a number of ways,
	  using a number of different comparison operators.  Instead
	  of the <literal>=</literal> shown in the example above,
	  the following operators may be used: <literal>!=</literal>,
	  <literal>&lt;</literal>, <literal>&gt;</literal>,
	  <literal>&lt;=</literal>, <literal>&gt;=</literal>,
	  <literal>eq</literal>, <literal>ne</literal>,
	  <literal>lt</literal>, <literal>gt</literal>,
	  <literal>le</literal>, and <literal>ge</literal>.</para>

	<para>To specify port ranges, place the two port numbers
	  between <literal>&lt;&gt;</literal> or
	  <literal>&gt;&lt;</literal></para>
      </listitem>
    </varlistentry>

      <varlistentry>
	<term><acronym>TCP</acronym>_FLAG</term>
	<listitem>
	<para>Flags are only effective for <acronym>TCP</acronym>
	  filtering.  The letters represent one of the possible flags
	  that can be matched against the <acronym>TCP</acronym>
	  packet header.</para>

	<para>The modernized rules processing logic uses the
	  <literal>flags S</literal> parameter to identify the TCP
	  session start request.</para>
      </listitem>
    </varlistentry>

      <varlistentry>
	<term>STATEFUL</term>
	<listitem>
	<para><literal>keep state</literal> indicates that on a pass
	  rule, any packets that match the rules selection parameters
	  should activate the stateful filtering facility.</para>
      </listitem>
    </varlistentry>
  </variablelist>
    </sect2>

    <sect2>
      <title>Stateful Filtering</title>

      <indexterm>
	<primary><application>IPFILTER</application></primary>

	<secondary>stateful filtering</secondary>
      </indexterm>

      <!-- XXX: duplicated -->

      <para>Stateful filtering treats traffic as a bi-directional
	exchange of packets comprising a session.  When activated,
	<literal>keep-state</literal> dynamically generates
	internal rules for each anticipated packet being exchanged
	during the session.  It has sufficient matching capabilities
	to determine if a packet is valid for a session.  Any packets
	that do not properly fit the session template are
	automatically rejected.</para>

      <para>IPF stateful filtering will also allow
	<acronym>ICMP</acronym> packets related to an existing
	<acronym>TCP</acronym> or <acronym>UDP</acronym> session.  So,
	if an <acronym>ICMP</acronym> type 3 code 4 packet is a
	response in a session started by a keep state rule, it will
	automatically be allowed.  Any packet that IPF can be certain
	is part of an active session, even if it is a different
	protocol, will be allowed.</para>

      <para>Packets destined to go out through the interface connected
	to the public Internet are first checked against the dynamic
	state table.  If the packet matches the next expected packet
	comprising an active session conversation, it exits the
	firewall and the state of the session conversation flow is
	updated in the dynamic state table.  Packets that do not
	belong to an already active session, are checked against the
	outbound ruleset.</para>

      <para>Packets coming in from the interface connected to the
	public Internet are first checked against the dynamic state
	table.  If the packet matches the next expected packet
	comprising an active session, it exits the firewall and the
	state of the session conversation flow is updated in the
	dynamic state table.  Packets that do not belong to an already
	active session, are checked against the inbound
	ruleset.</para>

      <para>When the session completes, it is removed from the
	dynamic state table.</para>

      <para>Stateful filtering allows one to focus on blocking/passing
	new sessions.  If the new session is passed, all its
	subsequent packets are allowed automatically and any impostor
	packets are automatically rejected.  If a new session is
	blocked, none of its subsequent packets are allowed.  Stateful
	filtering provides advanced matching abilities capable of
	defending against the flood of different attack methods
	employed by attackers.</para>
    </sect2>

    <sect2>
      <!-- XXX: This section needs a rewrite -->

      <title>Inclusive Ruleset Example</title>

      <para>The following ruleset is an example of an inclusive type
	of firewall which only allows services matching
	<literal>pass</literal> rules and blocks all others by
	default.  Network firewalls intended to protect other machines
	should have at least two interfaces, and are generally
	configured to trust the <acronym>LAN</acronym> and to not
	trust the public Internet.  Alternatively, a host based
	firewall might be configured to protect only the system it is
	running on, and is appropriate for servers on an untrusted
	network or a desktop system not protected by firewall on the
	network.</para>

      <para>&os; uses interface <filename>lo0</filename> and IP
	address <systemitem class="ipaddress">127.0.0.1</systemitem>
	for internal communication within the operating system.  The
	firewall rules must contain rules to allow free movement of
	these internally used packets.</para>

      <para>The interface which faces the public Internet is the one
	specified in the rules that authorize and control access of
	the outbound and inbound connections.</para>

      <para>In cases where one or more NICs are cabled to private
	network segments, those interfaces may require rules to allow
	packets originating from those LAN interfaces transit to each
	other or to the Internet.</para>

      <para>The rules should be organized into three major
	sections: the trusted interfaces, then the public
	interface outbound, and lastly, the public untrusted interface
	inbound.</para>

      <para>The rules in each of the public interface sections should
	have the most frequently matched rules placed before less
	commonly matched rules, with the last rule in the section
	blocking and logging all packets on that interface and
	direction.</para>

      <para>The outbound section in the following ruleset only
	contains <literal>pass</literal> rules which uniquely identify
	the services that are authorized for public Internet access.
	All the rules use <literal>quick</literal>,
	<literal>on</literal>, <literal>proto</literal>,
	<literal>port</literal>, and <literal>keep state</literal>.
	The <literal>proto tcp</literal> rules include
	<literal>flag</literal> to identify the session start request
	as the triggering packet to activate the stateful
	facility.</para>

      <para>The inbound section blocks undesirable packets first, for
	two different reasons.  The first is that malicious packets
	may be partial matches for legitimate traffic.  These packets
	have to be discarded rather than allowed, based on their
	partial matches against the <literal>allow</literal> rules.
	The second reason is that known and uninteresting rejects may
	be blocked silently, rather than being logged by the last rule
	in the section.</para>

      <para>The ruleset should ensure that there is no response
	returned for any undesirable traffic.  Invalid packets should
	be silently dropped so that the attacker has no knowledge if
	the packets reached the system.  Rules that include a
	<literal>log first</literal> option, will only log the event
	the first time they are triggered.  This option is included in
	the sample <literal>nmap OS fingerprint</literal> rule.  The
	<package>security/nmap</package> utility is
	commonly used by attackers who attempt to identify the
	operating system of the server.</para>

      <para>Any time there are logged messages on a rule with
	the <literal>log first</literal> option,
	<command>ipfstat -hio</command> should be executed
	to evaluate how many times the rule has been matched.  A
	large number of matches usually indicates that the system is
	being flooded or is under attack.</para>

      <para>To lookup unknown port numbers, refer to
	<filename>/etc/services</filename>.  Alternatively, visit <uri
	  xlink:href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</uri>
	and do a port number lookup to find the purpose of a
	particular port number.</para>

      <para>Check out this link for port numbers used by Trojans <uri
	  xlink:href="http://www.sans.org/security-resources/idfaq/oddports.php">http://www.sans.org/security-resources/idfaq/oddports.php</uri>.</para>

      <para>The following ruleset creates an
	<literal>inclusive</literal> firewall ruleset which can be
	easily customized by commenting out
	<literal>pass</literal> rules for services that should not
	be authorized.</para>

      <para>To avoid logging unwanted messages, add a
	<literal>block</literal> rule in the inbound section.</para>

      <para>Change the <filename>dc0</filename> interface name in
	every rule to the interface name that connects the system to
	the public Internet.</para>

      <para>The following statements were added to
	<filename>/etc/ipf.rules</filename>:</para>

      <programlisting>#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN
#################################################################

#pass out quick on xl0 all
#pass in quick on xl0 all

#################################################################
# No restrictions on Loopback Interface
#################################################################
pass in quick on lo0 all
pass out quick on lo0 all

#################################################################
# Interface facing Public Internet (Outbound Section)
# Match session start requests originating from behind the
# firewall on the private network
# or from this gateway server destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# xxx must be the IP address of your ISP's DNS.
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
pass out quick on dc0 proto tcp from any to xxx port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow out access to my ISP's DHCP server for cable or DSL networks.
# This rule is not needed for 'user ppp' type connection to the
# public Internet, so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state


# Allow out non-secure standard www function
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow out secure www function https over TLS SSL
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow out send &amp; get email function
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow out Time
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow out nntp news
pass out quick on dc0 proto tcp from any to any port = 119 flags S keep state

# Allow out gateway &amp; LAN users' non-secure FTP ( both passive &amp; active modes)
# This function uses the IP<acronym>NAT</acronym> built in FTP proxy function coded in
# the nat rules file to make this single rule function correctly.
# If you want to use the pkg_add command to install application packages
# on your gateway system you need this rule.
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow out ssh/sftp/scp (telnet/rlogin/FTP replacements)
# This function is using SSH (secure shell)
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow out insecure Telnet
pass out quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow out FreeBSD CVSup
pass out quick on dc0 proto tcp from any to any port = 5999 flags S keep state

# Allow out ping to public Internet
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Allow out whois from LAN to public Internet
pass out quick on dc0 proto tcp from any to any port = 43 flags S keep state

# Block and log only the first occurrence of everything
# else that's trying to get out.
# This rule implements the default block
block out log first quick on dc0 all

#################################################################
# Interface facing Public Internet (Inbound Section)
# Match packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

##### Block a bunch of different nasty things. ############
# That I do not want to see in the log

# Block frags
block in quick on dc0 all with frags

# Block short tcp packets
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block nmap OS fingerprint attempts
# Log first occurrence of these so I can get their IP address
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings
block in quick on dc0 proto icmp all icmp-type 8

# Block ident
block in quick on dc0 proto tcp from any to any port = 113

# Block all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP's DHCP server as it is the only
# authorized source to send this packet type. Only necessary for
# cable or DSL configurations. This rule is not needed for
# 'user ppp' type connection to the public Internet.
# This is the same IP address you captured and
# used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow in standard www function because I have apache server
pass in quick on dc0 proto tcp from any to any port = 80 flags S keep state

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID/PW passed over public Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
#pass in quick on dc0 proto tcp from any to any port = 23 flags S keep state

# Allow in secure FTP, Telnet, and SCP from public Internet
# This function is using SSH (secure shell)
pass in quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Block and log only first occurrence of all remaining traffic
# coming into the firewall. The logging of only the first
# occurrence avoids filling up disk with Denial of Service logs.
# This rule implements the default block.
block in log first quick on dc0 all
################### End of rules file #####################################</programlisting>
    </sect2>

    <sect2 xml:id="firewalls-ipf-rules-script">
      <title>Building the Rule Script with Symbolic
	Substitution</title>

      <para>Some experienced IPF users create a file containing the
	rules and code them in a manner compatible with running them
	as a script with symbolic substitution.  The major benefit
	of doing this is that only the value associated with the
	symbolic name needs to be changed, and when the script is
	run all the rules containing the symbolic name will have the
	value substituted in the rules.  Being a script, symbolic
	substitution can be used to code frequently used values and
	substitute them in multiple rules.  This can be seen in the
	following example.</para>

      <para>The script syntax used here is compatible with the
	&man.sh.1;, &man.csh.1;, and &man.tcsh.1; shells.</para>

      <para>Symbolic substitution fields are prefixed with a
	<literal>&dollar;</literal>.</para>

      <para>Symbolic fields do not have the &dollar; prefix.</para>

      <para>The value to populate the symbolic field must be enclosed
	between double quotes (<literal>"</literal>).</para>

      <para>Start the rule file with something like this:</para>

      <programlisting>############# Start of IPF rules script ########################

oif="dc0"            # name of the outbound interface
odns="192.0.2.11"    # ISP's DNS server IP address
myip="192.0.2.7"     # my static IP address from ISP
ks="keep state"
fks="flags S keep state"

# You can choose between building /etc/ipf.rules file
# from this script or running this script "as is".
#
# Uncomment only one line and comment out another.
#
# 1) This can be used for building /etc/ipf.rules:
#cat &gt; /etc/ipf.rules &lt;&lt; EOF
#
# 2) This can be used to run script "as is":
/sbin/ipf -Fa -f - &lt;&lt; EOF

# Allow out access to my ISP's Domain name server.
pass out quick on &dollar;oif proto tcp from any to &dollar;odns port = 53 &dollar;fks
pass out quick on &dollar;oif proto udp from any to &dollar;odns port = 53 &dollar;ks

# Allow out non-secure standard www function
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 80 &dollar;fks

# Allow out secure www function https over TLS SSL
pass out quick on &dollar;oif proto tcp from &dollar;myip to any port = 443 &dollar;fks
EOF
################## End of IPF rules script ########################</programlisting>

      <para>The rules are not important in this example as it instead
	focuses on how the symbolic substitution fields are populated.
	If this example was in a file named
	<filename>/etc/ipf.rules.script</filename>, these rules could
	be reloaded by running:</para>

      <screen>&prompt.root; <userinput>sh /etc/ipf.rules.script</userinput></screen>

      <para>There is one problem with using a rules file with embedded
	symbolics: IPF does not understand symbolic substitution, and
	cannot read such scripts directly.</para>

      <para>This script can be used in one of two ways:</para>

      <itemizedlist>
	<listitem>
	  <para>Uncomment the line that begins with
	    <literal>cat</literal>, and comment out the line that
	    begins with <literal>/sbin/ipf</literal>.  Place
	    <literal>ipfilter_enable="YES"</literal> into
	    <filename>/etc/rc.conf</filename>, and run the script
	    once after each modification to create or update
	    <filename>/etc/ipf.rules</filename>.</para>
	</listitem>

	<listitem>
	  <para>Disable <application>IPFILTER</application> in the system startup scripts by
	    adding <literal>ipfilter_enable="NO"</literal>to
	    <filename>/etc/rc.conf</filename>.</para>

	  <para>Then, add a script like the following to
	    <filename>/usr/local/etc/rc.d/</filename>.  The script
	    should have an obvious name like
	    <filename>ipf.loadrules.sh</filename>, where the
	    <filename>.sh</filename> extension is mandatory.</para>

	  <programlisting>#!/bin/sh
sh /etc/ipf.rules.script</programlisting>

	  <para>The permissions on this script file must be read,
	    write, execute for owner
	    <systemitem class="username">root</systemitem>:</para>

	  <screen>&prompt.root; <userinput>chmod 700 /usr/local/etc/rc.d/ipf.loadrules.sh</userinput></screen>
	</listitem>
      </itemizedlist>

      <para>Now, when the system boots, the IPF rules will be
	loaded.</para>
    </sect2>

    <sect2>
      <title>Configuring <acronym>NAT</acronym></title>

      <indexterm><primary>NAT</primary></indexterm>

      <indexterm>
	<primary>IP masquerading</primary>

	<see>NAT</see>
      </indexterm>

      <indexterm>
	<primary>network address translation</primary>

	<see>NAT</see>
      </indexterm>

      <para><acronym>NAT</acronym> stands for <emphasis>Network
	  Address Translation</emphasis>.  The IPF
	<acronym>NAT</acronym> function enables the private LAN behind
	the firewall to share a single ISP-assigned IP address, even
	if that address is dynamically assigned.  NAT allows each
	computer in the LAN to have Internet access, without
	having to pay the ISP for multiple Internet accounts or IP
	addresses.</para>

	<para>In IPF, when a packet arrives at the firewall from the LAN
	with a public destination, it passes through the outbound
	filter rules.  <acronym>NAT</acronym> gets its turn at the
	packet and applies its rules top down, where the first
	matching rule wins.  <acronym>NAT</acronym> tests each of its
	rules against the packet's interface name and source IP
	address.  When a packet's interface name matches a
	<acronym>NAT</acronym> rule, the packet's source IP address in
	the private LAN is checked to see if it falls within the IP
	address range specified to the left of the arrow symbol on the
	<acronym>NAT</acronym> rule.  On a match, the packet has its
	source IP address rewritten with the public IP address
	obtained by the <literal>0/32</literal> keyword.
	<acronym>NAT</acronym> posts an entry in its internal
	<acronym>NAT</acronym> table so when the packet returns from
	the public Internet it can be mapped back to its original
	private IP address and then passed to the filter rules for
	processing.</para>

	<para><acronym>NAT</acronym> will automatically translate the
	private LAN IP address for each system on the LAN to the
	single public IP address as packets exit the firewall bound
	for the public Internet.  It also performs the reverse
	translation for returning packets.</para>

      <para>According to RFC 1918, the following IP address ranges are
	reserved for private networks which will never be routed
	directly to the public Internet, and therefore are available
	for use with NAT:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>10.0.0.0/8</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>172.16.0.0/12</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>192.168.0.0/16</literal>.</para>
	</listitem>
      </itemizedlist>

      <indexterm><primary><command>ipnat</command></primary></indexterm>

      <para>To enable IP<acronym>NAT</acronym>, add these statements
	to <filename>/etc/rc.conf</filename>.</para>

      <para>To enable the machine to route traffic between
	interfaces:</para>

      <programlisting>gateway_enable="YES"</programlisting>

      <para>To start IP<acronym>NAT</acronym> automatically each
	time:</para>

      <programlisting>ipnat_enable="YES"</programlisting>

      <para>To specify where to load the IP<acronym>NAT</acronym>
	rules from:</para>

      <programlisting>ipnat_rules="/etc/ipnat.rules"</programlisting>

      <para><acronym>NAT</acronym> rules are loaded using
	<command>ipnat</command>.  Typically, the
	<acronym>NAT</acronym> rules are stored in
	<filename>/etc/ipnat.rules</filename>.  See &man.ipnat.8; for
	details.</para>

      <para>When the file containing the <acronym>NAT</acronym> rules
	is edited after <acronym>NAT</acronym> has been started, run
	<command>ipnat</command> with <option>-CF</option> to delete
	the internal in use <acronym>NAT</acronym> rules and flush the
	contents of the translation table of all active
	entries.</para>

      <para>To reload the <acronym>NAT</acronym> rules, issue a
	command like this:</para>

      <screen>&prompt.root; <userinput>ipnat -CF -f
	  /etc/ipnat.rules</userinput></screen>

      <para>To display some <acronym>NAT</acronym> statistics, use
	this command:</para>

      <screen>&prompt.root; <userinput>ipnat -s</userinput></screen>

      <para>To list the <acronym>NAT</acronym> table's current
	mappings, use this command:</para>

      <screen>&prompt.root; <userinput>ipnat -l</userinput></screen>

      <para>To turn verbose mode on and display information relating
	to rule processing and active rules/table entries:</para>

      <screen>&prompt.root; <userinput>ipnat -v</userinput></screen>

      <para><acronym>NAT</acronym> rules are flexible and can
	accomplish many different things to fit the needs of
	commercial and home users.</para>

      <para>The rule syntax presented here has been simplified to
	what is most commonly used in a non-commercial environment.
	For a complete rule syntax description, refer to
	&man.ipnat.5;.</para>

      <para>The syntax for a <acronym>NAT</acronym> rule looks like
	this:</para>

      <programlisting>map <replaceable>IF</replaceable> <replaceable>LAN_IP_RANGE</replaceable> -&gt; <replaceable>PUBLIC_ADDRESS</replaceable></programlisting>

      <para>The keyword <literal>map</literal> starts the rule.</para>

      <para>Replace <replaceable>IF</replaceable> with the external
	interface.</para>

      <para>The <replaceable>LAN_IP_RANGE</replaceable> is used by the
	internal clients use for IP Addressing.  Usually, this is
	something like <systemitem
	  class="ipaddress">192.168.1.0/24</systemitem>.</para>

      <para>The <replaceable>PUBLIC_ADDRESS</replaceable> can either
	be the static external IP address or the special keyword
	<literal>0/32</literal> which uses the IP address assigned to
	<replaceable>IF</replaceable>.</para>

    <sect3>
      <title><acronym>NAT</acronym> for a Large LAN</title>

      <para>For networks that have large numbers of systems on the LAN
	or networks with more than a single LAN, the process of
	funneling all those private IP addresses into a single public
	IP address becomes a resource problem that may cause problems
	with the same port numbers being used many times across many
	connections, causing collisions.  This section describes two ways to
	relieve this resource problem.</para>

	<para>The first method is to assign ports to use.  A normal NAT rule would look like:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32</programlisting>

	<para>In the above rule, the packet's source port is unchanged
	  as the packet passes through IP<acronym>NAT</acronym>.  By
	  adding the <literal>portmap</literal> keyword,
	  IP<acronym>NAT</acronym> can be directed to only use
	  source ports in the specified range.  For example, the
	  following rule will tell IP<acronym>NAT</acronym> to modify
	  the source port to be within the range shown:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</programlisting>

	<para>Additionally, the <literal>auto</literal> keyword tells
	  IP<acronym>NAT</acronym> to determine which ports are
	  available for use:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</programlisting>

	<para>The second method is to use a pool of public addresses.  In very large LANs there comes a point where there are
	  just too many LAN addresses to fit into a single public
	  address.  If a block of public IP addresses is available,
	  these addresses can be used as a <quote>pool</quote>, and
	  IP<acronym>NAT</acronym> may pick one of the public IP
	  addresses as packet addresses are mapped on their way
	  out.</para>

	<para>For example, instead of mapping all packets through a
	  single public IP address:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.1</programlisting>

	<para>A range of public IP addresses can be specified either
	  with a netmask:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0</programlisting>

	<para>or using CIDR notation:</para>

	<programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</programlisting>
      </sect3>

    <sect3>
      <title>Port Redirection</title>

      <para>A common practice is to have a web server, email server,
	database server, and DNS server each segregated to a different
	system on the LAN.  In this case, the traffic from these
	servers still has to undergo <acronym>NAT</acronym>, but there
	has to be some way to direct the inbound traffic to the
	correct server.  For example, a web server operating on LAN
	address <systemitem class="ipaddress">10.0.10.25</systemitem>
	and using a single public IP address of
	<systemitem class="ipaddress">20.20.20.5</systemitem>, would
	use this rule:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>or:</para>

	<programlisting>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</programlisting>

	<para>For a LAN DNS server on a private address of
	  <systemitem class="ipaddress">10.0.10.33</systemitem> that
	  needs to receive public DNS requests:</para>

	<programlisting>rdr dc0 20.20.20.5/32 port 53 -&gt; 10.0.10.33 port 53 udp</programlisting>
    </sect3>

    <sect3>
      <title>FTP and <acronym>NAT</acronym></title>

      <para>FTP has two modes:  active mode and passive mode.  The
	difference is in how the data channel is acquired.  Passive
	mode is more secure as the data channel is acquired by the
	ordinal ftp session requester.  For a good explanation of FTP
	and the different modes, see <uri
	  xlink:href="http://www.slacksite.com/other/ftp.html">http://www.slacksite.com/other/ftp.html</uri>.</para>

	<para>IP<acronym>NAT</acronym> has a built in FTP proxy option
	  which can be specified on the <acronym>NAT</acronym> map
	  rule.  It can monitor all outbound packet traffic for FTP
	  active or passive start session requests and dynamically
	  create temporary filter rules containing the port number
	  being used by the data channel.  This eliminates the
	  security risk FTP normally exposes the firewall to as it no
	  longer needs to open large ranges of high order ports for
	  FTP connections.</para>

	<para>This rule will handle all the traffic for the internal
	  LAN:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>This rule handles the FTP traffic from the
	  gateway:</para>

	<programlisting>map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp</programlisting>

	<para>This rule handles all non-FTP traffic from the internal
	  LAN:</para>

	<programlisting>map dc0 10.0.10.0/29 -&gt; 0/32</programlisting>

	<para>The FTP <literal>map</literal> rules go before the
	  <acronym>NAT</acronym> rule so that when a packet matches an
	  FTP rule, the FTP proxy creates temporary filter rules to
	  let the FTP session packets pass and undergo
	  <acronym>NAT</acronym>.  All LAN packets that are not FTP
	  will not match the FTP rules but will undergo
	  <acronym>NAT</acronym> if they match the third rule.</para>

	<para>Only one filter rule is needed for FTP if the
	  <acronym>NAT</acronym> FTP proxy is used.</para>

	<para>Without the FTP proxy, the following three rules will be
	  needed:</para>

	<programlisting># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>IPFSTAT</title>

      <indexterm><primary><command>ipfstat</command></primary></indexterm>

      <indexterm>
	<primary><application>IPFILTER</application></primary>

	<secondary>statistics</secondary>
      </indexterm>

      <para>The default behavior of &man.ipfstat.8; is to retrieve
	and display the totals of the accumulated statistics gathered
	by applying the rules against packets going in and out of the
	firewall since it was last started, or since the last time the
	accumulators were reset to zero using <command>ipf
	  -Z</command>.</para>

      <para>Refer to &man.ipfstat.8; for details.</para>

      <para>The default &man.ipfstat.8; output will look something
	like this:</para>

      <screen>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state(in): kept 0 lost 0
 fragment state(out): kept 0 lost 0
 packet state(in): kept 169364 lost 0
 packet state(out): kept 431395 lost 0
 ICMP replies: 0 <acronym>TCP</acronym> RSTs sent: 0
 Result cache hits(in): 1215208 (out): 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 <acronym>TCP</acronym> cksum fails(in): 0 (out): 0
 Packet log flags set: (0)</screen>

      <para>When supplied with either <option>-i</option> for inbound
	or <option>-o</option> for outbound, the command will retrieve
	and display the appropriate list of filter rules currently
	installed and in use by the kernel.</para>

      <para><command>ipfstat -in</command> displays the inbound
	internal rules table with rule numbers.</para>

      <para><command>ipfstat -on</command> displays the outbound
	internal rules table with rule numbers.</para>

      <para>The output will look something like this:</para>

      <screen>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para><command>ipfstat -ih</command> displays the inbound
	internal rules table, prefixing each rule with a count of how
	many times the rule was matched.</para>

      <para><command>ipfstat -oh</command> displays the outbound
	internal rules table, prefixing each rule with a count of how
	many times the rule was matched.</para>

      <para>The output will look something like this:</para>

      <screen>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>One of the most important options of
	<command>ipfstat</command> is <option>-t</option> which
	displays the state table in a way similar to how &man.top.1;
	shows the &os; running process table.  When a firewall is
	under attack, this function provides the ability to identify
	and see the attacking packets.  The optional sub-flags give
	the ability to select the destination or source IP, port, or
	protocol to be monitored in real time.  Refer to
	&man.ipfstat.8; for details.</para>
    </sect2>

    <sect2>
      <title>IPMON</title>

      <indexterm><primary><command>ipmon</command></primary></indexterm>

      <indexterm>
	<primary><application>IPFILTER</application></primary>

	<secondary>logging</secondary>
      </indexterm>

      <para>In order for <command>ipmon</command> to work properly,
	the kernel option <literal>IPFILTER_LOG</literal> must be
	turned on.  This command has two different modes.  Native mode
	is the default mode when the command is used without
	<option>-D</option>.</para>

      <para>Daemon mode provides a continuous system log file so that
	logging of past events may be reviewed.  &os; has a built in
	facility to automatically rotate system logs.  This is why
	outputting the log information to &man.syslogd.8; is better
	than the default of outputting to a regular file.  The default
	<filename>rc.conf</filename>
	<literal>ipmon_flags</literal> statement uses
	<option>-Ds</option>:</para>

      <programlisting>ipmon_flags="-Ds" # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</programlisting>

      <para>Logging provides the ability to review, after the fact,
	information such as which packets were dropped, what addresses
	they came from and where they were going.  These can all
	provide a significant edge in tracking down attackers.</para>

      <para>Even with the logging facility enabled, IPF will not
	generate any rule logging by default.  The firewall
	administrator decides which rules in the ruleset should be
	logged and adds the log keyword to those rules.  Normally,
	only deny rules are logged.</para>

      <para>It is customary to include a <quote>default deny
	  everything</quote> rule with the log keyword included as the
	last rule in the ruleset.  This makes it possible to see all
	the packets that did not match any of the rules in the
	ruleset.</para>

      <para>&man.syslogd.8; uses its own method for segregation of log
	data.  It uses groupings called <quote>facility</quote> and
	<quote>level</quote>.  By default, IPMON in
	<option>-Ds</option> mode uses <literal>local0</literal> as
	the <quote>facility</quote> name.  The following levels can be
	used to further segregate the logged data:</para>

      <screen>LOG_INFO - packets logged using the "log" keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short</screen>

      <!-- XXX: "can be considered short" == "with incomplete header" -->

      <para>In order to setup <application>IPFILTER</application> to log all data to
	<filename>/var/log/ipfilter.log</filename>, first
	create the empty file:</para>

       <screen>&prompt.root; <userinput>touch /var/log/ipfilter.log</userinput></screen>

      <para>&man.syslogd.8; is controlled by definition statements in
	<filename>/etc/syslog.conf</filename>.  This file offers
	considerable flexibility in how
	<application>syslog</application> will deal with system
	messages issued by software applications like IPF.</para>

      <para>To write all logged messages to the specified file,
	add the following statement to
	<filename>/etc/syslog.conf</filename>:</para>

      <programlisting>local0.* /var/log/ipfilter.log</programlisting>

      <para>To activate the changes and instruct &man.syslogd.8;
	to read the modified <filename>/etc/syslog.conf</filename>,
	run <command>service syslogd reload</command>.</para>

      <para>Do not forget to change
	<filename>/etc/newsyslog.conf</filename> to rotate the new
	log file.</para>

      <para>Messages generated by <command>ipmon</command> consist
	of data fields separated by white space.  Fields common to
	all messages are:</para>

      <orderedlist>
	<listitem>
	  <para>The date of packet receipt.</para>
	</listitem>

	<listitem>
	  <para>The time of packet receipt.  This is in the form
	    HH:MM:SS.F, for hours, minutes, seconds, and fractions
	    of a second.</para>
	</listitem>

	<listitem>
	  <para>The name of the interface that processed the
	    packet.</para>
	</listitem>

	<listitem>
	  <para>The group and rule number of the rule in the format
	    <literal>@0:17</literal>.</para>
	</listitem>
      </orderedlist>

      <para>These can be viewed with
	<command>ipfstat -in</command>.</para>

      <orderedlist>
	<listitem>
	  <para>The action: <literal>p</literal> for passed,
	    <literal>b</literal> for blocked, <literal>S</literal> for
	    a short packet, <literal>n</literal> did not match any
	    rules, and <literal>L</literal> for a log rule.  The order
	    of precedence in showing flags is: <literal>S</literal>,
	    <literal>p</literal>, <literal>b</literal>,
	    <literal>n</literal>, <literal>L</literal>.  A capital
	    <literal>P</literal> or <literal>B</literal> means that
	    the packet has been logged due to a global logging
	    setting, not a particular rule.</para>
	</listitem>

	<listitem>
	  <para>The addresses written as three fields: the source
	    address and port separated by a comma, the -&gt; symbol,
	    and the destination address and port.  For example:
	    <literal>209.53.17.22,80 -&gt;
	      198.73.220.17,1722</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>PR</literal> followed by the protocol name
	    or number: for example, <literal>PR tcp</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>len</literal> followed by the header length
	    and total length of the packet: for example,
	    <literal>len 20 40</literal>.</para>
	</listitem>
      </orderedlist>

      <para>If the packet is a <acronym>TCP</acronym> packet, there
	will be an additional field starting with a hyphen followed by
	letters corresponding to any flags that were set.  Refer to
	&man.ipf.5; for a list of letters and their flags.</para>

      <para>If the packet is an ICMP packet, there will be two fields
	at the end:  the first always being <quote>ICMP</quote> and
	the next being the ICMP message and sub-message type,
	separated by a slash.  For example:  ICMP 3/3 for a port
	unreachable message.</para>
      </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipfw">
    <title>IPFW</title>

    <indexterm>
      <primary>firewall</primary>

      <secondary>IPFW</secondary>
    </indexterm>

    <para><acronym>IPFW</acronym> is a stateful firewall written for
      &os; which also provides a traffic shaper, packet scheduler,
      and in-kernel NAT.</para>

    <para>&os; provides a sample ruleset in
      <filename>/etc/rc.firewall</filename>.  The sample ruleset
      define several firewall types for common scenarios to assist
      novice users in generating an appropriate ruleset.
      &man.ipfw.8; provides a powerful syntax which advanced users can
      use to craft customized rulesets that meet the security
      requirements of a given environment.</para>

    <para>IPFW is composed of several components:  the kernel firewall
      filter rule processor and its integrated packet accounting
      facility, the logging facility, the
      <literal>divert</literal> rule which triggers
      <acronym>NAT</acronym>, the dummynet traffic shaper facilities,
      the <literal>fwd rule</literal> forward facility, the bridge
      facility, and the ipstealth facility.  IPFW supports both IPv4
      and IPv6.</para>

    <sect2 xml:id="firewalls-ipfw-enable">
      <title>Enabling IPFW</title>

      <indexterm>
	<primary>IPFW</primary>

	<secondary>enabling</secondary>
      </indexterm>

      <para>IPFW is included in the basic &os; install as a run time
	loadable module.  The system will dynamically load the kernel
	module when <filename>rc.conf</filename> contains the
	statement <literal>firewall_enable="YES"</literal>.  After
	rebooting the system, the following white highlighted message
	is displayed on the screen as part of the boot process:</para>

      <screen>ipfw2 initialized, divert disabled, rule-based forwarding disabled, default to deny, logging disabled</screen>

      <para>The loadable module includes logging ability.  To enable
	logging and set the verbose logging limit, add these
	statements to
	<filename>/etc/sysctl.conf</filename> before rebooting:</para>

      <programlisting>net.inet.ip.fw.verbose=1
net.inet.ip.fw.verbose_limit=5</programlisting>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-kernel">
      <title>Kernel Options</title>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFIREWALL</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFIREWALL_VERBOSE</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFIREWALL_VERBOSE_LIMIT</secondary>
      </indexterm>

      <indexterm>
	<primary>IPFW</primary>

	<secondary>kernel options</secondary>
      </indexterm>

      <para>For those users who wish to statically compile kernel
	IPFW support, the following options are available for the
	custom kernel configuration file:</para>

      <programlisting>options    IPFIREWALL</programlisting>

      <para>This option enables IPFW as part of the kernel.</para>

      <programlisting>options    IPFIREWALL_VERBOSE</programlisting>

      <para>This option enables logging of packets that pass through
	IPFW and have the <literal>log</literal> keyword specified in
	the ruleset.</para>

      <programlisting>options    IPFIREWALL_VERBOSE_LIMIT=5</programlisting>

      <para>This option limits the number of packets logged through
	&man.syslogd.8;, on a per-entry basis.  This option may be
	used in hostile environments, when firewall activity logging
	is desired.  This will close a possible denial of service
	attack via syslog flooding.</para>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPFIREWALL_DEFAULT_TO_ACCEPT</secondary>
      </indexterm>

      <programlisting>options    IPFIREWALL_DEFAULT_TO_ACCEPT</programlisting>

      <para>This option allows everything to pass through the firewall
	by default, which is a good idea when the firewall is being
	set up for the first time.</para>

      <indexterm>
	<primary>kernel options</primary>

	<secondary>IPDIVERT</secondary>
      </indexterm>

      <programlisting>options    IPDIVERT</programlisting>

      <para>This option enables the use of <acronym>NAT</acronym>
	functionality.</para>

      <note>
	<para>The firewall will block all incoming and outgoing
	  packets if either the
	  <literal>IPFIREWALL_DEFAULT_TO_ACCEPT</literal> kernel
	  option or a rule to explicitly allow these connections is
	  missing.</para>
      </note>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-rc">
      <title><filename>/etc/rc.conf</filename> Options</title>

      <para>Enables the firewall:</para>

      <programlisting>firewall_enable="YES"</programlisting>

      <para>To select one of the default firewall types provided by
	&os;, select one by reading
	<filename>/etc/rc.firewall</filename> and specify it in
	the following:</para>

      <programlisting>firewall_type="open"</programlisting>

      <para>Available values for this setting are:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>open</literal>: passes all traffic.</para>
	</listitem>
	<listitem>
	  <para><literal>client</literal>: protects only this
	    machine.</para>
	</listitem>
	<listitem>
	  <para><literal>simple</literal>: protects the whole
	    network.</para>
	</listitem>
	<listitem>
	  <para><literal>closed</literal>: entirely disables IP
	    traffic except for the loopback interface.</para>
	</listitem>
	<listitem>
	  <para><literal>UNKNOWN</literal>: disables the loading of
	    firewall rules.</para>
	</listitem>
	<listitem>
	  <para><filename>filename</filename>:
	    absolute path of the file containing the firewall
	    rules.</para>
	</listitem>
      </itemizedlist>

      <para>Two methods are available for loading custom
	<application>ipfw</application> rules.  One is to set the
	<literal>firewall_type</literal> variable to the absolute
	path of the file which contains the firewall rules.</para>

      <para>The other method is to set the
	<literal>firewall_script</literal> variable to the absolute
	path of an executable script that includes
	<command>ipfw</command> commands.  A ruleset script that
	blocks all incoming and outgoing traffic would look like
	this:</para>

      <programlisting>#!/bin/sh

ipfw -q flush

ipfw add deny in
ipfw add deny out</programlisting>

      <note>
	<para>If <literal>firewall_type</literal> is set to either
	  <literal>client</literal> or <literal>simple</literal>,
	  modify the default rules found in
	  <filename>/etc/rc.firewall</filename> to fit the
	  configuration of the system.  The examples used in this
	  section assume that the <literal>firewall_script</literal>
	  is set to <filename>/etc/ipfw.rules</filename>.</para>
      </note>

      <para>Enable logging:</para>

      <programlisting>firewall_logging="YES"</programlisting>

      <warning>
	<para><varname>firewall_logging</varname> sets the
	  <varname>net.inet.ip.fw.verbose</varname> sysctl
	  variable to the value of <literal>1</literal>.  There is no
	  <filename>rc.conf</filename> variable to set log
	  limitations, but the desired value can be set using
	  <command>sysctl</command> or by adding the following
	  variable and desired value to
	  <filename>/etc/sysctl.conf</filename>:</para>

	<programlisting>net.inet.ip.fw.verbose_limit=5</programlisting>
      </warning>

      <para>If the machine is acting as a gateway providing
	<acronym>NAT</acronym> using &man.natd.8;,
	refer to <xref linkend="network-natd"/> for information
	regarding the required <filename>/etc/rc.conf</filename>
	options.</para>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-cmd">
      <title>The IPFW Command</title>

      <indexterm><primary><command>ipfw</command></primary></indexterm>

      <para><command>ipfw</command> can be used to make manual,
	single rule additions or deletions to the active firewall
	while it is running.  The problem with using this method is
	that all the changes are lost when the system reboots.  It is
	recommended to instead write all the rules in a file and to
	use that file to load the rules at boot time and to replace
	the currently running firewall rules whenever that file
	changes.</para>

      <para><command>ipfw</command> is a useful way to display the
	running firewall rules to the console screen.  The IPFW
	accounting facility dynamically creates a counter for each
	rule that counts each packet that matches the rule.  During
	the process of testing a rule, listing the rule with its
	counter is one way to determine if the rule is
	functioning as expected.</para>

      <para>To list all the running rules in sequence:</para>

      <screen>&prompt.root; <userinput>ipfw list</userinput></screen>

      <para>To list all the running rules with a time stamp of when
	the last time the rule was matched:</para>

      <screen>&prompt.root; <userinput>ipfw -t list</userinput></screen>

      <para>The next example lists accounting information and the
	packet count for matched rules along with the rules
	themselves.  The first column is the rule number, followed by
	the number of matched packets and bytes, followed by the rule
	itself.</para>

      <screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

      <para>To list dynamic rules in addition to static rules:</para>

      <screen>&prompt.root; <userinput>ipfw -d list</userinput></screen>

      <para>To also show the expired dynamic rules:</para>

      <screen>&prompt.root; <userinput>ipfw -d -e list</userinput></screen>

      <para>To zero the counters:</para>

      <screen>&prompt.root; <userinput>ipfw zero</userinput></screen>

      <para>To zero the counters for just the rule with number
	<replaceable>NUM</replaceable>:</para>

      <screen>&prompt.root; <userinput>ipfw zero NUM</userinput></screen>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-rules">
      <title>IPFW Rulesets</title>

      <indexterm>
	<primary>IPFW</primary>

	<secondary>rule processing order</secondary>
      </indexterm>

      <para>When a packet enters the <acronym>IPFW</acronym> firewall,
	it is compared against the first rule in the ruleset and
	progresses one rule at a time, moving from top to bottom of
	the set in ascending rule number sequence order.  When the
	packet matches the selection parameters of a rule, the rule's
	action field value is executed and the search of the ruleset
	terminates for that packet.  This is referred to as
	<quote>first match wins</quote>.  If the packet does not match
	any of the rules, it gets caught by the mandatory IPFW default
	rule, number 65535, which denies all packets and silently
	discards them.  However, if the packet matches a rule that
	contains the <literal>count</literal>,
	<literal>skipto</literal>, or <literal>tee</literal> keywords,
	the search continues.  Refer to &man.ipfw.8; for details on
	how these keywords affect rule processing.</para>

      <para>The examples in this section create an inclusive type
	firewall ruleset containing the stateful <literal>keep
	  state</literal>, <literal>limit</literal>,
	<literal>in</literal>, <literal>out</literal> and
	<literal>via</literal> options.  For a complete rule syntax
	description, refer to &man.ipfw.8;.</para>

      <warning>
	<para>Be careful when working with firewall rules, as it is
	  easy to lock out even the administrator.</para>
      </warning>

      <sect3 xml:id="firewalls-ipfw-rules-syntax">
	<title>Rule Syntax</title>

	<indexterm>
	  <primary>IPFW</primary>

	  <secondary>rule syntax</secondary>
	</indexterm>

	<para>This section describes the keywords which comprise an
	  <acronym>IPFW</acronym> rule.  Keywords must be written in
	  the following order.  <literal>#</literal> is used to mark
	  the start of a comment and may appear at the end of a rule
	  line or on its own line.  Blank lines are ignored.</para>

	<para><replaceable>CMD RULE_NUMBER ACTION LOGGING SELECTION
	    STATEFUL</replaceable></para>

	<sect4>
	  <title>CMD</title>

	  <para>Each new rule has to be prefixed with
	    <parameter>add</parameter> to add the rule to the internal
	    table.</para>
	</sect4>

	<sect4>
	  <title>RULE_NUMBER</title>

	  <para>Each rule is associated with a rule_number in the
	    range of <literal>1</literal> to
	    <literal>65535</literal>.</para>
	</sect4>

	<sect4>
	  <title>ACTION</title>

	  <para>A rule can be associated with one of the following
	    actions.  The specified action will be executed when the
	    packet matches the selection criterion of the rule.</para>

	  <para><parameter>allow | accept | pass |
	      permit</parameter></para>

	  <para>These keywords are equivalent as they allow packets
	    that match the rule to exit the firewall rule processing.
	    The search terminates at this rule.</para>

	  <para><parameter>check-state</parameter></para>

	  <para>Checks the packet against the dynamic rules table.
	    If a match is found, execute the action associated with
	    the rule which generated this dynamic rule, otherwise
	    move to the next rule.  A <literal>check-state</literal>
	    rule does not have selection criterion.  If no
	    <literal>check-state</literal> rule is present in the
	    ruleset, the dynamic rules table is checked at the first
	    <literal>keep-state</literal> or <literal>limit</literal>
	    rule.</para>

	  <para><parameter>deny | drop</parameter></para>

	  <para>Both words mean the same thing, which is to discard
	    packets that match this rule.  The search
	    terminates.</para>
	</sect4>

	<sect4>
	  <title>Logging</title>

	  <para>When a packet matches a rule with the
	    <literal>log</literal> keyword, a message will be logged
	    to &man.syslogd.8; with a facility name of
	    <literal>SECURITY</literal>.  Logging only occurs if the
	    number of packets logged for that particular rule does not
	    exceed the <literal>logamount</literal> parameter.  If no
	    <literal>logamount</literal> is specified, the limit is
	      taken from the <command>sysctl</command> value of
	    <varname>net.inet.ip.fw.verbose_limit</varname>.  In both
	    cases, a value of zero removes the logging limit.  Once
	    the limit is reached, logging can be re-enabled by
	    clearing the logging counter or the packet counter for
	    that rule, using <command>ipfw reset log</command>.</para>

	  <note>
	    <para>Logging is done after all other packet matching
	      conditions have been met, and before performing the
	      final action on the packet.  The administrator decides
	      which rules to enable logging on.</para>
	  </note>
	</sect4>

	<sect4>
	  <title>Selection</title>

	  <para>The keywords described in this section are used to
	    describe attributes of the packet to be checked when
	    determining whether rules match the packet or not.
	    The following general-purpose attributes are provided for
	    matching, and must be used in this order:</para>

	  <para><parameter>udp | tcp | icmp</parameter></para>

	  <para>Any other protocol names found in
	    <filename>/etc/protocols</filename> can be used.  The
	    value specified is the protocol to be matched against.
	    This is a mandatory keyword.</para>

	  <para><parameter>from src to dst</parameter></para>

	  <para>The <literal>from</literal> and <literal>to</literal>
	    keywords are used to match against IP addresses.  Rules
	    must specify <emphasis>both</emphasis> source and
	    destination parameters.  <literal>any</literal> is a
	    special keyword that matches any IP address.
	    <literal>me</literal> is a special keyword that matches
	    any IP address configured on an interface in the &os;
	    system to represent the PC the firewall is running on.
	    Example usage includes <literal>from me to any</literal>,
	    <literal>from any to me</literal>,
	    <literal>from 0.0.0.0/0 to any</literal>,
	    <literal>from any to 0.0.0.0/0</literal>,
	    <literal>from 0.0.0.0 to any</literal>,
	    <literal>from any to 0.0.0.0</literal>,
	    and <literal>from me to 0.0.0.0</literal>.  IP addresses
	    are specified in dotted IP address format followed by the
	    mask in CIDR notation, or as a single host in dotted IP
	    address format.  This keyword is a mandatory requirement.
	    The <package>net-mgmt/ipcalc</package> port may be used to
	    assist the mask calculation.</para>

	  <para><parameter>port number</parameter></para>

	  <para>For protocols which support port numbers, such as
	    <acronym>TCP</acronym> and <acronym>UDP</acronym>, it
	    is mandatory to include the port number of the service
	    that will be matched.  Service names from
	    <filename>/etc/services</filename> may be used instead
	    of numeric port values.</para>

	  <para><parameter>in | out</parameter></para>

	  <para>Matches incoming or outgoing packets.  It is mandatory
	    that one or the other is included as part of the rule
	    matching criterion.</para>

	  <para><parameter>via IF</parameter></para>

	  <para>Matches packets going through the interface specified
	    by device name.  The <literal>via</literal> keyword causes
	    the interface to always be checked as part of the match
	    process.</para>

	  <para><parameter>setup</parameter></para>

	  <para>This mandatory keyword identifies the session start
	    request for <acronym>TCP</acronym> packets.</para>

	  <para><parameter>keep-state</parameter></para>

	  <para>This is a mandatory keyword.  Upon a match, the
	    firewall will create a dynamic rule, whose default
	    behavior is to match bidirectional traffic between source
	    and destination IP/port using the same protocol.</para>

	  <para><parameter>limit {src-addr | src-port | dst-addr |
	      dst-port}</parameter></para>

	  <para>The firewall will only allow
	    <replaceable>N</replaceable> connections with the same
	    set of parameters as specified in the rule.  One or more
	    of source and destination addresses and ports can be
	    specified.  <literal>limit</literal> and
	    <literal>keep-state</literal> can not be used on the same
	    rule as they provide the same stateful function.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Stateful Rule Option</title>

	<indexterm>
	  <primary>IPFW</primary>

	  <secondary>stateful filtering</secondary>
	</indexterm>

	<para>The <literal>check-state</literal> option is used to
	  identify where in the IPFW ruleset the packet is to be
	  tested against the dynamic rules facility.  On a match, the
	  packet exits the firewall to continue on its way and a new
	  rule is dynamically created for the next anticipated packet
	  being exchanged during this session.  On a no match, the
	  packet advances to the next rule in the ruleset for
	  testing.</para>

	<para>The dynamic rules facility is vulnerable to resource
	  depletion from a SYN-flood attack which would open a huge
	  number of dynamic rules.  To counter this type of attack
	  with  <acronym>IPFW</acronym>, use <literal>limit</literal>.
	  This keyword limits the number of simultaneous sessions by
	  checking that rule's source or destinations fields and using
	  the packet's IP address in a search of the open dynamic
	  rules, counting the number of times this rule and IP address
	  combination occurred.  If this count is greater than the
	  value specified by <literal>limit</literal>, the packet is
	  discarded.</para>
      </sect3>

      <sect3>
	<title>Logging Firewall Messages</title>

	<indexterm>
	  <primary>IPFW</primary>

	  <secondary>logging</secondary>
	</indexterm>

	<para>Even with the logging facility enabled, IPFW will not
	  generate any rule logging on its own.  The firewall
	  administrator decides which rules in the ruleset will be
	  logged, and adds the <literal>log</literal> keyword to those
	  rules.  Normally only deny rules are logged.  It is
	  customary to duplicate the <quote>ipfw default deny
	    everything</quote> rule with the <literal>log</literal>
	  keyword included as the last rule in the ruleset.  This
	  way, it is possible to see all the packets that did not
	  match any of the rules in the ruleset.</para>

	<para>Logging is a two edged sword.  If one is not careful,
	  an over abundance of log data or a DoS attack can fill the
	  disk with log files.  Log messages are not only written to
	  <application>syslogd</application>, but also are displayed
	  on the root console screen and soon become annoying.</para>

	<para>The <literal>IPFIREWALL_VERBOSE_LIMIT=5</literal>
	  kernel option limits the number of consecutive messages
	  sent to &man.syslogd.8;, concerning the packet matching of a
	  given rule.  When this option is enabled in the kernel, the
	  number of consecutive messages concerning a particular rule
	  is capped at the number specified.  There is nothing to be
	  gained from 200 identical log messages.  With this option
	  set to five,
	  five consecutive messages concerning a particular rule
	  would be logged to <application>syslogd</application> and
	  the remainder identical consecutive messages would be
	  counted and posted to <application>syslogd</application>
	  with a phrase like the following:</para>

	<programlisting>last message repeated 45 times</programlisting>

	<para>All logged packets messages are written by default to
	  <filename>/var/log/security</filename>, which is
	  defined in <filename>/etc/syslog.conf</filename>.</para>
      </sect3>

      <sect3 xml:id="firewalls-ipfw-rules-script">
	<title>Building a Rule Script</title>

	<para>Most experienced IPFW users create a file containing
	  the rules and code them in a manner compatible with running
	  them as a script.  The major benefit of doing this is the
	  firewall rules can be refreshed in mass without the need
	  of rebooting the system to activate them.  This method is
	  convenient in testing new rules as the procedure can
	  be executed as many times as needed.  Being a script,
	  symbolic substitution can be used for frequently used
	  values to be substituted into multiple rules.</para>

	<para>This example script is compatible with the syntax used
	  by the &man.sh.1;,  &man.csh.1;, and &man.tcsh.1; shells.
	  Symbolic substitution fields are prefixed with a dollar sign
	  (&dollar;).  Symbolic fields do not have the &dollar;
	  prefix.  The value to populate the symbolic field must be
	  enclosed in double quotes ("").</para>

	<para>Start the rules file like this:</para>

	<programlisting>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif="tun0"             # out interface
odns="192.0.2.11"      # ISP's DNS server IP address
cmd="ipfw -q add "     # build rule prefix
ks="keep-state"        # just too lazy to key this each time
&dollar;cmd 00500 check-state
&dollar;cmd 00502 deny all from any to any frag
&dollar;cmd 00501 deny tcp from any to any established
&dollar;cmd 00600 allow tcp from any to any 80 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00610 allow tcp from any to &dollar;odns 53 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00611 allow udp from any to &dollar;odns 53 out via &dollar;oif &dollar;ks
################### End of example ipfw rules script ############</programlisting>

	<para>The rules are not important as the focus of this example
	  is how the symbolic substitution fields are
	  populated.</para>

	<para>If the above example was in
	  <filename>/etc/ipfw.rules</filename>, the rules could be
	  reloaded by the following command:</para>

	<screen>&prompt.root; <userinput>sh /etc/ipfw.rules</userinput></screen>

	<para><filename>/etc/ipfw.rules</filename> can be located
	  anywhere and the file can have any name.</para>

	<para>The same thing could be accomplished by running these
	  commands by hand:</para>

	<screen>&prompt.root; <userinput>ipfw -q -f flush</userinput>
&prompt.root; <userinput>ipfw -q add check-state</userinput>
&prompt.root; <userinput>ipfw -q add deny all from any to any frag</userinput>
&prompt.root; <userinput>ipfw -q add deny tcp from any to any established</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</userinput></screen>
      </sect3>

      <sect3>
	<title>An Example Stateful Ruleset</title>

	<para>The following sample ruleset is a complete inclusive
	  type ruleset.  Comment out any
	  <literal>pass</literal> rules for services that are not
	  required.  To avoid logging undesired messages, add a
	  <literal>deny</literal> rule in the inbound section.
	  Change the <filename>dc0</filename> in every rule to the
	  device name of the interface that connects the system to the
	  Internet.</para>

	<para>There is a noticeable pattern in the usage of these
	  rules.</para>

	<itemizedlist>
	  <listitem>
	    <para>All statements that are a request to start a session
	      to the Internet use
	      <literal>keep-state</literal>.</para>
	  </listitem>

	  <listitem>
	    <para>All the authorized services that originate from
	      the Internet use <literal>limit</literal> to prevent
	      flooding.</para>
	  </listitem>

	  <listitem>
	    <para>All rules use <literal>in</literal> or
	      <literal>out</literal> to clarify direction.</para>
	  </listitem>

	  <listitem>
	    <para>All rules use <literal>via</literal>
	      <replaceable>interface-name</replaceable> to specify
	      the interface the packet is traveling over.</para>
	  </listitem>
	</itemizedlist>

	<para>The following rules go into
	  <filename>/etc/ipfw.rules</filename>:</para>

	<programlisting>################ Start of IPFW rules file ###############################
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
pif="dc0"     # public interface name of NIC
              # facing the public Internet

#################################################################
# No restrictions on Inside LAN Interface for private network
# Not needed unless you have LAN.
# Change xl0 to your LAN NIC interface name
#################################################################
#&dollar;cmd 00005 allow all from any to any via xl0

#################################################################
# No restrictions on Loopback Interface
#################################################################
&dollar;cmd 00010 allow all from any to any via lo0

#################################################################
# Allow the packet through if it has previous been added to the
# the "dynamic" rules table by a allow keep-state statement.
#################################################################
&dollar;cmd 00015 check-state

#################################################################
# Interface facing Public Internet (Outbound Section)
# Interrogate session start requests originating from behind the
# firewall on the private network or from this gateway server
# destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# x.x.x.x must be the IP address of your ISP.s DNS
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
&dollar;cmd 00110 allow tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state
&dollar;cmd 00111 allow udp from any to x.x.x.x 53 out via &dollar;pif keep-state

# Allow out access to my ISP's DHCP server for cable/DSL configurations.
# This rule is not needed for .user ppp. connection to the public Internet.
# so you can delete this whole group.
# Use the following rule and check log for IP address.
# Then put IP address in commented out rule &amp; delete first rule
&dollar;cmd 00120 allow log udp from any to any 67 out via &dollar;pif keep-state
#&dollar;cmd 00120 allow udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Allow out non-secure standard www function
&dollar;cmd 00200 allow tcp from any to any 80 out via &dollar;pif setup keep-state

# Allow out secure www function https over TLS SSL
&dollar;cmd 00220 allow tcp from any to any 443 out via &dollar;pif setup keep-state

# Allow out send &amp; get email function
&dollar;cmd 00230 allow tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 00231 allow tcp from any to any 110 out via &dollar;pif setup keep-state

# Allow out FBSD (make install &amp; CVSUP) functions
# Basically give user root "GOD" privileges.
&dollar;cmd 00240 allow tcp from me to any out via &dollar;pif setup keep-state uid root

# Allow out ping
&dollar;cmd 00250 allow icmp from any to any out via &dollar;pif keep-state

# Allow out Time
&dollar;cmd 00260 allow tcp from any to any 37 out via &dollar;pif setup keep-state

# Allow out nntp news (i.e., news groups)
&dollar;cmd 00270 allow tcp from any to any 119 out via &dollar;pif setup keep-state

# Allow out secure FTP, Telnet, and SCP
# This function is using SSH (secure shell)
&dollar;cmd 00280 allow tcp from any to any 22 out via &dollar;pif setup keep-state

# Allow out whois
&dollar;cmd 00290 allow tcp from any to any 43 out via &dollar;pif setup keep-state

# deny and log everything else that.s trying to get out.
# This rule enforces the block all by default logic.
&dollar;cmd 00299 deny log all from any to any out via &dollar;pif

#################################################################
# Interface facing Public Internet (Inbound Section)
# Check packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 00300 deny all from 192.168.0.0/16 to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 00301 deny all from 172.16.0.0/12 to any in via &dollar;pif     #RFC 1918 private IP
&dollar;cmd 00302 deny all from 10.0.0.0/8 to any in via &dollar;pif          #RFC 1918 private IP
&dollar;cmd 00303 deny all from 127.0.0.0/8 to any in via &dollar;pif        #loopback
&dollar;cmd 00304 deny all from 0.0.0.0/8 to any in via &dollar;pif            #loopback
&dollar;cmd 00305 deny all from 169.254.0.0/16 to any in via &dollar;pif   #DHCP auto-config
&dollar;cmd 00306 deny all from 192.0.2.0/24 to any in via &dollar;pif       #reserved for docs
&dollar;cmd 00307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun cluster interconnect
&dollar;cmd 00308 deny all from 224.0.0.0/3 to any in via &dollar;pif         #Class D &amp; E multicast

# Deny public pings
&dollar;cmd 00310 deny icmp from any to any in via &dollar;pif

# Deny ident
&dollar;cmd 00315 deny tcp from any to any 113 in via &dollar;pif

# Deny all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
&dollar;cmd 00320 deny tcp from any to any 137 in via &dollar;pif
&dollar;cmd 00321 deny tcp from any to any 138 in via &dollar;pif
&dollar;cmd 00322 deny tcp from any to any 139 in via &dollar;pif
&dollar;cmd 00323 deny tcp from any to any 81 in via &dollar;pif

# Deny any late arriving packets
&dollar;cmd 00330 deny all from any to any frag in via &dollar;pif

# Deny ACK packets that did not match the dynamic rule table
&dollar;cmd 00332 deny tcp from any to any established in via &dollar;pif

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP.s DHCP server as it.s the only
# authorized source to send this packet type.
# Only necessary for cable or DSL configurations.
# This rule is not needed for .user ppp. type connection to
# the public Internet. This is the same IP address you captured
# and used in the outbound section.
#&dollar;cmd 00360 allow udp from any to x.x.x.x 67 in via &dollar;pif keep-state

# Allow in standard www function because I have apache server
&dollar;cmd 00400 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Allow in secure FTP, Telnet, and SCP from public Internet
&dollar;cmd 00410 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID &amp; PW are passed over public
# Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
&dollar;cmd 00420 allow tcp from any to me 23 in via &dollar;pif setup limit src-addr 2

# Reject &amp; Log all incoming connections from the outside
&dollar;cmd 00499 deny log all from any to any in via &dollar;pif

# Everything else is denied by default
# deny and log all packets that fell through to see what they are
&dollar;cmd 00999 deny log all from any to any
################ End of IPFW rules file ###############################</programlisting>
      </sect3>

      <sect3>
	<title>An Example <acronym>NAT</acronym> and Stateful
	  Ruleset</title>

	<indexterm>
	  <primary>NAT</primary>

	  <secondary>and IPFW</secondary>
	</indexterm>

	<para>There are some additional configuration statements that
	  need to be enabled to activate the <acronym>NAT</acronym>
	  function of IPFW.  For a customized kernel, the kernel
	  configuration file needs
	  <literal>option IPDIVERT</literal> added to the other
	  <literal>IPFIREWALL</literal> options.</para>

	<para>In addition to the normal IPFW options in
	  <filename>/etc/rc.conf</filename>, the following are
	  needed:</para>

	<programlisting>natd_enable="YES"                   # Enable <acronym>NAT</acronym>D function
natd_interface="rl0"                # interface name of public Internet NIC
natd_flags="-dynamic -m"            # -m = preserve port numbers if possible</programlisting>

	<para>Utilizing stateful rules with a
	  <literal>divert natd</literal> rule complicates the ruleset
	  logic.  The positioning of the
	  <literal>check-state</literal>, and
	  <literal>divert natd</literal> rules in the ruleset is
	  critical and a new action type is used, called
	  <literal>skipto</literal>.  When using
	  <literal>skipto</literal>, it is mandatory that each rule is
	  numbered, so that the <literal>skipto</literal> rule knows
	  which rule to jump to.</para>

	<para>The following is an uncommented example of a ruleset
	  which explains the sequence of the packet flow.</para>

	<para>The processing flow starts with the first rule from the
	  top of the ruleset and progresses one rule at a time until
	  the end is reached or the packet matches and the packet is
	  released out of the firewall.  Take note of the location of
	  rule numbers 100 101, 450, 500, and 510.  These rules
	  control the translation of the outbound and inbound packets
	  so that their entries in the dynamic keep-state table always
	  register the private LAN IP address.  All the allow and deny
	  rules specify the direction of the packet and the interface.
	  All start outbound session requests will
	  <literal>skipto rule 500</literal> to undergo NAT.</para>

	<para>Consider a web browser which initializes a new HTTP
	  session over port 80.  When the first outbound packet enters
	  the firewall, it does not match rule 100 because it is
	  headed out rather than in.  It passes rule 101 because this
	  is the first packet, and it has not been posted to the
	  dynamic keep-state table yet.  The packet finally matches
	  rule 125 as it is outbound through the NIC facing the
	  Internet and has a source IP address as a private LAN IP
	  address.  On matching this rule, two actions take place.
	  <literal>keep-state</literal> adds this rule to the dynamic
	  keep-state rules table and the specified action is executed
	  and posted as part of the info in the dynamic table.  In
	  this case, the action is <literal>skipto rule 500</literal>.
	  Rule 500 <acronym>NAT</acronym>s the packet IP address and
	  sends it out to the Internet.  This packet makes its way to
	  the destination web server, where a response packet is
	  generated and sent back.  This new packet enters the top of
	  the ruleset.  It matches rule 100 and has it destination IP
	  address mapped back to the corresponding LAN IP address.  It
	  then is processed by the <literal>check-state</literal>
	  rule, is found in the table as an existing session, and is
	  released to the LAN.  It goes to the LAN system that sent it
	  and a new packet is sent requesting another segment of the
	  data from the remote server.  This time it matches the
	  <literal>check-state</literal> rule, its outbound entry is
	  found,  and the associated action,
	  <literal>skipto 500</literal>, is executed.  The packet
	  jumps to rule 500, gets <acronym>NAT</acronym>ed, and is
	  released to the Internet.</para>

	<para>On the inbound side, everything coming in that is part
	  of an existing session is automatically handled by the
	  <literal>check-state</literal> rule and the properly placed
	  <literal>divert natd</literal> rules.  The ruleset only has
	  to deny bad packets and allow only authorized services.
	  Consider a web server running on the firewall where web
	  requests from the Internet should have access to the local
	  web site.  An inbound start request packet will match rule
	  100 and its IP address will be mapped to the LAN IP address
	  of the firewall.  The packet is then matched against all the
	  nasty things that need to be checked and finally matches
	  rule 425 where two actions occur.  The packet rule is posted
	  to the dynamic keep-state table but this time, any new
	  session requests originating from that source IP address are
	  limited to 2.  This defends against DoS attacks against the
	  service running on the specified port number.  The action is
	  <literal>allow</literal>, so the packet is released to the
	  LAN. The packet generated as a response is recognized by the
	  <literal>check-state</literal> as belonging to an existing
	  session.  It is then sent to rule 500 for
	  <acronym>NAT</acronym>ing and released to the outbound
	  interface.</para>

	<para>Example Ruleset #1:</para>

	<programlisting>#!/bin/sh
cmd="ipfw -q add"
skip="skipto 500"
pif=rl0
ks="keep-state"
good_tcpo="22,25,37,43,53,80,443,110,119"

ipfw -q -f flush

&dollar;cmd 002 allow all from any to any via xl0  # exclude LAN traffic
&dollar;cmd 003 allow all from any to any via lo0  # exclude loopback traffic

&dollar;cmd 100 divert natd ip from any to any in via &dollar;pif
&dollar;cmd 101 check-state

# Authorized outbound packets
&dollar;cmd 120 &dollar;skip udp from any to xx.168.240.2 53 out via &dollar;pif &dollar;ks
&dollar;cmd 121 &dollar;skip udp from any to xx.168.240.5 53 out via &dollar;pif &dollar;ks
&dollar;cmd 125 &dollar;skip tcp from any to any &dollar;good_tcpo out via &dollar;pif setup &dollar;ks
&dollar;cmd 130 &dollar;skip icmp from any to any out via &dollar;pif &dollar;ks
&dollar;cmd 135 &dollar;skip udp from any to any 123 out via &dollar;pif &dollar;ks


# Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 300 deny all from 192.168.0.0/16  to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 301 deny all from 172.16.0.0/12   to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 302 deny all from 10.0.0.0/8      to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 303 deny all from 127.0.0.0/8     to any in via &dollar;pif  #loopback
&dollar;cmd 304 deny all from 0.0.0.0/8       to any in via &dollar;pif  #loopback
&dollar;cmd 305 deny all from 169.254.0.0/16  to any in via &dollar;pif  #DHCP auto-config
&dollar;cmd 306 deny all from 192.0.2.0/24    to any in via &dollar;pif  #reserved for docs
&dollar;cmd 307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun cluster
&dollar;cmd 308 deny all from 224.0.0.0/3     to any in via &dollar;pif  #Class D &amp; E multicast

# Authorized inbound packets
&dollar;cmd 400 allow udp from xx.70.207.54 to any 68 in &dollar;ks
&dollar;cmd 420 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 1


&dollar;cmd 450 deny log ip from any to any

# This is skipto location for outbound stateful rules
&dollar;cmd 500 divert natd ip from any to any out via &dollar;pif
&dollar;cmd 510 allow ip from any to any

######################## end of rules  ##################</programlisting>

	<para>The next example is functionally equivalent, but uses
	  descriptive comments to help the inexperienced IPFW rule
	  writer to better understand what the rules are doing.</para>

	<para>Example Ruleset #2:</para>

	<programlisting>#!/bin/sh
################ Start of IPFW rules file ###############################
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
skip="skipto 800"
pif="rl0"     # public interface name of NIC
              # facing the public Internet

#################################################################
# No restrictions on Inside LAN Interface for private network
# Change xl0 to your LAN NIC interface name
#################################################################
&dollar;cmd 005 allow all from any to any via xl0

#################################################################
# No restrictions on Loopback Interface
#################################################################
&dollar;cmd 010 allow all from any to any via lo0

#################################################################
# check if packet is inbound and nat address if it is
#################################################################
&dollar;cmd 014 divert natd ip from any to any in via &dollar;pif

#################################################################
# Allow the packet through if it has previous been added to the
# the "dynamic" rules table by a allow keep-state statement.
#################################################################
&dollar;cmd 015 check-state

#################################################################
# Interface facing Public Internet (Outbound Section)
# Check session start requests originating from behind the
# firewall on the private network or from this gateway server
# destined for the public Internet.
#################################################################

# Allow out access to my ISP's Domain name server.
# x.x.x.x must be the IP address of your ISP's DNS
# Dup these lines if your ISP has more than one DNS server
# Get the IP addresses from /etc/resolv.conf file
&dollar;cmd 020 &dollar;skip tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state


# Allow out access to my ISP's DHCP server for cable/DSL configurations.
&dollar;cmd 030 &dollar;skip udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Allow out non-secure standard www function
&dollar;cmd 040 &dollar;skip tcp from any to any 80 out via &dollar;pif setup keep-state

# Allow out secure www function https over TLS SSL
&dollar;cmd 050 &dollar;skip tcp from any to any 443 out via &dollar;pif setup keep-state

# Allow out send &amp; get email function
&dollar;cmd 060 &dollar;skip tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 061 &dollar;skip tcp from any to any 110 out via &dollar;pif setup keep-state

# Allow out FreeBSD (make install &amp; CVSUP) functions
# Basically give user root "GOD" privileges.
&dollar;cmd 070 &dollar;skip tcp from me to any out via &dollar;pif setup keep-state uid root

# Allow out ping
&dollar;cmd 080 &dollar;skip icmp from any to any out via &dollar;pif keep-state

# Allow out Time
&dollar;cmd 090 &dollar;skip tcp from any to any 37 out via &dollar;pif setup keep-state

# Allow out nntp news (i.e., news groups)
&dollar;cmd 100 &dollar;skip tcp from any to any 119 out via &dollar;pif setup keep-state

# Allow out secure FTP, Telnet, and SCP
# This function is using SSH (secure shell)
&dollar;cmd 110 &dollar;skip tcp from any to any 22 out via &dollar;pif setup keep-state

# Allow out whois
&dollar;cmd 120 &dollar;skip tcp from any to any 43 out via &dollar;pif setup keep-state

# Allow ntp time server
&dollar;cmd 130 &dollar;skip udp from any to any 123 out via &dollar;pif keep-state

#################################################################
# Interface facing Public Internet (Inbound Section)
# Check packets originating from the public Internet
# destined for this gateway server or the private network.
#################################################################

# Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 300 deny all from 192.168.0.0/16  to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 301 deny all from 172.16.0.0/12   to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 302 deny all from 10.0.0.0/8      to any in via &dollar;pif  #RFC 1918 private IP
&dollar;cmd 303 deny all from 127.0.0.0/8     to any in via &dollar;pif  #loopback
&dollar;cmd 304 deny all from 0.0.0.0/8       to any in via &dollar;pif  #loopback
&dollar;cmd 305 deny all from 169.254.0.0/16  to any in via &dollar;pif  #DHCP auto-config
&dollar;cmd 306 deny all from 192.0.2.0/24    to any in via &dollar;pif  #reserved for docs
&dollar;cmd 307 deny all from 204.152.64.0/23 to any in via &dollar;pif  #Sun cluster
&dollar;cmd 308 deny all from 224.0.0.0/3     to any in via &dollar;pif  #Class D &amp; E multicast

# Deny ident
&dollar;cmd 315 deny tcp from any to any 113 in via &dollar;pif

# Deny all Netbios service. 137=name, 138=datagram, 139=session
# Netbios is MS/Windows sharing services.
# Block MS/Windows hosts2 name server requests 81
&dollar;cmd 320 deny tcp from any to any 137 in via &dollar;pif
&dollar;cmd 321 deny tcp from any to any 138 in via &dollar;pif
&dollar;cmd 322 deny tcp from any to any 139 in via &dollar;pif
&dollar;cmd 323 deny tcp from any to any 81  in via &dollar;pif

# Deny any late arriving packets
&dollar;cmd 330 deny all from any to any frag in via &dollar;pif

# Deny ACK packets that did not match the dynamic rule table
&dollar;cmd 332 deny tcp from any to any established in via &dollar;pif

# Allow traffic in from ISP's DHCP server. This rule must contain
# the IP address of your ISP's DHCP server as it is the only
# authorized source to send this packet type.
# Only necessary for cable or DSL configurations.
# This rule is not needed for 'user ppp' type connection to
# the public Internet. This is the same IP address you captured
# and used in the outbound section.
&dollar;cmd 360 allow udp from x.x.x.x to any 68 in via &dollar;pif keep-state

# Allow in standard www function because I have Apache server
&dollar;cmd 370 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Allow in secure FTP, Telnet, and SCP from public Internet
&dollar;cmd 380 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Allow in non-secure Telnet session from public Internet
# labeled non-secure because ID &amp; PW are passed over public
# Internet as clear text.
# Delete this sample group if you do not have telnet server enabled.
&dollar;cmd 390 allow tcp from any to me 23 in via &dollar;pif setup limit src-addr 2

# Reject &amp; Log all unauthorized incoming connections from the public Internet
&dollar;cmd 400 deny log all from any to any in via &dollar;pif

# Reject &amp; Log all unauthorized out going connections to the public Internet
&dollar;cmd 450 deny log all from any to any out via &dollar;pif

# This is skipto location for outbound stateful rules
&dollar;cmd 800 divert natd ip from any to any out via &dollar;pif
&dollar;cmd 801 allow ip from any to any

# Everything else is denied by default
# deny and log all packets that fell through to see what they are
&dollar;cmd 999 deny log all from any to any
################ End of IPFW rules file ###############################</programlisting>
      </sect3>
    </sect2>
  </sect1>
</chapter>
