<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
-->

<chapter id="disks">
  <title>Storage</title>

  <sect1 id="disks-synopsis">
    <title>Synopsis</title>

    <para>This chapter covers the use of disks in &os;.  This
      includes memory-backed disks, network-attached disks,
      standard SCSI/IDE storage devices, and devices using the USB
      interface.</para>

    <para>After reading this chapter, you will know:</para>

    <itemizedlist>
      <listitem>
	<para>The terminology &os; uses to describe the organization
	  of data on a physical disk.</para>
      </listitem>

      <listitem>
	<para>How to add additional hard disks to a &os;
	  system.</para>
      </listitem>

      <listitem>
	<para>How to configure &os; to use USB storage devices.</para>
      </listitem>

      <listitem>
	<para>How to set up virtual file systems, such as memory
	  disks.</para>
      </listitem>

      <listitem>
	<para>How to use quotas to limit disk space usage.</para>
      </listitem>

      <listitem>
	<para>How to encrypt disks to secure them against
	  attackers.</para>
      </listitem>

      <listitem>
	<para>How to create and burn CDs and DVDs on &os;.</para>
      </listitem>

      <listitem>
	<para>The various storage media options for backups.</para>
      </listitem>

      <listitem>
	<para>How to use the backup programs available under
	  &os;.</para>
      </listitem>

      <listitem>
	<para>How to backup to floppy disks.</para>
      </listitem>

      <listitem>
	<para>What file system snapshots are and how to use them
	  efficiently.</para>
      </listitem>
    </itemizedlist>

    <para>Before reading this chapter, you should:</para>

    <itemizedlist>
      <listitem>
	<para>Know how to <link linkend="kernelconfig">configure and
	    install a new &os; kernel</link>.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="disks-naming">
    <title>Device Names</title>

    <para>The following is a list of physical storage devices
      supported in &os;, and their associated device names.</para>

    <table id="disk-naming-physical-table" frame="none">
      <title>Physical Disk Naming Conventions</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Drive type</entry>
	    <entry>Drive device name</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>IDE hard drives</entry>
	    <entry><literal>ad</literal></entry>
	  </row>

	  <row>
	    <entry>IDE CDROM drives</entry>
	    <entry><literal>acd</literal></entry>
	  </row>

	  <row>
	    <entry>SCSI hard drives and USB Mass storage
	      devices</entry>
	    <entry><literal>da</literal></entry>
	  </row>

	  <row>
	    <entry>SCSI CDROM drives</entry>
	    <entry><literal>cd</literal></entry>
	  </row>

	  <row>
	    <entry>Assorted non-standard CDROM drives</entry>
	    <entry><literal>mcd</literal> for Mitsumi CD-ROM and
	      <literal>scd</literal> for Sony CD-ROM devices</entry>
	  </row>

	  <row>
	    <entry>Floppy drives</entry>
	    <entry><literal>fd</literal></entry>
	  </row>

	  <row>
	    <entry>SCSI tape drives</entry>
	    <entry><literal>sa</literal></entry>
	  </row>

	  <row>
	    <entry>IDE tape drives</entry>
	    <entry><literal>ast</literal></entry>
	  </row>

	  <row>
	    <entry>Flash drives</entry>
	    <entry><literal>fla</literal> for &diskonchip; Flash
	      device</entry>
	  </row>

	  <row>
	    <entry>RAID drives</entry>
	    <entry><literal>aacd</literal> for &adaptec; AdvancedRAID,
	      <literal>mlxd</literal> and <literal>mlyd</literal>
	      for &mylex;,
	      <literal>amrd</literal> for AMI &megaraid;,
	      <literal>idad</literal> for Compaq Smart RAID,
	      <literal>twed</literal> for &tm.3ware; RAID.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 id="disks-adding">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>David</firstname>
	  <surname>O'Brien</surname>
	  <contrib>Originally contributed by </contrib>
	</author>
      </authorgroup>
      <!-- 26 Apr 1998 -->
    </sect1info>

    <title>Adding Disks</title>

    <indexterm>
      <primary>disks</primary>
      <secondary>adding</secondary>
    </indexterm>

    <para>This section describes how to add a new
      <acronym>SCSI</acronym> disk to a machine that currently only
      has a single drive.  First, turn off the computer and install
      the drive in the computer following the instructions of the
      computer, controller, and drive manufacturers.  Reboot
      the system and become <username>root</username>.</para>

    <para>Inspect <filename>/var/run/dmesg.boot</filename> to ensure
      the new disk was found.  In this example, the newly added SCSI
      drive should appear as <devicename>da1</devicename>.</para>

    <indexterm><primary>partitions</primary></indexterm>
    <indexterm><primary>slices</primary></indexterm>
    <indexterm>
      <primary><command>fdisk</command></primary>
    </indexterm>

    <para>&os; runs on IBM-PC compatible computers, therefore it
      must take into account the PC BIOS partitions which are
      different from the traditional BSD partitions.  A PC disk has up
      to four BIOS partition entries.  If the disk is going to be
      truly dedicated to &os;, use <emphasis>dedicated</emphasis>
      mode.  Otherwise, &os; will have to live within one of the PC
      BIOS partitions.  &os; calls the PC BIOS partitions
      <emphasis>slices</emphasis> so as not to confuse them with
      traditional BSD partitions.  Slices may also be used on a disk
      that is dedicated to &os;, but used in a computer that also has
      another operating system installed.  This is a good way to avoid
      confusing the <command>fdisk</command> utility of non-&os;
      operating systems.</para>

    <para>In the slice case, the drive will be added as
      <filename>/dev/da1s1e</filename>.  This is read as: SCSI disk,
      unit number 1 (second SCSI disk), slice 1 (PC BIOS partition 1),
      and <filename>e</filename> BSD partition.  In the dedicated
      case, the drive will be added as
      <filename>/dev/da1e</filename>.</para>

    <para>Due to the use of 32-bit integers to store the number of
      sectors, &man.bsdlabel.8; is limited to 2^32-1 sectors per disk,
      or 2TB in most cases.  The &man.fdisk.8; format allows a
      starting sector of no more than 2^32-1 and a length of no more
      than 2^32-1, limiting partitions to 2TB and disks to 4TB, in
      most cases.  The &man.sunlabel.8; format is limited to 2^32-1
      sectors per partition and 8 partitions for a total of 16TB.  For
      larger disks, &man.gpart.8; may be used to create
      <acronym>GPT</acronym> partitions.  <acronym>GPT</acronym> has
      the added benefit of not being limited to 4 slices.</para>

    <sect2>
      <title>Using &man.sysinstall.8;</title>

      <indexterm>
	<primary><application>sysinstall</application></primary>
	<secondary>adding disks</secondary>
      </indexterm>
      <indexterm>
	<primary>su</primary>
      </indexterm>

      <procedure>
	<step>
	  <title>Navigating
	    <application>sysinstall</application></title>

	  <para><command>sysinstall</command> can be used to partition
	    and label a new disk using its easy-to-use menus.  As
	    <username>root</username>, run
	    <command>sysinstall</command> and enter the
	    <literal>Configure</literal> menu.  Within the
	    <literal>&os; Configuration Menu</literal>, scroll down
	    and select the <literal>Fdisk</literal> option.</para>
	</step>

	<step>
	  <title><application>fdisk</application> Partition
	    Editor</title>

	  <para>Once inside <application>fdisk</application>, pressing
	    <keycap>A</keycap> will use the entire disk for &os;.
	    When asked whether to <quote>remain cooperative with
	      any future possible operating systems</quote>, answer
	    <literal>YES</literal>.  Write the changes to the disk
	    using <keycap>W</keycap>.  Exit the fdisk editor by
	    pressing <keycap>Q</keycap> which will prompt about
	    the <quote>Master Boot Record</quote>.  Since the disk is
	    being added to an already running system, choose
	    <literal>None</literal>.</para>
	</step>

	<step>
	  <title>Disk Label Editor</title>

	  <indexterm><primary>BSD partitions</primary></indexterm>

	  <para>Next, exit <application>sysinstall</application> and
	    start it again.  Follow the directions above, except this
	    time choose the <literal>Label</literal> option.  This
	    will enter the <literal>Disk Label Editor</literal>.  This
	    editor is used to create traditional BSD partitions.  A
	    disk can have up to eight partitions, labeled
	    <literal>a-h</literal>.  A few of the partition labels
	    have special uses.  The <literal>a</literal> partition is
	    used for the root partition (<filename
	      class="directory">/</filename>).  Only the disk the
	    system boots from should have an <literal>a</literal>
	    partition.  The <literal>b</literal> partition is used for
	    swap partitions, and there can be many disks with swap
	    partitions.  The <literal>c</literal> partition addresses
	    the entire disk in dedicated mode, or the entire &os;
	    slice in slice mode.  The other partitions are for general
	    use.</para>

	  <para>The label editor in
	    <application>sysinstall</application> favors the
	    <literal>e</literal> partition for non-root, non-swap
	    partitions.  Within the label editor, create a single file
	    system by pressing <keycap>C</keycap>.  When prompted if
	    this will be a FS (file system) or swap, choose
	    <literal>FS</literal> and type in a mount point such as
	    <filename class="directory">/mnt</filename>).  When adding
	    a disk in post-install mode,
	    <application>sysinstall</application> will not create
	    entries in <filename>/etc/fstab</filename>, so the mount
	    point you specify is not important.</para>

	  <para>Press <keycap>W</keycap> to write the new label to the
	    disk and create a file system on it.  Ignore any errors
	    from <application>sysinstall</application> indicating that
	    it could not mount the new partition.  Exit the label
	    editor then <application>sysinstall</application>
	    completely.</para>
	</step>

	<step>
	  <title>Finish</title>

	  <para>The last step is to edit
	    <filename>/etc/fstab</filename> to add an entry for your
	    new disk.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Using Command Line Utilities</title>

      <sect3>
	<title>Using Slices</title>

	<para>The setup in the following example allows the new disk
	  to work correctly with other operating systems that might be
	  installed on the computer without confusing other operating
	  systems' <command>fdisk</command> utilities.  This method is
	  recommended for new disk installs.  Only use
	  <literal>dedicated</literal> mode if there is a good reason
	  to do so!</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> #Initialize your new disk
&prompt.root; <userinput>bsdlabel -B -w da1s1 auto</userinput> #Label it.
&prompt.root; <userinput>bsdlabel -e da1s1</userinput> # Edit the bsdlabel just created and add any partitions.
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> # Repeat this for every partition you created.
&prompt.root; <userinput>mount /dev/da1s1e /1</userinput> # Mount the partition(s)
&prompt.root; <userinput>vi /etc/fstab</userinput> # Add the appropriate entry/entries to your <filename>/etc/fstab</filename>.</screen>

	<para>For an IDE disk, substitute
	  <filename>ad</filename> for <filename>da</filename>.</para>
      </sect3>

      <sect3>
	<title>Dedicated</title>

	<indexterm><primary>OS/2</primary></indexterm>

	<para>If the new drive will not be shared with another
	  operating system, <literal>dedicated</literal> mode can be
	  used.  This mode can confuse Microsoft operating systems;
	  however, no damage will be done by them.  To configure a
	  disk in dedicated mode:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>bsdlabel -Bw da1 auto</userinput>
&prompt.root; <userinput>bsdlabel -e da1</userinput>				# create the `e' partition
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>				# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>

	<para>An alternate method is:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 count=2</userinput>
&prompt.root; <userinput>bsdlabel /dev/da1 | bsdlabel -BR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>					# add an entry for /dev/da1e
&prompt.root; <userinput>mount /1</userinput></screen>

      </sect3>
    </sect2>
  </sect1>

  <sect1 id="raid">
    <title>RAID</title>

    <sect2 id="raid-soft">
      <title>Software RAID</title>

      <sect3 id="ccd">
	<sect3info>
	  <authorgroup>
	    <author>
	      <firstname>Christopher</firstname>
	      <surname>Shumway</surname>
	      <contrib>Original work by </contrib>
	    </author>
	  </authorgroup>

	  <authorgroup>
	    <author>
	      <firstname>Jim</firstname>
	      <surname>Brown</surname>
	      <contrib>Revised by </contrib>
	    </author>
	  </authorgroup>
	</sect3info>

	<title>Concatenated Disk Driver (CCD) Configuration</title>

	<indexterm><primary>RAID</primary><secondary>software</secondary></indexterm>
	<indexterm><primary>RAID</primary><secondary>CCD</secondary></indexterm>

	<para>When choosing a mass storage solution, the most
	  important factors to consider are speed, reliability, and
	  cost.  It is rare to have all three in balance.  Normally a
	  fast, reliable mass storage device is expensive, and to cut
	  back on cost either speed or reliability must be
	  sacrificed.</para>

	<para>In designing the system described below, cost was
	  chosen as the most important factor, followed by speed,
	  then reliability.  Data transfer speed for this system is
	  ultimately constrained by the network.  While reliability is
	  very important, the CCD drive described below serves online
	  data that is already fully backed up and which can easily be
	  replaced.</para>

	<para>Defining the requirements is the first step in choosing
	  a mass storage solution.  If the requirements prefer speed
	  or reliability over cost, the solution will differ from the
	  system described in this section.</para>

	<sect4 id="ccd-installhw">
	  <title>Installing the Hardware</title>

	  <para>In addition to the IDE system disk, three Western
	    Digital 30GB, 5400 RPM IDE disks form the core of the CCD
	    disk described below, providing approximately 90GB of
	    online storage.  Ideally, each IDE disk would have its own
	    IDE controller and cable, but to minimize cost, additional
	    IDE controllers were not used.  Instead, the disks were
	    configured with jumpers so that each IDE controller has
	    one master, and one slave.</para>

	  <para>Upon reboot, the system BIOS was configured to
	    automatically detect the disks attached.  More
	    importantly, &os; detected them on reboot:</para>

	  <programlisting>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</programlisting>

	  <note><para>If &os; does not detect all the disks, consult
	    the drive documentation for proper setup and verify
	    that the controller is supported by &os;.</para></note>
	</sect4>

	<sect4 id="ccd-setup">
	  <title>Setting Up the CCD</title>

	  <para>The &man.ccd.4; driver takes several identical disks
	    and concatenates them into one logical file system.  In
	    order to use &man.ccd.4;, its kernel module must be
	    loaded using &man.ccd.4;.  When using a custom kernel,
	    ensure that this line is compiled in:</para>

	  <programlisting>device   ccd</programlisting>

	  <para>Before configuring &man.ccd.4;, use &man.bsdlabel.8;
	    to label the disks:</para>

	  <programlisting>bsdlabel -w ad1 auto
bsdlabel -w ad2 auto
bsdlabel -w ad3 auto</programlisting>

	  <para>This example creates a bsdlabel for
	    <devicename>ad1c</devicename>,
	    <devicename>ad2c</devicename> and
	    <devicename>ad3c</devicename> that spans the entire
	    disk.</para>

	  <para>The next step is to change the disk label type.  Use
	    &man.bsdlabel.8; to edit the disks:</para>

	  <programlisting>bsdlabel -e ad1
bsdlabel -e ad2
bsdlabel -e ad3</programlisting>

	  <para>This opens up the current disk label on each disk with
	    the editor specified by the <envar>EDITOR</envar>
	    environment variable, typically &man.vi.1;.</para>

	  <para>An unmodified disk label will look something like
	    this:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	  <para>Add a new <literal>e</literal> partition for
	    &man.ccd.4; to use.  This can usually be copied from the
	    <literal>c</literal> partition, but the
	    <option>fstype</option> <emphasis>must</emphasis> be
	    <userinput>4.2BSD</userinput>.  The disk label should now
	    look something like this:</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</programlisting>
	</sect4>

	<sect4 id="ccd-buildingfs">
	  <title>Building the File System</title>

	  <para>Now that all the disks are labeled, build the
	    &man.ccd.4; using &man.ccdconfig.8;, with options similar
	    to the following:</para>

	  <programlisting>ccdconfig ccd0<co id="co-ccd-dev"/> 32<co id="co-ccd-interleave"/> 0<co id="co-ccd-flags"/> /dev/ad1e<co id="co-ccd-devs"/> /dev/ad2e /dev/ad3e</programlisting>

	  <para>The use and meaning of each option is described
	    below:</para>

	  <calloutlist>
	    <callout arearefs="co-ccd-dev">
	      <para>The first argument is the device to configure, in
		this case, <filename>/dev/ccd0c</filename>.  The
		<literal>/dev/</literal> portion is optional.</para>
	    </callout>

	    <callout arearefs="co-ccd-interleave">
	      <para>The interleave for the file system, which defines
		the size of a stripe in disk blocks, each normally 512
		bytes.  So, an interleave of 32 would be 16,384
		bytes.</para>
	    </callout>

	    <callout arearefs="co-ccd-flags">
	      <para>Flags for &man.ccdconfig.8;.  For example, to
		enable drive mirroring, specify a flag.  This
		configuration does not provide mirroring for
		&man.ccd.4;, so it is set at 0 (zero).</para>
	    </callout>

	    <callout arearefs="co-ccd-devs">
	      <para>The final arguments to &man.ccdconfig.8; are the
		devices to place into the array.  Use the complete
		path name for each device.</para>
	    </callout>
	  </calloutlist>

	  <para>After running &man.ccdconfig.8; the &man.ccd.4; is
	    configured and a file system can be installed.  Refer to
	    &man.newfs.8; for options, or run: </para>

	  <programlisting>newfs /dev/ccd0c</programlisting>
	</sect4>

	<sect4 id="ccd-auto">
	  <title>Making it All Automatic</title>

	  <para>Generally, &man.ccd.4; should be configured to
	    automount upon each reboot.  To do this, write out the
	    current configuration to
	    <filename>/etc/ccd.conf</filename> using the following
	    command:</para>

	  <programlisting>ccdconfig -g &gt; /etc/ccd.conf</programlisting>

	  <para>During reboot, the script <command>/etc/rc</command>
	    runs <command>ccdconfig -C</command> if
	    <filename>/etc/ccd.conf</filename> exists.  This
	    automatically configures the &man.ccd.4; so it can be
	    mounted.</para>

	  <note>
	    <para>When booting into single user mode, the following
	      command must be issued to configure the array before
	      the &man.ccd.4; can be mounted:</para>

	    <programlisting>ccdconfig -C</programlisting>
	  </note>

	  <para>To automatically mount the &man.ccd.4;, place an entry
	    for the &man.ccd.4; in <filename>/etc/fstab</filename> so
	    it will be mounted at boot time:</para>

	  <programlisting>/dev/ccd0c              /media       ufs     rw      2       2</programlisting>
	</sect4>
      </sect3>

      <sect3 id="vinum">
	<title>The Vinum Volume Manager</title>

	<indexterm>
	  <primary>RAID</primary>
	  <secondary>software</secondary>
	</indexterm>
	<indexterm>
	  <primary>RAID</primary>
	  <secondary>Vinum</secondary>
	</indexterm>

	<para>The Vinum Volume Manager is a block device driver which
	  implements virtual disk drives.  It isolates disk hardware
	  from the block device interface and maps data in ways which
	  result in an increase in flexibility, performance and
	  reliability compared to the traditional slice view of disk
	  storage.  &man.vinum.4; implements the RAID-0, RAID-1 and
	  RAID-5 models, both individually and in combination.</para>

	<para>Refer to <link linkend="vinum-vinum"></link> for more
	  information about &man.vinum.4;.</para>
      </sect3>
    </sect2>

    <sect2 id="raid-hard">
      <title>Hardware RAID</title>

      <indexterm>
	<primary>RAID</primary>
	<secondary>hardware</secondary>
      </indexterm>

      <para>&os; also supports a variety of hardware
	<acronym>RAID</acronym> controllers.  These devices control a
	<acronym>RAID</acronym> subsystem without the need for &os;
	specific software to manage the array.</para>

      <para>Using an on-card <acronym>BIOS</acronym>, the card
	controls most of the disk operations.  The following is a
	brief setup description using a Promise
	<acronym>IDE</acronym> <acronym>RAID</acronym> controller.
	When this card is installed and the system is started up, it
	displays a prompt requesting information.  Follow the
	instructions to enter the card's setup screen and to combine
	all the attached drives.  After doing so, the disks will
	look like a single drive to &os;.  Other
	<acronym>RAID</acronym> levels can be set up
	accordingly.</para>
    </sect2>

    <sect2>
      <title>Rebuilding ATA RAID1 Arrays</title>

      <para>&os; supports the ability to hot-replace a failed disk in
	an array.</para>

      <para>An error indicating a failed disk will appear in
	<filename>/var/log/messages</filename> or in the &man.dmesg.8;
	output:</para>

      <programlisting>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)\\
status=59 error=40
ar0: WARNING - mirror lost</programlisting>

      <para>Use &man.atacontrol.8; to check for further
	information:</para>

      <screen>&prompt.root; <userinput>atacontrol list</userinput>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</screen>

      <procedure>
	<step>
	  <para>First, detach the ata channel with the failed disk
	    so that it can be safely removed:</para>

	  <screen>&prompt.root; <userinput>atacontrol detach ata3</userinput></screen>
	</step>

	<step>
	  <para>Replace the disk.</para>
	</step>

	<step>
	  <para>Reattach the ata channel:</para>

	  <screen>&prompt.root; <userinput>atacontrol attach ata3</userinput>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</screen>
	</step>

	<step>
	  <para>Add the new disk to the array as a spare:</para>

	  <screen>&prompt.root; <userinput>atacontrol addspare ar0 ad6</userinput></screen>
	</step>

	<step>
	  <para>Rebuild the array:</para>

	  <screen>&prompt.root; <userinput>atacontrol rebuild ar0</userinput></screen>
	</step>

	<step>
	  <para>It is possible to check on the progress by issuing the
	    following command:</para>

	  <screen>&prompt.root; <userinput>dmesg | tail -10</userinput>
[output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</screen>
	</step>

	<step>
	  <para>Wait until this operation completes.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 id="usb-disks">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <!-- Jul 2004 -->
    </sect1info>

    <title>USB Storage Devices</title>

    <indexterm>
      <primary>USB</primary>
      <secondary>disks</secondary>
    </indexterm>

    <para>Many external storage solutions, such as hard drives, USB
      thumbdrives, and CD/DVD burners, use the Universal Serial Bus
      (USB).  &os; provides support for these devices.</para>

    <sect2>
      <title>Configuration</title>

      <para>The USB mass storage devices driver, &man.umass.4;,
	is built into the <filename>GENERIC</filename> kernel
	and provides support for USB storage devices.  For a custom
	kernel, be sure that the following lines are present in the
	kernel configuration file:</para>

      <programlisting>device scbus
device da
device pass
device uhci
device ohci
device ehci
device usb
device umass</programlisting>

      <para>Since the &man.umass.4; driver uses the SCSI subsystem to
	access the USB storage devices, any USB device will be seen as
	a SCSI device by the system.  Depending on the USB chipset on
	the motherboard, <literal>device uhci</literal> or
	<literal>device ohci</literal> is used to provide USB 1.X
	support.  Support for USB 2.0 controllers is provided by
	<literal>device ehci</literal>.</para>

      <note>
	<para>If the USB device is a CD or DVD burner, &man.cd.4;,
	  must be added to the kernel via the line:</para>

	<programlisting>device cd</programlisting>

	<para>Since the burner is seen as a SCSI drive, the driver
	  &man.atapicam.4; should not be used in the kernel
	  configuration.</para>
      </note>
    </sect2>

    <sect2>
      <title>Testing the Configuration</title>

      <para>To test the USB configuration, plug in the USB device.  In
	the system message buffer, &man.dmesg.8;, the drive should
	appear as something like:</para>

      <screen>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)</screen>

      <para>The brand, device node (<devicename>da0</devicename>), and
	other details will differ according to the device.</para>

      <para>Since the USB device is seen as a SCSI one,
	<command>camcontrol</command> can be used to list the USB
	storage devices attached to the system:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 (da0,pass0)</screen>

      <para>If the drive comes with a file system, it can be mounted.
	Refer to <link linkend="disks-adding"></link> for
	instructions on how to format and create partitions on the USB
	drive.</para>

      <warning>
	<para>Allowing untrusted users to mount arbitrary media, by
	  enabling <varname>vfs.usermount</varname> as
	  described below, should not be considered safe from a
	  security point of view.  Most file systems in &os; were not
	  built to safeguard against malicious devices.</para>
      </warning>

      <para>To make the device mountable as a normal user, one
	solution is to make all users of the device a member of the
	<groupname>operator</groupname> group using &man.pw.8;.
	Next, ensure that the <groupname>operator</groupname> group is
	able to read and write the device by adding these lines to
	<filename>/etc/devfs.rules</filename>:</para>

      <programlisting>[localrules=5]
add path 'da*' mode 0660 group operator</programlisting>

      <note>
	<para>If SCSI disks are installed in the system, change
	  the second line as follows:</para>

	<programlisting>add path 'da[3-9]*' mode 0660 group operator</programlisting>

	<para>This will exclude the first three SCSI disks
	  (<devicename>da0</devicename> to
	  <devicename>da2</devicename>)from belonging to the
	  <groupname>operator</groupname> group.</para>
      </note>

      <para>Next, enable the &man.devfs.rules.5; ruleset in
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>devfs_system_ruleset="localrules"</programlisting>

      <para>Next, instruct the running kernel to allow regular users
	to mount file systems.  The easiest way is to add the
	following line to
	<filename>/etc/sysctl.conf</filename>:</para>

      <programlisting>vfs.usermount=1</programlisting>

      <para>Since this only takes effect after the next reboot use
	&man.sysctl.8; to set this variable now.</para>

      <para>The final step is to create a directory where the file
	system is to be mounted.  This directory needs to be owned by
	the user that is to mount the file system.  One way to do that
	is for <username>root</username> to create a subdirectory
	owned by that user as <filename
	class="directory">/mnt/<replaceable>username</replaceable></filename>.
	In the following example, replace
	<replaceable>username</replaceable> with the login name of the
	user and <replaceable>usergroup</replaceable> with the user's
	primary group:</para>

      <screen>&prompt.root; <userinput>mkdir /mnt/<replaceable>username</replaceable></userinput>
&prompt.root; <userinput>chown <replaceable>username</replaceable>:<replaceable>usergroup</replaceable> /mnt/<replaceable>username</replaceable></userinput></screen>

      <para>Suppose a USB thumbdrive is plugged in, and a device
	<filename>/dev/da0s1</filename> appears.  If the device is
	preformatted with a FAT file system, it can be mounted
	using:</para>

      <screen>&prompt.user; <userinput>mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/<replaceable>username</replaceable></userinput></screen>

      <para>Before the device can be unplugged, it
	<emphasis>must</emphasis> be unmounted first.  After device
	removal, the system message buffer will show messages similar
	to the following:</para>

      <screen>umass0: at uhub0 port 1 (addr 2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached</screen>
    </sect2>

    <sect2>
      <title>Further Reading</title>

      <para>Beside the <link linkend="disks-adding">Adding
	  Disks</link> and <link linkend="mount-unmount">Mounting and
	Unmounting File Systems</link> sections, reading various
	manual pages may be also useful: &man.umass.4;,
	&man.camcontrol.8;, and &man.usbconfig.8; under &os;&nbsp; 8.X
	or &man.usbdevs.8; under earlier versions of &os;.</para>
    </sect2>
  </sect1>

  <sect1 id="creating-cds">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Contributed by </contrib>
	  <!-- mwm@mired.org -->
	</author>
      </authorgroup>
      <!-- Apr 2001 -->
    </sect1info>

    <title>Creating and Using CD Media</title>

    <indexterm>
      <primary>CDROMs</primary>
      <secondary>creating</secondary>
    </indexterm>

    <sect2>
      <title>Introduction</title>

      <para>CD media provide a number of features that differentiate
	them from conventional disks.  Initially, they were not
	writable by the user.  They are designed so that they can be
	read continuously without delays to move the head between
	tracks.  They are also much easier to transport between
	systems.</para>

      <para>CD media do have tracks, but this refers to a section of
	data to be read continuously and not a physical property of
	the disk.  For example, to produce a CD on &os;, prepare the
	data files that are going to make up the tracks on the CD,
	then write the tracks to the CD.</para>

      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
	<primary>file systems</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>

      <para>The ISO 9660 file system was designed to deal with these
	differences.  To overcome the original file system limits, it
	provides an extension mechanism that allows properly written
	CDs to exceed those limits while still working with systems
	that do not support those extensions.</para>

      <indexterm>
	<primary><filename
	  role="package">sysutils/cdrtools</filename></primary>
      </indexterm>

      <para>The <filename role="package">sysutils/cdrtools</filename>
	port includes &man.mkisofs.8;, a program that can be used to
	produce a data file containing an ISO 9660 file system.  It
	has options that support various extensions, and is described
	below.</para>

      <indexterm>
	<primary>CD burner</primary>
	<secondary>ATAPI</secondary>
      </indexterm>

      <para>Which tool to use to burn the CD depends on whether the
	CD burner is ATAPI or something else.  ATAPI CD burners use
	<command><link linkend="burncd">burncd</link></command>
	which is part of the base system.  SCSI and USB CD burners
	should use <command><link
	  linkend="cdrecord">cdrecord</link></command> from the
	<filename role="package">sysutils/cdrtools</filename> port.
	It is also possible to use <command><link
	  linkend="cdrecord">cdrecord</link></command> and other tools
	for SCSI drives on ATAPI hardware with the <link
	  linkend="atapicam">ATAPI/CAM module</link>.</para>

      <para>For CD burning software with a graphical user
	interface, consider <application>X-CD-Roast</application> or
	<application>K3b</application>.  These tools are available as
	packages or from the
	<filename role="package">sysutils/xcdroast</filename> and
	<filename role="package">sysutils/k3b</filename> ports.
	<application>X-CD-Roast</application> and
	<application>K3b</application> require the
	<link linkend="atapicam">ATAPI/CAM module</link> with ATAPI
	hardware.</para>
    </sect2>

    <sect2 id="mkisofs">
      <title><application>mkisofs</application></title>

      <para>The <filename role="package">sysutils/cdrtools</filename>
	port also installs &man.mkisofs.8;, which produces an ISO 9660
	file system that is an image of a directory tree in the &unix;
	file system name space.  The simplest usage is:</para>

      <screen>&prompt.root; <userinput>mkisofs -o <replaceable>imagefile.iso</replaceable> <replaceable>/path/to/tree</replaceable></userinput></screen>

      <indexterm>
	<primary>file systems</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>

      <para>This command creates an
	<replaceable>imagefile.iso</replaceable> containing an ISO
	9660 file system that is a copy of the tree at
	<replaceable>/path/to/tree</replaceable>.  In the process, it
	maps the file names to names that fit the limitations of
	the standard ISO 9660 file system, and will exclude files that
	have names uncharacteristic of ISO file systems.</para>

      <indexterm>
	<primary>file systems</primary>
	<secondary>HFS</secondary>
      </indexterm>
      <indexterm>
	<primary>file systems</primary>
	<secondary>Joliet</secondary>
      </indexterm>
      <para>A number of options are available to overcome these
	restrictions.  In particular, <option>-R</option> enables the
	Rock Ridge extensions common to &unix; systems,
	<option>-J</option> enables Joliet extensions used by
	Microsoft systems, and <option>-hfs</option> can be used to
	create HFS file systems used by &macos;.</para>

      <para>For CDs that are going to be used only on &os; systems,
	<option>-U</option> can be used to disable all filename
	restrictions.  When used with <option>-R</option>, it produces
	a file system image that is identical to the specified &os;
	tree, though it may violate the ISO 9660 standard in a number
	of ways.</para>

      <indexterm>
	<primary>CDROMs</primary>
	<secondary>creating bootable</secondary>
      </indexterm>
      <para>The last option of general use is <option>-b</option>.
	This is used to specify the location of the boot image for use
	in producing an <quote>El Torito</quote> bootable CD.  This
	option takes an argument which is the path to a boot image
	from the top of the tree being written to the CD.  By default,
	&man.mkisofs.8; creates an ISO image in <quote>floppy disk
	  emulation</quote> mode, and thus expects the boot image to
	be exactly 1200, 1440 or 2880&nbsp;KB in size.  Some boot
	loaders, like the one used by the &os; distribution disks, do
	not use emulation mode.  In this case,
	<option>-no-emul-boot</option> should be used.  So, if
	<filename class="directory">/tmp/myboot</filename> holds a
	bootable &os; system with the boot image in <filename
	  class="directory">/tmp/myboot/boot/cdboot</filename>, this
	command would produce the image of an ISO 9660 file system as
	<filename>/tmp/bootable.iso</filename>:</para>

      <screen>&prompt.root; <userinput>mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</userinput></screen>

      <para>If <devicename>md</devicename> is configured in the
	kernel, the file system can be mounted as a memory disk
	with:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>One can then verify that <filename
	  class="directory">/mnt</filename> and <filename
	  class="directory">/tmp/myboot</filename> are
	identical.</para>

      <para>There are many other options available for
	&man.mkisofs.8; to fine-tune its behavior.  Refer to
	&man.mkisofs.8; for details.</para>
    </sect2>

    <sect2 id="burncd">
      <title><application>burncd</application></title>

      <indexterm>
	<primary>CDROMs</primary>
	<secondary>burning</secondary>
      </indexterm>
      <para>For an ATAPI CD burner, <command>burncd</command> can be
	used to burn an ISO image onto a CD.
	<command>burncd</command> is part of the base system,
	installed as <filename>/usr/sbin/burncd</filename>.  Usage is
	very simple, as it has few options:</para>

      <screen>&prompt.root; <userinput>burncd -f <replaceable>cddevice</replaceable> data <replaceable>imagefile.iso</replaceable> fixate</userinput></screen>

      <para>This command will burn a copy of
	<replaceable>imagefile.iso</replaceable> on
	<replaceable>cddevice</replaceable>.  The default device is
	<filename>/dev/acd0</filename>.  See &man.burncd.8; for
	options to set the write speed, eject the CD after burning,
	and write audio data.</para>
    </sect2>

    <sect2 id="cdrecord">
      <title><application>cdrecord</application></title>

      <para>For systems without an ATAPI CD burner,
	<command>cdrecord</command> can be used to burn CDs.
	<command>cdrecord</command> is not part of the base system and
	must be installed from either the <filename
	  role="package">sysutils/cdrtools</filename> package or port.
	Changes to the base system can cause binary versions of this
	program to fail, possibly resulting in a
	<quote>coaster</quote>.  It is recommended to either upgrade
	the port when the system is upgraded, or for users
	<link linkend="stable">tracking -STABLE</link>, to upgrade the
	port when a new version becomes available.</para>

      <para>While <command>cdrecord</command> has many options, basic
	usage is simple.  Burning an ISO 9660 image is done
	with:</para>

      <screen>&prompt.root; <userinput>cdrecord dev=<replaceable>device</replaceable> <replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>The tricky part of using <command>cdrecord</command> is
	finding the <option>dev</option> to use.  To find the proper
	setting, use <option>-scanbus</option> which might produce
	results like this:</para>

      <indexterm>
	<primary>CDROMs</primary>
	<secondary>burning</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord-Clone 2.01 (i386-unknown-freebsd7.0) Copyright (C) 1995-2004 J&ouml;rg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>This lists the appropriate <option>dev</option> value for
	the devices on the list.  Locate the CD burner, and use the
	three numbers separated by commas as the value for
	<option>dev</option>.  In this case, the CRW device is 1,5,0,
	so the appropriate input is <option>dev=1,5,0</option>.
	Refer to &man.cdrecord.1; for easier ways to specify this
	value and for information on writing audio tracks and
	controlling the write speed.</para>
    </sect2>

    <sect2 id="duplicating-audiocds">
      <title>Duplicating Audio CDs</title>

      <para>To duplicate an audio CD, extract the audio data from the
	CD to a series of files, then write these files to a blank CD.
	The process is slightly different for ATAPI and SCSI
	drives.</para>

      <procedure>
	<title>SCSI Drives</title>

	<step>
	  <para>Use <command>cdda2wav</command> to extract the
	    audio:</para>

	  <screen>&prompt.user; <userinput>cdda2wav -vall -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
	  <para>Use <command>cdrecord</command> to write the
	    <filename>.wav</filename> files:</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=<replaceable>2,0</replaceable> -dao -useinfo  *.wav</userinput></screen>

	  <para>Make sure that <replaceable>2,0</replaceable> is set
	    appropriately, as described in <link
	      linkend="cdrecord"></link>.</para>
	</step>
      </procedure>

      <procedure>
	<title>ATAPI Drives</title>

	<note>
	  <para>With the help of the
	    <link linkend="atapicam">ATAPI/CAM module</link>,
	    <command>cdda2wav</command> can also be used on ATAPI
	    drives.  This tool is usually a better choice for most of
	    users, as it supports jitter correction and endianness,
	    than the method proposed below.</para>
	</note>

	<step>
	  <para>The ATAPI CD driver makes each track available as
	    <filename>/dev/acd<replaceable>d</replaceable>t<replaceable>nn</replaceable></filename>,
	    where <replaceable>d</replaceable> is the drive number,
	    and <replaceable>nn</replaceable> is the track number
	    written with two decimal digits, prefixed with zero as
	    needed.  So the first track on the first disk is
	    <filename>/dev/acd0t01</filename>, the second is
	    <filename>/dev/acd0t02</filename>, the third is
	    <filename>/dev/acd0t03</filename>, and so on.</para>

	  <para>Make sure the appropriate files exist in
	    <filename>/dev</filename>.  If the entries are missing,
	    force the system to retaste the media:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=/dev/null count=1</userinput></screen>
	</step>

	<step>
	  <para>Extract each track using &man.dd.1;, making sure to
	    specify a block size when extracting the files:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t01 of=track1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t02 of=track2.cdr bs=2352</userinput>
...</screen>
	</step>

	<step>
	  <para>Burn the extracted files to disk using
	    <command>burncd</command>.  Specify that these are audio
	    files, and that <command>burncd</command> should fixate
	    the disk when finished:</para>

	  <screen>&prompt.root; <userinput>burncd -f <replaceable>/dev/acd0</replaceable> audio track1.cdr track2.cdr <replaceable>...</replaceable> fixate</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 id="imaging-cd">
      <title>Duplicating Data CDs</title>

      <para>It is possible to copy a data CD to an image file that is
	functionally equivalent to the image file created with
	&man.mkisofs.8;, and then use it to duplicate any data CD.
	The example given here assumes that the CDROM device is
	<devicename>acd0</devicename>.  Substitute the correct CDROM
	device.</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=file.iso bs=2048</userinput></screen>

      <para>Now that there is an image, it can be burned to CD as
	described above.</para>
    </sect2>

    <sect2 id="mounting-cd">
      <title>Using Data CDs</title>

      <para>It is possible to mount and read the data on a standard
	data CD.  By default, &man.mount.8; assumes that a file system
	is of type <literal>ufs</literal>.  Running this
	command:</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0 /mnt</userinput></screen>

      <para>will generate an error about <errorname>Incorrect super
	  block</errorname>, and will fail to mount the CD.  The CD
	  does not use the <literal>UFS</literal> file system, so
	  attempts to mount it as such will fail.  Instead, tell
	  &man.mount.8; that the file system is of type
	  <literal>ISO9660</literal> by specifying
	  <option>-t cd9660</option> to &man.mount.8;.  For example,
	  to mount the CDROM device, <filename>/dev/cd0</filename>,
	  under <filename class="directory">/mnt</filename>,
	  use:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Replace <filename>/dev/cd0</filename> with the device
	name for the CD device.  Also, <option>-t cd9660</option>
	executes &man.mount.cd9660.8;, meaning the above command is
	equivalent to:</para>

      <screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>While data CDROMs from any vendor can be mounted this way,
	disks with certain ISO 9660 extensions might behave oddly.
	For example, Joliet disks store all filenames in two-byte
	Unicode characters.  The &os; kernel does not speak Unicode,
	but the &os; CD9660 driver is able to convert Unicode
	characters on the fly.  If some non-English characters show up
	as question marks, specify the local charset with
	<option>-C</option>.  For more information, refer to
	&man.mount.cd9660.8;.</para>

      <note>
	<para>In order to do this character conversion with the help
	  of <option>-C</option>, the kernel requires the
	  <filename>cd9660_iconv.ko</filename> module to be loaded.
	  This can be done either by adding this line to
	  <filename>loader.conf</filename>:</para>

	<programlisting>cd9660_iconv_load="YES"</programlisting>

	<para>and then rebooting the machine, or by directly loading
	  the module with &man.kldload.8;.</para>
      </note>

      <para>Occasionally, <errorname>Device not configured</errorname>
	will be displayed when trying to mount a CDROM.  This
	usually means that the CDROM drive thinks that there is no
	disk in the tray, or that the drive is not visible on the bus.
	It can take a couple of seconds for a CDROM drive to realize
	that a media is present, so be patient.</para>

      <para>Sometimes, a SCSI CDROM may be missed because it did not
	have enough time to answer the bus reset.  To resolve this,add
	the following option to the kernel configuration and <link
	  linkend="kernelconfig-building">rebuild the
	  kernel</link>.</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>This tells the SCSI bus to pause 15 seconds during boot,
	to give the CDROM drive every possible chance to answer the
	bus reset.</para>
    </sect2>

    <sect2 id="rawdata-cd">
      <title>Burning Raw Data CDs</title>

      <para>It is possible to burn a file directly to CD, without
	creating an ISO 9660 file system.  Some people do this for
	backup purposes.  This command runs more quickly than burning
	a standard CD:</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate</userinput></screen>

      <para>In order to retrieve the data burned to such a CD, the
	data must be read from the raw device node:</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1</userinput></screen>

      <para>This type of disk can not be mounted as a normal CDROM and
	the data cannot be read under any operating system except
	&os;.  In order to mount the CD, or to share the data with
	another operating system, &man.mkisofs.8; must be used as
	described above.</para>
    </sect2>

    <sect2 id="atapicam">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Using the ATAPI/CAM Driver</title>

      <indexterm>
	<primary>CD burner</primary>
	<secondary>ATAPI/CAM driver</secondary>
      </indexterm>

      <para>This driver allows ATAPI devices, such as CD/DVD drives,
	to be accessed through the SCSI subsystem, and so allows the
	use of applications like <filename
	  role="package">sysutils/cdrdao</filename> or
	&man.cdrecord.1;.</para>

      <para>To use this driver, add the following line to
	<filename>/boot/loader.conf</filename>:</para>

      <programlisting>atapicam_load="YES"</programlisting>

      <para>then, reboot the system.</para>

      <note>
	<para>Users who prefer to statically compile &man.atapicam.4;
	  support into the kernel, should add this line to the
	  kernel configuration file:</para>

	<programlisting>device atapicam</programlisting>

	<para>Ensure the following lines are still in the kernel
	  configuration file:</para>

	<programlisting>device ata
device scbus
device cd
device pass</programlisting>

	<para>Then rebuild, install the new kernel, and reboot the
	  machine.</para>
      </note>

      <para>During the boot process, the burner should show up, like
	so:</para>

      <screen>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</screen>

      <para>The drive can now be accessed via the
	<filename>/dev/cd0</filename> device name.  For example, to
	mount a CD-ROM on <filename class="directory">/mnt</filename>,
	type the following:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 <replaceable>/dev/cd0</replaceable> /mnt</userinput></screen>

      <para>As <username>root</username>, run the following command
	to get the SCSI address of the burner:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 (pass0,cd0)</screen>

      <para>In this example, <literal>1,0,0</literal> is the SCSI
	address to use with &man.cdrecord.1; and other SCSI
	applications.</para>

      <para>For more information about ATAPI/CAM and SCSI system,
	refer to &man.atapicam.4; and &man.cam.4;.</para>
    </sect2>
  </sect1>

  <sect1 id="creating-dvds">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Andy</firstname>
	  <surname>Polyakov</surname>
	  <contrib>With inputs from </contrib>
	</author>
      </authorgroup>
      <!-- Feb 2004 -->
    </sect1info>

    <title>Creating and Using DVD Media</title>

    <indexterm>
      <primary>DVD</primary>
      <secondary>burning</secondary>
    </indexterm>

    <sect2>
      <title>Introduction</title>

      <para>Compared to the CD, the DVD is the next generation of
	optical media storage technology.  The DVD can hold more data
	than any CD and is the standard for video publishing.</para>

      <para>Five physical recordable formats can be defined for a
	recordable DVD:</para>

      <itemizedlist>
	<listitem>
	  <para>DVD-R: This was the first DVD recordable format
	    available.  The DVD-R standard is defined by the
	    <ulink url="http://www.dvdforum.com/forum.shtml">DVD
	      Forum</ulink>.  This format is write once.</para>
	</listitem>

	<listitem>
	  <para>DVD-RW: This is the rewritable version of the
	    DVD-R standard.  A DVD-RW can be rewritten about 1000
	    times.</para>
	</listitem>

	<listitem>
	  <para>DVD-RAM: This is a rewritable format which can be seen
	    as a removable hard drive.  However, this media is not
	    compatible with most DVD-ROM drives and DVD-Video players
	    as only a few DVD writers support the DVD-RAM format.
	    Refer to <link linkend="creating-dvd-ram"></link> for more
	    information on DVD-RAM use.</para>
	</listitem>

	<listitem>
	  <para>DVD+RW: This is a rewritable format defined by
	    the <ulink url="http://www.dvdrw.com/">DVD+RW
	    Alliance</ulink>.  A DVD+RW can be rewritten about 1000
	    times.</para>
	</listitem>

	<listitem>
	  <para>DVD+R: This format is the write once variation
	    of the DVD+RW format.</para>
	</listitem>
      </itemizedlist>

      <para>A single layer recordable DVD can hold up to
	4,700,000,000&nbsp;bytes which is actually 4.38&nbsp;GB or
	4485&nbsp;MB as 1 kilobyte is 1024 bytes.</para>

      <note>
	<para>A distinction must be made between the physical media
	  and the application.  For example, a DVD-Video is a specific
	  file layout that can be written on any recordable DVD
	  physical media such as DVD-R, DVD+R, or DVD-RW.  Before
	  choosing the type of media, ensure that both the burner and
	  the DVD-Video player are compatible with the media under
	  consideration.</para>
      </note>
    </sect2>

    <sect2>
      <title>Configuration</title>

      <para>To perform DVD recording, use &man.growisofs.1;.  This
	command is part of the <filename
	  role="package">sysutils/dvd+rw-tools</filename> utilities
	which support all DVD media types.</para>

      <para>These tools use the SCSI subsystem to access the devices,
	therefore <link linkend="atapicam">ATAPI/CAM support</link>
	must be loaded or statically compiled into the kernel.  This
	support is not needed if the burner uses the USB interface.
	Refer to <link linkend="usb-disks"></link> for more details
	on USB device configuration.</para>

      <para>DMA access must also be enabled for ATAPI devices, by
	adding the following line to
	<filename>/boot/loader.conf</filename>:</para>

      <programlisting>hw.ata.atapi_dma="1"</programlisting>

      <para>Before attempting to use
	<application>dvd+rw-tools</application>, consult the
	<ulink
	  url="http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html">Hardware
	  Compatibility Notes</ulink>.</para>

      <note>
	<para>For a graphical user interface, consider using <filename
	    role="package">sysutils/k3b</filename> which provides a
	  user friendly interface to &man.growisofs.1; and many other
	  burning tools.</para>
      </note>
    </sect2>

    <sect2>
      <title>Burning Data DVDs</title>

      <para>Since &man.growisofs.1; is a front-end to <link
	  linkend="mkisofs">mkisofs</link>, it will invoke
	&man.mkisofs.8; to create the file system layout and perform
	the write on the DVD.  This means that an image of the data
	does not need to be created before the burning process.</para>

      <para>To burn to a DVD+R or a DVD-R the data in
	<filename class="directory">/path/to/data</filename>,
	use the following command:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable></userinput></screen>

      <para>In this example, <option>-J -R</option> is passed to
	&man.mkisofs.8;  to create an ISO 9660 file system with Joliet
	and Rock Ridge extensions.  Refer to &man.mkisofs.8; for more
	details.</para>

      <para>For the initial session recording, <option>-Z</option> is
	used for both single and multiple sessions.  Replace
	<replaceable>/dev/cd0</replaceable>, with the name of the DVD
	device.  Using <option>-dvd-compat</option> indicates that the
	disk will be closed and that the recording will be
	unappendable.  This should also provide better media
	compatibility with DVD-ROM drives.</para>

      <para>To burn a pre-mastered image, such as
	<replaceable>imagefile.iso</replaceable>, use:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z <replaceable>/dev/cd0</replaceable>=<replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>The write speed should be detected and automatically set
	according to the media and the drive being used.  To force the
	write speed, use  <option>-speed=</option>.  Refer to
	&man.growisofs.1; for example usage.</para>

      <note>
	<para>In order to support working files larger than 4.38GB, an
	  UDF/ISO-9660 hybrid filesystem must be created by passing
	  <option>-udf -iso-level 3</option> to &man.mkisofs.8; and
	  all related programs, such as &man.growisofs.1;.  This is
	  required only when creating an ISO image file or when
	  writing files directly to a disk.  Since a disk created this
	  way must be mounted as an UDF filesystem with
	  &man.mount.udf.8;, it will be usable only on an UDF aware
	  operating system.  Otherwise it will look as if it contains
	  corrupted files.</para>

	<para>To create this type of ISO file:</para>

	<screen>&prompt.user; <userinput>mkisofs -R -J -udf -iso-level 3 -o <replaceable>imagefile.iso</replaceable> <replaceable>/path/to/data</replaceable></userinput></screen>

	<para>To burn files directly to a disk:</para>

	<screen>&prompt.root; <userinput>growisofs -dvd-compat -udf -iso-level 3 -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable></userinput></screen>

	<para>When an ISO image already contains large files, no
	  additional options are required for &man.growisofs.1; to
	  burn that image on a disk.</para>

	<para>Be sure to use an up-to-date version of <filename
	    role="package">sysutils/cdrtools</filename>, which
	  contains &man.mkisofs.8;, as an older version may not
	  contain large files support.  If the latest version does
	  not work, install <filename
	    role="package">sysutils/cdrtools-devel</filename> and read
	  its &man.mkisofs.8;.</para>
      </note>
    </sect2>

    <sect2>
      <title>Burning a DVD-Video</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-Video</secondary>
      </indexterm>

      <para>A DVD-Video is a specific file layout based on the ISO
	9660 and micro-UDF (M-UDF) specifications.  Since DVD-Video
	presents a specific data structure hierarchy, a particular
	program such as <filename
	  role="package">multimedia/dvdauthor</filename> is needed to
	author the DVD.</para>

      <para>If an image of the DVD-Video file system already exists,
	it can be burned in the same way as any other image.  If
	<command>dvdauthor</command> was used to make the DVD and the
	result is in <filename
	  class="directory">/path/to/video</filename>, the following
	command should be used to burn the DVD-Video:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -dvd-video <replaceable>/path/to/video</replaceable></userinput></screen>

      <para><option>-dvd-video</option> is passed to &man.mkisofs.8;
	to instruct it to create a DVD-Video file system layout.
	This option implies the <option>-dvd-compat</option>
	&man.growisofs.1; option.</para>
    </sect2>

    <sect2>
      <title>Using a DVD+RW</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD+RW</secondary>
      </indexterm>

      <para>Unlike CD-RW, a virgin DVD+RW needs to be formatted before
	first use.  It is <emphasis>recommended</emphasis> to let
	&man.growisofs.1; take care of this automatically whenever
	appropriate.  However, it is possible to use
	<command>dvd+rw-format</command> to format the DVD+RW:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format <replaceable>/dev/cd0</replaceable></userinput></screen>

      <para>Only perform this operation once and keep in mind that
	only virgin DVD+RW medias need to be formatted.  Once
	formatted, the DVD+RW can be burned as usual.</para>

      <para>To burn a totally new file system and not just append some
	data onto a DVD+RW, the media does not need to be blanked
	first.  Instead, write over the previous recording like
	this:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/newdata</replaceable></userinput></screen>

      <para>The DVD+RW format supports appending data to a previous
	recording.  This operation consists of merging a new session
	to the existing one as it is not considered to be
	multi-session writing.  &man.growisofs.1; will
	<emphasis>grow</emphasis> the ISO 9660 file system present on
	the media.</para>

      <para>For example, to append data to a DVD+RW, use the
	following:</para>

      <screen>&prompt.root; <userinput>growisofs -M <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/nextdata</replaceable></userinput></screen>

      <para>The same &man.mkisofs.8; options used to burn the
	initial session should be used during next writes.</para>

      <note>
	<para>Use <option>-dvd-compat</option> for better media
	  compatibility with DVD-ROM drives.  When using DVD+RW, this
	  option will not prevent the addition of data.</para>
      </note>

      <para>To blank the media, use:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable>=<replaceable>/dev/zero</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>Using a DVD-RW</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-RW</secondary>
      </indexterm>

      <para>A DVD-RW accepts two disc formats: incremental sequential
	and restricted overwrite.  By default, DVD-RW discs are in
	sequential format.</para>

      <para>A virgin DVD-RW can be directly written without being
	formatted.  However, a non-virgin DVD-RW in sequential format
	needs to be blanked before writing a new initial
	session.</para>

      <para>To blank a DVD-RW in sequential mode:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full <replaceable>/dev/cd0</replaceable></userinput></screen>

      <note>
	<para>A full blanking using <option>-blank=full</option> will
	  take about one hour on a 1x media.  A fast blanking can be
	  performed using <option>-blank</option>, if the DVD-RW will
	  be recorded in Disk-At-Once (DAO) mode.  To burn the DVD-RW
	  in DAO mode, use the command:</para>

	<screen>&prompt.root; <userinput>growisofs -use-the-force-luke=dao -Z <replaceable>/dev/cd0</replaceable>=<replaceable>imagefile.iso</replaceable></userinput></screen>

	<para>Since &man.growisofs.1; automatically attempts to detect
	  fast blanked media and engage DAO write,
	  <option>-use-the-force-luke=dao</option> should not be
	  required.</para>

	<para>One should instead use restricted overwrite mode with
	  any DVD-RW as this format is more flexible than the default
	  of incremental sequential.</para>
      </note>

      <para>To write data on a sequential DVD-RW, use the same
	instructions as for the other DVD formats:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable></userinput></screen>

      <para>To append some data to a previous recording, use
	<option>-M</option> with &man.growisofs.1;.  However, if data
	is appended on a DVD-RW in incremental sequential mode, a new
	session will be created on the disc and the result will be a
	multi-session disc.</para>

      <para>A DVD-RW in restricted overwrite format does not need to
	be blanked before a new initial session.  Instead, overwrite
	the disc with <option>-Z</option>.  It is also possible to
	grow an existing ISO 9660 file system written on the disc with
	<option>-M</option>.  The result will be a one-session
	DVD.</para>

      <para>To put a DVD-RW in restricted overwrite format, the
	following command must be used:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format <replaceable>/dev/cd0</replaceable></userinput></screen>

      <para>To change back to sequential format, use:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full <replaceable>/dev/cd0</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>Multi-Session</title>

      <para>Few DVD-ROM drives support multi-session DVDs and most of
	the time only read the first session.  DVD+R, DVD-R and DVD-RW
	in sequential format can accept multiple sessions.  The notion
	of multiple sessions does not exist for the DVD+RW and the
	DVD-RW restricted overwrite formats.</para>

      <para>Using the following command after an initial non-closed
	session on a DVD+R, DVD-R, or DVD-RW in sequential format,
	will add a new session to the disc:</para>

      <screen>&prompt.root; <userinput>growisofs -M <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/nextdata</replaceable></userinput></screen>

      <para>Using this command with a DVD+RW or a DVD-RW in restricted
	overwrite mode will append data while merging the new session
	to the existing one.  The result will be a single-session
	disc.  Use this method to add data after an initial write on
	these types of media.</para>

      <note>
	<para>Since some space on the media is used between each
	  session to mark the end and start of sessions, one should
	  add sessions with a large amount of data to optimize media
	  space.  The number of sessions is limited to 154 for a
	  DVD+R, about 2000 for a DVD-R, and 127 for a DVD+R Double
	  Layer.</para>
      </note>
    </sect2>

    <sect2>
      <title>For More Information</title>

      <para>To obtain more information about a DVD, use
	<command>dvd+rw-mediainfo
	  <replaceable>/dev/cd0</replaceable></command> while the disc
	in the specified drive.</para>

      <para>More information about
	<application>dvd+rw-tools</application> can be found in
	 &man.growisofs.1;, on the <ulink
	  url="http://fy.chalmers.se/~appro/linux/DVD+RW/">dvd+rw-tools
	web site</ulink>, and in the <ulink
	  url="http://lists.debian.org/cdwrite/">cdwrite mailing
	  list</ulink> archives.</para>

      <note>
	<para>When creating a problem report related to the use of
	  <application>dvd+rw-tools</application>, always include the
	  output of <command>dvd+rw-mediainfo</command>.</para>
      </note>
    </sect2>

    <sect2 id="creating-dvd-ram">
      <title>Using a DVD-RAM</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-RAM</secondary>
      </indexterm>

      <sect3>
	<title>Configuration</title>

	<para>DVD-RAM writers can use either a SCSI or ATAPI
	  interface.  For ATAPI devices, DMA access has to be
	  enabled by adding the following line to
	  <filename>/boot/loader.conf</filename>:</para>

	<programlisting>hw.ata.atapi_dma="1"</programlisting>
      </sect3>

      <sect3>
	<title>Preparing the Media</title>

	<para>A DVD-RAM can be seen as a removable hard drive.  Like
	  any other hard drive, the DVD-RAM must be formatted before
	  it can be used.  In this example, the whole disk space will
	  be formatted with a standard UFS2 file system:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/dev/acd0</replaceable> bs=2k count=1</userinput>
&prompt.root; <userinput>bsdlabel -Bw <replaceable>acd0</replaceable></userinput>
&prompt.root; <userinput>newfs <replaceable>/dev/acd0</replaceable></userinput></screen>

	<para>The DVD device, <devicename>acd0</devicename>, must be
	  changed according to the configuration.</para>
      </sect3>

      <sect3>
	<title>Using the Media</title>

	<para>Once the DVD-RAM has been formatted, it can be mounted
	  as a normal hard drive:</para>

	<screen>&prompt.root; <userinput>mount <replaceable>/dev/acd0</replaceable> <replaceable>/mnt</replaceable></userinput></screen>

	<para>Once mounted, the DVD-RAM will be both readable and
	  writeable.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="floppies">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Julio</firstname>
	  <surname>Merino</surname>
	  <contrib>Original work by </contrib>
	</author>
      </authorgroup>
      <!-- 24 Dec 2001 -->
      <authorgroup>
	<author>
	  <firstname>Martin</firstname>
	  <surname>Karlsson</surname>
	  <contrib>Rewritten by </contrib>
	</author>
      </authorgroup>
      <!-- 27 Apr 2003 -->
    </sect1info>

    <title>Creating and Using Floppy Disks</title>

    <para>Storing data on floppy disks is sometimes useful, for
      example when one does not have any other removable storage media
      or when one needs to transfer small amounts of data to another
      computer.</para>

    <para>This section explains how to use floppy disks in &os;.  It
      covers formatting and usage of 3.5inch DOS floppies, but the
      concepts are similar for other floppy disk formats.</para>

    <sect2>
      <title>Formatting Floppies</title>

      <sect3>
	<title>The Device</title>

	<para>Floppy disks are accessed through entries in
	  <filename class="directory">/dev</filename>, just like other
	  devices.  To access the raw floppy disk, simply use
	  <filename>/dev/fd<replaceable>N</replaceable></filename>.</para>
      </sect3>

      <sect3>
	<title>Formatting</title>

	<para>A floppy disk needs to be low-level formatted before it
	  can be used.  This is usually done by the vendor, but
	  formatting is a good way to check media integrity.  Although
	  it is possible to force other disk sizes, 1440kB is what
	  most floppy disks are designed for.</para>

	<para>To low-level format the floppy disk, use
	  &man.fdformat.1;.  This utility expects the device name as
	  an argument.</para>

	<para>Make note of any error messages, as these can help
	  determine if the disk is good or bad.</para>

	<sect4>
	  <title>Formatting Floppy Disks</title>

	  <para>To format the floppy, insert a new 3.5inch floppy
	    disk into the first floppy drive and issue:</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat -f 1440 /dev/fd0</userinput></screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>The Disk Label</title>

      <para>After low-level formatting the disk, a disk label needs to
	placed  on it.  This disk label will be destroyed later, but
	it is needed by the system to determine the size of the disk
	and its geometry.</para>

      <para>The new disk label will take over the whole disk and will
	contain all the proper information about the geometry of the
	floppy.  The geometry values for the disk label are listed in
	<filename>/etc/disktab</filename>.</para>

      <para>To write the disk label, use &man.bsdlabel.8;:</para>

      <screen>&prompt.root; <userinput>/sbin/bsdlabel -B -w /dev/fd0 fd1440</userinput></screen>
    </sect2>

    <sect2>
      <title>The File System</title>

      <para>The floppy is now ready to be high-level formatted.  This
	will place a new file system on it so that &os; can read and
	write to the disk.  Since creating the new file system
	destroys the disk label, the disk label needs to be recreated
	whenever the disk is reformatted.</para>

      <para>The floppy's file system can be either UFS or FAT.
	FAT is generally a better choice for floppies.</para>

      <para>To put a new file system on the floppy, issue:</para>

      <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>

      <para>The disk is now ready for use.</para>
    </sect2>

    <sect2>
      <title>Using the Floppy</title>

      <para>To use the floppy, mount it with &man.mount.msdosfs.8;.
	One can also use
	<filename role="package">emulators/mtools</filename> from the
	Ports Collection.</para>
    </sect2>
  </sect1>

  <sect1 id="backups-tapebackups">
    <title>Creating and Using Data Tapes</title>

    <indexterm><primary>tape media</primary></indexterm>

    <para>Tape technology has continued to evolve but is less likely
      to be used in a modern system.  Modern backup systems tend to
      use off site combined with local removable disk drive
      technologies.  Still, &os; will support any tape drive that
      uses SCSI, such as LTO and older devices such as DAT.  There is
      limited support for SATA and USB tape drives.</para>

    <sect2 id="tapes-sa0">
      <title>Serial Access with &man.sa.4;</title>

      <indexterm>
	<primary>tape drives</primary>
      </indexterm>

      <para>&os; uses the &man.sa.4; driver, providing
	<devicename>/dev/sa0</devicename>,
	<devicename>/dev/nsa0</devicename>, and
	<devicename>/dev/esa0</devicename>.  In normal use, only
	<devicename>/dev/sa0</devicename> is needed.
	<devicename>/dev/nsa0</devicename> is the same physical drive
	as <devicename>/dev/sa0</devicename> but does not rewind the
	tape after writing a file.  This allows writing more than one
	file to a tape.  Using <devicename>/dev/esa0</devicename>
	ejects the tape after the device is closed, if
	applicable.</para>
    </sect2>

    <sect2>
      <title id="tapes-mt">Controlling the Tape Drive with
	&man.mt.1;</title>

      <indexterm>
	<primary>tape media</primary>
	<secondary>mt</secondary>
      </indexterm>

      <para>&man.mt.1; is the &os; utility for controlling other
	operations of the tape drive, such as seeking through files on
	a tape or writing tape control marks to the tape.</para>

      <para>For example, the first three files on a tape can be
	preserved by skipping past them before writing a new
	file:</para>

      <screen>&prompt.root; <userinput>mt -f /dev/nsa0 fsf 3</userinput></screen>
    </sect2>

    <sect2>
      <title id="tapes-tar">Using &man.tar.1; to Read and
	Write Tape Backups</title>

      <para>An example of writing a single file to tape using
	&man.tar.1;:</para>

      <screen>&prompt.root; <userinput>tar cvf /dev/sa0 <replaceable>file</replaceable></userinput></screen>

      <para>Recovering files from a &man.tar.1; archive on tape into
	the current directory:</para>

      <screen>&prompt.root; <userinput>tar xvf /dev/sa0</userinput></screen>
    </sect2>

    <sect2>
      <title id="tapes-dumprestore">Using &man.dump.8; and
	&man.restore.8; to Create and Restore Backups</title>

      <para>A simple backup of <filename
	  class="directory">/usr</filename> with &man.dump.8;:</para>

      <screen>&prompt.root; <userinput>dump -0aL -b64 -f /dev/nsa0 /usr</userinput></screen>

      <para>Interactively restoring files from a &man.dump.8; file on
	tape into the current directory:</para>

      <screen>&prompt.root; <userinput>restore -i -f /dev/nsa0</userinput></screen>
    </sect2>

    <sect2>
      <title id="tapes-othersofware">Other Tape Software</title>

      <para>Higher-level programs are available to simplify tape
	backup.  The most popular are
	<application>Amanda</application> and
	<application>Bacula</application>.  These programs aim to make
	backups easier and more convenient, or to automate complex
	backups of multiple machines.  The Ports Collection contains
	both these and other tape utility applications.</para>
    </sect2>
  </sect1>

  <sect1 id="backups-floppybackups">
    <title>Backups to Floppies</title>

    <sect2 id="floppies-using">
      <title>Can I Use Floppies for Backing Up My Data?</title>

      <indexterm><primary>backup floppies</primary></indexterm>
      <indexterm><primary>floppy disks</primary></indexterm>

      <para>Floppy disks are not a suitable media for making backups
	as:</para>

      <itemizedlist>
	<listitem>
	  <para>The media is unreliable, especially over long periods
	    of time.</para>
	</listitem>

	<listitem>
	  <para>Backing up and restoring is very slow.</para>
	</listitem>

	<listitem>
	  <para>They have a very limited capacity.</para>
	</listitem>
      </itemizedlist>

      <para>However, if no other method of backing up data is
	available, floppy disks are better than no backup at
	all.</para>

      <para>When backing up to floppy disks, ensure the floppies are
	of good quality.  Floppies that have been lying around the
	office for a couple of years are a bad choice.  Ideally,
	use new ones from a reputable manufacturer.</para>
    </sect2>

    <sect2 id="floppies-creating">
      <title>So How Do I Backup My Data to Floppies?</title>

      <para>The best way to backup to floppy disk is to use
	&man.tar.1; with <option>-M</option> (multi-volume), which
	allows backups to span multiple floppies.</para>

      <para>To backup all the files in the current directory and
	sub-directory, use this as <username>root</username>:</para>

      <screen>&prompt.root; <userinput>tar Mcvf /dev/fd0 *</userinput></screen>

      <para>When the first floppy is full, &man.tar.1; will prompt
	to insert the next volume, which in this case is the next
	floppy disk:</para>

      <screen>Prepare volume #2 for /dev/fd0 and hit return:</screen>

      <para>This is repeated, with the volume number incrementing,
	until all the specified files have been archived.</para>
    </sect2>

    <sect2 id="floppies-compress">
      <title>Can I Compress My Backups?</title>

      <indexterm>
	<primary><command>tar</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>gzip</command></primary>
      </indexterm>
      <indexterm><primary>compression</primary></indexterm>

      <para>Unfortunately, &man.tar.1; does not support
	<option>-z</option> for multi-volume archives.  Instead,
	&man.gzip.1; all the files, &man.tar.1; them to the floppies,
	then &man.gunzip.1; the files.</para>
    </sect2>

    <sect2 id="floppies-restoring">
      <title>How Do I Restore My Backups?</title>

      <para>To restore the entire archive use:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0</userinput></screen>

      <para>There are two methods to restore only specific files.  The
	first is to insert the first floppy and use:</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0 <replaceable>filename</replaceable></userinput></screen>

      <para>&man.tar.1; will prompt to insert subsequent floppies
	until it finds the required file.</para>

      <para>Alternatively, if the floppy containing the file is known,
	insert that floppy and use the same command.  If the first
	file on the floppy is a continuation from the previous one,
	&man.tar.1; will warn that it cannot restore it, even if you
	have not asked it to.</para>
    </sect2>
  </sect1>

  <sect1 id="backup-strategies">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Lowell</firstname>
	  <surname>Gilbert</surname>
	  <contrib>Original work by </contrib>
	</author>
      </authorgroup>
      <!-- 3 Dec 2005 -->
    </sect1info>

    <title>Backup Strategies</title>

    <para>The first requirement in devising a backup plan is to make
      sure that all of the following problems are covered:</para>

    <itemizedlist>
      <listitem>
	<para>Disk failure.</para>
      </listitem>

      <listitem>
	<para>Accidental file deletion.</para>
      </listitem>

      <listitem>
	<para>Random file corruption.</para>
      </listitem>

      <listitem>
	<para>Complete machine destruction, say by fire, including
	  destruction of any on-site backups.</para>
      </listitem>
    </itemizedlist>

    <para>Some systems will be best served by having each of these
      problems covered by a completely different technique.  Except
      for strictly personal systems with low-value data, it is
      unlikely that one technique will cover all of them.</para>

    <para>Some possible techniques include:</para>

    <itemizedlist>
      <listitem>
	<para>Archives of the whole system, backed up onto permanent,
	  off-site media.  This provides protection against all of the
	  problems listed above, but is slow and inconvenient to
	  restore from.  Copies of the backups can be stored on site
	  or online, but there will still be inconveniences in
	  restoring files, especially for non-privileged users.</para>
      </listitem>

      <listitem>
	<para>Filesystem snapshots, which are really only helpful in
	  the accidental file deletion scenario, but can be
	  <emphasis>very</emphasis> helpful in that case, as well as
	  quick and easy to deal with.</para>
      </listitem>

      <listitem>
	<para>Copies of whole file systems or disks which can be
	  created with a periodic <filename
	    role="package">net/rsync</filename> of the whole machine.
	  This is generally most useful in networks with unique
	  requirements.  For general protection against disk failure,
	  this is usually inferior to <acronym>RAID</acronym>.  For
	  restoring accidentally deleted files, it can be comparable
	  to <acronym>UFS</acronym> snapshots.</para>
      </listitem>

      <listitem>
	<para><acronym>RAID</acronym>, which minimizes or avoids
	  downtime when a disk fails at the expense of having to deal
	  with disk failures more often, because there are more disks,
	  albeit at a much lower urgency.</para>
      </listitem>

      <listitem>
	<para>Checking fingerprints of files using &man.mtree.8;.
	  Although this is not a backup, this technique indicates
	  when one needs to resort to backups.  This is particularly
	  important for offline backups, and should be checked
	  periodically.</para>
      </listitem>
    </itemizedlist>

    <para>It is quite easy to come up with more techniques, many
      of them variations on the ones listed above.  Specialized
      requirements usually lead to specialized techniques.  For
      example, backing up a live database usually requires a method
      particular to the database software as an intermediate step.
      The important thing is to know which dangers should be protected
      against, and how each will be handled.</para>
  </sect1>

  <sect1 id="backup-basics">
    <title>Backup Basics</title>

    <para>The major backup programs built into &os; are
      &man.dump.8;, &man.tar.1;, &man.cpio.1;, and
      &man.pax.1;.</para>

    <sect2>
      <title>Dump and Restore</title>

      <indexterm>
	<primary>backup software</primary>
	<secondary>dump / restore</secondary>
      </indexterm>
      <indexterm>
	<primary><command>dump</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>restore</command></primary>
      </indexterm>

      <para>The traditional &unix; backup programs are
	<command>dump</command> and <command>restore</command>.  They
	operate on the drive as a collection of disk blocks, below the
	abstractions of files, links and directories that are created
	by the file systems.  Unlike other backup software,
	<command>dump</command> backs up an entire file system on a
	device.  It is unable to backup only part of a file system or
	a directory tree that spans more than one file system.
	<command>dump</command> does not write files and directories,
	but rather writes the raw data blocks that comprise files and
	directories.  When used to extract data,
	<command>restore</command> stores temporary
	files in <filename class="directory">/tmp/</filename> by
	default.  When using a recovery disk with a small <filename
	  class="directory">/tmp</filename>, set
	<envar>TMPDIR</envar> to a directory with more free space in
	order for the restore to succeed.</para>

      <note>
	<para>If <command>dump</command> is used on the root
	  directory, it will not back up <filename
	    class="directory">/home</filename>,
	  <filename class="directory">/usr</filename> or many other
	  directories since these are typically mount points for other
	  file systems or symbolic links into those file
	  systems.</para>
      </note>

      <para><command>dump</command> has quirks that remain from its
	early days in Version 6 of AT&amp;T &unix;,circa 1975.  The
	default parameters are suitable for 9-track tapes (6250 bpi),
	not the high-density media available today (up to 62,182
	ftpi).  These defaults must be overridden on the command line
	to utilize the capacity of current tape drives.</para>

      <indexterm>
	<primary><filename>.rhosts</filename></primary>
      </indexterm>
      <para>It is also possible to backup data across the network to a
	tape drive attached to another computer with
	<command>rdump</command> and <command>rrestore</command>.
	Both programs rely upon &man.rcmd.3; and &man.ruserok.3; to
	access the remote tape drive.  Therefore, the user performing
	the backup must be listed in <filename>.rhosts</filename> on
	the remote computer.  The arguments to
	<command>rdump</command> and <command>rrestore</command> must
	be suitable to use on the remote computer.  For example, to
	<command>rdump</command> from a &os; computer to an Exabyte
	tape drive connected to a host called
	<hostid>komodo</hostid>, use:</para>

      <screen>&prompt.root; <userinput>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2>&amp;1</userinput></screen>

      <para>There are security implications to allowing
	<filename>.rhosts</filename> authentication, so use
	with caution.</para>

      <para>It is also possible to use <command>dump</command> and
	<command>restore</command> in a more secure fashion over
	<command>ssh</command>.</para>

      <example>
	<title>Using <command>dump</command> over
	  <application>ssh</application></title>

	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</userinput></screen>
      </example>

      <para>Or, use the built-in <envar>RSH</envar>:</para>

      <example>
	<title>Using <command>dump</command> over
	  <application>ssh</application> with <envar>RSH</envar>
	  Set</title>

	<screen>&prompt.root; <userinput>env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr</userinput></screen>
      </example>
    </sect2>

    <sect2>
      <title><command>tar</command></title>

      <indexterm>
	<primary>backup software</primary>
	<secondary><command>tar</command></secondary>
      </indexterm>

      <para>&man.tar.1; also dates back to Version 6 of AT&amp;T
	&unix;, circa 1975.  <command>tar</command> operates in
	cooperation with the file system and writes files and
	directories to tape.  <command>tar</command> does not support
	the full range of options that are available from
	&man.cpio.1;, but it does not require the unusual command
	pipeline that <command>cpio</command> uses.</para>

      <indexterm><primary><command>tar</command></primary></indexterm>

      <para>To <command>tar</command> to an Exabyte tape drive
	connected to a host called <hostid>komodo</hostid>:</para>

      <screen>&prompt.root; <userinput>tar cf - . | rsh komodo dd of=<replaceable>tape-device</replaceable> obs=20b</userinput></screen>

      <para>When backing up over an insecure network, instead use
	<command>ssh</command>.</para>
    </sect2>

    <sect2>
      <title><command>cpio</command></title>

      <indexterm>
	<primary>backup software</primary>
	<secondary><command>cpio</command></secondary>
      </indexterm>

      <para>&man.cpio.1; is the original &unix; file interchange tape
	program for magnetic media.  <command>cpio</command> includes
	options to perform byte-swapping, write a number of different
	archive formats, and pipe the data to other programs.  This
	last feature makes <command>cpio</command> an excellent choice
	for installation media.  <command>cpio</command> does not know
	how to walk the directory tree and a list of files must be
	provided through <filename>stdin</filename>.</para>

      <indexterm>
	<primary><command>cpio</command></primary>
      </indexterm>

      <para>Since <command>cpio</command> does not support backups
	across the network, use a pipeline and <command>ssh</command>
	to send the data to a remote tape drive.</para>

      <screen>&prompt.root; <userinput>for f in <replaceable>directory_list; do</replaceable></userinput>
<userinput>find $f &gt;&gt; backup.list</userinput>
<userinput>done</userinput>
&prompt.root; <userinput>cpio -v -o --format=newc &lt; backup.list | ssh <replaceable>user</replaceable>@<replaceable>host</replaceable> "cat &gt; <replaceable>backup_device</replaceable>"</userinput></screen>

      <para>Where <replaceable>directory_list</replaceable> is the
	list of directories to back up,
	<replaceable>user</replaceable>@<replaceable>host</replaceable>
	is the user/hostname combination that will be performing the
	backups, and <replaceable>backup_device</replaceable> is where
	the backups should be written to, such as
	<filename>/dev/nsa0</filename>).</para>
    </sect2>

    <sect2>
      <title><command>pax</command></title>

      <indexterm>
	<primary>backup software</primary>
	<secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>&man.pax.1; is the IEEE/&posix; answer to
	<command>tar</command> and <command>cpio</command>.  Over the
	years the various versions of <command>tar</command> and
	<command>cpio</command> have become slightly incompatible.  So
	rather than fight it out to fully standardize them, &posix;
	created a new archive utility.  <command>pax</command>
	attempts to read and write many of the various
	<command>cpio</command> and <command>tar</command> formats,
	plus new formats of its own.  Its command set more resembles
	<command>cpio</command> than <command>tar</command>.</para>
    </sect2>

    <sect2 id="backups-programs-amanda">
      <title><application>Amanda</application></title>

      <indexterm>
	<primary>backup software</primary>
	<secondary><application>Amanda</application></secondary>
      </indexterm>
      <indexterm>
	<primary><application>Amanda</application></primary>
      </indexterm>

      <!-- Remove link until <port> tag is available -->
      <para><application>Amanda</application> (Advanced Maryland
	Network Disk Archiver) is a client/server backup system,
	rather than a single program.  An
	<application>Amanda</application> server will backup to a
	single tape drive any number of computers that have
	<application>Amanda</application> clients and a network
	connection to the <application>Amanda</application> server.  A
	common problem at sites with a number of large disks is that
	the length of time required to backup to data directly to tape
	exceeds the amount of time available for the task.
	<application>Amanda</application> solves this problem by using
	a <quote>holding disk</quote> to backup several file systems
	at the same time.  <application>Amanda</application> creates
	<quote>archive sets</quote>: a group of tapes used over a
	period of time to create full backups of all the file systems
	listed in <application>Amanda</application>'s configuration
	file.  The <quote>archive set</quote> also contains nightly
	incremental, or differential, backups of all the file systems.
	Restoring a damaged file system requires the most recent full
	backup and the incremental backups.</para>

      <para>The configuration file provides fine grained control of
	backups and the network traffic that
	<application>Amanda</application> generates.
	<application>Amanda</application> will use any of the above
	backup programs to write the data to tape.
	<application>Amanda</application> is not installed by
	but is available as either a port or package.</para>
    </sect2>

    <sect2>
      <title>Do Nothing</title>

      <para><quote>Do nothing</quote> is not a computer program, but
	it is the most widely used backup strategy.  There are no
	initial costs.  There is no backup schedule to follow.  Just
	say no.  If something happens to your data, grin and bear
	it!</para>

      <para>If your time and data is worth little to nothing, then
	<quote>Do nothing</quote> is the most suitable backup program
	for the computer.  But beware, &os; is a useful tool and
	over time it can be used to create a valuable collection of
	files.</para>

      <para><quote>Do nothing</quote> is the correct backup method for
	<filename class="directory">/usr/obj</filename> and other
	directory trees that can be exactly recreated by the computer.
	An example is the files that comprise the HTML or &postscript;
	version of this Handbook.  These document formats have been
	created from XML input files.  Creating backups of the HTML or
	&postscript; files is not necessary if the XML files are
	backed up regularly.</para>
    </sect2>

    <sect2>
      <title>Which Backup Program Is Best?</title>

      <indexterm>
	<primary>LISA</primary>
      </indexterm>

      <para>&man.dump.8; <emphasis>Period.</emphasis> Elizabeth D.
	Zwicky torture tested all the backup programs discussed here.
	The clear choice for preserving all your data and all the
	peculiarities of &unix; file systems is
	<command>dump</command>.  Elizabeth created file systems
	containing a large variety of unusual conditions (and some not
	so unusual ones) and tested each program by doing a backup and
	restore of those file systems.  The peculiarities included:
	files with holes, files with holes and a block of nulls, files
	with funny characters in their names, unreadable and
	unwritable files, devices, files that change size during the
	backup, files that are created/deleted during the backup and
	more.   She presented the results at LISA V in Oct. 1991.  See
	<ulink
	  url="http://www.coredumps.de/doc/dump/zwicky/testdump.doc.html">torture-testing
	  Backup and Archive Programs</ulink>.</para>
    </sect2>

    <sect2>
      <title>Emergency Restore Procedure</title>

      <sect3>
	<title>Before the Disaster</title>

	<para>There are four steps which should be performed in
	  preparation for any disaster that may occur.</para>
	<indexterm>
	  <primary><command>bsdlabel</command></primary>
	</indexterm>

	<para>First, print the bsdlabel of each disk using a command
	  such as <command>bsdlabel da0 | lpr</command>.  Also print a
	  copy of <filename>/etc/fstab</filename> and all boot
	  messages.</para>

	<indexterm><primary>livefs CD</primary></indexterm>
	<para>Second, burn a <quote>livefs</quote> CD.  This CD
	  contains support for booting into a &os;
	  <quote>livefs</quote> rescue mode, allowing the user to
	  perform many tasks like running &man.dump.8;,
	  &man.restore.8;, &man.fdisk.8;, &man.bsdlabel.8;,
	  &man.newfs.8;, &man.mount.8;, and more.  The livefs CD image
	  for &os;/&arch.i386;&nbsp;&rel2.current;-RELEASE is
	  available from <ulink
	    url="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO-IMAGES/&rel2.current;/&os;-&rel2.current;-RELEASE-&arch.i386;-livefs.iso"></ulink>.</para>

	<note>
	  <para>Livefs CD images are not available for
	    &os;&nbsp;&rel.current;-RELEASE and later.  In addition to
	    the CDROM installation images, flash drive installation
	    images may be used to recover a system.  The
	    <quote>memstick</quote> image for
	    &os;/&arch.i386;&nbsp;&rel.current;-RELEASE is available
	    from <ulink
	      url="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/&arch.i386;/ISO-IMAGES/&rel.current;/&os;-&rel.current;-RELEASE-&arch.i386;-memstick.img"></ulink>.</para>
	</note>

	<para>Third, create backup tapes regularly.  Any changes that
	  made after the last backup may be irretrievably lost.
	  Write-protect the backup media.</para>

	<para>Fourth, test the <quote>livefs</quote> CD and the
	  backups.  Make notes of the procedure.  Store these notes
	  with the CD, the printouts, and the backups.  These notes
	  may prevent the inadvertent destruction of the backups while
	  under the stress of performing an emergency
	  recovery.</para>

	<para>For an added measure of security, store an extra
	  <quote>livefs</quote> CD and the latest backup at a
	  remote location, where a remote location is
	  <emphasis>not</emphasis> the basement of the same building.
	  A remote location should be physically separated from the
	  computers and disk drives by a significant distance.</para>
      </sect3>

      <sect3>
	<title>After the Disaster</title>

	<para>First, determine if the hardware survived.  Thanks
	  to regular, off-site backups, there is no need to worry
	  about the software.</para>

	<para>If the hardware has been damaged, the parts should be
	  replaced before attempting to use the computer.</para>

	<para>If the hardware is okay, insert the
	  <quote>livefs</quote> CD and boot the computer.  The
	  original install menu will be displayed on the screen.
	  Select the correct country, then choose
	  <guimenuitem>Fixit -- Repair mode with CDROM/DVD/floppy or
	  start a shell.</guimenuitem> then select
	  <guimenuitem>CDROM/DVD -- Use the live filesystem
	  CDROM/DVD</guimenuitem>.
	  <command>restore</command> and the other needed programs
	  are located in <filename
	    class="directory">/mnt2/rescue</filename>.</para>

	<para>Recover each file system separately.</para>

	<indexterm>
	  <primary><command>mount</command></primary>
	</indexterm>
	<indexterm><primary>root partition</primary></indexterm>
	<indexterm>
	  <primary><command>bsdlabel</command></primary>
	</indexterm>
	<indexterm>
	  <primary><command>newfs</command></primary>
	</indexterm>

	<para>Try to <command>mount</command> the root partition
	  of the first disk using <command>mount /dev/da0a
	    /mnt</command>.  If the bsdlabel was damaged, use
	  <command>bsdlabel</command> to re-partition and label the
	  disk to match the label that was printed and saved.  Use
	  <command>newfs</command> to re-create the file systems.
	  Re-mount the root partition of the disk read-write using
	  <command>mount -u -o rw /mnt</command>.  Use the backups
	  to recover the data for this file system.  Unmount the file
	  system with <command>umount /mnt</command>.  Repeat for each
	  file system that was damaged.</para>

	<para>Once the system is running, backup the data onto new
	  media as whatever caused the crash or data loss may strike
	  again.  Another hour spent now may save further distress
	  later.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="disks-virtual">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>Reorganized and enhanced by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Network, Memory, and File-Backed File Systems</title>

    <indexterm><primary>virtual disks</primary></indexterm>
    <indexterm>
      <primary>disks</primary>
      <secondary>virtual</secondary>
    </indexterm>

    <para>In addition to physical disks such as floppies, CDs, and
      hard drives, &os; also supports <firstterm>virtual
	disks</firstterm>.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>disks</primary>
      <secondary>memory</secondary>
    </indexterm>
    <para>These include network file systems such as the
      <link linkend="network-nfs">Network File System</link> and Coda,
      memory-based file systems, and file-backed file systems.</para>

    <para>According to the &os; version, the tools used for the
      creation and use of file-backed and memory-based file systems
      differ.</para>

    <note>
      <para>Use &man.devfs.5; to allocate device nodes transparently
	for the user.</para>
    </note>

    <sect2 id="disks-mdconfig">
      <title>File-Backed File System</title>

      <indexterm>
	<primary>disks</primary>
	<secondary>file-backed</secondary>
      </indexterm>

      <para>&man.mdconfig.8; is used to configure and enable memory
	disks, &man.md.4;, under &os;.  To use &man.mdconfig.8;,
	&man.md.4; must be first loaded.  When using a custom kernel
	configuration file, ensure it includes this line:</para>

      <programlisting>device md</programlisting>

      <para>&man.mdconfig.8; supports several types of memory backed
	virtual disks: memory disks allocated with &man.malloc.9; and
	memory disks using a file or swap space as backing.  One
	possible use is the mounting of CD images.</para>

      <para>To mount an existing file system image:</para>

      <example>
	<title>Using <command>mdconfig</command> to Mount an Existing
	  File System Image</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>diskimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable> <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>To create a new file system image with
	&man.mdconfig.8;:</para>

      <example>
	<title>Creating a New File-Backed Disk with
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>newimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>bsdlabel -w md<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs md<replaceable>0</replaceable>a</userinput>
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable>a <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</screen>
      </example>

      <para>If unit number is not specified with
	<option>-u</option>, &man.mdconfig.8; uses the
	&man.md.4; automatic allocation to select an unused device.
	The name of the allocated unit will be output to stdout, such
	as <devicename>md4</devicename>.  Refer to &man.mdconfig.8;
	for more details about.</para>

      <para>While &man.mdconfig.8; is useful, it takes several
	command lines to create a file-backed file system.  &os; also
	comes with &man.mdmfs.8; which automatically configures a
	&man.md.4; disk using &man.mdconfig.8;, puts a UFS file system
	on it using &man.newfs.8;, and mounts it using &man.mount.8;.
	For example, to create and mount the same file system image as
	above, type the following:</para>

      <example>
	<title>Configure and Mount a File-Backed Disk with
	  <command>mdmfs</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdmfs -F <replaceable>newimage</replaceable> -s <replaceable>5</replaceable>m md<replaceable>0</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt</screen>
      </example>

      <para>When <option>md</option> is used without a unit number,
	&man.mdmfs.8; uses the &man.md.4; auto-unit feature to
	automatically select an unused device.  For more details
	about &man.mdmfs.8;, refer to its manual page.</para>
    </sect2>

    <sect2 id="disks-md-freebsd5">
      <title>Memory-Based File System</title>

      <indexterm>
	<primary>disks</primary>
	<secondary>memory file system</secondary>
      </indexterm>

      <para>For a memory-based file system, <quote>swap
	  backing</quote> should normally be used.  This does not mean
	that the memory disk will be swapped out to disk by default,
	but rather that the memory disk will be allocated from a
	memory pool which can be swapped out to disk if needed.  It is
	also possible to create memory-based disks which are
	&man.malloc.9; backed, but using large malloc backed memory
	disks can result in a system panic if the kernel runs out of
	memory.</para>

      <example>
	<title>Creating a New Memory-Based Disk with
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>mdconfig -a -t swap -s <replaceable>5</replaceable>m -u <replaceable>1</replaceable></userinput>
&prompt.root; <userinput>newfs -U md<replaceable>1</replaceable></userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
&prompt.root; <userinput>mount /dev/md<replaceable>1</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</screen>
      </example>

      <example>
	<title>Creating a New Memory-Based Disk with
	  <command>mdmfs</command></title>

	<screen>&prompt.root; <userinput>mdmfs -s <replaceable>5</replaceable>m md<replaceable>2</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2>
      <title>Detaching a Memory Disk from the System</title>

      <indexterm>
	<primary>disks</primary>
	<secondary>detaching a memory disk</secondary>
      </indexterm>

      <para>When a memory-based or file-based file system is no
	longer in use, its resources should be released back to
	the system.  First, unmount the file system, then use
	&man.mdconfig.8; to detach the disk from the system and
	release the resources.</para>

      <para>For example, to detach and free all resources used by
	<filename>/dev/md4</filename>:</para>

      <screen>&prompt.root; <userinput>mdconfig -d -u <replaceable>4</replaceable></userinput></screen>

      <para>It is possible to list information about configured
	&man.md.4; devices by running
	<command>mdconfig -l</command>.</para>
    </sect2>
  </sect1>

  <sect1 id="snapshots">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <!-- 15 JUL 2002 -->
    </sect1info>

    <title>File System Snapshots</title>

    <indexterm>
      <primary>file systems</primary>
      <secondary>snapshots</secondary>
    </indexterm>

    <para>&os; offers a feature in conjunction with
      <link linkend="soft-updates">Soft Updates</link>: file system
      snapshots.</para>

    <para>UFS snapshots allow a user to create images of specified
      file systems, and treat them as a file.  Snapshot files must be
      created in the file system that the action is performed on, and
      a user may create no more than 20 snapshots per file system.
      Active snapshots are recorded in the superblock so they are
      persistent across unmount and remount operations along with
      system reboots.  When a snapshot is no longer required, it can
      be removed using &man.rm.1;.  While snapshots may be removed in
      any order, all the used space may not be acquired because
      another snapshot will possibly claim some of the released
      blocks.</para>

    <para>The un-alterable <option>snapshot</option> file flag is set
      by &man.mksnap.ffs.8; after initial creation of a snapshot file.
      &man.unlink.1; makes an exception for snapshot files since it
      allows them to be removed.</para>

    <para>Snapshots are created using &man.mount.8;.  To place a
      snapshot of <filename class="directory">/var</filename> in the
      file <filename>/var/snapshot/snap</filename>, use the following
      command:</para>

    <screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

    <para>Alternatively, use &man.mksnap.ffs.8; to create the
      snapshot:</para>

    <screen>&prompt.root; <userinput>mksnap_ffs /var /var/snapshot/snap</userinput></screen>

    <para>One can find snapshot files on a file system, such as
      <filename class="directory">/var</filename>, using
      &man.find.1;:</para>

    <screen>&prompt.root; <userinput>find /var -flags snapshot</userinput></screen>

    <para>Once a snapshot has been created, it has several
      uses:</para>

    <itemizedlist>
      <listitem>
	<para>Some administrators will use a snapshot file for backup
	  purposes, because the snapshot can be transferred to CDs or
	  tape.</para>
      </listitem>

      <listitem>
	<para>The file system integrity checker, &man.fsck.8;, may be
	  run on the snapshot.  Assuming that the file system was
	  clean when it was mounted, this should always provide a
	  clean and unchanging result.</para>
      </listitem>

      <listitem>
	<para>Running &man.dump.8; on the snapshot will produce a dump
	  file that is consistent with the file system and the
	  timestamp of the snapshot.  &man.dump.8; can also take a
	  snapshot, create a dump image, and then remove the snapshot
	  in one command by using <option>-L</option>.</para>
      </listitem>

      <listitem>
	<para>The snapshot can be mounted as a frozen image of the
	  file system.  To &man.mount.8; the snapshot
	  <filename>/var/snapshot/snap</filename> run:</para>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput>
&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>
      </listitem>
    </itemizedlist>

    <para>The frozen <filename class="directory">/var</filename> is
      now available through <filename
	class="directory">/mnt</filename>.  Everything will initially
      be in the same state it was during the snapshot creation time.
      The only exception is that any earlier snapshots will appear as
      zero length files.  To unmount the snapshot, use:</para>

    <screen>&prompt.root; <userinput>umount /mnt</userinput>
&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

    <para>For more information about <option>softupdates</option> and
      file system snapshots, including technical papers, visit
      Marshall Kirk McKusick's website at
      <ulink url="http://www.mckusick.com/"></ulink>.</para>
  </sect1>

  <sect1 id="quotas">
    <title>File System Quotas</title>

    <indexterm>
      <primary>accounting</primary>
      <secondary>disk space</secondary>
    </indexterm>
    <indexterm><primary>disk quotas</primary></indexterm>

    <para>Quotas are an optional feature of the operating system that
      can be used to limit the amount of disk space or the number of
      files a user or members of a group may allocate on a per-file
      system basis.  This is used most often on timesharing systems
      where it is desirable to limit the amount of resources any one
      user or group of users may allocate.  This prevents one user or
      group of users from consuming all of the available disk
      space.</para>

    <sect2>
      <title>Configuring the System to Enable Disk Quotas</title>

      <para>Before using disk quotas, quota support must be added to
	the kernel by adding the following line to the kernel
	configuration file:</para>

      <programlisting>options QUOTA</programlisting>

      <para>The <filename>GENERIC</filename> kernel does not
	have this enabled by default, so a custom kernel must be
	compiled in order to use disk quotas.  Refer to <link
	  linkend="kernelconfig"></link> for more information on
	kernel configuration.</para>

      <para>Next, enable disk quotas in
	<filename>/etc/rc.conf</filename>.  On &os;&nbsp;7.X and
	earlier, this is done by adding the line:</para>

      <programlisting>enable_quotas="YES"</programlisting>

      <para>On &os;&nbsp;8.0-RELEASE and later, add the following
	line instead:</para>

      <programlisting>quota_enable="YES"</programlisting>

      <indexterm>
	<primary>disk quotas</primary>
	<secondary>checking</secondary>
      </indexterm>
      <para>For finer control over quota startup, an additional
	configuration variable is available.  Normally on bootup, the
	quota integrity of each file system is checked by
	&man.quotacheck.8;.  This program insures that the data in the
	quota database properly reflects the data on the file system.
	This is a time consuming process that will significantly
	affect the time the system takes to boot.  To skip this step,
	add this variable to <filename>/etc/rc.conf</filename>:</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>Finally, edit <filename>/etc/fstab</filename> to enable
	disk quotas on a per-file system basis.  This is when user or
	group quotas can be enabled on the file systems.</para>

      <para>To enable per-user quotas on a file system, add
	<option>userquota</option> to the options field in the
	<filename>/etc/fstab</filename> entry for the file system to
	enable quotas on.  For example:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>To enable group quotas, instead use
	<option>groupquota</option>.  To enable both user and group
	quotas, change the entry as follows:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>By default, the quota files are stored in the root
	directory of the file system as
	<filename>quota.user</filename> and
	<filename>quota.group</filename>.  Refer to &man.fstab.5; for
	more information.  Even though an alternate location for the
	quota files can be specified, this is not recommended because
	the various quota utilities do not seem to handle this
	properly.</para>

      <para>Once the configuration is complete, reboot the system
	with the new kernel.  <filename>/etc/rc</filename> will
	automatically run the appropriate commands to create the
	initial quota files for all of the quotas enabled in
	<filename>/etc/fstab</filename>.  There is no need to
	manually create any zero length quota files.</para>

      <para>In the normal course of operations, there should be no
	need to manually run &man.quotacheck.8;, &man.quotaon.8;, or
	&man.quotaoff.8;.  However, one should read their manual pages
	to be familiar with their operation.</para>
    </sect2>

    <sect2>
      <title>Setting Quota Limits</title>

      <indexterm>
	<primary>disk quotas</primary>
	<secondary>limits</secondary>
      </indexterm>

      <para>Once the system has been configured to enable quotas,
	verify they really are enabled by running:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>

      <para>There should be a one line summary of disk usage and
	current quota limits for each file system that quotas are
	enabled on.</para>

      <para>The system is now ready to be assigned quota limits with
	&man.edquota.8;.</para>

      <para>Several options are available to enforce limits on the
	amount of disk space a user or group may allocate, and how
	many files they may create.  Allocations can be limited based
	on disk space (block quotas), number of files (inode quotas),
	or a combination of both.  Each limits is further broken down
	into two categories: hard and soft limits.</para>

      <indexterm><primary>hard limit</primary></indexterm>
      <para>A hard limit may not be exceeded.  Once a user reaches a
	hard limit, no further allocations can be made on that file
	system by that user.  For example, if the user has a hard
	limit of 500 kbytes on a file system and is currently using
	490 kbytes, the user can only allocate an additional 10
	kbytes.  Attempting to allocate an additional 11 kbytes will
	fail.</para>

      <indexterm><primary>soft limit</primary></indexterm>
      <para>Soft limits can be exceeded for a limited amount of time,
	known as the grace period, which is one week by default.  If a
	user stays over their limit longer than the grace period, the
	soft limit turns into a hard limit and no further allocations
	are allowed.  When the user drops back below the soft limit,
	the grace period is reset.</para>

      <para>The following is an example output from &man.edquota.8;.
	When &man.edquota.8; is invoked, the editor specified by
	<envar>EDITOR</envar> is opened in order to edit the quota
	limits.  The default editor is set to
	<application>vi</application>.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>There are normally two lines for each file system that
	has quotas enabled.  One line represents the block limits and
	the other represents the inode limits.  Change the value to
	modify the quota limit.  For example, to raise this
	user's block limit from a soft limit of 50 and a hard limit of
	75 to a soft limit of 500 and a hard limit of 600,
	change:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>to:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>The new quota limits take affect upon exiting the
	editor.</para>

      <para>Sometimes it is desirable to set quota limits on a range
	of UIDs.  This can be done by passing <option>-p</option> to
	&man.edquota.8;.  First, assign the desired quota limit to a
	user, then run <command>edquota -p protouser
	  startuid-enduid</command>.  For example, if
	<username>test</username> has the desired quota limits, the
	following command will duplicate those quota limits for UIDs
	10,000 through 19,999:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>

      <para>For more information, refer to &man.edquota.8;.</para>
    </sect2>

    <sect2>
      <title>Checking Quota Limits and Disk Usage</title>

      <indexterm>
	<primary>disk quotas</primary>
	<secondary>checking</secondary>
      </indexterm>

      <para>Either &man.quota.1; or &man.repquota.8; can be used to
	check quota limits and disk usage.  To check individual user
	or group quotas and disk usage, use &man.quota.1;.  A user
	may only examine their own quota and the quota of a group they
	are a member of.  Only the superuser may view all user and
	group quotas.  To get a summary of all quotas and disk usage
	for file systems with quotas enabled, use
	&man.repquota.8;.</para>

      <para>The following is sample output from
	<command>quota -v</command> for a user that has quota limits
	on two file systems.</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm><primary>grace period</primary></indexterm>
      <para>In this example, the user is currently 15 kbytes over the
	soft limit of 50 kbytes on <filename
	  class="directory">/usr</filename>  and has 5 days of grace
	period left.  The asterisk <literal>*</literal> indicates that
	the user is currently over the quota limit.</para>

      <para>Normally, file systems that the user is not using any disk
	space on will not show in the output of &man.quota.1;, even if
	the user has a quota limit assigned for that file system.  Use
	<option>-v</option> to display those file systems, such as
	<filename class="directory">/usr/var</filename> in the above
	example.</para>
    </sect2>

    <sect2>
      <title>Quotas over NFS</title>

      <indexterm><primary>NFS</primary></indexterm>

      <para>Quotas are enforced by the quota subsystem on the NFS
	server.  The &man.rpc.rquotad.8; daemon makes quota
	information available to &man.quota.1; on NFS clients,
	allowing users on those machines to see their quota
	statistics.</para>

      <para>Enable <command>rpc.rquotad</command> in
	<filename>/etc/inetd.conf</filename> like so:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Now restart <command>inetd</command>:</para>

      <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
    </sect2>
  </sect1>

  <sect1 id="disks-encrypting">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Lucky</firstname>
	  <surname>Green</surname>
	  <contrib>Contributed by </contrib>
	  <affiliation>
	    <address><email>shamrock@cypherpunks.to</email></address>
	  </affiliation>
	</author>
      </authorgroup>
      <!-- 11 MARCH 2003 -->
    </sect1info>

    <title>Encrypting Disk Partitions</title>

    <indexterm>
      <primary>disks</primary>
      <secondary>encrypting</secondary>
    </indexterm>

    <para>&os; offers excellent online protections against
      unauthorized data access.  File permissions and <link
	linkend="mac">Mandatory Access Control</link> (MAC) help
      prevent unauthorized users from accessing data while the
      operating system is active and the computer is powered up.
      However, the permissions enforced by the operating system are
      irrelevant if an attacker has physical access to a computer and
      can move the computer's hard drive to another system to copy and
      analyze the data.</para>

    <para>Regardless of how an attacker may have come into possession
      of a hard drive or powered-down computer, both the GEOM Based
      Disk Encryption (<command>gbde</command>) and
      <command>geli</command> cryptographic subsystems in &os; are
      able to protect the data on the computer's file systems against
      even highly-motivated attackers with significant resources.
      Unlike cumbersome encryption methods that encrypt only
      individual files, <command>gbde</command> and
      <command>geli</command> transparently encrypt entire file
      systems.  No cleartext ever touches the hard drive's
      platter.</para>

    <sect2>
      <title>Disk Encryption with
	<application>gbde</application></title>

      <procedure>
	<step>
	  <para>Configuring <application>gbde</application> requires
	    superuser privileges.</para>

	  <screen>&prompt.user; <userinput>su -</userinput>
Password:</screen>
	</step>

	<step>
	  <para>If using a custom kernel configuration file, ensure it
	    contains this line:</para>

	  <para><literal>options GEOM_BDE</literal></para>

	  <para>If the kernel already contains this support, use
	    <command>kldload</command> to load &man.gbde.4;:</para>

	  <screen>&prompt.root; <userinput>kldload geom_bde</userinput></screen>
	</step>
      </procedure>

      <sect3>
	<title>Preparing the Encrypted Hard Drive</title>

	<para>The following example demonstrates adding a new hard
	  drive to a system that will hold a single encrypted
	  partition.  This partition will be mounted as
	  <filename class="directory">/private</filename>.
	  <application>gbde</application> can also be used to encrypt
	  <filename class="directory">/home</filename> and
	  <filename class="directory">/var/mail</filename>, but this
	  requires more complex instructions which exceed the scope of
	  this introduction.</para>

	<procedure>
	  <step>
	    <title>Add the New Hard Drive</title>

	    <para>Install the new drive to the system as explained in
	      <link linkend="disks-adding"></link>.  For the purposes
	      of this example, a new hard drive partition has been
	      added as <devicename>/dev/ad4s1c</devicename> and
	      <devicename>/dev/ad0s1<replaceable>*</replaceable></devicename>
	      represents the existing standard &os; partitions.</para>

	    <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</screen>
	  </step>

	  <step>
	    <title>Create a Directory to Hold <command>gbde</command>
	      Lock Files</title>

	    <screen>&prompt.root; <userinput>mkdir /etc/gbde</userinput></screen>

	    <para>The <application>gbde</application> lock file
	      contains information that
	      <application>gbde</application> requires to access
	      encrypted partitions.  Without access to the lock file,
	      <application>gbde</application> will not be able to
	      decrypt the data contained in the encrypted partition
	      without significant manual intervention which is not
	      supported by the software.  Each encrypted partition
	      uses a separate lock file.</para>
	  </step>

	  <step>
	    <title>Initialize the <command>gbde</command>
	      Partition</title>

	    <para>A <application>gbde</application> partition must be
	      initialized before it can be used.  This initialization
	      needs to be performed only once:</para>

	    <screen>&prompt.root; <userinput>gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</userinput></screen>

	    <para>&man.gbde.8; will open the default editor, in order
	      to set various configuration options in a template.  For
	      use with UFS1 or UFS2, set the sector_size to
	      2048:</para>

	    <programlisting># &dollar;FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size	=	2048
[...]</programlisting>

	    <para>&man.gbde.8; will ask the user twice to type the
	      passphrase used to secure the data.  The passphrase must
	      be the same both times.  The ability of
	      <application>gbde</application> to protect data depends
	      entirely on the quality of the passphrase.  For tips on
	      how to select a secure passphrase that is easy to
	      remember, see the <ulink
		url="http://world.std.com/~reinhold/diceware.html">Diceware
		Passphrase</ulink> website.</para>

	    <para><command>gbde init</command>creates a lock file for
	      the <application>gbde</application> partition.  In this
	      example, it is stored as
	      <filename>/etc/gbde/ad4s1c.lock</filename>.
	      <application>gbde</application> lock files must end in
	      <quote>.lock</quote> in order to be correctly detected
	      by the <filename>/etc/rc.d/gbde</filename> start up
	      script.</para>

	    <caution>
	      <para><application>gbde</application> lock files
		<emphasis>must</emphasis> be backed up together with
		the contents of any encrypted partitions.  While
		deleting a lock file alone cannot prevent a determined
		attacker from decrypting a
		<application>gbde</application> partition, without the
		lock file, the legitimate owner will be unable to
		access the data on the encrypted partition without a
		significant amount of work that is totally unsupported
		by &man.gbde.8;.</para>
	    </caution>
	  </step>

	  <step>
	    <title>Attach the Encrypted Partition to the
	      Kernel</title>

	    <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	    <para>This command will prompt to input the passphrase
	      that was selected during the initialization of the
	      encrypted partition.  The new encrypted device will
	      appear in
	      <filename class="directory">/dev</filename> as
	      <devicename>/dev/device_name.bde</devicename>:</para>

	    <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</screen>
	  </step>

	  <step>
	    <title>Create a File System on the Encrypted
	      Device</title>

	    <para>Once the encrypted device has been attached to the
	      kernel, a file system can be created on the device using
	      &man.newfs.8;.  This example creates a UFS2 file
	      system with soft updates enabled.</para>

	    <screen>&prompt.root; <userinput>newfs -U /dev/ad4s1c.bde</userinput></screen>

	    <note>
	      <para>&man.newfs.8; must be performed on an attached
		<application>gbde</application> partition which is
		identified by a
		<filename><replaceable>*</replaceable>.bde</filename>
		extension to the device name.</para>
	    </note>
	  </step>

	  <step>
	    <title>Mount the Encrypted Partition</title>

	    <para>Create a mount point for the encrypted file
	      system:</para>

	    <screen>&prompt.root; <userinput>mkdir /private</userinput></screen>

	    <para>Mount the encrypted file system:</para>

	    <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>
	  </step>

	  <step>
	    <title>Verify That the Encrypted File System is
	      Available</title>

	    <para>The encrypted file system should now be visible to
	      &man.df.1; and be available for use.</para>

	    <screen>&prompt.user; <userinput>df -H</userinput>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</screen>
	  </step>
	</procedure>
      </sect3>

      <sect3>
	<title>Mounting Existing Encrypted File Systems</title>

	<para>After each boot, any encrypted file systems must be
	  re-attached to the kernel, checked for errors, and mounted,
	  before the file systems can be used.  The required commands
	  must be executed as <username>root</username>.</para>

	<procedure>
	  <step>
	    <title>Attach the <command>gbde</command> Partition to the
	      Kernel</title>

	    <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	    <para>This command will prompt for the passphrase that was
	      selected during initialization of the encrypted
	      <application>gbde</application> partition.</para>
	  </step>

	  <step>
	    <title>Check the File System for Errors</title>

	    <para>Since encrypted file systems cannot yet be listed in
	      <filename>/etc/fstab</filename> for automatic mounting,
	      the file systems must be checked for errors by running
	      &man.fsck.8; manually before mounting:</para>

	    <screen>&prompt.root; <userinput>fsck -p -t ffs /dev/ad4s1c.bde</userinput></screen>
	  </step>

	  <step>
	    <title>Mount the Encrypted File System</title>

	    <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>

	    <para>The encrypted file system is now available for
	      use.</para>
	  </step>
	</procedure>

	<sect4>
	  <title>Automatically Mounting Encrypted Partitions</title>

	  <para>It is possible to create a script to automatically
	    attach, check, and mount an encrypted partition, but for
	    security reasons the script should not contain the
	    &man.gbde.8; password.  Instead, it is recommended that
	    such scripts be run manually while providing the password
	    via the console or &man.ssh.1;.</para>

	  <para>As an alternative, an <filename>rc.d</filename> script
	    is provided.  Arguments for this script can be passed via
	    &man.rc.conf.5;:</para>

	  <programlisting>gbde_autoattach_all="YES"
gbde_devices="ad4s1c"
gbde_lockdir="/etc/gbde"</programlisting>

	  <para>This requires that the
	    <application>gbde</application> passphrase be entered at
	    boot time.  After typing the correct passphrase, the
	    <application>gbde</application> encrypted partition will
	    be mounted automatically.  This can be useful when using
	    <application>gbde</application> on laptops.</para>
	</sect4>
      </sect3>

      <sect3>
	<title>Cryptographic Protections Employed by
	  <command>gbde</command></title>

	<para>&man.gbde.8; encrypts the sector payload using 128-bit
	  AES in CBC mode.  Each sector on the disk is encrypted with
	  a different AES key.  For more information on the
	  cryptographic design, including how the sector keys are
	  derived from the user-supplied passphrase, refer to
	  &man.gbde.4;.</para>
      </sect3>

      <sect3>
	<title>Compatibility Issues</title>

	<para>&man.sysinstall.8; is incompatible with
	  <application>gbde</application>-encrypted devices.  All
	  <devicename><replaceable>*</replaceable>.bde</devicename>
	  devices must be detached from the kernel before starting
	  &man.sysinstall.8; or it will crash during its initial
	  probing for devices.  To detach the encrypted device used in
	  the example, use the following command:</para>

	<screen>&prompt.root; <userinput>gbde detach /dev/ad4s1c</userinput></screen>

	<para>Also, since &man.vinum.4; does not use the
	  &man.geom.4; subsystem,
	  <application>gbde</application> can not be used with
	  <application>vinum</application> volumes.</para>
      </sect3>
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Daniel</firstname>
	    <surname>Gerzo</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
	<!-- Date of writing: 28 November 2005 -->
      </sect2info>

      <title>Disk Encryption with <command>geli</command></title>

      <para>An alternative cryptographic GEOM class is available
	through &man.geli.8;.  <command>geli</command> differs from
	<command>gbde</command>; offers different features, and uses
	a different scheme for doing cryptographic work.</para>

      <para>&man.geli.8; provides the following features:</para>

      <itemizedlist>
	<listitem>
	  <para>Utilizes the &man.crypto.9; framework and, when
	    cryptographic hardware is available,
	    <command>geli</command> uses it automatically.</para>
	</listitem>

	<listitem>
	  <para>Supports multiple cryptographic algorithms such as
	    AES, Blowfish, and 3DES.</para>
	</listitem>

	<listitem>
	  <para>Allows the root partition to be encrypted.  The
	    passphrase used to access the encrypted root partition
	    will be requested during system boot.</para>
	</listitem>

	<listitem>
	  <para>Allows the use of two independent keys such as a
	    <quote>key</quote> and a
	    <quote>company key</quote>.</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> is fast as it performs simple
	    sector-to-sector encryption.</para>
	</listitem>

	<listitem>
	  <para>Allows backup and restore of master keys.  If a user
	    destroys their keys, it is still possible to get access
	    to the data by restoring keys from the backup.</para>
	</listitem>

	<listitem>
	  <para>Allows a disk to attach with a random, one-time key
	    which is useful for swap partitions and temporary file
	    systems.</para>
	</listitem>
      </itemizedlist>

      <para>More <command>geli</command> features can be found in
	&man.geli.8;.</para>

      <para>This section describes how to enable support for
	<command>geli</command> in the &os; kernel and explains how
	to create and use a <command>geli</command> encryption
	provider.</para>

      <para>Superuser privileges are required since modifications
	to the kernel are necessary.</para>

      <procedure>
	<step>
	  <title>Adding <command>geli</command> Support to the
	    Kernel</title>

	  <para>For a custom kernel, ensure the kernel configuration
	    file contains these lines:</para>

	  <programlisting>options GEOM_ELI
device crypto</programlisting>

	  <para>Alternatively, the <command>geli</command> module can
	    be loaded at boot time by adding the following line to
	    <filename>/boot/loader.conf</filename>:</para>

	  <programlisting>geom_eli_load="YES"</programlisting>

	  <para>&man.geli.8; should now be supported by the
	    kernel.</para>
	</step>

	<step>
	  <title>Generating the Master Key</title>

	  <para>The following example describes how to generate a
	    key file which will be used as part of the master key for
	    the encrypted provider mounted under
	    <filename class="directory">/private</filename>.  The key
	    file will provide some random data used to encrypt the
	    master key.  The master key will also be protected by a
	    passphrase.  The provider's sector size will be 4kB.
	    The example will describe how to attach to the
	    <command>geli</command> provider, create a file system on
	    it, mount it, work with it, and finally, how to detach
	    it.</para>

	  <para>It is recommended to use a bigger sector size, such as
	    4kB, for better performance.</para>

	  <para>The master key will be protected with a passphrase and
	    the data source for the key file will be
	    <devicename>/dev/random</devicename>.  The sector size of
	    the provider <devicename>/dev/da2.eli</devicename> will be
	    4kB.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/root/da2.key bs=64 count=1</userinput>
&prompt.root; <userinput>geli init -s 4096 -K /root/da2.key /dev/da2</userinput>
Enter new passphrase:
Reenter new passphrase:</screen>

	  <para>It is not mandatory to use both a passphrase and a key
	    file as either method of securing the master key can be
	    used in isolation.</para>

	  <para>If the key file is given as <quote>-</quote>, standard
	    input will be used.  This example shows how more than one
	    key file can be used:</para>

	  <screen>&prompt.root; <userinput>cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</userinput></screen>
	</step>

	<step>
	  <title>Attaching the Provider with the Generated Key</title>

	  <screen>&prompt.root; <userinput>geli attach -k /root/da2.key /dev/da2</userinput>
Enter passphrase:</screen>

	  <para>The new plaintext device will be named
	    <filename>/dev/<replaceable>da2</replaceable>.eli</filename>.</para>

	  <screen>&prompt.root; <userinput>ls /dev/da2*</userinput>
/dev/da2  /dev/da2.eli</screen>
	</step>

	<step>
	  <title>Creating the New File System</title>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/da2.eli bs=1m</userinput>
&prompt.root; <userinput>newfs /dev/da2.eli</userinput>
&prompt.root; <userinput>mount /dev/da2.eli /private</userinput></screen>

	  <para>The encrypted file system should now be visible to
	    &man.df.1; and be available for use:</para>

	  <screen>&prompt.root; <userinput>df -H</userinput>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</screen>
	</step>

	<step>
	  <title>Unmounting and Detaching the Provider</title>

	  <para>Once the work on the encrypted partition is done, and
	    the <filename class="directory">/private</filename>
	    partition is no longer needed, it is prudent to consider
	    unmounting and detaching the <command>geli</command>
	    encrypted partition from the kernel:</para>

	  <screen>&prompt.root; <userinput>umount /private</userinput>
&prompt.root; <userinput>geli detach da2.eli</userinput></screen>
	</step>
      </procedure>

      <para>More information about the use of &man.geli.8; can be
	found in its manual page.</para>

      <sect3>
	<title>Using the <filename>geli</filename>
	  <filename>rc.d</filename> Script</title>

	<para><command>geli</command> comes with a
	  <filename>rc.d</filename> script which can be used to
	  simplify the usage of <command>geli</command>.  An example
	  of configuring <command>geli</command> through
	  &man.rc.conf.5; follows:</para>

	<programlisting>geli_devices="da2"
geli_da2_flags="-p -k /root/da2.key"</programlisting>

	<para>This configures <devicename>/dev/da2</devicename> as a
	  <command>geli</command> provider of which the master key
	  file is located in <filename>/root/da2.key</filename>.
	  <command>geli</command> will not use a passphrase when
	  attaching to the provider if
	  <option>-P</option> was given during the
	  <literal>geli init</literal> phase.  The system will detach
	  the <command>geli</command> provider from the kernel before
	  the system shuts down.</para>

	<para>More information about configuring
	  <filename>rc.d</filename> is provided in the
	  <link linkend="configtuning-rcd">rc.d</link> section of the
	  Handbook.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="swap-encrypting">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Christian</firstname>
	  <surname>Br&uuml;ffer</surname>
	  <contrib>Written by </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Encrypting Swap Space</title>

    <indexterm>
      <primary>swap</primary>
      <secondary>encrypting</secondary>
    </indexterm>

    <para>Swap encryption in &os; is easy to configure.  Depending on
      which version of &os; is being used, different options are
      available and configuration can vary slightly.  The &man.gbde.8;
      or &man.geli.8; encryption systems can be used for swap
      encryption.  Both systems use the <filename>encswap</filename>
      <link linkend="configtuning-rcd">rc.d</link> script.</para>

    <sect2>
      <title>Why Should Swap be Encrypted?</title>

      <para>Like the encryption of disk partitions, encryption of swap
	space is used to protect sensitive information.  Consider an
	application that deals with passwords.  As long as these
	passwords stay in physical memory, all is well.  However, if
	the operating system starts swapping out memory pages to free
	space for other applications, the passwords may be written to
	the disk platters unencrypted.  Encrypting swap space can be a
	solution for this scenario.</para>
    </sect2>

    <sect2>
      <title>Preparation</title>

      <note>
	<para>For the remainder of this section,
	  <devicename>ad0s1b</devicename> will be the swap
	  partition.</para>
      </note>

      <para>By default, swap is unencrypted.  It is possible that it
	contains passwords or other sensitive data in cleartext.  To
	rectify this, the data on the swap partition should be
	overwritten with random garbage:</para>

      <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/ad0s1b bs=1m</userinput></screen>
    </sect2>

    <sect2>
      <title>Swap Encryption with &man.gbde.8;</title>

      <para>The <literal>.bde</literal> suffix should be added to the
	device in the respective <filename>/etc/fstab</filename> swap
	line:</para>

      <programlisting># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ad0s1b.bde		none		swap	sw		0	0</programlisting>
    </sect2>

    <sect2>
      <title>Swap Encryption with &man.geli.8;</title>

      <para>The procedure for instead using &man.geli.8; for swap
	encryption is similar to that of using &man.gbde.8;.  The
	<literal>.eli</literal> suffix should be added to the device
	in the respective <filename>/etc/fstab</filename> swap
	line:</para>

      <programlisting># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ad0s1b.eli		none		swap	sw		0	0</programlisting>

      <para>&man.geli.8; uses the <acronym>AES</acronym> algorithm
	with a key length of 128 bit by default.  These defaults can
	be altered by using <literal>geli_swap_flags</literal> in
	<filename>/etc/rc.conf</filename>.  The following line tells
	the <filename>encswap</filename> rc.d script to create
	&man.geli.8; swap partitions using the Blowfish algorithm with
	a key length of 128 bits and a sectorsize of 4 kilobytes, and
	sets <quote>detach on last close</quote>:</para>

      <programlisting>geli_swap_flags="-e blowfish -l 128 -s 4096 -d"</programlisting>

      <para>Refer to the description of
	<command>onetime</command> in &man.geli.8; for a list of
	possible options.</para>
    </sect2>

    <sect2>
      <title>Verifying That it Works</title>

      <para>Once the system has rebooted, proper operation of the
	encrypted swap can be verified using
	<command>swapinfo</command>.</para>

      <para>If &man.gbde.8; is being used:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%</screen>

      <para>If &man.geli.8; is being used:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%</screen>
    </sect2>
  </sect1>

  <sect1 id="disks-hast">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Daniel</firstname>
	  <surname>Gerzo</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Freddie</firstname>
	  <surname>Cash</surname>
	  <contrib>With inputs from </contrib>
	</author>
	<author>
	  <firstname>Pawel Jakub</firstname>
	  <surname>Dawidek</surname>
	</author>
	<author>
	  <firstname>Michael W.</firstname>
	  <surname>Lucas</surname>
	</author>
	<author>
	  <firstname>Viktor</firstname>
	  <surname>Petersson</surname>
	</author>
      </authorgroup>
      <!-- Date of writing: 26 February 2011 -->
    </sect1info>

    <title>Highly Available Storage (HAST)</title>

    <indexterm>
      <primary>HAST</primary>
      <secondary>high availability</secondary>
    </indexterm>

    <sect2>
      <title>Synopsis</title>

      <para>High availability is one of the main requirements in
	serious business applications and highly-available storage is
	a key component in such environments.  Highly Available
	STorage, or <acronym>HAST<remark role="acronym">Highly
	    Available STorage</remark></acronym>, was developed by
	&a.pjd; as a framework which allows transparent storage of the
	same data across several physically separated machines
	connected by a TCP/IP network.  <acronym>HAST</acronym> can be
	understood as a network-based RAID1 (mirror), and is similar
	to the DRBD&reg; storage system known from the GNU/&linux;
	platform.  In combination with other high-availability
	features of &os; like <acronym>CARP</acronym>,
	<acronym>HAST</acronym> makes it possible to build a
	highly-available storage cluster that is resistant to hardware
	failures.</para>

      <para>After reading this section, you will know:</para>

      <itemizedlist>
	<listitem>
	  <para>What <acronym>HAST</acronym> is, how it works and
	    which features it provides.</para>
	</listitem>

	<listitem>
	  <para>How to set up and use <acronym>HAST</acronym> on
	    &os;.</para>
	</listitem>

	<listitem>
	  <para>How to integrate <acronym>CARP</acronym> and
	    &man.devd.8; to build a robust storage system.</para>
	</listitem>
      </itemizedlist>

      <para>Before reading this section, you should:</para>

      <itemizedlist>
	<listitem>
	  <para>Understand &unix; and <link
	      linkend="basics">&os; basics</link>.</para>
	</listitem>

	<listitem>
	  <para>Know how to <link
	      linkend="config-tuning">configure</link> network
	    interfaces and other core &os; subsystems.</para>
	</listitem>

	<listitem>
	  <para>Have a good understanding of <link
	      linkend="network-communication">&os;
	      networking</link>.</para>
	</listitem>

	<listitem>
	  <para>Use &os;&nbsp;8.1-RELEASE or newer.</para>
	</listitem>
      </itemizedlist>

      <para>The <acronym>HAST</acronym> project was sponsored by The
	&os; Foundation with support from <ulink
	  url="http://www.omc.net/">OMCnet Internet Service
	  GmbH</ulink> and <ulink url="http://www.transip.nl/">TransIP
	  BV</ulink>.</para>
    </sect2>

    <sect2>
      <title>HAST Features</title>

      <para>The main features of the <acronym>HAST</acronym> system
	are:</para>

      <itemizedlist>
	<listitem>
	  <para>Can be used to mask I/O errors on local hard
	    drives.</para>
	</listitem>

	<listitem>
	  <para>File system agnostic as it works with any file
	    system supported by &os;.</para>
	</listitem>

	<listitem>
	  <para>Efficient and quick resynchronization, synchronizing
	    only blocks that were modified during the downtime of a
	    node.</para>
	</listitem>

	<!--
	<listitem>
	  <para>Has several synchronization modes to allow for fast
	    failover.</para>
	</listitem>
	-->

	<listitem>
	  <para>Can be used in an already deployed environment to add
	    additional redundancy.</para>
	</listitem>

	<listitem>
	  <para>Together with <acronym>CARP</acronym>,
	    <application>Heartbeat</application>, or other tools, it
	    can be used to build a robust and durable storage
	    system.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>HAST Operation</title>

      <para>As <acronym>HAST</acronym> provides a synchronous
	block-level replication of any storage media to several
	machines, it requires at least two physical machines:
	the <literal>primary</literal>, also known as the
	<literal>master</literal> node, and the
	<literal>secondary</literal> or <literal>slave</literal>
	node.  These two machines together are referred to as a
	cluster.</para>

      <note>
	<para>HAST is currently limited to two cluster nodes in
	  total.</para>
      </note>

      <para>Since <acronym>HAST</acronym> works in a
	primary-secondary configuration, it allows only one of the
	cluster nodes to be active at any given time.  The
	<literal>primary</literal> node, also called
	<literal>active</literal>, is the one which will handle all
	the I/O requests to <acronym>HAST</acronym>-managed
	devices.  The <literal>secondary</literal> node is
	automatically synchronized from the <literal>primary</literal>
	node.</para>

      <para>The physical components of the <acronym>HAST</acronym>
	system are:</para>

      <itemizedlist>
	<listitem>
	  <para>local disk on primary node, and</para>
	</listitem>

	<listitem>
	  <para>disk on remote, secondary node.</para>
	</listitem>
      </itemizedlist>

      <para><acronym>HAST</acronym> operates synchronously on a block
	level, making it transparent to file systems and applications.
	<acronym>HAST</acronym> provides regular GEOM providers in
	<filename class="directory">/dev/hast/</filename> for use by
	other tools or applications, thus there is no difference
	between using <acronym>HAST</acronym>-provided devices and
	raw disks or partitions.</para>

      <para>Each write, delete, or flush operation is sent to the
	local disk and to the remote disk over TCP/IP.  Each read
	operation is served from the local disk, unless the local disk
	is not up-to-date or an I/O error occurs.  In such case, the
	read operation is sent to the secondary node.</para>

      <sect3>
	<title>Synchronization and Replication Modes</title>

	<para><acronym>HAST</acronym> tries to provide fast failure
	  recovery.  For this reason, it is very important to reduce
	  synchronization time after a node's outage.  To provide fast
	  synchronization, <acronym>HAST</acronym> manages an on-disk
	  bitmap of dirty extents and only synchronizes those during a
	  regular synchronization, with an exception of the initial
	  sync.</para>

	<para>There are many ways to handle synchronization.
	  <acronym>HAST</acronym> implements several replication modes
	  to handle different synchronization methods:</para>

	<itemizedlist>
	  <listitem>
	    <para><emphasis>memsync</emphasis>: report write operation
	      as completed when the local write operation is finished
	      and when the remote node acknowledges data arrival, but
	      before actually storing the data.  The data on the
	      remote node will be stored directly after sending the
	      acknowledgement.  This mode is intended to reduce
	      latency, but still provides very good reliability.  The
	      <emphasis>memsync</emphasis> replication mode is
	      currently not implemented.</para>
	  </listitem>

	  <listitem>
	    <para><emphasis>fullsync</emphasis>: report write
	      operation as completed when local write completes and
	      when remote write completes.  This is the safest and the
	      slowest replication mode.  This mode is the
	      default.</para>
	  </listitem>

	  <listitem>
	    <para><emphasis>async</emphasis>: report write operation
	      as completed when local write completes.  This is the
	      fastest and the most dangerous replication mode.  It
	      should be used when replicating to a distant node where
	      latency is too high for other modes.  The
	      <emphasis>async</emphasis> replication mode is currently
	      not implemented.</para>
	  </listitem>
	</itemizedlist>

	<warning>
	  <para>Only the <emphasis>fullsync</emphasis> replication
	    mode is currently supported.</para>
	</warning>
      </sect3>
    </sect2>

    <sect2>
      <title>HAST Configuration</title>

      <para><acronym>HAST</acronym> requires
	<literal>GEOM_GATE</literal> support which is not present in
	the default <literal>GENERIC</literal> kernel.  However, the
	<varname>geom_gate.ko</varname> loadable module is available
	in the default &os; installation.  Alternatively, to build
	<literal>GEOM_GATE</literal> support into the kernel
	statically, add this line to the custom kernel configuration
	file:</para>

      <programlisting>options	GEOM_GATE</programlisting>

      <para>The <acronym>HAST</acronym> framework consists of several
	parts from the operating system's point of view:</para>

      <itemizedlist>
	<listitem>
	  <para>the &man.hastd.8; daemon responsible for data
	    synchronization,</para>
	</listitem>

	<listitem>
	  <para>the &man.hastctl.8; userland management
	    utility,</para>
	</listitem>

	<listitem>
	  <para>and the &man.hast.conf.5; configuration file.</para>
	</listitem>
      </itemizedlist>

      <para>The following example describes how to configure two nodes
	in <literal>master</literal>-<literal>slave</literal> /
	<literal>primary</literal>-<literal>secondary</literal>
	operation using <acronym>HAST</acronym> to replicate the data
	between the two.  The nodes will be called
	<literal><replaceable>hasta</replaceable></literal> with an IP
	address of <replaceable>172.16.0.1</replaceable> and
	<literal><replaceable>hastb</replaceable></literal> with an IP
	of address <replaceable>172.16.0.2</replaceable>.  Both nodes
	will have a dedicated hard drive
	<devicename>/dev/<replaceable>ad6</replaceable></devicename>
	of the same size for <acronym>HAST</acronym> operation.  The
	<acronym>HAST</acronym> pool, sometimes also referred to as a
	resource or the GEOM provider in <filename
	  class="directory">/dev/hast/</filename>, will be
	called
	<filename><replaceable>test</replaceable></filename>.</para>

      <para>Configuration of <acronym>HAST</acronym> is done using
	<filename>/etc/hast.conf</filename>.  This file should be the
	same on both nodes.  The simplest configuration possible
	is:</para>

      <programlisting>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</programlisting>

      <para>For more advanced configuration, refer to
	&man.hast.conf.5;.</para>

      <tip>
	<para>It is also possible to use host names in the
	  <literal>remote</literal> statements.  In such a case, make
	  sure that these hosts are resolvable and are defined in
	  <filename>/etc/hosts</filename> or in the local
	  <acronym>DNS</acronym>.</para>
      </tip>

      <para>Now that the configuration exists on both nodes,
	the <acronym>HAST</acronym> pool can be created.  Run these
	commands on both nodes to place the initial metadata onto the
	local disk and to start &man.hastd.8;:</para>

      <screen>&prompt.root; <userinput>hastctl create test</userinput>
&prompt.root; <userinput>service hastd onestart</userinput></screen>

      <note>
	<para>It is <emphasis>not</emphasis> possible to use GEOM
	  providers with an existing file system or to convert an
	  existing storage to a <acronym>HAST</acronym>-managed pool.
	  This procedure needs to store some metadata on the provider
	  and there will not be enough required space
	  available on an existing provider.</para>
      </note>

      <para>A HAST node's <literal>primary</literal> or
	<literal>secondary</literal> role is selected by an
	administrator, or software like
	<application>Heartbeat</application>, using &man.hastctl.8;.
	On the primary node,
	<literal><replaceable>hasta</replaceable></literal>, issue
	this command:</para>

      <screen>&prompt.root; <userinput>hastctl role primary test</userinput></screen>

      <para>Similarly, run this command on the secondary node,
	<literal><replaceable>hastb</replaceable></literal>:</para>

      <screen>&prompt.root; <userinput>hastctl role secondary test</userinput></screen>

      <caution>
	<para>When the nodes are unable to communicate with each
	  other, and both are configured as primary nodes, the
	  condition is called <literal>split-brain</literal>.  To
	  troubleshoot this situation, follow the steps described in
	  <link linkend="disks-hast-sb"></link>.</para>
      </caution>

      <para>Verify the result by running &man.hastctl.8; on each
	node:</para>

      <screen>&prompt.root; <userinput>hastctl status test</userinput></screen>

      <para>The important text is the <literal>status</literal> line,
	which should say <literal>complete</literal>
	on each of the nodes.  If it says <literal>degraded</literal>,
	something went wrong.  At this point, the synchronization
	between the nodes has already started.  The synchronization
	completes when <command>hastctl status</command>
	reports 0 bytes of <literal>dirty</literal> extents.</para>


      <para>The next step is to create a filesystem on the
	<devicename>/dev/hast/<replaceable>test</replaceable></devicename>
	GEOM provider and mount it.  This must be done on the
	<literal>primary</literal> node, as
	<filename>/dev/hast/<replaceable>test</replaceable></filename>
	appears only on the <literal>primary</literal> node.  Creating
	the filesystem can take a few minutes, depending on the size
	of the hard drive:</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/hast/test</userinput>
&prompt.root; <userinput>mkdir /hast/test</userinput>
&prompt.root; <userinput>mount /dev/hast/test /hast/test</userinput></screen>

      <para>Once the <acronym>HAST</acronym> framework is configured
	properly, the final step is to make sure that
	<acronym>HAST</acronym> is started automatically during
	system boot.  Add this line to
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>hastd_enable="YES"</programlisting>

      <sect3>
	<title>Failover Configuration</title>

	<para>The goal of this example is to build a robust storage
	  system which is resistant to the failure of any given node.
	  The scenario is that a <literal>primary</literal> node of
	  the cluster fails.  If this happens, the
	  <literal>secondary</literal> node is there to take over
	  seamlessly, check and mount the file system, and continue to
	  work without missing a single bit of data.</para>

	<para>To accomplish this task, another &os; feature,
	  <acronym>CARP</acronym>, provides for automatic failover on
	  the IP layer.  <acronym>CARP</acronym> (Common
	  Address Redundancy Protocol) allows multiple hosts on the
	  same network segment to share an IP address.  Set up
	  <acronym>CARP</acronym> on both nodes of the cluster
	  according to the documentation available in
	  <link linkend="carp"></link>.  After setup, each node will
	  have its own <devicename>carp0</devicename> interface with a
	  shared IP address of
	  <replaceable>172.16.0.254</replaceable>.  The primary
	  <acronym>HAST</acronym> node of the cluster must be the
	  master <acronym>CARP</acronym> node.</para>

	<para>The <acronym>HAST</acronym> pool created in the previous
	  section is now ready to be exported to the other hosts on
	  the network.  This can be accomplished by exporting it
	  through <acronym>NFS</acronym> or
	  <application>Samba</application>, using the shared IP
	  address <replaceable>172.16.0.254</replaceable>.  The only
	  problem which remains unresolved is an automatic failover
	  should the primary node fail.</para>

	<para>In the event of <acronym>CARP</acronym> interfaces going
	  up or down, the &os; operating system generates a
	  &man.devd.8; event, making it possible to watch for state
	  changes on the <acronym>CARP</acronym> interfaces.  A state
	  change on the <acronym>CARP</acronym> interface is an
	  indication that one of the nodes failed or came back online.
	  These state change events make it possible to run a script
	  which will automatically handle the HAST failover.</para>

	<para>To be able to catch state changes on the
	  <acronym>CARP</acronym> interfaces, add this
	  configuration to
	  <filename>/etc/devd.conf</filename> on each node:</para>

	<programlisting>notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_UP";
	action "/usr/local/sbin/carp-hast-switch master";
};

notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_DOWN";
	action "/usr/local/sbin/carp-hast-switch slave";
};</programlisting>

	<para>Restart &man.devd.8; on both nodes to put the new
	  configuration into effect:</para>

	<screen>&prompt.root; <userinput>service devd restart</userinput></screen>

	<para>When the <devicename>carp0</devicename> interface state
	  changes by going up or down , the system generates a
	  notification, allowing the &man.devd.8; subsystem to run an
	  arbitrary script, in this case
	  <filename>/usr/local/sbin/carp-hast-switch</filename>.  This
	  script handles the automatic failover.  For further
	  clarification about the above &man.devd.8; configuration,
	  refer to &man.devd.conf.5;.</para>

	<para>An example of such a script could be:</para>

	<programlisting>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources="test"

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log="local0.debug"
name="carp-hast"

# end of user configurable stuff

case "$1" in
	master)
		logger -p $log -t $name "Switching to primary provider for ${resources}."
		sleep ${delay}

		# Wait for any "hastd secondary" processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf "hastd: ${disk} \(secondary\)" > /dev/null 2>&1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to change role to primary for resource ${disk}."
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c "/dev/hast/${disk}" ] && break
				sleep 0.5
			done

			if [ ! -c "/dev/hast/${disk}" ]; then
				logger -p $log -t $name "GEOM provider /dev/hast/${disk} did not appear."
				exit 1
			fi
		done

		logger -p $log -t $name "Role for HAST resources ${resources} switched to primary."


		logger -p $log -t $name "Mounting disks."
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name "Switching to secondary provider for ${resources}."

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q "^/dev/hast/${disk} on "
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2>&1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to switch role to secondary for resource ${disk}."
				exit 1
			fi
			logger -p $log -t $name "Role switched to secondary for resource ${disk}."
		done
	;;
esac</programlisting>

	<para>In a nutshell, the script takes these actions when a
	  node becomes <literal>master</literal> /
	  <literal>primary</literal>:</para>

	<itemizedlist>
	  <listitem>
	    <para>Promotes the <acronym>HAST</acronym> pools to
	      primary on a given node.</para>
	  </listitem>

	  <listitem>
	    <para>Checks the file system under the
	      <acronym>HAST</acronym> pool.</para>
	  </listitem>

	  <listitem>
	    <para>Mounts the pools at an appropriate place.</para>
	  </listitem>
	</itemizedlist>

	<para>When a node becomes <literal>backup</literal> /
	  <literal>secondary</literal>:</para>

	<itemizedlist>
	  <listitem>
	    <para>Unmounts the <acronym>HAST</acronym> pools.</para>
	  </listitem>

	  <listitem>
	    <para>Degrades the <acronym>HAST</acronym> pools to
	      secondary.</para>
	  </listitem>
	</itemizedlist>

	<caution>
	  <para>Keep in mind that this is just an example script which
	    serves as a proof of concept.  It does not handle all the
	    possible scenarios and can be extended or altered in any
	    way, for example, to start/stop required services.</para>
	</caution>

	<tip>
	  <para>For this example, a standard UFS file system was used.
	    To reduce the time needed for recovery, a journal-enabled
	    UFS or ZFS file system can be used instead.</para>
	</tip>

	<para>More detailed information with additional examples can
	  be found in the
	  <ulink url="http://wiki.FreeBSD.org/HAST">HAST Wiki</ulink>
	  page.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Troubleshooting</title>

      <sect3>
	<title>General Troubleshooting Tips</title>

	<para><acronym>HAST</acronym> should generally work without
	  issues.  However, as with any other software product, there
	  may be times when it does not work as supposed.  The sources
	  of the problems may be different, but the rule of thumb is
	  to ensure that the time is synchronized between all nodes of
	  the cluster.</para>

	<para>When troubleshooting <acronym>HAST</acronym> problems,
	  the debugging level of &man.hastd.8; should be increased by
	  starting &man.hastd.8; with <literal>-d</literal>.  This
	  argument may be specified multiple times to further increase
	  the debugging level.  A lot of useful information may be
	  obtained this way.  Consider also using
	  <literal>-F</literal>, which starts &man.hastd.8; in the
	  foreground.</para>
      </sect3>

      <sect3 id="disks-hast-sb">
	<title>Recovering from the Split-brain Condition</title>

	<para><literal>Split-brain</literal> is when the nodes of the
	  cluster are unable to communicate with each other, and both
	  are configured as primary.  This is a dangerous condition
	  because it allows both nodes to make incompatible changes to
	  the data.  This problem must be corrected manually by the
	  system administrator.</para>

	<para>The administrator must decide which node has more
	  important changes (or merge them manually) and let
	  <acronym>HAST</acronym> perform full synchronization of the
	  node which has the broken data.  To do this, issue these
	  commands on the node which needs to be
	  resynchronized:</para>

	<screen>&prompt.root; <userinput>hastctl role init &lt;resource&gt;</userinput>
&prompt.root; <userinput>hastctl create &lt;resource&gt;</userinput>
&prompt.root; <userinput>hastctl role secondary &lt;resource&gt;</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>
