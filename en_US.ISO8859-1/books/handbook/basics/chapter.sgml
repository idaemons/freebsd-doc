<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO8859-1/books/handbook/basics/chapter.sgml,v 1.39 2001/08/11 20:39:17 jim Exp $
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>Rewritten by </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
  </chapterinfo>

  <title>Unix Basics</title>
  
  <sect1>
    <title>Synopsis</title>
    <indexterm><primary>basics</primary></indexterm>


   <para>The following chapter will cover the basic commands and
     functionality of the FreeBSD operating system.  If you are new to
     FreeBSD, you will definitely want to read through this chapter before
     asking for help.</para>
  </sect1>

  <sect1 id="permissions">
    <title>Permissions</title>
    <indexterm><primary>Unix</primary></indexterm>

    <para>FreeBSD, having its history rooted in BSD Unix, has its
      fundamentals based on several key Unix concepts.  The first, and
      most pronounced, is that FreeBSD is a multi-user operating system.
      The system can handle several users all working simultaneously on
      completely unrelated tasks.  The system is responsible for properly
      sharing and managing requests for hardware devices, peripherals,
      memory, and CPU time evenly to each user.</para>

    <para>Because the system is capable of supporting multiple users,
      everything the system manages has a set of permissions governing who
      can read, write, and execute the resource.  These permissions are
      stored as two octets broken into three pieces, one for the owner of
      the file, one for the group that the file belongs to, and one for
      everyone else.  This numerical representation works like
      this:</para>

    <indexterm><primary>permissions</primary></indexterm>
    <indexterm>
      <primary>file permissions</primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Value</entry>
	    <entry>Permission</entry>
	    <entry>Directory Listing</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>No read, no write, no execute</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>No read, no write, execute</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>No read, write, no execute</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>No read, write, execute</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Read, no write, no execute</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Read, no write, execute</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Read, write, no execute</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Read, write, execute</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>directories</primary></indexterm>

    <para>For the long directory listing by <command>ls -l</command>, a
      column will show a file's permissions for the owner, group, and
      everyone else.  Here's how it is broken up:</para>

    <screen>-rw-r--r--</screen>

    <para>The first character, from left to right, is a special character
      that tells if this is a regular file, a directory, a special
      character or block device, a socket, or any other special
      pseudo-file device.  The  next three characters, designated as
      <literal>rw-</literal> gives the permissions for the owner of the
      file.  The next three characters, <literal>r--</literal> gives the
      permissions for the group that the file belongs to.  The final three
      characters, <literal>r--</literal>, gives the permissions for the
      rest of the world.  A dash means that the permission is turned off.
      In the case of this file, the permissions are set so the owner can
      read and write to the file, the group can read the file, and the
      rest of the world can only read the file.  According to the table
      above, the permissions for this file would be
      <literal>644</literal>, where each digit represents the three parts
      of the file's permission.</para>

    <para>This is all well and good, but how does the system control
      permissions on devices? FreeBSD actually treats most hardware
      devices as a file that programs can open, read, and write data to
      just like any other file.  These special device files are stored on
      the <filename>/dev</filename> directory.</para>

    <para>Directories are also treated as files.  They have read, write,
      and execute permissions.  The executable bit for a directory has a
      slightly different meaning than that of files.  When a directory is
      marked executable, it means it can be searched into, for example,  a
      directory listing can be done in that directory.</para>

    <para>There are more to permissions, but they are primarily used in
      special circumstances such as setuid binaries and sticky
      directories.  If you want more information on file permissions and
      how to set them, be sure to look at the &man.chmod.1; man
      page.</para>
  </sect1>

  <sect1 id="dirstructure">
    <title>Directory Structures</title>
    <indexterm><primary>directory hierarchy</primary></indexterm>

    <para>Since FreeBSD uses its file systems to determine many
      fundamental system operations, the hierarchy of the file system is
      extremely important.  Due to the fact that the &man.hier.7; manual page
      provides a complete description of the directory structure, it will
      not be duplicated here.  Please read &man.hier.7; for more
      information.</para>
      
    <para>Of significant importance is the root of all directories, the /
      directory.  This directory is the first directory mounted at boot
      time and it contains the base system necessary at boot time.  The
      root directory also contains mount points for every other file
      system that you want to mount.</para>

    <para>A mount point is a directory where additional file systems can
      be grafted onto the root file system.  Standard mount points include
      <filename>/usr</filename>, <filename>/var</filename>,
      <filename>/mnt</filename>, and <filename>/cdrom</filename>.  These
      directories are usually referenced to entries in the file
      <filename>/etc/fstab</filename>.  <filename>/etc/fstab</filename> is
      a table of various file systems and mount points for reference by the
      system.  Most of the file systems in <filename>/etc/fstab</filename>
      are mounted automatically at boot time from the script &man.rc.8;
      unless they contain the <option>noauto</option> option.  Consult the
      &man.fstab.5; manual page for more information on the format of the
      <filename>/etc/fstab</filename> file and the options it
      contains.</para>
  </sect1>

  <sect1 id="basics-processes">
    <title>Processes</title>

    <para>FreeBSD is a multi-tasking operating system.  This means that it
      seems as though more than one program is running at once.  Each program
      running at any one time is called a <firstterm>process</firstterm>.
      Every command you run will start at least one new process, and there are
      a number of system processes that run all the time, keeping the system
      functional.</para>

    <para>Each process is uniquely identified by a number called a
      <firstterm>process ID</firstterm>, or <firstterm>PID</firstterm>, and,
      like files, each process also has one owner and group.  The owner and
      group information is used to determine what files and devices the
      process can open, using the file permissions discussed earlier.  Most
      processes also have a parent process.  The parent process is the process
      that started them.  For example, if you are typing commands to the shell
      then the shell is a process, and any commands you run are also
      processes.  Each process you run in this way will have your shell as its
      parent process.  The exception to this is a special process called
      <command>init</command>.  <command>init</command> is always the first
      process, so its PID is always 1.  <command>init</command> is started
      automatically by the kernel when FreeBSD starts.</para>

    <para>Two commands are particularly useful to see the processes on the
      system, &man.ps.1; and &man.top.1;.  The &man.ps.1; command is used to
      show a static list of the currently running processes, and can show
      their PID, how much memory they are using, the command line they were
      started with, and so on.  The &man.top.1; command displays all the
      running processes, and updates the display every few seconds, so that
      you can interactively see what your computer is doing.</para>

    <para>By default, &man.ps.1; only shows you the commands that are running
      and are owned by you.  For example;</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>As you can see in this example, the output from &man.ps.1; is
      organized in to a number of columns.  <literal>PID</literal> is the
      process ID discussed earlier.  PIDs are assigned starting from 1, go up
      to 65536, and wrap around back to the beginning when you run out.
      <literal>TT</literal> shows the tty the program is running on, and can
      safely be ignore for the moment.  <literal>STAT</literal> shows the
      program's state, and again, can be safely ignored.
      <literal>TIME</literal> is the amount of time the program has been
      running on the CPU&mdash;this is not necessarily the elapsed time since
      you started the program, as some programs spend a lot of time waiting
      for things to happen before they need to spend time on the CPU.
      Finally, <literal>COMMAND</literal> is the command line that was used to
      run the program.</para>

    <para>&man.ps.1; supports a number of different options to change the
      information that is displayed.  One of the most useful sets is
      <literal>auxww</literal>.  <option>a</option> displays information
      about all the running processes, not just your own.  <option>u</option>
      displays the username of the process' owner, as well as memory usage.
      <option>x</option> displays information about daemon processes, and
      <option>ww</option> causes &man.ps.1; to display the full command line,
      rather than truncating it once it gets too long to fit on the
      screen.</para>

    <para>The output from &man.top.1; is similar.  A sample session looks like
      this;</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>The output is split in to two sections.  The header (the first five
      lines) shows the PID of the last process to run, the system load averages
      (which are a measure of how busy the system is), the system uptime (time
      since the last reboot) and the current time.  The other figures in the
      header relate to how many processes are running (47 in this case), how
      much memory and swap space has been taken up, and how much time the
      system is spending in different CPU states.</para>

    <para>Below that are a series of columns containing similar information
      to the output from &man.ps.1;.  As before you can see the PID, the
      username, the amount of CPU time taken, and the command that was run.
      &man.top.1; also defaults to showing you the amount of memory space
      taken by the process.  This is split in to two columns, one for total
      size, and one for resident size&mdash;total size is how much memory the
      application has needed, and the resident size is how much it is actually
      using at the moment.  In this example you can see that Netscape has
      needed almost 30 MB of RAM, and is currently only needing 9 MB.</para>

    <para>&man.top.1; automatically updates this display every two seconds;
      this can be changed with the <option>s</option> option.</para>
  </sect1>

  <sect1>
    <title>Daemons, Signals, and Killing Processes</title>

    <para>When you run an editor it is easy to control the editor, tell it to
      load files, and so on.  You can do this because the editor provides
      facilities to do so, and because the editor is attached to a
      <firstterm>terminal</firstterm>.  Some programs are not designed to be
      run with continuous user input, and so they disconnect from the terminal
      at the first opportunity.  For example, a web server spends all day
      responding to web requests, it normally does not need any input from
      you.  Programs that transport email from site to site are another
      example of this class of application.</para>

    <para>We call these programs <firstterm>daemons</firstterm>.  Daemons were
      characters in Greek mythology; neither good or evil, they were little
      attendant spirits that, by and large, did useful things for mankind.
      Much like the web servers and mail servers of today do useful things.
      This is why the BSD mascot has, for a long time, been the cheerful
      looking daemon with sneakers and a pitchfork.</para>

    <para>There is a convention to name programs that normally run as daemons
      with a trailing <quote>d</quote>. <application>BIND</application> is the
      Berkeley Internet Name Daemon (and the program you can is called
      <command>named</command>), the <application>Apache</application> web
      server program is called <command>httpd</command>, the line printer
      spooling daemon is <command>lpd</command> and so on.  This is a
      convention, not a hard and fast rule; for example, the main mail daemon
      for the <application>Sendmail</application> application is called
      <command>sendmail</command>, and not <command>maild</command>, as you
      might imagine.</para>

    <para>Sometimes you will need to communicate with a daemon process.  These
      communications are called <firstterm>signals</firstterm>, and you can
      communicate with daemons (or with any running process) by sending it a
      signal.  There are a number if different signals that you can
      send&mdash;some of them have a specific meaning, others are interpreted
      by the application, and the application's documentation will tell you
      how that application interprets signals.  You can only send a signal to
      a process that you own.  If you try and send a signal to someone else's
      process it will be ignored.  The exception to this is the
      <username>root</username> user, who can send signals to everyone's
      processes.</para>

    <para>FreeBSD will also send applications signals in some cases.  If an
      application is badly written, and tries to access memory that it is not
      supposed to, FreeBSD sends the process the <firstterm>Segmentation
	Violation</firstterm> signal (<literal>SIGSEGV</literal>).  If an
      application has used the &man.alarm.3; system call to be alerted after a
      period of time has elapsed then it will be sent the Alarm signal
      (<literal>SIGALRM</literal>), and so on.</para>

    <para>Two signals can be used to stop a process,
      <literal>SIGTERM</literal> and <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> is the polite way to kill a process; the
      process can <emphasis>catch</emphasis> the signal, realize that you want
      it to shut down, close any log files it may have open, and generally
      finish whatever it is doing at the time before shutting down.  In some
      cases a process may even ignore <literal>SIGTERM</literal> if it is in
      the middle of some task that can not be interrupted.</para>

    <para><literal>SIGKILL</literal> can not be ignored by a process.  This is
      the <quote>I don't care what you are doing, stop right now</quote>
      signal.  If you send <literal>SIGKILL</literal> to a process then
      FreeBSD will stop that process there and then<footnote>
	<para>Not quite true&mdash;there are a few things that can not be
	  interrupted.  For example, if the process is trying to read from a
	  file that is on another computer on the network, and the other
	  computer has gone away for some reason (been turned off, or the
	  network has a fault), then the process is said to be
	  <quote>uninterruptible</quote>.  Eventually the process will time
	  out, typically after two minutes.  As soon as this time out occurs
	  the process will be killed.</para>
      </footnote>.</para>

    <para>The other signals you might want to use are
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal>, and
      <literal>SIGUSR2</literal>.  These are general purpose signals, and
      different applications will do different things when they are
      sent.</para>

    <para>Suppose that you have changed your web server's configuration
      file&mdash;you would like to tell the web server to re-read its
      configuration.  You could stop and restart <command>httpd</command>, but
      this would result in a brief outage period on your web server, which may
      be undesirable.  Most daemons are written to respond to the
      <literal>SIGHUP</literal> signal by re-reading their configuration
      file.  So instead of killing and restarting <command>httpd</command> you
      would send it the <literal>SIGHUP</literal> signal.  Because there is no
      standard way to respond to these signals, different daemons will have
      different behavior, so be sure and read the documentation for the
      daemon in question.</para>
    
    <para>Signals are sent using the &man.kill.1; command, as this example
      shows.</para>

    <procedure>
      <title>Sending a Signal to a Process</title>

      <para>This example shows how to send a signal to &man.inetd.8;.  The
	  &man.inetd.8; configuration file is
	<filename>/etc/inetd.conf</filename>, and &man.inetd.8; will re-read
	this configuration file when it is sent
	<literal>SIGHUP</literal>.</para>

      <step>
	<para>Find the process ID of the process you want to send the signal
	  to.  Do this using &man.ps.1; and &man.grep.1;.  The &man.grep.1;
	  command is used to search through output, looking for the string you
	  specify.  This command is run as a normal user, and &man.inetd.8; is
	  run as <username>root</username>, so the <option>ax</option> options
	  must be given to &man.ps.1;.</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>So the &man.inetd.8; PID is 198.  In some cases the
	  <literal>grep inetd</literal> command might also occur in this
	  output.  This is because of the way &man.ps.1; has to find the list
	  of running processes.</para>
      </step>

      <step>
	<para>Use &man.kill.1; to send the signal.  Because &man.inetd.8; is
	  being run by <username>root</username> you must use &man.su.1; to
	  become <username>root</username> first.</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>As is common with Unix commands, &man.kill.1; will not print any
	  output if it is successfully.  If you try and send a signal to a
	  process that you do not own then you will see <errorname>kill:
	    <replaceable>PID</replaceable>: Operation not
	    permitted</errorname>.  If you mistype the PID you will either
	  send the signal to the wrong process, which could be bad, or, if
	  you are lucky, you will have sent the signal to a PID that is not
	  currently in use, and you will see <errorname>kill:
	    <replaceable>PID</replaceable>: No such process</errorname>.</para>

	<note>
	  <title>Why Use <command>/bin/kill</command>?</title>

	  <para>Many shells provide the <command>kill</command> command as a
	    built in command; that is, the shell will send the signal
	    directly, rather than running <filename>/bin/kill</filename>.
	    This can be very useful, but different shells have a different
	    syntax for specifying the name of the signal to send.  Rather than
	    try to learn all of them, it can be simpler just to use the
	    <command>/bin/kill <replaceable>...</replaceable></command>
	    command directly.</para>
	</note>
      </step>
    </procedure>

    <para>Sending other signals is very similar, just substitute
      <literal>TERM</literal> or <literal>KILL</literal> in the command line
      as necessary.</para>

    <important>
      <para>Killing random process on the system can be a bad idea.  In
	particular, &man.init.8;, process ID 1, is very special.  Running
	<command>/bin/kill -s KILL 1</command> is a quick way to shutdown your
	system.  <emphasis>Always</emphasis> double check the arguments you
	run &man.kill.1; with <emphasis>before</emphasis> you press
	<keycap>RETURN</keycap>.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>shells</primary></indexterm>
    <indexterm><primary>command-line</primary></indexterm>

    <para>In FreeBSD, a lot of everyday work is done in a command line
      interface called a shell.  A shell's main job is to take commands
      from the input channel and execute them.  A lot of shells also have
      built in functions to help everyday tasks such a file management,
      file globing, command line editing, command macros, and environment
      variables.  FreeBSD comes with a set of shells, such as 
      <command>sh</command>, the Bourne Shell, and <command>csh</command>, 
      the C-shell.  Many other shells are available
      from the FreeBSD Ports Collection that have much more power, such as
      <command>tcsh</command> and <command>bash</command>.</para>

    <para>Which shell do you use?  It is really a matter of taste.  If you
      are a C programmer you might feel more comfortable with a C-like shell
      such as <command>tcsh</command>.  If you've come from Linux or are new 
      to a Unix command line interface you might try <command>bash</command>.  
      The point is that each
      shell has unique properties that may or may not work with your
      preferred working environment, and that you have a choice of what
      shell to use.</para>

    <para>One common feature in a shell is file-name completion.  Given
      the typing of the first few letters of a command or filename, you
      can usually have the shell automatically complete the rest of the
      command or filename by hitting the TAB key on the keyboard.  Here is
      an example.  Suppose you have two files called
      <filename>foobar</filename> and <filename>foo.bar</filename>.  You
      want to delete <filename>foo.bar</filename>.  So what you would type
      on the keyboard is: <command>rm fo[TAB].[TAB]</command>.</para>

    <para>The shell would print out <command>rm
      foo[BEEP].bar</command>.</para>

    <para>The [BEEP] is the console bell, which is the shell telling me it
      was unable to totally complete the filename because there is more
      than one match.  Both <filename>foobar</filename> and
      <filename>foo.bar</filename> start with <literal>fo</literal>, but
      it was able to complete to <literal>foo</literal>.  If you type in
      <literal>.</literal>, then hit TAB again, the shell would be able to
      fill in the rest of the filename for you.</para>
    <indexterm><primary>environment variables</primary></indexterm>

    <para>Another function of the shell is environment variables.
      Environment variables are a variable key pair stored in the shell's
      environment space.  This space can be read by any program invoked by
      the shell, and thus contains a lot of program configuration.  Here
      is a list of common environment variables and what they mean:</para>
    <indexterm><primary>environment variables</primary></indexterm>

    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Description</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Current logged in user's name.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Colon separated list of directories to search for
	      binaries.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Network name of the X11 display to connect to, if
	      available.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>The current shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>The name of the user's terminal.  Used to determine the
	      capabilities of the terminal.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Database entry of the terminal escape codes to perform
	      various terminal functions.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Type of operating system.  E.g., FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>The CPU architecture that the system is running
	      on.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>The user's preferred text editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>The user's preferred text pager.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Colon separated list of directories to search for
	      manual pages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>To view or set an environment variable differs somewhat from
      shell to shell.  For example, in the C-Style shells such as
      <command>tcsh</command> and <command>csh</command>, you would use
      <command>setenv</command> to set and view environment variables.
      Under Bourne shells such as <command>sh</command> and
      <command>bash</command>, you would use <command>set</command> and
      <command>export</command> to view and set your current environment
      variables.  For example, to set or modify the
      <envar>EDITOR</envar> environment variable, under <command>csh</command> or 
      <command>tcsh</command> a
      command like this would set <envar>EDITOR</envar> to
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Under Bourne shells:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>You can also make most shells expand the environment variable by
      placing a <literal>$</literal> character in front of it on the
      command line.  For example, <command>echo $TERM</command> would
      print out whatever <envar>$TERM</envar> is set to, because the shell
      expands <envar>$TERM</envar> and passes it on to echo.</para>

    <para>Shells treat a lot of special characters, called meta-characters
      as special representations of data.  The most common one is the
      <literal>*</literal> character, which represents any number of
      characters in a filename.  These special meta-characters can be used
      to do file name globing.  For example, typing in
      <command>echo *</command> is almost the same as typing in
      <command>ls</command> because the shell takes all the files that
      match <command>*</command> and puts them on the command line for
      echo to see.</para>

    <para>To prevent the shell from interpreting these special characters,
      they can be escaped from the shell by putting a backslash
      (<literal>\</literal>) character in front of them.  <command>echo
      $TERM</command> prints whatever your terminal is set to.
      <command>echo \$TERM</command> prints <envar>$TERM</envar> as
      is.</para>

    <sect2 id="changing-shells">
      <title>Changing Your Shell</title>

      <para>The easiest way to change your shell is to use the
	<command>chsh</command> command.  Running <command>chsh</command> will
	place you into the editor that is in your <envar>EDITOR</envar>
	environment variable; if it is not set, you will be placed in
	<command>vi</command>.  Change the <quote>Shell:</quote> line
	accordingly.</para>

      <para>You can also give <command>chsh</command> the
	<option>-s</option> option; this will set your shell for you,
	without requiring you to enter an editor.  
	For example, if you wanted to
	change your shell to bash, the following should do the
	trick:</para>
	
      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Running <command>chsh</command> with no parameters and editing
	the shell from there would work also.</para>

      <note>
	<para>The shell that you wish to use <emphasis>must</emphasis> be
	  present in the <filename>/etc/shells</filename> file.  If you
	  have installed a shell from the <link linkend="ports">ports
	  collection</link>, then this should have been done for you
	  already.  If you installed the shell by hand, you must do
	  this.</para>
     
      <para>For example, if you installed <command>bash</command> by hand
	and placed it into <filename>/usr/local/bin</filename>, you would
	want to:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Then rerun <command>chsh</command>.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Text Editors</title>
    <indexterm><primary>text editors</primary></indexterm>
    <indexterm><primary>editors</primary></indexterm>

    <para>A lot of configuration in FreeBSD is done by editing a text
      file.  Because of this, it would be a good idea to become familiar
      with a text editor.  FreeBSD comes with a few as part of the base
      system, and many more are available in the ports collection.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <para>The easiest and simplest editor to learn is an editor called
      <application>ee</application>, which stands for easy editor.  To
      start <application>ee</application>, one would type at the command
      line <command>ee filename</command> where
      <literal>filename</literal> is the name of the file to be edited.
      For example, to edit <filename>/etc/rc.conf</filename>, type in
      <command>ee /etc/rc.conf</command>.  Once inside of 
      <command>ee</command>, all of the
      commands for manipulating the editor's functions are listed at the
      top of the display. The caret <literal>^</literal> character means
      the control key on the keyboard, so ^e expands to pressing the
      control key plus the letter <literal>e</literal>.  To leave
      <application>ee</application>, hit the escape key, then choose leave
      editor.  The editor will prompt you to save any changes if the file
      has been modified.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD also comes with more powerful text editors such as
      <command>vi</command> as part of the base system, and
      <command>emacs</command> and <command>vim</command>
      as part of the FreeBSD Ports Collection.  These editors offer much
      more functionality and power at the expense of being a little more
      complicated to learn.  However if you plan on doing a lot of text
      editing, learning a more powerful editor such as
      <command>vim</command> or <command>emacs</command>
      will save you much more time in the long run.</para>
  </sect1>

  <sect1>
    <title>For More Information...</title>

    <sect2 id="basics-man">
      <title>Manual Pages</title>
      <indexterm><primary>manual pages</primary></indexterm>

      <para>The most comprehensive documentation on FreeBSD is in the form
	of manual pages. Nearly every program on the system comes with a
	short reference manual explaining the basic operation and various
	arguments. These manuals can be viewed with the man command.  Use
	of the man command is simple:</para>

      <screen>&prompt.user; <userinput>man <replaceable>command</replaceable></userinput></screen>

      <para><literal>command</literal> is the name of the command you
        wish to learn about.  For example, to learn more about
	<command>ls</command> command type:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>The online manual is divided up into numbered sections:</para>

      <orderedlist>
	<listitem>
	  <para>User commands.</para>
	</listitem>

	<listitem>
	  <para>System calls and error numbers.</para>
	</listitem>

	<listitem>
	  <para>Functions in the C libraries.</para>
	</listitem>

	<listitem>
	  <para>Device drivers.</para>
	</listitem>

	<listitem>
	  <para>File formats.</para>
	</listitem>

	<listitem>
	  <para>Games and other diversions.</para>
	</listitem>

	<listitem>
	  <para>Miscellaneous information.</para>
	</listitem>

	<listitem>
	  <para>System maintenance and operation commands.</para>
	</listitem>

	<listitem>
	  <para>Kernel developers.</para>
	</listitem>
      </orderedlist>

      <para>In some cases, the same topic may appear in more than one
	section of the online manual.  For example, there is a
	<command>chmod</command> user command and a
	<function>chmod()</function> system call.  In this case, you can
	tell the man command which one you want by specifying the
	section:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>This will display the manual page for the user command
        <command>chmod</command>. References to a particular section of
	the online manual are traditionally placed in parenthesis in
	written documentation, so &man.chmod.1; refers to the
	<command>chmod</command> user command and &man.chmod.2; refers to
	the system call.</para>

      <para>This is fine if you know the name of the command and simply
	wish to know how to use it, but what if you cannot recall the
	command name?  You can use man to search for keywords in the
	command descriptions by using the <option>-k</option>
	switch:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>With this command you will be presented with a list of
        commands that have the keyword <quote>mail</quote> in their
	descriptions.  This is actually functionally equivalent to using
	the apropos command.</para>

      <para>So, you are looking at all those fancy commands in
	<filename>/usr/bin</filename> but do not have the faintest idea
	what most of them actually do?  Simply do:</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>or</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>which does the same thing.</para>
    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info Files</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>FreeBSD includes many applications and utilities produced by
	the Free Software Foundation (FSF).  In addition to manual pages,
	these programs come with more extensive hypertext documents called
	<literal>info</literal> files which can be viewed with the
	<command>info</command> command or, if you installed
	<application>emacs</application>, the info mode of
	<application>emacs</application>.</para>

      <para>To use the &man.info.1; command, simply type:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>For a brief introduction, type <literal>h</literal>.  For a
	quick command reference, type <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

