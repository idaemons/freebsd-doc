<!--
     The FreeBSD Documentation Project

     $FreeBSD: doc/en_US.ISO_8859-1/books/developers-handbook/book.sgml,v 1.4 2000/11/06 10:22:11 murray Exp $
-->

<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V3.1-Based Extension//EN" [
<!ENTITY % bookinfo PUBLIC "-//FreeBSD//ENTITIES DocBook BookInfo Entities//EN">
%bookinfo;
]>

<book>
  <bookinfo>
    <title>FreeBSD Developers' Handbook</title>
    
    <authorgroup>
      <author>
	<surname>The FreeBSD Documentation Project</surname>
        <affiliation>
          <address>
            <email>doc@FreeBSD.org</email>
          </address>
        </affiliation>
      </author>
    </authorgroup>
    
    <pubdate>August 2000</pubdate>
    
    <copyright>
      <year>2000</year>
      <holder>The FreeBSD Documentation Project</holder>
    </copyright>

    &bookinfo.legalnotice;
    
    <abstract>
      <para>Welcome to the Developers' Handbook.</para>
    </abstract>
  </bookinfo>
  
  <part id="introduction">
    <title>Introduction</title>

    <chapter id="developmentplatform">
      <title>Developing on FreeBSD</title>

      <para>This will need to discuss FreeBSD as a development
        platform, the vision of BSD, architectural overview, layout of
        /usr/src, history, etc.</para>

      <para>Thank you for considering FreeBSD as your development
        platform!  We hope it will not let you down.</para>
    </chapter>

    <chapter id="bsdvision">
      <title>The BSD Vision</title>

      <para></para>
    </chapter>

    <chapter id="archoverview">
      <title>Architectural Overview</title>

      <para></para>
    </chapter>

    <chapter id="sourcelayout">
      <title>The Layout of /usr/src</title>

      <para>The complete source code to FreeBSD is available from our
      public CVS repository.  The source code is normally installed in
      <filename class=directory>/usr/src</filename> which contains the
      following subdirectories.</para>

      <para>
      <informaltable frame="none">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Directory</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  
	  <tbody>
	    <row>
	    <entry><filename class=directory>bin/</filename></entry>
            <entry>Source for files in
            <filename>/bin</filename></entry>
	    </row>
	    
	    <row>
	    <entry><filename class=directory>contrib/</filename></entry>
	    <entry>Source for files from contribued software.</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>crypto/</filename></entry>
	    <entry>DES source</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>etc/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/etc</filename></entry>
	    </row>

	    <row>
	    <entry><filename class=directory>games/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/usr/games</filename></entry>
	    </row>

	    <row>
	    <entry><filename class=directory>gnu/</filename></entry>
	    <entry>Utilities covered by the GNU Public License</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>include/</filename></entry>
            <entry>Source for files in <filename
            class=directory>/usr/include</filename></entry>
	    </row>

	    <row>
	    <entry><filename
 class=directory>kerberosIV/</filename></entry>
            <entry>Source for Kerbereros version IV</entry>
	    </row>

	    <row>
	    <entry><filename
 class=directory>kerberos5/</filename></entry>
            <entry>Source for Kerbereros version 5</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>lib/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/usr/lib</filename></entry>
	    </row>
	    
	    <row>
	    <entry><filename class=directory>libexec/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/usr/libexec</filename></entry>
	    </row>
	    
	    <row>
	    <entry><filename
 class=directory>release/</filename></entry>
            <entry>Files required to produce a FreeBSD release</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>sbin/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/sbin</filename></entry>
	    </row>

	    <row>
	    <entry><filename class=directory>secure/</filename></entry>
	    <entry>FreeSec sources</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>share/</filename></entry>
	    <entry>Source for files in <filename
	    class=directory>/sbin</filename></entry>
	    </row>

	    <row>
	    <entry><filename class=directory>sys/</filename></entry>
	    <entry>Kernel source files</entry>
	    </row>

	    <row>
	    <entry><filename class=directory>tools/</filename></entry>
	    <entry>Tools used for maintenance and testing of
	    FreeBSD</entry>
	    </row>

	    <row>
	    <entry><filename
 class=directory>usr.bin/</filename></entry>
            <entry>Source for files in <filename
 class=directory>/usr/bin</filename></entry>
            </row>

	    <row>
	    <entry><filename
 class=directory>usr.sbin/</filename></entry>
            <entry>Source for files in <filename
 class=directory>/usr/sbin</filename></entry>
            </row>
          </tbody>
	</tgroup>
      </informaltable>

      </para>

    </chapter>
  </part>

  <part id="Basics">
    <title>Basics</title>

    <chapter id="compilation">
      <title>Compilation</title>

      <para>This will include things like: compilation, makefiles, .mk
        files, basic debugging, linking, secure programming
        guidelines, style(9), CVS, diff, patch, etc.</para>

      <para></para>
    </chapter>

    <chapter id="secure-programming">
      <title>Secure Programming</title>

      <para>This chapter was written by Murray Stokely.</para>

      <sect1><title>Synopsis</title>
 
      <para>This chapter describes some of the security issues that
      have plagued Unix programmers for decades and some of the new
      tools available to help programmers avoid writing exploitable
      code.</para>
      </sect1>

      <sect1 id="secure-philosophy"><title>Secure Design
      Methodology</title>

      <para>Writing secure applications takes a very scrutinous and
      pessimistic outlook on life.  Applications should be run with
      the principle of <quote>least privilege</quote> so that no
      process is ever running than more with the bare minimum access
      that it needs to accomplish its function.  Previously tested
      code should be reused whenever possible to avoid common
      mistakes that others may have already fixed.</para>

      <para>One of the pitfalls of the Unix environment is how easy it
      is to make assumptions about the sanity of the environment.
      Applications should never trust user input (in all its forms),
      system resources, inter-process communication, or the timing of
      events.  Unix processes do not execute synchronously so logical
      operations are rarely atomic.</para>
      </sect1>

      <sect1><title>Buffer Overflows</title> 

      <para>Buffer Overflows have been around since the very
      beginnings of the Von-Neuman <xref linkend="COD"> architecture.
      They first gained widespread notoriety in 1988 with the Moorse
      Internet worm.  Unfortunately, the same basic attack remains
      effective today.  Of the 17 CERT security advisories of 1999, 10
      of them were directly caused by buffer-overflow software bugs.
      By far the most common type of buffer overflow attack is based
      on corrupting the stack.</para>

      <para>Most modern computer systems use a stack to pass arguments
      to procedures and to store local variables.  A stack is a last
      in first out (LIFO) buffer in the high memory area of a process
      image.  When a program invokes a function a new "stack frame" is
      created.  This stack frame consists of the arguments passed to
      the function as well as a dynamic amount of local variable
      space.  The "stack pointer" is a register that holds the current
      location of the top of the stack.  Since this value is
      constantly changing as new values are pushed onto the top of the
      stack, many implementations also provide a "frame pointer" that
      is located near the beginning of a stack frame so that local
      variables can more easily be addressed relative to this
      value. <xref linkend="COD"> The return address for function
      calls is also stored on the stack, and this is the cause of
      stack-overflow exploits since overflowing a local variable in a
      function can overwrite the return address of that function,
      potentially allowing a malicious user to execute any code he or
      she wants.</para>

      <para>Although stack-based attacks are by far the most common,
      it would also be possible to overrun the stack with a heap-based
      (malloc/free) attack.</para>

      <para>The C programming language does not perform automatic
      bounds checking on arrays or pointers as many other languages
      do.  In addition, the standard C library is filled with a
      handful of very dangerous functions.</para>

      <informaltable>
        <tgroup cols=2>
          <tbody>
          <row><entry><function>strcpy</function>(char *dest, const char
          *src)</entry>
          <entry><simpara>May overflow the dest buffer</simpara></entry>
          </row>

          <row><entry><function>strcat</function>(char *dest, const char
          *src)</entry>
          <entry><simpara>May overflow the dest buffer</simpara></entry>
          </row>

          <row><entry><function>getwd</function>(char *buf)</entry>
          <entry><simpara>May overflow the buf buffer</simpara></entry>
          </row>

          <row><entry><function>gets</function>(char *s)</entry>
          <entry><simpara>May overflow the s buffer</simpara></entry>
          </row>

          <row><entry><function>[vf]scanf</function>(const char *format,
          ...)</entry>
          <entry><simpara>May overflow its arguments.</simpara></entry>
          </row>

          <row><entry><function>realpath</function>(char *path, char
          resolved_path[])</entry>
          <entry><simpara>May overflow the path buffer</simpara></entry>
          </row>

          <row><entry><function>[v]sprintf</function>(char *str, const char
          *format, ...)</entry>
          <entry><simpara>May overflow the str buffer.</simpara></entry>
          </row>
          </tbody>
        </tgroup>
      </informaltable>

      <sect2><title>Example Buffer Overflow</title>

      <para>The following example code contains a buffer overflow
      designed to overwrite the return address and skip the
      instruction immediately following the function call.  (Inspired
      by <xref linkend="Phrack">)</para>

<programlisting>
#include <sgmltag>stdio.h</sgmltag>

void manipulate(char *buffer) {
  char newbuffer[80];
  strcpy(newbuffer,buffer);
}

int main() {
  char ch,buffer[4096];
  int i=0;

  while ((buffer[i++] = getchar()) != '\n') {};
  
  i=1;
  manipulate(buffer);
  i=2;
  printf("The value of i is : %d\n",i);
  return 0;
}
</programlisting>

      <para>Let us examine what the memory image of this process would
      look like if we were to input 160 spaces into our little program
      before hitting return.</para> 

      <para>[XXX figure here!]</para>

      <para>Obviously more malicious input can be devised to execute
      actual compiled instructions (such as exec(/bin/sh)).</para>
      </sect2>

      <sect2><title>Avoiding Buffer Overflows</title>

      <para>The most straightforward solution to the problem of
      stack-overflows is to always use length restricted memory and
      string copy functions.  <function>strncpy</function> and
      <function>strncat</function> are part of the standard C library.
      These functions accept a length value as a parameter which
      should be no larger than the size of the destination buffer.
      These functions will then copy up to `length' bytes from the
      source to the destination.  However there are a number of
      problems with these functions.  Neither function guarantees NUL
      termination if the size of the input buffer is as large as the
      destination.  The length parameter is also used inconsistently
      between strncpy and strncat so it is easy for programmers to get
      confused as to their proper usage.  There is also a significant
      performance loss compared to <function>strcpy</function> when
      copying a short string into a large buffer since
      <function>strncpy</function> NUL fills up the the size
      specified.</para>

      <para>In OpenBSD, another memory copy implementation has been
      created to get around these problem.  The
      <function>strlcpy</function> and <function>strlcat</function>
      functions guarantee that they will always null terminate the
      destination string when given a non-zero length argument.  For
      more information about these functions see <xref
      linkend="OpenBSD">.  The OpenBSD <function>strlcpy</function> and
      <function>strlcat</function> instructions have been in FreeBSD
      since 3.5.</para>

        <sect3><title>Compiler based run-time bounds checking</title>

        <para>Unfortunately there is still a very large assortment of
        code in public use which blindly copies memory around without
        using any of the bounded copy routines we just discussed.
        Fortunately, there is another solution.  Several compiler
        add-ons and libraries exist to do Run-time bounds checking in
        C/C++.</para> 

        <para>StackGuard is one such add-on that is implemented as a
        small patch to the gcc code generator.  From the StackGuard
        website, http://immunix.org/stackguard.html :
        <blockquote><para>"StackGuard detects and defeats stack
        smashing attacks by protecting the return address on the stack
        from being altered.  StackGuard places a "canary" word next to
        the return address when a function is called.  If the canary
        word has been altered when the function returns, then a stack
        smashing attack has been attempted, and the program responds
        by emitting an intruder alert into syslog, and then
        halts."</para></blockquote> 

        <blockquote><para>"StackGuard is implemented as a small patch
        to the gcc code generator, specifically the function_prolog()
        and function_epilog() routines.  function_prolog() has been
        enhanced to lay down canaries on the stack when functions
        start, and function_epilog() checks canary integrity when the
        function exits.  Any attempt at corrupting the return address
        is thus detected before the function
        returns."</para></blockquote>
        </para>

        <para>Recompiling your application with StackGuard is an
        effective means of stopping most buffer-overflow attacks, but
        it can still be compromised.</para>

        </sect3>

        <sect3><title>Library based run-time bounds checking</title>

        <para>Compiler-based mechanisms are completely useless for
        binary-only software for which you cannot recompile.  For
        these situations there are a number of libraries which
        re-implement the unsafe functions of the C-library
        (<function>strcpy</function>, <function>fscanf</function>,
        <function>getwd</function>, etc..) and ensure that these
        functions can never write past the stack pointer.</para>

        <itemizedlist>
        <listitem><simpara>libsafe</simpara></listitem>
        <listitem><simpara>libverify</simpara></listitem>
        <listitem><simpara>libparnoia</simpara></listitem>
        </itemizedlist>

	<para>Unfortunately these library-based defenses have a number
        of shortcomings.  These libraries only protect against a very
        small set of security related issues and they neglect to fix
        the actual problem.  These defenses may fail if the
        application was compiled with -fomit-frame-pointer.  Also, the
        LD_PRELOAD and LD_LIBRARY_PATH environment variables can be
        overwritten/unset by the user.</para>
        </sect3>

        </sect2>
      </sect1>

      <sect1><title>SetUID issues</title>

      <para>There are at least 6 different IDs associated with any
      given process.  Because of this you have to be very careful with
      the access that your process has at any given time.  In
      particular, all seteuid applications should give up their
      privileges as soon as it is no longer required.</para>

      <para>The real user ID can only be changed by a superuser
      process.  The <application>login</application> program sets this
      when a user initially logs in and it is seldom changed.</para>

      <para>The effective user ID is set by the
      <function>exec()</function> functions if a program has its
      seteuid bit set.  An application can call
      <function>seteuid()</function> at any time to set the effective
      user ID to either the real user ID or the saved set-user-ID.
      When the effective user ID is set by <function>exec()</function>
      functions, the previous value is saved in the saved set-user-ID.</para>

      </sect1>

      <sect1 id="chroot"><title>Limiting your program's environment</title>

      <para>The traditional method of restricting access to a process
      is with the <function>chroot()</function> system call.  This
      system call changes the root directory from which all other
      paths are referenced for a process and any child processes.  For
      this call to succeed the process must have execute (search)
      permission on the directory being referenced.  The new
      environment does not actually take affect until you
      <function>chdir()</function> into your new environment.  It
      should also be noted that a process can easily break out of a
      chroot environment if it has root privilege.  This could be
      accomplished by creating device nodes to read kernel memory,
      attaching a debugger to a process outside of the jail, or in
      many other creative ways.</para>
      
      <para>The behavior of the <function>chroot()</function> system
      call can be controlled somewhat with the
      kern.chroot_allow_open_directories <command>sysctl</command>
      variable.  When this value is set to 0,
      <function>chroot()</function> will fail with EPERM if there are
      any directories open.  If set to the default value of 1, then
      <function>chroot()</function> will fail with EPERM if there are
      any directories open and the process is already subject to a
      <function>chroot()</function> call.  For any other value, the
      check for open directories will be bypassed completely.</para>

      <sect2><title>FreeBSD's jail functionality</title>

      <para>The concept of a Jail extends upon the
      <function>chroot()</function> by limiting the powers of the
      superuser to create a true `virtual server'.  Once a prison is
      setup all network communication must take place through the
      specified IP address, and the power of "root privilege" in this
      jail is severely constrained.</para>

      <para>While in a prison, any tests of superuser power within the
      kernel using the <function>suser()</function> call will fail.
      However, some calls to <function>suser()</function> have been
      changed to a new interface <function>suser_xxx()</function>.
      This function is responsible for recognizing or denying access
      to superuser power for imprisoned processes.</para>

      <para>A superuser process within a jailed environment has the
      power to : </para>
      <itemizedlist>
      <listitem><simpara>Manipulate credential with
        <function>setuid</function>, <function>seteuid</function>,
        <function>setgid</function>, <function>setegid</function>,
        <function>setgroups</function>, <function>setreuid</function>,
        <function>setregid</function>, <function>setlogin</function></simpara></listitem>
      <listitem><simpara>Set resource limits with <function>setrlimit</function></simpara></listitem>
      <listitem><simpara>Modify some sysctl nodes
        (kern.hostname)</simpara></listitem>
      <listitem><simpara><function>chroot()</function></simpara></listitem>
      <listitem><simpara>Set flags on a vnode:
        <function>chflags</function>,
        <function>fchflags</function></simpara></listitem>
      <listitem><simpara>Set attributes of a vnode such as file
        permission, owner, group, size, access time, and modification
        time.</simpara></listitem>
      <listitem><simpara>Bind to privileged ports in the Internet
        domain (ports < 1024)</simpara></listitem>
      </itemizedlist>

      <para><function>Jail</function> is a very useful tool for
      running applications in a secure environment but it does have
      some shortcomings.  Currently, the IPC mechanisms have not been
      converted to the <function>suser_xxx</function> so applications
      such as MySQL can not be run within a jail.  Superuser access
      may have a very limited meaning within a jail, but there is
      no way to specify exactly what "very limited" means.</para>
      </sect2>

      <sect2><title>POSIX.1e Process Capabilities</title>

      <para>Posix has released a working draft that adds event
      auditing, access control lists, fine grained privileges,
      information labeling, and mandatory access control.</para>
      <para>This is a work in progress and is the focus of the <ulink
      url="http://www.trustedbsd.org">TrustedBSD</ulink> project.  Some
      of the initial work has been committed to FreeBSD-current
      (cap_set_proc(3)).</para>

      </sect2>

      </sect1>

      <sect1><title>Trust</title>

      <para>An application should never assume that anything about the
      users environment is sane.  This includes (but is certainly not
      limited to) : user input, signals, environment variables,
      resources, IPC, mmaps, the file system working directory, file
      descriptors, the # of open files, etc.</para>

      <para>You should never assume that you can catch all forms of
      invalid input that a user might supply.  Instead, your
      application should use positive filtering to only allow a
      specific subset of inputs that you deem safe.  Improper data
      validation has been the cause of many exploits, especially with
      CGI scripts on the world wide web.  For filenames you need to be
      extra careful about paths ("../", "/"), symbolic links, and
      shell escape characters.</para>

      <para>Perl has a really cool feature called "Taint" mode which
      can be used to prevent scripts for using data derived outside
      the program in an unsafe way.  This mode will check command line
      arguments, environment variables, locale information, the
      results of certain syscalls (<function>readdir()</function>,
      <function>readlink()</function>,
      <function>getpwxxx()</function>, and all file input.</para>

      </sect1>

      <sect1><title>Race Conditions</title>

      <para>A race condition is anomalous behavior caused by the
      unexpected dependence on the relative timing of events.  In
      other words, a programmer incorrectly assumed that a particular
      event would always happen before another.</para>

      <para>Some of the common causes of race conditions are signals,
      access checks, and file opens.  Signals are asynchronous events
      by nature so special care must be taken in dealing with them.
      Checking access with <function>access(2)</function> then
      <function>open(2)</function> is clearly non-atomic.  Users can
      move files in between the two calls.  Instead, privileged
      applications should <function>seteuid()</function> and then call
      <function>open()</function> directly.  Along the same lines, an
      application should always set a proper umask before
      <function>open()</function> to obviate the need for spurious
      <function>chmod()</function> calls.</para>

      </sect1>

     </chapter>
  </part>

  <part id="kernel">
    <title>Kernel</title>

    <chapter id="kernelhistory">
      <title>History of the Unix Kernel</title>

      <para>Some history of the Unix/BSD kernel, system calls, how do
        processes work, blocking, scheduling, threads (kernel),
        context switching, signals, interrupts, modules, etc.</para>

      <para></para>
    </chapter>
  </part>

  <part id="memory">
    <title>Memory and Virtual Memory</title>

    <chapter id="virtualmemory">
      <title>Virtual Memory</title>

      <para>VM, paging, swapping, allocating memory, testing for
        memory leaks, mmap, vnodes, etc.</para>

      <para></para>
    </chapter>
  </part>

  <part id="iosystem">
    <title>I/O System</title>

    <chapter id="ufs">
      <title>UFS</title>

      <para>UFS, FFS, Ext2FS, JFS, inodes, buffer cache, labeling,
        locking, metadata, soft-updates, LFS, portalfs, procfs,
        vnodes, memory sharing, memory objects, TLBs, caching</para>

    </chapter>
  </part>

  <part id="ipc">
    <title>Interprocess Communication</title>
    
    <chapter id="signals">
      <title>Signals</title>

      <para>Signals, pipes, semaphores, message queues, shared memory,
        ports, sockets, doors</para>

    </chapter>
  </part>

  <part id="networking">
    <title>Networking</title>
    
    <chapter id="sockets">
      <title>Sockets</title>

      <para>Sockets, bpf, IP, TCP, UDP, ICMP, OSI, bridging,
        firewalling, NAT, switching, etc</para>

    </chapter>
  </part>
  
  <part id="networkfs">
    <title>Network Filesystems</title>

    <chapter id="afs">
      <title>AFS</title>

      <para>AFS, NFS, SANs etc]</para>

    </chapter>
  </part>
  
  <part id="terminal">
    <title>Terminal Handling</title>

    <chapter id="syscons">
      <title>Syscons</title>

      <para>Syscons, tty, PCVT, serial console, screen savers,
        etc</para>

    </chapter>
  </part>
  
  <part id="sound">
    <title>Sound</title>

    <chapter id="oss">
      <title>OSS</title>

      <para>OSS, waveforms, etc</para>

    </chapter>
  </part>
  
  <part id="devicedrivers">
    <title>Device Drivers</title>

    <chapter id="driverbasics">
      <title>Writing FreeBSD Device Drivers</title>

      <para>This chapter was written by Murray Stokely with selections from
      a variety of sources including the intro(4) man page by Joerg
      Wunsch.</para>

      <sect1>
        <title>Introduction</title>
	<para>
	This chapter provides a brief introduction to writing device
	drivers for FreeBSD.  A device in this context is a term used
	mostly for hardware-related stuff that belongs to the system,
	like disks, printers, or a graphics display with its keyboard.
	A device driver is the software component of the operating
	system that controls a specific device.  There are also
	so-called pseudo-devices where a device driver emulates the
	behaviour of a device in software without any particular
	underlying hardware.  Device drivers can be compiled into the
	system statically or loaded on demand through the dynamic
	kernel linker facility `kld'.</para>

	<para>Most devices in a Unix-like operating system are
	accessed through device-nodes, sometimes also called special
	files.  These files are usually located under the directory
	<filename>/dev</filename> in the file system hierarchy.  Until
	devfs is fully integrated into FreeBSD, each device node must
	be created statically and independent of the existence of the
	associated device driver.  Most device nodes on the system are
	created by running <command>MAKEDEV</command>.</para>

	<para>Device drivers can roughly be broken down into three
	categories; character (unbuffered), block (buffered), and
	network drivers.</para>
      </sect1>

      <sect1>
        <title>Dynamic Kernel Linker Facility - KLD</title>
	<para>The kld interface allows system administrators to
	dynamically add and remove functionality from a running
	system.  This allows device driver writers to load their new
	changes into a running kernel without constantly rebooting to
	test changes.</para>

	<para>The kld interface is used through the following
	administrator commands : 
	<itemizedlist>
	<listitem><simpara><command>kldload</command> - loads a new kernel
	module</simpara></listitem>
	<listitem><simpara><command>kldunload</command> - unloads a kernel
	module</simpara></listitem>
	<listitem><simpara><command>kldstat</command> - lists the currently loadded
	modules</simpara></listitem>
	</itemizedlist>
	</para>

	<para>Skeleton Layout of a kernel module</para>
<programlisting>
/*
 * KLD Skeleton
 * Inspired by Andrew Reiter's Daemonnews article
 */

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt;  /* uprintf */ 
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/kernel.h&gt; /* types used in module initialization */

/* 
 * Load handler that deals with the loading and unloading of a KLD.
 */

static int
skel_loader(struct module *m, int what, void *arg)
{
  int err = 0;
  
  switch (what) {
  case MOD_LOAD:                /* kldload */
    uprintf("Skeleton KLD loaded.\n");
    break;
  case MOD_UNLOAD:
    uprintf("Skeleton KLD unloaded.\n");
    break;
  default:
    err = EINVAL;
    break;
  }
  return(err);
}

/* Declare this module to the rest of the kernel */

DECLARE_MODULE(skeleton, skel_loader, SI_SUB_KLD, SI_ORDER_ANY);
</programlisting>


	<sect2>
	  <title>Makefile</title>
	  <para>FreeBSD provides a makefile include that you can use
	  to quickly compile your kernel addition.</para>
	  <programlisting>
SRCS=skeleton.c
KMOD=skeleton

.include &lt;bsd.kmod.mk&gt;
</programlisting>


	  <para>Simply running <command>make</command> with
	  this makefile will create a file
	  <filename>skeleton.ko</filename> that can be loaded into
	  your system by typing : 
<screen>  
&prompt.root kldload -v ./skeleton.ko
</screen>
          </para>
         </sect2>
      </sect1>

      <sect1>
        <title>Accessing a device driver</title>
	<para>Unix provides a common set of system calls for user
	applications to use.  The upper layers of the kernel dispatch
	these calls to the corresponding device driver when a user
	accesses a device node.  The <command>/dev/MAKEDEV</command>
	script makes most of the device nodes for your system but if
	you are doing your own driver development it may be necessary
	to create your own device nodes with <command>mknod</command>
	</para>

	<sect2>
	<title>Creating static device nodes</title>
	<para>The <command>mknod</command> command requires four
	arguments to create a device node.  You must specify the
	name of this device node, the type of device, the major number
	of the device, and the minor number of the device.</para>
	</sect2>

	<sect2>
	<title>Dynamic device nodes</title>
	<para>The device filesystem, or devfs, provides access to the
	kernel's device namespace in the global filesystem namespace.
	This eliminates the problems of potentially having a device
	driver without a static device node, or a device node without
	an installed device driver.  Unfortunately, devfs is still a
	work in progress.</para>
	</sect2>

      </sect1>

      <sect1>
        <title>Character Devices</title>
	<para>A character device driver is one that transfers data
	directly to and from a user process.  This is the most common
	type of device driver and there are plenty of simple examples
	in the source tree.</para>
	<para>This simple example pseudo-device remembers whatever values you write
	to it and can then supply them back to you when you read from
	it.</para>
<programlisting>
/*
 * Simple `echo' pseudo-device KLD
 *
 * Murray Stokely
 */

#define MIN(a,b) (((a) < (b)) ? (a) : (b))

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt; /* uprintf */ 
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/kernel.h&gt; /* types used in module initialization */
#include &lt;sys/conf.h&gt;   /* cdevsw struct */
#include &lt;sys/uio.h&gt;    /* uio struct */
#include &lt;sys/malloc.h&gt;

#define BUFFERSIZE 256

/* Function prototypes */
d_open_t      echo_open;
d_close_t     echo_close;
d_read_t      echo_read;
d_write_t     echo_write;

/* Character device entry points */
static struct cdevsw echo_cdevsw = {
  echo_open,
  echo_close,
  echo_read,
  echo_write,
  noioctl,
  nopoll,
  nommap,
  nostrategy,
  "echo",
  33,                   /* reserved for lkms - /usr/src/sys/conf/majors */
  nodump,
  nopsize,
  D_TTY,
  -1
};

typedef struct s_echo {
  char msg[BUFFERSIZE];
  int len;
} t_echo;

/* vars */
static dev_t sdev;
static int len;
static int count;
static t_echo *echomsg;

MALLOC_DECLARE(M_ECHOBUF);
MALLOC_DEFINE(M_ECHOBUF, "echobuffer", "buffer for echo module");

/*
 * This function acts is called by the kld[un]load(2) system calls to
 * determine what actions to take when a module is loaded or unloaded.
 */
      
static int
echo_loader(struct module *m, int what, void *arg)
{
  int err = 0;
  
  switch (what) {
  case MOD_LOAD:                /* kldload */
    sdev = make_dev(<literal>&</literal>echo_cdevsw,
		    0,
		    UID_ROOT,
		    GID_WHEEL,
		    0600,
		    "echo");
    /* kmalloc memory for use by this driver */
    /*    malloc(256,M_ECHOBUF,M_WAITOK); */
    MALLOC(echomsg, t_echo *, sizeof(t_echo), M_ECHOBUF, M_WAITOK);
    printf("Echo device loaded.\n");
    break;
  case MOD_UNLOAD:
    destroy_dev(sdev);
    FREE(echomsg,M_ECHOBUF);
    printf("Echo device unloaded.\n");
    break;
  default:
    err = EINVAL;
    break;
  }
  return(err);
}

int 
echo_open(dev_t dev, int oflags, int devtype, struct proc *p)
{
  int err = 0;
  
  uprintf("Opened device \"echo\" successfully.\n");
  return(err);
}

int 
echo_close(dev_t dev, int fflag, int devtype, struct proc *p)
{
  uprintf("Closing device \"echo.\"\n"); 
  return(0);
} 

/* 
 * The read function just takes the buf that was saved via
 * echo_write() and returns it to userland for accessing.
 * uio(9) 
 */

int
echo_read(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;
  int amt;

  /* How big is this read operation?  Either as big as the user wants,
     or as big as the remaining data */
  amt = MIN(uio->uio_resid, (echomsg->len - uio->uio_offset > 0) ? echomsg->len - uio->uio_offset : 0);
  if ((err = uiomove(echomsg->msg + uio->uio_offset,amt,uio)) != 0) {
    uprintf("uiomove failed!\n");
  }

  return err;
}

/*
 * echo_write takes in a character string and saves it
 * to buf for later accessing.
 */

int
echo_write(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;

  /* Copy the string in from user memory to kernel memory */
  err = copyin(uio->uio_iov->iov_base, echomsg->msg, MIN(uio->uio_iov->iov_len,BUFFERSIZE));

  /* Now we need to null terminate */
  *(echomsg->msg + MIN(uio->uio_iov->iov_len,BUFFERSIZE)) = 0;
  /* Record the length */
  echomsg->len = MIN(uio->uio_iov->iov_len,BUFFERSIZE);

  if (err != 0) {
    uprintf("Write failed: bad address!\n");
  }

  count++;
  return(err);
}

DEV_MODULE(echo,echo_loader,NULL);
</programlisting>

<para>To install this driver you will first need to make a node on
	your filesystem with a command such as : </para> 
<screen>
	&prompt.root mknod /dev/echo c 33 0
</screen>
<para>With this driver loaded you should now be able to type something
	like :</para>
<screen>
        &prompt.root echo -n "Test Data" > /dev/echo
        &prompt.root cat /dev/echo
	Test Data
</screen>
	<para>Real hardware devices in the next chapter..</para>

	<para>Additional Resources
	<itemizedlist>
	<listitem><simpara><ulink
	url="http://www.daemonnews.org/200010/blueprints.html">Dynamic
	Kernel Linker (KLD) Facility Programming Tutorial</ulink> -
	<ulink url="http://www.daemonnews.org">Daemonnews</ulink> October 2000</simpara></listitem>
	<listitem><simpara><ulink
	url="http://www.daemonnews.org/200007/newbus-intro.html">How
	to Write Kernel Drivers with NEWBUS</ulink> - <ulink
	url="http://www.daemonnews.org">Daemonnews</ulink> July
	2000</simpara></listitem>
	</itemizedlist>
	</para>
      </sect1>

      <sect1>
        <title>Block Devices</title>
	<para>A block device driver transfers data to and from the
	operating system's buffer cache.  They are solely intended to
	layer a file system on top of them.  For this reason they are
	normally implemented for disks and disk-like devices only.</para>

	<para>Example test data generator ... </para>

	<para>Example ramdisk device ... </para>

	<para>Real hardware devices in the next chapter..</para>
      </sect1>

      <sect1>
        <title>Network Drivers</title>
	<para>Drivers for network devices do not use device nodes in
	ord to be accessed.  Their selection is based on other
	decisions made inside the kernel and instead of calling
	open(), use of a network device is generally introduced by
	using the system call socket(2).</para>
	<para>man ifnet(), loopback device, Bill Pauls drivers, etc..</para>
      </sect1>

    </chapter>

    <chapter id="pci">
      <title>PCI Devices</title>

      <para>This chapter will talk about the FreeBSD mechanisms for
      writing a device driver for a device on a PCI bus.</para>

      <sect1><title>Probe and Attach</title>

      <para>Information here about how the PCI bus code iterates
      through the unattached devices and see if a newly loaded kld
      will attach to any of them.</para>
<programlisting>
/*
 * Simple KLD to play with the PCI functions.
 *
 * Murray Stokely
 */

#define MIN(a,b) (((a) < (b)) ? (a) : (b))

#include &lt;sys/types.h&gt;
#include &lt;sys/module.h&gt;
#include &lt;sys/systm.h&gt;  /* uprintf */ 
#include &lt;sys/errno.h&gt;
#include &lt;sys/param.h&gt;  /* defines used in kernel.h */
#include &lt;sys/kernel.h&gt; /* types used in module initialization */
#include &lt;sys/conf.h&gt;   /* cdevsw struct */
#include &lt;sys/uio.h&gt;    /* uio struct */
#include &lt;sys/malloc.h&gt;
#include &lt;sys/bus.h&gt;	/* structs, prototypes for pci bus stuff */

#include &lt;pci/pcivar.h&gt; /* For get_pci macros! */

/* Function prototypes */
d_open_t      mypci_open;
d_close_t     mypci_close;
d_read_t      mypci_read;
d_write_t     mypci_write;

/* Character device entry points */

static struct cdevsw mypci_cdevsw = {
  mypci_open,
  mypci_close,
  mypci_read,
  mypci_write,
  noioctl,
  nopoll,
  nommap,
  nostrategy,
  "mypci",
  36,                   /* reserved for lkms - /usr/src/sys/conf/majors */
  nodump,
  nopsize,
  D_TTY,
  -1
};

/* vars */
static dev_t sdev;

/* We're more interested in probe/attach than with
   open/close/read/write at this point */

int 
mypci_open(dev_t dev, int oflags, int devtype, struct proc *p)
{
  int err = 0;

  uprintf("Opened device \"mypci\" successfully.\n");
  return(err);
}

int 
mypci_close(dev_t dev, int fflag, int devtype, struct proc *p)
{
  int err=0;

  uprintf("Closing device \"mypci.\"\n"); 
  return(err);
} 

int
mypci_read(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;

  uprintf("mypci read!\n");
  return err;
}

int
mypci_write(dev_t dev, struct uio *uio, int ioflag)
{
  int err = 0;

  uprintf("mypci write!\n");
  return(err);
}

/* PCI Support Functions */

/*
 * Return identification string if this is device is ours.
 */
static int
mypci_probe(device_t dev)
{
  uprintf("MyPCI Probe\n"
	  "Vendor ID : 0x%x\n"
	  "Device ID : 0x%x\n",pci_get_vendor(dev),pci_get_device(dev));

  if (pci_get_vendor(dev) == 0x11c1) {
    uprintf("We've got the Winmodem, probe successful!\n");
    return 0;
  }

  return ENXIO;
}

/* Attach function is only called if the probe is successful */

static int
mypci_attach(device_t dev)
{
  uprintf("MyPCI Attach for : deviceID : 0x%x\n",pci_get_vendor(dev));
  sdev = make_dev(<literal>&</literal>mypci_cdevsw,
		  0,
		  UID_ROOT,
		  GID_WHEEL,
		  0600,
		  "mypci");
  uprintf("Mypci device loaded.\n");
  return ENXIO;
}

/* Detach device. */

static int
mypci_detach(device_t dev)
{
  uprintf("Mypci detach!\n");
  return 0;
}

/* Called during system shutdown after sync. */

static int
mypci_shutdown(device_t dev)
{
  uprintf("Mypci shutdown!\n");
  return 0;
}

/*
 * Device suspend routine.  
 */
static int
mypci_suspend(device_t dev)
{
  uprintf("Mypci suspend!\n");
  return 0;
}

/*
 * Device resume routine.
 */

static int
mypci_resume(device_t dev)
{
  uprintf("Mypci resume!\n");
  return 0;
}

static device_method_t mypci_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		mypci_probe),
	DEVMETHOD(device_attach,	mypci_attach),
	DEVMETHOD(device_detach,	mypci_detach),
	DEVMETHOD(device_shutdown,	mypci_shutdown),
	DEVMETHOD(device_suspend,	mypci_suspend),
	DEVMETHOD(device_resume,	mypci_resume),

	{ 0, 0 }
};

static driver_t mypci_driver = {
	"mypci",
	mypci_methods,
	0,
	/*	sizeof(struct mypci_softc), */
};

static devclass_t mypci_devclass;

DRIVER_MODULE(mypci, pci, mypci_driver, mypci_devclass, 0, 0);
</programlisting>
      
        <para>Additional Resources
	<itemizedlist>
	<listitem><simpara><ulink
	url="http://www.pcisig.org">PCI Special Interest
	Group</ulink></simpara></listitem>
	<listitem><simpara>PCI System Architecture, Fourth Edition by
	Tom Shanley, et al.</simpara></listitem>
	</itemizedlist>
	</para>
      </sect1>
    </chapter>

    <chapter id="usb">
      <title>USB Devices</title>

      <para>This chapter will talk about the FreeBSD mechanisms for
      writing a device driver for a device on a USB bus.</para>
    </chapter>

    <chapter id="newbus">
      <title>NewBus</title>

      <para>This chapter will talk about the FreeBSD NewBus
      architecture.</para>
    </chapter>

  </part>
  
  <part id="architectures">
    <title>Architectures</title>

    <chapter id="ia32">
      <title>IA-32</title>

      <para>Talk about the architectural specifics of FreeBSD/x86.</para>

    </chapter>

    <chapter id="alpha">
      <title>Alpha</title>

      <para>Talk about the architectural specifics of
      FreeBSD/alpha.</para>

      <para>Explanation of allignment errors, how to fix, how to
      ignore.</para>

      <para>Example assembly language code for FreeBSD/alpha.</para>
    </chapter>

    <chapter id="ia64">
      <title>IA-64</title>

      <para>Talk about the architectural specifics of
      FreeBSD/ia64.</para>

    </chapter>
  </part>
  
  <part id="debugging">
    <title>Debugging</title>

    <chapter id="truss">
      <title>Truss</title>

      <para>various descriptions on how to debug certain aspects of
        the system using truss, ktrace, gdb, kgdb, etc</para>

    </chapter>
  </part>
  
  <part id="compatibility">
    <title>Compatibility Layers</title>

    <chapter id="linux">
      <title>Linux</title>

      <para>Linux, SVR4, etc</para>

    </chapter>
  </part>
  
  <part id="appendices">
    <title>Appendices</title>

      <bibliography>

      <biblioentry id="COD" xreflabel="1">
        <authorgroup>
          <author>
            <firstname>Dave</firstname>
            <othername role="MI">A</othername>
            <surname>Patterson</surname>
          </author>
          <author>
            <firstname>John</firstname>
            <othername role="MI">L</othername>
            <surname>Hennessy</surname>
          </author>
        </authorgroup>
        <copyright><year>1998</year><holder>Morgan Kaufmann Publishers,
        Inc.</holder></copyright>
        <isbn>1-55860-428-6</isbn>
        <publisher>
          <publishername>Morgan Kaufmann Publishers, Inc.</publishername>
        </publisher>
        <title>Computer Organization and Design</title>
        <subtitle>The Hardware / Software Interface</subtitle>
        <pagenums>1-2</pagenums>
      </biblioentry>

      <biblioentry xreflabel="2">
        <authorgroup>
          <author>
            <firstname>W.</firstname>
            <othername role="Middle">Richard</othername>
            <surname>Stevens</surname>
          </author>
        </authorgroup>
        <copyright><year>1993</year><holder>Addison Wesley Longman,
        Inc.</holder></copyright>
        <isbn>0-201-56317-7</isbn>
        <publisher>
          <publishername>Addison Wesley Longman, Inc.</publishername>
        </publisher>
        <title>Advanced Programming in the Unix Environment</title>
        <pagenums>1-2</pagenums>
      </biblioentry>

      <biblioentry xreflabel="3">
        <authorgroup>
          <author>
            <firstname>Marshall</firstname>
            <othername role="Middle">Kirk</othername>
            <surname>McKusick</surname>
          </author>
          <author>
            <firstname>Keith</firstname>
            <surname>Bostic</surname>
          </author>
          <author>
            <firstname>Michael</firstname>
            <othername role="MI">J</othername>
            <surname>Karels</surname>
          </author>
          <author>
            <firstname>John</firstname>
            <othername role="MI">S</othername>
            <surname>Quarterman</surname>
          </author>
        </authorgroup>
        <copyright><year>1996</year><holder>Addison-Wesley Publishing Company,
        Inc.</holder></copyright>
        <isbn>0-201-54979-4</isbn>
        <publisher>
          <publishername>Addison-Wesley Publishing Company, Inc.</publishername>
        </publisher>
        <title>The Design and Implementation of the 4.4 BSD Operating System</title>
        <pagenums>1-2</pagenums>
      </biblioentry>

      <biblioentry id="Phrack" xreflabel="4">
        <authorgroup>
          <author>
            <firstname>Aleph</firstname>
            <surname>One</surname>
          </author>
        </authorgroup>
        <title>Phrack 49; "Smashing the Stack for Fun and Profit"</title>
      </biblioentry>

      <biblioentry id="StackGuard" xreflabel="5">
        <authorgroup>
          <author>
            <firstname>Chrispin</firstname>
            <surname>Cowan</surname>
          </author>
          <author>
            <firstname>Calton</firstname>
            <surname>Pu</surname>
          </author>
          <author>
            <firstname>Dave</firstname>
            <surname>Maier</surname>
          </author>
        </authorgroup>
        <title>StackGuard; Automatic Adaptive Detection and Prevention of
        Buffer-Overflow Attacks</title>
      </biblioentry>

      <biblioentry id="OpenBSD" xreflabel="6">
        <authorgroup>
	  <author>
	    <firstname>Todd</firstname>
	    <surname>Miller</surname>
	  </author>
	  <author>
	    <firstname>Theo</firstname>
	    <surname>de Raadt</surname>
	  </author>
	</authorgroup>
	<title>strlcpy and strlcat -- consistent, safe string copy and
	concatenation.</title>
      </biblioentry>

      </bibliography>

  </part>

</book>
