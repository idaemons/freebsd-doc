<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
  <head>
    <title>Independent Verification of IPsec Functionality in FreeBSD</title>
  </head>
  
  <body text="#000000" bgcolor="#FFFFFF">
    
    <h1>Independent Verification of IPsec Functionality in FreeBSD</h1>
    
    <p align="center"><i>You installed IPsec and it seems to be working.&nbsp;
	How do you know?  I describe a method for experimentally verifying
	that IPsec is working</i></p>
    
    <h2>The Problem</h2>
    
    <p>First, let's assume you have <a href="#Installing IPsec">installed
	<i>IPsec</i></a>. How do you know its <a href="#Caveat">working</a>?
      Sure, your connection won't work if its misconfigured, and it will work
      when you finally get it right. <i>Netstat</i> will list it. But can you
      independently confirm it?</p>
    
    <h2>The Solution</h2>
    
    <p>First, some crypto-relevent info theory:</p>
    
    <ol>
      <li>
	<p>encrypted data is uniformly distributed, i.e., has maximal entropy
	  per symbol;</p>
      </li>
      
      <li>
	<p>raw, uncompressed data is typically redundant, i.e., has
	  sub-maximal entropy.</p>
      </li>
    </ol>
    
    <p>Suppose you could measure the entropy of the data to- and from- your
      network interface. Then you could see the difference between unencrypted
      data and encrypted data. This would be true even if some of the data
      in "encrypted mode" was not encrypted---as the outermost IP header must
      be, if the packet is to be routable.</p>
    
    <h4><a name="MUST"></a>MUST</h4>
    
    <p>Ueli Maurer's "Universal Statistical Test for Random Bit Generators"
	(<a href="http://www.geocities.com/SiliconValley/Code/4704/universal.pdf">MUST</a>)
	quickly measures the entropy of a sample. It uses a
	compression-like algorithm. <a href="#Maurer's Universal Statistical
	Test">The code is given below</a> for a variant which measures successive
	(~quarter megabyte) chunks of a file.</p>
    
    <h4><a NAME="Tcpdump"></a>Tcpdump</h4>
    
    <p>We also need a way to capture the raw network data. A program called
      "<i>tcpdump</i>" lets you do this, if you have enabled the <i>Berkeley
	Packet Filter</i> interface in your <a
	href="#KERNELNAME">kernel's config file</a>.</p>
    
    <p>The command</p>

    <blockquote><b>tcpdump</b> <b>-c</b> 4000 <b>-s</b> 10000 <b>-w</b>
      <i>dumpfile.bin</i></blockquote>
    
    <p>will capture 4000 raw packets to <i>dumpfile.bin</i>. Up to 10,000
      bytes per packet will be captured in this example.</p>
    
    <h2>The Experiment</h2>
    
    <p>Here's the experiment. Open a window to an IPsec host and another
      window to an insecure host.</p>
    
    <p>Now start <a href="#Tcpdump">capturing packets</a>.</p>
    
    <p>In the "secure" window, run the unix command "yes", which will stream
      the "y" character.  After a while, stop this. Switch to the insecure
      window, and repeat.  After a while, stop.</p>
    
    <p>Now run <a href="#Maurer's Universal Statistical Test">MUST</a> on the
      captured packets. You should see something like the following.
      The important thing to note is that the secure connection has 93% (6.7)
      of the expected value (7.18), and the "normal" connection has 29% (2.1)
      of the expected value.</p>

    
    <pre>% tcpdump -c 4000 -s 10000 -w ipsecdemo.bin
% uliscan ipsecdemo.bin

Uliscan 21 Dec 98
L=8 256 258560
Measuring file ipsecdemo.bin
Init done
Expected value for L=8 is 7.1836656
6.9396 --------------------------------------------------------
6.6177 -----------------------------------------------------
6.4100 ---------------------------------------------------
2.1101 -----------------
2.0838 -----------------
2.0983 -----------------</pre>

    <h2><a NAME="Caveat"></a>Caveat</h2>
    
    <p>This experiment shows that IPsec <i>does</i> seem to be distributing the
      payload data <i>uniformly</i>, as encryption should. However, the
      experiment described here <i>cannot</i>detect many possible flaws in a
      system (none of which do I have any evidence for). These include poor
      key generation or exchange, data or keys being visible to others, use of
      weak algorithms, kernel subversion, etc. Study the source; know the
      code.</p>
      
    <h2><a NAME="IPsec"></a>IPsec---Definition</h2>

    <p>Internet Protocol security extensions to IPv4; required for IPv6.  A
      protocol for negotiating encryption and authentication at the IP
      (host-to-host) level. SSL secures only one application socket; SSH
      secures only a login; PGP secures only a specified file or
      message. IPsec encrypts everything between two hosts.</p>
    
    <h2><a NAME="Installing IPsec"></a>Installing IPsec</h2>

    <p>Most of the modern versions of FreeBSD have IPsec support
	in their base source.  So you'll probably will need to
	include <i>IPSEC</i> option in your kernel config
	and, after kernel rebuild and reinstall, configure IPsec
	connections using <i>setkey</i> command.</p>
    

    <p>A comprehensive guide on running IPsec on FreeBSD is
      provided in <a
      href="http://www.freebsd.org/handbook/ipsec.html">FreeBSD
      Handbook</a>.

    <h2><a NAME="KERNELNAME"></a>usr/src/sys/i386/conf/KERNELNAME</h2>
    
    <p>This needs to be present in the kernel config file in order to be able
      to capture network data with <i>tcpdump</i>.
      Be sure to run <i>config</i> after adding this, and rebuild and
      reinstall.</p>

    <pre>device	bpf
</pre>

    <h2><a name="Maurer's Universal Statistical Test"></a>Maurer's Universal Statistical Test (for block
      size=8 bits)</h2>

        <p>You can find the same code at <a
          href="http://www.geocities.com/SiliconValley/Code/4704/uliscanc.txt">
          this link</a>.</p>

    <pre><![ CDATA [/*
  ULISCAN.c   ---blocksize of 8

  1 Oct 98
  1 Dec 98
  21 Dec 98       uliscan.c derived from ueli8.c

  This version has // comments removed for Sun cc

  This implements Ueli M Maurer's "Universal Statistical Test for Random
  Bit Generators" using L=8

  Accepts a filename on the command line; writes its results, with other
  info, to stdout.

  Handles input file exhaustion gracefully.

  Ref: J. Cryptology v 5 no 2, 1992 pp 89-105
  also on the web somewhere, which is where I found it.

  -David Honig
  honig@sprynet.com

  Usage:
  ULISCAN filename
  outputs to stdout
*/

#define L 8
#define V (1<<L)
#define Q (10*V)
#define K (100   *Q)
#define MAXSAMP (Q + K)

#include <stdio.h>
#include <math.h>

int main(argc, argv)
int argc;
char **argv;
{
  FILE *fptr;
  int i,j;
  int b, c;
  int table[V];
  double sum = 0.0;
  int iproduct = 1;
  int run;

  extern double   log(/* double x */);

  printf("Uliscan 21 Dec 98 \nL=%d %d %d \n", L, V, MAXSAMP);

  if (argc < 2) {
    printf("Usage: Uliscan filename\n");
    exit(-1);
  } else {
    printf("Measuring file %s\n", argv[1]);
  }

  fptr = fopen(argv[1],"rb");

  if (fptr == NULL) {
    printf("Can't find %s\n", argv[1]);
    exit(-1);
  }

  for (i = 0; i < V; i++) {
    table[i] = 0;
  }

  for (i = 0; i < Q; i++) {
    b = fgetc(fptr);
    table[b] = i;
  }

  printf("Init done\n");

  printf("Expected value for L=8 is 7.1836656\n");

  run = 1;

  while (run) {
    sum = 0.0;
    iproduct = 1;

    if (run)
      for (i = Q; run && i < Q + K; i++) {
        j = i;
        b = fgetc(fptr);

        if (b < 0)
          run = 0;

        if (run) {
          if (table[b] > j)
            j += K;

          sum += log((double)(j-table[b]));

          table[b] = i;
        }
      }

    if (!run)
      printf("Premature end of file; read %d blocks.\n", i - Q);

    sum = (sum/((double)(i - Q))) /  log(2.0);
    printf("%4.4f ", sum);

    for (i = 0; i < (int)(sum*8.0 + 0.50); i++)
      printf("-");

    printf("\n");

    /* refill initial table */
    if (0) {
      for (i = 0; i < Q; i++) {
        b = fgetc(fptr);
        if (b < 0) {
          run = 0;
        } else {
          table[b] = i;
        }
      }
    }
  }
}]]></pre>
  </body>
</html>


